[
    {
        "title": "All Ancestors of a Node in a Directed Acyclic Graph",
        "question_content": "You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\nReturn a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\nA node u is an ancestor of another node v if u can reach v via a set of edges.\n&nbsp;\nExample 1:\n\nInput: n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]\nOutput: [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Nodes 0, 1, and 2 do not have any ancestors.\n- Node 3 has two ancestors 0 and 1.\n- Node 4 has two ancestors 0 and 2.\n- Node 5 has three ancestors 0, 1, and 3.\n- Node 6 has five ancestors 0, 1, 2, 3, and 4.\n- Node 7 has four ancestors 0, 1, 2, and 3.\n\nExample 2:\n\nInput: n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nOutput: [[],[0],[0,1],[0,1,2],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Node 0 does not have any ancestor.\n- Node 1 has one ancestor 0.\n- Node 2 has two ancestors 0 and 1.\n- Node 3 has three ancestors 0, 1, and 2.\n- Node 4 has four ancestors 0, 1, 2, and 3.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 1000\n\t0 <= edges.length <= min(2000, n * (n - 1) / 2)\n\tedges[i].length == 2\n\t0 <= fromi, toi <= n - 1\n\tfromi != toi\n\tThere are no duplicate edges.\n\tThe graph is directed and acyclic.",
        "solutions": [
            {
                "id": 1821935,
                "title": "python3-java-c-simple-dfs-o-n-2",
                "content": "**Explanation**:\\n* DFS on each node `x`\\n* For every node `ch` that is found after node `x` in dfs, add `x` as parent of `ch`\\n\\n**Steps**:\\n* Record the direct children of each node in a graph. Can be implemented using nested vectors or hashmap of lists.\\n* Run DFS for each node in graph\\n* For every subsequent node that is found after dfs starting from x, add x as parent of subsequent node in ans\\n\\n*If dfs from x is like:*\\n\\n```\\n                       x\\n\\t\\t\\t\\t\\t  /  \\\\\\n\\t\\t\\t\\t\\t 3    5\\n\\t\\t\\t\\t\\t |    | \\\\\\n\\t\\t\\t\\t\\t 1    8  0 \\n\\t\\t\\t\\t\\t\\n```\\n*x is added as parent for 3, 5, 1, 8, 0*\\n\\n<iframe src=\"https://leetcode.com/playground/JQFvFjdu/shared\" frameBorder=\"0\" width=\"750\" height=\"400\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n                       x\\n\\t\\t\\t\\t\\t  /  \\\\\\n\\t\\t\\t\\t\\t 3    5\\n\\t\\t\\t\\t\\t |    | \\\\\\n\\t\\t\\t\\t\\t 1    8  0 \\n\\t\\t\\t\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822108,
                "title": "c-solution-plain-dfs-short-and-clean-code",
                "content": "Simple DFS\\nIdea is simple if you start from any node then the node that you will be visiting will have start node as an ancestor.\\nLet us understand with an example.\\nLet\\'s say i start from node 0 and i have visited node 1 node 3 and node 4 \\nso node 0 will be ancestor of all node 1,3 and 4\\n\\n* Ancestor Meaning: \" A node u is an ancestor of another node v if u can reach v via a set of edges\"\\n\\n* Node 0 is ancestor of which all nodes?\\n=> Start a DFS(/BFS) from node 0 as src, and all the reachable nodes will\\nalways have node 0 as an ancestor [from definition]\\n\\n* Node 1 is ancestor of which all nodes?\\n=> Start a DFS(/BFS) from node 1 as src, and all the reachable nodes will\\nalways have node 1 as an ancestor [from definition of ancestor]\\n\\n* Node 2 is .....?\\n=> Start a DFS(/BFS) from node 2, ....\\n\\n...\\n\\n* Node n is ancestor of which all nodes?\\n=> Start a DFS(/BFS) from node n as src , and all the reachable nodes will\\nalways have node n as an ancestor [from definition of ancestor]\\n\\n* Hence, you see that we will automatically have all the ancestors in\\nincreasing order.\\n\\n* TC:O(N*N) Since for each src node (i) we do a DFS(/BFS) of entire graph form (i) and check which nodes are reachable\\n\\n* SC:O(N) for DFS(/BFS) + O(N^N) for returning answer\\n\\nThank you @[tbne1905](https://leetcode.com/tbne1905/) for such a nice explanation.\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &graph,int i,int j,vector<vector<int>> &ans,vector<bool> &vis){\\n        vis[j]=true;\\n        for(auto &x:graph[j]){\\n            if(!vis[x]){\\n                ans[x].push_back(i);\\n                dfs(graph,i,x,ans,vis);\\n            }\\n            \\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> ans(n),graph(n);\\n        for(auto &v:edges){\\n            graph[v[0]].push_back(v[1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<bool> vis(n);\\n            dfs(graph,i,i,ans,vis);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nNow the `vis` array that we are using is an overhead to our code. So lets try to remove this.\\nYou wonder how we will remove it? right?\\nLets understand What\\'s happening .\\nIf we will not use `vis` array then the element for which we arleady added `starting node` as an ancestor we will be adding again and again if we keep visiting that node from some other path. Lets understand this with example.\\nif we start from 0 and visited 2 ,3 ,4.\\nso we have 0 as an ancestor for 2,3 and 4\\nnow lets assume we have a directed edge from 3 to 2 \\nso when we will go deeper in dfs then we will again visit 2 and we will put 0 as an ancestor of 2 again so we will be end up getting `[0,0]` so by using `vis` array we are removing this only so this can be removed by simple if logic\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &graph,int i,int j,vector<vector<int>> &ans){\\n        for(auto &x:graph[j]){\\n            if(ans[x].empty() || ans[x].back()!=i){\\n                ans[x].push_back(i);\\n                dfs(graph,i,x,ans);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans(n),graph(n);\\n        for(auto &v:edges){\\n            graph[v[0]].push_back(v[1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            dfs(graph,i,i,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**If you have any doubt ask in comment section ..I\\'ll be happy to help**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &graph,int i,int j,vector<vector<int>> &ans,vector<bool> &vis){\\n        vis[j]=true;\\n        for(auto &x:graph[j]){\\n            if(!vis[x]){\\n                ans[x].push_back(i);\\n                dfs(graph,i,x,ans,vis);\\n            }\\n            \\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> ans(n),graph(n);\\n        for(auto &v:edges){\\n            graph[v[0]].push_back(v[1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<bool> vis(n);\\n            dfs(graph,i,i,ans,vis);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &graph,int i,int j,vector<vector<int>> &ans){\\n        for(auto &x:graph[j]){\\n            if(ans[x].empty() || ans[x].back()!=i){\\n                ans[x].push_back(i);\\n                dfs(graph,i,x,ans);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans(n),graph(n);\\n        for(auto &v:edges){\\n            graph[v[0]].push_back(v[1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            dfs(graph,i,i,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821991,
                "title": "java-python-3-2-codes-topological-sort-dfs-w-brief-explanation-and-comments",
                "content": "**Topological Sort**\\n\\n1. Build graph from parent to kids, and compute in-degree for each node;\\n2. Use topological to get direct parent and all ancestors of the direct parent of each node;\\n\\n```java\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        // Build graph, and compute in degree.\\n        int[] inDegree = new int[n];\\n        Map<Integer, List<Integer>> parentToKids = new HashMap<>();\\n        for (int[] e : edges) {\\n            parentToKids.computeIfAbsent(e[0], l -> new ArrayList<>()).add(e[1]);\\n            ++inDegree[e[1]];\\n        }\\n        \\n        // 1. Use a list of sets to save ancestors \\n        // and to avoid duplicates.\\n        // 2. Use a Queue to save 0-in-degree nodes as\\n        // the starting nodes for topological sort.\\n        List<Set<Integer>> sets = new ArrayList<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < n; ++i) {\\n            sets.add(new HashSet<>());\\n            if (inDegree[i] == 0)\\n                q.offer(i);\\n        }\\n        \\n        // BFS to their neighbors and decrease \\n        // the in degrees, when reaching 0, add\\n        // it into queue;\\n        // During this procedure, get direct parent, add \\n        // all ancestors of direct parents\\' of each kid.\\n        while (!q.isEmpty()) {\\n            int parent = q.poll();\\n            for (int kid : parentToKids.getOrDefault(parent, Arrays.asList())) {\\n                sets.get(kid).add(parent);\\n                sets.get(kid).addAll(sets.get(parent));\\n                if (--inDegree[kid] == 0)\\n                    q.offer(kid);\\n            }\\n        }\\n        \\n        // Sort ancestors and put into return list. \\n        List<List<Integer>> ans = new ArrayList<>();\\n        for (Set<Integer> set : sets)\\n            ans.add(new ArrayList<>(new TreeSet<>(set)));\\n        return ans;\\n    }\\n```\\n```python\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n         \\n        # Build graph, compute in degree and\\n        # get direct parent for each node.   \\n        ans = [set() for _ in range(n)]\\n        in_degree = [0] * n\\n        parent_to_kids = defaultdict(set)\\n        for parent, kid in edges:\\n            ans[kid].add(parent)\\n            parent_to_kids[parent].add(kid)\\n            in_degree[kid] += 1\\n            \\n        # Use Topological sort to get direct parent\\'s all ancestors    \\n        dq = deque([u for u, degree in enumerate(in_degree) if degree == 0])\\n        while dq:\\n            parent = dq.popleft()\\n            for kid in parent_to_kids[parent]:\\n                ans[kid].update(ans[parent])\\n                in_degree[kid] -= 1\\n                if in_degree[kid] == 0:\\n                    dq.append(kid)\\n        return [sorted(s) for s in  ans]    \\n```\\n\\n----\\n\\n**DFS**\\n\\n**Q & A**\\n*Q1*: In the DFS approach how are we sorting the sublists?\\n*A1*: \\n1) The recursion sequence of the dfs method \\nand \\n2) the traversal sequence in the last for loop in the `getAncestors` method \\n\\nguarantee that the ancestor list is sorted during adding process.\\n\\nYou can print out the methods names and nodes number to verify it.\\n\\n----\\n\\n\\n1. Build graph from parent to kids, and save `n` empty list into return List `ans`; \\n2. Traverse all nodes; for each node, recurse to the lowest offspring; During recursion, add the ancestor into the corresponding ancestors list for each offspring;\\n3. The recursion terminates once the the ancestor list ends with current ancestor.\\n\\n```java\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> parentToKids = new HashMap<>();\\n        for (int[] e : edges) {\\n            parentToKids.computeIfAbsent(e[0], l -> new ArrayList<>()).add(e[1]);\\n        }\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            ans.add(new ArrayList<>());\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            dfs(i, i, ans, parentToKids);\\n        }\\n        return ans;\\n    }\\n    private void dfs(int ancestor, int kid, List<List<Integer>> ans, Map<Integer, List<Integer>> parentToKids) {\\n        List<Integer> ancestors = ans.get(kid);\\n        if (ancestors.isEmpty() || ancestors.get(ancestors.size() - 1) != ancestor) {\\n            if (ancestor != kid) {\\n                ancestors.add(ancestor);\\n            }\\n            for (int grandKid : parentToKids.getOrDefault(kid, Arrays.asList())) {\\n                dfs(ancestor, grandKid, ans, parentToKids);\\n            }\\n        }\\n    }\\n```\\n```python\\n   def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        \\n        def dfs(ancestor: int, kid: int) -> None:\\n            if not (ans[kid] and ans[kid][-1] == ancestor):\\n                if kid != ancestor:\\n                    ans[kid].append(ancestor)\\n                for grand_child in parent_to_kids[kid]:\\n                    dfs(ancestor, grand_child)\\n\\n        parent_to_kids = defaultdict(list)\\n        for parent, kid in edges:\\n            parent_to_kids[parent].append(kid)\\n        ans = [[] for _ in range(n)]\\n        for i in range(n):\\n            dfs(i, i)\\n        return ans\\n```\\n\\n**Analysis for both methods:**\\n\\nTime & space: `O(n ^ 2 + E)`, where `E = # of edges`.\\n\\n----\\n\\nPlease free feel to ask if you have any questions, and **Upovte** if it is helpful. Thanks.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        // Build graph, and compute in degree.\\n        int[] inDegree = new int[n];\\n        Map<Integer, List<Integer>> parentToKids = new HashMap<>();\\n        for (int[] e : edges) {\\n            parentToKids.computeIfAbsent(e[0], l -> new ArrayList<>()).add(e[1]);\\n            ++inDegree[e[1]];\\n        }\\n        \\n        // 1. Use a list of sets to save ancestors \\n        // and to avoid duplicates.\\n        // 2. Use a Queue to save 0-in-degree nodes as\\n        // the starting nodes for topological sort.\\n        List<Set<Integer>> sets = new ArrayList<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < n; ++i) {\\n            sets.add(new HashSet<>());\\n            if (inDegree[i] == 0)\\n                q.offer(i);\\n        }\\n        \\n        // BFS to their neighbors and decrease \\n        // the in degrees, when reaching 0, add\\n        // it into queue;\\n        // During this procedure, get direct parent, add \\n        // all ancestors of direct parents\\' of each kid.\\n        while (!q.isEmpty()) {\\n            int parent = q.poll();\\n            for (int kid : parentToKids.getOrDefault(parent, Arrays.asList())) {\\n                sets.get(kid).add(parent);\\n                sets.get(kid).addAll(sets.get(parent));\\n                if (--inDegree[kid] == 0)\\n                    q.offer(kid);\\n            }\\n        }\\n        \\n        // Sort ancestors and put into return list. \\n        List<List<Integer>> ans = new ArrayList<>();\\n        for (Set<Integer> set : sets)\\n            ans.add(new ArrayList<>(new TreeSet<>(set)));\\n        return ans;\\n    }\\n```\n```python\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n         \\n        # Build graph, compute in degree and\\n        # get direct parent for each node.   \\n        ans = [set() for _ in range(n)]\\n        in_degree = [0] * n\\n        parent_to_kids = defaultdict(set)\\n        for parent, kid in edges:\\n            ans[kid].add(parent)\\n            parent_to_kids[parent].add(kid)\\n            in_degree[kid] += 1\\n            \\n        # Use Topological sort to get direct parent\\'s all ancestors    \\n        dq = deque([u for u, degree in enumerate(in_degree) if degree == 0])\\n        while dq:\\n            parent = dq.popleft()\\n            for kid in parent_to_kids[parent]:\\n                ans[kid].update(ans[parent])\\n                in_degree[kid] -= 1\\n                if in_degree[kid] == 0:\\n                    dq.append(kid)\\n        return [sorted(s) for s in  ans]    \\n```\n```java\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> parentToKids = new HashMap<>();\\n        for (int[] e : edges) {\\n            parentToKids.computeIfAbsent(e[0], l -> new ArrayList<>()).add(e[1]);\\n        }\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            ans.add(new ArrayList<>());\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            dfs(i, i, ans, parentToKids);\\n        }\\n        return ans;\\n    }\\n    private void dfs(int ancestor, int kid, List<List<Integer>> ans, Map<Integer, List<Integer>> parentToKids) {\\n        List<Integer> ancestors = ans.get(kid);\\n        if (ancestors.isEmpty() || ancestors.get(ancestors.size() - 1) != ancestor) {\\n            if (ancestor != kid) {\\n                ancestors.add(ancestor);\\n            }\\n            for (int grandKid : parentToKids.getOrDefault(kid, Arrays.asList())) {\\n                dfs(ancestor, grandKid, ans, parentToKids);\\n            }\\n        }\\n    }\\n```\n```python\\n   def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        \\n        def dfs(ancestor: int, kid: int) -> None:\\n            if not (ans[kid] and ans[kid][-1] == ancestor):\\n                if kid != ancestor:\\n                    ans[kid].append(ancestor)\\n                for grand_child in parent_to_kids[kid]:\\n                    dfs(ancestor, grand_child)\\n\\n        parent_to_kids = defaultdict(list)\\n        for parent, kid in edges:\\n            parent_to_kids[parent].append(kid)\\n        ans = [[] for _ in range(n)]\\n        for i in range(n):\\n            dfs(i, i)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1823075,
                "title": "c-bfs-kahn-s-algorithm-explained-with-image-and-dry-run-topological-sort",
                "content": "\\n![image](https://assets.leetcode.com/users/images/2a09ff9f-1953-4502-aca9-db7e2b285cdc_1646514461.6325643.png)\\n\\n**n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]**\\n\\nNow **adjancecy list** will be:\\n0 -> 1,2,3,4\\n1 -> 2,3,4\\n2 -> 3,4\\n3 -> 4\\n4 ->\\n\\n**Indegree vector:**\\n0 -> 0\\n1 -> 1\\n2 -> 2\\n3 -> 3\\n4 -> 4\\n\\nSo queue will have just 0 while starting\\n**cur=0**\\n\\nso **\\'it\\'** will have the value **1,2,3,4** one by one\\nand st[it].insert(cur) will make the set look like\\n**0 -> \\n1 -> 0\\n2 -> 0\\n3 -> 0\\n4 -> 0**\\n\\nAfter **indegree[it]--**\\n**indegree array** will look like\\n0 -> 0\\n1 -> 0\\n2 -> 1\\n3 -> 2\\n4 -> 3\\n\\ntherefore 1 willl be pushed into the queue\\n\\nnow for next iteration **cur=1**\\n\\nso \\'it\\' will have the value 2,3,4 one by one\\nand **st[it].insert(cur)** will make the set look like\\n0 -> \\n1 -> 0\\n2 -> 0,1\\n3 -> 0,1\\n4 -> 0,1\\n\\nnow \\nfor(auto it2:st[cur])\\n     st[it].insert(it2);\\n\\t \\nThis will add parent of 1(ancestors of \\'it\\') in all the childnode of cur i.e 1\\nAlthough in this case, 0 is the direct parent of 2,3,4 so 0 is already present.\\n\\n**BUT\\nin a scenario where  ADJ LIST is\\n0 -> 1\\n1 -> 2,3,4\\n2 -> 3,4\\n3 -> 4\\n4 ->\\nthen \\nfor 2,3,4  0 would have also been added as an ancestor by the above 2 lines of code.**\\n\\nMoving on\\nAfter indegree[it]--\\nindegree array will look like\\n0 -> 0\\n1 -> 0\\n2 -> 0\\n3 -> 1\\n4 -> 2\\n\\n**therefore 2 willl be pushed into the queue\\nand iteration continues**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        //stores vector of adjacency list with each node having a vector of nodes to which it points \\n        vector<int> adj_list[n];   \\n        \\n        //stores indegree of each node\\n        vector<int> indegree(n);\\n        \\n        //creating adjacency list and updating indegrees\\n        for(int i=0;i<edges.size();++i)\\n        {\\n            adj_list[edges[i][0]].push_back(edges[i][1]);\\n            indegree[edges[i][1]]++;\\n        }\\n        \\n        //queue for BFS Traversal\\n        queue<int> q; \\n        \\n        //adding all the nodes with indegree==0 as they act as the source node\\n        for(int i=0;i<n;++i)\\n        {\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n        \\n        set<int> st[n]; //to avoid repetition of parent nodes \\n        while(!q.empty())\\n        {\\n            \\n            int cur=q.front(); \\n            q.pop();\\n            \\n            for(auto it:adj_list[cur])\\n            {\\n                //inserting immediate parent node to each child of current node\\n                st[it].insert(cur); \\n                \\n                //adds all the ancestors of the current node\\n                for(auto it2:st[cur])\\n                    st[it].insert(it2);\\n                 \\n                //adding to queue if indegree ==0\\n                indegree[it]--;\\n                if(indegree[it]==0)\\n                q.push(it);\\n            }\\n        }\\n        \\n        //to store ans\\n        vector<vector<int>> ans(n,vector<int>());\\n        \\n        //adding ancestors of each node to final ans vector\\n        for(int i=0;i<n;++i)\\n            ans[i]=vector<int>(st[i].begin(),st[i].end());\\n        \\n        \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        //stores vector of adjacency list with each node having a vector of nodes to which it points \\n        vector<int> adj_list[n];   \\n        \\n        //stores indegree of each node\\n        vector<int> indegree(n);\\n        \\n        //creating adjacency list and updating indegrees\\n        for(int i=0;i<edges.size();++i)\\n        {\\n            adj_list[edges[i][0]].push_back(edges[i][1]);\\n            indegree[edges[i][1]]++;\\n        }\\n        \\n        //queue for BFS Traversal\\n        queue<int> q; \\n        \\n        //adding all the nodes with indegree==0 as they act as the source node\\n        for(int i=0;i<n;++i)\\n        {\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n        \\n        set<int> st[n]; //to avoid repetition of parent nodes \\n        while(!q.empty())\\n        {\\n            \\n            int cur=q.front(); \\n            q.pop();\\n            \\n            for(auto it:adj_list[cur])\\n            {\\n                //inserting immediate parent node to each child of current node\\n                st[it].insert(cur); \\n                \\n                //adds all the ancestors of the current node\\n                for(auto it2:st[cur])\\n                    st[it].insert(it2);\\n                 \\n                //adding to queue if indegree ==0\\n                indegree[it]--;\\n                if(indegree[it]==0)\\n                q.push(it);\\n            }\\n        }\\n        \\n        //to store ans\\n        vector<vector<int>> ans(n,vector<int>());\\n        \\n        //adding ancestors of each node to final ans vector\\n        for(int i=0;i<n;++i)\\n            ans[i]=vector<int>(st[i].begin(),st[i].end());\\n        \\n        \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822414,
                "title": "dfs",
                "content": "It could be hard to find an efficient solution here. I tried DFS and got TLE, then tried BFS and it got AC. Later, I realized that we can make DFS efficient, and it is much simpler.\\n\\nWe first build the adjacency list `al`. Then, we start from each ancestor node ( `anc`), and traverse all children. For each child, we add `anc` to the list of ancestors.\\n\\nThat way, the list of ancestors will be naturally sorted.\\n\\n> Note: for each child, we can check if it\\'s visited by inspecting it\\'s last ancestor. We will get TLE if we do not check if the child has been visited and deduping list of ancestors later.\\n\\n**C++**\\n```cpp\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> res(n), al(n);\\n    function<void(int, int)> dfs = [&](int i, int anc){\\n        for (auto j : al[i])\\n            if (res[j].empty() || res[j].back() != anc) {\\n                res[j].push_back(anc);\\n                dfs(j, anc);    \\n            }\\n    };\\n    for (auto &e: edges)\\n        al[e[0]].push_back(e[1]);\\n    for (int i = 0; i < n; ++i)\\n        dfs(i, i);\\n    return res;    \\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n ^ 2). Traversing DAG from a node is O(n), and we do it for n nodes.\\n- Memory:  O(n ^ 2). We can have up to `n ^ 2` edges to store. Also, we need up to `n ^ 2` to store the result.",
                "solutionTags": [],
                "code": "```cpp\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> res(n), al(n);\\n    function<void(int, int)> dfs = [&](int i, int anc){\\n        for (auto j : al[i])\\n            if (res[j].empty() || res[j].back() != anc) {\\n                res[j].push_back(anc);\\n                dfs(j, anc);    \\n            }\\n    };\\n    for (auto &e: edges)\\n        al[e[0]].push_back(e[1]);\\n    for (int i = 0; i < n; ++i)\\n        dfs(i, i);\\n    return res;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1821981,
                "title": "topological-sort-cpp-solution",
                "content": "The idea is simple we can use topological sort .\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n\\t\\t\\n        vector<int>in(n,0);\\n        //we will create geraph first\\n\\t\\tfor(auto it : edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            in[it[1]]++;      //count of incoming edges\\n        }\\n\\t\\n        queue<int>q;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n\\t\\t\\t//We will push the edges ifirst which has zero incoming edges\\n            if(in[i] == 0)\\n                q.push(i);\\n        }\\n\\t\\t//there may be repeatation of node so we will use the set for unique value\\n\\t\\t\\n        vector<set<int>>ans(n);\\n        while(!q.empty()){\\n            int si = q.size();\\n            while(si--)\\n            {\\n                int top = q.front();\\n                for(int i : adj[top])\\n                {\\n\\t\\t\\t\\t//when we visit the node we will decrease the incoming egde count\\n                    in[i]--;\\n                     ans[i].insert(top);\\n\\t\\t\\t\\t\\t \\n                       if(in[i] == 0)\\n                           q.push(i);\\n                        for(auto j : ans[top])\\n                        {\\n                            ans[i].insert(j);\\n                        }\\n                    \\n                }\\n                q.pop();\\n            }\\n        }\\n        vector<vector<int>>res(n);\\n        for(int i=0; i<n; i++)\\n        {\\n            for(auto j : ans[i])\\n            {\\n                res[i].push_back(j);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n\\t\\t\\n        vector<int>in(n,0);\\n        //we will create geraph first\\n\\t\\tfor(auto it : edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            in[it[1]]++;      //count of incoming edges\\n        }\\n\\t\\n        queue<int>q;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n\\t\\t\\t//We will push the edges ifirst which has zero incoming edges\\n            if(in[i] == 0)\\n                q.push(i);\\n        }\\n\\t\\t//there may be repeatation of node so we will use the set for unique value\\n\\t\\t\\n        vector<set<int>>ans(n);\\n        while(!q.empty()){\\n            int si = q.size();\\n            while(si--)\\n            {\\n                int top = q.front();\\n                for(int i : adj[top])\\n                {\\n\\t\\t\\t\\t//when we visit the node we will decrease the incoming egde count\\n                    in[i]--;\\n                     ans[i].insert(top);\\n\\t\\t\\t\\t\\t \\n                       if(in[i] == 0)\\n                           q.push(i);\\n                        for(auto j : ans[top])\\n                        {\\n                            ans[i].insert(j);\\n                        }\\n                    \\n                }\\n                q.pop();\\n            }\\n        }\\n        vector<vector<int>>res(n);\\n        for(int i=0; i<n; i++)\\n        {\\n            for(auto j : ans[i])\\n            {\\n                res[i].push_back(j);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821952,
                "title": "c-brute-force-dfs",
                "content": "The core idea is just reverse the edges in the graph and then simply do dfs from every node and check how many  nodes that current node visits.\\n```\\nclass Solution {\\npublic:\\n    void dfs(unordered_map<int,vector<int>> &gr,vector<bool> &vis,int src){\\n        vis[src] = true;\\n        \\n        for(auto v:gr[src]){\\n            if(!vis[v]){\\n                dfs(gr,vis,v);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>>mp;\\n        \\n        for(auto i:edges){\\n            mp[i[1]].push_back(i[0]);\\n        }\\n        \\n        vector<vector<int>>ans;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            vector<bool>vis(n,false);\\n            vector<int>tmp;\\n            \\n            dfs(mp,vis,i);\\n            for(int j=0;j<n;j++){\\n                if(vis[j] && i!=j){\\n                    tmp.push_back(j);\\n                }\\n            }\\n            \\n            ans.push_back(tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(unordered_map<int,vector<int>> &gr,vector<bool> &vis,int src){\\n        vis[src] = true;\\n        \\n        for(auto v:gr[src]){\\n            if(!vis[v]){\\n                dfs(gr,vis,v);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>>mp;\\n        \\n        for(auto i:edges){\\n            mp[i[1]].push_back(i[0]);\\n        }\\n        \\n        vector<vector<int>>ans;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            vector<bool>vis(n,false);\\n            vector<int>tmp;\\n            \\n            dfs(mp,vis,i);\\n            for(int j=0;j<n;j++){\\n                if(vis[j] && i!=j){\\n                    tmp.push_back(j);\\n                }\\n            }\\n            \\n            ans.push_back(tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268897,
                "title": "c-brute-force-dfs-with-a-easy-trick",
                "content": "# Trick: \\n* While building the adjacency list built the graph in reverse order. i.e `from -> to` \\u274C but `to -> from` \\u2705\\n* So now the children\\'s become the ancestors.\\n* Now simply do DFS and get all the child nodes of each parent node.\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<vector<int>> &adj, vector<int> &curr, vector<bool> &vis)\\n    {\\n        vis[node] = true;\\n        \\n        for(int nbr : adj[node])\\n        {\\n            if(!vis[nbr])\\n            {\\n                curr.push_back(nbr);\\n                \\n                dfs(nbr, adj, curr, vis);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for(vector<int> &edge: edges)\\n        {\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<vector<int>> answer(n);\\n        \\n        for(int i=0; i<n; ++i)\\n        {\\n            vector<bool> vis(n, false);\\n            \\n            vector<int> curr;\\n            \\n            dfs(i, adj, curr, vis);\\n            \\n            sort(curr.begin(), curr.end());\\n            \\n            answer[i] = curr;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<vector<int>> &adj, vector<int> &curr, vector<bool> &vis)\\n    {\\n        vis[node] = true;\\n        \\n        for(int nbr : adj[node])\\n        {\\n            if(!vis[nbr])\\n            {\\n                curr.push_back(nbr);\\n                \\n                dfs(nbr, adj, curr, vis);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for(vector<int> &edge: edges)\\n        {\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<vector<int>> answer(n);\\n        \\n        for(int i=0; i<n; ++i)\\n        {\\n            vector<bool> vis(n, false);\\n            \\n            vector<int> curr;\\n            \\n            dfs(i, adj, curr, vis);\\n            \\n            sort(curr.begin(), curr.end());\\n            \\n            answer[i] = curr;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821948,
                "title": "java-topological-sort",
                "content": "```\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        \\n        List<TreeSet<Integer>> ancestorList = new ArrayList();\\n        List<List<Integer>> list = new ArrayList();\\n\\n        Queue<Integer> queue = new LinkedList();\\n        \\n        int degree[] = new int[n];\\n        ArrayList<Integer>[] connections = new ArrayList[n];\\n        \\n        for(int i = 0;i<n;i++){\\n            connections[i] = new ArrayList<Integer>();\\n            ancestorList.add(new TreeSet<Integer>());\\n        }\\n        \\n        for(int edge[]: edges){\\n           connections[edge[0]].add(edge[1]);\\n           degree[edge[1]]++;\\n        }\\n    \\n        for(int i = 0;i<n;i++){\\n            if(degree[i] == 0){\\n                queue.add(i);\\n            }\\n        }\\n        \\n     \\n        while(!queue.isEmpty()){\\n            \\n            int currNode = queue.poll();\\n            for(int node : connections[currNode]){\\n                ancestorList.get(node).addAll(new TreeSet(ancestorList.get(currNode)));\\n                ancestorList.get(node).add(currNode);\\n                \\n                degree[node]--;\\n                if(degree[node] == 0){\\n                    queue.add(node);\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        for(TreeSet<Integer> set : ancestorList){\\n            list.add(new ArrayList<Integer>(set));\\n        }\\n        \\n        return list;\\n        \\n        \\n        \\n    }",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        \\n        List<TreeSet<Integer>> ancestorList = new ArrayList();\\n        List<List<Integer>> list = new ArrayList();\\n\\n        Queue<Integer> queue = new LinkedList();\\n        \\n        int degree[] = new int[n];\\n        ArrayList<Integer>[] connections = new ArrayList[n];\\n        \\n        for(int i = 0;i<n;i++){\\n            connections[i] = new ArrayList<Integer>();\\n            ancestorList.add(new TreeSet<Integer>());\\n        }\\n        \\n        for(int edge[]: edges){\\n           connections[edge[0]].add(edge[1]);\\n           degree[edge[1]]++;\\n        }\\n    \\n        for(int i = 0;i<n;i++){\\n            if(degree[i] == 0){\\n                queue.add(i);\\n            }\\n        }\\n        \\n     \\n        while(!queue.isEmpty()){\\n            \\n            int currNode = queue.poll();\\n            for(int node : connections[currNode]){\\n                ancestorList.get(node).addAll(new TreeSet(ancestorList.get(currNode)));\\n                ancestorList.get(node).add(currNode);\\n                \\n                degree[node]--;\\n                if(degree[node] == 0){\\n                    queue.add(node);\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        for(TreeSet<Integer> set : ancestorList){\\n            list.add(new ArrayList<Integer>(set));\\n        }\\n        \\n        return list;\\n        \\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1822955,
                "title": "bfs-java-solution-with-explanation",
                "content": "**Explanation**\\n1. Using bfs, We start with the nodes that have an indegree of zero.\\n2. Once we process all the nodes with in degree of zero at the current level, we move to the next level.\\n3. We repeat the above process untill all the nodes are processed.\\n\\n**Algorithm**\\n1. Create an indegree counter array and adjacency map.\\n2. Add each node with indegree count of zero the the queue.\\n3. Pop the parent node that needs to be processed.\\n4. For the current parent, get all the children.\\n5. For each child, add all the ancestors of parent to the child list.\\n6. Add the current parent to the child list.\\n7. Decrement the indegree count of the child node since we processed the current *parent -> child* edge.\\n8. If the in degree count of child becomes zero, then no parents are left. we add it to the queue.\\n\\n**Example**\\nInput: [Image](https://assets.leetcode.com/users/images/ca8a3cdd-061d-4dd3-af5a-1884655fe7c3_1646510728.9197474.png)\\nMatrix representation: {0:[3,1],1:[3],2:[3,5,1],3:[],4:[3,5,2,0],5:[0,3,1]}\\nOutput: [[2,4,5],[0,2,4,5],[4],[0,1,2,4,5],[],[2,4]]\\n\\n```java\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<Set<Integer>> list = new ArrayList<>();\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int[] in = new int[n];\\n        \\n        // Initializing the path list & adjacency map.\\n        for(int i = 0; i < n; i++){\\n            list.add(new HashSet<>());\\n            map.put(i, new ArrayList<>());\\n        }\\n        \\n        // Processing all the edges. \\n        // For each edge add the child to adjacency matrix and incrment it\\'s indegree count.\\n        for(int[] edge: edges){\\n            int u = edge[0], v = edge[1];\\n            map.get(u).add(v);\\n            in[v]++;\\n        }\\n        \\n        // Intializing queue & add adding all nodes to with indegree count as zero to queue.\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i = 0; i < n; i++){\\n            if(in[i] == 0){\\n                q.add(i);\\n            }\\n        }\\n        \\n        // perform bfs traversal.\\n        // we add new node to the queue when its in degree becomes zero.\\n        while(!q.isEmpty()){\\n            int node = q.poll();\\n            for(int child: map.get(node)){\\n                list.get(child).addAll(list.get(node));\\n                list.get(child).add(node);\\n                in[child]--;\\n                if(in[child] == 0){\\n                    q.add(child);\\n                }\\n            }\\n        }\\n        \\n        // Convert the list into required format.\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(Set<Integer> s : list){\\n            result.add(new ArrayList<>(s));\\n            Collections.sort(result.get(result.size()-1));\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nplease upvote if this is simple & easy to understand/implement. Thanks :)",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<Set<Integer>> list = new ArrayList<>();\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int[] in = new int[n];\\n        \\n        // Initializing the path list & adjacency map.\\n        for(int i = 0; i < n; i++){\\n            list.add(new HashSet<>());\\n            map.put(i, new ArrayList<>());\\n        }\\n        \\n        // Processing all the edges. \\n        // For each edge add the child to adjacency matrix and incrment it\\'s indegree count.\\n        for(int[] edge: edges){\\n            int u = edge[0], v = edge[1];\\n            map.get(u).add(v);\\n            in[v]++;\\n        }\\n        \\n        // Intializing queue & add adding all nodes to with indegree count as zero to queue.\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i = 0; i < n; i++){\\n            if(in[i] == 0){\\n                q.add(i);\\n            }\\n        }\\n        \\n        // perform bfs traversal.\\n        // we add new node to the queue when its in degree becomes zero.\\n        while(!q.isEmpty()){\\n            int node = q.poll();\\n            for(int child: map.get(node)){\\n                list.get(child).addAll(list.get(node));\\n                list.get(child).add(node);\\n                in[child]--;\\n                if(in[child] == 0){\\n                    q.add(child);\\n                }\\n            }\\n        }\\n        \\n        // Convert the list into required format.\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(Set<Integer> s : list){\\n            result.add(new ArrayList<>(s));\\n            Collections.sort(result.get(result.size()-1));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822053,
                "title": "reverse-all-edges-and-dfs-from-every-node",
                "content": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        graph = {}\\n        for a, b in edges:\\n            graph[b] = graph.get(b, []) + [a]\\n        op = [[] for i in range(n)]\\n        for a in graph:\\n            visited = set()\\n            paths = [a]\\n            while len(paths) > 0:\\n                curr = paths.pop()\\n                for b in graph.get(curr, []):\\n                    if b not in visited:\\n                        visited.add(b)\\n                        paths.append(b)\\n            op[a] = sorted(visited)\\n        return op\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        graph = {}\\n        for a, b in edges:\\n            graph[b] = graph.get(b, []) + [a]\\n        op = [[] for i in range(n)]\\n        for a in graph:\\n            visited = set()\\n            paths = [a]\\n            while len(paths) > 0:\\n                curr = paths.pop()\\n                for b in graph.get(curr, []):\\n                    if b not in visited:\\n                        visited.add(b)\\n                        paths.append(b)\\n            op[a] = sorted(visited)\\n        return op\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822035,
                "title": "c-dfs-with-comments-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>> &graph, vector<vector<int>> &res, vector<bool> &vis, int start, int store) {\\n\\t\\t// mark the current node as visited to not reach it again\\n        vis[start] = true;\\n\\t\\t\\n\\t\\t// iterate over all the neighbours of start node\\n\\t\\t// and if it is not visited, add it to the result list\\n\\t\\t// make a recursive call making the current node as start \\n        for (int node : graph[start]) {\\n            if (!vis[node]) {\\n                res[node].push_back(store);\\n                dfs(graph, res, vis, node, store);\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        // converting the edge list into an adjacency list\\n        vector<vector<int>> graph(n);\\n        for (auto &i : edges) {\\n            graph[i[0]].push_back(i[1]);\\n        }\\n        \\n        // here we iterate over all the nodes and check upto which nodes we can reach from the current node\\n        // for example, start from 0 and check upto which nodes we can reach from 0\\n        // when you reach a new node looping through the neighbours, add 0 to the result list at the index of the reached node\\n        // so as to mention that we can reach this node from 0\\n        vector<vector<int>> res(n);\\n        for (int i = 0; i < n; ++i) {\\n            vector<bool> visited(n);\\n\\t\\t\\t// mark the current node as visited to not reach it again\\n            visited[i] = true;\\n            dfs(graph, res, visited, i, i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>> &graph, vector<vector<int>> &res, vector<bool> &vis, int start, int store) {\\n\\t\\t// mark the current node as visited to not reach it again\\n        vis[start] = true;\\n\\t\\t\\n\\t\\t// iterate over all the neighbours of start node\\n\\t\\t// and if it is not visited, add it to the result list\\n\\t\\t// make a recursive call making the current node as start \\n        for (int node : graph[start]) {\\n            if (!vis[node]) {\\n                res[node].push_back(store);\\n                dfs(graph, res, vis, node, store);\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        // converting the edge list into an adjacency list\\n        vector<vector<int>> graph(n);\\n        for (auto &i : edges) {\\n            graph[i[0]].push_back(i[1]);\\n        }\\n        \\n        // here we iterate over all the nodes and check upto which nodes we can reach from the current node\\n        // for example, start from 0 and check upto which nodes we can reach from 0\\n        // when you reach a new node looping through the neighbours, add 0 to the result list at the index of the reached node\\n        // so as to mention that we can reach this node from 0\\n        vector<vector<int>> res(n);\\n        for (int i = 0; i < n; ++i) {\\n            vector<bool> visited(n);\\n\\t\\t\\t// mark the current node as visited to not reach it again\\n            visited[i] = true;\\n            dfs(graph, res, visited, i, i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821957,
                "title": "ancestors-easy-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[],int s,vector<bool>& viz){\\n        viz[s]=true;\\n        for(auto x:adj[s]){\\n            if(!viz[x]){\\n                dfs(adj,x,viz);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            adj[u].push_back(v);\\n        }\\n        \\n        vector<vector<int>> rez(n);\\n        for(int i=0;i<n;i++){\\n            vector<bool>viz(n,false);\\n            dfs(adj,i,viz);\\n            \\n            for(int j=0;j<n;j++){\\n                if(viz[j] && i!=j){\\n                    rez[j].push_back(i);\\n                }\\n            }\\n        }\\n        return rez;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[],int s,vector<bool>& viz){\\n        viz[s]=true;\\n        for(auto x:adj[s]){\\n            if(!viz[x]){\\n                dfs(adj,x,viz);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            adj[u].push_back(v);\\n        }\\n        \\n        vector<vector<int>> rez(n);\\n        for(int i=0;i<n;i++){\\n            vector<bool>viz(n,false);\\n            dfs(adj,i,viz);\\n            \\n            for(int j=0;j<n;j++){\\n                if(viz[j] && i!=j){\\n                    rez[j].push_back(i);\\n                }\\n            }\\n        }\\n        return rez;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333862,
                "title": "python3-solved-using-topo-sort-kahn-algo-with-queue-bfs",
                "content": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        #Use Kahn\\'s algorithm of toposort using a queue and bfs!\\n        graph = [[] for _ in range(n)]\\n        indegrees = [0] * n\\n        \\n        #Time: O(n^2)\\n        #Space: O(n^2 + n + n) -> O(n^2)\\n        \\n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\\n        for edge in edges:\\n            src, dest = edge[0], edge[1]\\n            graph[src].append(dest)\\n            indegrees[dest] += 1\\n        \\n        \\n        queue = deque()\\n        ans = [set() for _ in range(n)]\\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\\n        for i in range(len(indegrees)):\\n            if(indegrees[i] == 0):\\n                queue.append(i)\\n        \\n        #Kahn\\'s algorithm initiation!\\n        #while loop will run for each and every node in graph!\\n        #in worst case, adjacency list for one particular node may contain all other vertices!\\n        while queue:\\n            cur = queue.pop()\\n            \\n            #for each neighbor\\n            for neighbor in graph[cur]:\\n                #current node is ancestor to each and every neighboring node!\\n                ans[neighbor].add(cur)\\n                #every ancestor of current node is also an ancestor to the neighboring node!\\n                ans[neighbor].update(ans[cur])\\n                indegrees[neighbor] -= 1\\n                if(indegrees[neighbor] == 0):\\n                    queue.append(neighbor)\\n        \\n        #at the end, we should have set of ancestors for each and every node!\\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\\n        ans = [(sorted(list(s))) for s in ans]\\n        return ans",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        #Use Kahn\\'s algorithm of toposort using a queue and bfs!\\n        graph = [[] for _ in range(n)]\\n        indegrees = [0] * n\\n        \\n        #Time: O(n^2)\\n        #Space: O(n^2 + n + n) -> O(n^2)\\n        \\n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\\n        for edge in edges:\\n            src, dest = edge[0], edge[1]\\n            graph[src].append(dest)\\n            indegrees[dest] += 1\\n        \\n        \\n        queue = deque()\\n        ans = [set() for _ in range(n)]\\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\\n        for i in range(len(indegrees)):\\n            if(indegrees[i] == 0):\\n                queue.append(i)\\n        \\n        #Kahn\\'s algorithm initiation!\\n        #while loop will run for each and every node in graph!\\n        #in worst case, adjacency list for one particular node may contain all other vertices!\\n        while queue:\\n            cur = queue.pop()\\n            \\n            #for each neighbor\\n            for neighbor in graph[cur]:\\n                #current node is ancestor to each and every neighboring node!\\n                ans[neighbor].add(cur)\\n                #every ancestor of current node is also an ancestor to the neighboring node!\\n                ans[neighbor].update(ans[cur])\\n                indegrees[neighbor] -= 1\\n                if(indegrees[neighbor] == 0):\\n                    queue.append(neighbor)\\n        \\n        #at the end, we should have set of ancestors for each and every node!\\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\\n        ans = [(sorted(list(s))) for s in ans]\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1824328,
                "title": "simple-bfs-solution",
                "content": "**Idea?**\\n* Consider every node as the source point and start breadth first search from that node.\\n* Whatever, the node that will be visited during the path have the ancestors as source node.\\n\\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(N^2)\\n    // Space Complexity:- O(N^2)\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        vector<vector<int>> ans(n);\\n        for(auto& edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            vector<bool> vis(n);\\n            queue<int> q;\\n            \\n            q.push(i);\\n            vis[i] = true;\\n            \\n            while(!q.empty()){\\n                int v = q.front();\\n                q.pop();\\n                \\n                for(auto& u:adj[v]){\\n                    if(!vis[u]){\\n                        q.push(u);\\n                        vis[u] = true;\\n                        ans[u].push_back(i);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(N^2)\\n    // Space Complexity:- O(N^2)\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        vector<vector<int>> ans(n);\\n        for(auto& edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            vector<bool> vis(n);\\n            queue<int> q;\\n            \\n            q.push(i);\\n            vis[i] = true;\\n            \\n            while(!q.empty()){\\n                int v = q.front();\\n                q.pop();\\n                \\n                for(auto& u:adj[v]){\\n                    if(!vis[u]){\\n                        q.push(u);\\n                        vis[u] = true;\\n                        ans[u].push_back(i);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822374,
                "title": "java-dfs-parent-graph-treeset-easy-to-understand",
                "content": "**Solution:**\\n```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<Integer>[] parents = new ArrayList[n];\\n        TreeSet<Integer>[] ancestors = new TreeSet[n];\\n        for (int i = 0; i < n; ++ i) {\\n            parents[i] = new ArrayList<>();\\n        }\\n        \\n        for (int[] edge: edges) {\\n            parents[edge[1]].add(edge[0]);\\n        }\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        for (int i = 0; i < n; ++ i) {\\n            if (ancestors[i] == null) {\\n                dfs(i, parents, ancestors);\\n            }\\n            \\n            result.add(new ArrayList<>(ancestors[i]));\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public void dfs(int node, List<Integer>[] parents, TreeSet<Integer>[] ancestors) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int parent: parents[node]) {\\n            set.add(parent);\\n            if (ancestors[parent] == null) {\\n                dfs(parent, parents, ancestors);\\n            }\\n            set.addAll(ancestors[parent]);\\n        }\\n        \\n        ancestors[node] = set;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<Integer>[] parents = new ArrayList[n];\\n        TreeSet<Integer>[] ancestors = new TreeSet[n];\\n        for (int i = 0; i < n; ++ i) {\\n            parents[i] = new ArrayList<>();\\n        }\\n        \\n        for (int[] edge: edges) {\\n            parents[edge[1]].add(edge[0]);\\n        }\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        for (int i = 0; i < n; ++ i) {\\n            if (ancestors[i] == null) {\\n                dfs(i, parents, ancestors);\\n            }\\n            \\n            result.add(new ArrayList<>(ancestors[i]));\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public void dfs(int node, List<Integer>[] parents, TreeSet<Integer>[] ancestors) {\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int parent: parents[node]) {\\n            set.add(parent);\\n            if (ancestors[parent] == null) {\\n                dfs(parent, parents, ancestors);\\n            }\\n            set.addAll(ancestors[parent]);\\n        }\\n        \\n        ancestors[node] = set;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822012,
                "title": "idea-explained-and-optimization-dfs-based-approach-c-clean-code",
                "content": "**Intuition :**\\n\\n* Idea here is to store nodes in adjacency list by **reversing edges.** \\n\\n\\t* i.e if we have **[ u -> v ],** then we store this in adjacency list as  **[ v -> u ]**\\n* In simple terms instead of connecting **parent -> child**, connect **child -> parent**\\n* So, in this way we can easily get all the ancestors of a node by simply doing **DFS**.\\n* Then perform simple DFS for each node from 0 to n-1.\\n* And in DFS call we store the nodes that are reachable from source node.\\n* In the end we sort all reachable nodes as mentioned in problem.\\n\\n# Code :\\n\\n```\\nclass Solution {\\nprivate:\\n\\tvoid dfs(vector<vector<int>>& adj, vector<vector<int>>& res, vector<bool>& vis, int node, int source) {\\n        vis[node] = true;\\n\\t\\t// If current node is not source then \\n\\t\\t// add current node to list of ancestor of source node\\n        if(node != source) \\n            res[source].push_back(node);\\n\\t\\t\\n\\t\\t// Iterate over adjacent nodes and perform dfs \\n\\t\\t// to include ancestors \\n        for(auto& adjnode : adj[node]) {\\n            if(!vis[adjnode]) {\\n                dfs(adj, res, vis, adjnode, source);\\n            }\\n        }\\n    }\\n\\t\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> adj(n); // adjacency list\\n        vector<vector<int>> res(n); // List to store all ancestors of each node\\n        \\n        for(auto& edge : edges) {\\n\\t\\t\\t// Connect child -> parent\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n\\t\\t// Iterate over all node to get their ancestors\\n        for(int i=0; i<n; i++) {\\n            vector<bool> vis(n, false);\\n            dfs(adj, res, vis, i, i);\\n        }\\n        \\n\\t\\t// In the end, sort list of ancestors of each node\\n        for(int i=0; i<n; i++) {\\n            sort(begin(res[i]), end(res[i]));\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(N * N + N * (k log k))` , \\n\\t* N -> number of nodes\\n\\t* k -> average number of ancestors of each node \\n\\n* Space : `~ O(N * N)`\\n\\n-------------------------------\\n\\nNote : We can optimize this certainly by skipping sorting step. And store ancestors of each node in such a way that it remains in sorted order.\\n\\n------------------------------------\\n\\n**Optimization :**\\n\\n* Idea here is to build adjacency list such that we connect **parent -> child**.\\n\\n* Then iterate over all nodes, considering it as a **parent node**, and perform DFS.\\n* Now, in DFS call, we pass **parent node**, and it would also be ancestor of all its adjacent nodes.\\n\\t* that we can reach from **parent node.**\\n* In this way we can get ancestors in sorted order, since we start from 0 to n.\\n\\n# Code : \\n\\n```\\nclass Solution {\\nprivate:\\n\\tvoid dfs(vector<vector<int>>& adj, vector<vector<int>>& res, vector<bool>& vis, int node, int parent) {\\n        vis[node] = true;\\n\\t\\n        for(auto& adjnode : adj[node]) {\\n            if(!vis[adjnode]) {\\n                res[adjnode].push_back(parent);\\n                dfs(adj, res, vis, adjnode, parent);\\n            }\\n        }\\n    }\\n\\t\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> adj(n); // adjacency list\\n        vector<vector<int>> res(n); // List to store all ancestors of each node\\n        \\n        for(auto& edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            vector<bool> vis(n, false);\\n            dfs(adj, res, vis, i, i);\\n        }      \\n\\t\\treturn res;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(N * N)` , \\n\\t* N -> number of nodes\\n\\n* Space : `~ O(N * N)`\\n\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\tvoid dfs(vector<vector<int>>& adj, vector<vector<int>>& res, vector<bool>& vis, int node, int source) {\\n        vis[node] = true;\\n\\t\\t// If current node is not source then \\n\\t\\t// add current node to list of ancestor of source node\\n        if(node != source) \\n            res[source].push_back(node);\\n\\t\\t\\n\\t\\t// Iterate over adjacent nodes and perform dfs \\n\\t\\t// to include ancestors \\n        for(auto& adjnode : adj[node]) {\\n            if(!vis[adjnode]) {\\n                dfs(adj, res, vis, adjnode, source);\\n            }\\n        }\\n    }\\n\\t\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> adj(n); // adjacency list\\n        vector<vector<int>> res(n); // List to store all ancestors of each node\\n        \\n        for(auto& edge : edges) {\\n\\t\\t\\t// Connect child -> parent\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n\\t\\t// Iterate over all node to get their ancestors\\n        for(int i=0; i<n; i++) {\\n            vector<bool> vis(n, false);\\n            dfs(adj, res, vis, i, i);\\n        }\\n        \\n\\t\\t// In the end, sort list of ancestors of each node\\n        for(int i=0; i<n; i++) {\\n            sort(begin(res[i]), end(res[i]));\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n\\tvoid dfs(vector<vector<int>>& adj, vector<vector<int>>& res, vector<bool>& vis, int node, int parent) {\\n        vis[node] = true;\\n\\t\\n        for(auto& adjnode : adj[node]) {\\n            if(!vis[adjnode]) {\\n                res[adjnode].push_back(parent);\\n                dfs(adj, res, vis, adjnode, parent);\\n            }\\n        }\\n    }\\n\\t\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> adj(n); // adjacency list\\n        vector<vector<int>> res(n); // List to store all ancestors of each node\\n        \\n        for(auto& edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            vector<bool> vis(n, false);\\n            dfs(adj, res, vis, i, i);\\n        }      \\n\\t\\treturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821934,
                "title": "python-3-topological-sort-o-v-e",
                "content": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        \\n        in_degree = defaultdict(int)\\n        graph = defaultdict(set)\\n        \\n        for A, B in edges:\\n            graph[A].add(B)\\n            in_degree[B] += 1\\n        \\n        q = deque()\\n        \\n        for i in range(n):\\n            if i not in in_degree:\\n                q.append(i)\\n            \\n        ans = [set() for i in range(n)] \\n\\n        while q:\\n            node = q.popleft()\\n            \\n            for nei in graph[node]:\\n\\n                ans[nei].update(ans[node])  # my ancestors are your ancestors\\n                ans[nei].add(node)          # i\\'m your ancestor now, boy\\n                \\n                in_degree[nei] -= 1\\n                if in_degree[nei] == 0:\\n                    q.append(nei)\\n        for i in range(len(ans)):\\n            ans[i] = sorted(list(ans[i]))\\n        return ans    \\n            \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        \\n        in_degree = defaultdict(int)\\n        graph = defaultdict(set)\\n        \\n        for A, B in edges:\\n            graph[A].add(B)\\n            in_degree[B] += 1\\n        \\n        q = deque()\\n        \\n        for i in range(n):\\n            if i not in in_degree:\\n                q.append(i)\\n            \\n        ans = [set() for i in range(n)] \\n\\n        while q:\\n            node = q.popleft()\\n            \\n            for nei in graph[node]:\\n\\n                ans[nei].update(ans[node])  # my ancestors are your ancestors\\n                ans[nei].add(node)          # i\\'m your ancestor now, boy\\n                \\n                in_degree[nei] -= 1\\n                if in_degree[nei] == 0:\\n                    q.append(nei)\\n        for i in range(len(ans)):\\n            ans[i] = sorted(list(ans[i]))\\n        return ans    \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 2054706,
                "title": "c-easy-toposort-solution-clean-code-explained-with-comments",
                "content": "***The main intuition behind the approach is that, we can find the ancestor of a node only if we know the parents of the current node. We start from the node having no parent so that the ancestor of the node is also empty, then the children of that node will have their parent and the parent of parent and this will go so on***\\n\\n***This gives the clue that, we need to first analyse the parent of the node and then we need to analyse the node, so we thought of using toposort, the toposort works in such a manner that, the parent of current node will have occured before the current node. Means while finding the ancestor of the current node, we must have found the ancestor of its parent node, hence we will put the parent into the ancestor of current node and the ancestor array of its parents in the current node answer***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    //here we are finding the toposort \\n    void findtoposort(int node, vector<int>&vis, unordered_map<int,vector<int>>&adj, stack<int>&stk){\\n        vis[node] = 1;\\n        \\n        for(int x: adj[node]){\\n            if(!vis[x]){\\n                findtoposort(x, vis, adj,stk);\\n            }\\n        }\\n        \\n        stk.push(node);\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        //this is the ancestor ans which we need to return \\n        vector<vector<int>>ans(n);\\n        //here is the visited array for finding the toposort\\n        vector<int>vis(n,0);\\n        //here is the stack for containing the elements of the DAG in topological sort manner\\n        stack<int>stk;\\n        \\n        //here we have created adjancency list in the mapped form as the node and then its children\\n        unordered_map<int, vector<int>>adj;\\n        //inserting children into the adjencency list\\n        for(int i = 0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n        }\\n        \\n        //here we are finding the toposort of the elements of the graph\\n        for(int i = 0; i<n; i++){\\n            if(!vis[i]){\\n                findtoposort(i, vis, adj, stk);\\n            }\\n        }\\n        \\n        //here is the map to store the parents of a node\\n        //first is the node and second is the set containing all the parents of the current node\\n        unordered_map<int, set<int>>mp;\\n        //inserting parents into the node\\n        for(int i = 0; i<edges.size(); i++){\\n            mp[edges[i][1]].insert(edges[i][0]);\\n        }\\n        \\n        //here we are traversing the stack in topological sort manner so that answer can be evaluated\\n        while(stk.empty()==false){\\n            int currnode = stk.top();\\n            stk.pop();\\n            set<int>s;\\n            \\n            for(int x: mp[currnode]){\\n                s.insert(x);\\n                s.insert(ans[x].begin(), ans[x].end());\\n            }\\n            \\n            vector<int>currvec(s.begin(), s.end());\\n            ans[currnode] = currvec;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //here we are finding the toposort \\n    void findtoposort(int node, vector<int>&vis, unordered_map<int,vector<int>>&adj, stack<int>&stk){\\n        vis[node] = 1;\\n        \\n        for(int x: adj[node]){\\n            if(!vis[x]){\\n                findtoposort(x, vis, adj,stk);\\n            }\\n        }\\n        \\n        stk.push(node);\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        //this is the ancestor ans which we need to return \\n        vector<vector<int>>ans(n);\\n        //here is the visited array for finding the toposort\\n        vector<int>vis(n,0);\\n        //here is the stack for containing the elements of the DAG in topological sort manner\\n        stack<int>stk;\\n        \\n        //here we have created adjancency list in the mapped form as the node and then its children\\n        unordered_map<int, vector<int>>adj;\\n        //inserting children into the adjencency list\\n        for(int i = 0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n        }\\n        \\n        //here we are finding the toposort of the elements of the graph\\n        for(int i = 0; i<n; i++){\\n            if(!vis[i]){\\n                findtoposort(i, vis, adj, stk);\\n            }\\n        }\\n        \\n        //here is the map to store the parents of a node\\n        //first is the node and second is the set containing all the parents of the current node\\n        unordered_map<int, set<int>>mp;\\n        //inserting parents into the node\\n        for(int i = 0; i<edges.size(); i++){\\n            mp[edges[i][1]].insert(edges[i][0]);\\n        }\\n        \\n        //here we are traversing the stack in topological sort manner so that answer can be evaluated\\n        while(stk.empty()==false){\\n            int currnode = stk.top();\\n            stk.pop();\\n            set<int>s;\\n            \\n            for(int x: mp[currnode]){\\n                s.insert(x);\\n                s.insert(ans[x].begin(), ans[x].end());\\n            }\\n            \\n            vector<int>currvec(s.begin(), s.end());\\n            ans[currnode] = currvec;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854153,
                "title": "c-easy-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void bfs(vector<vector<int>> &adj_list, vector<vector<bool>> &visited, int v)\\n    {\\n        queue<int> q;\\n        q.push(v);\\n        \\n        while(!q.empty()){\\n            auto temp = q.front();\\n            q.pop();\\n            \\n            for(auto j : adj_list[temp]){\\n                if(visited[v][j] == false){\\n                    visited[v][j] = true;\\n                    q.push(j);\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj_list(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            adj_list[edges[i][0]].push_back(edges[i][1]);\\n        }\\n        \\n        vector<vector<bool>> visited(n,vector<bool>(n,false));\\n        \\n        for(int i=0;i<n;i++){\\n            bfs(adj_list, visited, i);\\n        }\\n        \\n        vector<vector<int>> ans(n);\\n        \\n        for(int i=0;i<visited.size();i++){\\n            for(int j=0;j<visited[i].size();j++){\\n                if(visited[i][j] == true){\\n                    ans[j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void bfs(vector<vector<int>> &adj_list, vector<vector<bool>> &visited, int v)\\n    {\\n        queue<int> q;\\n        q.push(v);\\n        \\n        while(!q.empty()){\\n            auto temp = q.front();\\n            q.pop();\\n            \\n            for(auto j : adj_list[temp]){\\n                if(visited[v][j] == false){\\n                    visited[v][j] = true;\\n                    q.push(j);\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj_list(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            adj_list[edges[i][0]].push_back(edges[i][1]);\\n        }\\n        \\n        vector<vector<bool>> visited(n,vector<bool>(n,false));\\n        \\n        for(int i=0;i<n;i++){\\n            bfs(adj_list, visited, i);\\n        }\\n        \\n        vector<vector<int>> ans(n);\\n        \\n        for(int i=0;i<visited.size();i++){\\n            for(int j=0;j<visited[i].size();j++){\\n                if(visited[i][j] == true){\\n                    ans[j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832477,
                "title": "javascript-easy-to-understand-3-solutions-detailed-explanation",
                "content": "## Base Information\\n\\nIt\\'s a DAG, and we have all the edges, which means we also have these information:\\n- the indegree for each node, let\\'s call them array `indegrees`\\n- the outdegree for each node, let\\'s call them array `outdegrees`\\n- all the nodes that link to current node, let\\'s call them array `inEdges`\\n- all the nodes that current node linked to, let\\'s call them array `outEdges`\\n\\nBased on these information, let\\'s move into the 3 solutions.\\n\\n## BFS\\n\\nLet\\'s see what is a node with 0 indegree.\\n\\n![image](https://assets.leetcode.com/users/images/f91f9cd8-58c0-4b5b-8064-fc8ac072c803_1646791992.766624.png)\\n\\nWith this test case, it\\'s the nodes `0`, `1` and `2` at first. And since there\\'s no extra income edges, which means we\\'ve get the final result for these nodes already. Let\\'s call them the level 0.\\n\\nThen, for all the out edges from level 0, which are `3`, `4` and `7`, let\\'s update their indegree. Take the node `3` as an example:\\n- the first income edge is `[0, 3]`, so we could add all the income edges of `0` into the income edges of `3`, which is merging `inEdges[0]` into `inEdges[3]`. After this, we\\'ve handled this edge fine, so we could do the `--indegree[3]` to assume there\\'s no such edge.\\n- then, we do the same things to the second edge `[1, 3]`.\\n- finally, the node `3` is a new node with 0 indegree.\\n\\nLet\\'s finish all the things for the edges `3`, `4` and `7`. And then, we could get a new batch of nodes with 0 indegree, which are `3` and `4`. Let\\'s call them the level 1.\\n\\nThen, for all the out edges from level 1, we continue to do the same things above. We can get the level 2, level 3 and so on. Until there\\'s no node for the next level, which means we get all the results we want.\\n\\nFinally, let\\'s look back the whole strategy, it\\'s just like we get deeper level by level from the start. So, it\\'s a classic BFS strategy.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\n// BFS\\nconst getAncestors = (n, edges) => {\\n  const indegrees = new Uint16Array(n);\\n  const inEdges = Array.from({ length: n }, () => new Set());\\n  const outEdges = Array.from({ length: n }, () => []);\\n  let curLevel = [];\\n  // init information\\n  for (const [from, to] of edges) {\\n    ++indegrees[to];\\n    inEdges[to].add(from);\\n    outEdges[from].push(to);\\n  }\\n  // init level 0\\n  for (let i = 0; i < n; ++i) {\\n    indegrees[i] === 0 && curLevel.push(i);\\n  }\\n  // geting deeper level by level\\n  while (curLevel.length) {\\n    const next = [];\\n    for (const i of curLevel) {\\n      for (const out of outEdges[i]) {\\n        --indegrees[out] === 0 && next.push(out);\\n        for (const edge of inEdges[i]) {\\n          inEdges[out].add(edge);\\n        }\\n      }\\n    }\\n    curLevel = next;\\n  }\\n  return inEdges.map(set => Array.from(set).sort((a, b) => a - b));\\n};\\n```\\n\\n## DFS - bottom top\\n\\nLet\\'s see how to get the final result for one node.\\n\\n![image](https://assets.leetcode.com/users/images/f91f9cd8-58c0-4b5b-8064-fc8ac072c803_1646791992.766624.png)\\n\\nWith this test case again, let\\'s take node `5` as an example:\\n- what\\'s the final result for node `5`\\n\\t- it comes from node `3` and the final result of node `3`\\n\\t- what\\'s the final result for node `3`\\n\\t\\t- it comes from node `0`, the final result of node `0`, node `1`, and the final result of node `1`\\n\\t\\t\\t- what\\'s the final result for node `0`\\n\\t\\t\\t\\t- empty\\n\\t\\t\\t- what\\'s the final result for node `1`\\n\\t\\t\\t\\t- empty\\n\\nWe could find out that we are dealing with the same kind of problem for different node again and again, until meets the end condition. That\\'s a classic recursive strategy.\\n\\nSo, for the whole problem, we just need to deal with all the leaf nodes as the start of recursion, then we could get the final answer.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\n// DFS - bottom top\\nconst dfs = (inEdges, idx, finished) => {\\n  if (finished[idx]) return; // avoid repeat calculation\\n  if (inEdges[idx].size === 0) return; // end condition\\n  for (const edge of inEdges[idx]) {\\n    dfs(inEdges, edge, finished); // move up\\n    inEdges[idx] = new Set([...inEdges[idx], ...inEdges[edge]]); // merge\\n  }\\n  finished[idx] = 1;\\n};\\nconst getAncestors = (n, edges) => {\\n  const inEdges = Array.from({ length: n }, () => new Set());\\n  const outdegrees = new Uint16Array(n);\\n  const finished = new Uint8Array(n);\\n  // init information\\n  for (const [from, to] of edges) {\\n    inEdges[to].add(from);\\n    ++outdegrees[from];\\n  }\\n  for (let i = 0; i < n; ++i) {\\n\\t// start dfs from every leaf node\\n    outdegrees[i] == 0 && dfs(inEdges, i, finished);\\n  }\\n  return inEdges.map(set => Array.from(set).sort((a, b) => a - b));\\n};\\n```\\n\\n## DFS - top bottom\\n\\nLet\\'s see how we can handle all the effects of a node on the final result.\\n\\n![image](https://assets.leetcode.com/users/images/f91f9cd8-58c0-4b5b-8064-fc8ac072c803_1646791992.766624.png)\\n\\nWith this test case again again, haha, let\\'s take node `0` as an example. In the final result, the nodes `3`, `4`, `5`, `6` and `7` will be effected by node `0`. Let\\'s look at these nodes individually, actually it\\'s just a tree with the root node `0`. So we could traverse the tree by DFS easily to add the `0` to the result of each node.\\n\\nThen we do the same things for each node, so we could get the final result.\\n\\nHere\\'s a sameple code from me:\\n\\n```js\\n// DFS - top bottom\\nconst dfs = (inEdges, outEdges, originValue, curValue, finished) => {\\n  if (finished[curValue]) return; // avoid repeat calculation\\n  finished[curValue] = 1;\\n  for (const out of outEdges[curValue]) {\\n    inEdges[out].add(originValue);\\n    dfs(inEdges, outEdges, originValue, out, finished); // traverse tree\\n  }\\n};\\nconst getAncestors = (n, edges) => {\\n  const inEdges = Array.from({ length: n }, () => new Set());\\n  const outEdges = Array.from({ length: n }, () => []);\\n  // init information\\n  for (const [from, to] of edges) {\\n    inEdges[to].add(from);\\n    outEdges[from].push(to);\\n  }\\n  for (let i = 0; i < n; ++i) {\\n\\t// start dfs from each node as the root\\n    dfs(inEdges, outEdges, i, i, new Uint8Array(n));\\n  }\\n  return inEdges.map(set => Array.from(set).sort((a, b) => a - b));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n// BFS\\nconst getAncestors = (n, edges) => {\\n  const indegrees = new Uint16Array(n);\\n  const inEdges = Array.from({ length: n }, () => new Set());\\n  const outEdges = Array.from({ length: n }, () => []);\\n  let curLevel = [];\\n  // init information\\n  for (const [from, to] of edges) {\\n    ++indegrees[to];\\n    inEdges[to].add(from);\\n    outEdges[from].push(to);\\n  }\\n  // init level 0\\n  for (let i = 0; i < n; ++i) {\\n    indegrees[i] === 0 && curLevel.push(i);\\n  }\\n  // geting deeper level by level\\n  while (curLevel.length) {\\n    const next = [];\\n    for (const i of curLevel) {\\n      for (const out of outEdges[i]) {\\n        --indegrees[out] === 0 && next.push(out);\\n        for (const edge of inEdges[i]) {\\n          inEdges[out].add(edge);\\n        }\\n      }\\n    }\\n    curLevel = next;\\n  }\\n  return inEdges.map(set => Array.from(set).sort((a, b) => a - b));\\n};\\n```\n```js\\n// DFS - bottom top\\nconst dfs = (inEdges, idx, finished) => {\\n  if (finished[idx]) return; // avoid repeat calculation\\n  if (inEdges[idx].size === 0) return; // end condition\\n  for (const edge of inEdges[idx]) {\\n    dfs(inEdges, edge, finished); // move up\\n    inEdges[idx] = new Set([...inEdges[idx], ...inEdges[edge]]); // merge\\n  }\\n  finished[idx] = 1;\\n};\\nconst getAncestors = (n, edges) => {\\n  const inEdges = Array.from({ length: n }, () => new Set());\\n  const outdegrees = new Uint16Array(n);\\n  const finished = new Uint8Array(n);\\n  // init information\\n  for (const [from, to] of edges) {\\n    inEdges[to].add(from);\\n    ++outdegrees[from];\\n  }\\n  for (let i = 0; i < n; ++i) {\\n\\t// start dfs from every leaf node\\n    outdegrees[i] == 0 && dfs(inEdges, i, finished);\\n  }\\n  return inEdges.map(set => Array.from(set).sort((a, b) => a - b));\\n};\\n```\n```js\\n// DFS - top bottom\\nconst dfs = (inEdges, outEdges, originValue, curValue, finished) => {\\n  if (finished[curValue]) return; // avoid repeat calculation\\n  finished[curValue] = 1;\\n  for (const out of outEdges[curValue]) {\\n    inEdges[out].add(originValue);\\n    dfs(inEdges, outEdges, originValue, out, finished); // traverse tree\\n  }\\n};\\nconst getAncestors = (n, edges) => {\\n  const inEdges = Array.from({ length: n }, () => new Set());\\n  const outEdges = Array.from({ length: n }, () => []);\\n  // init information\\n  for (const [from, to] of edges) {\\n    inEdges[to].add(from);\\n    outEdges[from].push(to);\\n  }\\n  for (let i = 0; i < n; ++i) {\\n\\t// start dfs from each node as the root\\n    dfs(inEdges, outEdges, i, i, new Uint8Array(n));\\n  }\\n  return inEdges.map(set => Array.from(set).sort((a, b) => a - b));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824992,
                "title": "c-topological-sort-brief-explanation-similar-to-course-schedule-problem",
                "content": "**Intuition**\\n1. Since the graph is DAG and we need to find all the ancestors of a node. (Its kinda similar to Course Schedule Problem where we need to satisfy all prerequisite courses to do a particular course)\\n2. Topological sort came to my mind.\\n3. The concept is exactly same but we have to do some little tweaks. \\n4. For the current node all the neighbours we can reach will contain the current node as ancestor and all the ancestor of the current node will also be the ancestors of neighbours we can reach from current node. \\n5. So we will just iterate thru current node\\'s ancestor and push it inside neighbour\\'s ancestor vector and also push the current node because this would be an immediate and original predecessor.\\n6. also maintain a set for each node for storing ancestors because we can visit or add same node multiple times for a neighbour.\\n7. DONE!!!!!\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        int sz = edges.size();\\n        vector<vector<int>> l(n);\\n        vector<int> indegree(n,0);   \\n        \\n        vector<set<int>> ans(n);\\n\\n        for(int i = 0;i<sz;i++){\\n            l[edges[i][0]].push_back(edges[i][1]);\\n            indegree[edges[i][1]]++;   \\n        }\\n        \\n        queue<int> topological_order;\\n        \\n        for(int i = 0;i<n;i++){\\n            if(indegree[i] == 0){  \\n                topological_order.push(i);\\n                ans[i] = {};   \\n            }\\n        }\\n        \\n            \\n        while(!topological_order.empty()){\\n            int node = topological_order.front();\\n\\n            topological_order.pop();\\n            for(auto nbr : l[node]){\\n                    indegree[nbr]--;\\n                if(indegree[nbr] == 0){\\n                    topological_order.push(nbr);\\n                }\\n\\n                    for(auto x : ans[node]){\\n                        ans[nbr].insert(x);\\n                    }\\n                    ans[nbr].insert(node);\\n\\n                }\\n            }\\n            \\n        vector<vector<int>> res(n);\\n        \\n        for(int i = 0;i<ans.size();i++){\\n            for(auto x : ans[i]){\\n                res[i].push_back(x);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        int sz = edges.size();\\n        vector<vector<int>> l(n);\\n        vector<int> indegree(n,0);   \\n        \\n        vector<set<int>> ans(n);\\n\\n        for(int i = 0;i<sz;i++){\\n            l[edges[i][0]].push_back(edges[i][1]);\\n            indegree[edges[i][1]]++;   \\n        }\\n        \\n        queue<int> topological_order;\\n        \\n        for(int i = 0;i<n;i++){\\n            if(indegree[i] == 0){  \\n                topological_order.push(i);\\n                ans[i] = {};   \\n            }\\n        }\\n        \\n            \\n        while(!topological_order.empty()){\\n            int node = topological_order.front();\\n\\n            topological_order.pop();\\n            for(auto nbr : l[node]){\\n                    indegree[nbr]--;\\n                if(indegree[nbr] == 0){\\n                    topological_order.push(nbr);\\n                }\\n\\n                    for(auto x : ans[node]){\\n                        ans[nbr].insert(x);\\n                    }\\n                    ans[nbr].insert(node);\\n\\n                }\\n            }\\n            \\n        vector<vector<int>> res(n);\\n        \\n        for(int i = 0;i<ans.size();i++){\\n            for(auto x : ans[i]){\\n                res[i].push_back(x);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823406,
                "title": "c-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<set<int>>ans(n);\\n        int m=edges.size();\\n        vector<vector<int>>adj(n);\\n        vector<int>indegree(n,0);\\n        for(int i=0; i<m; i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            indegree[edges[i][1]]++;\\n        }\\n        queue<int>q;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(indegree[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            auto it=q.front();\\n            q.pop();\\n            \\n            for(auto i:adj[it])\\n            {\\n                indegree[i]--;\\n                \\n                set<int>s=ans[it];\\n                s.insert(it);\\n                \\n                for (auto itr = s.begin(); itr != s.end(); itr++)\\n                {\\n                    ans[i].insert(*itr);\\n                }\\n                \\n                if(indegree[i]==0)\\n                {\\n                    q.push(i);\\n                }\\n            }\\n        }\\n        vector<vector<int>>res;\\n        for(int i=0; i<n; i++)\\n        {\\n            vector<int>v;\\n            set<int>s=ans[i];\\n            for(auto itr = s.begin(); itr != s.end(); itr++)\\n            {\\n                v.push_back(*itr);\\n            }\\n            res.push_back(v);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<set<int>>ans(n);\\n        int m=edges.size();\\n        vector<vector<int>>adj(n);\\n        vector<int>indegree(n,0);\\n        for(int i=0; i<m; i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            indegree[edges[i][1]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1822118,
                "title": "python-3-reverse-direction-and-find-all-children",
                "content": "Reverse the direction for each edge and find all children of each node instead.\\nUse dynamic programming to save the paths of the previous nodes.\\nDo **UPVOTE** if you found it helpful.\\n\\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        ans = [[] for _ in range(n)]\\n        \\n        graph = defaultdict(list)\\n        for f, t in edges:\\n            graph[t].append(f)\\n        \\n        memo = defaultdict(list)\\n        def dfs(src):\\n            if src in memo:\\n                return memo[src]\\n            \\n            for nei in graph[src]:\\n                memo[src] += [nei]+dfs(nei)\\n            \\n            memo[src] = list(set(memo[src]))\\n            return memo[src]\\n        \\n        for i in range(n):\\n            dfs(i)\\n        return [sorted(memo[i]) for i in range(n)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        ans = [[] for _ in range(n)]\\n        \\n        graph = defaultdict(list)\\n        for f, t in edges:\\n            graph[t].append(f)\\n        \\n        memo = defaultdict(list)\\n        def dfs(src):\\n            if src in memo:\\n                return memo[src]\\n            \\n            for nei in graph[src]:\\n                memo[src] += [nei]+dfs(nei)\\n            \\n            memo[src] = list(set(memo[src]))\\n            return memo[src]\\n        \\n        for i in range(n):\\n            dfs(i)\\n        return [sorted(memo[i]) for i in range(n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821949,
                "title": "java-easy-to-understand-topological-sort",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        Map<Integer,Integer> dependencyCountMap = new HashMap<>();\\n        Map<Integer, Set<Integer>> nextNodeMap = new HashMap<>();\\n        Map<Integer, Set<Integer>> prevNodeMap = new HashMap<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int []edge: edges){\\n            dependencyCountMap.put(edge[1],dependencyCountMap.getOrDefault(edge[1],0)+1);\\n            Set<Integer> set = nextNodeMap.getOrDefault(edge[0],new HashSet<>());\\n            set.add(edge[1]);\\n            nextNodeMap.put(edge[0], set);\\n            \\n            set = prevNodeMap.getOrDefault(edge[1],new HashSet<>());\\n            set.add(edge[0]);\\n            prevNodeMap.put(edge[1], set);\\n        }\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n                if(dependencyCountMap.getOrDefault(i,0)==0){//if there are no unresolved dependencies\\n                    queue.offer(i);\\n                }\\n        }\\n        while(queue.size()>0){\\n            int current = queue.poll();\\n            for(int next: nextNodeMap.getOrDefault(current,new HashSet<>())){\\n                int nextCount = dependencyCountMap.getOrDefault(next,0);\\n                dependencyCountMap.put(next, nextCount - 1);\\n                if(nextCount -1 == 0)\\n                    queue.offer(next);\\n            }\\n            \\n            for(int prev: prevNodeMap.getOrDefault(current,new HashSet<>())){//pick resolved dependecies and add to result\\n                        map.putIfAbsent(current,new HashSet<>());\\n                        map.get(current).add(prev);//add 3,4 for 6\\n                        map.get(current).addAll(map.getOrDefault(prev, new HashSet<>()));\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n\\t\\t\\t List<Integer> list =   new ArrayList<>(map.getOrDefault(i, new HashSet<>()));\\n             Collections.sort(list);\\n\\t\\t\\tresult.add(list);\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        Map<Integer,Integer> dependencyCountMap = new HashMap<>();\\n        Map<Integer, Set<Integer>> nextNodeMap = new HashMap<>();\\n        Map<Integer, Set<Integer>> prevNodeMap = new HashMap<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int []edge: edges){\\n            dependencyCountMap.put(edge[1],dependencyCountMap.getOrDefault(edge[1],0)+1);\\n            Set<Integer> set = nextNodeMap.getOrDefault(edge[0],new HashSet<>());\\n            set.add(edge[1]);\\n            nextNodeMap.put(edge[0], set);\\n            \\n            set = prevNodeMap.getOrDefault(edge[1],new HashSet<>());\\n            set.add(edge[0]);\\n            prevNodeMap.put(edge[1], set);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3941125,
                "title": "dfs-from-child-to-parent",
                "content": "# approach:\\njust take transpose of the graph and call dfs for each node.\\nAs graph edges are reversed and we are calling dfs, its like calling dfs from leaf to parent, and just keep appending the vertices which are not in ans[node]..... \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\n        ans = [[] for _ in range(n)]\\n\\n        g = defaultdict(list)\\n\\n        for u, v in edges:\\n            g[v].append(u)\\n        \\n        def dfs(node, curr):\\n            for v in g[curr]:\\n                if v not in ans[node]:\\n                    dfs(node, v)\\n                    ans[node].append(v)  \\n        \\n        for i in range(n):\\n            dfs(i,i)\\n\\n        for k in ans:\\n            k.sort()\\n            \\n        return ans \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\n        ans = [[] for _ in range(n)]\\n\\n        g = defaultdict(list)\\n\\n        for u, v in edges:\\n            g[v].append(u)\\n        \\n        def dfs(node, curr):\\n            for v in g[curr]:\\n                if v not in ans[node]:\\n                    dfs(node, v)\\n                    ans[node].append(v)  \\n        \\n        for i in range(n):\\n            dfs(i,i)\\n\\n        for k in ans:\\n            k.sort()\\n            \\n        return ans \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293704,
                "title": "python-elegant-short-reverse-edges",
                "content": "```\\nfrom collections import defaultdict\\nfrom typing import Iterable, List\\n\\n\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> Iterable[List[int]]:\\n        def dfs(u: int) -> set:\\n            if not ancestors[u]:\\n                for v in graph[u]:\\n                    if v not in ancestors[u]:\\n                        ancestors[u].update({v} | dfs(v))\\n            return ancestors[u]\\n\\n        graph = defaultdict(set)\\n        for u, v in edges:\\n            graph[v].add(u)\\n\\n        ancestors = [set() for _ in range(n)]\\n        for u in range(n):\\n            if not ancestors[u]:\\n                dfs(u)\\n\\n        return map(sorted, ancestors)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom typing import Iterable, List\\n\\n\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> Iterable[List[int]]:\\n        def dfs(u: int) -> set:\\n            if not ancestors[u]:\\n                for v in graph[u]:\\n                    if v not in ancestors[u]:\\n                        ancestors[u].update({v} | dfs(v))\\n            return ancestors[u]\\n\\n        graph = defaultdict(set)\\n        for u, v in edges:\\n            graph[v].add(u)\\n\\n        ancestors = [set() for _ in range(n)]\\n        for u in range(n):\\n            if not ancestors[u]:\\n                dfs(u)\\n\\n        return map(sorted, ancestors)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775961,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> ans(n), directChild(n);\\n    for(auto& e: edges) \\n        directChild[e[0]].push_back(e[1]);\\n    for(int i = 0; i < n; i++)\\n        dfs(i, i, ans, directChild);\\n    return ans;\\n}\\nvoid dfs(int x, int curr, vector<vector<int>>& ans, vector<vector<int>>& directChild) {\\n    for (auto& ch: directChild[curr]) \\n        if(ans[ch].size() == 0 || ans[ch].back() != x) {\\n            ans[ch].push_back(x);\\n            dfs(x, ch, ans, directChild);\\n        }\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> ans(n), directChild(n);\\n    for(auto& e: edges) \\n        directChild[e[0]].push_back(e[1]);\\n    for(int i = 0; i < n; i++)\\n        dfs(i, i, ans, directChild);\\n    return ans;\\n}\\nvoid dfs(int x, int curr, vector<vector<int>>& ans, vector<vector<int>>& directChild) {\\n    for (auto& ch: directChild[curr]) \\n        if(ans[ch].size() == 0 || ans[ch].back() != x) {\\n            ans[ch].push_back(x);\\n            dfs(x, ch, ans, directChild);\\n        }\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725360,
                "title": "python-cached-dfs",
                "content": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        v_edges = [set() for i in range(n)]\\n        for u, v in edges:\\n            v_edges[v].add(u)\\n        \\n        @cache\\n        def dfs(v):\\n            children = set()\\n            for v2 in v_edges[v]:\\n                children.add(v2)\\n                children |= dfs(v2)\\n            return children\\n        \\n        ans = [dfs(v) for v in range(n)]\\n        return [sorted(list(i)) for i in ans]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        v_edges = [set() for i in range(n)]\\n        for u, v in edges:\\n            v_edges[v].add(u)\\n        \\n        @cache\\n        def dfs(v):\\n            children = set()\\n            for v2 in v_edges[v]:\\n                children.add(v2)\\n                children |= dfs(v2)\\n            return children\\n        \\n        ans = [dfs(v) for v in range(n)]\\n        return [sorted(list(i)) for i in ans]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702965,
                "title": "brute-force-to-optimal-c",
                "content": "# O(n log n) \\n```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<int> &vis, vector<set<int>> &ancs) {\\n        vis[node] = 1;\\n        for(int ad : adj[node]) {\\n            if(!vis[ad]) dfs(ad, adj, vis, ancs);\\n            ancs[node].insert(ancs[ad].begin(), ancs[ad].end()), ancs[node].insert(ad);\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto e : edges) adj[e[1]].push_back(e[0]);\\n\\n        vector<set<int>> ancs(n, set<int>());\\n        vector<int> vis(n, 0);\\n        for(int i=0; i<n; i++) {\\n            if(!vis[i]) dfs(i, adj, vis, ancs);\\n        }\\n        vector<vector<int>> ans;\\n        for(auto s : ancs) {\\n            vector<int> v(s.begin(), s.end());\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# O(n ^ 2)\\n```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<vector<int>> &ans, int &sp) {\\n        for(int ad : adj[node]) {\\n            if(!ans[ad].size() || ans[ad].back() != sp) ans[ad].push_back(sp);\\n            dfs(ad, adj, ans, sp);\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto e : edges) adj[e[0]].push_back(e[1]);\\n\\n        vector<vector<int>> ans(n, vector<int>());\\n        for(int i=0; i<n; i++) dfs(i, adj, ans, i);\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<int> &vis, vector<set<int>> &ancs) {\\n        vis[node] = 1;\\n        for(int ad : adj[node]) {\\n            if(!vis[ad]) dfs(ad, adj, vis, ancs);\\n            ancs[node].insert(ancs[ad].begin(), ancs[ad].end()), ancs[node].insert(ad);\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto e : edges) adj[e[1]].push_back(e[0]);\\n\\n        vector<set<int>> ancs(n, set<int>());\\n        vector<int> vis(n, 0);\\n        for(int i=0; i<n; i++) {\\n            if(!vis[i]) dfs(i, adj, vis, ancs);\\n        }\\n        vector<vector<int>> ans;\\n        for(auto s : ancs) {\\n            vector<int> v(s.begin(), s.end());\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<vector<int>> &ans, int &sp) {\\n        for(int ad : adj[node]) {\\n            if(!ans[ad].size() || ans[ad].back() != sp) ans[ad].push_back(sp);\\n            dfs(ad, adj, ans, sp);\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto e : edges) adj[e[0]].push_back(e[1]);\\n\\n        vector<vector<int>> ans(n, vector<int>());\\n        for(int i=0; i<n; i++) dfs(i, adj, ans, i);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680291,
                "title": "python-topological-sort",
                "content": "\\tclass Solution:\\n\\t\\tdef getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\t\\t\\t\\n\\t\\t\\tgraph = defaultdict(list)\\n\\t\\t\\tin_degree = [0]*n\\n\\t\\t\\tres = [set() for _ in range(n)]\\n\\t\\t\\t\\n\\t\\t\\t# build the graph and count the in degree for each node\\n\\t\\t\\tfor i in edges:\\n\\t\\t\\t\\tgraph[i[0]].append(i[1])\\n\\t\\t\\t\\tin_degree[i[1]] += 1\\n\\t\\t\\t\\n\\t\\t\\tque = deque()\\n\\t\\t\\t# nodes with an in degree of 0 are added in the que \\n\\t\\t\\tfor i in range(len(in_degree)):\\n\\t\\t\\t\\tif not in_degree[i]:\\n\\t\\t\\t\\t\\tque.append(i)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\twhile que:\\n\\t\\t\\t\\tnode = que.popleft()\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor i in graph[node]:\\n\\t\\t\\t\\t\\t# since this node is already visited, we can decrease the in degree of it\\'s children by 1 \\n\\t\\t\\t\\t\\tin_degree[i] -= 1\\n\\t\\t\\t\\t\\tres[i].add(node)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# for the children nodes, we need to add the path of their ancestor \\n\\t\\t\\t\\t\\tfor j in res[node]:\\n\\t\\t\\t\\t\\t\\tres[i].add(j)\\n\\t\\t\\t\\t\\tif not in_degree[i]:\\n\\t\\t\\t\\t\\t\\tque.append(i)\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tfor i in range(len(res)):\\n\\t\\t\\t\\tres[i] = sorted(res[i])\\n\\t\\t\\t   \\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\t\\t\\t\\n\\t\\t\\tgraph = defaultdict(list)\\n\\t\\t\\tin_degree = [0]*n\\n\\t\\t\\tres = [set() for _ in range(n)]\\n\\t\\t\\t\\n\\t\\t\\t# build the graph and count the in degree for each node\\n\\t\\t\\tfor i in edges:\\n\\t\\t\\t\\tgraph[i[0]].append(i[1])\\n\\t\\t\\t\\tin_degree[i[1]] += 1\\n\\t\\t\\t\\n\\t\\t\\tque = deque()\\n\\t\\t\\t# nodes with an in degree of 0 are added in the que \\n\\t\\t\\tfor i in range(len(in_degree)):\\n\\t\\t\\t\\tif not in_degree[i]:\\n\\t\\t\\t\\t\\tque.append(i)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\twhile que:\\n\\t\\t\\t\\tnode = que.popleft()\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor i in graph[node]:\\n\\t\\t\\t\\t\\t# since this node is already visited, we can decrease the in degree of it\\'s children by 1 \\n\\t\\t\\t\\t\\tin_degree[i] -= 1\\n\\t\\t\\t\\t\\tres[i].add(node)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# for the children nodes, we need to add the path of their ancestor \\n\\t\\t\\t\\t\\tfor j in res[node]:\\n\\t\\t\\t\\t\\t\\tres[i].add(j)\\n\\t\\t\\t\\t\\tif not in_degree[i]:\\n\\t\\t\\t\\t\\t\\tque.append(i)\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tfor i in range(len(res)):\\n\\t\\t\\t\\tres[i] = sorted(res[i])\\n\\t\\t\\t   \\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2542818,
                "title": "cpp-brute-force-accepted",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    void dfs(int i,int ansc,vector<vector<int>>&ans,vector<int>&vis,vector<vector<int>>&res){\\n             \\n        vis[i]=1;\\n        \\n        for(auto t:ans[i]){\\n            if(!vis[t]){\\n                dfs(t,ansc,ans,vis,res);\\n            }\\n        }\\n       \\n        if(i!=ansc)\\n            res[i].push_back(ansc);\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>>ans(n),result(n);\\n        \\n        for(auto a:edges){\\n            ans[a[0]].push_back(a[1]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            vector<int>visited(n);\\n            dfs(i,i,ans,visited,result);\\n        }\\n      \\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n   \\n    void dfs(int i,int ansc,vector<vector<int>>&ans,vector<int>&vis,vector<vector<int>>&res){\\n             \\n        vis[i]=1;\\n        \\n        for(auto t:ans[i]){\\n            if(!vis[t]){\\n                dfs(t,ansc,ans,vis,res);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2091939,
                "title": "java-solution-using-dfs",
                "content": "Java Solution Using DFS :\\n\\nSteps :\\n\\n1. Create adjList as a directed graph from input matrix .\\n2. Do DFS for each node from 0 --> n\\n3. Here we are considering each node as root/Parent and using DFS we will add this root/Parent into resultList of each nodes where we can reach from this root ( its children and their children ).\\n4. We will use visited[] to identify if any of the child or their children are already visited for that particular root/parent, so to avoid duplicity and call reduction .\\n\\n\\n\\n```\\n\\nclass Solution {\\n    \\n    List<List<Integer>> adjList ;\\n    List<List<Integer>> result ;\\n    \\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        this.adjList = new ArrayList<>() ;\\n        this.result = new ArrayList<>() ;\\n\\n        for(int i=0 ; i<n ; i++){\\n            adjList.add(new ArrayList<>()) ;\\n            result.add(new ArrayList<>()) ;\\n        }\\n        \\n        for(int i=0 ; i<edges.length ; i++){\\n            int start = edges[i][0] ;\\n            int end = edges[i][1] ;\\n            adjList.get(start).add(end) ;\\n        }\\n        \\n        //  DFS for each node from 0 --> n , and add that node as root/parent into each reachable node and their child\\n        //  Use visited[] to identify if any of the child or their childs are already visited for that perticular root/parent, \\n        //  so will not add the root to avoid duplicacy and call reduction .\\n        \\n        for(int i=0 ; i<n ; i++){            \\n            boolean visited[] = new boolean[n] ;\\n            List<Integer> childList = adjList.get(i);\\n            for(Integer child : childList){\\n                if(!visited[child]){\\n                    dfs( i , child , visited);\\n                }                \\n            }            \\n        }\\n        \\n        return result ;\\n    }\\n    \\n    public void dfs(int root , int node , boolean[] visited){\\n        if(visited[node]){\\n            return ;\\n        }\\n        visited[node] = true ;\\n        result.get(node).add(root) ;\\n        List<Integer> childList = adjList.get(node) ;\\n        for(Integer child : childList){\\n            if(!visited[child]){\\n                dfs( root , child , visited);\\n            }                \\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    \\n    List<List<Integer>> adjList ;\\n    List<List<Integer>> result ;\\n    \\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        this.adjList = new ArrayList<>() ;\\n        this.result = new ArrayList<>() ;\\n\\n        for(int i=0 ; i<n ; i++){\\n            adjList.add(new ArrayList<>()) ;\\n            result.add(new ArrayList<>()) ;\\n        }\\n        \\n        for(int i=0 ; i<edges.length ; i++){\\n            int start = edges[i][0] ;\\n            int end = edges[i][1] ;\\n            adjList.get(start).add(end) ;\\n        }\\n        \\n        //  DFS for each node from 0 --> n , and add that node as root/parent into each reachable node and their child\\n        //  Use visited[] to identify if any of the child or their childs are already visited for that perticular root/parent, \\n        //  so will not add the root to avoid duplicacy and call reduction .\\n        \\n        for(int i=0 ; i<n ; i++){            \\n            boolean visited[] = new boolean[n] ;\\n            List<Integer> childList = adjList.get(i);\\n            for(Integer child : childList){\\n                if(!visited[child]){\\n                    dfs( i , child , visited);\\n                }                \\n            }            \\n        }\\n        \\n        return result ;\\n    }\\n    \\n    public void dfs(int root , int node , boolean[] visited){\\n        if(visited[node]){\\n            return ;\\n        }\\n        visited[node] = true ;\\n        result.get(node).add(root) ;\\n        List<Integer> childList = adjList.get(node) ;\\n        for(Integer child : childList){\\n            if(!visited[child]){\\n                dfs( root , child , visited);\\n            }                \\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2049836,
                "title": "took-me-few-days-to-think-but-never-came-up-with-an-approach",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(unordered_map<int,vector<int>> &mp,vector<bool> &visited, int ancestor){\\n\\t\\t\\tif(visited[ancestor] == true)   return;\\n\\t\\t\\tvisited[ancestor] = true;\\n\\t\\t\\tfor(int i = 0; i<mp[ancestor].size(); i++){\\n\\t\\t\\t\\tif(visited[mp[ancestor][i]] == false){\\n\\t\\t\\t\\t\\tdfs(mp,visited,mp[ancestor][i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n\\t\\t\\tunordered_map<int,vector<int>> mp;\\n\\t\\t\\tfor(int i = 0; i<edges.size(); i++)  mp[edges[i][1]].push_back(edges[i][0]);\\n\\t\\t\\tvector<vector<int>> answer;\\n\\t\\t\\tfor(int i = 0; i<n; i++){\\n\\t\\t\\t\\tvector<bool> visited(n,false);\\n\\t\\t\\t\\tvector<int> temp;\\n\\t\\t\\t\\tdfs(mp,visited,i);\\n\\t\\t\\t\\tfor(int j = 0; j<n; j++){\\n\\t\\t\\t\\t\\tif(visited[j] == true && i!=j)  temp.push_back(j);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tanswer.push_back(temp);\\n\\t\\t\\t}\\n\\t\\t\\treturn answer;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(unordered_map<int,vector<int>> &mp,vector<bool> &visited, int ancestor){\\n\\t\\t\\tif(visited[ancestor] == true)   return;\\n\\t\\t\\tvisited[ancestor] = true;\\n\\t\\t\\tfor(int i = 0; i<mp[ancestor].size(); i++){\\n\\t\\t\\t\\tif(visited[mp[ancestor][i]] == false){\\n\\t\\t\\t\\t\\tdfs(mp,visited,mp[ancestor][i]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2008263,
                "title": "c-dfs-simple-easy-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) \\n    {\\n        vector<vector<int>> g(n);\\n        vector<vector<int>>ans(n);\\n        \\n        for(auto &i:edges)\\n        {\\n             g[i[0]].push_back(i[1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            dfs(g,ans,i, i);\\n        }\\n        return ans;\\n    }\\n    \\n    void dfs(vector<vector<int>> &g,vector<vector<int>> &ans,int src, int anc)\\n    {\\n        for(auto &it : g[src])\\n        {\\n            if(ans[it].size()==0 || ans[it].back()!=anc)\\n            {\\n                ans[it].push_back(anc);\\n                dfs(g,ans,it,anc);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) \\n    {\\n        vector<vector<int>> g(n);\\n        vector<vector<int>>ans(n);\\n        \\n        for(auto &i:edges)\\n        {\\n             g[i[0]].push_back(i[1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            dfs(g,ans,i, i);\\n        }\\n        return ans;\\n    }\\n    \\n    void dfs(vector<vector<int>> &g,vector<vector<int>> &ans,int src, int anc)\\n    {\\n        for(auto &it : g[src])\\n        {\\n            if(ans[it].size()==0 || ans[it].back()!=anc)\\n            {\\n                ans[it].push_back(anc);\\n                dfs(g,ans,it,anc);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004370,
                "title": "python-topological-traversal-approach-with-notes",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    we can use a bfs based approach to get the required ancestors for each node nodes\\n    nodes with indegree of 0 will have empty ancestors list\\n    then we will put all nodes with no incoming edges in queue\\n    until the queue is empty:\\n        pop the node\\n        for all neighbors of node:\\n            add the ancestor set of node along with the node in the ancestor set of neighbor\\n    \"\"\"\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        graph = {node: set() for node in range(n)}\\n        indegree = {node: 0 for node in range(n)}\\n        ans = [set() for _ in range(n)]\\n        for edge in edges:\\n            graph[edge[0]].add(edge[1])\\n            indegree[edge[1]]+=1\\n        nodes_with_no_incoming_edges = []\\n        for node, indeg in indegree.items():\\n            if indeg == 0:\\n                nodes_with_no_incoming_edges.append(node)\\n        while len(nodes_with_no_incoming_edges):\\n            node = nodes_with_no_incoming_edges.pop()\\n            for neighbor in graph[node]:\\n                ans[neighbor].add(node)\\n                ans[neighbor] = ans[neighbor].union(ans[node])\\n                indegree[neighbor]-=1\\n                if indegree[neighbor] == 0:\\n                    nodes_with_no_incoming_edges.append(neighbor)\\n                    \\n        sorted_ans = []           \\n        for ancestor in ans:\\n            temp = sorted(list(ancestor))\\n            sorted_ans.append(temp)\\n        return sorted_ans\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    we can use a bfs based approach to get the required ancestors for each node nodes\\n    nodes with indegree of 0 will have empty ancestors list\\n    then we will put all nodes with no incoming edges in queue\\n    until the queue is empty:\\n        pop the node\\n        for all neighbors of node:\\n            add the ancestor set of node along with the node in the ancestor set of neighbor\\n    \"\"\"\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        graph = {node: set() for node in range(n)}\\n        indegree = {node: 0 for node in range(n)}\\n        ans = [set() for _ in range(n)]\\n        for edge in edges:\\n            graph[edge[0]].add(edge[1])\\n            indegree[edge[1]]+=1\\n        nodes_with_no_incoming_edges = []\\n        for node, indeg in indegree.items():\\n            if indeg == 0:\\n                nodes_with_no_incoming_edges.append(node)\\n        while len(nodes_with_no_incoming_edges):\\n            node = nodes_with_no_incoming_edges.pop()\\n            for neighbor in graph[node]:\\n                ans[neighbor].add(node)\\n                ans[neighbor] = ans[neighbor].union(ans[node])\\n                indegree[neighbor]-=1\\n                if indegree[neighbor] == 0:\\n                    nodes_with_no_incoming_edges.append(neighbor)\\n                    \\n        sorted_ans = []           \\n        for ancestor in ans:\\n            temp = sorted(list(ancestor))\\n            sorted_ans.append(temp)\\n        return sorted_ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995245,
                "title": "java-simple-dfs-w-brief-explanation-beat-100",
                "content": "```\\npublic List<List<Integer>> getAncestors(int n, int[][] edges) {\\n\\t\\t// Build directed graph\\n        List<Integer>[] graph = new ArrayList[n];\\n        for (int[] e : edges) {\\n            if (graph[e[0]] == null) \\n                graph[e[0]] = new ArrayList<>();\\n            graph[e[0]].add(e[1]);\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < n; i++) \\n            res.add(new ArrayList<>());\\n        \\n\\t\\t// Since the list of ancestors should be sorted in ascending order, we iterator from node 0 to node n - 1\\n\\t\\t// Use DFS to find the nodes that node i can reach\\n        for (int i = 0; i < n; i++) {\\n            if (graph[i] == null) continue;\\n\\t\\t\\t// We need to check whether we visited the node before\\n\\t\\t\\t// Example: 0 -> 3 -> 6, 0 -> 4 -> 6, if we DFS from node 0, we may visite node 6 twice\\n            boolean[] visited = new boolean[n];\\n\\t\\t\\t// We do one step of DFS here since node i is not the ancestor of itself.\\n\\t\\t\\t// Then in the following steps of DFS, we add node i to the node next\\'s ancestor\\n            for (int next : graph[i]) {\\n                if (visited[next]) continue;\\n                visited[next] = true;\\n                dfs(i, next, graph, res, visited);\\n            }\\n        }\\n        return res;\\n    }\\n    private void dfs(int ancestor, int node, List<Integer>[] graph, List<List<Integer>> res, boolean[] visited) {\\n        res.get(node).add(ancestor);\\n        if (graph[node] == null) return;\\n        for (int next : graph[node]) {\\n            if (visited[next]) continue;\\n            visited[next] = true;\\n            dfs(ancestor, next, graph, res, visited);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> getAncestors(int n, int[][] edges) {\\n\\t\\t// Build directed graph\\n        List<Integer>[] graph = new ArrayList[n];\\n        for (int[] e : edges) {\\n            if (graph[e[0]] == null) \\n                graph[e[0]] = new ArrayList<>();\\n            graph[e[0]].add(e[1]);\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < n; i++) \\n            res.add(new ArrayList<>());\\n        \\n\\t\\t// Since the list of ancestors should be sorted in ascending order, we iterator from node 0 to node n - 1\\n\\t\\t// Use DFS to find the nodes that node i can reach\\n        for (int i = 0; i < n; i++) {\\n            if (graph[i] == null) continue;\\n\\t\\t\\t// We need to check whether we visited the node before\\n\\t\\t\\t// Example: 0 -> 3 -> 6, 0 -> 4 -> 6, if we DFS from node 0, we may visite node 6 twice\\n            boolean[] visited = new boolean[n];\\n\\t\\t\\t// We do one step of DFS here since node i is not the ancestor of itself.\\n\\t\\t\\t// Then in the following steps of DFS, we add node i to the node next\\'s ancestor\\n            for (int next : graph[i]) {\\n                if (visited[next]) continue;\\n                visited[next] = true;\\n                dfs(i, next, graph, res, visited);\\n            }\\n        }\\n        return res;\\n    }\\n    private void dfs(int ancestor, int node, List<Integer>[] graph, List<List<Integer>> res, boolean[] visited) {\\n        res.get(node).add(ancestor);\\n        if (graph[node] == null) return;\\n        for (int next : graph[node]) {\\n            if (visited[next]) continue;\\n            visited[next] = true;\\n            dfs(ancestor, next, graph, res, visited);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1880771,
                "title": "topological-dfs-easy-and-commented-with-dry-run-explanation",
                "content": "## Approach:\\n\\t1. \\tIn this apprach,we will not update answer list while doing DFS at each node (this approach was taking more time and hence threw TLE).\\n\\t2. \\tIn this approach, we will instead iterate over all nodes. In each iteration, we will update that node as ancestor to all of the nodes it is connected directly or indirectly (via DFS).\\n\\t3. \\tSee below dry-run to understand the approach more easily.  \\n\\n## Dry Run\\n\\tIt was bit hard to draw everything in the limited space, but did my best. Let me know if anything is unclear or need any explanation. \\n\\tJust follow the steps from a) to y) \\n![image](https://assets.leetcode.com/users/images/c7fc01e3-5893-49de-83aa-672e4bce707e_1648155240.6652746.png)\\n![image](https://assets.leetcode.com/users/images/acc5bf7a-065c-491a-b775-a6fab62fe86b_1648155335.1324124.png)\\n\\n**Zoomed bottom portion**\\n![image](https://assets.leetcode.com/users/images/8626bd6f-1337-4ee6-aa46-34a1d5f40c2e_1648155407.7836995.png)\\n\\n\\n\\n\\n\\n\\tBelow is how the answer will keep getting updated in each iteration:\\n\\t--------------------\\n\\ti: 0 , answer now: \\n\\t0, []\\n\\t1, []\\n\\t2, []\\n\\t3, [0]\\n\\t4, [0]\\n\\t5, [0]\\n\\t6, [0]\\n\\t7, [0]\\n\\t--------------------\\n\\ti: 1 , answer now: \\n\\t0, []\\n\\t1, []\\n\\t2, []\\n\\t3, [0, 1]\\n\\t4, [0]\\n\\t5, [0, 1]\\n\\t6, [0, 1]\\n\\t7, [0, 1]\\n\\t--------------------\\n\\ti: 2 , answer now: \\n\\t0, []\\n\\t1, []\\n\\t2, []\\n\\t3, [0, 1]\\n\\t4, [0, 2]\\n\\t5, [0, 1]\\n\\t6, [0, 1, 2]\\n\\t7, [0, 1, 2]\\n\\t--------------------\\n\\ti: 3 , answer now: \\n\\t0, []\\n\\t1, []\\n\\t2, []\\n\\t3, [0, 1]\\n\\t4, [0, 2]\\n\\t5, [0, 1, 3]\\n\\t6, [0, 1, 2, 3]\\n\\t7, [0, 1, 2, 3]\\n\\t--------------------\\n\\ti: 4 , answer now: \\n\\t0, []\\n\\t1, []\\n\\t2, []\\n\\t3, [0, 1]\\n\\t4, [0, 2]\\n\\t5, [0, 1, 3]\\n\\t6, [0, 1, 2, 3, 4]\\n\\t7, [0, 1, 2, 3]\\n\\t--------------------\\n\\ti: 5 , answer now: \\n\\t0, []\\n\\t1, []\\n\\t2, []\\n\\t3, [0, 1]\\n\\t4, [0, 2]\\n\\t5, [0, 1, 3]\\n\\t6, [0, 1, 2, 3, 4]\\n\\t7, [0, 1, 2, 3]\\n\\t--------------------\\n\\ti: 6 , answer now: \\n\\t0, []\\n\\t1, []\\n\\t2, []\\n\\t3, [0, 1]\\n\\t4, [0, 2]\\n\\t5, [0, 1, 3]\\n\\t6, [0, 1, 2, 3, 4]\\n\\t7, [0, 1, 2, 3]\\n\\t--------------------\\n\\ti: 7 , answer now: \\n\\t0, []\\n\\t1, []\\n\\t2, []\\n\\t3, [0, 1]\\n\\t4, [0, 2]\\n\\t5, [0, 1, 3]\\n\\t6, [0, 1, 2, 3, 4]\\n\\t7, [0, 1, 2, 3]\\n\\n\\n\\n## Code\\n\\n\\tclass Solution {\\n\\t\\tpublic List<List<Integer>> getAncestors(int n, int[][] edges) {\\n\\t\\t\\tList<List<Integer>> adjList = new ArrayList<>();                                  \\n\\t\\t\\tList<List<Integer>> answer  = new ArrayList<>();                                   \\n\\n\\t\\t\\tinitialize(answer, adjList, n);                                                    // initialize answer and adjList lists with empty list. \\n\\t\\t\\tfillAdjList(adjList, edges, n);                                                    // fill adjacency list\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tint ancestor = i;\\n\\t\\t\\t\\tdfs(ancestor, i, adjList, answer);                                            // call DFS\\n\\t\\t\\t}\\n\\t\\t\\treturn answer;\\n\\t\\t}    \\n\\n\\t\\tpublic void dfs(int ancestor, int src, List<List<Integer>> adjList, List<List<Integer>> answer){                // DFS method\\n\\t\\t\\tList<Integer> ancestorList = answer.get(src);\\n\\t\\t\\tif(ancestorList.isEmpty() || ancestorList.get( ancestorList.size() -1 ) != ancestor){         \\n\\t\\t\\t\\tif(ancestor != src){ ancestorList.add(ancestor); }                           // add ancestor to ancestor list, if only ancestor list is either empty, or does not already contain ancestor node.\\n\\t\\t\\t\\tfor(int dest : adjList.get(src)){\\n\\t\\t\\t\\t\\tdfs(ancestor, dest, adjList, answer);                                    // for each connected edge, do DFS recursion\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic void initialize(List<List<Integer>> answer, List<List<Integer>> adjList, int n){\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tanswer.add(new ArrayList<>());\\n\\t\\t\\t\\tadjList.add(new ArrayList<>());\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic void fillAdjList(List<List<Integer>> adjList, int[][] edges, int n){\\n\\t\\t\\tfor(int[] edge : edges){\\n\\t\\t\\t\\tadjList.get(edge[0]).add(edge[1]);    \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n\\t\\tpublic List<List<Integer>> getAncestors(int n, int[][] edges) {\\n\\t\\t\\tList<List<Integer>> adjList = new ArrayList<>();                                  \\n\\t\\t\\tList<List<Integer>> answer  = new ArrayList<>();                                   \\n\\n\\t\\t\\tinitialize(answer, adjList, n);                                                    // initialize answer and adjList lists with empty list. \\n\\t\\t\\tfillAdjList(adjList, edges, n);                                                    // fill adjacency list\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tint ancestor = i;\\n\\t\\t\\t\\tdfs(ancestor, i, adjList, answer);                                            // call DFS\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1833569,
                "title": "python-short-easy-dfs",
                "content": "First create the mapping between each node and its direct parent.\\nThen for each node do depth first to gather all of its parents (removing duplicates with set)\\n```\\nclass Solution:\\n    def getAncestors(self, n, edges):\\n        ancestors = defaultdict(list)\\n        for a, b in edges:\\n            ancestors[b].append(a)\\n        \\n        @lru_cache(None)\\n        def dfs(i):\\n            res = set(ancestors[i])\\n            for x in ancestors[i]:\\n                res |= dfs(x)\\n            return res\\n        return [sorted(dfs(i)) for i in range(n)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n, edges):\\n        ancestors = defaultdict(list)\\n        for a, b in edges:\\n            ancestors[b].append(a)\\n        \\n        @lru_cache(None)\\n        def dfs(i):\\n            res = set(ancestors[i])\\n            for x in ancestors[i]:\\n                res |= dfs(x)\\n            return res\\n        return [sorted(dfs(i)) for i in range(n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828049,
                "title": "c-easy-topological-sorting",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        map<int,set<int>>mp;\\n        vector<int>adj[n+1];\\n        vector<int>indeg(n+1,0);\\n        for(auto xt : edges)\\n        {\\n            adj[xt[0]].push_back(xt[1]);\\n            indeg[xt[1]]++;\\n        }\\n        queue<int>q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indeg[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int parent = q.front();q.pop();\\n            for(auto child : adj[parent])\\n            {\\n                mp[child].insert(parent);\\n                \\n                for(auto xt : mp[parent])\\n                {\\n                    mp[child].insert(xt);\\n                }\\n                if(--indeg[child]==0)\\n                {\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp.find(i)==mp.end())\\n            {\\n                ans.push_back({});\\n            }\\n            else\\n            {\\n                vector<int> nodes(mp[i].begin(),mp[i].end());\\n                ans.push_back(nodes);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        map<int,set<int>>mp;\\n        vector<int>adj[n+1];\\n        vector<int>indeg(n+1,0);\\n        for(auto xt : edges)\\n        {\\n            adj[xt[0]].push_back(xt[1]);\\n            indeg[xt[1]]++;\\n        }\\n        queue<int>q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indeg[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int parent = q.front();q.pop();\\n            for(auto child : adj[parent])\\n            {\\n                mp[child].insert(parent);\\n                \\n                for(auto xt : mp[parent])\\n                {\\n                    mp[child].insert(xt);\\n                }\\n                if(--indeg[child]==0)\\n                {\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp.find(i)==mp.end())\\n            {\\n                ans.push_back({});\\n            }\\n            else\\n            {\\n                vector<int> nodes(mp[i].begin(),mp[i].end());\\n                ans.push_back(nodes);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822646,
                "title": "javascript-bfs-dfs-topogical-sort",
                "content": "bfs: 588ms (recommend)\\n```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packDG = (g, edges) => { for (const [u, v] of edges) { g[u].push(v); } };\\n\\nconst getAncestors = (n, edges) => {\\n    let g = initializeGraph(n), res = initializeGraph(n);\\n    packDG(g, edges);\\n    for (let i = 0; i < n; i++) { // start from i parent\\n        let q = [i], visit = new Set([i]);\\n        while (q.length) {\\n            let cur = q.shift();\\n            if (cur != i) res[cur].push(i); // each time set ancestor for current node, ignore parent itself\\n            for (const child of g[cur]) {\\n                if (visit.has(child)) continue;\\n                visit.add(child);\\n                q.push(child);\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```\\ntopogical sort 706ms  (recommend)\\n```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packDGInDegree = (g, edges, indegree) => { for (const [u, v] of edges) { g[u].push(v); indegree[v]++; } };\\nconst initializeGraphSet = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push(new Set()); } return g; };\\n\\nlet res;\\nconst getAncestors = (n, edges) => {\\n    let g = initializeGraph(n), indegree = Array(n).fill(0); // record depth of nodes\\n    res = initializeGraphSet(n);\\n    packDGInDegree(g, edges, indegree);\\n    topologicalSort(g, indegree);\\n    return res.map(se => [...se].sort((x, y) => x - y)); // convert inside set to sorted array\\n};\\n\\nconst topologicalSort = (g, indegree) => {\\n    let q = [], n = g.length;\\n    for (let i = 0; i < n; i++) {\\n        if (indegree[i] == 0) q.push(i); // set starting node/top parent/root of depth 0\\n    }\\n    while (q.length) {\\n        let cur = q.shift();\\n        for (const child of g[cur]) { // cur -> child\\n            if (--indegree[child] == 0) q.push(child);\\n            res[child].add(cur); // cur is parent, set ancestor for each child\\n            for (const ancestor of res[cur]) res[child].add(ancestor); // remember to add parent\\'s parents to child\\n        }\\n    }\\n};\\n```\\ndfs: 468ms\\n```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packDGParent = (g, edges) => { for (const [u, v] of edges) { g[v].push(u); } };\\nconst initializeGraphSet = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push(new Set()); } return g; };\\n\\nlet g;\\nconst getAncestors = (n, edges) => {\\n    g = initializeGraph(n);\\n    packDGParent(g, edges);\\n    let res = initializeGraphSet(n), visit = Array(n).fill(false);\\n    for (let i = 0; i < n; i++) {\\n        if (!visit[i]) dfs(i, visit, res);\\n    }\\n    return res.map(se => [...se].sort((x, y) => x - y));\\n};\\n\\nconst dfs = (cur, visit, res) => {\\n    visit[cur] = true;\\n    for (const child of g[cur]) {\\n        if (!visit[child]) dfs(child, visit, res);\\n        res[cur].add(child);\\n        for (const ancestor of res[child]) res[cur].add(ancestor);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packDG = (g, edges) => { for (const [u, v] of edges) { g[u].push(v); } };\\n\\nconst getAncestors = (n, edges) => {\\n    let g = initializeGraph(n), res = initializeGraph(n);\\n    packDG(g, edges);\\n    for (let i = 0; i < n; i++) { // start from i parent\\n        let q = [i], visit = new Set([i]);\\n        while (q.length) {\\n            let cur = q.shift();\\n            if (cur != i) res[cur].push(i); // each time set ancestor for current node, ignore parent itself\\n            for (const child of g[cur]) {\\n                if (visit.has(child)) continue;\\n                visit.add(child);\\n                q.push(child);\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```\n```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packDGInDegree = (g, edges, indegree) => { for (const [u, v] of edges) { g[u].push(v); indegree[v]++; } };\\nconst initializeGraphSet = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push(new Set()); } return g; };\\n\\nlet res;\\nconst getAncestors = (n, edges) => {\\n    let g = initializeGraph(n), indegree = Array(n).fill(0); // record depth of nodes\\n    res = initializeGraphSet(n);\\n    packDGInDegree(g, edges, indegree);\\n    topologicalSort(g, indegree);\\n    return res.map(se => [...se].sort((x, y) => x - y)); // convert inside set to sorted array\\n};\\n\\nconst topologicalSort = (g, indegree) => {\\n    let q = [], n = g.length;\\n    for (let i = 0; i < n; i++) {\\n        if (indegree[i] == 0) q.push(i); // set starting node/top parent/root of depth 0\\n    }\\n    while (q.length) {\\n        let cur = q.shift();\\n        for (const child of g[cur]) { // cur -> child\\n            if (--indegree[child] == 0) q.push(child);\\n            res[child].add(cur); // cur is parent, set ancestor for each child\\n            for (const ancestor of res[cur]) res[child].add(ancestor); // remember to add parent\\'s parents to child\\n        }\\n    }\\n};\\n```\n```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packDGParent = (g, edges) => { for (const [u, v] of edges) { g[v].push(u); } };\\nconst initializeGraphSet = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push(new Set()); } return g; };\\n\\nlet g;\\nconst getAncestors = (n, edges) => {\\n    g = initializeGraph(n);\\n    packDGParent(g, edges);\\n    let res = initializeGraphSet(n), visit = Array(n).fill(false);\\n    for (let i = 0; i < n; i++) {\\n        if (!visit[i]) dfs(i, visit, res);\\n    }\\n    return res.map(se => [...se].sort((x, y) => x - y));\\n};\\n\\nconst dfs = (cur, visit, res) => {\\n    visit[cur] = true;\\n    for (const child of g[cur]) {\\n        if (!visit[child]) dfs(child, visit, res);\\n        res[cur].add(child);\\n        for (const ancestor of res[child]) res[cur].add(ancestor);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822601,
                "title": "javascript-dfs",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number[][]}\\n */\\nvar getAncestors = function(n, edges) {\\n    const arr = Array(n).fill(1).map(el => new Set());\\n    const seen = new Set();\\n    const egs = [];\\n    \\n    for(const [from, to] of edges)\\xA0{\\n        if(egs[from]) egs[from].push(to)\\n        else egs[from] = [to]\\n    }\\n\\n    const dfs = (curr, by) => {\\n        if(curr != by) {\\n            arr[curr].add(by);\\n        }\\n        if(seen.has(curr)) return;\\n        if(!egs[curr]) return;\\n        seen.add(curr)\\n        for(const dest of egs[curr]) {\\n            dfs(dest, by);\\n        }\\n    }\\n    for(let i = 0; i < n; i++) {\\n        dfs(i, i);\\n        seen.clear();\\n    }\\n    \\n    return arr.map(set => {\\n        return Array.from(set);\\n    })\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number[][]}\\n */\\nvar getAncestors = function(n, edges) {\\n    const arr = Array(n).fill(1).map(el => new Set());\\n    const seen = new Set();\\n    const egs = [];\\n    \\n    for(const [from, to] of edges)\\xA0{\\n        if(egs[from]) egs[from].push(to)\\n        else egs[from] = [to]\\n    }\\n\\n    const dfs = (curr, by) => {\\n        if(curr != by) {\\n            arr[curr].add(by);\\n        }\\n        if(seen.has(curr)) return;\\n        if(!egs[curr]) return;\\n        seen.add(curr)\\n        for(const dest of egs[curr]) {\\n            dfs(dest, by);\\n        }\\n    }\\n    for(let i = 0; i < n; i++) {\\n        dfs(i, i);\\n        seen.clear();\\n    }\\n    \\n    return arr.map(set => {\\n        return Array.from(set);\\n    })\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822562,
                "title": "java-dfs-simple-explanation",
                "content": "```\\n/*\\n\\n    First parameter of the dfs is going to fill itself as the ansester of all the \\n    nodes it can traverse in one dfs call\\n\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        ArrayList<Integer>[] graph = new ArrayList[n], res = new ArrayList[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            res[i] = new ArrayList<>();\\n        }\\n        for (int i = 0; i < n; i++) {\\n            boolean[] visited = new boolean[n];\\n            dfs(i, i, graph, visited, res);\\n        }\\n        List<List<Integer>> answer = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            answer.add(res[i]);\\n        }\\n        return answer;\\n    }\\n    \\n    //          originalSource, neighbour, graph, visited\\n    public void dfs(int osrc, int next, ArrayList<Integer>[] graph, boolean[] visited,\\n                   ArrayList<Integer>[] res) {\\n        visited[next] = true;\\n        for (int nbr : graph[next]) {\\n            if (!visited[nbr]) {\\n                res[nbr].add(osrc);\\n                dfs(osrc, nbr, graph, visited, res);\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        ArrayList<Integer>[] graph = new ArrayList[n], res = new ArrayList[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1822415,
                "title": "c-dfs-easy-to-understand",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    void dfs(vector<int>g[], vector<bool>& vis, int node){\\n        if(vis[node]==true) return;\\n        vis[node] = true;\\n        for(auto x:g[node]){\\n            if(vis[x]==false){\\n                dfs(g, vis, x);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int>g[n];\\n        for(auto x:edges){\\n            g[x[1]].push_back(x[0]);\\n        }\\n        vector<vector<int>>ans;\\n        \\n        for(int i=0;i<n;i++){\\n            vector<bool>vis(n, false);\\n            dfs(g, vis, i);\\n            vector<int>v;\\n            for(int j=0;j<n;j++){\\n                if(vis[j]==true and j!=i){\\n                    v.push_back(j);\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    void dfs(vector<int>g[], vector<bool>& vis, int node){\\n        if(vis[node]==true) return;\\n        vis[node] = true;\\n        for(auto x:g[node]){\\n            if(vis[x]==false){\\n                dfs(g, vis, x);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1822330,
                "title": "python3-dfs-on-transposed-graph-help-from-hint-medium",
                "content": "* First tried Kahn\\'s (twice queue traversal) but failed to implement. \\n* Took help from the given hint and coded. Hope It is good.\\n* Please suggest if any improvements/advise. (PS : Started giving contest now to improve my time management)\\n\\n\\n\\t\\t\\tg = defaultdict(list)\\n\\t\\t\\tfor u, v in edges:\\n\\t\\t\\t\\tg[v].append(u)               #reversing the edges in adjacency list\\n\\n\\t\\t\\tdef dfs(node, root):\\n\\t\\t\\t\\tvis[node] = 1\\n\\t\\t\\t\\tfor k in g[node]:\\n\\t\\t\\t\\t\\tif vis[k]==0:\\n\\t\\t\\t\\t\\t\\tans[root].add(k)\\n\\t\\t\\t\\t\\t\\tdfs(k, root)\\n\\n\\t\\t\\tans = [set() for _ in range(n)]\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tvis=[0]*n\\n\\t\\t\\t\\tdfs(i, i)\\n\\t\\t\\treturn [sorted(row) for row in ans]",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "* First tried Kahn\\'s (twice queue traversal) but failed to implement. \\n* Took help from the given hint and coded. Hope It is good.\\n* Please suggest if any improvements/advise. (PS : Started giving contest now to improve my time management)\\n\\n\\n\\t\\t\\tg = defaultdict(list)\\n\\t\\t\\tfor u, v in edges:\\n\\t\\t\\t\\tg[v].append(u)               #reversing the edges in adjacency list\\n\\n\\t\\t\\tdef dfs(node, root):\\n\\t\\t\\t\\tvis[node] = 1\\n\\t\\t\\t\\tfor k in g[node]:\\n\\t\\t\\t\\t\\tif vis[k]==0:\\n\\t\\t\\t\\t\\t\\tans[root].add(k)\\n\\t\\t\\t\\t\\t\\tdfs(k, root)\\n\\n\\t\\t\\tans = [set() for _ in range(n)]\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tvis=[0]*n\\n\\t\\t\\t\\tdfs(i, i)\\n\\t\\t\\treturn [sorted(row) for row in ans]",
                "codeTag": "Python3"
            },
            {
                "id": 1822186,
                "title": "java-reverse-the-graph",
                "content": "**Explanation**\\n\\nIn this approach, we reverse the graph where direction between two node pairs are reversed. Originally if 3 was directing towards 4 then we build a graph where 4 will be directing towards 3. And the same goes for each and every node pair. Now all our ancestors turn into descendants who can be easily recovered using simple Depth First Search.\\n\\n**Time complexity :**   O(n^2 log n)\\n\\n```\\nclass Solution {\\n    \\n    List<List<Integer>> output = new ArrayList<>();\\n    \\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        List<Integer> [] graph = new ArrayList[n];\\n        \\n        for(int i=0;i<n;++i) {\\n            \\n            graph[i] = new ArrayList<>();\\n        }\\n        \\n        for(int [] edge : edges) {\\n        \\n            graph[edge[1]].add(edge[0]);\\n        }\\n        \\n        for(int i=0;i<n;++i) {\\n            \\n            List<Integer> ans = new ArrayList<>();\\n            \\n            dfs(graph,i,new boolean[n],ans);\\n            \\n            Collections.sort(ans);  \\n            output.add(ans);\\n        }\\n        \\n        return output;\\n    }\\n       \\n    public void dfs(List<Integer> [] graph, int vertex, boolean [] visit, List<Integer> ans) {\\n        \\n        for(int curr : graph[vertex]) {\\n            \\n            if(visit[curr]) continue;\\n            \\n            ans.add(curr);\\n            visit[curr] = true;\\n            dfs(graph,curr,visit,ans);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    List<List<Integer>> output = new ArrayList<>();\\n    \\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        List<Integer> [] graph = new ArrayList[n];\\n        \\n        for(int i=0;i<n;++i) {\\n            \\n            graph[i] = new ArrayList<>();\\n        }\\n        \\n        for(int [] edge : edges) {\\n        \\n            graph[edge[1]].add(edge[0]);\\n        }\\n        \\n        for(int i=0;i<n;++i) {\\n            \\n            List<Integer> ans = new ArrayList<>();\\n            \\n            dfs(graph,i,new boolean[n],ans);\\n            \\n            Collections.sort(ans);  \\n            output.add(ans);\\n        }\\n        \\n        return output;\\n    }\\n       \\n    public void dfs(List<Integer> [] graph, int vertex, boolean [] visit, List<Integer> ans) {\\n        \\n        for(int curr : graph[vertex]) {\\n            \\n            if(visit[curr]) continue;\\n            \\n            ans.add(curr);\\n            visit[curr] = true;\\n            dfs(graph,curr,visit,ans);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822164,
                "title": "swift-topological-sort",
                "content": "This is a classical Topolical sort problem. \\n* Build `graph` from `edges`\\n* Start with all nodes `u` which don\\'t have any incoming edges\\n* Visit all children of node `u`, for each child `v`, insert `u` as well as `ancestors[u]` as ancestors of `v`. We need to use `Set` to avoid any duplication\\n* Repeat until we\\'ve already processed all nodes \\n* Go over each node and sort the list of ancestors as per the problem statement\\n\\n**Swift**\\n```swift\\nclass Solution {\\n  func getAncestors(_ n: Int, _ edges: [[Int]]) -> [[Int]] {\\n    var graph = [Int: [Int]]()\\n    var inDegree = Array(repeating: 0, count: n)\\n    for edge in edges {\\n      let (u, v) = (edge[0], edge[1])\\n      graph[u, default: []].append(v)\\n      inDegree[v] += 1\\n    }\\n    \\n    var ancestors = Array(repeating: Set<Int>(), count: n)\\n    var stack = [Int]()\\n    for u in 0..<n where inDegree[u] == 0 {\\n      stack.append(u)\\n    }\\n    \\n    while !stack.isEmpty {\\n      let u = stack.removeLast()\\n      for v in graph[u, default: []] {\\n        inDegree[v] -= 1 \\n        if inDegree[v] == 0 {\\n          stack.append(v)\\n        }\\n          \\n        ancestors[v].insert(u)\\n        ancestors[v].formUnion(ancestors[u])\\n      }\\n    }\\n    \\n    var res = [[Int]]()\\n    for u in 0..<n {\\n      res.append(ancestors[u].sorted())\\n    }\\n    \\n    return res\\n  }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```swift\\nclass Solution {\\n  func getAncestors(_ n: Int, _ edges: [[Int]]) -> [[Int]] {\\n    var graph = [Int: [Int]]()\\n    var inDegree = Array(repeating: 0, count: n)\\n    for edge in edges {\\n      let (u, v) = (edge[0], edge[1])\\n      graph[u, default: []].append(v)\\n      inDegree[v] += 1\\n    }\\n    \\n    var ancestors = Array(repeating: Set<Int>(), count: n)\\n    var stack = [Int]()\\n    for u in 0..<n where inDegree[u] == 0 {\\n      stack.append(u)\\n    }\\n    \\n    while !stack.isEmpty {\\n      let u = stack.removeLast()\\n      for v in graph[u, default: []] {\\n        inDegree[v] -= 1 \\n        if inDegree[v] == 0 {\\n          stack.append(v)\\n        }\\n          \\n        ancestors[v].insert(u)\\n        ancestors[v].formUnion(ancestors[u])\\n      }\\n    }\\n    \\n    var res = [[Int]]()\\n    for u in 0..<n {\\n      res.append(ancestors[u].sorted())\\n    }\\n    \\n    return res\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822134,
                "title": "all-ancestors-of-a-node-in-dag-c-bfs-topological-sorting-simple-clean-code",
                "content": "```\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        int m = edges.size();\\n        \\n        vector<int> adj[n];\\n        \\n        for(int i=0; i<m; i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n        }\\n        \\n        vector<int> indegree(n);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(auto u : adj[i])\\n            {\\n                indegree[u]++;\\n            }\\n        }\\n        \\n        queue<int> q;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(indegree[i] == 0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        \\n        vector<unordered_set<int>> ump(n);\\n        \\n        while(!q.empty())\\n        {\\n            int  i = q.front();\\n            \\n            for(auto u : adj[i])\\n            {\\n                ump[u].insert(i);\\n                \\n                for(auto v : ump[i])\\n                {\\n                    ump[u].insert(v);\\n                }\\n                \\n                \\n                \\n                indegree[u]--;\\n                \\n                if(indegree[u] == 0)\\n                {\\n                    q.push(u);\\n                }\\n            }\\n            \\n            q.pop();\\n        }\\n        \\n        vector<vector<int>> res;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            vector<int> temp;\\n            \\n            for(auto v : ump[i])\\n            {\\n                temp.push_back(v);\\n            }\\n            \\n            sort(temp.begin(), temp.end());\\n            \\n            res.push_back(temp);\\n        }\\n        \\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort",
                    "Ordered Set"
                ],
                "code": "```\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        int m = edges.size();\\n        \\n        vector<int> adj[n];\\n        \\n        for(int i=0; i<m; i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n        }\\n        \\n        vector<int> indegree(n);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(auto u : adj[i])\\n            {\\n                indegree[u]++;\\n            }\\n        }\\n        \\n        queue<int> q;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(indegree[i] == 0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        \\n        vector<unordered_set<int>> ump(n);\\n        \\n        while(!q.empty())\\n        {\\n            int  i = q.front();\\n            \\n            for(auto u : adj[i])\\n            {\\n                ump[u].insert(i);\\n                \\n                for(auto v : ump[i])\\n                {\\n                    ump[u].insert(v);\\n                }\\n                \\n                \\n                \\n                indegree[u]--;\\n                \\n                if(indegree[u] == 0)\\n                {\\n                    q.push(u);\\n                }\\n            }\\n            \\n            q.pop();\\n        }\\n        \\n        vector<vector<int>> res;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            vector<int> temp;\\n            \\n            for(auto v : ump[i])\\n            {\\n                temp.push_back(v);\\n            }\\n            \\n            sort(temp.begin(), temp.end());\\n            \\n            res.push_back(temp);\\n        }\\n        \\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822020,
                "title": "dfs-memorization-c-complexity-analysis",
                "content": "## Solution\\n\\n#### Logic\\n\\nParent -> Child (TLE)\\nChild -> Parent (Accepted)\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    unordered_map<int, set<int>> me;\\n    set<int> dfs(map<int, vector<int>> &graph, int start) {\\n        if (me.find(start) != me.end()) {\\n            return me[start];\\n        }\\n        set<int> parents;\\n        for (int i = 0; i < graph[start].size(); i++) {\\n            set<int> temp;\\n            parents.insert(graph[start][i]);\\n            temp = dfs(graph, graph[start][i]);\\n            for (auto x : temp) {\\n                parents.insert(x);\\n            }\\n        }\\n        me[start] = parents;\\n        return parents;\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        map<int, vector<int>> graph;\\n        vector<vector<int>> sol;\\n\\n        for (int i = 0; i < edges.size(); i++) {\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            set<int> temp = dfs(graph, i);\\n            sol.push_back({temp.begin(), temp.end()});\\n        }\\n        \\n        \\n        return sol;\\n    }\\n};\\n```\\n\\n## Complexity\\n\\n __Time Complexity__: O(total_edges * total_edges), because we are using Depth first search. Actully it will be less as we are also using memorization.\\n \\n __Space Complexity__: O(total_edges * total_edges), becuase we are storing solution to return them also we are making graph in inverted manner so that will also add O(total_edges * total_edges). So 2 * O(total_edges * total_edges) = O(total_edges * total_edges)\\n\\n<br>\\n<br>\\n<br>\\n\\n<p>\\n\\n __Check out all [my](https://leetcode.com/siddp6/) recent solutions [here](https://github.com/sidd6p/LeetCode)__\\n\\n \\n __Feel Free to Ask Doubts\\nAnd Please Share Some Suggestions\\nHAPPY CODING :)__\\n\\n</p>\\n\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    unordered_map<int, set<int>> me;\\n    set<int> dfs(map<int, vector<int>> &graph, int start) {\\n        if (me.find(start) != me.end()) {\\n            return me[start];\\n        }\\n        set<int> parents;\\n        for (int i = 0; i < graph[start].size(); i++) {\\n            set<int> temp;\\n            parents.insert(graph[start][i]);\\n            temp = dfs(graph, graph[start][i]);\\n            for (auto x : temp) {\\n                parents.insert(x);\\n            }\\n        }\\n        me[start] = parents;\\n        return parents;\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        map<int, vector<int>> graph;\\n        vector<vector<int>> sol;\\n\\n        for (int i = 0; i < edges.size(); i++) {\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            set<int> temp = dfs(graph, i);\\n            sol.push_back({temp.begin(), temp.end()});\\n        }\\n        \\n        \\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989518,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- O(N*N)\\n\\n- Space complexity:\\n- O(N*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,vector<int>>mp;\\n    void fill(vector<vector<int>>& edges){\\n        for(auto i:edges){\\n            int u=i[0],v=i[1];\\n            mp[v].push_back(u);\\n        }\\n        return;\\n    }\\n    void dfs(int node,vector<bool>&vis,set<int>&ans){\\n        int kk=node;\\n        if(mp.find(node)==mp.end()){\\n            ans.insert(node);\\n            return;\\n        }\\n        vis[node]=true;\\n        ans.insert(node);\\n\\n        for(auto i:mp[node]){\\n            if(!vis[i]) dfs(i,vis,ans);\\n        }\\n        return;\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        mp.clear();\\n        fill(edges);\\n        \\n        vector<vector<int>>ans;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp.find(i)==mp.end()){\\n                ans.push_back({});\\n                continue;\\n            }\\n            vector<bool>vis(n+1,false);\\n            set<int>res;\\n\\n            dfs(i,vis,res);\\n\\n            if(res.find(i)!=res.end()) res.erase(i);\\n\\n            vector<int>temp(res.begin(),res.end());\\n            \\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,vector<int>>mp;\\n    void fill(vector<vector<int>>& edges){\\n        for(auto i:edges){\\n            int u=i[0],v=i[1];\\n            mp[v].push_back(u);\\n        }\\n        return;\\n    }\\n    void dfs(int node,vector<bool>&vis,set<int>&ans){\\n        int kk=node;\\n        if(mp.find(node)==mp.end()){\\n            ans.insert(node);\\n            return;\\n        }\\n        vis[node]=true;\\n        ans.insert(node);\\n\\n        for(auto i:mp[node]){\\n            if(!vis[i]) dfs(i,vis,ans);\\n        }\\n        return;\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        mp.clear();\\n        fill(edges);\\n        \\n        vector<vector<int>>ans;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp.find(i)==mp.end()){\\n                ans.push_back({});\\n                continue;\\n            }\\n            vector<bool>vis(n+1,false);\\n            set<int>res;\\n\\n            dfs(i,vis,res);\\n\\n            if(res.find(i)!=res.end()) res.erase(i);\\n\\n            vector<int>temp(res.begin(),res.end());\\n            \\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775408,
                "title": "python-simple-bfs-solution-with-explanation-o-v-e",
                "content": "# Intuition\\nThis is a topoligical sort problem. Here we use the famous Kahn\\'s algo. \\n\\n# Approach\\n1) Like most of the graphs problem first we create and adjacency map and in_degree dictionary.\\n2) Then we create a queue and add the nodes with no parent (in_degree[node]==0 or node not in_degree), we add that to the queue.\\n3) We create a list of sets, which set_i contains the ancestors for node i\\n4) we run a BFS to reduce the in_degree of each node we visit and once the the degree is zero we add that to the queue. Also, at each step, we update the set_i. \\n\\n# Complexity\\n- Time complexity: O(V+E)\\n\\n- Space complexity: O(V+E) not including the space we need for the output. \\n# Code\\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        adj_map = defaultdict(defaultdict)\\n        in_degree = defaultdict(int)\\n        for beg, end in edges:\\n            adj_map[beg][end]=None\\n            in_degree[end]+=1\\n\\n        q = deque()\\n        for node in range(n):\\n            if node not in in_degree:\\n                q.append(node)\\n\\n        ans = [set() for _ in range(n)]\\n        while q:\\n            node = q.popleft()\\n            for child in adj_map[node]:\\n                in_degree[child]-=1\\n                if in_degree[child]==0:\\n                    q.append(child)\\n                ans[child].update(ans[node] | {node})\\n        return [sorted(list(i)) for i in ans]\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        adj_map = defaultdict(defaultdict)\\n        in_degree = defaultdict(int)\\n        for beg, end in edges:\\n            adj_map[beg][end]=None\\n            in_degree[end]+=1\\n\\n        q = deque()\\n        for node in range(n):\\n            if node not in in_degree:\\n                q.append(node)\\n\\n        ans = [set() for _ in range(n)]\\n        while q:\\n            node = q.popleft()\\n            for child in adj_map[node]:\\n                in_degree[child]-=1\\n                if in_degree[child]==0:\\n                    q.append(child)\\n                ans[child].update(ans[node] | {node})\\n        return [sorted(list(i)) for i in ans]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736211,
                "title": "dfs-using-hashset-and-hashmaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDepth First Search.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nReverse the graph and check its adjacency list. If it\\'s not visited apply recursion on that (adjnode) and append it the set of the current call. If it is visited find its corresponding set in the map and append it to the set of the current call.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(V+E)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(V+E)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,set<int>> m ;\\n\\n    set<int> dfs(int node,vector<vector<int>> &adj,vector<int>&visited){\\n        \\n        set<int> s;\\n        visited[node]=1;\\n       \\n        s.insert(node);\\n\\n        for(auto adjnode : adj[node]){\\n            if (!visited[adjnode]){\\n                set<int> back = dfs(adjnode,adj,visited);\\n                s.insert(back.begin(),back.end());\\n            }\\n            else{\\n                set<int> vis = m[adjnode];\\n                s.insert(vis.begin(),vis.end());\\n            }\\n        }\\n        m[node]=s;\\n        return s;\\n    }\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n         vector<vector<int>> adj(n);\\n\\n         for (auto i : edges){\\n             adj[i[1]].push_back(i[0]);\\n         }\\n\\n         vector<vector<int>> ans;\\n\\n         vector<int>visited(n,0);\\n\\n        for(int i  = 0 ;  i <n ; i++){\\n            if (!visited[i]){\\n                dfs(i,adj,visited);\\n            }\\n        }\\n\\n        for (int i = 0 ; i < n ; i++){\\n            vector<int> temp;\\n            for(int k : m[i]){\\n               if ( k!=i) \\n                temp.push_back(k);\\n            }\\n            ans.push_back(temp);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,set<int>> m ;\\n\\n    set<int> dfs(int node,vector<vector<int>> &adj,vector<int>&visited){\\n        \\n        set<int> s;\\n        visited[node]=1;\\n       \\n        s.insert(node);\\n\\n        for(auto adjnode : adj[node]){\\n            if (!visited[adjnode]){\\n                set<int> back = dfs(adjnode,adj,visited);\\n                s.insert(back.begin(),back.end());\\n            }\\n            else{\\n                set<int> vis = m[adjnode];\\n                s.insert(vis.begin(),vis.end());\\n            }\\n        }\\n        m[node]=s;\\n        return s;\\n    }\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n         vector<vector<int>> adj(n);\\n\\n         for (auto i : edges){\\n             adj[i[1]].push_back(i[0]);\\n         }\\n\\n         vector<vector<int>> ans;\\n\\n         vector<int>visited(n,0);\\n\\n        for(int i  = 0 ;  i <n ; i++){\\n            if (!visited[i]){\\n                dfs(i,adj,visited);\\n            }\\n        }\\n\\n        for (int i = 0 ; i < n ; i++){\\n            vector<int> temp;\\n            for(int k : m[i]){\\n               if ( k!=i) \\n                temp.push_back(k);\\n            }\\n            ans.push_back(temp);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669965,
                "title": "javascript-2192-all-ancestors-of-a-node-in-a-directed-acyclic-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n...\\nvariable names\\n...\\n**p = parent\\nps = parent set\\naps = array of parent set\\ngp = grand parent**\\n\\n...\\nalgorithm\\n...\\n**1 create parents\\n2 add grand parents to parents\\n3 sort & return\\n...**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar getAncestors = function (n, ed) {\\n  let aps = Array(n).fill().map(() => new Set())\\n  for (let [u, v] of ed) {\\n    aps[v].add(u)\\n  }\\n  for (let ps of aps) {\\n    for (let p of ps) {\\n      for (let gp of aps[p]) {\\n        ps.add(gp)\\n      }\\n    }\\n  }\\n  return aps.map(ps => [...ps].sort((a, b) => a - b))\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getAncestors = function (n, ed) {\\n  let aps = Array(n).fill().map(() => new Set())\\n  for (let [u, v] of ed) {\\n    aps[v].add(u)\\n  }\\n  for (let ps of aps) {\\n    for (let p of ps) {\\n      for (let gp of aps[p]) {\\n        ps.add(gp)\\n      }\\n    }\\n  }\\n  return aps.map(ps => [...ps].sort((a, b) => a - b))\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3552179,
                "title": "brute-force-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n void dfs(int i,vector<int>&vis,unordered_map<int,vector<int>>&adj,vector<vector<int>>&ans)\\n {\\n     vis[i]=1;\\n     unordered_map<int,int>h;\\n     for(auto e:adj[i])\\n     {\\n         if(vis[e]==0)\\n         dfs(e,vis,adj,ans);\\n          if(h.count(e)==0)\\n              ans[i].push_back(e);\\n              h[e]++;\\n\\n        for(auto f:ans[e])\\n          {\\n              if(h.count(f)==0)\\n              {\\n                  ans[i].push_back(f);\\n                  h[f]++;\\n              }\\n          }\\n\\n     }\\n }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>>adj;\\n        for(auto e:edges)\\n        {\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<int>vis(n,0);\\n        vector<vector<int>>ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0)\\n             dfs(i,vis,adj,ans);\\n\\n        }\\n        for(auto &e:ans)\\n         sort(e.begin(),e.end());\\n        return(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n void dfs(int i,vector<int>&vis,unordered_map<int,vector<int>>&adj,vector<vector<int>>&ans)\\n {\\n     vis[i]=1;\\n     unordered_map<int,int>h;\\n     for(auto e:adj[i])\\n     {\\n         if(vis[e]==0)\\n         dfs(e,vis,adj,ans);\\n          if(h.count(e)==0)\\n              ans[i].push_back(e);\\n              h[e]++;\\n\\n        for(auto f:ans[e])\\n          {\\n              if(h.count(f)==0)\\n              {\\n                  ans[i].push_back(f);\\n                  h[f]++;\\n              }\\n          }\\n\\n     }\\n }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>>adj;\\n        for(auto e:edges)\\n        {\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<int>vis(n,0);\\n        vector<vector<int>>ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0)\\n             dfs(i,vis,adj,ans);\\n\\n        }\\n        for(auto &e:ans)\\n         sort(e.begin(),e.end());\\n        return(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443750,
                "title": "java-dfs-beats-94-o-n-2",
                "content": "#### Time Complexity : O(n^2 + n*log(n))\\n#### Space Complexity : O(n^2)\\n\\n\\n``` java []\\nclass Solution {\\n    boolean[] vis;\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> res = new ArrayList<>(n);\\n        \\n        ArrayList<Integer>[] a = new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            a[i] = new ArrayList<>();\\n            res.add(new ArrayList<>());\\n        }\\n        for(int[] x:edges){\\n            a[x[1]].add(x[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            boolean[] vis = new boolean[n];\\n            vis[i] = true;\\n            dfs(a,i,res.get(i),vis);\\n            Collections.sort(res.get(i));\\n        }\\n        return res;\\n    }\\n\\n\\n    private void dfs(ArrayList<Integer>[] a,int curr, List<Integer> temp,boolean[] vis){\\n        for(int x:a[curr]){\\n            if(!vis[x]){\\n                vis[x] = true;\\n                temp.add(x);\\n                dfs(a,x,temp,vis);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    boolean[] vis;\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> res = new ArrayList<>(n);\\n        \\n        ArrayList<Integer>[] a = new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            a[i] = new ArrayList<>();\\n            res.add(new ArrayList<>());\\n        }\\n        for(int[] x:edges){\\n            a[x[1]].add(x[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            boolean[] vis = new boolean[n];\\n            vis[i] = true;\\n            dfs(a,i,res.get(i),vis);\\n            Collections.sort(res.get(i));\\n        }\\n        return res;\\n    }\\n\\n\\n    private void dfs(ArrayList<Integer>[] a,int curr, List<Integer> temp,boolean[] vis){\\n        for(int x:a[curr]){\\n            if(!vis[x]){\\n                vis[x] = true;\\n                temp.add(x);\\n                dfs(a,x,temp,vis);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357409,
                "title": "c-4-approaches-comparison-analysis-of-dfs-bfs-w-w-o-visited-array",
                "content": "## Approach1 - DFS w/ visit array\\nThe main idea is to traverse from one ancestor and reach out to all its descendants.\\n1. Iterating through`edges`and store the directly linked child of each ancestor node. \\n2. Traversing from an ancestor`src`to reach every descendants; While in one search,`visit`array is used to record the descendants that had been visited.\\n3. Iterating through the`visit`descendants array and push the ancestor`src`to each descendant array, and since the iterator`src` start with`0`and end with`n-1`, the anscestor array in`ans`would be in order of smallest to largest.\\n### Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>> &adj, vector<bool> &visit, int src) {\\n        visit[src] = 1;\\n        for (auto n : adj[src])\\n            if (!visit[n])\\n                dfs(adj, visit, n);\\n    }\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans (n);\\n        vector<vector<int>> adj (n, vector<int>{});//store the descendants\\n        for (auto e : edges)\\n            adj[e[0]].push_back(e[1]);\\n        for (int src = 0; src < n; src++) {\\n            vector<bool> visit (n, 0);//visited descendants in this dfs search path\\n            dfs(adj, visit, src);//traverse the path from ancestor_src\\n            visit[src] = 0;//excluding ancestor itself\\n            for (int child = 0; child < n; child++)\\n                if (visit[child])\\n                    ans[child].push_back(src);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n### Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n^2)$$, in worst case, every node is pointed by all the other nodes except its parent, which implies (n - 1) + (n - 2) + ... + 1\\n## Approach2 - DFS w/o visit array\\nIn approach1, a`visit`array is used to remember the descendants that had been visited within one DFS traversal path. Since the ancestor is fixed in each DFS traversal, only the descendant may be repeatedly vistied. That is, the`visit`array wouldn\\'t be necessary as long as the ancestor array of each descendants is being tracked, which is recorded in`ans`.\\nThis can be done by checking the last ancestor of each descendant array. For example, if the ancestor already exists in`ans[descendant_i]`, skip recording this ancestor and stop traversing the descendants of`descendant_i`since it had been visited within this DFS traversal. And the ancestor of DFS traversal iterates from`0`to`n-1`, the ancestor array in`ans`would also be in order.\\n### Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>> &adj, vector<vector<int>> &ans, int src, const int &ancestor) {\\n        for (auto i : adj[src])\\n            if (ans[i].empty() || ans[i].back() != ancestor) {//check the last ancestor in one dfs traversal to avoid duplicates\\n                ans[i].push_back(ancestor);\\n                dfs(adj, ans, i, ancestor);\\n            }\\n    }\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans(n), adj(n);//adj store the descendants\\n        for (auto e : edges)\\n            adj[e[0]].push_back(e[1]);\\n        for (int src = 0; src < n; src++)\\n            dfs(adj, ans, src, src);//traverse the path from ancestor_src\\n        return ans;\\n    }\\n};\\n```\\n### Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n^2)$$\\n## Approach3 - BFS w/ visit array\\nThe main idea is just like the hint suggested, reverse the direction of`edges`and store the directly linked ancestors of each node. Starting a traversal from a descendant node to collect all its ancestors, this can be done by`queue`.\\n1. Iterating through`edges`and store the directly linked ancestor of each descendant node.\\n2. Using a queue`bfs`to perform BFS for each descendant and collecting the visited ancestors by using a`visit`array within one traversal.\\n3. If the ancestor was not yet visited, push it into the queue`bfs`.\\n4. Checking whether the queue empty or not, if not empty, keep traversing unitl there is no ancestor waiting to be traversed.\\n5. For each descendant, check the`visit`array from index`0`to`n-1`to see if the ancestor had been visited within this BFS traversal and record it in`ans`.\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans (n);\\n        vector<vector<int>> adj (n, vector<int>{});//store the ancestors\\n        for (auto e : edges)\\n            adj[e[1]].push_back(e[0]);\\n        for (int dec = 0; dec < n; dec++) {\\n            vector<bool> visit (n, 0);//visited ancestor in this bfs search path\\n            queue<int> bfs;\\n            bfs.push(dec);\\n            while (!bfs.empty()) {\\n                if (!visit[bfs.front()]) {\\n                    visit[bfs.front()] = 1;\\n                    for (auto n : adj[bfs.front()])//find grand parents\\n                        if (!visit[n])\\n                            bfs.push(n);\\n                }\\n                bfs.pop();\\n            }\\n            visit[dec] = 0;//excluding descendant itself\\n            for (int anc = 0; anc < n; anc++)\\n                if (visit[anc])\\n                    ans[dec].push_back(anc);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n### Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n^2)$$\\n## Approach4 - BFS w/o visit array\\nThe BFS can also be done without a visit array. Since storing only direct ancestor of each node in`adj`, there are some operations to do for checking whether the ancestor had been repeatedly visited or not. Also, the ancestor might be in any order during the ancestor collecting process, the ancestor index shall be sorted after collection.\\n### Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans (n);\\n        vector<vector<int>> adj (n, vector<int>{});//store the ancestors\\n        for (auto e : edges)\\n            adj[e[1]].push_back(e[0]);\\n        for (int dec = 0; dec < n; dec++) {\\n            queue<int> bfs;\\n            bfs.push(dec);\\n            while (!bfs.empty()) {\\n                for (auto anc : adj[bfs.front()]) {//find grand parents\\n                    if (find(ans[dec].begin(), ans[dec].end(), anc) == ans[dec].end()) {//avoid the same ancestor\\n                        ans[dec].push_back(anc);\\n                        bfs.push(anc);\\n                    }\\n                }\\n                bfs.pop();\\n            }\\n            sort(ans[dec].begin(), ans[dec].end());\\n        }\\n        return ans;\\n    }\\n};\\n```\\n### Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n^2)$$\\n##  Summary\\n- Runtime: A2 < A1 < A3 << A4\\n- Memory usage: A2 < A1 < A4 < A3\\n\\nThe overall runtime of using queue to do BFS is longer than recursively doing DFS; And the runtime of BFS without a visit array is explicitly much longer than BFS with a visit array, this is due to the result of doing find() of every ancestor for checking duplicates and sort() to sort the index of ancestor for each descendant.\\n\\nIf there\\'s any mistake or suggestion, please comment. And if you think my post really helps, please upvote, thanks!",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>> &adj, vector<bool> &visit, int src) {\\n        visit[src] = 1;\\n        for (auto n : adj[src])\\n            if (!visit[n])\\n                dfs(adj, visit, n);\\n    }\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans (n);\\n        vector<vector<int>> adj (n, vector<int>{});//store the descendants\\n        for (auto e : edges)\\n            adj[e[0]].push_back(e[1]);\\n        for (int src = 0; src < n; src++) {\\n            vector<bool> visit (n, 0);//visited descendants in this dfs search path\\n            dfs(adj, visit, src);//traverse the path from ancestor_src\\n            visit[src] = 0;//excluding ancestor itself\\n            for (int child = 0; child < n; child++)\\n                if (visit[child])\\n                    ans[child].push_back(src);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>> &adj, vector<vector<int>> &ans, int src, const int &ancestor) {\\n        for (auto i : adj[src])\\n            if (ans[i].empty() || ans[i].back() != ancestor) {//check the last ancestor in one dfs traversal to avoid duplicates\\n                ans[i].push_back(ancestor);\\n                dfs(adj, ans, i, ancestor);\\n            }\\n    }\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans(n), adj(n);//adj store the descendants\\n        for (auto e : edges)\\n            adj[e[0]].push_back(e[1]);\\n        for (int src = 0; src < n; src++)\\n            dfs(adj, ans, src, src);//traverse the path from ancestor_src\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans (n);\\n        vector<vector<int>> adj (n, vector<int>{});//store the ancestors\\n        for (auto e : edges)\\n            adj[e[1]].push_back(e[0]);\\n        for (int dec = 0; dec < n; dec++) {\\n            vector<bool> visit (n, 0);//visited ancestor in this bfs search path\\n            queue<int> bfs;\\n            bfs.push(dec);\\n            while (!bfs.empty()) {\\n                if (!visit[bfs.front()]) {\\n                    visit[bfs.front()] = 1;\\n                    for (auto n : adj[bfs.front()])//find grand parents\\n                        if (!visit[n])\\n                            bfs.push(n);\\n                }\\n                bfs.pop();\\n            }\\n            visit[dec] = 0;//excluding descendant itself\\n            for (int anc = 0; anc < n; anc++)\\n                if (visit[anc])\\n                    ans[dec].push_back(anc);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans (n);\\n        vector<vector<int>> adj (n, vector<int>{});//store the ancestors\\n        for (auto e : edges)\\n            adj[e[1]].push_back(e[0]);\\n        for (int dec = 0; dec < n; dec++) {\\n            queue<int> bfs;\\n            bfs.push(dec);\\n            while (!bfs.empty()) {\\n                for (auto anc : adj[bfs.front()]) {//find grand parents\\n                    if (find(ans[dec].begin(), ans[dec].end(), anc) == ans[dec].end()) {//avoid the same ancestor\\n                        ans[dec].push_back(anc);\\n                        bfs.push(anc);\\n                    }\\n                }\\n                bfs.pop();\\n            }\\n            sort(ans[dec].begin(), ans[dec].end());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331671,
                "title": "easy-peasy-93-beats-beginner-using-dfs",
                "content": "\\nWhat we are doing here ?\\n\\nSuppose we have tree :-\\n\\n0           2      1       7 \\n        3             6\\n    4      5\\n\\n\\nso 2 is connected to 3 ans 4, 1 is connected to 4 and 6, 3 is connected to 4 and 5. 7 is isolated.\\n\\nwe have to traverse dfs on every node.\\n\\n2 -> 3\\n3 -> 4,5\\n\\nwe have make result = {}, and push parent node to its adjacent nodes.\\n\\nand make every nodes in result with empty array, \\nfor each i in [0...n]\\nresult[i] = []\\n\\nIteration: 1, (0 is isolated),\\nresult[0] = []\\n\\n\\nIteration: 2, (1)\\n1 -> 6,\\nresult[6] = 1\\n\\nIteration: 3, (2)\\n2 -> 3\\nresult[3] = [2]\\n\\n3 is connected with 4 and 5\\nresult[4] = [2]\\nresult[5] = [2]\\n\\nIteration: 4, (3)\\n3 -> 4,5\\nresult[4] = [2, 3]\\nresult[5] = [2, 3]\\n\\nIteration: 5, (4)\\n4 is not connected with any child nodes\\nresult[4] = [2, 3]\\n\\nIteration: 6, (5)\\nresult[5] = [2, 3]\\n\\nIteration: 7, (6)\\n6 is not connected to any child nodes\\nresult[6] = [1]\\n\\nIteration: 8, (7)\\n7 is isolated so,\\nresult[7] = []\\n\\n\\nso at the end we have resultant result =\\n{0: [], 1: [], 2: [], 3: [], 4: [2, 3], 5: [2, 3], 6: [1], 7: []};\\n\\n\\n# Please do upvote if you like the solution. please consider effort also.\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number[][]}\\n */\\nvar getAncestors = function(n, edges) {\\n    let adjList = {}, result = {};\\n\\n    for(let [s, d] of edges) {\\n        if(!adjList[s]) adjList[s] = [];\\n        adjList[s].push(d);\\n    }\\n\\n    for(let i = 0; i < n; i++) {\\n        result[i] = [];\\n    }\\n\\n\\n    var dfs = function(s, p) {\\n        let count = [];\\n        for(let d of adjList[s] || []) {\\n            if(!visited[d]) {\\n                visited[d] = true\\n                result[d].push(p);\\n                dfs(d, p);\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    \\n    for(let i = 0; i < n; i++) {\\n        visited = {[i]: true};\\n        dfs(i, i)\\n    }\\n\\n    return Object.values(result);\\n};```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number[][]}\\n */\\nvar getAncestors = function(n, edges) {\\n    let adjList = {}, result = {};\\n\\n    for(let [s, d] of edges) {\\n        if(!adjList[s]) adjList[s] = [];\\n        adjList[s].push(d);\\n    }\\n\\n    for(let i = 0; i < n; i++) {\\n        result[i] = [];\\n    }\\n\\n\\n    var dfs = function(s, p) {\\n        let count = [];\\n        for(let d of adjList[s] || []) {\\n            if(!visited[d]) {\\n                visited[d] = true\\n                result[d].push(p);\\n                dfs(d, p);\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    \\n    for(let i = 0; i < n; i++) {\\n        visited = {[i]: true};\\n        dfs(i, i)\\n    }\\n\\n    return Object.values(result);\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 3173952,
                "title": "python-dfs-memoization-w-o-lru-cache",
                "content": "- solution w/o @lru_cache\\n```\\n\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        adjacents = collections.defaultdict(list)\\n        for u, v in edges:\\n            adjacents[v].append(u)\\n\\n        memo = {}\\n        def dfs(node):\\n            if node in memo:\\n                return memo[node]\\n\\n            ancestors = set()\\n            for neighbor in adjacents[node]:\\n                ancestors.add(neighbor)\\n                for n in dfs(neighbor):\\n                    ancestors.add(n)\\n            \\n            memo[node] = ancestors\\n            return ancestors\\n\\n        res = []\\n        for i in range(n):\\n            ancestors = dfs(i)\\n            res.append(sorted(list(ancestors)))\\n\\n        return res\\n```\\n\\n\\n- solution w/ @lru_cache\\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        adjacents = collections.defaultdict(list)\\n        for u, v in edges:\\n            adjacents[v].append(u)\\n\\n        @lru_cache(None)\\n        def dfs(node):\\n            ancestors = set()\\n            for neighbor in adjacents[node]:\\n                ancestors.add(neighbor)\\n                temp = dfs(neighbor)\\n                for n in temp:\\n                    ancestors.add(n)\\n\\n            return ancestors\\n\\n        res = []\\n        for i in range(n):\\n            ancestors = dfs(i)\\n            res.append(sorted(list(ancestors)))\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        adjacents = collections.defaultdict(list)\\n        for u, v in edges:\\n            adjacents[v].append(u)\\n\\n        memo = {}\\n        def dfs(node):\\n            if node in memo:\\n                return memo[node]\\n\\n            ancestors = set()\\n            for neighbor in adjacents[node]:\\n                ancestors.add(neighbor)\\n                for n in dfs(neighbor):\\n                    ancestors.add(n)\\n            \\n            memo[node] = ancestors\\n            return ancestors\\n\\n        res = []\\n        for i in range(n):\\n            ancestors = dfs(i)\\n            res.append(sorted(list(ancestors)))\\n\\n        return res\\n```\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        adjacents = collections.defaultdict(list)\\n        for u, v in edges:\\n            adjacents[v].append(u)\\n\\n        @lru_cache(None)\\n        def dfs(node):\\n            ancestors = set()\\n            for neighbor in adjacents[node]:\\n                ancestors.add(neighbor)\\n                temp = dfs(neighbor)\\n                for n in temp:\\n                    ancestors.add(n)\\n\\n            return ancestors\\n\\n        res = []\\n        for i in range(n):\\n            ancestors = dfs(i)\\n            res.append(sorted(list(ancestors)))\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883534,
                "title": "bfs-n-2-iterative-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we sort the result array at the end, it will result in a (n^2)*log(n) time complexity. \\nWe want to reach a n^2 time complexity, and for that we need the BFS to build a sorted result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo build the sorted result using iterative BFS, we set a list of starting_points containing all the nodes. For each of those starting points, we will conduct the BFS, look through all their descendant and add the starting point as ancestor for them.\\n\\n-> We begin with starting_point = 0, adding 0 as ancestor for each of its descendant\\n-> We continue with starting_point = 1, adding 1 as ancestor for each of its descendant\\n->... until starting_point = n.\\nIt results in getting all ancestors array sorted.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\nFor each node, we are going through all their descendants.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\nWe have \\'starting_points\\' containing each node, we maintain \\'level\\' in the starting_points loop and maintain \\'new_level\\' in level loop.\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def getAncestors(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        ancestors = [[] for _ in range(n)]\\n        \\n        adjacency_list = defaultdict(list)\\n        for source, destination in edges:\\n            adjacency_list[source].append(destination)\\n            \\n        starting_points = [(node, node) for node in reversed(range(n))]\\n        visited = set()\\n        while starting_points:\\n            level = [starting_points.pop()]\\n            while level:\\n                new_level = []\\n                for node, ancestor in level:\\n                    if (node, ancestor) not in visited:\\n                        visited.add((node, ancestor))\\n                        if node != ancestor:\\n                            ancestors[node].append(ancestor)\\n                        for destination in adjacency_list[node]:\\n                            new_level.append((destination, ancestor))\\n                level = new_level\\n            \\n        return ancestors\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def getAncestors(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        ancestors = [[] for _ in range(n)]\\n        \\n        adjacency_list = defaultdict(list)\\n        for source, destination in edges:\\n            adjacency_list[source].append(destination)\\n            \\n        starting_points = [(node, node) for node in reversed(range(n))]\\n        visited = set()\\n        while starting_points:\\n            level = [starting_points.pop()]\\n            while level:\\n                new_level = []\\n                for node, ancestor in level:\\n                    if (node, ancestor) not in visited:\\n                        visited.add((node, ancestor))\\n                        if node != ancestor:\\n                            ancestors[node].append(ancestor)\\n                        for destination in adjacency_list[node]:\\n                            new_level.append((destination, ancestor))\\n                level = new_level\\n            \\n        return ancestors\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685576,
                "title": "python-92-reverse-direction-memoize",
                "content": "Idea:\\n\\n- Reverse alldirection of the DAG, so we can start from each vertex and go back to all of the ancestors\\n- To save answer for each node, we can use a hashmap, where each key is the vertex and the value is the set of all the ancestors\\n\\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\n        graph      = collections.defaultdict(list)\\n        ancestors  = collections.defaultdict(set)\\n        \\n        for u, v in edges: graph[v].append(u) #Add in reverse direction\\n            \\n        res = {}\\n        \\n        def dfs(u):\\n            if u in ancestors: return ancestors[u]\\n            \\n            for v in graph[u]:\\n                ancestors[u].update([v, *ancestors[u], *dfs(v)]) #Add sub results\\n            \\n            return ancestors[u]\\n        \\n        for i in range(n): dfs(i)\\n        \\n        return [sorted(ancestors[i]) for i in range(n)]",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\n        graph      = collections.defaultdict(list)\\n        ancestors  = collections.defaultdict(set)\\n        \\n        for u, v in edges: graph[v].append(u) #Add in reverse direction\\n            \\n        res = {}",
                "codeTag": "Java"
            },
            {
                "id": 2521731,
                "title": "javascript-topological-sort-w-comments",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number[][]}\\n */\\nvar getAncestors = function(n, edges) {\\n    // create in-degree tracker (array)\\n    const inDegrees = Array(n).fill(0);\\n    \\n    // maintain the results in a hash for each node\\n    const res = {}\\n    for (let i = 0; i < n; i++) {\\n        res[i] = new Set();\\n    }\\n    \\n    // create the graph + increment in-degrees\\n    const graph = {};\\n    for (const [from, to] of edges) {\\n        inDegrees[to]++;\\n        \\n        if (!graph[from]) {\\n            graph[from] = [];\\n        }\\n        graph[from].push(to);\\n    }\\n    \\n    // build queue for top sort where in-degree === 0\\n    const q = [];\\n    for (let i = 0; i < n; i++) {\\n        if (inDegrees[i] === 0) {\\n            q.push(i);\\n        }\\n    }\\n    \\n    // perform top sort w/ motifications\\n    while (q.length) {\\n        const node = q.shift();\\n        const neighbors = graph[node] || [];\\n\\n        for (const neighbor of neighbors) {\\n            // add this node to its child\\'s ancestor set\\n            res[neighbor].add(node);\\n            // add each of this node\\'s ancestors to its child\\'s ancestor set\\n            for (const v of res[node]) {\\n                res[neighbor].add(v)\\n            }\\n            \\n            // decrease the in-degree for this node\\'s child + check if should be added to top sort\\n            inDegrees[neighbor]--\\n            if (inDegrees[neighbor] === 0) {\\n                q.push(neighbor);\\n            }\\n        }\\n    }\\n    \\n    // turn the sets into arrays + sort them\\n    const result = [];\\n    for (const set of Object.values(res)) {\\n        const arr = Array.from(set);\\n        arr.sort((a,b) => a-b);\\n        result.push(arr)\\n    }\\n    return result\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number[][]}\\n */\\nvar getAncestors = function(n, edges) {\\n    // create in-degree tracker (array)\\n    const inDegrees = Array(n).fill(0);\\n    \\n    // maintain the results in a hash for each node\\n    const res = {}\\n    for (let i = 0; i < n; i++) {\\n        res[i] = new Set();\\n    }\\n    \\n    // create the graph + increment in-degrees\\n    const graph = {};\\n    for (const [from, to] of edges) {\\n        inDegrees[to]++;\\n        \\n        if (!graph[from]) {\\n            graph[from] = [];\\n        }\\n        graph[from].push(to);\\n    }\\n    \\n    // build queue for top sort where in-degree === 0\\n    const q = [];\\n    for (let i = 0; i < n; i++) {\\n        if (inDegrees[i] === 0) {\\n            q.push(i);\\n        }\\n    }\\n    \\n    // perform top sort w/ motifications\\n    while (q.length) {\\n        const node = q.shift();\\n        const neighbors = graph[node] || [];\\n\\n        for (const neighbor of neighbors) {\\n            // add this node to its child\\'s ancestor set\\n            res[neighbor].add(node);\\n            // add each of this node\\'s ancestors to its child\\'s ancestor set\\n            for (const v of res[node]) {\\n                res[neighbor].add(v)\\n            }\\n            \\n            // decrease the in-degree for this node\\'s child + check if should be added to top sort\\n            inDegrees[neighbor]--\\n            if (inDegrees[neighbor] === 0) {\\n                q.push(neighbor);\\n            }\\n        }\\n    }\\n    \\n    // turn the sets into arrays + sort them\\n    const result = [];\\n    for (const set of Object.values(res)) {\\n        const arr = Array.from(set);\\n        arr.sort((a,b) => a-b);\\n        result.push(arr)\\n    }\\n    return result\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2512648,
                "title": "java-reverse-all-edges-then-just-iterate-over-neighbours-dfs-bfs-0ms",
                "content": "**DFS**\\n\\n```\\npublic List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] edge : edges){\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            boolean vis[] = new boolean[n];\\n            \\n            dfs(adj,vis,i);\\n            \\n            List<Integer> resMini = new ArrayList<>();\\n            \\n            for(int j=0;j<n;j++){\\n                if(i!=j&&vis[j]){\\n                    resMini.add(j);\\n                }\\n            }\\n            \\n            res.add(resMini);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void dfs(List<List<Integer>> adj, boolean[] vis,int num){\\n      \\n        vis[num]=true;\\n        \\n        for(int neigh : adj.get(num)){\\n            if(!vis[neigh]){\\n                dfs(adj,vis,neigh);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] edge : edges){\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            boolean vis[] = new boolean[n];\\n            \\n            dfs(adj,vis,i);\\n            \\n            List<Integer> resMini = new ArrayList<>();\\n            \\n            for(int j=0;j<n;j++){\\n                if(i!=j&&vis[j]){\\n                    resMini.add(j);\\n                }\\n            }\\n            \\n            res.add(resMini);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void dfs(List<List<Integer>> adj, boolean[] vis,int num){\\n      \\n        vis[num]=true;\\n        \\n        for(int neigh : adj.get(num)){\\n            if(!vis[neigh]){\\n                dfs(adj,vis,neigh);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2497951,
                "title": "java-khan-s-algo-topo-sort-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> adjacencyList = new HashMap();\\n        int m = edges.length;\\n        int[] indegrees = new int[n];\\n        for(int i=0; i<m; i++){\\n            int from = edges[i][0];\\n            int to = edges[i][1];\\n            adjacencyList.putIfAbsent(from, new LinkedList());\\n            adjacencyList.get(from).add(to);\\n            indegrees[to]++;\\n        }\\n        LinkedList<Integer> q = new LinkedList();\\n        TreeSet<Integer>[] resArr = new TreeSet[n];\\n        for(int i = 0; i<n; i++){\\n            if(indegrees[i]==0){\\n                q.offer(i);\\n                resArr[i] = new TreeSet();\\n            }\\n        }\\n        while(!q.isEmpty()){\\n            int nd = q.poll();\\n            if(adjacencyList.containsKey(nd)){\\n                List<Integer> nexts = adjacencyList.get(nd);\\n                for(int next : nexts){\\n                    indegrees[next]--;\\n                    if(resArr[next] == null)\\n                        resArr[next] = new TreeSet(resArr[nd]);\\n                    else\\n                        resArr[next].addAll(resArr[nd]);\\n                    resArr[next].add(nd);\\n                    if(indegrees[next] == 0){\\n                        q.offer(next);\\n                    }\\n                }\\n            }\\n        }\\n        List<List<Integer>> resList = new LinkedList();\\n        for(TreeSet<Integer> ts : resArr)\\n            resList.add(new LinkedList(ts));\\n        return resList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> adjacencyList = new HashMap();\\n        int m = edges.length;\\n        int[] indegrees = new int[n];\\n        for(int i=0; i<m; i++){\\n            int from = edges[i][0];\\n            int to = edges[i][1];\\n            adjacencyList.putIfAbsent(from, new LinkedList());\\n            adjacencyList.get(from).add(to);\\n            indegrees[to]++;\\n        }\\n        LinkedList<Integer> q = new LinkedList();\\n        TreeSet<Integer>[] resArr = new TreeSet[n];\\n        for(int i = 0; i<n; i++){\\n            if(indegrees[i]==0){\\n                q.offer(i);\\n                resArr[i] = new TreeSet();\\n            }\\n        }\\n        while(!q.isEmpty()){\\n            int nd = q.poll();\\n            if(adjacencyList.containsKey(nd)){\\n                List<Integer> nexts = adjacencyList.get(nd);\\n                for(int next : nexts){\\n                    indegrees[next]--;\\n                    if(resArr[next] == null)\\n                        resArr[next] = new TreeSet(resArr[nd]);\\n                    else\\n                        resArr[next].addAll(resArr[nd]);\\n                    resArr[next].add(nd);\\n                    if(indegrees[next] == 0){\\n                        q.offer(next);\\n                    }\\n                }\\n            }\\n        }\\n        List<List<Integer>> resList = new LinkedList();\\n        for(TreeSet<Integer> ts : resArr)\\n            resList.add(new LinkedList(ts));\\n        return resList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480444,
                "title": "c-dfs-easy-approach",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(int node,vector<int> &vis,vector<int> adj[]){\\n\\t\\t\\tvis[node]=1;\\n\\n\\t\\t\\tfor(auto x:adj[node]){\\n\\t\\t\\t\\tif(!vis[x])\\n\\t\\t\\t\\t\\tdfs(x,vis,adj);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n\\n\\t\\t\\tvector<int> adj[n];\\n\\t\\t\\tvector<vector<int>> ans(n);\\n\\n\\t\\t\\tfor(auto i:edges)\\n\\t\\t\\t\\tadj[i[0]].push_back(i[1]);\\n\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\n\\t\\t\\t\\tvector<int> vis(n,0);\\n\\t\\t\\t\\tdfs(i,vis,adj);\\n\\n\\t\\t\\t\\tfor(int j=0;j<n;j++){\\n\\t\\t\\t\\t\\tif(i!=j and vis[j])\\n\\t\\t\\t\\t\\t\\tans[j].push_back(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(int node,vector<int> &vis,vector<int> adj[]){\\n\\t\\t\\tvis[node]=1;\\n\\n\\t\\t\\tfor(auto x:adj[node]){\\n\\t\\t\\t\\tif(!vis[x])\\n\\t\\t\\t\\t\\tdfs(x,vis,adj);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2427139,
                "title": "faster-solution-practise-bfs",
                "content": "This is done by bfs approach .Apply the bfs from each node . and add all the ancestors to the answer vector . The good problem to practise bfs algorithm  if you have any kind of doubts . This problem will help a lot . \\n```\\nclass Solution {\\npublic:\\n    \\n    void bfs(vector<vector<int>>&adj , queue<int>q , int i , vector<vector<int>>&ans)\\n    {\\n        q.push(i);\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            for(auto it : adj[node])\\n            {\\n                if(ans[it].empty() or ans[it].back()!=i){\\n                ans[it].push_back(i);\\n                q.push(it);\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>>adj(n+1);\\n        for( auto x : edges)\\n        {\\n            int u = x[0];\\n            int v = x[1];\\n            adj[u].push_back(v);\\n        }\\n        queue<int>q;\\n        vector<vector<int>>ans(n);\\n        \\n        for(int i=0;i<n;i++){\\n            bfs(adj , q , i , ans);\\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void bfs(vector<vector<int>>&adj , queue<int>q , int i , vector<vector<int>>&ans)\\n    {\\n        q.push(i);\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            for(auto it : adj[node])\\n            {\\n                if(ans[it].empty() or ans[it].back()!=i){\\n                ans[it].push_back(i);\\n                q.push(it);\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>>adj(n+1);\\n        for( auto x : edges)\\n        {\\n            int u = x[0];\\n            int v = x[1];\\n            adj[u].push_back(v);\\n        }\\n        queue<int>q;\\n        vector<vector<int>>ans(n);\\n        \\n        for(int i=0;i<n;i++){\\n            bfs(adj , q , i , ans);\\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382973,
                "title": "c-simple-dfs-without-toposort",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<vector<int>>&adj,vector<int>&temp,vector<bool>&vis)\\n    {   vis[node]=true;\\n        for(auto child:adj[node])\\n        {  \\n          if(vis[child]==false)\\n          {\\n            temp.push_back(child);\\n            \\n            dfs(child,adj,temp,vis);\\n           }\\n            \\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& a) {\\n       vector<vector<int>>adj(n);\\n        for(int i=0;i<a.size();i++)\\n        {\\n            adj[a[i][1]].push_back(a[i][0]);\\n        }\\n        vector<vector<int>>ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {    vector<bool>vis(n,false);\\n            vector<int>temp;\\n            dfs(i,adj,temp,vis);\\n            sort(temp.begin(),temp.end());\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<vector<int>>&adj,vector<int>&temp,vector<bool>&vis)\\n    {   vis[node]=true;\\n        for(auto child:adj[node])\\n        {  \\n          if(vis[child]==false)\\n          {\\n            temp.push_back(child);\\n            \\n            dfs(child,adj,temp,vis);\\n           }\\n            \\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& a) {\\n       vector<vector<int>>adj(n);\\n        for(int i=0;i<a.size();i++)\\n        {\\n            adj[a[i][1]].push_back(a[i][0]);\\n        }\\n        vector<vector<int>>ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {    vector<bool>vis(n,false);\\n            vector<int>temp;\\n            dfs(i,adj,temp,vis);\\n            sort(temp.begin(),temp.end());\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317053,
                "title": "c-dfs-beginner-level",
                "content": "**RUN THE COMMENTS AS WELL TO SEE THE FLOW OF DATA.**\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>>adj;\\n    vector<vector<int>>ans;\\n    \\n    void helper(int node,int temp, vector<bool>& visited)\\n    {\\n        visited[temp]=true;        \\n        for(auto it: adj[temp])\\n            {\\n            //cout<<temp<<\"->\";\\n                if(!visited[it])\\n                {   \\n                    //cout<<it<<\\' \\';\\n                    ans[node].push_back(it);\\n                    helper(node,it,visited);\\n                }                \\n            }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {        \\n        adj.resize(n);\\n        ans.resize(n);\\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n                vector<bool> visited;\\n                visited.resize(n,false);\\n                //cout<<endl;\\n                helper(i,i,visited);\\n                sort(ans[i].begin(),ans[i].end());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>>adj;\\n    vector<vector<int>>ans;\\n    \\n    void helper(int node,int temp, vector<bool>& visited)\\n    {\\n        visited[temp]=true;        \\n        for(auto it: adj[temp])\\n            {\\n            //cout<<temp<<\"->\";\\n                if(!visited[it])\\n                {   \\n                    //cout<<it<<\\' \\';\\n                    ans[node].push_back(it);\\n                    helper(node,it,visited);\\n                }                \\n            }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {        \\n        adj.resize(n);\\n        ans.resize(n);\\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n                vector<bool> visited;\\n                visited.resize(n,false);\\n                //cout<<endl;\\n                helper(i,i,visited);\\n                sort(ans[i].begin(),ans[i].end());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2272095,
                "title": "python-topological-sort",
                "content": "```\\n#Baraa\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        graph = collections.defaultdict(list)\\n        parents = [set() for i in range(n)]\\n        ranks = [0] * n\\n        for a, b in edges:\\n            graph[a].append(b)\\n            ranks[b] += 1\\n        deque = collections.deque()\\n        for i in range(n):\\n            if not ranks[i]:\\n                deque.append(i)\\n        while deque:\\n            node = deque.popleft()\\n            for child in graph[node]:\\n                parents[child] |= parents[node]\\n                parents[child].add(node)\\n                ranks[child] -= 1\\n                if not ranks[child]:\\n                    deque.append(child)\\n        return [sorted(list(s)) for s in parents]\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\n#Baraa\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        graph = collections.defaultdict(list)\\n        parents = [set() for i in range(n)]\\n        ranks = [0] * n\\n        for a, b in edges:\\n            graph[a].append(b)\\n            ranks[b] += 1\\n        deque = collections.deque()\\n        for i in range(n):\\n            if not ranks[i]:\\n                deque.append(i)\\n        while deque:\\n            node = deque.popleft()\\n            for child in graph[node]:\\n                parents[child] |= parents[node]\\n                parents[child].add(node)\\n                ranks[child] -= 1\\n                if not ranks[child]:\\n                    deque.append(child)\\n        return [sorted(list(s)) for s in parents]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037910,
                "title": "python3-topological-sort-kahn-s-algorithm",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        graph = [[] for _ in range(n)]\\n        indegrees = [0] * n\\n        \\n        for a, b in edges:\\n            graph[a].append(b)\\n            indegrees[b] += 1\\n            \\n        todo = deque()\\n        for node, degree in enumerate(indegrees):\\n            if degree == 0:\\n                todo.append(node)\\n        \\n        result = [[] for _ in range(n)]\\n        ancestors = defaultdict(set)\\n        while todo:\\n            cur = todo.popleft()\\n            for neigh in graph[cur]:\\n                \\n                ancestors[neigh].add(cur)\\n                for ancestor in ancestors[cur]:\\n                    ancestors[neigh].add(ancestor)\\n                    \\n                indegrees[neigh] -= 1\\n                if indegrees[neigh] == 0:\\n                    todo.append(neigh)\\n        \\n        for key in ancestors:\\n            for ancestor in ancestors[key]:\\n                result[key].append(ancestor)\\n                result[key].sort()\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        graph = [[] for _ in range(n)]\\n        indegrees = [0] * n\\n        \\n        for a, b in edges:\\n            graph[a].append(b)\\n            indegrees[b] += 1\\n            \\n        todo = deque()\\n        for node, degree in enumerate(indegrees):\\n            if degree == 0:\\n                todo.append(node)\\n        \\n        result = [[] for _ in range(n)]\\n        ancestors = defaultdict(set)\\n        while todo:\\n            cur = todo.popleft()\\n            for neigh in graph[cur]:\\n                \\n                ancestors[neigh].add(cur)\\n                for ancestor in ancestors[cur]:\\n                    ancestors[neigh].add(ancestor)\\n                    \\n                indegrees[neigh] -= 1\\n                if indegrees[neigh] == 0:\\n                    todo.append(neigh)\\n        \\n        for key in ancestors:\\n            for ancestor in ancestors[key]:\\n                result[key].append(ancestor)\\n                result[key].sort()\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024131,
                "title": "python3-reverse-edge-direction-problem-becomes-dfs-finding-all-children",
                "content": "This problem asks to find all parents nodes of a given node. If we inverse the edge direction, the problem becomes finding all children nodes, which is a basic dfs problem.\\ndfs(node) returns all children nodes, in our case since the edges are reversed, it means all parents nodes.\\nAlso need to cache the result of dfs(node) because this is not a tree, there might exists multiple parent nodes targeting same child node, in which case child node result can be reused.\\n\\n**Python3**\\n```python\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        edges_reverse = [[] for _ in range(n)]\\n        for a,b in edges:\\n            edges_reverse[b].append(a)\\n        @cache\\n        def dfs(node):\\n            res = set()\\n            for nxt in edges_reverse[node]:\\n                res.add(nxt)\\n                res |= dfs(nxt)\\n            return res\\n        return [sorted(dfs(i)) for i in range(n)]\\n```",
                "solutionTags": [],
                "code": "```python\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        edges_reverse = [[] for _ in range(n)]\\n        for a,b in edges:\\n            edges_reverse[b].append(a)\\n        @cache\\n        def dfs(node):\\n            res = set()\\n            for nxt in edges_reverse[node]:\\n                res.add(nxt)\\n                res |= dfs(nxt)\\n            return res\\n        return [sorted(dfs(i)) for i in range(n)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2012720,
                "title": "only-dfs-c-without-topological-sort-faster-than-84",
                "content": "```\\n//Just reverse the edges direction, as a result now child is pointing to its parent.\\n// and now just make dfs call on each node and store the parents.\\n\\nclass Solution\\n{\\npublic:\\n    void dfs(int i, vector<bool> &vis, vector<int> adj[], vector<int> &temp)\\n    {\\n        vis[i] = true;\\n        temp.push_back(i);\\n        for (auto it : adj[i])\\n            if (vis[it] == false)\\n                dfs(it, vis, adj, temp);\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>> &edges)\\n    {\\n        vector<int> adj[n];\\n        for (auto it : edges)\\n        {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        for (int i = 0; i < n; i++)\\n        {\\n            vector<bool> vis(n, false);\\n            temp.clear();\\n            for (auto it : adj[i])\\n                if(vis[it]==false)\\n                    dfs(it, vis, adj, temp);\\n            sort(temp.begin(), temp.end());\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n//Just reverse the edges direction, as a result now child is pointing to its parent.\\n// and now just make dfs call on each node and store the parents.\\n\\nclass Solution\\n{\\npublic:\\n    void dfs(int i, vector<bool> &vis, vector<int> adj[], vector<int> &temp)\\n    {\\n        vis[i] = true;\\n        temp.push_back(i);\\n        for (auto it : adj[i])\\n            if (vis[it] == false)\\n                dfs(it, vis, adj, temp);\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>> &edges)\\n    {\\n        vector<int> adj[n];\\n        for (auto it : edges)\\n        {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        for (int i = 0; i < n; i++)\\n        {\\n            vector<bool> vis(n, false);\\n            temp.clear();\\n            for (auto it : adj[i])\\n                if(vis[it]==false)\\n                    dfs(it, vis, adj, temp);\\n            sort(temp.begin(), temp.end());\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983399,
                "title": "c-learn-3-solutions-topo-reverse-edge-simple-dfs",
                "content": "\\n#### 1. Topological Sort ~829ms\\n- First thing to come up in your mind would be, Yes find parent `inorder[i] == 0` and start.\\n- Traverse below, add all grand parents as its parents.\\n- Overall complexity, along with sorting - O(NMLogM)\\n\\n```cpp\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> graph(n), res(n);\\n    vector<int> indegree(n);\\n\\n    for(auto& edge: edges){\\n        graph[edge[0]].push_back(edge[1]);\\n        indegree[edge[1]]++;\\n    }\\n\\n    //not dependednt nodes - grand parents - topo sort\\n    queue<int> q;\\n    for(int i=0; i<n; i++)\\n        if(indegree[i] == 0)\\n            q.push(i);\\n\\n    //start bfs from least edge\\n    while(!q.empty()){\\n        int node = q.front(); q.pop();\\n\\n        for(int child: graph[node]){\\n            res[child].insert(node);\\n            for(int c: res[node])\\n                res[child].insert(c);\\n\\n            if(--indegree[child] == 0)\\n                q.push(child);\\n        }\\n    }\\n\\n    //sort\\n    vector<vector<int>> ans(n);\\n    for(int i=0; i<n; i++)\\n        ans[i] = vector<int>(res[i].begin(), res[i].end());\\n\\n    return ans;\\n}\\n```\\n\\n#### 2. Reverse Edges ~744ms\\n- Wait thats right, you can reverse the edges and move from child -> parent\\n- A simple DFS/BFS will help you go over to grand parents and keep adding them to your result.\\n- Time Complexity: O(NMLogM)\\n\\n```cpp\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> graph(n), res(n);\\n    for(auto& edge: edges)\\n        graph[edge[1]].push_back(edge[0]); // reverse the edge direction\\n\\n    for(int i=0; i<n; i++){\\n        queue<int> q; \\n\\t\\tq.push(i);\\n\\n        set<int> visited;\\n        while(!q.empty()){\\n            int node = q.front(); q.pop();\\n            for(int parent: graph[node])\\n                if(!visited.count(parent)){\\n                    q.push(parent);\\n                    visited.insert(parent);\\n                }\\n        }\\n        res[i] = vector<int>(visited.begin(), visited.end());\\n    }\\n    return res;\\n}\\n```\\n\\n#### 3. Simple DFS ~211 ms\\n- A DFS  from source node (0 -> N-1) to all the reachable nodes will always have that visiting nodes as an ancestors.\\n- Sorting is already looked after - just think input as - `[[0,2],[0,1],[0,3]....` - Edge order doesn\\'t matter - By our DFS visits in inc order - First ancessor is `0` which would visit childs first, and append parent `0` to the `res` list, so already getting sorted.\\n- Time Complexity: O(N*M)\\n```cpp\\nvoid dfs(vector<vector<int>>& graph, vector<vector<int>>& res, vector<int>& visited, int prev, int node){\\n    visited[node] = 1;\\n    \\n\\tfor(int& child: graph[node]){\\n        if(visited[child]) continue;\\n        if(res[child].size() == 0 || res[child].back() != prev){\\n            res[child].push_back(prev);\\n            dfs(graph, res, visited, prev, child);\\n        }\\n    }\\n}\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> graph(n), res(n);\\n    for(auto& edge: edges)\\n        graph[edge[0]].push_back(edge[1]);\\n\\n    for(int i=0; i<n; i++){\\n        vector<int> visited(n);\\n        dfs(graph, res, visited, i, i);\\n    }\\n\\n    return res;\\n}\\n```\\n\\n**Upvote and let other leetcoders  too learn.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> graph(n), res(n);\\n    vector<int> indegree(n);\\n\\n    for(auto& edge: edges){\\n        graph[edge[0]].push_back(edge[1]);\\n        indegree[edge[1]]++;\\n    }\\n\\n    //not dependednt nodes - grand parents - topo sort\\n    queue<int> q;\\n    for(int i=0; i<n; i++)\\n        if(indegree[i] == 0)\\n            q.push(i);\\n\\n    //start bfs from least edge\\n    while(!q.empty()){\\n        int node = q.front(); q.pop();\\n\\n        for(int child: graph[node]){\\n            res[child].insert(node);\\n            for(int c: res[node])\\n                res[child].insert(c);\\n\\n            if(--indegree[child] == 0)\\n                q.push(child);\\n        }\\n    }\\n\\n    //sort\\n    vector<vector<int>> ans(n);\\n    for(int i=0; i<n; i++)\\n        ans[i] = vector<int>(res[i].begin(), res[i].end());\\n\\n    return ans;\\n}\\n```\n```cpp\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> graph(n), res(n);\\n    for(auto& edge: edges)\\n        graph[edge[1]].push_back(edge[0]); // reverse the edge direction\\n\\n    for(int i=0; i<n; i++){\\n        queue<int> q; \\n\\t\\tq.push(i);\\n\\n        set<int> visited;\\n        while(!q.empty()){\\n            int node = q.front(); q.pop();\\n            for(int parent: graph[node])\\n                if(!visited.count(parent)){\\n                    q.push(parent);\\n                    visited.insert(parent);\\n                }\\n        }\\n        res[i] = vector<int>(visited.begin(), visited.end());\\n    }\\n    return res;\\n}\\n```\n```cpp\\nvoid dfs(vector<vector<int>>& graph, vector<vector<int>>& res, vector<int>& visited, int prev, int node){\\n    visited[node] = 1;\\n    \\n\\tfor(int& child: graph[node]){\\n        if(visited[child]) continue;\\n        if(res[child].size() == 0 || res[child].back() != prev){\\n            res[child].push_back(prev);\\n            dfs(graph, res, visited, prev, child);\\n        }\\n    }\\n}\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> graph(n), res(n);\\n    for(auto& edge: edges)\\n        graph[edge[0]].push_back(edge[1]);\\n\\n    for(int i=0; i<n; i++){\\n        vector<int> visited(n);\\n        dfs(graph, res, visited, i, i);\\n    }\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1939950,
                "title": "c-topological-sort-queue-easily-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>ans(n);\\n        map<int, vector<int>> g;\\n        int inDegree[n];\\n        memset(inDegree, 0, sizeof(inDegree));\\n        for(auto e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            inDegree[e[1]]++;\\n        }\\n        queue<int> Q;\\n        for(int i = 0; i < n; i++) {\\n            if(inDegree[i] == 0) {\\n                Q.push(i);\\n            }\\n        }\\n        \\n        bool visited[n][n];\\n        memset(visited, false, sizeof(visited));\\n        \\n        while(!Q.empty()) {\\n            int parent = Q.front();\\n            Q.pop();\\n            for(int child : g[parent]) {\\n                inDegree[child]--;\\n                if(inDegree[child] == 0) {\\n                    Q.push(child);\\n                }\\n                for(int anc : ans[parent]) {\\n                    if(visited[child][anc]) continue;\\n                    ans[child].push_back(anc);\\n                    visited[child][anc] = true;\\n                }\\n                if(visited[child][parent]) continue;\\n                ans[child].push_back(parent);\\n                visited[child][parent] = true;\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            sort(ans[i].begin(), ans[i].end());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>ans(n);\\n        map<int, vector<int>> g;\\n        int inDegree[n];\\n        memset(inDegree, 0, sizeof(inDegree));\\n        for(auto e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            inDegree[e[1]]++;\\n        }\\n        queue<int> Q;\\n        for(int i = 0; i < n; i++) {\\n            if(inDegree[i] == 0) {\\n                Q.push(i);\\n            }\\n        }\\n        \\n        bool visited[n][n];\\n        memset(visited, false, sizeof(visited));\\n        \\n        while(!Q.empty()) {\\n            int parent = Q.front();\\n            Q.pop();\\n            for(int child : g[parent]) {\\n                inDegree[child]--;\\n                if(inDegree[child] == 0) {\\n                    Q.push(child);\\n                }\\n                for(int anc : ans[parent]) {\\n                    if(visited[child][anc]) continue;\\n                    ans[child].push_back(anc);\\n                    visited[child][anc] = true;\\n                }\\n                if(visited[child][parent]) continue;\\n                ans[child].push_back(parent);\\n                visited[child][parent] = true;\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            sort(ans[i].begin(), ans[i].end());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898595,
                "title": "topological-sort-bitset",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n\\tvector<vector<int>> getAncestors(int n, vector<vector<int>> &edges)\\n\\t{\\n\\t\\tvector<int> in(n);\\n\\t\\tvector<vector<int>> g(n), rg(n);\\n\\t\\tfor (auto &i : edges)\\n\\t\\t{\\n\\t\\t\\tg[i[0]].push_back(i[1]);\\n\\t\\t\\trg[i[1]].push_back(i[0]);\\n\\t\\t\\tin[i[1]]++;\\n\\t\\t}\\n\\t\\tvector<bitset<1001>> ancestor(n);\\n\\t\\trep(i, 0, n) ancestor[i].set(i);\\n\\t\\tqueue<int> q;\\n\\t\\trep(i, 0, n) if (in[i] == 0) q.push(i);\\n\\n\\t\\twhile (q.size())\\n\\t\\t{\\n\\t\\t\\tint curr = q.front();\\n\\t\\t\\tq.pop();\\n\\t\\t\\tfor (int i : rg[curr])\\n\\t\\t\\t\\tancestor[curr] |= ancestor[i];\\n\\t\\t\\tfor (int i : g[curr])\\n\\t\\t\\t{\\n\\t\\t\\t\\tin[i]--;\\n\\t\\t\\t\\tif (in[i] == 0)\\n\\t\\t\\t\\t\\tq.push(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<vector<int>> ans(n, vector<int>());\\n\\t\\tfor (int i = 0; i < n; ++i)\\n\\t\\t{\\n\\t\\t\\tfor (int j = 0; j < n; ++j)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (i == j)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (ancestor[i].test(j))\\n\\t\\t\\t\\t\\tans[i].push_back(j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n\\tvector<vector<int>> getAncestors(int n, vector<vector<int>> &edges)\\n\\t{\\n\\t\\tvector<int> in(n);\\n\\t\\tvector<vector<int>> g(n), rg(n);\\n\\t\\tfor (auto &i : edges)\\n\\t\\t{\\n\\t\\t\\tg[i[0]].push_back(i[1]);\\n\\t\\t\\trg[i[1]].push_back(i[0]);\\n\\t\\t\\tin[i[1]]++;\\n\\t\\t}\\n\\t\\tvector<bitset<1001>> ancestor(n);\\n\\t\\trep(i, 0, n) ancestor[i].set(i);\\n\\t\\tqueue<int> q;\\n\\t\\trep(i, 0, n) if (in[i] == 0) q.push(i);\\n\\n\\t\\twhile (q.size())\\n\\t\\t{\\n\\t\\t\\tint curr = q.front();\\n\\t\\t\\tq.pop();\\n\\t\\t\\tfor (int i : rg[curr])\\n\\t\\t\\t\\tancestor[curr] |= ancestor[i];\\n\\t\\t\\tfor (int i : g[curr])\\n\\t\\t\\t{\\n\\t\\t\\t\\tin[i]--;\\n\\t\\t\\t\\tif (in[i] == 0)\\n\\t\\t\\t\\t\\tq.push(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<vector<int>> ans(n, vector<int>());\\n\\t\\tfor (int i = 0; i < n; ++i)\\n\\t\\t{\\n\\t\\t\\tfor (int j = 0; j < n; ++j)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (i == j)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (ancestor[i].test(j))\\n\\t\\t\\t\\t\\tans[i].push_back(j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856808,
                "title": "java-dfs-o-n-2",
                "content": "```\\nclass Solution {\\n    class Node {\\n        int value;\\n        List<Node> children;\\n        public Node(int value) {\\n            this.value = value;\\n            this.children = new ArrayList<>();\\n        }\\n    }\\n    \\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        Map<Integer, Node> graph = new HashMap<>();\\n        List<List<Integer>> ancestors = new ArrayList<>();\\n        buildGraph(n, edges, graph);\\n        for (int node = 0; node < n; node += 1) {\\n            ancestors.add(new ArrayList<>());\\n        }\\n        for (int node = 0; node < n; node += 1) {\\n            boolean[] visited = new boolean[n];\\n            dfs(graph.get(node), graph, ancestors, node, visited);\\n        }\\n        return ancestors;\\n    }\\n    \\n    private void buildGraph(int n, int[][] edges, Map<Integer, Node> graph) {\\n        for (int node = 0; node < n; node += 1) {\\n            graph.put(node, new Node(node));\\n        }\\n        for (int[] edge: edges) {\\n            graph.get(edge[0]).children.add(graph.get(edge[1]));\\n        }\\n    }\\n    \\n    private void dfs(Node currentNode, Map<Integer, Node> graph, List<List<Integer>> ancestors, int ancestor, boolean[] visited) {\\n        for(Node node: currentNode.children) {\\n            int value = node.value;\\n            if (!visited[value]) {\\n                ancestors.get(value).add(ancestor);\\n                visited[value] = true;\\n                dfs(node, graph, ancestors, ancestor, visited);   \\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class Node {\\n        int value;\\n        List<Node> children;\\n        public Node(int value) {\\n            this.value = value;\\n            this.children = new ArrayList<>();\\n        }\\n    }\\n    \\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        Map<Integer, Node> graph = new HashMap<>();\\n        List<List<Integer>> ancestors = new ArrayList<>();\\n        buildGraph(n, edges, graph);\\n        for (int node = 0; node < n; node += 1) {\\n            ancestors.add(new ArrayList<>());\\n        }\\n        for (int node = 0; node < n; node += 1) {\\n            boolean[] visited = new boolean[n];\\n            dfs(graph.get(node), graph, ancestors, node, visited);\\n        }\\n        return ancestors;\\n    }\\n    \\n    private void buildGraph(int n, int[][] edges, Map<Integer, Node> graph) {\\n        for (int node = 0; node < n; node += 1) {\\n            graph.put(node, new Node(node));\\n        }\\n        for (int[] edge: edges) {\\n            graph.get(edge[0]).children.add(graph.get(edge[1]));\\n        }\\n    }\\n    \\n    private void dfs(Node currentNode, Map<Integer, Node> graph, List<List<Integer>> ancestors, int ancestor, boolean[] visited) {\\n        for(Node node: currentNode.children) {\\n            int value = node.value;\\n            if (!visited[value]) {\\n                ancestors.get(value).add(ancestor);\\n                visited[value] = true;\\n                dfs(node, graph, ancestors, ancestor, visited);   \\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856251,
                "title": "c-recursion-memoization-99-9-faster-better-stronger",
                "content": "**Remarks:**\\n- Other solutions look simpler and I have not tested them but this one seems efficent. \\n- The idea I followed is to reuse the list of ancestors of other nodes if already calculated, else compute them, after that, resort them and remove the duplicates.\\n- The \"faster, better, stronger\" in the title is just for having a click bait title, definitely not sure this solution is fastor or better than others :-)\\n\\n![image](https://assets.leetcode.com/users/images/5b8164f7-33d9-4514-be44-fcc53b05b817_1647470459.3264768.png)\\n\\n**Note:** I had to run it multiple times as there is some jitter in leetcode benchmarks (min 80%, max 99.95%)\\n\\n```cpp\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n\\tvector<vector<int>> ancestors(n);\\n\\tfor(const auto& e: edges)\\n\\t\\tancestors[e[1]].push_back(e[0]);\\n\\tvector<int> visited(n);   \\n\\tfor(int i = 0; i < n; ++i) \\n\\t\\tget_ancestors(visited, ancestors, i);\\n\\treturn ancestors;\\n}\\n\\nvoid get_ancestors(vector<int>& visited, \\n\\t\\t\\t\\t   vector<vector<int>>& ancestors, \\n\\t\\t\\t\\t   int node) {\\n\\tif(!visited[node]) {\\n\\t\\tvisited[node] = 1;\\n\\t\\tauto & v = ancestors[node];\\n\\t\\tfor(int i=0, size=v.size(); i <size; ++i) {\\n\\t\\t\\tget_ancestors(visited, ancestors, v[i]);\\n\\t\\t\\tv.insert(v.end(), ancestors[v[i]].begin(), ancestors[v[i]].end());\\n\\t\\t}\\n\\t\\tsort(v.begin(), v.end());\\n\\t\\tv.erase(unique(v.begin(), v.end()), v.end());\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n\\tvector<vector<int>> ancestors(n);\\n\\tfor(const auto& e: edges)\\n\\t\\tancestors[e[1]].push_back(e[0]);\\n\\tvector<int> visited(n);   \\n\\tfor(int i = 0; i < n; ++i) \\n\\t\\tget_ancestors(visited, ancestors, i);\\n\\treturn ancestors;\\n}\\n\\nvoid get_ancestors(vector<int>& visited, \\n\\t\\t\\t\\t   vector<vector<int>>& ancestors, \\n\\t\\t\\t\\t   int node) {\\n\\tif(!visited[node]) {\\n\\t\\tvisited[node] = 1;\\n\\t\\tauto & v = ancestors[node];\\n\\t\\tfor(int i=0, size=v.size(); i <size; ++i) {\\n\\t\\t\\tget_ancestors(visited, ancestors, v[i]);\\n\\t\\t\\tv.insert(v.end(), ancestors[v[i]].begin(), ancestors[v[i]].end());\\n\\t\\t}\\n\\t\\tsort(v.begin(), v.end());\\n\\t\\tv.erase(unique(v.begin(), v.end()), v.end());\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1843207,
                "title": "python-o-n-2",
                "content": "```\\ndef getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        d = defaultdict(set)\\n        \\n        for i,j in edges:\\n            d[i].add(j)\\n            \\n        res = [[] for i in range(n)]\\n        \\n        for i in range(n):\\n            q = [i]\\n            while q:\\n                node = q.pop(0)\\n                for nei in d[node]:\\n                    if i not in res[nei]:\\n                        res[nei].append(i)\\n                        q.append(nei)\\n        return res\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\ndef getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        d = defaultdict(set)\\n        \\n        for i,j in edges:\\n            d[i].add(j)\\n            \\n        res = [[] for i in range(n)]\\n        \\n        for i in range(n):\\n            q = [i]\\n            while q:\\n                node = q.pop(0)\\n                for nei in d[node]:\\n                    if i not in res[nei]:\\n                        res[nei].append(i)\\n                        q.append(nei)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1842817,
                "title": "dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>adj[1005];\\n    bool vis[1005];\\n    \\n    void dfs(int node, vector<int>&v,int start)\\n    {\\n        vis[node]=true;\\n        if(node!=start)v.push_back(node);\\n        \\n        for(auto it:adj[node])\\n        {\\n            if(!vis[it])\\n            {\\n                dfs(it,v,start);\\n            }\\n        }\\n        \\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>ans(n);\\n        for(auto it:edges)\\n        {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            dfs(i,ans[i],i);\\n            sort(ans[i].begin(),ans[i].end());\\n            for(int i=0;i<1005;i++)\\n            {\\n                vis[i]=false;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>adj[1005];\\n    bool vis[1005];\\n    \\n    void dfs(int node, vector<int>&v,int start)\\n    {\\n        vis[node]=true;\\n        if(node!=start)v.push_back(node);\\n        \\n        for(auto it:adj[node])\\n        {\\n            if(!vis[it])\\n            {\\n                dfs(it,v,start);\\n            }\\n        }\\n        \\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>ans(n);\\n        for(auto it:edges)\\n        {\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            dfs(i,ans[i],i);\\n            sort(ans[i].begin(),ans[i].end());\\n            for(int i=0;i<1005;i++)\\n            {\\n                vis[i]=false;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840055,
                "title": "very-simple-reversing-the-edges-and-then-using-set-properties-of-java",
                "content": "```\\nclass Solution {\\n    ArrayList<Integer>[] adj;\\n    List<List<Integer>> res ;\\n    boolean[] visited;\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n         adj = new ArrayList[n ];\\n        for (int i = 0; i < n; i++ ) adj[i] = new ArrayList<Integer>(); \\n        int len = edges.length;\\n        for (int i = 0; i < len; i++){adj[edges[i][1]].add(edges[i][0]);}\\n       res = new ArrayList<>();\\n        for (int i = 0; i < n; i++) res.add(new ArrayList<Integer>());\\n        visited = new boolean[n ];\\n        for (int i = 0; i < n; i++){\\n            if (!visited[i]) dfs(i);\\n        }\\n        \\n        return res;        \\n    }\\n    public void dfs(int i){\\n        visited[i] = true; \\n        for (int k: adj[i]){\\n            if (!visited[k]){\\n                dfs(k);\\n            }\\n            for (int j: res.get(k)){\\n                res.get(i).add(j);\\n            }\\n            res.get(i).add(k);\\n        }\\n         res.set(i, res.get(i).stream().distinct().collect(Collectors.toList()));\\n        Collections.sort(res.get(i));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    ArrayList<Integer>[] adj;\\n    List<List<Integer>> res ;\\n    boolean[] visited;\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n         adj = new ArrayList[n ];\\n        for (int i = 0; i < n; i++ ) adj[i] = new ArrayList<Integer>(); \\n        int len = edges.length;\\n        for (int i = 0; i < len; i++){adj[edges[i][1]].add(edges[i][0]);}\\n       res = new ArrayList<>();\\n        for (int i = 0; i < n; i++) res.add(new ArrayList<Integer>());\\n        visited = new boolean[n ];\\n        for (int i = 0; i < n; i++){\\n            if (!visited[i]) dfs(i);\\n        }\\n        \\n        return res;        \\n    }\\n    public void dfs(int i){\\n        visited[i] = true; \\n        for (int k: adj[i]){\\n            if (!visited[k]){\\n                dfs(k);\\n            }\\n            for (int j: res.get(k)){\\n                res.get(i).add(j);\\n            }\\n            res.get(i).add(k);\\n        }\\n         res.set(i, res.get(i).stream().distinct().collect(Collectors.toList()));\\n        Collections.sort(res.get(i));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833895,
                "title": "c-topological-sort",
                "content": "```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    \\n    void dfs(int i,bool vis[],vector<int>adj[],int element,vector<vector<int>>&res){\\n        if(vis[i])\\n            return;\\n        vis[i] = 1;\\n        if(i!=element)\\n            res[i].push_back(element);\\n        for(auto it : adj[i]){\\n            dfs(it,vis,adj,element,res);\\n        }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>>res(n);\\n        vector<int>adj[n+1];\\n        int deg[10001]{0};\\n        \\n        for(auto it :edges){\\n            adj[it[0]].pb(it[1]);\\n            deg[it[1]]++;\\n        }\\n        \\n        queue<int>Q;\\n        bool vis[1001]{0};\\n        for(int i=0;i<n;++i){\\n            if(deg[i]==0)\\n                Q.push(i),vis[i]=1;\\n        }\\n        \\n        while(!Q.empty()){\\n            auto front = Q.front();\\n            Q.pop();\\n            bool locvis[1001]{0};\\n            dfs(front,locvis,adj,front,res);\\n            for(auto it : adj[front]){\\n                deg[it]--;\\n                if(!deg[it]){\\n                    Q.push(it);\\n                    vis[it] = 1;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;++i){\\n            sort(res[i].begin(),res[i].end());\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    \\n    void dfs(int i,bool vis[],vector<int>adj[],int element,vector<vector<int>>&res){\\n        if(vis[i])\\n            return;\\n        vis[i] = 1;\\n        if(i!=element)\\n            res[i].push_back(element);\\n        for(auto it : adj[i]){\\n            dfs(it,vis,adj,element,res);\\n        }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>>res(n);\\n        vector<int>adj[n+1];\\n        int deg[10001]{0};\\n        \\n        for(auto it :edges){\\n            adj[it[0]].pb(it[1]);\\n            deg[it[1]]++;\\n        }\\n        \\n        queue<int>Q;\\n        bool vis[1001]{0};\\n        for(int i=0;i<n;++i){\\n            if(deg[i]==0)\\n                Q.push(i),vis[i]=1;\\n        }\\n        \\n        while(!Q.empty()){\\n            auto front = Q.front();\\n            Q.pop();\\n            bool locvis[1001]{0};\\n            dfs(front,locvis,adj,front,res);\\n            for(auto it : adj[front]){\\n                deg[it]--;\\n                if(!deg[it]){\\n                    Q.push(it);\\n                    vis[it] = 1;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;++i){\\n            sort(res[i].begin(),res[i].end());\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830139,
                "title": "c-runtime-124-ms-faster-than-99-84-memory-48-7-mb-less-than-99-10",
                "content": "```\\nclass Solution {\\npublic:\\n\\tvoid dfs(int i, int anc, vector<vector<int>> &al, vector<vector<int>> &res) {\\n\\t\\tif (res[i].empty() || res[i].back() != anc)  {\\n\\t\\t\\tif (i != anc)\\n\\t\\t\\t\\tres[i].push_back(anc);\\n\\t\\t\\tfor (auto j : al[i])\\n\\t\\t\\t\\tdfs(j, anc, al, res);\\n\\t\\t}\\n\\t}\\n\\tvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n\\t\\tvector<vector<int>> res(n), al(n);\\n\\t\\tfor (auto &e: edges)\\n\\t\\t\\tal[e[0]].push_back(e[1]);\\n\\t\\tfor (int i = 0; i < n; ++i)\\n\\t\\t\\tdfs(i, i, al, res);\\n\\t\\treturn res;    \\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvoid dfs(int i, int anc, vector<vector<int>> &al, vector<vector<int>> &res) {\\n\\t\\tif (res[i].empty() || res[i].back() != anc)  {\\n\\t\\t\\tif (i != anc)\\n\\t\\t\\t\\tres[i].push_back(anc);\\n\\t\\t\\tfor (auto j : al[i])\\n\\t\\t\\t\\tdfs(j, anc, al, res);\\n\\t\\t}\\n\\t}\\n\\tvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n\\t\\tvector<vector<int>> res(n), al(n);\\n\\t\\tfor (auto &e: edges)\\n\\t\\t\\tal[e[0]].push_back(e[1]);\\n\\t\\tfor (int i = 0; i < n; ++i)\\n\\t\\t\\tdfs(i, i, al, res);\\n\\t\\treturn res;    \\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825201,
                "title": "simple-dfs-apply-on-all-paprent-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>adj[],int st,int papa,vector<vector<int>>&vec,vector<int>&vis){\\n        vis[st]=1;\\n        for(auto it:adj[st]){\\n            if(!vis[it]){\\n                vec[it].push_back(papa);\\n                dfs(adj,it,papa,vec,vis);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        vector<vector<int>>vec(n);\\n        \\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n        }\\n        for(int i=0;i<n;i++){\\n                vector<int>vis(n,0);\\n                dfs(adj,i,i,vec,vis);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>adj[],int st,int papa,vector<vector<int>>&vec,vector<int>&vis){\\n        vis[st]=1;\\n        for(auto it:adj[st]){\\n            if(!vis[it]){\\n                vec[it].push_back(papa);\\n                dfs(adj,it,papa,vec,vis);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        vector<vector<int>>vec(n);\\n        \\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n        }\\n        for(int i=0;i<n;i++){\\n                vector<int>vis(n,0);\\n                dfs(adj,i,i,vec,vis);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824987,
                "title": "c-simple-dfs-zero-flex",
                "content": "\\n- Ancestor Meaning: \" A node u is an ancestor of another node v if u can reach v via a set of edges\"\\n\\n- Node 0 is ancestor of which all nodes?\\n    => Start a DFS(/BFS) from node 0 as src, and all the reachable nodes will \\n    always have node 0 as an ancestor [from definition]\\n    \\n- Node 1 is ancestor of which all nodes?\\n    => Start a DFS(/BFS) from node 1 as src, and all the reachable nodes will \\n    always have node 1 as an ancestor [from definition of ancestor]\\n    \\n- Node 2 is .....?\\n    => Start a DFS(/BFS) from node 2, ....\\n\\n- ...\\n\\n- Node n is ancestor of which all nodes?\\n    => Start a DFS(/BFS) from node n as src , and all the reachable nodes will \\n    always  have node n as an ancestor [from definition of ancestor]\\n    \\n- Hence, you see that we will automatically have all the ancestors in \\nincreasing order.\\n\\n- TC:O(N*N) Since for each src node (i) we do a DFS(/BFS) of entire graph form (i) and check which nodes are reachable\\n\\n- SC:O(N) for DFS(/BFS) + O(N^N) for returning answer\\n\\n```\\nvector<vector<int>> solution(int n, vector<vector<int>>& edges){\\n\\n\\tvector<int> adj[n];\\n\\n\\tfor(auto& e : edges){\\n\\t\\tint u = e[0], v = e[1];\\n\\t\\tadj[u].push_back(v);\\n\\t}\\n\\n\\tvector<vector<int>> ancestors(n);\\n\\n\\tfor(int src = 0; src < n; src++){\\n\\n\\t\\tvector<int> visited(n, 0);\\n\\t\\tdfs(src, src, visited, adj, ancestors);\\n\\n\\t}\\n\\n\\treturn ancestors;\\n}\\nvoid dfs(int currNode, int src, vector<int>& visited, vector<int> adj[], vector<vector<int>>& ancestors){\\n\\n\\tvisited[currNode] = +1;\\n\\n\\tif(currNode != src) \\n\\t\\tancestors[currNode].push_back(src);\\n\\n\\tfor(auto& adjNode : adj[currNode]){\\n\\t\\tif(visited[adjNode]) continue;\\n\\n\\t\\tdfs(adjNode, src, visited, adj, ancestors);\\n\\t}\\n\\n\\treturn;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> solution(int n, vector<vector<int>>& edges){\\n\\n\\tvector<int> adj[n];\\n\\n\\tfor(auto& e : edges){\\n\\t\\tint u = e[0], v = e[1];\\n\\t\\tadj[u].push_back(v);\\n\\t}\\n\\n\\tvector<vector<int>> ancestors(n);\\n\\n\\tfor(int src = 0; src < n; src++){\\n\\n\\t\\tvector<int> visited(n, 0);\\n\\t\\tdfs(src, src, visited, adj, ancestors);\\n\\n\\t}\\n\\n\\treturn ancestors;\\n}\\nvoid dfs(int currNode, int src, vector<int>& visited, vector<int> adj[], vector<vector<int>>& ancestors){\\n\\n\\tvisited[currNode] = +1;\\n\\n\\tif(currNode != src) \\n\\t\\tancestors[currNode].push_back(src);\\n\\n\\tfor(auto& adjNode : adj[currNode]){\\n\\t\\tif(visited[adjNode]) continue;\\n\\n\\t\\tdfs(adjNode, src, visited, adj, ancestors);\\n\\t}\\n\\n\\treturn;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824375,
                "title": "simple-solution-in-java-two-approaches-1-topological-sort-2-dfs-with-memo",
                "content": "**Topological Sort**\\n```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        // Topological Sort\\n        \\n        \\n        // Create Graph and the inorder array\\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\\n        int[] inorder = new int[n];\\n        for(int[] e : edges){\\n            graph.computeIfAbsent(e[0], k -> new ArrayList<>()).add(e[1]);\\n            inorder[e[1]]++;\\n        }\\n        \\n        \\n        List<TreeSet<Integer>> ancestor = new ArrayList<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i=0; i<n; i++){\\n            ancestor.add(new TreeSet<>());\\n            if(inorder[i] == 0) queue.offer(i);\\n        }\\n        \\n        while(!queue.isEmpty()){\\n            int node = queue.poll();\\n            \\n            if(graph.containsKey(node)){\\n                for(int child : graph.get(node)){\\n                    ancestor.get(child).add(node);\\n                    ancestor.get(child).addAll(new TreeSet<>(ancestor.get(node)));\\n                        \\n                    if(--inorder[child] == 0) queue.offer(child);\\n                }\\n            }\\n        }\\n        \\n        // Create the result list\\n        List<List<Integer>> res = new ArrayList<>();\\n        for(TreeSet<Integer> li : ancestor){\\n            res.add(new ArrayList<>(li));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n**DFS**\\n```\\nclass Solution {\\n    private HashMap<Integer, List<Integer>> graph;\\n    private HashMap<Integer, List<Integer>> memo;\\n    \\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        this.graph = new HashMap<>();\\n        this.memo = new HashMap<>();\\n            \\n        for(int[] e : edges){\\n            graph.computeIfAbsent(e[1], k -> new ArrayList<>()).add(e[0]);\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for(int i=0; i<n; i++){\\n            res.add(find(i));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private List<Integer> find(int node){\\n        if(memo.containsKey(node)) return memo.get(node);\\n        \\n        TreeSet<Integer> ancestors = new TreeSet<>();\\n        if(graph.containsKey(node)){\\n            for(int tp : graph.get(node)){\\n                ancestors.add(tp);\\n                ancestors.addAll(find(tp));\\n            }\\n        }\\n        \\n        memo.put(node, new ArrayList<Integer>(ancestors));\\n        return memo.get(node);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        // Topological Sort\\n        \\n        \\n        // Create Graph and the inorder array\\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\\n        int[] inorder = new int[n];\\n        for(int[] e : edges){\\n            graph.computeIfAbsent(e[0], k -> new ArrayList<>()).add(e[1]);\\n            inorder[e[1]]++;\\n        }\\n        \\n        \\n        List<TreeSet<Integer>> ancestor = new ArrayList<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i=0; i<n; i++){\\n            ancestor.add(new TreeSet<>());\\n            if(inorder[i] == 0) queue.offer(i);\\n        }\\n        \\n        while(!queue.isEmpty()){\\n            int node = queue.poll();\\n            \\n            if(graph.containsKey(node)){\\n                for(int child : graph.get(node)){\\n                    ancestor.get(child).add(node);\\n                    ancestor.get(child).addAll(new TreeSet<>(ancestor.get(node)));\\n                        \\n                    if(--inorder[child] == 0) queue.offer(child);\\n                }\\n            }\\n        }\\n        \\n        // Create the result list\\n        List<List<Integer>> res = new ArrayList<>();\\n        for(TreeSet<Integer> li : ancestor){\\n            res.add(new ArrayList<>(li));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private HashMap<Integer, List<Integer>> graph;\\n    private HashMap<Integer, List<Integer>> memo;\\n    \\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        this.graph = new HashMap<>();\\n        this.memo = new HashMap<>();\\n            \\n        for(int[] e : edges){\\n            graph.computeIfAbsent(e[1], k -> new ArrayList<>()).add(e[0]);\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for(int i=0; i<n; i++){\\n            res.add(find(i));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private List<Integer> find(int node){\\n        if(memo.containsKey(node)) return memo.get(node);\\n        \\n        TreeSet<Integer> ancestors = new TreeSet<>();\\n        if(graph.containsKey(node)){\\n            for(int tp : graph.get(node)){\\n                ancestors.add(tp);\\n                ancestors.addAll(find(tp));\\n            }\\n        }\\n        \\n        memo.put(node, new ArrayList<Integer>(ancestors));\\n        return memo.get(node);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823394,
                "title": "java-topological-sorting-easy-understanding",
                "content": "When I first got this question, I saw 1,000 data volumes, another graph topic. I used breadth-first search first, but it certainly didn\\'t work (at least the breadth I wrote won\\'t work). Then it came to mind as if and [210.Course schedule II](https://leetcode-cn.com/problems/course-schedule-ii/ ) Almost, so I have the next thoughts:\\n\\n1. Build two linear tables, one as a return value and the other using `TreeSet`, to sort elements while removing duplicate elements\\n2. Construct an adjacency matrix (the adjacency table would be better) and an array of degrees\\n3. Traverse `edges`to construct the relationship between edges in the graph and the degree of entry of each node\\n4. Queue the zero-penetration nodes in the graph and \"populate\" the two linear tables we originally built\\n5. Traverse through the entire penetration array separately. If the penetration is 0, join the queue, and add the parent node and all its parent nodes to the linear table\\n6. Put the final answer together in the return value`ans`\\n\\n\\nThe idea is too simple, only for AC, more advanced method also please see another problem solving\\n\\n```java\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Set<Integer>> demo = new ArrayList<>();\\n\\n        int[] system = new int[n];\\n        int[][] grid = new int[n][n];\\n\\n        for (int[] edge : edges) {\\n            system[edge[1]]++;\\n            grid[edge[0]][edge[1]] = 1;\\n        }\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            if (system[i] == 0) {\\n                queue.offer(i);\\n                system[i]--;\\n            }\\n            ans.add(new ArrayList<>());\\n            demo.add(new TreeSet<>());\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            while (size-- > 0) {\\n                int idx = queue.poll();\\n                for (int i = 0; i < n; i++) {\\n                    if (grid[idx][i] == 1) {\\n                        system[i]--;\\n                        demo.get(i).add(idx);\\n                        demo.get(i).addAll(demo.get(idx));\\n                    }\\n                    if (system[i] == 0) {\\n                        queue.offer(i);\\n                        system[i]--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            ans.get(i).addAll(demo.get(i));\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```java\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Set<Integer>> demo = new ArrayList<>();\\n\\n        int[] system = new int[n];\\n        int[][] grid = new int[n][n];\\n\\n        for (int[] edge : edges) {\\n            system[edge[1]]++;\\n            grid[edge[0]][edge[1]] = 1;\\n        }\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            if (system[i] == 0) {\\n                queue.offer(i);\\n                system[i]--;\\n            }\\n            ans.add(new ArrayList<>());\\n            demo.add(new TreeSet<>());\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            while (size-- > 0) {\\n                int idx = queue.poll();\\n                for (int i = 0; i < n; i++) {\\n                    if (grid[idx][i] == 1) {\\n                        system[i]--;\\n                        demo.get(i).add(idx);\\n                        demo.get(i).addAll(demo.get(idx));\\n                    }\\n                    if (system[i] == 0) {\\n                        queue.offer(i);\\n                        system[i]--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            ans.get(i).addAll(demo.get(i));\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823284,
                "title": "python-3-topological-sort-via-bfs",
                "content": "Similar to LC 207 ([Course Schedule](https://leetcode.com/problems/course-schedule/)), LC 210 ([Course Schedule II](https://leetcode.com/problems/course-schedule-II/)), first we build the graph as an adjacency list and use an array `inDegree` to count the number of incoming edges of a given node. Then, we use a BFS algorithm implemented via a queue to get the topological order of all nodes in the graph. The topological order allows us to find all ancestors of a given node sequentially.\\nPlease upvote if you find this solution helpful.\\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        # Topological sort with BFS (Kahn\\'s algorithm)\\n        # Similar to LC 207 (Course Schedule), LC 210 (Course Schedule II)\\n        graph = [[] for _ in range(n)]\\n        inDegree = [0] * n\\n        for edge in edges:\\n            start, end = edge[0], edge[1]\\n            graph[start].append(end)\\n            inDegree[end] += 1\\n        output = [set() for _ in range(n)]        \\n        queue = deque()\\n        for i in range(n):\\n            if inDegree[i] == 0:\\n                queue.append(i)\\n        while queue:\\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n                for desc in graph[node]:\\n                    output[desc].add(node)\\n                    for anc in output[node]:\\n                        output[desc].add(anc)\\n                    inDegree[desc] -= 1\\n                    if inDegree[desc] == 0:\\n                        queue.append(desc)\\n        for i in range(n):\\n            output[i] = sorted(list(output[i]))\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        # Topological sort with BFS (Kahn\\'s algorithm)\\n        # Similar to LC 207 (Course Schedule), LC 210 (Course Schedule II)\\n        graph = [[] for _ in range(n)]\\n        inDegree = [0] * n\\n        for edge in edges:\\n            start, end = edge[0], edge[1]\\n            graph[start].append(end)\\n            inDegree[end] += 1\\n        output = [set() for _ in range(n)]        \\n        queue = deque()\\n        for i in range(n):\\n            if inDegree[i] == 0:\\n                queue.append(i)\\n        while queue:\\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n                for desc in graph[node]:\\n                    output[desc].add(node)\\n                    for anc in output[node]:\\n                        output[desc].add(anc)\\n                    inDegree[desc] -= 1\\n                    if inDegree[desc] == 0:\\n                        queue.append(desc)\\n        for i in range(n):\\n            output[i] = sorted(list(output[i]))\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823141,
                "title": "java-solution",
                "content": "\\tpublic List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for(int[] e : edges){\\n            map.putIfAbsent(e[1], new HashSet<>());\\n            map.get(e[1]).add(e[0]);\\n        }\\n        Map<Integer, Set<Integer>> dp = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            res.add(new ArrayList<>(dfs(map, dp, i)));\\n        }\\n        return res;\\n    }\\n    \\n    Set<Integer> dfs(Map<Integer, Set<Integer>> map, Map<Integer, Set<Integer>> dp, int cur){\\n        if(dp.containsKey(cur))\\n            return dp.get(cur);\\n        Set<Integer> set = new TreeSet<>();\\n        for(int nei: map.getOrDefault(cur, new HashSet<>())){\\n            set.add(nei);\\n            set.addAll(dfs(map, dp, nei));\\n        }\\n        dp.put(cur, set);\\n        return set;\\n    }",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "\\tpublic List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for(int[] e : edges){\\n            map.putIfAbsent(e[1], new HashSet<>());\\n            map.get(e[1]).add(e[0]);\\n        }\\n        Map<Integer, Set<Integer>> dp = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            res.add(new ArrayList<>(dfs(map, dp, i)));\\n        }\\n        return res;\\n    }\\n    \\n    Set<Integer> dfs(Map<Integer, Set<Integer>> map, Map<Integer, Set<Integer>> dp, int cur){\\n        if(dp.containsKey(cur))\\n            return dp.get(cur);\\n        Set<Integer> set = new TreeSet<>();\\n        for(int nei: map.getOrDefault(cur, new HashSet<>())){\\n            set.add(nei);\\n            set.addAll(dfs(map, dp, nei));\\n        }\\n        dp.put(cur, set);\\n        return set;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1822994,
                "title": "dfs-solution-with-explanation-faster-than-100-in-time-and-memory-c",
                "content": "public class Solution {\\n    public IList<IList<int>> GetAncestors(int n, int[][] edges) {\\n    \\n    // store all pareent child into this. (parent wil be the index of the key)    \\n    List<IList<int>> children = new List<IList<int>>();    \\n        \\n    // This will hold output values from the above list.    \\n    List<IList<int>> output = new List<IList<int>>();    \\n        \\n    // initialize both the lists so later we don\\'t have to take care of initialing again and again.    \\n    for(int i=0;i<n;i++)\\n    {\\n        children.Add(new List<int>());\\n        output.Add(new List<int>());\\n    }\\n    \\n    // Since edges are in parent-child fashion, edge[0] will be parent and edge[1] will be child\\n    foreach(var edge in edges)\\n    {\\n        children[edge[0]].Add(edge[1]);\\n    }\\n        \\n    // call dfs for all the nodes and fill parent value into all grandchildren\\n    // we are starting from node 0, so all it\\'s children and grandchildren will get 0 filled    \\n    for(int i=0;i<n;i++)\\n    {\\n        bool[] visited = new bool[n];\\n        DFS(i,i,visited,children,output);\\n    }\\n    \\n    return output;\\n    }\\n    \\n    \\n    public void DFS(int parent, int current, bool[] visited, List<IList<int>>children, List<IList<int>> output)\\n    {\\n\\t\\t// every loop in the parent function we are recreating this visited array.\\n\\t\\t// so we have this array only in the recursive scope to skip checking for previsously checked item.\\n        visited[current] = true;\\n        // fill current\\'s father into current\\'s children\\n        \\n        foreach(var child in children[current])\\n        {\\n            if(!visited[child])\\n            {\\n                output[child].Add(parent);\\n                DFS(parent,child,visited,children, output);\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public IList<IList<int>> GetAncestors(int n, int[][] edges) {\\n    \\n    // store all pareent child into this. (parent wil be the index of the key)    \\n    List<IList<int>> children = new List<IList<int>>();    \\n        \\n    // This will hold output values from the above list.    \\n    List<IList<int>> output = new List<IList<int>>();    \\n        \\n    // initialize both the lists so later we don\\'t have to take care of initialing again and again.    \\n    for(int i=0;i<n;i++)\\n    {\\n        children.Add(new List<int>());\\n        output.Add(new List<int>());\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1822772,
                "title": "python3-very-direct-and-simple-bfs",
                "content": "Brute force BFS\\n\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        # contruct a graph from children to parent\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[b].append(a)\\n        \\n        ans = []\\n        for i in range(n):\\n            queue = deque([i])\\n            visited = set()\\n            while queue:\\n                node = queue.popleft()\\n                for nei in graph[node]:\\n                    if nei not in visited:\\n                        queue.append(nei)\\n                        visited.add(nei)\\n            ans.append(sorted(list(visited)))\\n        return ans\\n                    \\n",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "Brute force BFS\\n\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        # contruct a graph from children to parent\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[b].append(a)\\n        \\n        ans = []\\n        for i in range(n):\\n            queue = deque([i])\\n            visited = set()\\n            while queue:\\n                node = queue.popleft()\\n                for nei in graph[node]:\\n                    if nei not in visited:\\n                        queue.append(nei)\\n                        visited.add(nei)\\n            ans.append(sorted(list(visited)))\\n        return ans\\n                    \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1822721,
                "title": "c-very-simple-solution-dfs-beats-95-o-n-2",
                "content": "**Please UPVOTE if you like the solution.**\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], int u, vector<int> &vec, vector<bool> &vis){\\n        \\n        vis[u] = true;\\n        \\n        for(auto v: adj[u]){\\n            if(vis[v] == false){\\n                vec.push_back(v);\\n                dfs(adj, v, vec, vis);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> ans;\\n        vector<int> adj[n];\\n        \\n        for(auto it: edges)\\n            adj[it[1]].push_back(it[0]);\\n        \\n        for(int i=0 ; i<n ; i++){\\n            vector<bool> vis(n, false);\\n            vector<int> v;\\n            \\n            dfs(adj, i, v, vis);\\n            sort(v.begin(), v.end());\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], int u, vector<int> &vec, vector<bool> &vis){\\n        \\n        vis[u] = true;\\n        \\n        for(auto v: adj[u]){\\n            if(vis[v] == false){\\n                vec.push_back(v);\\n                dfs(adj, v, vec, vis);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> ans;\\n        vector<int> adj[n];\\n        \\n        for(auto it: edges)\\n            adj[it[1]].push_back(it[0]);\\n        \\n        for(int i=0 ; i<n ; i++){\\n            vector<bool> vis(n, false);\\n            vector<int> v;\\n            \\n            dfs(adj, i, v, vis);\\n            sort(v.begin(), v.end());\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822571,
                "title": "java-easy-bfs",
                "content": "Can also be done using dfs\\n```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n        List<List<Integer>> list=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList<>());\\n        for(int i=0;i<n;i++)\\n            list.add(new ArrayList<>());\\n        for(int i=0;i<edges.length;i++)\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n        for(int i=0;i<n;i++){\\n            Queue<Integer> q=new ArrayDeque<>();\\n            boolean[] vis=new boolean[n];\\n            q.add(i);\\n            vis[i]=true;\\n            while(!q.isEmpty()){\\n                int node=q.remove();\\n                \\n                if(node!=i)\\n                    list.get(node).add(i);\\n                for(int ele:adj.get(node)){\\n                    if(!vis[ele]){\\n                        vis[ele]=true;\\n                        q.add(ele);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n            Collections.sort(list.get(i));\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n        List<List<Integer>> list=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList<>());\\n        for(int i=0;i<n;i++)\\n            list.add(new ArrayList<>());\\n        for(int i=0;i<edges.length;i++)\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n        for(int i=0;i<n;i++){\\n            Queue<Integer> q=new ArrayDeque<>();\\n            boolean[] vis=new boolean[n];\\n            q.add(i);\\n            vis[i]=true;\\n            while(!q.isEmpty()){\\n                int node=q.remove();\\n                \\n                if(node!=i)\\n                    list.get(node).add(i);\\n                for(int ele:adj.get(node)){\\n                    if(!vis[ele]){\\n                        vis[ele]=true;\\n                        q.add(ele);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n            Collections.sort(list.get(i));\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822543,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n     HashMap<Integer,TreeSet<Integer>> amap=new HashMap<>();\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n         HashMap<Integer,List<Integer>> map=new HashMap<>();\\n         int[] in=new int[n];\\n         for(int i=0;i<n;i++)\\n         {\\n             map.put(i,new ArrayList<>());\\n            amap.put(i,new TreeSet<>());\\n        }\\n        for(int[] a:edges)\\n        {\\n            map.get(a[0]).add(a[1]);\\n            in[a[1]]++;\\n        }\\n        Queue<Integer> queue=new LinkedList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            {\\n               // System.out.println(i);\\n                queue.add(i);\\n                //dfs(i,map,new ArrayList<>());\\n            }\\n        }\\n        while(!queue.isEmpty())\\n        {\\n            int value=queue.poll();\\n            if(map.get(value).size()>0)\\n            {\\n                for(int a:map.get(value))\\n                {\\n                    amap.get(a).add(value);\\n                    amap.get(a).addAll(amap.get(value));\\n                    in[a]--;\\n                    if(in[a]==0)\\n                    {\\n                        queue.add(a);\\n                    }\\n                }\\n            }\\n        }\\n         List<List<Integer>> result=new ArrayList<>();\\n        for(int a:amap.keySet())\\n        {\\n            TreeSet<Integer> set=amap.get(a);\\n            List<Integer> templist=new ArrayList<>();\\n            for(int val:set)\\n            {\\n                templist.add(val);\\n            }\\n            result.add(templist);\\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     HashMap<Integer,TreeSet<Integer>> amap=new HashMap<>();\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n         HashMap<Integer,List<Integer>> map=new HashMap<>();\\n         int[] in=new int[n];\\n         for(int i=0;i<n;i++)\\n         {\\n             map.put(i,new ArrayList<>());\\n            amap.put(i,new TreeSet<>());\\n        }\\n        for(int[] a:edges)\\n        {\\n            map.get(a[0]).add(a[1]);\\n            in[a[1]]++;\\n        }\\n        Queue<Integer> queue=new LinkedList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(in[i]==0)\\n            {\\n               // System.out.println(i);\\n                queue.add(i);\\n                //dfs(i,map,new ArrayList<>());\\n            }\\n        }\\n        while(!queue.isEmpty())\\n        {\\n            int value=queue.poll();\\n            if(map.get(value).size()>0)\\n            {\\n                for(int a:map.get(value))\\n                {\\n                    amap.get(a).add(value);\\n                    amap.get(a).addAll(amap.get(value));\\n                    in[a]--;\\n                    if(in[a]==0)\\n                    {\\n                        queue.add(a);\\n                    }\\n                }\\n            }\\n        }\\n         List<List<Integer>> result=new ArrayList<>();\\n        for(int a:amap.keySet())\\n        {\\n            TreeSet<Integer> set=amap.get(a);\\n            List<Integer> templist=new ArrayList<>();\\n            for(int val:set)\\n            {\\n                templist.add(val);\\n            }\\n            result.add(templist);\\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822456,
                "title": "javascript-dfs-with-set",
                "content": "```\\nvar getAncestors = function(n, edges) {\\n    const nodes = new Array(n);\\n    for (let i = 0; i < edges.length; ++i) {\\n        if (!nodes[edges[i][1]]) nodes[edges[i][1]] = [];\\n        nodes[edges[i][1]].push(edges[i][0]);\\n    }\\n    \\n    const set = new Set();\\n    const result = new Array(n);\\n    \\n    const dfs = (node) => {\\n        set.add(node);\\n        if (nodes[node]) {\\n            for (let i = 0; i < nodes[node].length; ++i) {\\n                if (set.has(nodes[node][i]) === false) {\\n                    dfs(nodes[node][i]);\\n                }\\n            }\\n        }\\n    };\\n    \\n    for (let i = 0; i < n; ++i) {\\n        set.clear();\\n        \\n        if (nodes[i]) {\\n            for (const node of nodes[i]) {\\n                dfs(node);\\n            }\\n        }\\n        \\n        result[i] = Array.from(set);\\n        result[i].sort((a, b) => a - b);\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar getAncestors = function(n, edges) {\\n    const nodes = new Array(n);\\n    for (let i = 0; i < edges.length; ++i) {\\n        if (!nodes[edges[i][1]]) nodes[edges[i][1]] = [];\\n        nodes[edges[i][1]].push(edges[i][0]);\\n    }\\n    \\n    const set = new Set();\\n    const result = new Array(n);\\n    \\n    const dfs = (node) => {\\n        set.add(node);\\n        if (nodes[node]) {\\n            for (let i = 0; i < nodes[node].length; ++i) {\\n                if (set.has(nodes[node][i]) === false) {\\n                    dfs(nodes[node][i]);\\n                }\\n            }\\n        }\\n    };\\n    \\n    for (let i = 0; i < n; ++i) {\\n        set.clear();\\n        \\n        if (nodes[i]) {\\n            for (const node of nodes[i]) {\\n                dfs(node);\\n            }\\n        }\\n        \\n        result[i] = Array.from(set);\\n        result[i].sort((a, b) => a - b);\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822373,
                "title": "c-dfs-easy-and-consise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void dfs(int node,unordered_map<int,vector<int>>&graph, vector<int>&res,vector<bool>&vis){\\n        vis[node]=1;\\n        for(auto x:graph[node]){\\n            if(!vis[x]){\\n                res.push_back(x);\\n                dfs(x,graph,res,vis);\\n            }     \\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>>graph;\\n        for(auto e:edges){\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<int>res;\\n            vector<bool>vis(n,false);\\n            dfs(i,graph,res,vis);\\n            sort(res.begin(),res.end());\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void dfs(int node,unordered_map<int,vector<int>>&graph, vector<int>&res,vector<bool>&vis){\\n        vis[node]=1;\\n        for(auto x:graph[node]){\\n            if(!vis[x]){\\n                res.push_back(x);\\n                dfs(x,graph,res,vis);\\n            }     \\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>>graph;\\n        for(auto e:edges){\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<int>res;\\n            vector<bool>vis(n,false);\\n            dfs(i,graph,res,vis);\\n            sort(res.begin(),res.end());\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822339,
                "title": "c-solution-bfs",
                "content": "**C++:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> graph[n];\\n        int arr[n];\\n        memset(arr,0,sizeof(arr));\\n        \\n        for(auto it: edges){\\n            arr[it[1]]+=1;\\n            graph[it[0]].push_back(it[1]);\\n        }\\n        \\n        queue<int> q;\\n        vector<int> res;\\n        \\n        for(int i=0;i<n;i++){\\n            if(arr[i]==0)\\n            {\\n                q.push(i);\\n                res.push_back(i);\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int f = q.front();\\n            q.pop();\\n            for(auto it : graph[f]){\\n                arr[it]-=1;\\n                if(arr[it]==0)\\n                {\\n                    q.push(it);\\n                    res.push_back(it);\\n                }\\n            }\\n        }\\n        vector<unordered_set<int>> ans(n);\\n        vector<vector<int>> fans;\\n        \\n        for(int i=0 ; i<n ; i++){\\n            int val = res[i];\\n            for(auto it : graph[val]){\\n                ans[it].insert(val);\\n                for(auto it2: ans[val]) ans[it].insert(it2);\\n            }\\n        }\\n        \\n        for(auto it: ans){\\n            vector<int> temp;\\n            for(auto it2: it) temp.push_back(it2);\\n            sort(temp.begin(),temp.end());\\n            fans.push_back(temp);\\n        }\\n        \\n        return fans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> graph[n];\\n        int arr[n];\\n        memset(arr,0,sizeof(arr));\\n        \\n        for(auto it: edges){\\n            arr[it[1]]+=1;\\n            graph[it[0]].push_back(it[1]);\\n        }\\n        \\n        queue<int> q;\\n        vector<int> res;\\n        \\n        for(int i=0;i<n;i++){\\n            if(arr[i]==0)\\n            {\\n                q.push(i);\\n                res.push_back(i);\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int f = q.front();\\n            q.pop();\\n            for(auto it : graph[f]){\\n                arr[it]-=1;\\n                if(arr[it]==0)\\n                {\\n                    q.push(it);\\n                    res.push_back(it);\\n                }\\n            }\\n        }\\n        vector<unordered_set<int>> ans(n);\\n        vector<vector<int>> fans;\\n        \\n        for(int i=0 ; i<n ; i++){\\n            int val = res[i];\\n            for(auto it : graph[val]){\\n                ans[it].insert(val);\\n                for(auto it2: ans[val]) ans[it].insert(it2);\\n            }\\n        }\\n        \\n        for(auto it: ans){\\n            vector<int> temp;\\n            for(auto it2: it) temp.push_back(it2);\\n            sort(temp.begin(),temp.end());\\n            fans.push_back(temp);\\n        }\\n        \\n        return fans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822260,
                "title": "cpp-easisest-solution-dfs",
                "content": "**APPROACH**\\n\\n*OPTIONAL If you like the approach, make an upvote*\\n*Can comment your approach and maximum optimisation possible.*\\n\\n\\n* The question can be think just as \\n* Take a node run the dfs from it so that each and every child get covered\\n* Keep track the child by pushing in the array/set and then store it.\\n* Make sure that dont run the dfs for itself;\\n\\n*Implementation -1*\\n```\\n  vector<vector<int>> ans;\\n    void dfs(int src,vector<int> graph[],int par,vector<int> &vis,vector<int> &temp){\\n        if(src!=par) temp.push_back(src);\\n\\t\\t// only consider the child when it is not parent.\\n\\t\\t\\n        vis[src]=1;\\n\\t\\t\\n        for(int c:graph[src]) if(!vis[c]) dfs(c,graph,par,vis,temp);\\n\\t\\t// run dfs for the further childs.\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> graph[n+1];\\n        for(auto i:edges) graph[i[1]].push_back(i[0]);\\n        for(int i=0;i<n;i++){\\n            vector<int> vis(n+1,0);\\n\\t\\t\\t// for keeping track of visited\\n\\t\\t\\t\\n            vector<int> temp;\\n\\t\\t\\t// storing the child;\\n\\t\\t\\t\\n            dfs(i,graph,i,vis,temp);\\n\\t\\t\\t// passing the value i,twice and in dfs to only push child when node is not parent.\\n\\t\\t\\t\\n            sort(begin(temp),end(temp));\\n\\t\\t\\t// sorting the child received.\\n\\t\\t\\t\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n```\\n*Implementation-2*\\n```\\n vector<vector<int>> ans;\\n    void dfs(int src,vector<int> graph[],int par,set<int> &s,vector<int> &vis){\\n\\t    if(vis[src]) return;\\n\\t\\tvis[src]=1;\\n        if(src!=par) s.insert(src);\\n        for(int c:graph[src]) if(!vis[c]) dfs(c,graph,par,s,vis);\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> graph[n+1];\\n        for(auto i:edges) graph[i[1]].push_back(i[0]);\\n        for(int i=0;i<n;i++){\\n\\t\\t    set<int> s;\\n\\t\\t\\tvector<int> vis(n+1,0);\\n            dfs(i,graph,i,s,vis);\\n\\t\\t\\tvector<int> temp(begin(s),end(s));\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n  vector<vector<int>> ans;\\n    void dfs(int src,vector<int> graph[],int par,vector<int> &vis,vector<int> &temp){\\n        if(src!=par) temp.push_back(src);\\n\\t\\t// only consider the child when it is not parent.\\n\\t\\t\\n        vis[src]=1;\\n\\t\\t\\n        for(int c:graph[src]) if(!vis[c]) dfs(c,graph,par,vis,temp);\\n\\t\\t// run dfs for the further childs.\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> graph[n+1];\\n        for(auto i:edges) graph[i[1]].push_back(i[0]);\\n        for(int i=0;i<n;i++){\\n            vector<int> vis(n+1,0);\\n\\t\\t\\t// for keeping track of visited\\n\\t\\t\\t\\n            vector<int> temp;\\n\\t\\t\\t// storing the child;\\n\\t\\t\\t\\n            dfs(i,graph,i,vis,temp);\\n\\t\\t\\t// passing the value i,twice and in dfs to only push child when node is not parent.\\n\\t\\t\\t\\n            sort(begin(temp),end(temp));\\n\\t\\t\\t// sorting the child received.\\n\\t\\t\\t\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n```\n```\\n vector<vector<int>> ans;\\n    void dfs(int src,vector<int> graph[],int par,set<int> &s,vector<int> &vis){\\n\\t    if(vis[src]) return;\\n\\t\\tvis[src]=1;\\n        if(src!=par) s.insert(src);\\n        for(int c:graph[src]) if(!vis[c]) dfs(c,graph,par,s,vis);\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> graph[n+1];\\n        for(auto i:edges) graph[i[1]].push_back(i[0]);\\n        for(int i=0;i<n;i++){\\n\\t\\t    set<int> s;\\n\\t\\t\\tvector<int> vis(n+1,0);\\n            dfs(i,graph,i,s,vis);\\n\\t\\t\\tvector<int> temp(begin(s),end(s));\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822255,
                "title": "java-dfs-approach-explained",
                "content": "**Approach followed:**\\n1. Create a map for each `fromNode` and add its all `direct ancestors by iteraring over edges.`\\n2. Now for all the nodes, dfs for all its ancestors to add their ancestors (grand ancestors).\\n3. Sort the ancestors list and return the result.\\n\\n**Avoiding TLE**\\nKeep a visited[] when calling dfs for node\\'s ancestors. Once all ancestors are found, mark visited[node] = true.\\nIf node is already visited, it means all its ancestors are already in place. Can add them simply.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        Map<Integer, Set<Integer>> ancestors = new HashMap<>();\\n        calculateAncestors(n, edges, ancestors);\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            List l = new ArrayList<>();\\n            res.add(l);\\n            Set<Integer> set = ancestors.get(i);\\n            if (set != null) {\\n                l.addAll(set);\\n                Collections.sort(l);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private void calculateAncestors(int n, int[][] edges, Map<Integer, Set<Integer>> ancestors) {\\n        for (int[] edge: edges) {\\n            Set<Integer> set = ancestors.get(edge[1]);\\n            if (set == null) {\\n                set = new HashSet<>();\\n                ancestors.put(edge[1], set);\\n            }\\n            set.add(edge[0]);\\n        }\\n        \\n        boolean[] visited = new boolean[n];\\n        for (int i = 0; i < n; ++i) {\\n            helper(ancestors, i, visited);\\n        }\\n    }\\n    \\n    private void helper(Map<Integer, Set<Integer>> ancestors, int to , boolean[] visited) {\\n        Set<Integer> toSet = ancestors.get(to);\\n        if (toSet == null || visited[to]) {\\n            return;\\n        }\\n        Set<Integer> latest = new HashSet<>();\\n        for (int v: toSet) {\\n            if (!visited[v]) {\\n                helper(ancestors, v, visited);\\n            }\\n                \\n            Set<Integer> set = ancestors.get(v);\\n            if (set != null) {\\n                latest.addAll(set);\\n            }\\n        }\\n        toSet.addAll(latest);\\n        visited[to] = true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        Map<Integer, Set<Integer>> ancestors = new HashMap<>();\\n        calculateAncestors(n, edges, ancestors);\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            List l = new ArrayList<>();\\n            res.add(l);\\n            Set<Integer> set = ancestors.get(i);\\n            if (set != null) {\\n                l.addAll(set);\\n                Collections.sort(l);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private void calculateAncestors(int n, int[][] edges, Map<Integer, Set<Integer>> ancestors) {\\n        for (int[] edge: edges) {\\n            Set<Integer> set = ancestors.get(edge[1]);\\n            if (set == null) {\\n                set = new HashSet<>();\\n                ancestors.put(edge[1], set);\\n            }\\n            set.add(edge[0]);\\n        }\\n        \\n        boolean[] visited = new boolean[n];\\n        for (int i = 0; i < n; ++i) {\\n            helper(ancestors, i, visited);\\n        }\\n    }\\n    \\n    private void helper(Map<Integer, Set<Integer>> ancestors, int to , boolean[] visited) {\\n        Set<Integer> toSet = ancestors.get(to);\\n        if (toSet == null || visited[to]) {\\n            return;\\n        }\\n        Set<Integer> latest = new HashSet<>();\\n        for (int v: toSet) {\\n            if (!visited[v]) {\\n                helper(ancestors, v, visited);\\n            }\\n                \\n            Set<Integer> set = ancestors.get(v);\\n            if (set != null) {\\n                latest.addAll(set);\\n            }\\n        }\\n        toSet.addAll(latest);\\n        visited[to] = true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822170,
                "title": "c-solution-set-and-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<int> getAll(int node , vector<int> adj[])\\n    {\\n        \\n        vector<int> ans;\\n        \\n        set<int> s;\\n        queue<int> q;\\n        q.push(node);\\n        \\n        while(!q.empty())\\n        {\\n            int x=q.front();\\n            q.pop();\\n            \\n            for(auto &it:adj[x])\\n            {\\n                if(s.find(it)==s.end())\\n                {\\n                    s.insert(it);\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        \\n        for(auto &it:s)\\n            ans.push_back(it);\\n        return ans;\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        \\n       \\n         vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int from=edges[i][0];\\n            int to=edges[i][1];\\n            \\n            adj[to].push_back(from);  // transpose\\n            \\n        }\\n        \\n        vector<vector<int>> ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> temp=getAll(i,adj);\\n            \\n            ans.push_back(temp);\\n        }\\n        \\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<int> getAll(int node , vector<int> adj[])\\n    {\\n        \\n        vector<int> ans;\\n        \\n        set<int> s;\\n        queue<int> q;\\n        q.push(node);\\n        \\n        while(!q.empty())\\n        {\\n            int x=q.front();\\n            q.pop();\\n            \\n            for(auto &it:adj[x])\\n            {\\n                if(s.find(it)==s.end())\\n                {\\n                    s.insert(it);\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        \\n        for(auto &it:s)\\n            ans.push_back(it);\\n        return ans;\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        \\n       \\n         vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int from=edges[i][0];\\n            int to=edges[i][1];\\n            \\n            adj[to].push_back(from);  // transpose\\n            \\n        }\\n        \\n        vector<vector<int>> ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> temp=getAll(i,adj);\\n            \\n            ans.push_back(temp);\\n        }\\n        \\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822149,
                "title": "well-explained-graph-bfs-cpp-solution",
                "content": "```\\n// BFS\\n\\n// simply stored the edges in the opposite order (like if there is an edge from 1->2, I stored 1 in adj[2]: 2->1).  Basically i reversed the graph\\n\\n// and for each val (0->n-1) i did bfs and stored the parents in a vector and returned it\\n// Then i sorted the vector v and pushed it into ans vector\\n\\n// I hope it helps you. Please do upvote if you like my solution\\n\\nclass Solution {\\npublic:\\n    #define ll int\\n    vector<ll> fun(vector<ll>adj[],vector<ll>&vis,ll n,ll i){\\n        queue<ll>q;vector<ll>v;\\n        q.push(i);\\n        while(!q.empty()){\\n            ll i=q.front();\\n            q.pop();\\n            for(auto x:adj[i]){\\n                if(!vis[x]){\\n                    vis[x]=1;\\n                    v.push_back(x);\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<ll>adj[n];vector<vector<ll>>ans;\\n        for(ll i=0;i<edges.size();i++){\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(ll i=0;i<n;i++){\\n            vector<ll>vis(n,0);\\n            vis[i]=1;\\n            vector<ll>v=fun(adj,vis,n,i);\\n            sort(v.begin(),v.end());\\n            ans.push_back(v);\\n        }\\n        return ans;\\n        \\n    }\\n};``\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n// BFS\\n\\n// simply stored the edges in the opposite order (like if there is an edge from 1->2, I stored 1 in adj[2]: 2->1).  Basically i reversed the graph\\n\\n// and for each val (0->n-1) i did bfs and stored the parents in a vector and returned it\\n// Then i sorted the vector v and pushed it into ans vector\\n\\n// I hope it helps you. Please do upvote if you like my solution\\n\\nclass Solution {\\npublic:\\n    #define ll int\\n    vector<ll> fun(vector<ll>adj[],vector<ll>&vis,ll n,ll i){\\n        queue<ll>q;vector<ll>v;\\n        q.push(i);\\n        while(!q.empty()){\\n            ll i=q.front();\\n            q.pop();\\n            for(auto x:adj[i]){\\n                if(!vis[x]){\\n                    vis[x]=1;\\n                    v.push_back(x);\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<ll>adj[n];vector<vector<ll>>ans;\\n        for(ll i=0;i<edges.size();i++){\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(ll i=0;i<n;i++){\\n            vector<ll>vis(n,0);\\n            vis[i]=1;\\n            vector<ll>v=fun(adj,vis,n,i);\\n            sort(v.begin(),v.end());\\n            ans.push_back(v);\\n        }\\n        return ans;\\n        \\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822136,
                "title": "java-topological-sorting",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        List<TreeSet<Integer>> ans = new ArrayList<>();\\n        List<List<Integer>> adj = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n            ans.add(new TreeSet<>());\\n        }\\n        \\n        int []indegree = new int[n];\\n        \\n        for(int []edge : edges){\\n            adj.get(edge[0]).add(edge[1]);\\n            indegree[edge[1]]++;\\n        }\\n        \\n        Queue<Integer>qu = new LinkedList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0){\\n                qu.add(i);\\n            }\\n        }\\n        \\n        while(!qu.isEmpty()){\\n\\n            int top = qu.poll();\\n            \\n            for(int u:adj.get(top)){\\n                \\n                ans.get(u).add(top);\\n                ans.get(u).addAll(ans.get(top));                    \\n                indegree[u]--;\\n                    \\n                if(indegree[u]==0)\\n                qu.add(u);\\n            }\\n        }\\n        \\n        List<List<Integer>> Ancestors = new ArrayList<>();\\n        \\n        for(var x:ans)\\n            Ancestors.add(new ArrayList<>(x));\\n       \\n        \\n        return Ancestors;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        List<TreeSet<Integer>> ans = new ArrayList<>();\\n        List<List<Integer>> adj = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n            ans.add(new TreeSet<>());\\n        }\\n        \\n        int []indegree = new int[n];\\n        \\n        for(int []edge : edges){\\n            adj.get(edge[0]).add(edge[1]);\\n            indegree[edge[1]]++;\\n        }\\n        \\n        Queue<Integer>qu = new LinkedList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0){\\n                qu.add(i);\\n            }\\n        }\\n        \\n        while(!qu.isEmpty()){\\n\\n            int top = qu.poll();\\n            \\n            for(int u:adj.get(top)){\\n                \\n                ans.get(u).add(top);\\n                ans.get(u).addAll(ans.get(top));                    \\n                indegree[u]--;\\n                    \\n                if(indegree[u]==0)\\n                qu.add(u);\\n            }\\n        }\\n        \\n        List<List<Integer>> Ancestors = new ArrayList<>();\\n        \\n        for(var x:ans)\\n            Ancestors.add(new ArrayList<>(x));\\n       \\n        \\n        return Ancestors;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822124,
                "title": "java-solution-hashmap-set-stack",
                "content": "~~~\\n public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        Map<Integer, List<Integer>> edgesList = new HashMap<>();\\n        \\n        for(int i = 0; i < edges.length; i++) {\\n            \\n            if(!edgesList.containsKey(edges[i][1])) {\\n                edgesList.put(edges[i][1], new ArrayList<Integer>());\\n            }\\n            edgesList.get(edges[i][1]).add(edges[i][0]);\\n            \\n        }\\n                \\n        for(int i = 0; i < n; i++) {\\n            \\n            Set<Integer> set = new HashSet<>();\\n            \\n            if(edgesList.containsKey(i)) {\\n                \\n                Stack<Integer> stack = new Stack<>();\\n                stack.addAll(edgesList.get(i));\\n                \\n                while(!stack.isEmpty()) {\\n                    int current_val = stack.pop();\\n                    \\n                    if(!set.contains(current_val)) {\\n                        set.add(current_val);\\n                        if(edgesList.containsKey(current_val)) {\\n                            stack.addAll(edgesList.get(current_val));\\n                        }\\n                    }\\n                }                \\n            }\\n            \\n            List<Integer> current_list = set.stream().collect(Collectors.toList());\\n            Collections.sort(current_list);\\n            result.add(current_list);\\n        }\\n        \\n        return result;   \\n    }\\n\\n~~~",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Ordered Set"
                ],
                "code": "~~~\\n public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        Map<Integer, List<Integer>> edgesList = new HashMap<>();\\n        \\n        for(int i = 0; i < edges.length; i++) {\\n            \\n            if(!edgesList.containsKey(edges[i][1])) {\\n                edgesList.put(edges[i][1], new ArrayList<Integer>());\\n            }\\n            edgesList.get(edges[i][1]).add(edges[i][0]);\\n            \\n        }\\n                \\n        for(int i = 0; i < n; i++) {\\n            \\n            Set<Integer> set = new HashSet<>();\\n            \\n            if(edgesList.containsKey(i)) {\\n                \\n                Stack<Integer> stack = new Stack<>();\\n                stack.addAll(edgesList.get(i));\\n                \\n                while(!stack.isEmpty()) {\\n                    int current_val = stack.pop();\\n                    \\n                    if(!set.contains(current_val)) {\\n                        set.add(current_val);\\n                        if(edgesList.containsKey(current_val)) {\\n                            stack.addAll(edgesList.get(current_val));\\n                        }\\n                    }\\n                }                \\n            }\\n            \\n            List<Integer> current_list = set.stream().collect(Collectors.toList());\\n            Collections.sort(current_list);\\n            result.add(current_list);\\n        }\\n        \\n        return result;   \\n    }\\n\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 1822088,
                "title": "c-o-n-2-simple-bfs-clear-explanation",
                "content": "Using simple BFS, we find every descendant of node `i` (Say `x`). `i` will be an ancestor of `x`.\\n\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> res;\\npublic:\\n    void bfs(vector<vector<int>>& graph, int i) {\\n        queue<int> q;\\n        vector<bool> vis(graph.size(), false);\\n        \\n        q.push(i);\\n        vis[i] = true;\\n        \\n        while(!q.empty()) {\\n            int curr = q.front();\\n            q.pop();\\n            for(auto &x : graph[curr]) {\\n                if(!vis[x]) {\\n                    res[x].push_back(i); // i is the ancestor of x\\n                    q.push(x);\\n                    vis[x] = true;\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        res = vector<vector<int>>(n);\\n        for(auto &x : edges) {\\n            graph[x[0]].push_back(x[1]);\\n        }\\n        \\n        for(int i = 0; i<n; i++) {\\n            bfs(graph, i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Time Complexity:** O(n^2)\\n\\n**Liked the solution? Kindly UPVOTE!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> res;\\npublic:\\n    void bfs(vector<vector<int>>& graph, int i) {\\n        queue<int> q;\\n        vector<bool> vis(graph.size(), false);\\n        \\n        q.push(i);\\n        vis[i] = true;\\n        \\n        while(!q.empty()) {\\n            int curr = q.front();\\n            q.pop();\\n            for(auto &x : graph[curr]) {\\n                if(!vis[x]) {\\n                    res[x].push_back(i); // i is the ancestor of x\\n                    q.push(x);\\n                    vis[x] = true;\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        res = vector<vector<int>>(n);\\n        for(auto &x : edges) {\\n            graph[x[0]].push_back(x[1]);\\n        }\\n        \\n        for(int i = 0; i<n; i++) {\\n            bfs(graph, i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822064,
                "title": "c-easy-to-understand-bfs-with-detailed-comments",
                "content": "The basic idea is to do BFS in reverse, that is from child to ancestor.\\n\\nWe start at the given node and move backwards and each time we encounter a new node we add it to the BFS queue and the ancestor list\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans; //This vector will be returned in the end\\n        map<int,vector<int>> mp; //Maps the edges in reverse order so that we can efficiently traverse backwards\\n        for(auto i: edges) mp[i[1]].push_back(i[0]);\\n            \\n        for(int i = 0; i < n; ++i){  // We perform BFS for each node starting from 0\\n            vector<int> temp;  // Stores the current node\\'s ancestors\\n            set<int> st;       // To ensure we dont visit/store the same node multiple times\\n            queue<int> curr;   // Standard BFS code, stores the current set of nodes to visit\\n            queue<int> next;   // Standard BFS code, stores the nodes that will be visited in the next iteration\\n            curr.push(i);      // First node to be visited is the current node\\n              \\n            while(!curr.empty() || !next.empty()){ //Start of BFS code \\n                \\n                while(!curr.empty()){\\n\\n                    for(auto j: mp[curr.front()]){ // We iterate through the list of direct ancestors of current node\\n                        if(st.find(j) == st.end()){ // Check that the current ancestor hasnt been already traversed\\n                            next.push(j);\\n                            temp.push_back(j);\\n                            st.insert(j);\\n                        }\\n                    }\\n                    curr.pop();\\n                }\\n                while(!next.empty()){ // Move nodes from next to current queue\\n                    curr.push(next.front());\\n                    next.pop();\\n                }\\n                \\n            } // End of BFS code\\n            \\n            sort(temp.begin(), temp.end()); // Sort just in case\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans; //This vector will be returned in the end\\n        map<int,vector<int>> mp; //Maps the edges in reverse order so that we can efficiently traverse backwards\\n        for(auto i: edges) mp[i[1]].push_back(i[0]);\\n            \\n        for(int i = 0; i < n; ++i){  // We perform BFS for each node starting from 0\\n            vector<int> temp;  // Stores the current node\\'s ancestors\\n            set<int> st;       // To ensure we dont visit/store the same node multiple times\\n            queue<int> curr;   // Standard BFS code, stores the current set of nodes to visit\\n            queue<int> next;   // Standard BFS code, stores the nodes that will be visited in the next iteration\\n            curr.push(i);      // First node to be visited is the current node\\n              \\n            while(!curr.empty() || !next.empty()){ //Start of BFS code \\n                \\n                while(!curr.empty()){\\n\\n                    for(auto j: mp[curr.front()]){ // We iterate through the list of direct ancestors of current node\\n                        if(st.find(j) == st.end()){ // Check that the current ancestor hasnt been already traversed\\n                            next.push(j);\\n                            temp.push_back(j);\\n                            st.insert(j);\\n                        }\\n                    }\\n                    curr.pop();\\n                }\\n                while(!next.empty()){ // Move nodes from next to current queue\\n                    curr.push(next.front());\\n                    next.pop();\\n                }\\n                \\n            } // End of BFS code\\n            \\n            sort(temp.begin(), temp.end()); // Sort just in case\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1822054,
                "title": "python-easy-dfs-solution",
                "content": "Here instead of taking an edge from parent to child, I assume an edge from child to parent and the problem becomes easy i.e. children of a node.\\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        \\n        adj = [[] for i in range(n)]\\n        for i in range(len(edges)):\\n            adj[edges[i][1]].append(edges[i][0])\\n        \\n        ans = [set() for i in range(n)]\\n        visited = [True]*n\\n            \\n        def dfs(v):\\n            visited[v] = False\\n            for i in adj[v]:\\n                ans[v].add(i)\\n                if visited[i]:\\n                    dfs(i)\\n                ans[v] = ans[v].union(ans[i])\\n        \\n        for i in range(n):\\n            if visited[i]:\\n                dfs(i)\\n                \\n        for i in range(n):\\n            ans[i] = sorted(list(ans[i]))\\n        return ans \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        \\n        adj = [[] for i in range(n)]\\n        for i in range(len(edges)):\\n            adj[edges[i][1]].append(edges[i][0])\\n        \\n        ans = [set() for i in range(n)]\\n        visited = [True]*n\\n            \\n        def dfs(v):\\n            visited[v] = False\\n            for i in adj[v]:\\n                ans[v].add(i)\\n                if visited[i]:\\n                    dfs(i)\\n                ans[v] = ans[v].union(ans[i])\\n        \\n        for i in range(n):\\n            if visited[i]:\\n                dfs(i)\\n                \\n        for i in range(n):\\n            ans[i] = sorted(list(ans[i]))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821983,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n+1);\\n        for (auto it:edges){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        vector<vector<int>> v;\\n        \\n        for (int i =0; i<n; i++){\\n            vector<int> temp;\\n            queue<int> q;\\n            q.push(i);\\n            set<int> vis;\\n            vis.insert(i);\\n            while(q.empty()==0){\\n                int x = q.front();\\n                q.pop();\\n                for (auto it:adj[x]){\\n                    if (vis.find(it)==vis.end()){\\n                        vis.insert(it);\\n                        temp.push_back(it);\\n                        q.push(it);\\n                    }\\n                }\\n                \\n            }\\n            sort(temp.begin(),temp.end());\\n            v.push_back(temp);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n+1);\\n        for (auto it:edges){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        vector<vector<int>> v;\\n        \\n        for (int i =0; i<n; i++){\\n            vector<int> temp;\\n            queue<int> q;\\n            q.push(i);\\n            set<int> vis;\\n            vis.insert(i);\\n            while(q.empty()==0){\\n                int x = q.front();\\n                q.pop();\\n                for (auto it:adj[x]){\\n                    if (vis.find(it)==vis.end()){\\n                        vis.insert(it);\\n                        temp.push_back(it);\\n                        q.push(it);\\n                    }\\n                }\\n                \\n            }\\n            sort(temp.begin(),temp.end());\\n            v.push_back(temp);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821976,
                "title": "brute-force-solution-in-c",
                "content": "```\\nclass Solution {\\nprivate:    \\n    void dfs(int currNode,int parent,vector<int> adjList[],vector<bool>& visited,unordered_map<int,vector<int>>& ans)\\n    {\\n        if(visited[currNode])\\n            return;\\n     \\n        if(currNode != parent)\\n            ans[currNode].push_back(parent);\\n            \\n        visited[currNode]=true;\\n        \\n        for(auto& adjNode : adjList[currNode])\\n        {\\n            if(visited[adjNode] == false)\\n            {\\n                dfs(adjNode,parent,adjList,visited,ans);\\n            }\\n        }\\n    }    \\npublic:\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> adjList[n];\\n        \\n        for(auto& edg : edges)\\n        {\\n            adjList[edg[0]].push_back(edg[1]);\\n        }\\n        \\n        unordered_map<int,vector<int>> ans;        \\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            vector<bool> visited(n,false);\\n            dfs(i,i,adjList,visited,ans);\\n        }  \\n        \\n        vector<vector<int>> res;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(ans.find(i) == ans.end())\\n                res.push_back({});\\n            else\\n                res.push_back(ans[i]);\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\nprivate:    \\n    void dfs(int currNode,int parent,vector<int> adjList[],vector<bool>& visited,unordered_map<int,vector<int>>& ans)\\n    {\\n        if(visited[currNode])\\n            return;\\n     \\n        if(currNode != parent)\\n            ans[currNode].push_back(parent);\\n            \\n        visited[currNode]=true;\\n        \\n        for(auto& adjNode : adjList[currNode])\\n        {\\n            if(visited[adjNode] == false)\\n            {\\n                dfs(adjNode,parent,adjList,visited,ans);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1821972,
                "title": "topological-sort-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> g[10005];\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n\\n        int ind[1001];\\n        memset(ind,0,sizeof ind);\\n\\n        for(auto it:edges)\\n        {\\n            int s = it[0];\\n            int d = it[1];\\n            g[s].push_back(d);\\n            ind[d]++;\\n\\n        }\\n\\n        set<int> s[n];\\n\\n        vector<vector<int>> ans(n);\\n\\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ind[i] == 0)q.push(i);\\n        }\\n\\n        while(!q.empty())\\n        {\\n            int now = q.front();\\n            q.pop();\\n\\n            for(auto v:g[now])\\n            {\\n                s[v].insert(now);\\n                for(int x: s[now])s[v].insert(x);\\n                ind[v]--;\\n                if(ind[v] == 0){\\n                    q.push(v);\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int x:s[i])\\n            {\\n                ans[i].push_back(x);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> g[10005];\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n\\n        int ind[1001];\\n        memset(ind,0,sizeof ind);\\n\\n        for(auto it:edges)\\n        {\\n            int s = it[0];\\n            int d = it[1];\\n            g[s].push_back(d);\\n            ind[d]++;\\n\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1821951,
                "title": "c-kahn-s-algorithm-topo-sort-dfs",
                "content": "\\t\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tvoid dfs(int x,vector<vector<int>>&parents,set<int>&s){\\n\\t\\t\\t\\t\\ts.insert(x);\\n\\t\\t\\t\\t\\tfor(auto y:parents[x]){\\n\\t\\t\\t\\t\\t\\tif(s.count(y)){\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tdfs(y,parents,s);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n\\t\\t\\t\\t\\tvector<int>adj[n];\\n\\t\\t\\t\\t\\t// calculate Indegree of each vertex\\n\\t\\t\\t\\t\\tint in[n];\\n\\t\\t\\t\\t\\tmemset(in,0,sizeof(in));\\n\\t\\t\\t\\t\\tfor(auto x:edges)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tadj[x[0]].push_back(x[1]);\\n\\t\\t\\t\\t\\t\\tin[x[1]]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t// Use kahn\\'s Algorithms to traverse DAG(Directed acyclic graph).\\n\\t\\t\\t\\t\\tqueue<int>q;\\n\\n\\t\\t\\t\\t\\tfor(int i = 0;i<n;i++){\\n\\t\\t\\t\\t\\t\\tif(in[i]==0){\\n\\t\\t\\t\\t\\t\\t\\tq.push(i);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tvector<vector<int>>parents(n);\\n\\t\\t\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\t\\t\\tauto cur = q.front();\\n\\t\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\t\\tfor(auto x:adj[cur]){\\n\\t\\t\\t\\t\\t\\t\\tparents[x].push_back(cur);\\n\\t\\t\\t\\t\\t\\t\\tif(--in[x]==0){\\n\\t\\t\\t\\t\\t\\t\\t\\tq.push(x);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tvector<vector<int>>res;\\n\\t\\t\\t\\t\\tfor(auto x:parents){\\n\\t\\t\\t\\t\\t\\t// use set data structure to store data in ascending order\\n\\t\\t\\t\\t\\t\\tset<int>s;\\n\\t\\t\\t\\t\\t\\t// Do DFS for store all parents of parents\\n\\t\\t\\t\\t\\t\\tfor(auto y:x){\\n\\t\\t\\t\\t\\t\\t\\tdfs(y,parents,s);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tvector<int>temp(s.begin(),s.end());\\n\\t\\t\\t\\t\\t\\tres.push_back(temp);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};",
                "solutionTags": [
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tvoid dfs(int x,vector<vector<int>>&parents,set<int>&s){\\n\\t\\t\\t\\t\\ts.insert(x);\\n\\t\\t\\t\\t\\tfor(auto y:parents[x]){\\n\\t\\t\\t\\t\\t\\tif(s.count(y)){\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4064410,
                "title": "java-solution-using-topological-sort-and-treeset",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(V+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        List<TreeSet<Integer>> tset = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n            tset.add(new TreeSet<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n        }\\n        int[] indegree = new int[n];\\n        int[] topSort = new int[n];\\n        for(int i=0;i<adj.size();i++){\\n            for(int it : adj.get(i)){\\n                indegree[it]++;\\n            }\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0){\\n                q.add(i);\\n            }\\n        }\\n        int idx=0;\\n        while(!q.isEmpty()){\\n            int curr = q.remove();\\n            topSort[idx]=curr;\\n            idx++;\\n            for(int it:adj.get(curr)){\\n                tset.get(it).addAll(new TreeSet(tset.get(curr)));\\n                tset.get(it).add(curr);\\n                indegree[it]--;\\n                if(indegree[it]==0){\\n                    q.add(it);\\n                }\\n            }\\n        }\\n   \\n        List<List<Integer>> ancestors = new ArrayList<>();\\n        for(TreeSet<Integer> set : tset){\\n            ancestors.add(new ArrayList<>(set));\\n        }\\n       \\n        return ancestors;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        List<TreeSet<Integer>> tset = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n            tset.add(new TreeSet<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n        }\\n        int[] indegree = new int[n];\\n        int[] topSort = new int[n];\\n        for(int i=0;i<adj.size();i++){\\n            for(int it : adj.get(i)){\\n                indegree[it]++;\\n            }\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==0){\\n                q.add(i);\\n            }\\n        }\\n        int idx=0;\\n        while(!q.isEmpty()){\\n            int curr = q.remove();\\n            topSort[idx]=curr;\\n            idx++;\\n            for(int it:adj.get(curr)){\\n                tset.get(it).addAll(new TreeSet(tset.get(curr)));\\n                tset.get(it).add(curr);\\n                indegree[it]--;\\n                if(indegree[it]==0){\\n                    q.add(it);\\n                }\\n            }\\n        }\\n   \\n        List<List<Integer>> ancestors = new ArrayList<>();\\n        for(TreeSet<Integer> set : tset){\\n            ancestors.add(new ArrayList<>(set));\\n        }\\n       \\n        return ancestors;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064220,
                "title": "cpp-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    void findone(vector<vector<int>>&edges,int i,int p,vector<vector<int>>&ans,vector<bool>&vis){\\n        vis[p]=1;\\n        for(auto &x:edges[p]){\\n            if(!vis[x]){\\n                ans[x].push_back(i);\\n                findone(edges,i,x,ans,vis);\\n            }\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>ans(n),graph(n);\\n        for(auto &v:edges){\\n            graph[v[0]].push_back(v[1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<bool>vis(n);\\n            findone(graph,i,i,ans,vis);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void findone(vector<vector<int>>&edges,int i,int p,vector<vector<int>>&ans,vector<bool>&vis){\\n        vis[p]=1;\\n        for(auto &x:edges[p]){\\n            if(!vis[x]){\\n                ans[x].push_back(i);\\n                findone(edges,i,x,ans,vis);\\n            }\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>ans(n),graph(n);\\n        for(auto &v:edges){\\n            graph[v[0]].push_back(v[1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<bool>vis(n);\\n            findone(graph,i,i,ans,vis);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058620,
                "title": "dfs-traversal-from-child-to-parent",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst we have to adjacency list which stores all my incoming edges to that node.And then for every node We will traverse from child to parent and push back into the vector  \\n\\n# Complexity\\n- Time complexity: O(N+E) +O(N)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    void dfs(int node,vector<int>&vis,map<int,vector<int>>&outedge,vector<int>&v){\\n        for(auto it:outedge[node]){\\n            if(!vis[it]){\\n                v.push_back(it);\\n                vis[it]=1;\\n                dfs(it,vis,outedge,v);\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        map<int,vector<int>>outedge;\\n        vector<vector<int>>ans;\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            outedge[v].push_back(u);\\n        }\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            vector<int>vis(n,0);\\n            dfs(i,vis,outedge,v);\\n            sort(v.begin(),v.end());\\n            ans.push_back(v);\\n            v.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    void dfs(int node,vector<int>&vis,map<int,vector<int>>&outedge,vector<int>&v){\\n        for(auto it:outedge[node]){\\n            if(!vis[it]){\\n                v.push_back(it);\\n                vis[it]=1;\\n                dfs(it,vis,outedge,v);\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        map<int,vector<int>>outedge;\\n        vector<vector<int>>ans;\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            outedge[v].push_back(u);\\n        }\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            vector<int>vis(n,0);\\n            dfs(i,vis,outedge,v);\\n            sort(v.begin(),v.end());\\n            ans.push_back(v);\\n            v.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058473,
                "title": "c-dfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(int s,vector<int> &temp,vector<int> &vis,unordered_map<int,vector<int>> &mp){\\n    vis[s]=1;\\n    if(mp.count(s)){\\n        for(auto it: mp[s]){\\n            if(!vis[it]){\\n                temp.push_back(it);\\n                dfs(it,temp,vis,mp);\\n            }\\n        }\\n    }\\n}\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> mp;\\n        //storing child and their parents\\n        sort(edges.begin(),edges.end());\\n        for(auto it: edges){\\n            mp[it[1]].push_back(it[0]);\\n        }\\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++){\\n            // set<int> st;\\n            vector<int> vis(n,0);\\n            vector<int> temp;\\n            if(!mp.count(i)){\\n                ans.push_back(temp);\\n            }\\n            else{\\n                dfs(i,temp,vis,mp);\\n                sort(temp.begin(),temp.end());\\n                ans.push_back(temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(int s,vector<int> &temp,vector<int> &vis,unordered_map<int,vector<int>> &mp){\\n    vis[s]=1;\\n    if(mp.count(s)){\\n        for(auto it: mp[s]){\\n            if(!vis[it]){\\n                temp.push_back(it);\\n                dfs(it,temp,vis,mp);\\n            }\\n        }\\n    }\\n}\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> mp;\\n        //storing child and their parents\\n        sort(edges.begin(),edges.end());\\n        for(auto it: edges){\\n            mp[it[1]].push_back(it[0]);\\n        }\\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++){\\n            // set<int> st;\\n            vector<int> vis(n,0);\\n            vector<int> temp;\\n            if(!mp.count(i)){\\n                ans.push_back(temp);\\n            }\\n            else{\\n                dfs(i,temp,vis,mp);\\n                sort(temp.begin(),temp.end());\\n                ans.push_back(temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055327,
                "title": "c-reversing-the-edges",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2logn)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(vector<int> adj[], int s, vector<int> &curr, vector<bool> &visited){\\n        visited[s] = true;\\n        for(int x: adj[s]){\\n            if(visited[x] == false){\\n                curr.push_back(x);\\n                dfs(adj, x, curr,visited);\\n            }\\n        }\\n        // visited[s] = false;\\n    }\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans;\\n        vector<int> adj[n];\\n        for(auto x: edges){\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i = 0; i < n; i++){\\n            vector<int> curr;\\n            vector<bool> visited(n, false);\\n            dfs(adj, i, curr, visited);\\n            sort(curr.begin(), curr.end());\\n            ans.push_back(curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(vector<int> adj[], int s, vector<int> &curr, vector<bool> &visited){\\n        visited[s] = true;\\n        for(int x: adj[s]){\\n            if(visited[x] == false){\\n                curr.push_back(x);\\n                dfs(adj, x, curr,visited);\\n            }\\n        }\\n        // visited[s] = false;\\n    }\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans;\\n        vector<int> adj[n];\\n        for(auto x: edges){\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for(int i = 0; i < n; i++){\\n            vector<int> curr;\\n            vector<bool> visited(n, false);\\n            dfs(adj, i, curr, visited);\\n            sort(curr.begin(), curr.end());\\n            ans.push_back(curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048124,
                "title": "reversing-the-edges-c-dfs-easy-approach",
                "content": "```\\nvoid dfs(int node , vector<int>& ancestors , vector<int>& vis , vector<int> adj[]){\\n        \\n        vis[node] = 1;\\n        ancestors.push_back(node);\\n        \\n        for(auto it : adj[node]){\\n            \\n            if(!vis[it])\\n                dfs(it , ancestors , vis , adj);\\n        }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> adj[n];\\n        vector<vector<int>> allAncestors;\\n        \\n        for(auto it : edges){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        for(int i=0 ; i<n ; i++){\\n            \\n            vector<int> vis(n , 0);\\n            vector<int> ancestors;\\n            dfs(i , ancestors , vis , adj);\\n            \\n            ancestors.erase(ancestors.begin());\\n            sort(ancestors.begin() , ancestors.end());\\n            allAncestors.push_back(ancestors);\\n        }\\n        \\n        return allAncestors;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid dfs(int node , vector<int>& ancestors , vector<int>& vis , vector<int> adj[]){\\n        \\n        vis[node] = 1;\\n        ancestors.push_back(node);\\n        \\n        for(auto it : adj[node]){\\n            \\n            if(!vis[it])\\n                dfs(it , ancestors , vis , adj);\\n        }\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> adj[n];\\n        vector<vector<int>> allAncestors;\\n        \\n        for(auto it : edges){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        for(int i=0 ; i<n ; i++){\\n            \\n            vector<int> vis(n , 0);\\n            vector<int> ancestors;\\n            dfs(i , ancestors , vis , adj);\\n            \\n            ancestors.erase(ancestors.begin());\\n            sort(ancestors.begin() , ancestors.end());\\n            allAncestors.push_back(ancestors);\\n        }\\n        \\n        return allAncestors;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034320,
                "title": "simple-dfs-beginner-s-friendly",
                "content": "# Intuition\\nSimply First reverse the Graph Edges.\\nand do dfs fromt each vertices having distinct values by taking a visited.\\nand sort the temp vector and simply pushback in the ans vector.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(int s, vector<int>*adj,vector<int>&v,vector<bool>&visited){\\n    visited[s]=true;\\n    for(int x:adj[s]){\\n        if(!visited[x])\\n        dfs(x,adj,v,visited);\\n    }\\n    v.push_back(s);\\n}\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>ans(n);\\n        vector<int>adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<int>t;\\n            vector<bool>visited(n,false);\\n            dfs(i,adj,t,visited);\\n            \\n            if(t.size()>0)\\n            t.pop_back();\\n            sort(t.begin(),t.end());\\n            ans[i]=t;\\n            t.clear();\\n            visited.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(int s, vector<int>*adj,vector<int>&v,vector<bool>&visited){\\n    visited[s]=true;\\n    for(int x:adj[s]){\\n        if(!visited[x])\\n        dfs(x,adj,v,visited);\\n    }\\n    v.push_back(s);\\n}\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>ans(n);\\n        vector<int>adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<int>t;\\n            vector<bool>visited(n,false);\\n            dfs(i,adj,t,visited);\\n            \\n            if(t.size()>0)\\n            t.pop_back();\\n            sort(t.begin(),t.end());\\n            ans[i]=t;\\n            t.clear();\\n            visited.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033150,
                "title": "clean-c-17-style-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndfs\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        // dfs the nodes as the question denotes DAG and n <= 1000\\n        \\n        // set to save intermediate value\\n        // slow but easy to work with\\n        // can be optimized away\\n        vector<set<int>> res(n);\\n        vector<vector<int>> r;\\n        \\n        // construct graph with edges\\n        unordered_map<int, vector<int>> m;\\n        for (auto &e : edges) {\\n            auto from = e[0], to = e[1];\\n            m[from].push_back(to);            \\n        }\\n\\n        // dfs function\\n        function<void(int,int)> dfs = [&](int i, int root) -> void {\\n            // skip if visited (TLE otherwise)\\n            if (res[i].count(root)) return;\\n            \\n            // insert if node is not root\\n            if (i != root) {\\n                res[i].insert(root);\\n            }\\n\\n            // visit all children\\n            for (auto &node : m[i]) {\\n                dfs(node, root);\\n            }\\n        };\\n\\n\\n        for (int i = 0; i < n; i++) {\\n            dfs(i, i);\\n        }\\n\\n        // tranform into vector<vector<>>\\n        for (auto &s : res) {\\n            r.push_back(vector<int>(s.begin(), s.end()));\\n        } \\n\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        // dfs the nodes as the question denotes DAG and n <= 1000\\n        \\n        // set to save intermediate value\\n        // slow but easy to work with\\n        // can be optimized away\\n        vector<set<int>> res(n);\\n        vector<vector<int>> r;\\n        \\n        // construct graph with edges\\n        unordered_map<int, vector<int>> m;\\n        for (auto &e : edges) {\\n            auto from = e[0], to = e[1];\\n            m[from].push_back(to);            \\n        }\\n\\n        // dfs function\\n        function<void(int,int)> dfs = [&](int i, int root) -> void {\\n            // skip if visited (TLE otherwise)\\n            if (res[i].count(root)) return;\\n            \\n            // insert if node is not root\\n            if (i != root) {\\n                res[i].insert(root);\\n            }\\n\\n            // visit all children\\n            for (auto &node : m[i]) {\\n                dfs(node, root);\\n            }\\n        };\\n\\n\\n        for (int i = 0; i < n; i++) {\\n            dfs(i, i);\\n        }\\n\\n        // tranform into vector<vector<>>\\n        for (auto &s : res) {\\n            r.push_back(vector<int>(s.begin(), s.end()));\\n        } \\n\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008602,
                "title": "easy-solution-in-python-dfs",
                "content": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        \\n        adj_list=defaultdict(list)\\n        \\n        for i,j in edges:\\n            adj_list[j].append(i)\\n        \\n        arr=[[] for i in range(n)]\\n        \\n        def helper(node):            \\n            visited[node]=1\\n            for i in adj_list[node]:\\n                if visited[i]==0:\\n                    helper(i)\\n                \\n        \\n        for i in range(n):\\n            visited=[0]*n\\n            helper(i)\\n            values=[]\\n            \\n            for j in range(n):\\n                if visited[j]==1:\\n                    if i!=j:\\n                        arr[i].append(j)\\n        \\n        return arr\\n   \\n```\\n\\n![image](https://assets.leetcode.com/users/images/582e756b-bd32-49c1-bb36-b3116f96614e_1693982629.2326968.jpeg)\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        \\n        adj_list=defaultdict(list)\\n        \\n        for i,j in edges:\\n            adj_list[j].append(i)\\n        \\n        arr=[[] for i in range(n)]\\n        \\n        def helper(node):            \\n            visited[node]=1\\n            for i in adj_list[node]:\\n                if visited[i]==0:\\n                    helper(i)\\n                \\n        \\n        for i in range(n):\\n            visited=[0]*n\\n            helper(i)\\n            values=[]\\n            \\n            for j in range(n):\\n                if visited[j]==1:\\n                    if i!=j:\\n                        arr[i].append(j)\\n        \\n        return arr\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007704,
                "title": "easy-cpp-solution-brute-force-solution-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<set<int>> ans(n);\\n        unordered_map<int, int> vis;\\n\\n        map<int, vector<int>> adj;\\n        map<int, int> in;\\n        int sz = edges.size();\\n        for(int i=0; i<sz; i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            in[edges[i][1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0; i<n; i++){\\n            if(in[i] == 0){\\n                vis[i] = 1;\\n                q.push(i);\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            int ind = q.front();\\n            q.pop();\\n            vis[ind] = 1;\\n            for(auto i : adj[ind]){\\n                in[i]--;\\n                if(in[i] == 0) q.push(i);\\n                ans[i].insert(ind);\\n                for(auto j : ans[ind]){\\n                    ans[i].insert(j);\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> fans;\\n        for(auto i : ans){\\n            fans.push_back(vector<int>(i.begin(), i.end()));\\n        }\\n        return fans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<set<int>> ans(n);\\n        unordered_map<int, int> vis;\\n\\n        map<int, vector<int>> adj;\\n        map<int, int> in;\\n        int sz = edges.size();\\n        for(int i=0; i<sz; i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            in[edges[i][1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0; i<n; i++){\\n            if(in[i] == 0){\\n                vis[i] = 1;\\n                q.push(i);\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            int ind = q.front();\\n            q.pop();\\n            vis[ind] = 1;\\n            for(auto i : adj[ind]){\\n                in[i]--;\\n                if(in[i] == 0) q.push(i);\\n                ans[i].insert(ind);\\n                for(auto j : ans[ind]){\\n                    ans[i].insert(j);\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> fans;\\n        for(auto i : ans){\\n            fans.push_back(vector<int>(i.begin(), i.end()));\\n        }\\n        return fans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002170,
                "title": "easy-c-topo-sort-type",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        vector<int> indeg (n,0);\\n\\n        for(auto i:edges)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            indeg[i[1]]++;\\n        }\\n\\n        queue<int> qu;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indeg[i]==0)\\n            qu.push(i);\\n        }\\n        vector<set<int>> ans(n);\\n        while(!qu.empty())\\n        {\\n            int root = qu.front();qu.pop();\\n            for(int i=0;i<adj[root].size();i++)\\n            {\\n                ans[adj[root][i]].insert(root);\\n                for(auto j:ans[root])\\n                {\\n                    ans[adj[root][i]].insert(j);\\n                }\\n                indeg[adj[root][i]]--;\\n                if(indeg[adj[root][i]]==0)\\n                {\\n                    qu.push(adj[root][i]);\\n                }\\n            }\\n        }\\n        vector<vector<int>> res;\\n        for(int i=0;i<n;i++)\\n        {\\n            set<int> st = ans[i];\\n            vector<int> v;\\n            for(auto i:st){\\n                v.push_back(i);\\n            }\\n            res.push_back(v);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        vector<int> indeg (n,0);\\n\\n        for(auto i:edges)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            indeg[i[1]]++;\\n        }\\n\\n        queue<int> qu;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indeg[i]==0)\\n            qu.push(i);\\n        }\\n        vector<set<int>> ans(n);\\n        while(!qu.empty())\\n        {\\n            int root = qu.front();qu.pop();\\n            for(int i=0;i<adj[root].size();i++)\\n            {\\n                ans[adj[root][i]].insert(root);\\n                for(auto j:ans[root])\\n                {\\n                    ans[adj[root][i]].insert(j);\\n                }\\n                indeg[adj[root][i]]--;\\n                if(indeg[adj[root][i]]==0)\\n                {\\n                    qu.push(adj[root][i]);\\n                }\\n            }\\n        }\\n        vector<vector<int>> res;\\n        for(int i=0;i<n;i++)\\n        {\\n            set<int> st = ans[i];\\n            vector<int> v;\\n            for(auto i:st){\\n                v.push_back(i);\\n            }\\n            res.push_back(v);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996319,
                "title": "2192-java-100-45ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst throught is that in given graph we have to sort it down because ecah node is dpenedent on other for finding all the ancestors.\\n\\nSo I sorted it down using topological sort. Then after we have the order of the nodes stored in stack we need to just simply iterate over it and keep inserting the currentNode\\'s values and currentNode\\'s ancestors into the neighbor node\\'s list.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor topological sort to get the order of nodes:\\n```\\nvoid topologicalVisit(Map < Integer, List < Integer >> map, int i, Stack < Integer > stack, boolean[] visited) {\\n      if (map.containsKey(i)) {\\n        for (int neighbor: map.get(i)) {\\n          if (!visited[neighbor]) {\\n            topologicalVisit(map, neighbor, stack, visited);\\n          }\\n        }\\n      }\\n      visited[i] = true;\\n      stack.push(i);\\n    }\\n\\n    public Stack < Integer > topologicalSort(Map < Integer, List < Integer >> map, int n, boolean[] visited) {\\n      Stack < Integer > stack = new Stack < > ();\\n      for (int i = 0; i < n; i++) {\\n        if (!visited[i]) {\\n          topologicalVisit(map, i, stack, visited);\\n        }\\n      }\\n\\n      return stack;\\n    }\\n```\\n\\nFor insertion of currentNode\\'s value and it\\'s ancestor into neighbor\\'s list.\\nI have used Binary Search insertion for inserting currentNode\\'s value :\\n```\\nvoid binarySearchInsert (List<Integer> list, int val) {\\n        int n = list.size();\\n            if(list.size()==0 || list.get(n-1) < val)\\n                list.add(val);\\n            else{\\n                int k=0;\\n                int l=n;\\n                while(k<l){\\n                    int mid = (k+l)/2;\\n                    if(list.get(mid) == val)\\n                    return;\\n                    if(list.get(mid)<val)\\n                        k=mid+1;\\n                    else\\n                        l=mid;\\n                }\\n                list.add(k, val);\\n            }\\n\\n    }\\n```\\n\\n\\n & merging the currentNode\\'s ancestors I have used mergeSortedLists() similar to used in merge sort: \\n```\\npublic static void mergeSortedLists(List<Integer> list1, List<Integer> list2) {\\n        int i = 0, j = 0;\\n\\n        while (i < list1.size() && j < list2.size()) {\\n            int num1 = list1.get(i);\\n            int num2 = list2.get(j);\\n\\n            if(num1 == num2) {\\n               i++;\\n               j++;\\n            }else if (num1 < num2) {\\n                list2.add(j, num1);\\n                i++;\\n            } else {\\n                j++;\\n            }\\n        }\\n\\n        while (i < list1.size()) {\\n            list2.add(list1.get(i));\\n            i++;\\n        }\\n    }\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List < List < Integer >> getAncestors(int n, int[][] edges) {\\n      Map < Integer, List < Integer >> map = new HashMap < > ();\\n      for (int[] edge: edges) {\\n        map.computeIfAbsent(edge[0], value -> new ArrayList < Integer > ()).add(edge[1]);\\n      }\\n\\n      boolean[] visited = new boolean[n];\\n      Stack < Integer > stack = topologicalSort(map, n, visited);\\n\\n      List < List < Integer >> list = new ArrayList < > (n);\\n      for (int i = 0; i < n; i++) {\\n             list.add(new ArrayList<>());\\n        }\\n      while (!stack.isEmpty()) {\\n        int node = stack.pop();\\n        //System.out.print(node + \" \");\\n        if (map.containsKey(node)) {\\n          for (int neighbor: map.get(node)) {\\n             binarySearchInsert(list.get(neighbor), node); \\n\\n            if (list.get(node).size()>0) \\n                mergeSortedLists(list.get(node), list.get(neighbor));\\n          }\\n        }\\n      }\\n\\n      return list;\\n    }\\n\\n    void topologicalVisit(Map < Integer, List < Integer >> map, int i, Stack < Integer > stack, boolean[] visited) {\\n      if (map.containsKey(i)) {\\n        for (int neighbor: map.get(i)) {\\n          if (!visited[neighbor]) {\\n            topologicalVisit(map, neighbor, stack, visited);\\n          }\\n        }\\n      }\\n      visited[i] = true;\\n      stack.push(i);\\n    }\\n\\n    public Stack < Integer > topologicalSort(Map < Integer, List < Integer >> map, int n, boolean[] visited) {\\n      Stack < Integer > stack = new Stack < > ();\\n      for (int i = 0; i < n; i++) {\\n        if (!visited[i]) {\\n          topologicalVisit(map, i, stack, visited);\\n        }\\n      }\\n\\n      return stack;\\n    }\\n\\n    void binarySearchInsert (List<Integer> list, int val) {\\n        int n = list.size();\\n            if(list.size()==0 || list.get(n-1) < val)\\n                list.add(val);\\n            else{\\n                int k=0;\\n                int l=n;\\n                while(k<l){\\n                    int mid = (k+l)/2;\\n                    if(list.get(mid) == val)\\n                    return;\\n                    if(list.get(mid)<val)\\n                        k=mid+1;\\n                    else\\n                        l=mid;\\n                }\\n                list.add(k, val);\\n            }\\n\\n    }\\n\\n    public static void mergeSortedLists(List<Integer> list1, List<Integer> list2) {\\n        int i = 0, j = 0;\\n\\n        while (i < list1.size() && j < list2.size()) {\\n            int num1 = list1.get(i);\\n            int num2 = list2.get(j);\\n\\n            if(num1 == num2) {\\n               i++;\\n               j++;\\n            }else if (num1 < num2) {\\n                list2.add(j, num1);\\n                i++;\\n            } else {\\n                j++;\\n            }\\n        }\\n\\n        while (i < list1.size()) {\\n            list2.add(list1.get(i));\\n            i++;\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Binary Search",
                    "Graph",
                    "Topological Sort",
                    "Merge Sort"
                ],
                "code": "```\\nvoid topologicalVisit(Map < Integer, List < Integer >> map, int i, Stack < Integer > stack, boolean[] visited) {\\n      if (map.containsKey(i)) {\\n        for (int neighbor: map.get(i)) {\\n          if (!visited[neighbor]) {\\n            topologicalVisit(map, neighbor, stack, visited);\\n          }\\n        }\\n      }\\n      visited[i] = true;\\n      stack.push(i);\\n    }\\n\\n    public Stack < Integer > topologicalSort(Map < Integer, List < Integer >> map, int n, boolean[] visited) {\\n      Stack < Integer > stack = new Stack < > ();\\n      for (int i = 0; i < n; i++) {\\n        if (!visited[i]) {\\n          topologicalVisit(map, i, stack, visited);\\n        }\\n      }\\n\\n      return stack;\\n    }\\n```\n```\\nvoid binarySearchInsert (List<Integer> list, int val) {\\n        int n = list.size();\\n            if(list.size()==0 || list.get(n-1) < val)\\n                list.add(val);\\n            else{\\n                int k=0;\\n                int l=n;\\n                while(k<l){\\n                    int mid = (k+l)/2;\\n                    if(list.get(mid) == val)\\n                    return;\\n                    if(list.get(mid)<val)\\n                        k=mid+1;\\n                    else\\n                        l=mid;\\n                }\\n                list.add(k, val);\\n            }\\n\\n    }\\n```\n```\\npublic static void mergeSortedLists(List<Integer> list1, List<Integer> list2) {\\n        int i = 0, j = 0;\\n\\n        while (i < list1.size() && j < list2.size()) {\\n            int num1 = list1.get(i);\\n            int num2 = list2.get(j);\\n\\n            if(num1 == num2) {\\n               i++;\\n               j++;\\n            }else if (num1 < num2) {\\n                list2.add(j, num1);\\n                i++;\\n            } else {\\n                j++;\\n            }\\n        }\\n\\n        while (i < list1.size()) {\\n            list2.add(list1.get(i));\\n            i++;\\n        }\\n    }\\n```\n```\\nclass Solution {\\n    public List < List < Integer >> getAncestors(int n, int[][] edges) {\\n      Map < Integer, List < Integer >> map = new HashMap < > ();\\n      for (int[] edge: edges) {\\n        map.computeIfAbsent(edge[0], value -> new ArrayList < Integer > ()).add(edge[1]);\\n      }\\n\\n      boolean[] visited = new boolean[n];\\n      Stack < Integer > stack = topologicalSort(map, n, visited);\\n\\n      List < List < Integer >> list = new ArrayList < > (n);\\n      for (int i = 0; i < n; i++) {\\n             list.add(new ArrayList<>());\\n        }\\n      while (!stack.isEmpty()) {\\n        int node = stack.pop();\\n        //System.out.print(node + \" \");\\n        if (map.containsKey(node)) {\\n          for (int neighbor: map.get(node)) {\\n             binarySearchInsert(list.get(neighbor), node); \\n\\n            if (list.get(node).size()>0) \\n                mergeSortedLists(list.get(node), list.get(neighbor));\\n          }\\n        }\\n      }\\n\\n      return list;\\n    }\\n\\n    void topologicalVisit(Map < Integer, List < Integer >> map, int i, Stack < Integer > stack, boolean[] visited) {\\n      if (map.containsKey(i)) {\\n        for (int neighbor: map.get(i)) {\\n          if (!visited[neighbor]) {\\n            topologicalVisit(map, neighbor, stack, visited);\\n          }\\n        }\\n      }\\n      visited[i] = true;\\n      stack.push(i);\\n    }\\n\\n    public Stack < Integer > topologicalSort(Map < Integer, List < Integer >> map, int n, boolean[] visited) {\\n      Stack < Integer > stack = new Stack < > ();\\n      for (int i = 0; i < n; i++) {\\n        if (!visited[i]) {\\n          topologicalVisit(map, i, stack, visited);\\n        }\\n      }\\n\\n      return stack;\\n    }\\n\\n    void binarySearchInsert (List<Integer> list, int val) {\\n        int n = list.size();\\n            if(list.size()==0 || list.get(n-1) < val)\\n                list.add(val);\\n            else{\\n                int k=0;\\n                int l=n;\\n                while(k<l){\\n                    int mid = (k+l)/2;\\n                    if(list.get(mid) == val)\\n                    return;\\n                    if(list.get(mid)<val)\\n                        k=mid+1;\\n                    else\\n                        l=mid;\\n                }\\n                list.add(k, val);\\n            }\\n\\n    }\\n\\n    public static void mergeSortedLists(List<Integer> list1, List<Integer> list2) {\\n        int i = 0, j = 0;\\n\\n        while (i < list1.size() && j < list2.size()) {\\n            int num1 = list1.get(i);\\n            int num2 = list2.get(j);\\n\\n            if(num1 == num2) {\\n               i++;\\n               j++;\\n            }else if (num1 < num2) {\\n                list2.add(j, num1);\\n                i++;\\n            } else {\\n                j++;\\n            }\\n        }\\n\\n        while (i < list1.size()) {\\n            list2.add(list1.get(i));\\n            i++;\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995225,
                "title": "easy-topological-sorting-java-c-python",
                "content": "# Approach\\nUsing topological sorting to process the nodes. You can look into an explanation in the linked video: \\n\\n# Complexity\\n- Time complexity: O(n^2logn)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n\\n```java []\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<Integer>[] adj = new ArrayList[n];\\n        int [] indegrees = new int[n];\\n        List<List<Integer>> result = new ArrayList();\\n\\n        //build our adjacency list\\n        for(int k = 0; k < n; k++){\\n            adj[k] = new ArrayList();\\n            result.add(new ArrayList());\\n        }\\n        for(int [] edge : edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            indegrees[v]++;\\n            adj[u].add(v);\\n        }\\n\\n        Queue<Integer> q = new LinkedList();\\n        for(int k = 0; k < n; k++){\\n            if(indegrees[k] == 0){\\n                q.add(k);\\n            }\\n        }\\n\\n        while(!q.isEmpty()){\\n            int current = q.poll();\\n            for(int neighbor : adj[current]){\\n                Set<Integer> set = new HashSet(result.get(current)); //all the ancestors of the current\\n                set.add(current); //add current as an ancestor\\n                set.addAll(result.get(neighbor)); //ancestors of our neighbor\\n                indegrees[neighbor]--;\\n                if(indegrees[neighbor] == 0){\\n                    q.add(neighbor);\\n                }\\n                List<Integer> list = new ArrayList(set);\\n                Collections.sort(list);\\n                result.set(neighbor, list);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        adj = defaultdict(list)\\n        indegrees = [0] * n\\n        result = [[] for _ in range(n)]\\n        \\n        # build adjacency list\\n        for u, v in edges:\\n            indegrees[v] += 1\\n            adj[u].append(v)\\n\\n        q = deque([i for i in range(n) if indegrees[i] == 0])\\n\\n        while q:\\n            current = q.popleft()\\n            for neighbor in adj[current]:\\n                ancestor_set = set(result[current])\\n                ancestor_set.add(current)\\n                ancestor_set.update(result[neighbor])\\n                \\n                indegrees[neighbor] -= 1\\n                if indegrees[neighbor] == 0:\\n                    q.append(neighbor)\\n                \\n                result[neighbor] = sorted(list(ancestor_set))\\n\\n        return result\\n\\n```\\n```C++ []\\n#include <iostream>\\n#include <vector>\\n#include <queue>\\n#include <unordered_set>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, const vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        vector<int> indegrees(n, 0);\\n        vector<vector<int>> result(n);\\n\\n        // Build adjacency list\\n        for(auto& edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            indegrees[v]++;\\n            adj[u].push_back(v);\\n        }\\n\\n        queue<int> q;\\n        for(int i = 0; i < n; i++) {\\n            if(indegrees[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n\\n        while(!q.empty()) {\\n            int current = q.front();\\n            q.pop();\\n            for(int neighbor : adj[current]) {\\n                unordered_set<int> ancestor_set(result[current].begin(), result[current].end());\\n                ancestor_set.insert(current);\\n                ancestor_set.insert(result[neighbor].begin(), result[neighbor].end());\\n\\n                indegrees[neighbor]--;\\n                if(indegrees[neighbor] == 0) {\\n                    q.push(neighbor);\\n                }\\n\\n                result[neighbor].assign(ancestor_set.begin(), ancestor_set.end());\\n                sort(result[neighbor].begin(), result[neighbor].end());\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```java []\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<Integer>[] adj = new ArrayList[n];\\n        int [] indegrees = new int[n];\\n        List<List<Integer>> result = new ArrayList();\\n\\n        //build our adjacency list\\n        for(int k = 0; k < n; k++){\\n            adj[k] = new ArrayList();\\n            result.add(new ArrayList());\\n        }\\n        for(int [] edge : edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            indegrees[v]++;\\n            adj[u].add(v);\\n        }\\n\\n        Queue<Integer> q = new LinkedList();\\n        for(int k = 0; k < n; k++){\\n            if(indegrees[k] == 0){\\n                q.add(k);\\n            }\\n        }\\n\\n        while(!q.isEmpty()){\\n            int current = q.poll();\\n            for(int neighbor : adj[current]){\\n                Set<Integer> set = new HashSet(result.get(current)); //all the ancestors of the current\\n                set.add(current); //add current as an ancestor\\n                set.addAll(result.get(neighbor)); //ancestors of our neighbor\\n                indegrees[neighbor]--;\\n                if(indegrees[neighbor] == 0){\\n                    q.add(neighbor);\\n                }\\n                List<Integer> list = new ArrayList(set);\\n                Collections.sort(list);\\n                result.set(neighbor, list);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        adj = defaultdict(list)\\n        indegrees = [0] * n\\n        result = [[] for _ in range(n)]\\n        \\n        # build adjacency list\\n        for u, v in edges:\\n            indegrees[v] += 1\\n            adj[u].append(v)\\n\\n        q = deque([i for i in range(n) if indegrees[i] == 0])\\n\\n        while q:\\n            current = q.popleft()\\n            for neighbor in adj[current]:\\n                ancestor_set = set(result[current])\\n                ancestor_set.add(current)\\n                ancestor_set.update(result[neighbor])\\n                \\n                indegrees[neighbor] -= 1\\n                if indegrees[neighbor] == 0:\\n                    q.append(neighbor)\\n                \\n                result[neighbor] = sorted(list(ancestor_set))\\n\\n        return result\\n\\n```\n```C++ []\\n#include <iostream>\\n#include <vector>\\n#include <queue>\\n#include <unordered_set>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, const vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        vector<int> indegrees(n, 0);\\n        vector<vector<int>> result(n);\\n\\n        // Build adjacency list\\n        for(auto& edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            indegrees[v]++;\\n            adj[u].push_back(v);\\n        }\\n\\n        queue<int> q;\\n        for(int i = 0; i < n; i++) {\\n            if(indegrees[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n\\n        while(!q.empty()) {\\n            int current = q.front();\\n            q.pop();\\n            for(int neighbor : adj[current]) {\\n                unordered_set<int> ancestor_set(result[current].begin(), result[current].end());\\n                ancestor_set.insert(current);\\n                ancestor_set.insert(result[neighbor].begin(), result[neighbor].end());\\n\\n                indegrees[neighbor]--;\\n                if(indegrees[neighbor] == 0) {\\n                    q.push(neighbor);\\n                }\\n\\n                result[neighbor].assign(ancestor_set.begin(), ancestor_set.end());\\n                sort(result[neighbor].begin(), result[neighbor].end());\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3979160,
                "title": "cpp-solution-kahn-s-algorithm",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) \\n    {\\n        vector<vector<int>> adj(n);\\n        vector<set<int>> st(n);\\n        vector<int> inDegree(n);\\n        queue<int> store;\\n        for(auto edge : edges)\\n        {\\n            adj[edge[0]].push_back(edge[1]);\\n            inDegree[edge[1]]++;\\n        }\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(inDegree[i] == 0)\\n            {\\n                store.push(i);\\n            }\\n        }\\n        while(!store.empty())\\n        {\\n            int node = store.front();\\n            store.pop();\\n            for(auto i : adj[node])\\n            {\\n                for(auto j : st[node])\\n                {\\n                    st[i].insert(j);\\n                }\\n                st[i].insert(node);\\n                inDegree[i]--;\\n                 if(inDegree[i] == 0)\\n                 {\\n                    store.push(i);\\n                 }\\n            }\\n        }\\n        vector<vector<int>> answer(n);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(auto j : st[i])\\n            {\\n                answer[i].push_back(j);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) \\n    {\\n        vector<vector<int>> adj(n);\\n        vector<set<int>> st(n);\\n        vector<int> inDegree(n);\\n        queue<int> store;\\n        for(auto edge : edges)\\n        {\\n            adj[edge[0]].push_back(edge[1]);\\n            inDegree[edge[1]]++;\\n        }\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(inDegree[i] == 0)\\n            {\\n                store.push(i);\\n            }\\n        }\\n        while(!store.empty())\\n        {\\n            int node = store.front();\\n            store.pop();\\n            for(auto i : adj[node])\\n            {\\n                for(auto j : st[node])\\n                {\\n                    st[i].insert(j);\\n                }\\n                st[i].insert(node);\\n                inDegree[i]--;\\n                 if(inDegree[i] == 0)\\n                 {\\n                    store.push(i);\\n                 }\\n            }\\n        }\\n        vector<vector<int>> answer(n);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(auto j : st[i])\\n            {\\n                answer[i].push_back(j);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977961,
                "title": "reverse-traversal-from-child-to-parent-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> g;\\n    void dfs(int i, vector<int>&p, vector<int> &v)\\n    {\\n        v[i]=1;\\n        cout<<i<<\" \";\\n        for(auto t: g[i])\\n        {\\n            if(!v[t])\\n            {\\n                p.push_back(t);\\n                dfs(t,p,v);\\n            }\\n        }\\n        \\n       \\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) \\n    {\\n        g.resize(n);\\n        for(auto i: edges)\\n        {\\n            g[i[1]].push_back(i[0]);  // child to parent easy  to trace parents other wise it touch to traverse back all \\n            // now all possible paths nodes from childs gives parents node \\n            \\n        }\\n        vector<vector<int>> ans(n);\\n        for(int i=0; i<n; i++)\\n        {\\n            vector<int> v(n,0);\\n            vector<int> p;\\n            dfs(i,p,v);\\n            sort(p.begin(),p.end());\\n            ans[i]=p;\\n        }\\n       \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> g;\\n    void dfs(int i, vector<int>&p, vector<int> &v)\\n    {\\n        v[i]=1;\\n        cout<<i<<\" \";\\n        for(auto t: g[i])\\n        {\\n            if(!v[t])\\n            {\\n                p.push_back(t);\\n                dfs(t,p,v);\\n            }\\n        }\\n        \\n       \\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) \\n    {\\n        g.resize(n);\\n        for(auto i: edges)\\n        {\\n            g[i[1]].push_back(i[0]);  // child to parent easy  to trace parents other wise it touch to traverse back all \\n            // now all possible paths nodes from childs gives parents node \\n            \\n        }\\n        vector<vector<int>> ans(n);\\n        for(int i=0; i<n; i++)\\n        {\\n            vector<int> v(n,0);\\n            vector<int> p;\\n            dfs(i,p,v);\\n            sort(p.begin(),p.end());\\n            ans[i]=p;\\n        }\\n       \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3963213,
                "title": "c-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<int>&vis,vector<vector<int>>&adj,vector<int>&v){\\n        vis[node]=1;\\n        for(auto it:adj[node]){\\n            \\n            if(!vis[it]){\\n                v.push_back(it);\\n                dfs(it,vis,adj,v);\\n\\n            }\\n\\n\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        vector<vector<int>>ans(n);\\n        for(auto it:edges){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<int>v;\\n            vector<int>vis(n,0);\\n             if(!vis[i])\\n            dfs(i,vis,adj,v);\\n            sort(v.begin(),v.end());\\n            ans[i]=v;\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<int>&vis,vector<vector<int>>&adj,vector<int>&v){\\n        vis[node]=1;\\n        for(auto it:adj[node]){\\n            \\n            if(!vis[it]){\\n                v.push_back(it);\\n                dfs(it,vis,adj,v);\\n\\n            }\\n\\n\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        vector<vector<int>>ans(n);\\n        for(auto it:edges){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<int>v;\\n            vector<int>vis(n,0);\\n             if(!vis[i])\\n            dfs(i,vis,adj,v);\\n            sort(v.begin(),v.end());\\n            ans[i]=v;\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953193,
                "title": "dfs",
                "content": "# Intuition\\nReverse the directions of given graph and appending the path from the DFS traversal of that node\\n\\n# Approach\\nCreate an adj list contains opposite directions and do DFS for all the nodes \\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        adj=defaultdict(list)\\n        for s,d in edges:\\n            adj[d].append(s)\\n        ans=[]\\n        for i in range(n):\\n            temp=set()\\n            stack=[i]\\n            visited=[False]*n\\n            while stack:\\n                node=stack.pop()\\n                visited[node]=True\\n                for nei in adj[node]:\\n                    if not visited[nei]:\\n                        stack.append(nei)\\n                        temp.add(nei)\\n            temp=list(temp)\\n            temp.sort()       \\n            ans.append(temp)\\n        return ans\\n\\n            \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        adj=defaultdict(list)\\n        for s,d in edges:\\n            adj[d].append(s)\\n        ans=[]\\n        for i in range(n):\\n            temp=set()\\n            stack=[i]\\n            visited=[False]*n\\n            while stack:\\n                node=stack.pop()\\n                visited[node]=True\\n                for nei in adj[node]:\\n                    if not visited[nei]:\\n                        stack.append(nei)\\n                        temp.add(nei)\\n            temp=list(temp)\\n            temp.sort()       \\n            ans.append(temp)\\n        return ans\\n\\n            \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953006,
                "title": "java-solution-dfs",
                "content": "class Solution {\\n    Map<Integer, Set<Integer>> ancestors_set;\\n    Map<Integer, Set<Integer>> graph;\\n    boolean visited[];\\n    \\n    private void dfs(int node) {\\n        visited[node]=true;\\n        if (graph.containsKey(node))\\n        {\\n            for(Integer neighbor:graph.get(node)) \\n            {\\n                if(visited[neighbor]==false)\\n                    dfs(neighbor);\\n                \\n                Set<Integer> current_set=new HashSet<>();\\n                \\n                if(ancestors_set.containsKey(neighbor))\\n                    current_set.addAll(ancestors_set.get(neighbor));\\n                current_set.add(neighbor);\\n                ancestors_set.putIfAbsent(node, new HashSet<>());\\n                ancestors_set.get(node).addAll(current_set);\\n            }\\n        }\\n    }\\n    \\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> ancestors_list=new ArrayList<List<Integer>>();\\n        \\n        ancestors_set=new HashMap<>();\\n        graph=new HashMap<>();\\n        visited=new boolean[n];\\n        \\n        for(int i=0; i<edges.length; i++)\\n        {//building reverse graph\\n            int u=edges[i][1], v=edges[i][0];\\n            \\n            graph.putIfAbsent(u, new HashSet<>());\\n            graph.get(u).add(v);\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {            \\n            if(visited[i]==false)\\n                dfs(i);\\n        }\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            ancestors_list.add(new ArrayList<>());\\n            if(ancestors_set.containsKey(i))\\n            {\\n                for(Integer ancestor:ancestors_set.get(i))\\n                {\\n                    ancestors_list.get(i).add(ancestor);\\n                    Collections.sort(ancestors_list.get(i));\\n                }\\n            }\\n        }\\n        \\n        return ancestors_list;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    Map<Integer, Set<Integer>> ancestors_set;\\n    Map<Integer, Set<Integer>> graph;\\n    boolean visited[];\\n    \\n    private void dfs(int node) {\\n        visited[node]=true;\\n        if (graph.containsKey(node))\\n        {\\n            for(Integer neighbor:graph.get(node)) \\n            {\\n                if(visited[neighbor]==false)\\n                    dfs(neighbor);\\n                \\n                Set<Integer> current_set=new HashSet<>();\\n                \\n                if(ancestors_set.containsKey(neighbor))\\n                    current_set.addAll(ancestors_set.get(neighbor));\\n                current_set.add(neighbor);\\n                ancestors_set.putIfAbsent(node, new HashSet<>());\\n                ancestors_set.get(node).addAll(current_set);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3943120,
                "title": "java-clean-and-simple-dynamic-programming",
                "content": "```\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.stream.IntStream;\\n\\nimport static java.util.Arrays.stream;\\nimport static java.util.Collections.emptyList;\\nimport static java.util.stream.Collectors.groupingBy;\\nimport static java.util.stream.Collectors.mapping;\\nimport static java.util.stream.Collectors.toList;\\nimport static java.util.stream.Stream.concat;\\n\\n\\nclass Solution {\\n    private Map<Integer, List<Integer>> graph;\\n    private List<Integer>[] dp;\\n\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        this.dp = new List[n];\\n        this.graph = stream(edges).collect(groupingBy(x -> x[1], mapping(x -> x[0], toList())));\\n\\n        return IntStream.range(0, n).mapToObj(this::ancestors).toList();\\n    }\\n\\n    private List<Integer> ancestors(int u) {\\n        if (dp[u] == null) {\\n            var neighbors = graph.getOrDefault(u, emptyList());\\n\\n            var a = neighbors.stream();\\n            var b = neighbors.stream().map(this::ancestors).flatMap(List::stream);\\n\\n            dp[u] = concat(a, b).distinct().sorted().toList();\\n        }\\n        \\n        return dp[u];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.stream.IntStream;\\n\\nimport static java.util.Arrays.stream;\\nimport static java.util.Collections.emptyList;\\nimport static java.util.stream.Collectors.groupingBy;\\nimport static java.util.stream.Collectors.mapping;\\nimport static java.util.stream.Collectors.toList;\\nimport static java.util.stream.Stream.concat;\\n\\n\\nclass Solution {\\n    private Map<Integer, List<Integer>> graph;\\n    private List<Integer>[] dp;\\n\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        this.dp = new List[n];\\n        this.graph = stream(edges).collect(groupingBy(x -> x[1], mapping(x -> x[0], toList())));\\n\\n        return IntStream.range(0, n).mapToObj(this::ancestors).toList();\\n    }\\n\\n    private List<Integer> ancestors(int u) {\\n        if (dp[u] == null) {\\n            var neighbors = graph.getOrDefault(u, emptyList());\\n\\n            var a = neighbors.stream();\\n            var b = neighbors.stream().map(this::ancestors).flatMap(List::stream);\\n\\n            dp[u] = concat(a, b).distinct().sorted().toList();\\n        }\\n        \\n        return dp[u];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942152,
                "title": "python-clean-dfs-dynamic-programming-solution",
                "content": "```\\nfrom collections import defaultdict\\nfrom functools import cache, reduce\\n\\n\\nclass Solution:\\n\\n    def getAncestors(self, n: int, edges: list[list[int]]) -> list[list[int]]:\\n        g = self.create_graph(edges)\\n\\n        @cache\\n        def ancestors(u: int) -> set[int]:\\n            return reduce(set.union, map(ancestors, g[u]), set(g[u]))\\n\\n        return [ancestors(i) for i in range(n)]\\n\\n    @staticmethod\\n    def create_graph(edges: list[list[int]]) -> defaultdict[int, list[int]]:\\n        g = defaultdict(list)\\n\\n        for u, v in edges:\\n            g[v].append(u)\\n\\n        return g\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom functools import cache, reduce\\n\\n\\nclass Solution:\\n\\n    def getAncestors(self, n: int, edges: list[list[int]]) -> list[list[int]]:\\n        g = self.create_graph(edges)\\n\\n        @cache\\n        def ancestors(u: int) -> set[int]:\\n            return reduce(set.union, map(ancestors, g[u]), set(g[u]))\\n\\n        return [ancestors(i) for i in range(n)]\\n\\n    @staticmethod\\n    def create_graph(edges: list[list[int]]) -> defaultdict[int, list[int]]:\\n        g = defaultdict(list)\\n\\n        for u, v in edges:\\n            g[v].append(u)\\n\\n        return g\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939557,
                "title": "c-simple-dfs-with-slight-optimization",
                "content": "# Intuition\\nSee the problem in slightly different manner if possible, like a node to be an ancestor how does the node qualify?\\nLet us have an example if there is `node 0` which is connected to `node 4 and node 5`, `node 0` becomes the ancestor and also node 5 can be connected to more nodes, which means that must also have `node 0` as an ancestor.\\n\\nSo for each node go through it\\'s adjacency list and perform a DFS to put that node which can be an ancestor for all the nodes, this way assures that we are keeping the sortedness of the ancestor also!\\n\\n# Approach\\nCreate a adjacency list and for each node starting from 0 do a simple DFS with slightly optimized manner, (`we can use a visited array, but since we know which element we are starting DFS from, we can simply avoid visited and rather check if we have already pushed the element into the ancestor of the current node that we are visiting`).\\n\\n# Complexity\\n- Time complexity:\\nO(N*N) - In worst case we end up doing DFS for all n-1 node (So n*(n-1) ~ n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(N) + O(N*N) - recursion Stack space + Adjacency list we have created\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], vector<vector<int>> &ans, int start, int curr) {\\n        for(auto &node:adj[curr]) {\\n            if(ans[node].empty() || ans[node].back() != start) {\\n                ans[node].push_back(start);\\n                dfs(adj, ans, start, node);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto &it:edges) {\\n            adj[it[0]].push_back(it[1]);\\n        }\\n        vector<vector<int>> ans(n);\\n        for(int i=0;i<n;i++) {\\n            dfs(adj, ans, i, i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], vector<vector<int>> &ans, int start, int curr) {\\n        for(auto &node:adj[curr]) {\\n            if(ans[node].empty() || ans[node].back() != start) {\\n                ans[node].push_back(start);\\n                dfs(adj, ans, start, node);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto &it:edges) {\\n            adj[it[0]].push_back(it[1]);\\n        }\\n        vector<vector<int>> ans(n);\\n        for(int i=0;i<n;i++) {\\n            dfs(adj, ans, i, i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937602,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) { \\n        vector<vector<int>> ans(n), g(n);\\n        \\n        for (const auto& edge : edges) {\\n            g[edge[0]].push_back(edge[1]);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            vector<bool> vis(n);\\n            dfs(g, i, i, ans, vis);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(const vector<vector<int>>& g, int i, int j, vector<vector<int>>& ans, vector<bool>& vis) {\\n        vis[j] = true;\\n        \\n        for (int x : g[j]) {\\n            if (!vis[x]) {\\n                ans[x].push_back(i);\\n                dfs(g, i, x, ans, vis);\\n            }\\n        }\\n    } \\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) { \\n        vector<vector<int>> ans(n), g(n);\\n        \\n        for (const auto& edge : edges) {\\n            g[edge[0]].push_back(edge[1]);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            vector<bool> vis(n);\\n            dfs(g, i, i, ans, vis);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(const vector<vector<int>>& g, int i, int j, vector<vector<int>>& ans, vector<bool>& vis) {\\n        vis[j] = true;\\n        \\n        for (int x : g[j]) {\\n            if (!vis[x]) {\\n                ans[x].push_back(i);\\n                dfs(g, i, x, ans, vis);\\n            }\\n        }\\n    } \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934273,
                "title": "2192-all-ancestors-of-a-node-in-a-directed-acyclic-graph",
                "content": "```\\nclass Solution:\\n  def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n    ans = [[] for _ in range(n)]\\n    graph = [[] for _ in range(n)]\\n\\n    for u, v in edges:\\n      graph[u].append(v)\\n\\n    def dfs(u: int, ancestor: int, seen: Set[int]) -> None:\\n      seen.add(u)\\n      for v in graph[u]:\\n        if v in seen:\\n          continue\\n        ans[v].append(ancestor)\\n        dfs(v, ancestor, seen)\\n\\n    for i in range(n):\\n      dfs(i, i, set())\\n\\n    return ans",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n  def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n    ans = [[] for _ in range(n)]\\n    graph = [[] for _ in range(n)]\\n\\n    for u, v in edges:\\n      graph[u].append(v)\\n\\n    def dfs(u: int, ancestor: int, seen: Set[int]) -> None:\\n      seen.add(u)\\n      for v in graph[u]:\\n        if v in seen:\\n          continue\\n        ans[v].append(ancestor)\\n        dfs(v, ancestor, seen)\\n\\n    for i in range(n):\\n      dfs(i, i, set())\\n\\n    return ans",
                "codeTag": "Java"
            },
            {
                "id": 3911278,
                "title": "fast-af-python-solution-91-89",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def getAncestors(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        tree = defaultdict(list)\\n        for src, dest in edges:\\n            tree[dest].append(src)\\n\\n        cache = {}\\n        \\n        def getAllAncestors(currNode):\\n            if currNode in cache:\\n                return cache[currNode]\\n            if not tree[currNode]:\\n                return set([currNode])\\n\\n            newList = set()\\n            for parent in tree[currNode]:\\n                newList.add(parent)\\n                newList.update(getAllAncestors(parent))\\n\\n            cache[currNode] = newList\\n            return newList\\n\\n        ret = []\\n        for i in range(0, n):\\n            if not tree[i]:\\n                ret.append([])\\n                continue\\n            temp = getAllAncestors(i)\\n            ret.append(temp)\\n\\n        return map(sorted, ret)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def getAncestors(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        tree = defaultdict(list)\\n        for src, dest in edges:\\n            tree[dest].append(src)\\n\\n        cache = {}\\n        \\n        def getAllAncestors(currNode):\\n            if currNode in cache:\\n                return cache[currNode]\\n            if not tree[currNode]:\\n                return set([currNode])\\n\\n            newList = set()\\n            for parent in tree[currNode]:\\n                newList.add(parent)\\n                newList.update(getAllAncestors(parent))\\n\\n            cache[currNode] = newList\\n            return newList\\n\\n        ret = []\\n        for i in range(0, n):\\n            if not tree[i]:\\n                ret.append([])\\n                continue\\n            temp = getAllAncestors(i)\\n            ret.append(temp)\\n\\n        return map(sorted, ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905332,
                "title": "java-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private void dfs(List<List<Integer>> adj, boolean[] vis, List<Integer> temp,int node){\\n        vis[node] = true;\\n        for(int it : adj.get(node)){\\n            if(vis[it]==false){\\n                temp.add(it);\\n                dfs(adj,vis,temp,it);\\n            }\\n        }\\n    }\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i = 0; i < edges.length; i++){\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        for(int i = 0; i < n; i++){\\n            boolean[] vis = new boolean[n];\\n            List<Integer> temp = new ArrayList<>();\\n            dfs(adj,vis,temp,i);\\n            Collections.sort(temp);\\n            ans.add(temp);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    private void dfs(List<List<Integer>> adj, boolean[] vis, List<Integer> temp,int node){\\n        vis[node] = true;\\n        for(int it : adj.get(node)){\\n            if(vis[it]==false){\\n                temp.add(it);\\n                dfs(adj,vis,temp,it);\\n            }\\n        }\\n    }\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i = 0; i < edges.length; i++){\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        for(int i = 0; i < n; i++){\\n            boolean[] vis = new boolean[n];\\n            List<Integer> temp = new ArrayList<>();\\n            dfs(adj,vis,temp,i);\\n            Collections.sort(temp);\\n            ans.add(temp);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886419,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& ed) {\\n        vector<vector<int>> ans(n);\\n        vector<int> adj[n];\\n\\n        for (auto& e: ed) {\\n            adj[e[0]].push_back(e[1]);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            queue<int> q {{ i }};\\n            vector<bool> visited(n, false);\\n\\n            while(!q.empty()) {\\n                int node = q.front();\\n                q.pop();\\n\\n                for (auto& nei: adj[node]) {\\n                    if (visited[nei]) continue;\\n                    visited[nei] = true;\\n                    ans[nei].push_back(i);\\n                    q.push(nei);\\n                }\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& ed) {\\n        vector<vector<int>> ans(n);\\n        vector<int> adj[n];\\n\\n        for (auto& e: ed) {\\n            adj[e[0]].push_back(e[1]);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            queue<int> q {{ i }};\\n            vector<bool> visited(n, false);\\n\\n            while(!q.empty()) {\\n                int node = q.front();\\n                q.pop();\\n\\n                for (auto& nei: adj[node]) {\\n                    if (visited[nei]) continue;\\n                    visited[nei] = true;\\n                    ans[nei].push_back(i);\\n                    q.push(nei);\\n                }\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878403,
                "title": "reversing-graph-easy-cpp-implemenatation",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> bfs(vector<vector<int>> adj,int i, vector<bool> visit){\\n        vector<int>temp={};\\n        queue<int>q;\\n        q.push(i);\\n        while(!q.empty()){\\n            int n=q.front();\\n            q.pop();\\n            if(n!=i)temp.push_back(n);\\n            for(auto e: adj[n]){\\n                if(!visit[e]){\\n                    visit[e]=true;\\n                    q.push(e);\\n                }\\n            }\\n        }\\n        return temp;\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        for( auto &e: edges){\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<vector<int>> ans;\\n        vector<bool> visitd(n,false);\\n        for(int i=0;i<n;i++){\\n            vector<int> v=bfs(adj,i,visitd);\\n            sort(v.begin(),v.end());\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> bfs(vector<vector<int>> adj,int i, vector<bool> visit){\\n        vector<int>temp={};\\n        queue<int>q;\\n        q.push(i);\\n        while(!q.empty()){\\n            int n=q.front();\\n            q.pop();\\n            if(n!=i)temp.push_back(n);\\n            for(auto e: adj[n]){\\n                if(!visit[e]){\\n                    visit[e]=true;\\n                    q.push(e);\\n                }\\n            }\\n        }\\n        return temp;\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        for( auto &e: edges){\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<vector<int>> ans;\\n        vector<bool> visitd(n,false);\\n        for(int i=0;i<n;i++){\\n            vector<int> v=bfs(adj,i,visitd);\\n            sort(v.begin(),v.end());\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858037,
                "title": "by-reversing-the-direction-of-edges-dfs-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void dfs(int node,vector<vector<int>> &adj,vector<int> &temp,vector<int> &visited){\\n        visited[node]=true;\\n        for(auto it:adj[node]){\\n            if (!visited[it]){\\n                temp.push_back(it);\\n                dfs(it,adj,temp,visited);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n\\n        for (auto it:edges){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        ans.resize(n);\\n        vector<vector<int>> dp(n);\\n        for (int i=0;i<n;i++){\\n                vector<int> temp;\\n                vector<int> visited(n,0);\\n                dfs(i,adj,temp,visited);\\n                sort(temp.begin(),temp.end());\\n                ans[i]=temp;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void dfs(int node,vector<vector<int>> &adj,vector<int> &temp,vector<int> &visited){\\n        visited[node]=true;\\n        for(auto it:adj[node]){\\n            if (!visited[it]){\\n                temp.push_back(it);\\n                dfs(it,adj,temp,visited);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n\\n        for (auto it:edges){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        ans.resize(n);\\n        vector<vector<int>> dp(n);\\n        for (int i=0;i<n;i++){\\n                vector<int> temp;\\n                vector<int> visited(n,0);\\n                dfs(i,adj,temp,visited);\\n                sort(temp.begin(),temp.end());\\n                ans[i]=temp;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850258,
                "title": "easiest-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe probelem is nothing but applying **BFS** on the reverse graph.\\nhere we will make a reverse adjacency list and apply BFS over it and thats all.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> helper(vector<vector<int>>& rev_adj,int i){\\n        queue<int> q;\\n        q.push(i);\\n        vector<int> ans;\\n        vector<bool> vis(rev_adj.size(),false);\\n\\n        while(!q.empty()){\\n            int curr= q.front();\\n            q.pop();\\n\\n            if(i!=curr)ans.push_back(curr);\\n\\n            for(auto it:rev_adj[curr]){\\n                if(!vis[it])q.push(it),vis[it]=true;\\n            }\\n        }\\n\\n        sort(ans.begin(),ans.end());\\n\\n        return ans;\\n    }\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        // the question is nothing but applying reverse bfs and thats all\\n        // we will first make a rev_adj list\\n        vector<vector<int>> rev_adj(n);\\n        for(auto it:edges){\\n            rev_adj[it[1]].push_back(it[0]);\\n        }\\n\\n        vector<vector<int>> ans(n);\\n\\n        for(int i=0;i<n;i++){\\n            ans[i]=helper(rev_adj,i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> helper(vector<vector<int>>& rev_adj,int i){\\n        queue<int> q;\\n        q.push(i);\\n        vector<int> ans;\\n        vector<bool> vis(rev_adj.size(),false);\\n\\n        while(!q.empty()){\\n            int curr= q.front();\\n            q.pop();\\n\\n            if(i!=curr)ans.push_back(curr);\\n\\n            for(auto it:rev_adj[curr]){\\n                if(!vis[it])q.push(it),vis[it]=true;\\n            }\\n        }\\n\\n        sort(ans.begin(),ans.end());\\n\\n        return ans;\\n    }\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        // the question is nothing but applying reverse bfs and thats all\\n        // we will first make a rev_adj list\\n        vector<vector<int>> rev_adj(n);\\n        for(auto it:edges){\\n            rev_adj[it[1]].push_back(it[0]);\\n        }\\n\\n        vector<vector<int>> ans(n);\\n\\n        for(int i=0;i<n;i++){\\n            ans[i]=helper(rev_adj,i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850074,
                "title": "using-dfs-clean-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int s, vector<int>& vis, vector<int> adj[], vector<vector<int>>& ans,int i) {\\n        vis[s] = 1;\\n\\n        for (auto x : adj[s]) {\\n            if (vis[x] == 0) {\\n               ans[x].push_back(i);\\n                dfs(x, vis, adj, ans,i);\\n                  \\n            } \\n        }\\n    }\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for (int i = 0; i < edges.size(); i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n        }\\n\\n        vector<vector<int>> ans(n);\\n        vector<int> vis(n, 0);\\n\\n        for (int i = 0; i < n; i++) \\n        {\\n            vector<int> vis(n, 0);\\n           \\n                dfs(i, vis, adj, ans,i);\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int s, vector<int>& vis, vector<int> adj[], vector<vector<int>>& ans,int i) {\\n        vis[s] = 1;\\n\\n        for (auto x : adj[s]) {\\n            if (vis[x] == 0) {\\n               ans[x].push_back(i);\\n                dfs(x, vis, adj, ans,i);\\n                  \\n            } \\n        }\\n    }\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for (int i = 0; i < edges.size(); i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n        }\\n\\n        vector<vector<int>> ans(n);\\n        vector<int> vis(n, 0);\\n\\n        for (int i = 0; i < n; i++) \\n        {\\n            vector<int> vis(n, 0);\\n           \\n                dfs(i, vis, adj, ans,i);\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843624,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe only need to get ancestors node\\nSo reverse the edge in adjacency list to get a node\\'s parents.\\nEach node is numbered from `0` to `n-1`\\nSo use a `for loop` to iterate\\nThis is to avoid disconnected graphs.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create adjacency list\\n2. Reverse the edges to get each node\\'s parents\\n3. DFS each node to get all ancestors\\n> Remember to keep track of visited ancestors for each node\\nIn Python, a list can be access within each iteration of a `for loop` (`visited` can be accessed in `dfs()`)\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ where at nodes are connected\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n + E)$$ to store adjacency list\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        res = [[] for _ in range(n)]\\n        parent_list = defaultdict(list)\\n        for a,b in edges:\\n            parent_list[b].append(a)\\n        def dfs(a, cur):\\n            visited[a] = 1\\n            for p in parent_list[a]:\\n                if visited[p] == 0:\\n                    res[cur].append(p)\\n                    dfs(p, cur)\\n        for i in range(n):\\n            visited = [0] * n\\n            dfs(i, i)\\n            res[i].sort()\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        res = [[] for _ in range(n)]\\n        parent_list = defaultdict(list)\\n        for a,b in edges:\\n            parent_list[b].append(a)\\n        def dfs(a, cur):\\n            visited[a] = 1\\n            for p in parent_list[a]:\\n                if visited[p] == 0:\\n                    res[cur].append(p)\\n                    dfs(p, cur)\\n        for i in range(n):\\n            visited = [0] * n\\n            dfs(i, i)\\n            res[i].sort()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836762,
                "title": "dfs-c-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(vector<int> graph[],vector<int>& nodes,int src,vector<bool>& vis)\\n{ if(vis[src])\\n   return;\\n   vis[src]=true;\\n        for(int i=0;i<graph[src].size();i++)\\n           { int m=graph[src][i];\\n                  if(!vis[m])\\n             {nodes.push_back(m);\\n                 dfs(graph,nodes,m,vis);\\n             }\\n           }\\n\\n}\\n\\n\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> graph[n];\\n        for(int i=0;i<edges.size();i++)\\n       {int a=edges[i][0];\\n        int b=edges[i][1];\\n          graph[b].push_back(a);\\n\\n       }\\n       vector<vector<int>> res;\\n        for(int i=0;i<n;i++)\\n       {vector<int> nodes;\\n       vector<bool> vis(n,false);\\n             dfs(graph,nodes,i,vis);\\n           res.push_back(nodes);     \\n\\n\\n       }\\n       for(auto& x:res)\\n  {sort(x.begin(),x.end());\\n  }\\n\\n    return res;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(vector<int> graph[],vector<int>& nodes,int src,vector<bool>& vis)\\n{ if(vis[src])\\n   return;\\n   vis[src]=true;\\n        for(int i=0;i<graph[src].size();i++)\\n           { int m=graph[src][i];\\n                  if(!vis[m])\\n             {nodes.push_back(m);\\n                 dfs(graph,nodes,m,vis);\\n             }\\n           }\\n\\n}\\n\\n\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> graph[n];\\n        for(int i=0;i<edges.size();i++)\\n       {int a=edges[i][0];\\n        int b=edges[i][1];\\n          graph[b].push_back(a);\\n\\n       }\\n       vector<vector<int>> res;\\n        for(int i=0;i<n;i++)\\n       {vector<int> nodes;\\n       vector<bool> vis(n,false);\\n             dfs(graph,nodes,i,vis);\\n           res.push_back(nodes);     \\n\\n\\n       }\\n       for(auto& x:res)\\n  {sort(x.begin(),x.end());\\n  }\\n\\n    return res;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830181,
                "title": "c-dfs-easy-to-understand-beast-100-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n   private readonly Dictionary<int, List<int>> _dictionary = new Dictionary<int, List<int>>();\\n    \\n    public IList<IList<int>> GetAncestors(int n, int[][] edges)\\n    {\\n        var result = new List<IList<int>>();\\n\\n        Initialize(n);\\n        Fill(edges);\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            result.Add(Transform(TraversePath(i)));\\n        }\\n        \\n        return result;\\n    }\\n\\n    void Initialize(int size)\\n    {\\n        for (int i = 0; i < size; i++)\\n        {\\n            _dictionary[i] = new List<int>();\\n        }\\n    }\\n\\n    void Fill(int[][] edges)\\n    {\\n        foreach (var edge in edges)\\n        {\\n            _dictionary[edge[1]].Add(edge[0]);\\n        }\\n    }\\n\\n    Stack<int> TraversePath(int vertix)\\n    {\\n        var path = new Stack<int>();\\n        var queue = new Queue<int>();\\n        var visited = new HashSet<int>();\\n        \\n        queue.Enqueue(vertix);\\n        visited.Add(vertix);\\n\\n        while (queue.Count != 0)\\n        {\\n            var current = queue.Dequeue();\\n            if (current != vertix)\\n            {\\n                path.Push(current);\\n            }\\n\\n            for (int i = _dictionary[current].Count - 1; i >= 0; i--)\\n            {\\n                var nextVertix = _dictionary[current][i];\\n                if (!visited.Contains(nextVertix))\\n                {\\n                    visited.Add(nextVertix);\\n                    queue.Enqueue(nextVertix);\\n                }\\n            }\\n        }\\n\\n        return path;\\n    }\\n\\n    List<int> Transform(Stack<int> values)\\n    {\\n        var result = new List<int>(values.Count);\\n        \\n        while (values.Count != 0)\\n        {\\n            result.Add(values.Pop());\\n        }\\n\\n        result.Sort();\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n   private readonly Dictionary<int, List<int>> _dictionary = new Dictionary<int, List<int>>();\\n    \\n    public IList<IList<int>> GetAncestors(int n, int[][] edges)\\n    {\\n        var result = new List<IList<int>>();\\n\\n        Initialize(n);\\n        Fill(edges);\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            result.Add(Transform(TraversePath(i)));\\n        }\\n        \\n        return result;\\n    }\\n\\n    void Initialize(int size)\\n    {\\n        for (int i = 0; i < size; i++)\\n        {\\n            _dictionary[i] = new List<int>();\\n        }\\n    }\\n\\n    void Fill(int[][] edges)\\n    {\\n        foreach (var edge in edges)\\n        {\\n            _dictionary[edge[1]].Add(edge[0]);\\n        }\\n    }\\n\\n    Stack<int> TraversePath(int vertix)\\n    {\\n        var path = new Stack<int>();\\n        var queue = new Queue<int>();\\n        var visited = new HashSet<int>();\\n        \\n        queue.Enqueue(vertix);\\n        visited.Add(vertix);\\n\\n        while (queue.Count != 0)\\n        {\\n            var current = queue.Dequeue();\\n            if (current != vertix)\\n            {\\n                path.Push(current);\\n            }\\n\\n            for (int i = _dictionary[current].Count - 1; i >= 0; i--)\\n            {\\n                var nextVertix = _dictionary[current][i];\\n                if (!visited.Contains(nextVertix))\\n                {\\n                    visited.Add(nextVertix);\\n                    queue.Enqueue(nextVertix);\\n                }\\n            }\\n        }\\n\\n        return path;\\n    }\\n\\n    List<int> Transform(Stack<int> values)\\n    {\\n        var result = new List<int>(values.Count);\\n        \\n        while (values.Count != 0)\\n        {\\n            result.Add(values.Pop());\\n        }\\n\\n        result.Sort();\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823912,
                "title": "beats-100-runtime-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&res,vector<int>adj[],vector<bool>&visited, int u, int &v)\\n    {\\n        visited[u] = true;\\n        if(u != v)\\n            res[u].push_back(v);\\n        for(int &x:adj[u])\\n        {\\n            if(!visited[x])\\n            {\\n                dfs(res,adj,visited,x,v);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        for(vector<int>&tmp:edges)\\n        {\\n            adj[tmp[0]].push_back(tmp[1]);\\n        }\\n        \\n        vector<vector<int>>res(n);\\n        for(int i=0;i<n;++i)\\n        {\\n            vector<bool>visited(n,false);\\n            dfs(res,adj,visited,i,i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&res,vector<int>adj[],vector<bool>&visited, int u, int &v)\\n    {\\n        visited[u] = true;\\n        if(u != v)\\n            res[u].push_back(v);\\n        for(int &x:adj[u])\\n        {\\n            if(!visited[x])\\n            {\\n                dfs(res,adj,visited,x,v);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        for(vector<int>&tmp:edges)\\n        {\\n            adj[tmp[0]].push_back(tmp[1]);\\n        }\\n        \\n        vector<vector<int>>res(n);\\n        for(int i=0;i<n;++i)\\n        {\\n            vector<bool>visited(n,false);\\n            dfs(res,adj,visited,i,i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807676,
                "title": "dfs",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    // TC: O(V*E)\\n    // SC: O(V+E)\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n            ans.add(new ArrayList<>());\\n        }\\n\\n        for(int[] e:edges){\\n            adj.get(e[0]).add(e[1]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            boolean[] isVisited = new boolean[n];\\n            dfs(adj,ans,i,i,isVisited);\\n        }\\n\\n        return ans;\\n    }\\n\\n    private void dfs(List<List<Integer>> adj,List<List<Integer>> ans,int parent,int curr,boolean[] isVisited){\\n        isVisited[curr]=true;\\n        for(int a:adj.get(curr)){\\n            if(!isVisited[a]){\\n                ans.get(a).add(parent);\\n                dfs(adj,ans,parent,a,isVisited);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // TC: O(V*E)\\n    // SC: O(V+E)\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n            ans.add(new ArrayList<>());\\n        }\\n\\n        for(int[] e:edges){\\n            adj.get(e[0]).add(e[1]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            boolean[] isVisited = new boolean[n];\\n            dfs(adj,ans,i,i,isVisited);\\n        }\\n\\n        return ans;\\n    }\\n\\n    private void dfs(List<List<Integer>> adj,List<List<Integer>> ans,int parent,int curr,boolean[] isVisited){\\n        isVisited[curr]=true;\\n        for(int a:adj.get(curr)){\\n            if(!isVisited[a]){\\n                ans.get(a).add(parent);\\n                dfs(adj,ans,parent,a,isVisited);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802446,
                "title": "easy-peasy-java-solution",
                "content": "# Intuition\\njust reverse the edge direction and do dfs \\n\\n# Approach\\n   dfs + traspose graph\\n\\n# Complexity\\n- Time complexity:\\n            \\n\\n\\n        O(v*(v+e))\\n\\n- Space complexity:\\n\\n\\n\\n\\n        O(v+e)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> graph=new ArrayList<>();\\n\\n        for(int i=0;i<n;i++){\\n          graph.add(new ArrayList<>());\\n        }\\n\\n        for(int [] edge:edges){\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n\\n\\n\\n        List<List<Integer>> res=new ArrayList<>();\\n\\n\\n        for(int i=0;i<n;i++){\\n            List<Integer> al =new ArrayList<>();\\n            boolean[] vis=new boolean[n];\\n            dfs(i,graph,vis);\\n            for(int j=0;j<n;j++){\\n                if(vis[j])\\n                    al.add(j);\\n            }\\n            al.remove(Integer.valueOf(i));\\n            res.add(al);\\n        }     \\n        return res;\\n        \\n    }\\n\\n    public void dfs(int i,List<List<Integer>> g,boolean[] vis){\\n        vis[i]=true;\\n         for(int adj:g.get(i)){\\n             if(!vis[adj]){\\n                 dfs(adj,g,vis);\\n             }\\n         }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> getAncestors(int n, int[][] edges) {\\n        List<List<Integer>> graph=new ArrayList<>();\\n\\n        for(int i=0;i<n;i++){\\n          graph.add(new ArrayList<>());\\n        }\\n\\n        for(int [] edge:edges){\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n\\n\\n\\n        List<List<Integer>> res=new ArrayList<>();\\n\\n\\n        for(int i=0;i<n;i++){\\n            List<Integer> al =new ArrayList<>();\\n            boolean[] vis=new boolean[n];\\n            dfs(i,graph,vis);\\n            for(int j=0;j<n;j++){\\n                if(vis[j])\\n                    al.add(j);\\n            }\\n            al.remove(Integer.valueOf(i));\\n            res.add(al);\\n        }     \\n        return res;\\n        \\n    }\\n\\n    public void dfs(int i,List<List<Integer>> g,boolean[] vis){\\n        vis[i]=true;\\n         for(int adj:g.get(i)){\\n             if(!vis[adj]){\\n                 dfs(adj,g,vis);\\n             }\\n         }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789001,
                "title": "easy-dfs-c-all-the-path-from-root",
                "content": "# Intuition\\nIntuition is quite simple. Reverse the [a(from) -> b(to)] and then find all the path from b(current from ) to a (current to).\\n\\n# Approach\\nJust Run a dfs and apply the logic of store the path from root\\n\\n# Complexity\\n- Time complexity:\\n$$O(N^2 * log(n))$$\\n\\n``` Do upvote if it helped you. Thankyou, Happy Coding :)```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void f(int root, vector<int> adj[], vector<int> &visit, set<int> &ans){\\n        visit[root] = 1;\\n        \\n        for(auto i:adj[root]){\\n            if(visit[i]) continue;\\n            ans.insert(i);\\n            f(i,adj,visit,ans);\\n        }\\n    }\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n+1];\\n\\n        for(auto i:edges){\\n            adj[i[1]].push_back(i[0]);\\n        }\\n\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0;i<n;i+=1){\\n            vector<int> visit(n+1,0);\\n            set<int> st;\\n            f(i,adj,visit,st);\\n            vector<int> temp(st.begin(), st.end());\\n            ans.push_back(temp);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "``` Do upvote if it helped you. Thankyou, Happy Coding :)```\n```\\nclass Solution {\\npublic:\\n\\n    void f(int root, vector<int> adj[], vector<int> &visit, set<int> &ans){\\n        visit[root] = 1;\\n        \\n        for(auto i:adj[root]){\\n            if(visit[i]) continue;\\n            ans.insert(i);\\n            f(i,adj,visit,ans);\\n        }\\n    }\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n+1];\\n\\n        for(auto i:edges){\\n            adj[i[1]].push_back(i[0]);\\n        }\\n\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0;i<n;i+=1){\\n            vector<int> visit(n+1,0);\\n            set<int> st;\\n            f(i,adj,visit,st);\\n            vector<int> temp(st.begin(), st.end());\\n            ans.push_back(temp);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785991,
                "title": "bfs-topological-sort-graph-tc-sc-optimized-with-intuition-brute-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1.moving to other nodes with connected components and dependent to other edges\\n2. **dirrected edges without any cycles- topological sort**  \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. if bfs / dfs gives O(n*N) time complexcity , **think  about topological sort with bfs** \\n\\n# Complexity\\n- Time complexity:O(N*N) - moving to each edges and along with that moving to each nodes ,its indegree count \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: queue+ indegree ->= 2*O(n)\\n- set matrix + res matrix -> = O(n*n) \\n- **overall SPACE COMPLEXICITY = o(N*N)** \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int>indG(n,0),adj[n];\\n        queue<int>q;\\n        vector<set<int>>temp(n);\\n        vector<vector<int>> res(n);\\n        for(auto it:edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            indG[it[1]]++;\\n\\n        }\\n        for(int i=0;i<n;++i)\\n        {\\n            if(indG[i]==0)\\n            {\\n                q.push(i);\\n               \\n            }\\n        }\\n        while(!q.empty())\\n        {\\n           \\n                int cur=q.front();\\n                q.pop();\\n                for(auto it:adj[cur])\\n                {\\n                    indG[it]--;\\n                  for(auto y:temp[cur])\\n                  temp[it].insert(y);\\n\\n                    temp[it].insert(cur);\\n                   \\n                    if(indG[it]==0)\\n                    {\\n                        q.push(it);\\n                        \\n                    }\\n\\n                }\\n\\n            \\n        }\\n\\n    for(int i=0;i<n;++i)\\n    { \\n        res[i]=vector<int>(temp[i].begin(),temp[i].end()); \\n    }\\n\\n         return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int>indG(n,0),adj[n];\\n        queue<int>q;\\n        vector<set<int>>temp(n);\\n        vector<vector<int>> res(n);\\n        for(auto it:edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            indG[it[1]]++;\\n\\n        }\\n        for(int i=0;i<n;++i)\\n        {\\n            if(indG[i]==0)\\n            {\\n                q.push(i);\\n               \\n            }\\n        }\\n        while(!q.empty())\\n        {\\n           \\n                int cur=q.front();\\n                q.pop();\\n                for(auto it:adj[cur])\\n                {\\n                    indG[it]--;\\n                  for(auto y:temp[cur])\\n                  temp[it].insert(y);\\n\\n                    temp[it].insert(cur);\\n                   \\n                    if(indG[it]==0)\\n                    {\\n                        q.push(it);\\n                        \\n                    }\\n\\n                }\\n\\n            \\n        }\\n\\n    for(int i=0;i<n;++i)\\n    { \\n        res[i]=vector<int>(temp[i].begin(),temp[i].end()); \\n    }\\n\\n         return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785843,
                "title": "most-easiest-solution-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node,  vector<vector<int>> &v,  vector<int> &vis ){\\n\\n        vis[node]=1;\\n\\n        for(auto x:v[node]){\\n            if(!vis[x]){\\n                dfs(x,v,vis);\\n            }\\n        }\\n\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n         vector<vector<int>> v(n);\\n\\n           for(auto x:edges){\\n\\n               int a=x[0];\\n               int b=x[1];\\n\\n               v[a].push_back(b);\\n           }\\n\\n           vector<vector<int>> ans(n);\\n\\n\\n          \\n\\n           for(int i=0; i<n; i++){\\n          vector<int> vis(n,0);\\n               dfs(i,v,vis);\\n                  for(int j=0; j<vis.size(); j++){\\n                         \\n                      if(vis[j]&&i!=j){\\n                            ans[j].push_back(i);\\n                      }\\n\\n\\n                  }\\n\\n            \\n\\n           }\\n\\n           return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node,  vector<vector<int>> &v,  vector<int> &vis ){\\n\\n        vis[node]=1;\\n\\n        for(auto x:v[node]){\\n            if(!vis[x]){\\n                dfs(x,v,vis);\\n            }\\n        }\\n\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n         vector<vector<int>> v(n);\\n\\n           for(auto x:edges){\\n\\n               int a=x[0];\\n               int b=x[1];\\n\\n               v[a].push_back(b);\\n           }\\n\\n           vector<vector<int>> ans(n);\\n\\n\\n          \\n\\n           for(int i=0; i<n; i++){\\n          vector<int> vis(n,0);\\n               dfs(i,v,vis);\\n                  for(int j=0; j<vis.size(); j++){\\n                         \\n                      if(vis[j]&&i!=j){\\n                            ans[j].push_back(i);\\n                      }\\n\\n\\n                  }\\n\\n            \\n\\n           }\\n\\n           return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763510,
                "title": "reverse-edges-then-dfs-from-every-node-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<vector<int>> &adjList,vector<int>&temp,vector<int>&vis){\\n        vis[node]=1;\\n        temp.push_back(node);\\n        for(auto it: adjList[node]){\\n            if(!vis[it]){\\n                dfs(it,adjList,temp,vis);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adjList(n);\\n        vector<vector<int>> ans(n);\\n        for(auto it: edges){\\n            adjList[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<int> temp;\\n            vector<int> vis(n,0);\\n            dfs(i,adjList,temp,vis);\\n            auto it = temp.begin();\\n            temp.erase(it);\\n            sort(temp.begin(),temp.end());\\n            ans[i] = temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<vector<int>> &adjList,vector<int>&temp,vector<int>&vis){\\n        vis[node]=1;\\n        temp.push_back(node);\\n        for(auto it: adjList[node]){\\n            if(!vis[it]){\\n                dfs(it,adjList,temp,vis);\\n            }\\n        }\\n    }\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adjList(n);\\n        vector<vector<int>> ans(n);\\n        for(auto it: edges){\\n            adjList[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<int> temp;\\n            vector<int> vis(n,0);\\n            dfs(i,adjList,temp,vis);\\n            auto it = temp.begin();\\n            temp.erase(it);\\n            sort(temp.begin(),temp.end());\\n            ans[i] = temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761296,
                "title": "python-bfs",
                "content": "# Approach\\nKahn\\'s Algorithm + BFS\\n\\n    1. Initialization:\\n        Create a dictionary called indegree to store the indegree count of each node (number of incoming edges).\\n        Create a dictionary called adj to store the adjacency list for each node.\\n        Create a list called ans to store the ancestors of each node.\\n\\n    2. Process the edges:\\n        Iterate over each edge (a, b) in the input edges.\\n        Increment the indegree count of node b since it has an incoming edge.\\n        Add node b to the adjacency list of node a.\\n\\n    3. Find nodes with no incoming edges:\\n        Create a queue called queue to store nodes that have no incoming edges.\\n        Iterate over all nodes (0 to n-1).\\n        If a node has an indegree count of 0 (no incoming edges), add it to the queue.\\n\\n    4. Perform BFS:\\n        While the queue is not empty, do the following:\\n            Remove the first node (p) from the queue.\\n            Iterate over each child node of p (obtained from the adjacency list).\\n                Update the ancestors of the child node by adding the ancestors of p along with p itself.\\n                Decrement the indegree count of the child node.\\n                If the indegree count of the child node becomes 0, add it to the queue.\\n\\n    5. Prepare the output:\\n        Convert the ancestor sets in the ans list into sorted lists.\\n        Return the resulting list of sorted ancestor lists.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(|V| + |E|) = O(n ^ 2)\\nDAG can have the maximum number of n * (n - 1) /2 edges where n is the number of vertices. Therefore, we have O(n ^ 2). \\n\\n- Space complexity:\\nO(|V| + |E|) = O(n ^ 2)\\n\\n# Code\\n```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        indegree = defaultdict(int)\\n        adj = defaultdict(set)\\n        ans = [set() for _ in range(n)]\\n        for a, b in edges:\\n            indegree[b] += 1\\n            adj[a].add(b)\\n\\n        queue = deque([])\\n        for a in range(n):\\n            if a not in indegree:\\n                queue.append(a)\\n        \\n        while queue:\\n            p = queue.popleft()\\n            for child in adj[p]:\\n                ans[child].update(ans[p], [p])\\n                indegree[child] -= 1\\n                if indegree[child] == 0:\\n                    queue.append(child)\\n        return [sorted(list(s)) for s in ans]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        indegree = defaultdict(int)\\n        adj = defaultdict(set)\\n        ans = [set() for _ in range(n)]\\n        for a, b in edges:\\n            indegree[b] += 1\\n            adj[a].add(b)\\n\\n        queue = deque([])\\n        for a in range(n):\\n            if a not in indegree:\\n                queue.append(a)\\n        \\n        while queue:\\n            p = queue.popleft()\\n            for child in adj[p]:\\n                ans[child].update(ans[p], [p])\\n                indegree[child] -= 1\\n                if indegree[child] == 0:\\n                    queue.append(child)\\n        return [sorted(list(s)) for s in ans]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718494,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) { \\n          vector<vector<int>>ans(n),g(n);\\n          for(auto &v: edges)\\n          {\\n              g[v[0]].push_back(v[1]);\\n          }\\n          for(int i=0;i<n;i++)\\n          {\\n              vector<bool> vis(n);\\n              dfs(g,i,i,ans,vis);\\n          }\\n          return ans;\\n    }\\n    void dfs(vector<vector<int>> &g,int i,int j,vector<vector<int>>&ans,vector<bool> &vis)\\n     {\\n         vis[j]=true;\\n         for(auto x:g[j])\\n         {\\n             if(!vis[x])\\n             {\\n             ans[x].push_back(i);\\n             dfs(g,i,x,ans,vis);\\n             }\\n         }\\n     } \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) { \\n          vector<vector<int>>ans(n),g(n);\\n          for(auto &v: edges)\\n          {\\n              g[v[0]].push_back(v[1]);\\n          }\\n          for(int i=0;i<n;i++)\\n          {\\n              vector<bool> vis(n);\\n              dfs(g,i,i,ans,vis);\\n          }\\n          return ans;\\n    }\\n    void dfs(vector<vector<int>> &g,int i,int j,vector<vector<int>>&ans,vector<bool> &vis)\\n     {\\n         vis[j]=true;\\n         for(auto x:g[j])\\n         {\\n             if(!vis[x])\\n             {\\n             ans[x].push_back(i);\\n             dfs(g,i,x,ans,vis);\\n             }\\n         }\\n     } \\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576568,
                "content": [
                    {
                        "username": "seafmch",
                        "content": "Because you have to copy over the array of the previous result, which is an O(N) operation. \\n\\nThis problem is O(N^2), no getting around it."
                    },
                    {
                        "username": "rewill11",
                        "content": "so ig performing a dfs from every node would suffice?"
                    },
                    {
                        "username": "juraj24",
                        "content": "Two important things to realize:\\n- Start traversal from every node, starting from node 0. This is to ensure the sorted order of ancestors in the output.\\n- A given node can be reached from an ancestor by different paths. Thus, the first time you reach a node, mark it as seen, record the ancestor, and continue the traversal. The first path to reach a given node \"wins\". Subequent paths that reach the node should neither record the ancestor (that would lead to duplicates), nor continue the traversal (you will run out of memory)."
                    },
                    {
                        "username": "R_aghav",
                        "content": "Is anyhow it\\'s possible to optimized this code ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        vector<vector<int>> vv(n);\\n        for(auto i:edges){\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            queue<int> q;\\n            q.push(i);\\n            if(adj[i].size()==0) {continue; }\\n            set<int> st;\\n            while(!q.empty()){\\n                int node=q.front();\\n                q.pop();\\n                st.insert(node);\\n                for(auto i:adj[node]){\\n                    q.push(i);\\n                }\\n            }\\n          vv[i]=(vector<int> (st.begin(),st.end()));\\n        }\\n        for(int i=0;i<n;i++){\\n            if(vv[i].size()==0) continue;\\n            vv[i].erase(remove(vv[i].begin(),vv[i].end(),i));\\n        }\\n        return vv;\\n    }\\n};\\n"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "what you are truly having trouble with is after creating a adj list is that how will you make a visited array, the simple answer is taking a new vis array for every dfs traversal refer to following for more\\nhttps://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/solutions/3905332/java-dfs-solution "
                    }
                ]
            },
            {
                "id": 1897936,
                "content": [
                    {
                        "username": "seafmch",
                        "content": "Because you have to copy over the array of the previous result, which is an O(N) operation. \\n\\nThis problem is O(N^2), no getting around it."
                    },
                    {
                        "username": "rewill11",
                        "content": "so ig performing a dfs from every node would suffice?"
                    },
                    {
                        "username": "juraj24",
                        "content": "Two important things to realize:\\n- Start traversal from every node, starting from node 0. This is to ensure the sorted order of ancestors in the output.\\n- A given node can be reached from an ancestor by different paths. Thus, the first time you reach a node, mark it as seen, record the ancestor, and continue the traversal. The first path to reach a given node \"wins\". Subequent paths that reach the node should neither record the ancestor (that would lead to duplicates), nor continue the traversal (you will run out of memory)."
                    },
                    {
                        "username": "R_aghav",
                        "content": "Is anyhow it\\'s possible to optimized this code ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        vector<vector<int>> vv(n);\\n        for(auto i:edges){\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            queue<int> q;\\n            q.push(i);\\n            if(adj[i].size()==0) {continue; }\\n            set<int> st;\\n            while(!q.empty()){\\n                int node=q.front();\\n                q.pop();\\n                st.insert(node);\\n                for(auto i:adj[node]){\\n                    q.push(i);\\n                }\\n            }\\n          vv[i]=(vector<int> (st.begin(),st.end()));\\n        }\\n        for(int i=0;i<n;i++){\\n            if(vv[i].size()==0) continue;\\n            vv[i].erase(remove(vv[i].begin(),vv[i].end(),i));\\n        }\\n        return vv;\\n    }\\n};\\n"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "what you are truly having trouble with is after creating a adj list is that how will you make a visited array, the simple answer is taking a new vis array for every dfs traversal refer to following for more\\nhttps://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/solutions/3905332/java-dfs-solution "
                    }
                ]
            },
            {
                "id": 1843396,
                "content": [
                    {
                        "username": "seafmch",
                        "content": "Because you have to copy over the array of the previous result, which is an O(N) operation. \\n\\nThis problem is O(N^2), no getting around it."
                    },
                    {
                        "username": "rewill11",
                        "content": "so ig performing a dfs from every node would suffice?"
                    },
                    {
                        "username": "juraj24",
                        "content": "Two important things to realize:\\n- Start traversal from every node, starting from node 0. This is to ensure the sorted order of ancestors in the output.\\n- A given node can be reached from an ancestor by different paths. Thus, the first time you reach a node, mark it as seen, record the ancestor, and continue the traversal. The first path to reach a given node \"wins\". Subequent paths that reach the node should neither record the ancestor (that would lead to duplicates), nor continue the traversal (you will run out of memory)."
                    },
                    {
                        "username": "R_aghav",
                        "content": "Is anyhow it\\'s possible to optimized this code ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        vector<vector<int>> vv(n);\\n        for(auto i:edges){\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            queue<int> q;\\n            q.push(i);\\n            if(adj[i].size()==0) {continue; }\\n            set<int> st;\\n            while(!q.empty()){\\n                int node=q.front();\\n                q.pop();\\n                st.insert(node);\\n                for(auto i:adj[node]){\\n                    q.push(i);\\n                }\\n            }\\n          vv[i]=(vector<int> (st.begin(),st.end()));\\n        }\\n        for(int i=0;i<n;i++){\\n            if(vv[i].size()==0) continue;\\n            vv[i].erase(remove(vv[i].begin(),vv[i].end(),i));\\n        }\\n        return vv;\\n    }\\n};\\n"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "what you are truly having trouble with is after creating a adj list is that how will you make a visited array, the simple answer is taking a new vis array for every dfs traversal refer to following for more\\nhttps://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/solutions/3905332/java-dfs-solution "
                    }
                ]
            },
            {
                "id": 2012944,
                "content": [
                    {
                        "username": "seafmch",
                        "content": "Because you have to copy over the array of the previous result, which is an O(N) operation. \\n\\nThis problem is O(N^2), no getting around it."
                    },
                    {
                        "username": "rewill11",
                        "content": "so ig performing a dfs from every node would suffice?"
                    },
                    {
                        "username": "juraj24",
                        "content": "Two important things to realize:\\n- Start traversal from every node, starting from node 0. This is to ensure the sorted order of ancestors in the output.\\n- A given node can be reached from an ancestor by different paths. Thus, the first time you reach a node, mark it as seen, record the ancestor, and continue the traversal. The first path to reach a given node \"wins\". Subequent paths that reach the node should neither record the ancestor (that would lead to duplicates), nor continue the traversal (you will run out of memory)."
                    },
                    {
                        "username": "R_aghav",
                        "content": "Is anyhow it\\'s possible to optimized this code ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        vector<vector<int>> vv(n);\\n        for(auto i:edges){\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            queue<int> q;\\n            q.push(i);\\n            if(adj[i].size()==0) {continue; }\\n            set<int> st;\\n            while(!q.empty()){\\n                int node=q.front();\\n                q.pop();\\n                st.insert(node);\\n                for(auto i:adj[node]){\\n                    q.push(i);\\n                }\\n            }\\n          vv[i]=(vector<int> (st.begin(),st.end()));\\n        }\\n        for(int i=0;i<n;i++){\\n            if(vv[i].size()==0) continue;\\n            vv[i].erase(remove(vv[i].begin(),vv[i].end(),i));\\n        }\\n        return vv;\\n    }\\n};\\n"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "what you are truly having trouble with is after creating a adj list is that how will you make a visited array, the simple answer is taking a new vis array for every dfs traversal refer to following for more\\nhttps://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/solutions/3905332/java-dfs-solution "
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximize the Topmost Element After K Moves",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> representing the contents of a <b>pile</b>, where <code>nums[0]</code> is the topmost element of the pile.</p>\n\n<p>In one move, you can perform <strong>either</strong> of the following:</p>\n\n<ul>\n\t<li>If the pile is not empty, <strong>remove</strong> the topmost element of the pile.</li>\n\t<li>If there are one or more removed elements, <strong>add</strong> any one of them back onto the pile. This element becomes the new topmost element.</li>\n</ul>\n\n<p>You are also given an integer <code>k</code>, which denotes the total number of moves to be made.</p>\n\n<p>Return <em>the <strong>maximum value</strong> of the topmost element of the pile possible after <strong>exactly</strong></em> <code>k</code> <em>moves</em>. In case it is not possible to obtain a non-empty pile after <code>k</code> moves, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,2,2,4,0,6], k = 4\n<strong>Output:</strong> 5\n<strong>Explanation:</strong>\nOne of the ways we can end with 5 at the top of the pile after 4 moves is as follows:\n- Step 1: Remove the topmost element = 5. The pile becomes [2,2,4,0,6].\n- Step 2: Remove the topmost element = 2. The pile becomes [2,4,0,6].\n- Step 3: Remove the topmost element = 2. The pile becomes [4,0,6].\n- Step 4: Add 5 back onto the pile. The pile becomes [5,4,0,6].\nNote that this is not the only way to end with 5 at the top of the pile. It can be shown that 5 is the largest answer possible after 4 moves.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2], k = 1\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> \nIn the first move, our only option is to pop the topmost element of the pile.\nSince it is not possible to obtain a non-empty pile after one move, we return -1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i], k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1844102,
                "title": "c-discuss-case-by-case",
                "content": "\\n\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n\\n## Solution 1.\\n\\nSee comments in the code.\\n\\nA note on the removing `min(k - 1, N)` elements case:\\n\\nWhat if `k > N + 1` -- there are still steps left after removing `N` elements and putting back the greatest one? We can always waste these steps by putting another element in and out. Since `N >= 2` in this case, it\\'s guaranteed to have another element to waste steps.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/maximize-the-topmost-element-after-k-moves/\\n// Author: github.com/lzl124631x\\n// Time: O(min(N, K))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& A, int k) {\\n        int N = A.size();\\n        if (k == 0) return N >= 1 ? A[0] : -1; // if no moves allowed, return the topmost element if any\\n        if (k == 1) return N == 1 ? -1 : A[1]; // if only one move is allowed, we can only remove the topmost element\\n        if (N == 1) return k % 2 == 0 ? A[0] : -1; // if `N == 1`, we can return the topmost element if `k` is a even number (keep removing the topmost element and adding it back).\\n        int mx = *max_element(begin(A), begin(A) + min(k - 1, N)); // we can take `min(k-1, N)` elements and put back the largest one on the top\\n        if (k < N) mx = max(mx, A[k]); // If `k < N`, we can take all the topmost `k` elements and return the one left at the top\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/maximize-the-topmost-element-after-k-moves/\\n// Author: github.com/lzl124631x\\n// Time: O(min(N, K))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& A, int k) {\\n        int N = A.size();\\n        if (k == 0) return N >= 1 ? A[0] : -1; // if no moves allowed, return the topmost element if any\\n        if (k == 1) return N == 1 ? -1 : A[1]; // if only one move is allowed, we can only remove the topmost element\\n        if (N == 1) return k % 2 == 0 ? A[0] : -1; // if `N == 1`, we can return the topmost element if `k` is a even number (keep removing the topmost element and adding it back).\\n        int mx = *max_element(begin(A), begin(A) + min(k - 1, N)); // we can take `min(k-1, N)` elements and put back the largest one on the top\\n        if (k < N) mx = max(mx, A[k]); // If `k < N`, we can take all the topmost `k` elements and return the one left at the top\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844179,
                "title": "python-o-n-t-o-1-s-explanation",
                "content": "We dont need to remove any element from the array, we can just keep track of the maximum element.\\n\\n**Steps:**\\nWe initialize variable (maxi) which keeps track of the maximum topmost element.\\nIf k > len(array), then we can traverse the entire array once and find the maximum element of the array. \\n  Example: arr = [5,2,2,4,0,6], k = 40 ==> ans = 6\\n  \\nIf k == len(array), then we need to traverse upto the k-1<sup>th</sup> element and find the maximum element. We use only k-1 steps as the last step would be required to add the maximum element back at the top.\\n  Example: arr = [5,2,2,4,0,6], k = 6 ==> ans = 5\\n  \\nIf k < len(array), then we can traverse upto the k-1<sup>th</sup> element of the array and find the maximum element. In this case there is also a possibility that the k<sup>th</sup> element will be greater than the maximum element that we have found, so we do a check to see which is greater (We will be removing first k elements from the array if the k<sup>th</sup> element is greater).\\nExample: arr = [5,2,2,4,0,6], k = 5 ==> ans = 6\\n\\nIf the len(array) is 1 and k is odd, then we will not be able to find an answer.\\n\\n```\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if (len(nums) == 1) and (k & 1): return -1\\n        \\n        maxi = -1\\n        for i in range(min(len(nums), k-1)):\\n            maxi = max(maxi, nums[i])\\n        \\n        if k < len(nums):\\n            maxi = max(maxi, nums[k])\\n            \\n        return maxi\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if (len(nums) == 1) and (k & 1): return -1\\n        \\n        maxi = -1\\n        for i in range(min(len(nums), k-1)):\\n            maxi = max(maxi, nums[i])\\n        \\n        if k < len(nums):\\n            maxi = max(maxi, nums[k])\\n            \\n        return maxi\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1844089,
                "title": "simple-java-solution-removing-top-k-1-element-and-comparing-with-kth-elemt",
                "content": "\\n    public static int maximumTop(int[] nums, int k) {\\n        if (nums.length == 1 && k % 2 == 1) return -1; // if size is 1 and k odd stack will be empty\\n        int max = 0;\\n        for (int i = 0; i < Math.min(k - 1 ,nums.length); i++) //finding the max element from first k-1 elelment or len -1 if len is less than k\\n            max = Math.max(max, nums[i]);\\n        if (k < nums.length)  // check for scenario where we dont have to put back Max out of k-1 element\\n            max = Math.max(max, nums[k]);\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "\\n    public static int maximumTop(int[] nums, int k) {\\n        if (nums.length == 1 && k % 2 == 1) return -1; // if size is 1 and k odd stack will be empty\\n        int max = 0;\\n        for (int i = 0; i < Math.min(k - 1 ,nums.length); i++) //finding the max element from first k-1 elelment or len -1 if len is less than k\\n            max = Math.max(max, nums[i]);\\n        if (k < nums.length)  // check for scenario where we dont have to put back Max out of k-1 element\\n            max = Math.max(max, nums[k]);\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1844303,
                "title": "simple-understanding-c-code-with-explanation",
                "content": "We can infer from the question that in the first operation we have to remove first element and for remaining k-1 choices we can convert the question into following 4 cases:\\n\\n3 4 5 ,k=2     output will be 5\\nprocess:\\nk=1 - 3 will be reomved\\nk=2 - 4 will be reomved \\nnow 5 will be answer\\n\\n3 5 4 2 1 k=3 output will be 5\\nprocess:\\nk=1 - 3 will be removes \\nk=2 - 5 will be removed \\nnow we have 2 choices either to add 5 or remove 4( then 2 will be on top ) out of which best would be to add 5 so we add 5\\n5 4 2 1\\n\\n\\nWe can split the question into 4 cases.\\n\\n1st case :\\nIf the size of the vector is 1\\nFor 1st operation : We will remove the element from the vector.\\nFor 2nd operation : We will add the element to the vector.\\nFor 3rd operation : We will remove the element from the vector.\\nFor 4th operation : We will add the element to the vector.\\nFor 5th operation : We will remove the element from the vector.\\nFor 6th operation : We will add the element to the vector.\\n..\\n..\\nWe can generalize that if the number of operations is odd, the vector will be empty and so we will return -1.\\nIf the number of operations is even then we will return the element.\\n\\n2nd case :\\nIf the number of operations is greater than the vector size, then we can remove all the elements from the vector and add the highest elements.\\nBy generalizing this case, we can return the maximum element of the vector.\\n\\n3rd case :\\nIf the number of operations is equal to the vector size, then we will remove the first (k-1) elements from the vector and add the maximum element from the removed elements to vector.\\nSo we will return the maximum element from the first (k-1) elements.\\n\\n4th case :\\nIf the number of operations is less than vector size, then we will remove the first (k-1) elements from the vector and we have a option of removing the kth element from the vector or adding the maximum of removed (k-1) elements.\\nBy generalizing, the answer will be maximum element from the maximum element of  first (k-1) elements and the (k+1)th element.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& v, int k) {\\n        int n=v.size();\\n        if(n==1 && k%2==1){\\n            return -1;\\n        }\\n        int mx=INT_MIN;\\n        for(int i=0;i<n && i<k-1;i++){\\n            mx=max(mx,v[i]);\\n        }\\n        if(k<n){\\n            mx=max(mx,v[k]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& v, int k) {\\n        int n=v.size();\\n        if(n==1 && k%2==1){\\n            return -1;\\n        }\\n        int mx=INT_MIN;\\n        for(int i=0;i<n && i<k-1;i++){\\n            mx=max(mx,v[i]);\\n        }\\n        if(k<n){\\n            mx=max(mx,v[k]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877511,
                "title": "tricky-edge-cases",
                "content": "Easy intuition (return the largest of `k - 1` elements), but tricky edge cases:\\n\\n1. One element - pile is empty if `k` is odd.\\n2. `k < 2` - return `nums[k]`.\\n3. `k >= n` - return the maximum element from the array.\\n\\t- Edge case when `k == n` - we have to keep last element in the pile to avoid empty pile.\\n4. `k < n` \\n\\t- Remove `k - 1` elements and return the largest one among those.\\n\\t- Or remove `k` elements and return `nums[k]`.\\n\\n**C++**\\n```cpp\\nint maximumTop(vector<int>& nums, int k) {\\n    if (nums.size() == 1 && k % 2)\\n        return -1;\\n    if (k < 2)\\n        return nums[k];\\n    if (k >= nums.size())\\n        return *max_element(begin(nums), end(nums) - (k == nums.size()));\\n    return max(nums[k], *max_element(begin(nums), begin(nums) + k - 1));\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maximumTop(vector<int>& nums, int k) {\\n    if (nums.size() == 1 && k % 2)\\n        return -1;\\n    if (k < 2)\\n        return nums[k];\\n    if (k >= nums.size())\\n        return *max_element(begin(nums), end(nums) - (k == nums.size()));\\n    return max(nums[k], *max_element(begin(nums), begin(nums) + k - 1));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844141,
                "title": "c-greedy-cases-discussed-with-examples",
                "content": "Three main cases to be noticed:\\n\\n1) Remove k elements (k+1th is maxm) \\n**Example:**\\n``k = 7``\\n`` A = [1,2,3,4,5,6,7,8]``\\noptimal solution = remove top 7 elements then top will be 8\\n\\n2) Remove k-1 elements then insert maxm element (maxm element lies in [0,k-1])\\n**Example:**\\n``k = 7 ``\\n`` A = [1,2,3,4,5,8,7,6]``\\nOptimal solution = remove top 6 elements and then insert 8\\n\\n\\n\\n3) When **k>n (n>=2)**\\nWe can remove all elements and insert top two or top 1 element\\nFor Example: ``A = [1,2,3,4,5]``\\n``k=6``\\nBest solution: Remove all elements (5 moves) and insert max element (i.e 5) ( total moves = 6)\\n``k=7``\\nBest solution: Remove all elements (5 moves) insert 4 and then insert max element (i.e 5) (total moves = 7)\\n``k=8``\\nBest solution: Remove all elements (5 moves) insert max, remove max and then insert max again (total moves = 8)\\nSimilarly we can do for any value of k, k>n\\n\\nCode Referred From [Sushant Mishra](https://leetcode.com/sushantk_04/)\\n\\nTime Complexity : **O(min(k,n))**\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n   \\n        //if no moves given first element is max element\\n        if(k == 0) return nums[0];\\n        \\n        //if size is one we can remove one element and insert one element only when k is even\\n        if(k %2 != 0 && nums.size()==1) return -1;\\n        \\n        int n = nums.size();\\n        int i=0, maxm = 0;\\n        \\n        // Remove top k-1 elements and find maxm out of them\\n        while(i < n && i < k-1){\\n            maxm = max(maxm, nums[i]);\\n            i++;\\n        }\\n        \\n        int ans = 0;\\n        \\n        //We choose best from two options \\n        //either remove k elements (k+1th is maxm) or remove k-1 elements then insert maxm element (maxm element lies in [0,k-1])\\n        if(k < n) ans = nums[k];\\n        return max(maxm, ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n   \\n        //if no moves given first element is max element\\n        if(k == 0) return nums[0];\\n        \\n        //if size is one we can remove one element and insert one element only when k is even\\n        if(k %2 != 0 && nums.size()==1) return -1;\\n        \\n        int n = nums.size();\\n        int i=0, maxm = 0;\\n        \\n        // Remove top k-1 elements and find maxm out of them\\n        while(i < n && i < k-1){\\n            maxm = max(maxm, nums[i]);\\n            i++;\\n        }\\n        \\n        int ans = 0;\\n        \\n        //We choose best from two options \\n        //either remove k elements (k+1th is maxm) or remove k-1 elements then insert maxm element (maxm element lies in [0,k-1])\\n        if(k < n) ans = nums[k];\\n        return max(maxm, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844186,
                "title": "python-3-find-maximum-of-first-k-1-elements-or-k-1-th-element-beats-100",
                "content": "The num after the kth element do not matter as they can\\'t be accessed.\\nSo, handling some corner cases like:\\n1. If len(num) == 1.\\n2. if k == 0\\n3. Comparing k and len(nums)\\n\\n**DO UPVOTE if you found it useful.**\\n```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1:\\n            if k%2 != 0:\\n                return -1\\n            return nums[0]\\n        \\n        if k == 0:\\n            return nums[0]\\n        if k == len(nums):\\n            return max(nums[:-1])\\n        if k > len(nums):\\n            return max(nums)\\n        if k == 1:\\n            return nums[1]\\n        m = max(nums[:k-1])\\n        m = max(m, nums[k])\\n        return m\\n```\\nTime Complexity: O(n) - finding max\\nSpace Complexity: O(1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1:\\n            if k%2 != 0:\\n                return -1\\n            return nums[0]\\n        \\n        if k == 0:\\n            return nums[0]\\n        if k == len(nums):\\n            return max(nums[:-1])\\n        if k > len(nums):\\n            return max(nums)\\n        if k == 1:\\n            return nums[1]\\n        m = max(nums[:k-1])\\n        m = max(m, nums[k])\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844710,
                "title": "java-discuss-case-by-case-beat-100",
                "content": "The idea is quite simple and straitforward based on observation:\\n1)when n==1\\n2)when n > 1\\n        1. when k > n\\n        2. when k == n\\n        3. when k < n\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length, max = -1;\\n\\t\\t\\n        if(n==1){\\n            if(k%2==1)  return -1;\\n            else    return nums[0];\\n        }\\n\\t\\t\\n        if(k<n) max = nums[k];\\n        else if(k>n)    k = n+1;\\n\\t\\t\\n        for (int i = 0; i < k-1; i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        return max;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length, max = -1;\\n\\t\\t\\n        if(n==1){\\n            if(k%2==1)  return -1;\\n            else    return nums[0];\\n        }\\n\\t\\t\\n        if(k<n) max = nums[k];\\n        else if(k>n)    k = n+1;\\n\\t\\t\\n        for (int i = 0; i < k-1; i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845405,
                "title": "c-85-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0) return nums[0];\\n        int n = nums.size();\\n        if(n==1){\\n            if(k&1) return -1;\\n            else   return nums[0];\\n        }\\n        if(k<n) {\\n                    if(k==1) return nums[1];\\n            return max(*(max_element(nums.begin(),nums.begin() + k-1)) , nums[k]);\\n        }\\n        if(k==n){\\n            return *(max_element(nums.begin(),nums.begin() + k-1));\\n        }\\n        return *(max_element(nums.begin(),nums.begin()+n));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0) return nums[0];\\n        int n = nums.size();\\n        if(n==1){\\n            if(k&1) return -1;\\n            else   return nums[0];\\n        }\\n        if(k<n) {\\n                    if(k==1) return nums[1];\\n            return max(*(max_element(nums.begin(),nums.begin() + k-1)) , nums[k]);\\n        }\\n        if(k==n){\\n            return *(max_element(nums.begin(),nums.begin() + k-1));\\n        }\\n        return *(max_element(nums.begin(),nums.begin()+n));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844205,
                "title": "java-detailed-explanation-small-code",
                "content": "If the array has only one element, then we can just add/remove a single element. Hence, in case \\'k\\' is even, we return the only element else we return -1 because it is not possible to perform \\'k\\' steps and finish with a non empty pile.\\n\\nFor generic cases, we traverse the array and for every element calculate the steps required to make that element as the top most element. Finally we find the max number which can be made as the topmost element.\\n\\n**Number of steps to make an element as the topmost element of the pile:**\\nFor ith index, first we need i steps (steps consumed) to remove the elements before it. Then, if we still have steps left (k>steps consumed), then we will be able to make it the top most element only if remaining steps is greater than 0 and not equal to 1.\\n\\n\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length;\\n        if(n==1){\\n            if(k%2!=0){\\n                return -1;\\n            }\\n            return nums[0];\\n        }\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            int stepsConsumed = i;\\n            stepsConsumed = k-stepsConsumed;\\n            if(stepsConsumed>=0 && stepsConsumed!=1){\\n                ans = Math.max(ans, nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Please upvote if you find this helpful ! :)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length;\\n        if(n==1){\\n            if(k%2!=0){\\n                return -1;\\n            }\\n            return nums[0];\\n        }\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            int stepsConsumed = i;\\n            stepsConsumed = k-stepsConsumed;\\n            if(stepsConsumed>=0 && stepsConsumed!=1){\\n                ans = Math.max(ans, nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012753,
                "title": "c-greedy-and-observation-based-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        // If size of nums is one and k is odd then we will not have any element in the pile.\\n        // Therefore will return -1.\\n        if(nums.size() == 1 and k % 2 != 0) {\\n            return -1;\\n        }\\n        \\n        // If k is greater than nums.size() then the answer would be then maximum element of nums array.\\n        if(nums.size() < k) {\\n            return *max_element(nums.begin(), nums.end());\\n        }\\n        \\n        // This below condition will apply only when k is less than nums.size()\\n        // The answer would be be either the maximum from nums[0], nums[1], .... nums[k - 2] or nums[k].\\n        // We can never have nums[k - 1] as answer.\\n        int ans = 0;\\n        for(int i = 0; i < k - 1; i++) {\\n            ans = max(ans, nums[i]);\\n        }\\n        if(k < nums.size()) {\\n            ans = max(ans, nums[k]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        // If size of nums is one and k is odd then we will not have any element in the pile.\\n        // Therefore will return -1.\\n        if(nums.size() == 1 and k % 2 != 0) {\\n            return -1;\\n        }\\n        \\n        // If k is greater than nums.size() then the answer would be then maximum element of nums array.\\n        if(nums.size() < k) {\\n            return *max_element(nums.begin(), nums.end());\\n        }\\n        \\n        // This below condition will apply only when k is less than nums.size()\\n        // The answer would be be either the maximum from nums[0], nums[1], .... nums[k - 2] or nums[k].\\n        // We can never have nums[k - 1] as answer.\\n        int ans = 0;\\n        for(int i = 0; i < k - 1; i++) {\\n            ans = max(ans, nums[i]);\\n        }\\n        if(k < nums.size()) {\\n            ans = max(ans, nums[k]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844149,
                "title": "c-commented-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        if(k==0)return nums[0];  //can\\'t do anything in such a case\\n        \\n        if(nums.size()==1){  \\n            if(k%2!=0)return -1;   // will always end up with empty array after k operations.\\n            return nums[0];\\n        }\\n        \\n        int maxm=0, n=nums.size();\\n        for(auto i: nums)maxm=max(maxm,i);\\n        if(k>n)return maxm;   // can have any value from the array at the top in case k>n, hence, maximum element will be the result.\\n        \\n        int res=0;\\n        for(int i=0;i<k-1;i++)res=max(res,nums[i]);  //k>(k-1), hence, assume k-1 to be new n,so we can have any val from 0th to (k-2)th idx\\n                                                     //at the top, if we would want it to be at the top.\\n        \\n        if(k<n)res=max(res,nums[k]);                 //additional case, as we can remove elements from 0th to (k-1)th idx in k moves and if \\n                                                     //kth idx exists in the array then it can be a probable candidate for the answer too.\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        if(k==0)return nums[0];  //can\\'t do anything in such a case\\n        \\n        if(nums.size()==1){  \\n            if(k%2!=0)return -1;   // will always end up with empty array after k operations.\\n            return nums[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1845153,
                "title": "c-intutive-approach-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        priority_queue<int>pq;\\n        stack<int>st;\\n        \\n        int n = nums.size();\\n        for(int i = nums.size()-1;i>=0;i--)\\n            st.push(nums[i]);\\n        \\n        if(k%2 != 0 && nums.size() == 1)\\n            return -1;\\n        \\n        if(k > n ){\\n            int maxi = *max_element(nums.begin(),nums.end());\\n            pq.push(maxi);\\n            k = k-1;\\n        }\\n        \\n        if(k!=n)\\n        k = k%nums.size();\\n        \\n        int steps = k-1;\\n        if(steps == 0){\\n            while(k--){\\n                st.pop();\\n            }\\n            if(st.empty())\\n            return -1;\\n        }\\n        \\n        while(steps > 0){\\n            pq.push(st.top());\\n            st.pop();\\n            steps--;\\n        }\\n        \\n        if(pq.size()>0){\\n        st.pop();\\n        if(st.empty())\\n            st.push(pq.top());\\n        else if(pq.top() > st.top())\\n        st.push(pq.top());\\n        }\\n        \\n        return st.top();\\n    }\\n};",
                "solutionTags": [
                    "Stack",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        priority_queue<int>pq;\\n        stack<int>st;\\n        \\n        int n = nums.size();\\n        for(int i = nums.size()-1;i>=0;i--)\\n            st.push(nums[i]);\\n        \\n        if(k%2 != 0 && nums.size() == 1)\\n            return -1;\\n        \\n        if(k > n ){\\n            int maxi = *max_element(nums.begin(),nums.end());\\n            pq.push(maxi);\\n            k = k-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1844424,
                "title": "c-solution-explanation-short-code",
                "content": "**If n is 1 and k is odd**, then array will always be empty. In this case answer will be -1.\\n\\n**Example:** \\nnums=[23], k=3 , \\n\\nHere after first operation,\\nnums=[]\\n\\nAfter second operation,\\nnums=[23]\\n\\nAfter third operation,\\nnums=[]\\n\\n\\n**In rest of the situations, you have two options:**\\n1)  You can remove first k-1 elements, consuming k-1 operations.\\n\\t Among removed k-1 elements, choose the maximum element and place it on the top.\\n2)  Remove all k elements. Considering 0-based indexing, in this case, nums[k] will be topmost element.\\n\\nSince k can be upto 10^9,  we have to be careful.\\n\\nIn code, (k&1) is an alternative to k%2. \\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==1&&(k&1)){\\n            return -1;\\n        }\\n        int mxm=-1;\\n        for(int i=0;i<n&&i<k-1;i++){\\n            mxm=max(mxm,nums[i]);\\n        }\\n        if(k<n){\\n            mxm=max(mxm,nums[k]);\\n        }\\n        return mxm;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==1&&(k&1)){\\n            return -1;\\n        }\\n        int mxm=-1;\\n        for(int i=0;i<n&&i<k-1;i++){\\n            mxm=max(mxm,nums[i]);\\n        }\\n        if(k<n){\\n            mxm=max(mxm,nums[k]);\\n        }\\n        return mxm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844252,
                "title": "java-o-n-greedy",
                "content": "With k steps, other than the nums[k - 1] element, we can put any one form nums[0] to nums[k - 2] to the top;\\n we also need to compare the top one after remove k element if there is one;\\nTime: O(min(n,k))\\nSpace: O(1)\\n\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int ans = -1;\\n        if (nums.length == 1 && k % 2 == 1)\\n            return ans;\\n        //\\n        for (int i = 0; i < k - 1 && i < nums.length; i++) {\\n            ans = Math.max(ans, nums[i]);\\n        }\\n        if (k < nums.length)\\n            ans = Math.max(ans, nums[k]);\\n        return  ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int ans = -1;\\n        if (nums.length == 1 && k % 2 == 1)\\n            return ans;\\n        //\\n        for (int i = 0; i < k - 1 && i < nums.length; i++) {\\n            ans = Math.max(ans, nums[i]);\\n        }\\n        if (k < nums.length)\\n            ans = Math.max(ans, nums[k]);\\n        return  ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563379,
                "title": "4-line-java-code-beat-100",
                "content": "Please upvote if this helps\\n```\\npublic int maximumTop(int[] nums, int k) {\\n        int max = -1;\\n        if(nums.length==1) return k%2==1? max : nums[0];\\n        for(int i =0; i<nums.length && i<k-1; i++) max = Math.max(max,nums[i]);  \\n        return (k<nums.length && nums[k]>max)? nums[k]: max;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maximumTop(int[] nums, int k) {\\n        int max = -1;\\n        if(nums.length==1) return k%2==1? max : nums[0];\\n        for(int i =0; i<nums.length && i<k-1; i++) max = Math.max(max,nums[i]);  \\n        return (k<nums.length && nums[k]>max)? nums[k]: max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2450648,
                "title": "c-easy-clean-code",
                "content": "class Solution {\\npublic\\n\\n    //source:bro coders\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1&&k%2)return -1;//k is odd\\n        if(k==1)return nums[1];//nums.size() wala edge case ho chuka \\n        int ans=0,n=nums.size();\\n        if(k>n){\\n            for(auto i:nums) ans=max(ans,i);\\n            return ans;\\n        }\\n        if(k==n){\\n            for(int i=0;i<k-1;i++) ans=max(ans,nums[i]);\\n            return ans;\\n        }\\n        else {\\n            for(int i=0;i<k-1;i++)ans=max(ans,nums[i]);     \\n            return max(ans,nums[k]);\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\npublic\\n\\n    //source:bro coders\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1&&k%2)return -1;//k is odd\\n        if(k==1)return nums[1];//nums.size() wala edge case ho chuka \\n        int ans=0,n=nums.size();\\n        if(k>n){\\n            for(auto i:nums) ans=max(ans,i);\\n            return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2449115,
                "title": "97-faster-c-easy-o-n",
                "content": "//**UPVOTE IF IT HELPS**\\n\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        if(k==0)\\n            return nums[0];\\n        \\n        if(n==1)\\n        {   if(k%2!=0)\\n            return -1;\\n         else\\n             return nums[0];\\n        \\n        }\\n        int maxi =INT_MIN;\\n        if(k > n )\\n        {\\n         for(int i=0;i<nums.size();i++)\\n         {\\n            maxi = max(maxi,nums[i]);\\n         }\\n           return maxi; \\n        }\\n        else{\\n            int j=0;\\n            for(j=0;j<k-1;j++)\\n            {\\n                maxi=max(maxi,nums[j]);\\n            }\\n            if(nums[j+1] > maxi)\\n            {\\n                return nums[j+1];\\n            }\\n            else return maxi;\\n        }\\n        \\n        return -1;\\n    }\\n        \\n};",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        if(k==0)\\n            return nums[0];\\n        \\n        if(n==1)\\n        {   if(k%2!=0)\\n            return -1;\\n         else\\n             return nums[0];\\n        \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2297657,
                "title": "easy-soution-self-explanatory",
                "content": "```\\nclass Solution {\\n\\tpublic static int maximumTop(int[] arr, int k) {\\n\\t\\tif (arr.length == 1 && k % 2 == 1) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tint max = -1;\\n\\t\\tint len = Math.min(arr.length, k-1);\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tmax = Math.max(arr[i], max);\\n\\t\\t}\\n\\t\\tif (k < arr.length) {\\n\\t\\t\\treturn Math.max(arr[k], max);\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic static int maximumTop(int[] arr, int k) {\\n\\t\\tif (arr.length == 1 && k % 2 == 1) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tint max = -1;\\n\\t\\tint len = Math.min(arr.length, k-1);\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tmax = Math.max(arr[i], max);\\n\\t\\t}\\n\\t\\tif (k < arr.length) {\\n\\t\\t\\treturn Math.max(arr[k], max);\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948854,
                "title": "why-this-6-lines-code-works-java-o-1-space-o-n-time",
                "content": "```\\nRuntime: 1 ms, faster than 98.78% of Java online submissions for Maximize the Topmost Element After K Moves.\\nMemory Usage: 57.7 MB, less than 86.04% of Java online submissions for Maximize the Topmost Element After K Moves.\\n```\\n**Solution Code**\\n```\\nclass Solution {\\n    public int maximumTop(int[] ar, int k) {\\n        int n=ar.length;\\n        if(n==1 && k%2!=0)return -1; //base case\\n        int max = -1;\\n        for (int i = 0; i < Math.min(n , k + 1); i++) \\n            if (i != k - 1) max = Math.max(max, ar[i]);\\n        return max;\\n    }\\n    \\n}\\n\\n```\\n\\nTime `O(N)`\\nSpace `O(1)`\\n\\n**Why this solution works?**\\n- The base case is very clear. If we have odd operations to perform and length of given array is 1, then we\\'ll always be left with an empty array after the operations which is not valid.\\n- Now, we see we have `k` operations to perform. What can be the topmost element of the array? Let\\'s think over it. \\n\\t- The topmost element either can be the element peeked after popping `k` elements from array (considering `n >k`)\\n\\t- Or pop out `k-1` elements and for the kth move,push the max element we have popped so far. Read it again.\\n\\nWhat do we conclude?\\nTopmost element can be either kth index element (after removing k elements i.e 0,1,2,3...k-1 indices) or can be the max element we have got in removing k-1 elements  i.e 0,1,2,3...k-2 indices because 1 move will  be required to push the max element.\\nThis logic is what coded in the above solution.\\n\\nOR\\n\\nYou can visualize this as:\\n`(k-1)th` index can never be the topmost element, because if `(k-1)th` element is on the top that means \\n- either we have done only (k-1)moves so either push a value from popped elements or pop one more tocomplete k moves.\\n- or we have taken k+1 moves, k moves to pop upto `(k-1)th` index elements & one move again to push the  `(k-1)th` index element.\\n\\nHope you get the solution. Please upvote if you do.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nRuntime: 1 ms, faster than 98.78% of Java online submissions for Maximize the Topmost Element After K Moves.\\nMemory Usage: 57.7 MB, less than 86.04% of Java online submissions for Maximize the Topmost Element After K Moves.\\n```\n```\\nclass Solution {\\n    public int maximumTop(int[] ar, int k) {\\n        int n=ar.length;\\n        if(n==1 && k%2!=0)return -1; //base case\\n        int max = -1;\\n        for (int i = 0; i < Math.min(n , k + 1); i++) \\n            if (i != k - 1) max = Math.max(max, ar[i]);\\n        return max;\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844584,
                "title": "c-priority-queue-simple-greedy",
                "content": "Consider the test case [5,6,7,8,10,18,14,6,7,8] and k = 6 output is 14.\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0)return nums[0];\\n        if(k %2 != 0 and nums.size()==1)// if nums.size()==1 then if k is odd then it becomes empty \\n            return -1;\\n        if(k==1 and nums.size()>=2)return nums[1];\\n        priority_queue<int> pq;\\n       if( k > nums.size())\\n           return *max_element(nums.begin(), nums.end());\\n        else if(k==nums.size())\\n        {\\n             for(int i=0;i<k-1;i++)\\n            {\\n              pq.push(nums[i]);\\n            }\\n            return pq.top();\\n        }\\n        else\\n        {   //idea is simple boss:\\n            //remove k-1 elemets store the max and compare it with the nums[k] so either pq.top() wins or nums[k]\\n            for(int i=0;i<k-1;i++)\\n            {\\n              pq.push(nums[i]);\\n            }\\n            \\n            int ans = pq.top()>nums[k]?pq.top():nums[k];\\n          \\n            return ans;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0)return nums[0];\\n        if(k %2 != 0 and nums.size()==1)// if nums.size()==1 then if k is odd then it becomes empty \\n            return -1;\\n        if(k==1 and nums.size()>=2)return nums[1];\\n        priority_queue<int> pq;\\n       if( k > nums.size())\\n           return *max_element(nums.begin(), nums.end());\\n        else if(k==nums.size())\\n        {\\n             for(int i=0;i<k-1;i++)\\n            {\\n              pq.push(nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1844231,
                "title": "c-easy-detailed-explanation",
                "content": "- Either remove all k elements in the vector\\n- Either keep track of maximum in k - 1 elements and last operation is to put the element back in the element.\\n```cpp\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size(), ans = -1;\\n        if(n == 1 && (k & 1))\\n            return ans;\\n        if(n > k)\\n            ans = max(ans, nums[k]);\\n        for(int i = 0; i < n && i < k - 1; ++i)\\n            ans = max(ans, nums[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size(), ans = -1;\\n        if(n == 1 && (k & 1))\\n            return ans;\\n        if(n > k)\\n            ans = max(ans, nums[k]);\\n        for(int i = 0; i < n && i < k - 1; ++i)\\n            ans = max(ans, nums[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844225,
                "title": "python-solution-by-analyzing-all-cases",
                "content": "**Basically we want to remove as many values as possible to maximize the value of number that we can add, yet have atleast one/more operations in hand to add these values back into nums as out topmost element. Otherwise we would have had the largest value but we won\\'t be able to add it.**\\n1. **Case 1 `k == 0`:** Since no removal is possible, just return the top of nums.\\n2. **Case 2 `k == 1`:** One removal allowed but the size of array might be 1 in which case we have and empty list thus return -1. If len(nums) > 1 then return 1st value since 0th index value was removed\\n3. **Case 3 `n == 1`:** Since size of nums is 1. If even number of operations are allowed then we will have a non empty list and empty is k is odd.\\n4. **Case 4 IMPORTANT CASE `k-n-1 >= 0`:** It means that k is sufficiently large enough that we can remove all the elements from the array, reserve one operation to add the largest of all the values removed so far, and still be left with 0 or more operations. Since we already reserved one operation for adding the largest value removed into the array as its top most element. This simply return the maximum value from nums.\\n5. **Case 5 `n == k`:** We cannot remove all values since then we will be left with no operation to do and an empty array which is not the best approach. We remove k-1 numbers and add the maximum from those.\\n6. **Case 6 `n > k`:** We can either remove k-1 numbers and then add the largest values from those or we can remove all k numbers and then let the top most remaining value in nums be the top most value of nums.\\n\\n```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        if k == 0:\\n            return nums[0]\\n        if k == 1:\\n            if n == 1:\\n                return -1\\n            else:\\n                return nums[1]\\n        if n == 1:\\n            if k % 2 != 0:\\n                return -1\\n            else:\\n                return nums[0]\\n        if k - n - 1 >= 0:\\n            return max(nums)\\n        if n == k:\\n            return max(nums[0:k - 1])\\n        if n > k:\\n            return max(max(nums[0:k - 1]), nums[k])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        if k == 0:\\n            return nums[0]\\n        if k == 1:\\n            if n == 1:\\n                return -1\\n            else:\\n                return nums[1]\\n        if n == 1:\\n            if k % 2 != 0:\\n                return -1\\n            else:\\n                return nums[0]\\n        if k - n - 1 >= 0:\\n            return max(nums)\\n        if n == k:\\n            return max(nums[0:k - 1])\\n        if n > k:\\n            return max(max(nums[0:k - 1]), nums[k])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844203,
                "title": "very-esy-to-understand-c-o-n-solution-using-stack",
                "content": "\\n\\n         int x=k;\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n        bool temp=true;\\n        if(k>n){\\n            x=n+1;\\n            temp=false;\\n        }\\n       stack<int>st;\\n        for(int i=0;i<x-1;i++){\\n            maxi=max(maxi,nums[i]);\\n            st.push(nums[i]);\\n        }\\n        if(n==1 and k%2==1){\\n            maxi=-1;\\n        }\\n        else if(x<n){\\n            maxi=max(nums[x],maxi);\\n        }\\n        return maxi;",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "\\n\\n         int x=k;\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n        bool temp=true;\\n        if(k>n){\\n            x=n+1;\\n            temp=false;\\n        }\\n       stack<int>st;\\n        for(int i=0;i<x-1;i++){\\n            maxi=max(maxi,nums[i]);\\n            st.push(nums[i]);\\n        }\\n        if(n==1 and k%2==1){\\n            maxi=-1;\\n        }\\n        else if(x<n){\\n            maxi=max(nums[x],maxi);\\n        }\\n        return maxi;",
                "codeTag": "Unknown"
            },
            {
                "id": 3101410,
                "title": "simple-and-easy-java-solution",
                "content": "# Intuition\\nThere can be three cases when \\n1)k>arr.length\\n2)k==arr.length\\n3)k<arr.length\\n\\n\\n# Approach\\n1)When k>len\\nThere can be two possibilities in this:\\n\\n1.When the array has only 1 element then if k is even return max element else when k is odd the only element is removed and array left is empty return -1\\n\\n2.When more than one element is there then we can simply return the max of the array element\\n\\n2)When k==len then we need to find the max from arr[k-1]\\n\\n3)When k<len then we need to find max of max(arr[k-1]) and arr[k]\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(k-1)\\n\\n# Code\\n```\\n/*There can be three cases when \\n1)k>arr.length\\n2)k==arr.length\\n3)k<arr.length\\n*/\\nclass Solution {\\n    //defining a function to return the max from the array\\n    public int max(int[] arr)\\n    {\\n        int m=Integer.MIN_VALUE;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if (arr[i]>m)\\n            m=arr[i];\\n        }\\n        return m;\\n    }\\n    public int maximumTop(int[] nums, int k) {\\n        int len=nums.length;\\n        /*1)When k>len\\n        there can be two possibilities in this\\n        1.When the array has only 1 element then if k is even return max element else when k is odd the only element is removed and array left is empty return -1\\n        2.When more than one element is there then we can simply return the max of the array element*/\\n        if (k>len)\\n        {\\n            if(len==1)\\n            {\\n                if(k%2!=0)\\n                return -1;\\n            }\\n            return max(nums);\\n        }\\n        /*When k==len then we need to find the max from arr[k-1]*/\\n        else if(k==len)\\n        {\\n            int temp[]=new int[k-1];\\n            for(int i=0;i<k-1;i++)\\n            temp[i]=nums[i];\\n            if (temp.length!=0)\\n            return max(temp);\\n        }\\n        /*When k<len then we need to find max of max(arr[k-1]) and arr[k]*/\\n        else\\n        {\\n            if (k==0)\\n            return nums[0];\\n            else\\n            {\\n            int temp[]=new int[k-1];\\n            for(int i=0;i<k-1;i++)\\n            temp[i]=nums[i];\\n            int m=max(temp);\\n            return Math.max(m,nums[k]);\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*There can be three cases when \\n1)k>arr.length\\n2)k==arr.length\\n3)k<arr.length\\n*/\\nclass Solution {\\n    //defining a function to return the max from the array\\n    public int max(int[] arr)\\n    {\\n        int m=Integer.MIN_VALUE;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if (arr[i]>m)\\n            m=arr[i];\\n        }\\n        return m;\\n    }\\n    public int maximumTop(int[] nums, int k) {\\n        int len=nums.length;\\n        /*1)When k>len\\n        there can be two possibilities in this\\n        1.When the array has only 1 element then if k is even return max element else when k is odd the only element is removed and array left is empty return -1\\n        2.When more than one element is there then we can simply return the max of the array element*/\\n        if (k>len)\\n        {\\n            if(len==1)\\n            {\\n                if(k%2!=0)\\n                return -1;\\n            }\\n            return max(nums);\\n        }\\n        /*When k==len then we need to find the max from arr[k-1]*/\\n        else if(k==len)\\n        {\\n            int temp[]=new int[k-1];\\n            for(int i=0;i<k-1;i++)\\n            temp[i]=nums[i];\\n            if (temp.length!=0)\\n            return max(temp);\\n        }\\n        /*When k<len then we need to find max of max(arr[k-1]) and arr[k]*/\\n        else\\n        {\\n            if (k==0)\\n            return nums[0];\\n            else\\n            {\\n            int temp[]=new int[k-1];\\n            for(int i=0;i<k-1;i++)\\n            temp[i]=nums[i];\\n            int m=max(temp);\\n            return Math.max(m,nums[k]);\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011593,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind maximum of from first k-1 elements(save 1 last step for placing back the maximum element)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind maximum of from first k-1 elements(save 1 last step for placing back the maximum element).\\nIf(steps are greater than nums size) return maximum element;\\nElse{\\n      we now have a maximum element till index k-1 and 1 step with remaining array\\n      we want maximum element, we can either place the maximum found element back on pile in last step or remove element from last step(if stack does not get empty after removing another element) as the maximum we are holding might be less than element we get at top of pile after removing one more element from remaining pile\\n      \\n     Evaluate both scenarios and return maximum element \\n \\n}\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1 && k%2!=0) return -1;\\n        else if(nums.size()==1 && k%2==0) return nums[0];  \\n        if(k==0) return nums[0];\\n        if(k==1) return nums[1];\\n        \\n        int maximum=0;\\n        int i=0;\\n        for(;i<k-1;i++){\\n            if(i==nums.size()){\\n                break;\\n            }\\n            maximum=max(maximum,nums[i]);\\n        }\\n        if(i<nums.size()-1){\\n            i++;\\n            if(nums[i]>maximum) return nums[i];\\n        }\\n        return maximum;\\n        \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1 && k%2!=0) return -1;\\n        else if(nums.size()==1 && k%2==0) return nums[0];  \\n        if(k==0) return nums[0];\\n        if(k==1) return nums[1];\\n        \\n        int maximum=0;\\n        int i=0;\\n        for(;i<k-1;i++){\\n            if(i==nums.size()){\\n                break;\\n            }\\n            maximum=max(maximum,nums[i]);\\n        }\\n        if(i<nums.size()-1){\\n            i++;\\n            if(nums[i]>maximum) return nums[i];\\n        }\\n        return maximum;\\n        \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543792,
                "title": "java-100-faster-with-explanation",
                "content": "*Please upvote if you find this solution useful.*\\n\\n**Intuition:**\\n1. This looked like a greedy problem for me because we are looking for the maximum value after a sequence of operations\\n2. So I tried to figure out all the possible patterns. The different patterns I could see were,\\n\\ti. No moves possible case.\\n\\tii. k > nums.length\\n\\tiii. k <= nums.length\\n3. The simplest pattern is \"No moves possible\". \\n\\ti. If nums.length is more than 1, we can take and put back the same number any number of times. So we will definitely have a solution. \\n\\tii. When k is even also, we can take and put back the same item, resulting in some value.\\n\\tiii. So, the only case where we will return -1 is when there is only 1 number in the array and the k value is odd.\\n4. When k > nums.length, we can return the maximum value as we can cycle and bring the maximum value to the top.\\n5. When k <= nums.length is very similar to the previous case except we can\\'t bring the kth element to the top. \\n\\ti. This is because we need `k - 1` moves to reach the kth element and in the last move, we either have to pick the element or keep another element on top. \\n\\tii. So, we find the maximum value in the first `k + 1` elements.\\n6. Time complexity: `O(n)` and space complexity: `O(1)`.\\n\\t\\n**Code**\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if(k % 2 == 1 && nums.length == 1) return -1;\\n        int ans = -1;\\n        if(k > nums.length){\\n            for(int num : nums) ans = Math.max(ans, num);\\n        }\\n        else{\\n            for(int i = 0; i < k - 1; i++){\\n                ans = Math.max(ans, nums[i]);\\n            }\\n            if(k < nums.length) ans = Math.max(ans, nums[k]);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nNote: We can remove the if-else conditions and make the code shorter but I wanted to upload a version that is similar to my explanation and is easy to understand.",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if(k % 2 == 1 && nums.length == 1) return -1;\\n        int ans = -1;\\n        if(k > nums.length){\\n            for(int num : nums) ans = Math.max(ans, num);\\n        }\\n        else{\\n            for(int i = 0; i < k - 1; i++){\\n                ans = Math.max(ans, nums[i]);\\n            }\\n            if(k < nums.length) ans = Math.max(ans, nums[k]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445878,
                "title": "java-return-max-or-next",
                "content": "\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        \\n        int mx = -1;\\n        int n = nums.length;\\n        int next = -1;\\n        \\n        if(k < n) next = nums[k];\\n        if(n == 1 && k % 2 == 1) return mx;\\n        \\n        int s = Math.min(k - 1, n);\\n        for(int i = 0; i < s; i++){\\n            mx = Math.max(nums[i], mx);\\n        }\\n        return Math.max(mx, next);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        \\n        int mx = -1;\\n        int n = nums.length;\\n        int next = -1;\\n        \\n        if(k < n) next = nums[k];\\n        if(n == 1 && k % 2 == 1) return mx;\\n        \\n        int s = Math.min(k - 1, n);\\n        for(int i = 0; i < s; i++){\\n            mx = Math.max(nums[i], mx);\\n        }\\n        return Math.max(mx, next);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884610,
                "title": "checking-top-k-elements",
                "content": "**Approach**\\nCheck for all the elements in ``arr`` if it is possible to make it the top-most element in the array in exactly ``k`` number of steps i.e. moves. And then find the maximum of all the possible candidates.\\n \\n**How to check if it is possible to make an element the top-most element? (Also a Proof)**\\nLet\\'s see how can we use the given ``k`` moves to make an element ``arr[i]`` the top most element.\\n\\n> To reach any element ``arr[i]`` in the ``arr``, we have to first use ``i`` moves because we have to remove the first ``i`` number of elements from the array and if ``i`` is greater than ``k`` then we cannot reach it.\\n\\nThis leaves us with ``k - i`` moves remaining.\\n\\nIf we have reached the element ``arr[i]`` then the following cases arise.\\n\\n**Case 1** - ``k - i == 0``. No moves are available. The element ``arr[i]`` is already at the top and hence a candidate. \\n\\n**Case 2** - ``k - i == 1``. We cannot make ``arr[i]`` the top-most element since a ``pop`` operation will remove ``arr[i]`` from the stack and a ``push from pile`` operation will change the top-most element.\\n\\n**Case 3** - ``k - i`` is even. \\n> In this case, for the element ``arr[i]`` we can follow the sequence ``[(pop, push), (pop, push), ..., (pop, push)]`` and in each atomic operation ``(pop, push)`` we end up with the current element on top.\\n> This way we exhaust all our ``k - i``moves and make the element ``arr[i]`` the top-most element in exactly ``k`` steps and hence we can include it in our candidates.\\n\\n**Case 4** - ``k - i`` is odd. \\n> In this case, if we follow the ``(pop, push)`` sequence the last operation will always be a ``pop`` operation which will fail our objective.\\n> \\n> *So, what to do in this case?* \\n> Now, the operation ``If there are one or more removed elements, add any one of them back onto the pile. This element becomes the new topmost element`` given in the problem comes in handy.\\n>\\n> Let\\'s first use the extra moves by following the sequence ``[(pop, push), (pop, push), ..., (pop, push)]`` for the current element ``arr[i]`` till there are ``3`` moves remaining.\\n> \\n> And hence the following sub-cases arise:-\\n> **Case 4.a** - If we already have some elements in the pile i.e. the elements we removed before to reach this element.\\n> > Then follow the sequence``\"pop arr[i]\", \"push from pile\"`` and then ``\"push arr[i]\"``. The current element ``arr[i]`` will end up being on the top.\\n> > **Note** - The operation \"Push from pile\" pushes any element ``arr[j]`` where ``i != j``.\\n> \\n> **Case 4.b** - What if there are no elements in the pile and ``arr[i]`` is not the last element?\\n> > Then follow the sequence``\"pop arr[i]\", \"pop arr[i + 1]\"`` and then ``\"push arr[i]\"``. The current element ``arr[i]`` will end up being on the top.\\n>  \\n> In any other case, we cannot make the current element ``arr[i]`` the top-most and hence it will be exculded from the candidature.\\n\\nNow, compute the maximum from all the candidates.\\n\\n**Code**\\n```cpp\\nint maximumTop(vector<int>& nums, int k) {\\n\\tint n = nums.size();\\n\\t\\n\\tint res = -1, curr, moves;\\n\\tfor(int i = 0; i < n && k - i >= 0; i++) {\\n\\t\\tmoves = k - i;\\n\\t\\tcurr = nums[i];\\n            \\n\\t\\tif(moves > 0) {\\n\\t\\t\\t// Even Case\\n\\t\\t\\tif(moves%2 == 0(\\n\\t\\t\\t\\tmoves = 0;\\n\\t\\t\\t// Odd Case\\n\\t\\t\\telse if(moves != 1 && (n - i - 1 >= 1 || i))\\n\\t\\t\\t\\tmoves = 0;\\n\\t\\t\\t// All Other Cases\\n\\t\\t\\telse\\n\\t\\t\\t\\tmoves = -1;\\n\\t\\t}\\n            \\n\\t\\tif(moves == 0)\\n\\t\\t\\tres = max<int>(res, curr);\\n\\t}\\n        \\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```cpp\\nint maximumTop(vector<int>& nums, int k) {\\n\\tint n = nums.size();\\n\\t\\n\\tint res = -1, curr, moves;\\n\\tfor(int i = 0; i < n && k - i >= 0; i++) {\\n\\t\\tmoves = k - i;\\n\\t\\tcurr = nums[i];\\n            \\n\\t\\tif(moves > 0) {\\n\\t\\t\\t// Even Case\\n\\t\\t\\tif(moves%2 == 0(\\n\\t\\t\\t\\tmoves = 0;\\n\\t\\t\\t// Odd Case\\n\\t\\t\\telse if(moves != 1 && (n - i - 1 >= 1 || i))\\n\\t\\t\\t\\tmoves = 0;\\n\\t\\t\\t// All Other Cases\\n\\t\\t\\telse\\n\\t\\t\\t\\tmoves = -1;\\n\\t\\t}\\n            \\n\\t\\tif(moves == 0)\\n\\t\\t\\tres = max<int>(res, curr);\\n\\t}\\n        \\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1849230,
                "title": "explained-greedy-approach-with-comments-linear-time-complexity-c-clean-code",
                "content": "\\n*Note : Logic is explained in detail along with code using comments.*\\n# Code : \\n\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n\\t\\t// Case : If we cannot remove element then return first one\\n        if(k == 0) return nums[0];\\n\\t\\t\\n\\t\\t// Case : If only one element is present\\n        if(n == 1) {\\n\\t\\t\\t// Case : If we have to remove just one element, \\n\\t\\t\\t// then array would be empty and hence return -1\\n            if(k == 1) return -1;\\n\\t\\t\\t\\n\\t\\t\\t// In order to get top element by performing 2 operation, \\n\\t\\t\\t// we need even number of steps. \\n\\t\\t\\t// Else if we have odd number of moves available, return -1\\n            if(k > n) {\\n                if(k&1) return -1;\\n                else return nums[0];\\n            }\\n        }\\n        \\n\\t\\t// maxVal : stores maximum value that we encounter till some index\\n\\t\\t// lastIndex : stores the last index till we run out of moves\\n        int maxVal = -1, lastIndex = -1;\\n        \\n        for(int i=0; i<n; i++) {\\n\\t\\t\\t// Break when we have one move available\\n\\t\\t\\t// This is due to the fact that, using this last move\\n\\t\\t\\t// we can again put maximum element as topmost element.\\n            if(k-1 == 0) {\\n                lastIndex = i;\\n                break;\\n            }\\n\\t\\t\\t// Update maximum value and decrement number of moves available.\\n            maxVal = max(maxVal, nums[i]);\\n            k--;\\n        }\\n        \\n\\t\\t// If next element that is after lastIndex is greater than maxVal,\\n\\t\\t// then we can remove element at lastIndex. And get maximum topmost element\\n\\t\\t// Or else we put element with maxVal again as topmost element\\n\\t\\t// using our last move available.\\n        if(index >= 0) maxVal = max(maxVal, nums[lastIndex+1]);\\n        \\n        return maxVal;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(N)`\\n* Space : `O(1)`\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n\\t\\t// Case : If we cannot remove element then return first one\\n        if(k == 0) return nums[0];\\n\\t\\t\\n\\t\\t// Case : If only one element is present\\n        if(n == 1) {\\n\\t\\t\\t// Case : If we have to remove just one element, \\n\\t\\t\\t// then array would be empty and hence return -1\\n            if(k == 1) return -1;\\n\\t\\t\\t\\n\\t\\t\\t// In order to get top element by performing 2 operation, \\n\\t\\t\\t// we need even number of steps. \\n\\t\\t\\t// Else if we have odd number of moves available, return -1\\n            if(k > n) {\\n                if(k&1) return -1;\\n                else return nums[0];\\n            }\\n        }\\n        \\n\\t\\t// maxVal : stores maximum value that we encounter till some index\\n\\t\\t// lastIndex : stores the last index till we run out of moves\\n        int maxVal = -1, lastIndex = -1;\\n        \\n        for(int i=0; i<n; i++) {\\n\\t\\t\\t// Break when we have one move available\\n\\t\\t\\t// This is due to the fact that, using this last move\\n\\t\\t\\t// we can again put maximum element as topmost element.\\n            if(k-1 == 0) {\\n                lastIndex = i;\\n                break;\\n            }\\n\\t\\t\\t// Update maximum value and decrement number of moves available.\\n            maxVal = max(maxVal, nums[i]);\\n            k--;\\n        }\\n        \\n\\t\\t// If next element that is after lastIndex is greater than maxVal,\\n\\t\\t// then we can remove element at lastIndex. And get maximum topmost element\\n\\t\\t// Or else we put element with maxVal again as topmost element\\n\\t\\t// using our last move available.\\n        if(index >= 0) maxVal = max(maxVal, nums[lastIndex+1]);\\n        \\n        return maxVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846662,
                "title": "c-no-stack-no-queue-85-faster",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    int maximumTop(vector<int>& nums, int k)\\n    {\\n        if(nums.size() == 1 && k%2 == 1) return -1;\\n        else if(nums.size() == 1 && k%2 == 0) return nums[0];\\n        if(k==0) return nums[0];\\n        if(k > nums.size())\\n        {\\n            int maxi = INT_MIN;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                maxi = max(maxi,nums[i]);\\n            }\\n            return maxi;\\n        }\\n        else if(k == nums.size())\\n        {\\n            int maxi = INT_MIN;\\n            for(int i=0;i<nums.size()-1;i++)\\n            {\\n                maxi = max(maxi,nums[i]);\\n            }\\n            return maxi;\\n        }\\n        else\\n        {\\n            int maxi = INT_MIN;\\n            int m=0;\\n            while(m < k-1)\\n            {\\n                maxi = max(maxi,nums[m++]);\\n            }\\n            return max(maxi,nums[k]);\\n        }\\n        return -1;\\n         \\n    }\\n};\\n\\n#IF THIS CODE IS HELPUL FOR U THEN PLEASE UPVOTE !!!\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int maximumTop(vector<int>& nums, int k)\\n    {\\n        if(nums.size() == 1 && k%2 == 1) return -1;\\n        else if(nums.size() == 1 && k%2 == 0) return nums[0];\\n        if(k==0) return nums[0];\\n        if(k > nums.size())\\n        {\\n            int maxi = INT_MIN;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                maxi = max(maxi,nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1845511,
                "title": "c-short-crisp-code-greedy-approach-linear-time-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k%2!=0 && nums.size()==1) return -1;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<k-1 && i<nums.size();i++) maxi=max(maxi,nums[i]);\\n        if(k<nums.size()) maxi=max(maxi,nums[k]);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k%2!=0 && nums.size()==1) return -1;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<k-1 && i<nums.size();i++) maxi=max(maxi,nums[i]);\\n        if(k<nums.size()) maxi=max(maxi,nums[k]);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844751,
                "title": "c-time-o-1-explained",
                "content": "1. Base cases and k>=n\\n\\ta. If nums size is 1 and operations are odd then after operations nums will be empty so return -1.\\n\\tb. If no.s of operations are 0 or 1 then return 0th or 1st element only as no push back will be done from popped elements. \\n\\tc. If no.s of operations are equal to size of nums then max element in nums.size() -1  will be the result as we will pop k-1 elements and push max in last operation.\\n2. If k<n\\n\\ta. Result will be in first k+1 elements only i.e. max(nums[k],max(nums[0] to nums[k-1])) since if kth element is max then we will do k deletions only or if any other element is max then we do deletion till max let say m deletions and then k-m-1 push/pop alternate operation of any number and lastly push max on top. \\n\\t\\nAssuming time to find max using *max_element is constant. TC: O(1)\\n\\nPlease consider upvote if you like the solution \\n```\\nint maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if((n==1) && (k%2!=0))\\n            return -1;\\n        else if(k==0 || k==1)\\n            return nums[k];\\n        else if(k==n)\\n            return *max_element(nums.begin(),nums.begin()+n-1);\\n        else if(k>n)\\n            return *max_element(nums.begin(),nums.begin()+n);\\n        return max(*max_element(nums.begin(),nums.begin()+k-1),nums[k]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if((n==1) && (k%2!=0))\\n            return -1;\\n        else if(k==0 || k==1)\\n            return nums[k];\\n        else if(k==n)\\n            return *max_element(nums.begin(),nums.begin()+n-1);\\n        else if(k>n)\\n            return *max_element(nums.begin(),nums.begin()+n);\\n        return max(*max_element(nums.begin(),nums.begin()+k-1),nums[k]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844390,
                "title": "c-simple-solution-with-comments-easy-to-understand",
                "content": "The below code is explained with approach and mindset behind the approach.\\nPlease go through the comments. Fell free to ping me if any queries .\\nThis was weekly contest 284 question.\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k%2!=0&&nums.size()==1)//coner case where u will end up with empty array.\\n            return -1;\\n        if(k==1&&nums.size()>1)//case where k=1 so kth element is largest as all u can do is remove element i=0.\\n            return nums[1];\\n        if(k==0)                //if no moves given then u just return the 0th index.\\n            return nums[0];\\n        int max=INT_MIN;\\n        if(k>nums.size())       //condition when moves greater then the size of nums u just find the largetest element and return that.\\n        {\\n           max= *max_element (nums.begin(),nums.end());\\n        }\\n        else\\n        { max= *max_element (nums.begin(),nums.begin()+k-1); // when moves<= nums size\\n                                                            //then we have to find max form (0 to k-2)th index both included.                                                                           //as one move will be required to put the max back at top. \\n            if(nums[k]>max)    //check if the kth element is greater then your current max\\n                max=nums[k];   //Then make nums[k]= max as then u would remove all the elements till k-1 index.\\n        }\\n        return max;\\n    }\\n};\\n```\\nIf you like the solution a upvote is appreciated.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k%2!=0&&nums.size()==1)//coner case where u will end up with empty array.\\n            return -1;\\n        if(k==1&&nums.size()>1)//case where k=1 so kth element is largest as all u can do is remove element i=0.\\n            return nums[1];\\n        if(k==0)                //if no moves given then u just return the 0th index.\\n            return nums[0];\\n        int max=INT_MIN;\\n        if(k>nums.size())       //condition when moves greater then the size of nums u just find the largetest element and return that.\\n        {\\n           max= *max_element (nums.begin(),nums.end());\\n        }\\n        else\\n        { max= *max_element (nums.begin(),nums.begin()+k-1); // when moves<= nums size\\n                                                            //then we have to find max form (0 to k-2)th index both included.                                                                           //as one move will be required to put the max back at top. \\n            if(nums[k]>max)    //check if the kth element is greater then your current max\\n                max=nums[k];   //Then make nums[k]= max as then u would remove all the elements till k-1 index.\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844385,
                "title": "python-9-lines",
                "content": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1:\\n            return -1 if k % 2 == 1 else nums[0]\\n        if k <= 1:\\n            return nums[k]\\n        if k < len(nums):\\n            return max(max(nums[:k-1]), nums[k])\\n        if k < len(nums) + 2: \\n            return max(nums[:k-1])\\n        return max(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1:\\n            return -1 if k % 2 == 1 else nums[0]\\n        if k <= 1:\\n            return nums[k]\\n        if k < len(nums):\\n            return max(max(nums[:k-1]), nums[k])\\n        if k < len(nums) + 2: \\n            return max(nums[:k-1])\\n        return max(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844277,
                "title": "c-greedy-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& arr, int k) {\\n        \\n        if(arr.size()==1 and k==0){\\n            return arr[0];\\n        }\\n        \\n        if(arr.size()==1 and k%2){\\n            return -1;\\n        }\\n        \\n        if(k==0){\\n            return arr[0];\\n        }\\n        \\n        int res=0;\\n        \\n        if(arr.size()<k){\\n            for(auto &x:arr){\\n                res=max(x,res);\\n            }\\n            return res;\\n        }\\n        \\n        reverse(arr.begin(),arr.end());\\n        \\n        while(k-1){\\n            res=max(res,arr.back());\\n            arr.pop_back();\\n            k--;\\n        }\\n        arr.pop_back();\\n        \\n        if(arr.size()==0){\\n            return res;\\n        }\\n        \\n        res=max(res,arr.back());\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& arr, int k) {\\n        \\n        if(arr.size()==1 and k==0){\\n            return arr[0];\\n        }\\n        \\n        if(arr.size()==1 and k%2){\\n            return -1;\\n        }\\n        \\n        if(k==0){\\n            return arr[0];\\n        }\\n        \\n        int res=0;\\n        \\n        if(arr.size()<k){\\n            for(auto &x:arr){\\n                res=max(x,res);\\n            }\\n            return res;\\n        }\\n        \\n        reverse(arr.begin(),arr.end());\\n        \\n        while(k-1){\\n            res=max(res,arr.back());\\n            arr.pop_back();\\n            k--;\\n        }\\n        arr.pop_back();\\n        \\n        if(arr.size()==0){\\n            return res;\\n        }\\n        \\n        res=max(res,arr.back());\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844250,
                "title": "c-all-cases-handled",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0) return nums[0];\\n        int n = nums.size();\\n        if(n==1){\\n            if(k&1) return -1;\\n            else   return nums[0];\\n        }\\n        if(k<n) {\\n            if(k==1) return nums[1];\\n            if(k==2) return max(nums[0],nums[2]);\\n            return max(*(max_element(nums.begin(),nums.begin() + k-1)) , nums[k]);\\n        }\\n        if(k==n){\\n            return *(max_element(nums.begin(),nums.begin() + k-1));\\n        }\\n        return *(max_element(nums.begin(),nums.begin()+n));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0) return nums[0];\\n        int n = nums.size();\\n        if(n==1){\\n            if(k&1) return -1;\\n            else   return nums[0];\\n        }\\n        if(k<n) {\\n            if(k==1) return nums[1];\\n            if(k==2) return max(nums[0],nums[2]);\\n            return max(*(max_element(nums.begin(),nums.begin() + k-1)) , nums[k]);\\n        }\\n        if(k==n){\\n            return *(max_element(nums.begin(),nums.begin() + k-1));\\n        }\\n        return *(max_element(nums.begin(),nums.begin()+n));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844222,
                "title": "2202-easy-to-understand-edge-case-soln-maximize-the-topmost-element-after-k-moves",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& A, int k) {\\n        int N = A.size();\\n        if (k == 0) return N >= 1 ? A[0] : -1; // if no moves allowed, return the topmost element if any\\n        if (k == 1) return N == 1 ? -1 : A[1]; // if only one move is allowed, we can only remove the topmost element\\n        if (N == 1) return k % 2 == 0 ? A[0] : -1; // if `N == 1`, we can return the topmost element if `k` is a even number (keep removing the topmost element and adding it back).\\n        int mx = *max_element(begin(A), begin(A) + min(k - 1, N)); // we can take `k-1` elements and put back the largest one on the top\\n        if (k < N) mx = max(mx, A[k]); // If `k < N`, we can take all the topmost `k` elements and return the one left at the top\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& A, int k) {\\n        int N = A.size();\\n        if (k == 0) return N >= 1 ? A[0] : -1; // if no moves allowed, return the topmost element if any\\n        if (k == 1) return N == 1 ? -1 : A[1]; // if only one move is allowed, we can only remove the topmost element\\n        if (N == 1) return k % 2 == 0 ? A[0] : -1; // if `N == 1`, we can return the topmost element if `k` is a even number (keep removing the topmost element and adding it back).\\n        int mx = *max_element(begin(A), begin(A) + min(k - 1, N)); // we can take `k-1` elements and put back the largest one on the top\\n        if (k < N) mx = max(mx, A[k]); // If `k < N`, we can take all the topmost `k` elements and return the one left at the top\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844136,
                "title": "o-min-n-k-solution-c-multiple-cases-explanation",
                "content": "There are two possible ways to use the K operations. Consider 0-indexing for the array.\\n\\n1. you can remove the top (K-1) elements and use one operation to add back the max element of removed (K-1) elements.\\n2. you can remove the first K elements(0 to K-1) from the array and the maximum element can be a[K].\\n\\nBase Case: \\nk==0 -> first element is the anwer.\\nn==1 and k is odd -> array is always empty.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        // array size is atleast 1. (k==0)-> no element is removed.\\n        if(k==0)\\n            return nums[0];\\n        \\n        int n=nums.size();\\n        \\n        // if n==1 and k is odd then the array will always be empty.\\n        if(n==1 and k%2==1)\\n            return -1;\\n        \\n        \\n        int ans=-1;\\n        \\n        // assume the first k elements are removed. answer can be nums[k]. \\n        if(k<n)\\n            ans=nums[k];\\n\\n        k--;\\n        \\n        // find the maximum of the first (K-1) elements.\\n        int maxi=INT_MIN;\\n        for(int i=0;i<k and i<n;i++)\\n            maxi=max(maxi,nums[i]);\\n        \\n        // maximum of (K-1) elements can be the answer.\\n        if(maxi!=INT_MIN)\\n            ans=max(ans,maxi);\\n        \\n        return ans;\\n        \\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        // array size is atleast 1. (k==0)-> no element is removed.\\n        if(k==0)\\n            return nums[0];\\n        \\n        int n=nums.size();\\n        \\n        // if n==1 and k is odd then the array will always be empty.\\n        if(n==1 and k%2==1)\\n            return -1;\\n        \\n        \\n        int ans=-1;\\n        \\n        // assume the first k elements are removed. answer can be nums[k]. \\n        if(k<n)\\n            ans=nums[k];\\n\\n        k--;\\n        \\n        // find the maximum of the first (K-1) elements.\\n        int maxi=INT_MIN;\\n        for(int i=0;i<k and i<n;i++)\\n            maxi=max(maxi,nums[i]);\\n        \\n        // maximum of (K-1) elements can be the answer.\\n        if(maxi!=INT_MIN)\\n            ans=max(ans,maxi);\\n        \\n        return ans;\\n        \\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3645657,
                "title": "o-n-prefix-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(!k) return nums[0];\\n\\n        int n = nums.size();\\n        int mx = 0;\\n        vector<int> prefix;\\n        for(int i : nums) {\\n            mx = max(mx, i);\\n            prefix.push_back(mx);\\n        }\\n        \\n        if(k > n) {\\n            if(n == 1) return k % 2 ? -1 : mx;\\n            return mx;\\n        }\\n        if(k == 1) return n == 1 ? -1 : nums[1];\\n        if(k == n) return prefix[n - 2];\\n        return max(prefix[k - 2], nums[k]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(!k) return nums[0];\\n\\n        int n = nums.size();\\n        int mx = 0;\\n        vector<int> prefix;\\n        for(int i : nums) {\\n            mx = max(mx, i);\\n            prefix.push_back(mx);\\n        }\\n        \\n        if(k > n) {\\n            if(n == 1) return k % 2 ? -1 : mx;\\n            return mx;\\n        }\\n        if(k == 1) return n == 1 ? -1 : nums[1];\\n        if(k == n) return prefix[n - 2];\\n        return max(prefix[k - 2], nums[k]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135303,
                "title": "bruh",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn maximum_top(nums: Vec<i32>, k: i32) -> i32 {\\n        if k == 0 { return nums[0];}\\n        let k = k as usize;\\n        /* Edge Cases */\\n        match (nums.len(),k%2) {\\n            (1,0) => {return nums[0];},\\n            (1,1) => {return -1;},\\n            _ => ()\\n        };\\n        if k == 1 { return nums[1]; }\\n        /*           */\\n        *match k.cmp(&nums.len()) {\\n            std::cmp::Ordering::Equal => nums[..k-1].iter().max().unwrap(),\\n            std::cmp::Ordering::Greater => nums.iter().max().unwrap(),\\n            _ => if k == 2 { return nums[0].max(nums[2]); } else { nums[..k-1].iter().max().unwrap().max(&nums[k]) }            \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_top(nums: Vec<i32>, k: i32) -> i32 {\\n        if k == 0 { return nums[0];}\\n        let k = k as usize;\\n        /* Edge Cases */\\n        match (nums.len(),k%2) {\\n            (1,0) => {return nums[0];},\\n            (1,1) => {return -1;},\\n            _ => ()\\n        };\\n        if k == 1 { return nums[1]; }\\n        /*           */\\n        *match k.cmp(&nums.len()) {\\n            std::cmp::Ordering::Equal => nums[..k-1].iter().max().unwrap(),\\n            std::cmp::Ordering::Greater => nums.iter().max().unwrap(),\\n            _ => if k == 2 { return nums[0].max(nums[2]); } else { nums[..k-1].iter().max().unwrap().max(&nums[k]) }            \\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3012617,
                "title": "easy-cpp-using-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0)return nums[0];\\n        int ans=-1;\\n        if(k==1&&nums.size()==1)return -1;\\n        if(nums.size()==1 && k%2==1)return -1;\\n        if(k==1 && nums.size()>1)return nums[1];\\n        if(k>nums.size())\\n        {\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        else\\n        {\\n            queue<int>q;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                q.push(nums[i]);\\n            }\\n        \\n                int t=k-1;\\n                while(t>0)\\n                {\\n                    \\n                    ans=max(ans,q.front());\\n                    q.pop();\\n                    t--;\\n                    \\n                }\\n               if(q.size()>1)\\n               {\\n                   q.pop();\\n                    if(ans<q.front())\\n                    {\\n                        return q.front();\\n                    }\\n               }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0)return nums[0];\\n        int ans=-1;\\n        if(k==1&&nums.size()==1)return -1;\\n        if(nums.size()==1 && k%2==1)return -1;\\n        if(k==1 && nums.size()>1)return nums[1];\\n        if(k>nums.size())\\n        {\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        else\\n        {\\n            queue<int>q;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                q.push(nums[i]);\\n            }\\n        \\n                int t=k-1;\\n                while(t>0)\\n                {\\n                    \\n                    ans=max(ans,q.front());\\n                    q.pop();\\n                    t--;\\n                    \\n                }\\n               if(q.size()>1)\\n               {\\n                   q.pop();\\n                    if(ans<q.front())\\n                    {\\n                        return q.front();\\n                    }\\n               }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012104,
                "title": "c-greedy-easy-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    int maximumTop(vector<int>& nums, int k)\\n    {\\n        int n=nums.size();\\n        if(k==0)\\n            return nums[0];\\n        if(n==1) \\n        {\\n            if(k%2)\\n                return -1;\\n            else\\n                return nums[0];\\n        }\\n        if(k>n)\\n        {\\n            int maxele=0;\\n            for(auto num:nums)\\n                maxele=max(maxele,num);\\n            return maxele;\\n        }\\n        int ans=0;\\n        for(int i=0;i<k-1;i++)\\n            ans=max(ans,nums[i]);\\n        return max(ans,nums[k]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int maximumTop(vector<int>& nums, int k)\\n    {\\n        int n=nums.size();\\n        if(k==0)\\n            return nums[0];\\n        if(n==1) \\n        {\\n            if(k%2)\\n                return -1;\\n            else\\n                return nums[0];\\n        }\\n        if(k>n)\\n        {\\n            int maxele=0;\\n            for(auto num:nums)\\n                maxele=max(maxele,num);\\n            return maxele;\\n        }\\n        int ans=0;\\n        for(int i=0;i<k-1;i++)\\n            ans=max(ans,nums[i]);\\n        return max(ans,nums[k]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011417,
                "title": "runtime-72-ms-beats-100",
                "content": "\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code:\\n```\\nvar maximumTop = function (nums, k) {\\n    if (nums.length === 1 && k == 0) return nums;\\n    if (nums.length === 1 && k % 2 !== 0) return -1;\\n    let max = Math.max(...nums.slice(0, Math.abs(k - 1)));\\n    return max > nums[k] || nums[k] === undefined ? max : nums[k];\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/d273de51-9378-40a2-a2e0-928a6653b541_1673061803.0500512.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumTop = function (nums, k) {\\n    if (nums.length === 1 && k == 0) return nums;\\n    if (nums.length === 1 && k % 2 !== 0) return -1;\\n    let max = Math.max(...nums.slice(0, Math.abs(k - 1)));\\n    return max > nums[k] || nums[k] === undefined ? max : nums[k];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2638986,
                "title": "c-o-n-time-solution",
                "content": "**Note: Handling edge cases is tricky . You have to observe carefully.**\\n**C++ Code:**\\n\\n```\\n  int maximumTop(vector<int>& nums, int k) {\\n    int maxi = 0;\\n    int n = nums.size();\\n    if(k==1){\\n        if(n==1) return -1;\\n        return nums[1];\\n    }\\n    // edge case eg:- [18],k=3\\n    if(n==1 && k%2!=0) return -1;\\n        \\n    for(int i=0;i<=min(k-2,n-1);i++){\\n     maxi = max(maxi,nums[i]);   \\n    }\\n   // edge cases for example (k-1)th index element is the maximum till now \\n    if(k<n && maxi<nums[k])\\n     maxi = nums[k];\\n    return maxi;   \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int maximumTop(vector<int>& nums, int k) {\\n    int maxi = 0;\\n    int n = nums.size();\\n    if(k==1){\\n        if(n==1) return -1;\\n        return nums[1];\\n    }\\n    // edge case eg:- [18],k=3\\n    if(n==1 && k%2!=0) return -1;\\n        \\n    for(int i=0;i<=min(k-2,n-1);i++){\\n     maxi = max(maxi,nums[i]);   \\n    }\\n   // edge cases for example (k-1)th index element is the maximum till now \\n    if(k<n && maxi<nums[k])\\n     maxi = nums[k];\\n    return maxi;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2428865,
                "title": "c-easy-to-understand-short-and-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int i, m=-1;\\n        for(i=0; i<nums.size()-1; i++)\\n        {\\n            if(k==0)\\n                break;\\n            if(k==1)\\n            {\\n                m=max(m, nums[i+1]);\\n                break;\\n            }\\n            m = max(m, nums[i]);\\n            k--;\\n        }\\n        if(k>1 && m!=-1)\\n            m=max(m, nums[i]);\\n        else if(m==-1 && k%2==0)\\n            m = nums[0];\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int i, m=-1;\\n        for(i=0; i<nums.size()-1; i++)\\n        {\\n            if(k==0)\\n                break;\\n            if(k==1)\\n            {\\n                m=max(m, nums[i+1]);\\n                break;\\n            }\\n            m = max(m, nums[i]);\\n            k--;\\n        }\\n        if(k>1 && m!=-1)\\n            m=max(m, nums[i]);\\n        else if(m==-1 && k%2==0)\\n            m = nums[0];\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415548,
                "title": "very-easy-and-simple-java-solution-with-explanation",
                "content": "```\\n//First I checked if there is a single element in array. If that was true, in one move we will remove it, in second move we add it. So, if we have odd number of moves, we get empty array.\\n\\n//Then, we can do 2 things, either remove k-1 elements and add the maximum of them ( (K-1) + 1 moves ), or we can simply remove k elements, and element at kth index will be the top element. So, I found the maximum among all these elements.\\n\\n//But if k is more than n, we will remove all elements and add elements in remaining moves such that top element is maximum.\\n\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) \\n    {\\n        if(nums.length==1 && k%2==1) return -1;\\n        int max=0;\\n        for(int i=0;i<Math.min(k-1,nums.length);i++)\\n        {\\n            max=Math.max(max,nums[i]);\\n        }\\n        if(k<nums.length)\\n        {\\n            max=Math.max(max,nums[k]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//First I checked if there is a single element in array. If that was true, in one move we will remove it, in second move we add it. So, if we have odd number of moves, we get empty array.\\n\\n//Then, we can do 2 things, either remove k-1 elements and add the maximum of them ( (K-1) + 1 moves ), or we can simply remove k elements, and element at kth index will be the top element. So, I found the maximum among all these elements.\\n\\n//But if k is more than n, we will remove all elements and add elements in remaining moves such that top element is maximum.\\n\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) \\n    {\\n        if(nums.length==1 && k%2==1) return -1;\\n        int max=0;\\n        for(int i=0;i<Math.min(k-1,nums.length);i++)\\n        {\\n            max=Math.max(max,nums[i]);\\n        }\\n        if(k<nums.length)\\n        {\\n            max=Math.max(max,nums[k]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347020,
                "title": "c-5-lines-code-simple-code-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n       if(k==0) return nums[0];\\n        if(nums.size()==1 and k%2!=0) return -1;\\n        if(k==1) return nums[1];\\n        if(k>nums.size()) return *max_element(nums.begin(),nums.end());\\n        return max(*max_element(nums.begin(),nums.begin()+k-1),nums[k]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n       if(k==0) return nums[0];\\n        if(nums.size()==1 and k%2!=0) return -1;\\n        if(k==1) return nums[1];\\n        if(k>nums.size()) return *max_element(nums.begin(),nums.end());\\n        return max(*max_element(nums.begin(),nums.begin()+k-1),nums[k]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306317,
                "title": "python-one-pass-simple-solution",
                "content": "```py\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1 and k % 2 == 1:\\n            return -1\\n        res = -1\\n        for i, d in enumerate(nums):\\n            if i < k - 1 or i == k:\\n                res = max(res, d)\\n        return res\\n```\\n\\nWhen `len(nums) == 1`, we don\\'t have much flexibility, we have to keep moving the same element in and out.  This part is easy to comprehend.\\n\\nWith `k` moves, we can make any elements in `nums[:k-1]` on top.  We just move everything in `nums[:k-1]` out in `k-1` moves, then 1 more move to make the largest one in.\\nWe can also make `nums[k]` on top. We just move `nums[:k]` out in `k` moves. Then element `nums[k]` will be on top.\\nSo the answer will be `max(max(nums[:k-1]), nums[k])`.\\n",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1 and k % 2 == 1:\\n            return -1\\n        res = -1\\n        for i, d in enumerate(nums):\\n            if i < k - 1 or i == k:\\n                res = max(res, d)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212816,
                "title": "maximize-the-topmost-element-after-k-moves-java-easy-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n=nums.length;\\n        if(n==1 && k%2!=0){\\n            return -1;\\n        }\\n        \\n        if(k==1){\\n            return nums[k];\\n        }\\n        \\n        if(k<=n){\\n           \\n            int max=nums[0];\\n            \\n            for(int i=1;i<k-1;i++){\\n               max=Math.max(max,nums[i]); \\n            }\\n            \\n            if(n>k){\\n                max=Math.max(max,nums[k]);\\n            }\\n            \\n            return max;\\n        }else{\\n            \\n            int max=nums[0];\\n            \\n            for(int i=1;i<n;i++){\\n                max=Math.max(max,nums[i]);\\n            }\\n            \\n            return max;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n=nums.length;\\n        if(n==1 && k%2!=0){\\n            return -1;\\n        }\\n        \\n        if(k==1){\\n            return nums[k];\\n        }\\n        \\n        if(k<=n){\\n           \\n            int max=nums[0];\\n            \\n            for(int i=1;i<k-1;i++){\\n               max=Math.max(max,nums[i]); \\n            }\\n            \\n            if(n>k){\\n                max=Math.max(max,nums[k]);\\n            }\\n            \\n            return max;\\n        }else{\\n            \\n            int max=nums[0];\\n            \\n            for(int i=1;i<n;i++){\\n                max=Math.max(max,nums[i]);\\n            }\\n            \\n            return max;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114804,
                "title": "javascript-solution-greedy",
                "content": "I am not sure what to call this. Like the categories suggest, therer is some greedy aspect to it, but I think its more about taking care of different edge case scenarios we can have with nums.length and k.\\n\\n```\\nvar maximumTop = function(nums, k) {\\n    const MIN = Number.MIN_SAFE_INTEGER;\\n    const n = nums.length;\\n    \\n    if (k === 0) return nums[0];\\n    if (n === 1 && k % 2 == 1) return -1; // if there is only 1 item and k is odd, then the last move always will be removing the item\\n    if (k === 1) return nums[1];\\n    if (k > n) return Math.max(...nums);\\n    \\n    let max = MIN;\\n    \\n    for (let i = 1; i <= k - 1; ++i) {\\n        const num = nums[i - 1];\\n        max = Math.max(max, num);\\n    }\\n   \\n    if (k < n) return Math.max(max, nums[k]); // If there is 1 or more item than k in the array, then the two choices we have is to remove\\n                                              // k elements which will make the nums[k] be the topmost element or removing k - 1 elements\\n                                              // and putting the largest number from there back onto the pile.\\n    \\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumTop = function(nums, k) {\\n    const MIN = Number.MIN_SAFE_INTEGER;\\n    const n = nums.length;\\n    \\n    if (k === 0) return nums[0];\\n    if (n === 1 && k % 2 == 1) return -1; // if there is only 1 item and k is odd, then the last move always will be removing the item\\n    if (k === 1) return nums[1];\\n    if (k > n) return Math.max(...nums);\\n    \\n    let max = MIN;\\n    \\n    for (let i = 1; i <= k - 1; ++i) {\\n        const num = nums[i - 1];\\n        max = Math.max(max, num);\\n    }\\n   \\n    if (k < n) return Math.max(max, nums[k]); // If there is 1 or more item than k in the array, then the two choices we have is to remove\\n                                              // k elements which will make the nums[k] be the topmost element or removing k - 1 elements\\n                                              // and putting the largest number from there back onto the pile.\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018841,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if(nums.length==1)\\n        {\\n            if(k%2==0)\\n                return nums[0];\\n\\t\\t\\telse\\n                return -1;\\n        }\\n        if(k==1)\\n            return nums[1];\\n        int max=nums[0];\\n        for(int i=0;i<Math.min(k-1,nums.length);i++)\\n        {\\n            if(nums[i]>max)\\n                max=nums[i];\\n        }\\n        if(k<=nums.length-1&&nums[k]>max)\\n            return nums[k];\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if(nums.length==1)\\n        {\\n            if(k%2==0)\\n                return nums[0];\\n\\t\\t\\telse\\n                return -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1978816,
                "title": "python3-easy-solution-o-n-time-4-lines-of-code",
                "content": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums)==1 and k%2==1: return -1\\n        if k>len(nums): return max(nums)\\n        if k<len(nums): return max(nums[0:max(k-1,0)]+[nums[k]])\\n        return max(nums[0:max(k-1,0)])\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums)==1 and k%2==1: return -1\\n        if k>len(nums): return max(nums)\\n        if k<len(nums): return max(nums[0:max(k-1,0)]+[nums[k]])\\n        return max(nums[0:max(k-1,0)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884614,
                "title": "c-clean-code-stl",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        if(nums.size() == 1){\\n            \\n            if(k % 2 == 0)\\n                return nums[0];\\n            \\n            return -1;\\n        }\\n        \\n        if(k == 0){\\n            return nums[0];\\n        }\\n        \\n        if(k == 1){\\n            return nums[1]; \\n        }\\n        \\n        if(k > nums.size()){\\n            return *max_element(begin(nums), end(nums));\\n        }\\n        \\n        // now in this case we can maintain every element at top from 0 to k except element at k - 1\\n        // so we take maximum of every element till k - 1\\n        // and then we take maximum of ans with element at k\\n        //so in the end element at k - 1 is excluded\\n        \\n        int ans = *max_element(begin(nums), begin(nums) + k - 1);\\n        \\n        ans = max(ans, nums[k]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        if(nums.size() == 1){\\n            \\n            if(k % 2 == 0)\\n                return nums[0];\\n            \\n            return -1;\\n        }\\n        \\n        if(k == 0){\\n            return nums[0];\\n        }\\n        \\n        if(k == 1){\\n            return nums[1]; \\n        }\\n        \\n        if(k > nums.size()){\\n            return *max_element(begin(nums), end(nums));\\n        }\\n        \\n        // now in this case we can maintain every element at top from 0 to k except element at k - 1\\n        // so we take maximum of every element till k - 1\\n        // and then we take maximum of ans with element at k\\n        //so in the end element at k - 1 is excluded\\n        \\n        int ans = *max_element(begin(nums), begin(nums) + k - 1);\\n        \\n        ans = max(ans, nums[k]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880870,
                "title": "very-simple-python-solution",
                "content": "```\\nclass Solution(object):\\n    def maximumTop(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) == 1 and k % 2 == 1: return -1\\n        if k ==0: return nums[0]\\n        if k== 1: return nums[1]\\n        \\n        if k > len(nums): return max(nums)\\n        if k == len(nums): return max(nums[0:len(nums)-1])\\n        # k < len(nums)\\n        a = max(nums[0:k-1])\\n        if (a > nums[k]): \\n            return a\\n        else: \\n            return nums[k]\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumTop(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) == 1 and k % 2 == 1: return -1\\n        if k ==0: return nums[0]\\n        if k== 1: return nums[1]\\n        \\n        if k > len(nums): return max(nums)\\n        if k == len(nums): return max(nums[0:len(nums)-1])\\n        # k < len(nums)\\n        a = max(nums[0:k-1])\\n        if (a > nums[k]): \\n            return a\\n        else: \\n            return nums[k]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879277,
                "title": "c-beats-92-time-easy-solution-single-loop-explained-for-understanding",
                "content": "**Intuition**:\\n1. If `nums` contains only one element, odd number of steps cannot keep pile non-empty, so return `-1`.\\n2. Otherwise, do `k-1` pops. And note the max value = `m` among those values poped.\\n3. In the last step, either push the max value `m` or pop the `top` element of the pile, so that the resulting pile has greatest at the `top`.\\n\\n**Code**: \\n\\n```cpp\\nint maximumTop(vector<int>& nums, int k) {\\n\\tint m = -1;\\n\\n\\t// If there is only one element, odd number of steps cannot keep pile non-empty\\n\\tif(k % 2 && nums.size() == 1)\\n\\t\\treturn m;\\n\\n\\t// do a maximum of `k - 1` pops and choose max among them = `m`\\n\\tint top = 0;\\n\\twhile(k > 1 && top < nums.size())\\n\\t\\tm = max(nums[top++], m), --k;\\n\\n\\t// last step can be pop or push `m`\\n\\tif (k)\\n\\t\\tif(nums.size() - top > 1 && nums[top + 1] > m)\\n\\t\\t\\t++top; // pop, so max value is `nums[top]`\\n\\t\\telse\\n\\t\\t\\t--top; // push, implicitly, so max value is `m`\\n\\n\\t// Remaining steps, i.e. if k > 1 here are ignored as they can always be used to build the pile\\n\\t// with max element at top, regardless of whether k is even or odd. Only exception being if nums\\n\\t// contains one element which handled above.\\n\\n\\treturn max(nums[top], m);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint maximumTop(vector<int>& nums, int k) {\\n\\tint m = -1;\\n\\n\\t// If there is only one element, odd number of steps cannot keep pile non-empty\\n\\tif(k % 2 && nums.size() == 1)\\n\\t\\treturn m;\\n\\n\\t// do a maximum of `k - 1` pops and choose max among them = `m`\\n\\tint top = 0;\\n\\twhile(k > 1 && top < nums.size())\\n\\t\\tm = max(nums[top++], m), --k;\\n\\n\\t// last step can be pop or push `m`\\n\\tif (k)\\n\\t\\tif(nums.size() - top > 1 && nums[top + 1] > m)\\n\\t\\t\\t++top; // pop, so max value is `nums[top]`\\n\\t\\telse\\n\\t\\t\\t--top; // push, implicitly, so max value is `m`\\n\\n\\t// Remaining steps, i.e. if k > 1 here are ignored as they can always be used to build the pile\\n\\t// with max element at top, regardless of whether k is even or odd. Only exception being if nums\\n\\t// contains one element which handled above.\\n\\n\\treturn max(nums[top], m);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1868695,
                "title": "golang-o-n-time-o-1-mem-detail-explanation",
                "content": "Suppose that k < n (number of ints):\\n- You are never able to touch nums[k-1]\\n- Because: \\n  - Firstly, you have to remove [0..k-2] which is `k - 1` steps.\\n  - Then you have no choice in last step: must remove nums[k - 1]\\n- In this way, you only able to touch: \\n  - nums[k] (remove first k ints: [0..k-1]) \\n  - nums[0..k-2]\\n\\nFor k == n, you are never able to touch nums[n-1], same reason as above. In this case, you only able to touch nums[0..n-2]\\n\\nFor k > n, you can touch all ints.\\n\\nLets say `i` is the index of maximum ints that you can touch.\\n\\n- if `i == 0`:\\n\\t- if k is odd, then steps: remove nums[0] -> remove nums[1] -> add nums[0] -> remove nums[0] .. -> add nums[0]\\n\\t- if k is even, then steps: remove nums[0] -> add nums[0]\\n\\t- So, no matter what, we can have `nums[i]`\\n- i > 0 now. First you remove 0..i-1 ints, which is `i` steps:\\n\\t- Remaining steps is: `remain = k - i`\\n\\t- if `remain` is odd, then steps: remove nums[i] -> add nums[i-1] -> add nums[i] -> remove nums[i] -> .. -> add nums[i]\\n\\t- `remain` is even, then steps: remove nums[i] -> add nums[i] -> .. -> add nums[i]\\n\\nSo, no matter what, we are able to get max int among all ints that we can touch.\\n\\n```go\\nfunc maximumTop(nums []int, k int) int {\\n    n := len(nums)\\n    lastBit := k & 1\\n    \\n    if n == 1 {\\n        if lastBit == 1 { // k is odd\\n            return -1\\n        }\\n        return nums[0]\\n    }\\n    \\n    max := -1\\n    if k < n {\\n        max = nums[k]\\n        k--\\n    } else if k == n {\\n        k = n - 1\\n    } else {\\n        k = n\\n    }\\n    \\n    for i := 0; i < k; i++ {\\n        if nums[i] > max {\\n            max = nums[i]\\n        }\\n    }\\n    \\n    return max\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc maximumTop(nums []int, k int) int {\\n    n := len(nums)\\n    lastBit := k & 1\\n    \\n    if n == 1 {\\n        if lastBit == 1 { // k is odd\\n            return -1\\n        }\\n        return nums[0]\\n    }\\n    \\n    max := -1\\n    if k < n {\\n        max = nums[k]\\n        k--\\n    } else if k == n {\\n        k = n - 1\\n    } else {\\n        k = n\\n    }\\n    \\n    for i := 0; i < k; i++ {\\n        if nums[i] > max {\\n            max = nums[i]\\n        }\\n    }\\n    \\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1857172,
                "title": "c-check-3-cases",
                "content": "class Solution {\\npublic:\\n   ``` int maximumTop(vector<int>& nums, int k) {```\\n        \\n        int n = nums.size();\\n        \\n        // k is odd, cannot get a non empty pile \\n        \\n        if(n==1 and (k&1)) return -1;\\n        \\n        if(n > k){\\n            int mx=0;\\n            \\n            // answer is max(k\\'th element in pile , max(first k-1 elements))\\n            \\n            for(int i=0; i<k-1; i++) mx = max(mx, nums[i]);\\n            \\n            return max(mx, nums[k]);\\n        }\\n        else if(k > n){\\n            int mx=0;\\n            \\n            // answer is max of all pile elements\\n            \\n            for(int i=0; i<n; i++) mx = max(mx, nums[i]);\\n            \\n            return mx;\\n        }\\n        else{\\n            int mx=-1;\\n            \\n            //answer is max of first k-1 elements\\n            \\n            for(int i=0; i<k-1; i++) mx = max(mx, nums[i]);\\n            \\n            return mx;\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "``` int maximumTop(vector<int>& nums, int k) {```",
                "codeTag": "Unknown"
            },
            {
                "id": 1855591,
                "title": "c-inline-explanation-easy-solution-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size(); // To store the size of the vector\\n        if(n==1){\\n            if(k%2 == 0) // If k is even , we will perform alternative add and remove operations at last we end up with the number nums[0]\\n                return nums[0];\\n            else\\n                return -1; // If k is odd , we will perform alternative add and remove operations at last we end up with empty vector so we return -1\\n        }\\n        else if(n>=k){\\n        int val = INT_MIN;\\n\\t\\t/* We are finding the maximum value of k-2 (included) elements only , \\n\\t\\t    Since our vector is zero based indexing , we will find the K th element at k-1 position , \\n\\t\\t\\tif we find maximum upto k-2 elements and compare it with Kth element which is at index k and\\n\\t\\t\\tif we found that Kth element is greater , then we will remove K-1 th element and return Kth element else  return val . K-1th element is remained same since our k operations are completed\\n\\t\\t*/\\n            for(int i = 0 ; i < k-1 ;i++){\\n                val = max(nums[i],val);\\n            }\\n            return max(val , nums[k]);\\n        }\\n\\t\\t// if k>n then we will find maximum of nums vector and return \\n        int mx = *max_element(nums.begin(),nums.end());\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size(); // To store the size of the vector\\n        if(n==1){\\n            if(k%2 == 0) // If k is even , we will perform alternative add and remove operations at last we end up with the number nums[0]\\n                return nums[0];\\n            else\\n                return -1; // If k is odd , we will perform alternative add and remove operations at last we end up with empty vector so we return -1\\n        }\\n        else if(n>=k){\\n        int val = INT_MIN;\\n\\t\\t/* We are finding the maximum value of k-2 (included) elements only , \\n\\t\\t    Since our vector is zero based indexing , we will find the K th element at k-1 position , \\n\\t\\t\\tif we find maximum upto k-2 elements and compare it with Kth element which is at index k and\\n\\t\\t\\tif we found that Kth element is greater , then we will remove K-1 th element and return Kth element else  return val . K-1th element is remained same since our k operations are completed\\n\\t\\t*/\\n            for(int i = 0 ; i < k-1 ;i++){\\n                val = max(nums[i],val);\\n            }\\n            return max(val , nums[k]);\\n        }\\n\\t\\t// if k>n then we will find maximum of nums vector and return \\n        int mx = *max_element(nums.begin(),nums.end());\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852039,
                "title": "java-super-simple-and-short-greedy-solution",
                "content": "Idea is that we can either \\n- Delete `k-1` numbers and then add the `max` to the top as the `kth` operation\\n- Delete all the `k` numbers and then `nums[k]` becomes the top\\n\\nBoth ways we make `k` operations. We greedily choose max from the above two cases.\\n\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if (k%2 == 1 && nums.length == 1) return -1; // Array becomes empty in this case\\n        int max = 0;\\n        for (int i = 0; i < nums.length && i < k-1; i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        if (k < nums.length) {\\n            max = Math.max(max, nums[k]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if (k%2 == 1 && nums.length == 1) return -1; // Array becomes empty in this case\\n        int max = 0;\\n        for (int i = 0; i < nums.length && i < k-1; i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        if (k < nums.length) {\\n            max = Math.max(max, nums[k]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847241,
                "title": "python-o-n-simplified-array",
                "content": "key observation: *For any i ( i < k ), we can set any of [nums[0] ... nums[i]] at the top of the stack after k add/remove operations*\\n\\nGiven k operations allowed, we can have two scenarios\\n\\t\\t1. Case 1 :  Perform k remove operations -> nums[k] on top\\n\\t\\t2. Case 2 :  Perform i remove operations , (k-i) add operations -> max(nums[:k-1]) on top\\n\\t\\t\\n if k less than size of nums : return max(case1, case2)\\n if k equals size of nums : return case2 (case1 is not possible)\\n if k greater than size of nums : return case 1 (case 2 is not applicable)\\n\\n\\n```class Solution(object):\\n    def maximumTop(self, nums, k):\\n\\n        if len(nums) == 1 and k % 2 == 1 : \\n            return -1\\n        \\n        # k less than size of nums\\n        if k < len(nums):\\n            if k > 1:\\n                return max(nums[k], max(nums[:k-1]))\\n            else : \\n                return nums[k]\\n        \\n        # k equals size of nums\\n        elif k == len(nums): \\n            return max(nums[:k-1])\\n        \\n        # k greater than size of nums\\n        else : \\n            return max(nums)",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "key observation: *For any i ( i < k ), we can set any of [nums[0] ... nums[i]] at the top of the stack after k add/remove operations*\\n\\nGiven k operations allowed, we can have two scenarios\\n\\t\\t1. Case 1 :  Perform k remove operations -> nums[k] on top\\n\\t\\t2. Case 2 :  Perform i remove operations , (k-i) add operations -> max(nums[:k-1]) on top\\n\\t\\t\\n if k less than size of nums : return max(case1, case2)\\n if k equals size of nums : return case2 (case1 is not possible)\\n if k greater than size of nums : return case 1 (case 2 is not applicable)\\n\\n\\n```class Solution(object):\\n    def maximumTop(self, nums, k):\\n\\n        if len(nums) == 1 and k % 2 == 1 : \\n            return -1\\n        \\n        # k less than size of nums\\n        if k < len(nums):\\n            if k > 1:\\n                return max(nums[k], max(nums[:k-1]))\\n            else : \\n                return nums[k]\\n        \\n        # k equals size of nums\\n        elif k == len(nums): \\n            return max(nums[:k-1])\\n        \\n        # k greater than size of nums\\n        else : \\n            return max(nums)",
                "codeTag": "Java"
            },
            {
                "id": 1846786,
                "title": "python3-scan-the-array",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/66f7e5045d1b91897d8dbb425b6af153e6802c59) for solutions of weekly 284. \\n\\n```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1 and k&1: return -1\\n        ans = 0 \\n        for i in range(min(k-1, len(nums))): ans = max(ans, nums[i])\\n        if k < len(nums): ans = max(ans, nums[k])\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1 and k&1: return -1\\n        ans = 0 \\n        for i in range(min(k-1, len(nums))): ans = max(ans, nums[i])\\n        if k < len(nums): ans = max(ans, nums[k])\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846387,
                "title": "java-o-min-n-k-explained",
                "content": "```\\n    public int maximumTop(int[] nums, int k) {\\n        if(nums.length <= 1 && k % 2 == 1) return -1;\\n        if(k == 1) return nums[1];//if k is 1, I can only remove the top of the pile. Hence, nums[1] is the new top.\\n        int max = nums[0];\\n\\n        for(int i = 0; i < Math.min(k-1, nums.length); i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        \\n        //i have one operation left. I can either return the max I have so far to the top of the pile.\\n        //Or i can remove the current top of the pile in case the one below it is > max.\\n        if(k < nums.length && nums[k] > max) return nums[k];\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maximumTop(int[] nums, int k) {\\n        if(nums.length <= 1 && k % 2 == 1) return -1;\\n        if(k == 1) return nums[1];//if k is 1, I can only remove the top of the pile. Hence, nums[1] is the new top.\\n        int max = nums[0];\\n\\n        for(int i = 0; i < Math.min(k-1, nums.length); i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        \\n        //i have one operation left. I can either return the max I have so far to the top of the pile.\\n        //Or i can remove the current top of the pile in case the one below it is > max.\\n        if(k < nums.length && nums[k] > max) return nums[k];\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1845961,
                "title": "java-max-of-first-k-1-elements-and-kth-index-element",
                "content": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int max = -1;\\n        if(nums.length == 1 && k % 2 == 1) {\\n            return -1;\\n        }\\n        if (k > nums.length) {\\n            //  simple max of the array\\n            for (int i = 0; i < nums.length; i++) {\\n                max = Math.max(max, nums[i]);\\n            }\\n            return max;\\n        }\\n        //  max of first (k-1) elements\\n        for (int i = 0; i < k - 1; i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        //  comparing with the kth element\\n        if (k < nums.length) {\\n            max = Math.max(max, nums[k]);\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int max = -1;\\n        if(nums.length == 1 && k % 2 == 1) {\\n            return -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1845737,
                "title": "python-simple-greedy-5-line-solution-o-n-tc-o-1-sc",
                "content": "```\\ndef maximumTop(self, nums, k):\\n\"\"\"\\n:type nums: List[int]\\n:type k: int\\n:rtype: int\\n\"\"\"\\n#The case is seperate if len(nums) == 1...\\n#When len(nums) == 1, then ans is nums[0] if k is even, else ans is -1 if k is odd\\n#Other than that, for any k, the MAX number that lies in the range of nums[:(k+1)] is the answer if index != k\\n#This is because the MAX answer can be restored to be the first element for any value of k\\n\\n#Time Complexity: O(N)\\n#Space Complexity: O(1)\\n\\nif len(nums) == 1: return nums[0] if not k % 2 else -1\\nnums, maxi = nums[:(k+1)], -1\\nfor i, ele in enumerate(nums):\\n\\tif (i + 1) != k: maxi = max(maxi, ele)\\nreturn maxi\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\ndef maximumTop(self, nums, k):\\n\"\"\"\\n:type nums: List[int]\\n:type k: int\\n:rtype: int\\n\"\"\"\\n#The case is seperate if len(nums) == 1...\\n#When len(nums) == 1, then ans is nums[0] if k is even, else ans is -1 if k is odd\\n#Other than that, for any k, the MAX number that lies in the range of nums[:(k+1)] is the answer if index != k\\n#This is because the MAX answer can be restored to be the first element for any value of k\\n\\n#Time Complexity: O(N)\\n#Space Complexity: O(1)\\n\\nif len(nums) == 1: return nums[0] if not k % 2 else -1\\nnums, maxi = nums[:(k+1)], -1\\nfor i, ele in enumerate(nums):\\n\\tif (i + 1) != k: maxi = max(maxi, ele)\\nreturn maxi\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1845482,
                "title": "c-easy-greedy-solution-with-multiple-cases",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maximumTop(vector<int>& nums, int k) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tif(k==0) return nums[0];\\n\\t\\t\\tif(n==1){\\n\\t\\t\\t\\tif(k&1) return -1;\\n\\t\\t\\t\\treturn nums[0];\\n\\t\\t\\t}\\n\\t\\t\\tif(k==1) return nums[1];\\n\\t\\t\\tif(k==2) return max(nums[0],nums[k]);\\n\\t\\t\\tif(k>n) return *max_element(begin(nums),end(nums));\\n\\t\\t\\tif(k<n) return max(*max_element(begin(nums),begin(nums)+k-1),nums[k]);\\n\\t\\t\\treturn *max_element(begin(nums),begin(nums)+k-1);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maximumTop(vector<int>& nums, int k) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tif(k==0) return nums[0];\\n\\t\\t\\tif(n==1){\\n\\t\\t\\t\\tif(k&1) return -1;\\n\\t\\t\\t\\treturn nums[0];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1845275,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length;\\n        if(n==1 && k%2==1) return -1;\\n        if(k==0 || k==1) return nums[k];\\n        return Math.max(nums[k%n],IntStream.range(0,Math.min(k-1,n))\\n                .map(i->nums[i])\\n                .max()\\n                .getAsInt());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length;\\n        if(n==1 && k%2==1) return -1;\\n        if(k==0 || k==1) return nums[k];\\n        return Math.max(nums[k%n],IntStream.range(0,Math.min(k-1,n))\\n                .map(i->nums[i])\\n                .max()\\n                .getAsInt());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845260,
                "title": "c-solution-memoization-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    //memo array\\n    int t[100001];\\n    \\n\\t// this function implements the 1st move i.e pop element from the array\\n    int solve1(vector<int>& nums, int k,priority_queue<int> pq,int top){\\n        pq.push(nums[top]);\\n        return solve(nums,k-1,pq,top+1);\\n    }\\n    \\n\\t//this function implements the 2nd move i.e push any one of the popped element at the top\\n    int solve2(vector<int>& nums, int k,priority_queue<int> pq,int top){\\n        if(pq.size()!=0){\\n            nums[top-1]=pq.top();\\n            pq.pop();\\n        }\\n        else{\\n            return -1;\\n        }\\n        return solve(nums,k-1,pq,top-1);\\n    }\\n    \\n    int solve(vector<int>& nums, int k,priority_queue<int> pq,int top){\\n        //base cond\\n        if(k==0){\\n            return nums[top];\\n        }\\n         // checking the memo array for the element\\n        if(t[top]!=-1){\\n            return t[top];\\n        }\\n\\t\\t//logic\\n\\t\\t// returning the  max between the two moves\\n        return t[top] = max(solve1(nums,k,pq,top),solve2(nums,k,pq,top));\\n        \\n    }\\n    \\n    int maximumTop(vector<int>& nums, int k) {\\n\\t//This is the driver func\\n\\t//init the array t(declared globally) with -1\\n        memset(t,-1,sizeof(t));\\n\\t\\t//corner cases\\n\\t\\t//1st corner case is when k>=nums.size() and nums.size()==1 now there can be two sub cases\\n\\t\\t//1. when k is odd : if nums.size()==1 the general solution will be to pop then push then pop then push till \\n\\t\\t// you exhaust k so this means in case of k being odd you will always end up with no element in the array\\n\\t\\t//nums hence we return -1\\n        if(k>=nums.size() && nums.size()==1){\\n            if(k%2){\\n                return -1;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// 2. when k is even: when k is even you will end up with the element being inside the array nums so you\\n\\t\\t\\t//can return it as the max element\\n            else{\\n                return nums[0];\\n            }\\n        }\\n\\t\\t// 2nd corner case is when k>nums.size(): if k>nums.size() and nums.size() is also greater than 1 that means\\n\\t\\t//you will have more options to push and pop and you can access all the elements of nums hence return the\\n\\t\\t//max element\\n        if(k>nums.size()){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n\\t\\t// since we need only the maximum element amoung the popped elements we use a max heap\\n        priority_queue<int> pq;\\n\\t\\t//recursive func\\n        return solve(nums,k,pq,0);\\n    }\\n};\\n```\\n\\n**NOTE:** The time to execute this code is a bit high and the memory consumed as well.\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //memo array\\n    int t[100001];\\n    \\n\\t// this function implements the 1st move i.e pop element from the array\\n    int solve1(vector<int>& nums, int k,priority_queue<int> pq,int top){\\n        pq.push(nums[top]);\\n        return solve(nums,k-1,pq,top+1);\\n    }\\n    \\n\\t//this function implements the 2nd move i.e push any one of the popped element at the top\\n    int solve2(vector<int>& nums, int k,priority_queue<int> pq,int top){\\n        if(pq.size()!=0){\\n            nums[top-1]=pq.top();\\n            pq.pop();\\n        }\\n        else{\\n            return -1;\\n        }\\n        return solve(nums,k-1,pq,top-1);\\n    }\\n    \\n    int solve(vector<int>& nums, int k,priority_queue<int> pq,int top){\\n        //base cond\\n        if(k==0){\\n            return nums[top];\\n        }\\n         // checking the memo array for the element\\n        if(t[top]!=-1){\\n            return t[top];\\n        }\\n\\t\\t//logic\\n\\t\\t// returning the  max between the two moves\\n        return t[top] = max(solve1(nums,k,pq,top),solve2(nums,k,pq,top));\\n        \\n    }\\n    \\n    int maximumTop(vector<int>& nums, int k) {\\n\\t//This is the driver func\\n\\t//init the array t(declared globally) with -1\\n        memset(t,-1,sizeof(t));\\n\\t\\t//corner cases\\n\\t\\t//1st corner case is when k>=nums.size() and nums.size()==1 now there can be two sub cases\\n\\t\\t//1. when k is odd : if nums.size()==1 the general solution will be to pop then push then pop then push till \\n\\t\\t// you exhaust k so this means in case of k being odd you will always end up with no element in the array\\n\\t\\t//nums hence we return -1\\n        if(k>=nums.size() && nums.size()==1){\\n            if(k%2){\\n                return -1;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// 2. when k is even: when k is even you will end up with the element being inside the array nums so you\\n\\t\\t\\t//can return it as the max element\\n            else{\\n                return nums[0];\\n            }\\n        }\\n\\t\\t// 2nd corner case is when k>nums.size(): if k>nums.size() and nums.size() is also greater than 1 that means\\n\\t\\t//you will have more options to push and pop and you can access all the elements of nums hence return the\\n\\t\\t//max element\\n        if(k>nums.size()){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n\\t\\t// since we need only the maximum element amoung the popped elements we use a max heap\\n        priority_queue<int> pq;\\n\\t\\t//recursive func\\n        return solve(nums,k,pq,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845117,
                "title": "python-with-easy-explanation-time-o-min-nums-k-space-o-1-with-comments",
                "content": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n            l = len(nums)\\n\\n            if k&1 and l == 1:return -1  #if k is odd and l == 1,after k steps nums will be empty\\n            elif k == 0 or l == 1:return nums[0]  #if k == 0 or (else part of above case) nums[0] is top element\\n            elif k == 1:return nums[1]  #if k == 1,nums[:k-1] will be empty list thus max(nums[:k-1]) will throw error\\n            elif k>l: return max(nums)  #if k>l any element we want can be at top\\n            else: \\n                x = nums[k] if k<l else 0  #if k == l  nums[k] will be out of range\\n                return max(max(nums[:k-1]),x)  \\n\\t\\t\\t\\t#With any permutaion of steps, all elements till k can be at top except (k-1)th element and because of these reason we cannot take k>=l in above condition else (k-1)th element will also get included\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n            l = len(nums)\\n\\n            if k&1 and l == 1:return -1  #if k is odd and l == 1,after k steps nums will be empty\\n            elif k == 0 or l == 1:return nums[0]  #if k == 0 or (else part of above case) nums[0] is top element\\n            elif k == 1:return nums[1]  #if k == 1,nums[:k-1] will be empty list thus max(nums[:k-1]) will throw error\\n            elif k>l: return max(nums)  #if k>l any element we want can be at top\\n            else: \\n                x = nums[k] if k<l else 0  #if k == l  nums[k] will be out of range\\n                return max(max(nums[:k-1]),x)  \\n\\t\\t\\t\\t#With any permutaion of steps, all elements till k can be at top except (k-1)th element and because of these reason we cannot take k>=l in above condition else (k-1)th element will also get included\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844990,
                "title": "simple-solution-in-java-100-faster-with-drawing-to-understand-the-edge-cases",
                "content": "![image](https://assets.leetcode.com/users/images/d2532458-76c6-4c00-a1c0-033654f7dcfd_1647154092.0153883.png)\\n\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if(nums.length == 1 && k%2 == 1) return -1;\\n        \\n        int max = k < nums.length ? nums[k] : -1;\\n        boolean isOdd = false;\\n        if(k%2 == 1){\\n            isOdd = true;\\n            k -= 1;\\n        }\\n        \\n        for(int i=0; i<Math.min(k - 1, nums.length); i++){\\n            max = Math.max(max, nums[i]);\\n        }\\n        if(isOdd == true){\\n            max = Math.max(max, k-1 >= 0 ? nums[Math.min(k-1, nums.length-1)] :  -1);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if(nums.length == 1 && k%2 == 1) return -1;\\n        \\n        int max = k < nums.length ? nums[k] : -1;\\n        boolean isOdd = false;\\n        if(k%2 == 1){\\n            isOdd = true;\\n            k -= 1;\\n        }\\n        \\n        for(int i=0; i<Math.min(k - 1, nums.length); i++){\\n            max = Math.max(max, nums[i]);\\n        }\\n        if(isOdd == true){\\n            max = Math.max(max, k-1 >= 0 ? nums[Math.min(k-1, nums.length-1)] :  -1);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844970,
                "title": "java-o-n-greedy-the-shortest-code-with-proof",
                "content": "We can only take one number or put it back to the array every operation at most k times.\\nSo the **maximun** must be in the range of [0, k]\\nThere are only 3 cases:\\n**case1**: When n == 1 and k is odd, we always get an empty array.\\n**proof:**\\nif k == 1, we take this number out, then get an empty array\\nif k == 3, we can only take this number out 3 times, it also get an empty array\\nand so on...\\n\\n**case2**: We use k times operation to take k numbers out, then the answer must be nums[k]\\nthat is if-statement k == i\\n\\n**case3**: The remainder of situation is that we used totally k-2 times operation to take some numbers out, and the rest of 2 times operation to take and push back the last number nums[k-2]. In this case, we can go to the index k-2 at mostright. **(the numbers of in range [0,k-3] will be take out once, and nums[k-2] is going to be taken and push back separately once)**, so we can use nums[k-2] update our **max**\\n**proof:**\\n**similarly**, if we used totally k-3 times operation to take numbers out, meantime using 2 times operation to take and push back the last number nums[k-3], we can go to the index k-3 at mostright. the maximum will be nums[k-3].\\nand so on...\\nthat is if-statement i <= k-2, it means that any numbers in range [0,k-2] will be considered as the final answer, but for sure, we just need the maximum in range [0,k-2]\\n\\n\\n\\n```java\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length;\\n        if (n == 1) return k%2 == 1 ? -1 : nums[0];\\n        int max = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(k == i || i <= k-2) max = Math.max(max, nums[i]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```java\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length;\\n        if (n == 1) return k%2 == 1 ? -1 : nums[0];\\n        int max = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(k == i || i <= k-2) max = Math.max(max, nums[i]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844842,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) \\n    {\\n        if(k%2 == 1 && nums.size() == 1)\\n        {\\n            return -1;\\n        }\\n        \\n        if(k > nums.size())\\n        {\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        else if(k == nums.size())\\n        {\\n            int maxi=INT_MIN;\\n            \\n            for(int i=0; i<k-1; i++)\\n            {\\n                maxi=max(maxi,nums[i]);\\n            }\\n            \\n            return maxi;\\n        }\\n        else\\n        {\\n            int maxi=INT_MIN;\\n            \\n            for(int i=0; i<k-1; i++)\\n            {\\n                maxi=max(maxi,nums[i]);\\n            }\\n            \\n            maxi=max(maxi,nums[k]);\\n            \\n            return maxi;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) \\n    {\\n        if(k%2 == 1 && nums.size() == 1)\\n        {\\n            return -1;\\n        }\\n        \\n        if(k > nums.size())\\n        {\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        else if(k == nums.size())\\n        {\\n            int maxi=INT_MIN;\\n            \\n            for(int i=0; i<k-1; i++)\\n            {\\n                maxi=max(maxi,nums[i]);\\n            }\\n            \\n            return maxi;\\n        }\\n        else\\n        {\\n            int maxi=INT_MIN;\\n            \\n            for(int i=0; i<k-1; i++)\\n            {\\n                maxi=max(maxi,nums[i]);\\n            }\\n            \\n            maxi=max(maxi,nums[k]);\\n            \\n            return maxi;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844796,
                "title": "simple-implementation-using-a-max-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1 and k>=1 and k%2==0) return nums[0];\\n        if(nums.size()==1 and k>=1 and k%2!=0) return -1;\\n        if(k==0) return nums[0];\\n        if(k==1) return nums[1];\\n        // when the k>nums.size()\\n        if(k>nums.size()) return *max_element(nums.begin(),nums.end());\\n        priority_queue<int>pq;\\n        for(int i=0;i<=k-2;i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n\\t\\t// when k==nums.size()\\n        if(k==nums.size()) return pq.top();\\n     // when k<nums.size()\\n\\t if(k<nums.size())\\n        {\\n            return max(pq.top(),nums[k]);\\n        }\\n        return -1;  // unexceutable statement\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1 and k>=1 and k%2==0) return nums[0];\\n        if(nums.size()==1 and k>=1 and k%2!=0) return -1;\\n        if(k==0) return nums[0];\\n        if(k==1) return nums[1];\\n        // when the k>nums.size()\\n        if(k>nums.size()) return *max_element(nums.begin(),nums.end());\\n        priority_queue<int>pq;\\n        for(int i=0;i<=k-2;i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n\\t\\t// when k==nums.size()\\n        if(k==nums.size()) return pq.top();\\n     // when k<nums.size()\\n\\t if(k<nums.size())\\n        {\\n            return max(pq.top(),nums[k]);\\n        }\\n        return -1;  // unexceutable statement\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844726,
                "title": "cpp-easy-soln-tc-o-n-sc-o-n-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        queue<int>q;\\n        int i=0;\\n        for(auto &a:nums){\\n            q.push(a);\\n        }\\n        \\n        i=1;\\n        int mx=0;\\n        int x= q.size();\\n        if(k==0)return q.front();\\n        if(x==1){\\n            if(k%2==0){\\n                return q.front();\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        while(!q.empty()){\\n            int p=q.front();\\n            q.pop();\\n             mx=max(mx,p);\\n            \\n            if(k==1){\\n                if(!q.empty()){\\n                return q.front();\\n                }\\n                else{\\n                    return -1;\\n                }\\n            }\\n            if(i==k-1){\\n                    if(!q.empty()){\\n                        q.pop();\\n                    }\\n                    if(!q.empty()){\\n                        if(q.front()>mx){\\n                            return q.front();\\n                        }\\n                        else{\\n                            return mx;\\n                        }\\n                    }\\n                else{\\n                    return mx;\\n                }\\n                }\\n            else if(i<k-1){\\n                i++;\\n            }\\n        }\\n        if(x<k){\\n            return mx;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        queue<int>q;\\n        int i=0;\\n        for(auto &a:nums){\\n            q.push(a);\\n        }\\n        \\n        i=1;\\n        int mx=0;\\n        int x= q.size();\\n        if(k==0)return q.front();\\n        if(x==1){\\n            if(k%2==0){\\n                return q.front();\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        while(!q.empty()){\\n            int p=q.front();\\n            q.pop();\\n             mx=max(mx,p);\\n            \\n            if(k==1){\\n                if(!q.empty()){\\n                return q.front();\\n                }\\n                else{\\n                    return -1;\\n                }\\n            }\\n            if(i==k-1){\\n                    if(!q.empty()){\\n                        q.pop();\\n                    }\\n                    if(!q.empty()){\\n                        if(q.front()>mx){\\n                            return q.front();\\n                        }\\n                        else{\\n                            return mx;\\n                        }\\n                    }\\n                else{\\n                    return mx;\\n                }\\n                }\\n            else if(i<k-1){\\n                i++;\\n            }\\n        }\\n        if(x<k){\\n            return mx;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844637,
                "title": "simulating-all-cases",
                "content": "Basically, it can be solved by considering lots of edge cases.\\n\\n```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        #edge cases\\n        if N == 1 and k % 2 == 1:\\n            return -1\\n        if k == 0:\\n            return nums[0]\\n        if k > N:\\n            return max(nums)\\n        if k == N:\\n            return max(nums[:N - 1])\\n        \\n        #non-edge cases\\n        return max(nums[:k - 1] + [nums[k]])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        #edge cases\\n        if N == 1 and k % 2 == 1:\\n            return -1\\n        if k == 0:\\n            return nums[0]\\n        if k > N:\\n            return max(nums)\\n        if k == N:\\n            return max(nums[:N - 1])\\n        \\n        #non-edge cases\\n        return max(nums[:k - 1] + [nums[k]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844571,
                "title": "java-simple-solution-3ms",
                "content": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if(k == 0)\\n            return nums[0];\\n        \\n        if(nums.length == 1 && k%2 != 0)\\n            return -1;\\n        \\n        if(k == 1)\\n            return (nums.length<=1) ? -1 : nums[1];\\n        \\n        int max = 0;\\n        \\n        int index = 0;\\n        \\n        while(k-- != 1 && index < nums.length)\\n            max = Math.max(max, nums[index++]);\\n        \\n        if(index >= nums.length-1)\\n            return max;\\n        \\n        return Math.max(max, nums[index+1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if(k == 0)\\n            return nums[0];\\n        \\n        if(nums.length == 1 && k%2 != 0)\\n            return -1;\\n        \\n        if(k == 1)\\n            return (nums.length<=1) ? -1 : nums[1];\\n        \\n        int max = 0;\\n        \\n        int index = 0;\\n        \\n        while(k-- != 1 && index < nums.length)\\n            max = Math.max(max, nums[index++]);\\n        \\n        if(index >= nums.length-1)\\n            return max;\\n        \\n        return Math.max(max, nums[index+1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844545,
                "title": "easy-to-understand-solution-with-comments",
                "content": "\\n\\n```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n    # made 0 moves so return top most element\\n\\tif k == 0:\\n\\t\\treturn nums[0]\\n\\n\\tn = len(nums)\\n\\t# odd k won\\'t work with len = 1 because we will end up empty array state\\n\\tif n == 1:\\n\\t\\treturn -1 if k % 2 != 0 else nums[0]\\n\\t\\n    # we have a lot of moves so we can do anything to make sure the first element is always the max\\n\\tif k > n:\\n\\t\\treturn max(nums)\\n\\telse: # k<=n scenario\\n\\t\\t# make sure you don\\'t exceed the array size\\n\\t\\tupper_bound = min(n, k - 1)\\n\\t\\t\\n\\t\\t# consider first k - 1 elements (aka upper bound)\\n\\t\\t# for kth index, we have the option to use the kth element if it\\'s available (k < len(nums))\\n        # or replace it with the previous seen max in which case we don\\'t consider it\\n\\t\\treturn max(nums[:upper_bound] + [nums[k] if k < n else float(\\'-inf\\')])\\n  ```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n    # made 0 moves so return top most element\\n\\tif k == 0:\\n\\t\\treturn nums[0]\\n\\n\\tn = len(nums)\\n\\t# odd k won\\'t work with len = 1 because we will end up empty array state\\n\\tif n == 1:\\n\\t\\treturn -1 if k % 2 != 0 else nums[0]\\n\\t\\n    # we have a lot of moves so we can do anything to make sure the first element is always the max\\n\\tif k > n:\\n\\t\\treturn max(nums)\\n\\telse: # k<=n scenario\\n\\t\\t# make sure you don\\'t exceed the array size\\n\\t\\tupper_bound = min(n, k - 1)\\n\\t\\t\\n\\t\\t# consider first k - 1 elements (aka upper bound)\\n\\t\\t# for kth index, we have the option to use the kth element if it\\'s available (k < len(nums))\\n        # or replace it with the previous seen max in which case we don\\'t consider it\\n\\t\\treturn max(nums[:upper_bound] + [nums[k] if k < n else float(\\'-inf\\')])\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 1844543,
                "title": "c-greedy-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        \\n        int sz=nums.size();\\n\\t\\tif(k==0)\\n            return nums[0];\\n        if(sz==1)\\n        {\\n            if(k&1)\\n                return -1;\\n            else\\n                return nums[0];\\n        }\\n        if(k>sz)\\n            return *max_element(nums.begin(),nums.end());\\n        \\n        int maxi=0;\\n        int i;\\n        for( i=1;i<=k-1;i++)\\n            maxi=max(maxi,nums[i-1]);\\n        \\n        //cout<<i<<endl;\\n        return max(maxi,nums[i]);\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        \\n        int sz=nums.size();\\n\\t\\tif(k==0)\\n            return nums[0];\\n        if(sz==1)\\n        {\\n            if(k&1)\\n                return -1;\\n            else\\n                return nums[0];\\n        }\\n        if(k>sz)\\n            return *max_element(nums.begin(),nums.end());\\n        \\n        int maxi=0;\\n        int i;\\n        for( i=1;i<=k-1;i++)\\n            maxi=max(maxi,nums[i-1]);\\n        \\n        //cout<<i<<endl;\\n        return max(maxi,nums[i]);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1844537,
                "title": "javascript-solution",
                "content": "```\\nvar maximumTop = function(nums, k) {\\n    const n  = nums.length;\\n\\n    if(k === 0) return nums[0];\\n\\n    if(n >= k ){\\n       if(k === 1) return n - k === 0 ? -1 : nums[1];\\n       const mostArr = nums.slice(0, k-1);\\n       const max = Math.max(...mostArr);\\n       return k === n || max > nums[k] ? max : nums[k];   \\n    }else{\\n       if(n == 1 && k % 2 == 1) return -1;\\n       const max = Math.max(...nums);\\n       return max;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maximumTop = function(nums, k) {\\n    const n  = nums.length;\\n\\n    if(k === 0) return nums[0];\\n\\n    if(n >= k ){\\n       if(k === 1) return n - k === 0 ? -1 : nums[1];\\n       const mostArr = nums.slice(0, k-1);\\n       const max = Math.max(...mostArr);\\n       return k === n || max > nums[k] ? max : nums[k];   \\n    }else{\\n       if(n == 1 && k % 2 == 1) return -1;\\n       const max = Math.max(...nums);\\n       return max;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844520,
                "title": "c-solution-with-each-case-explaination",
                "content": "Case 1- when n==1 , As there is only one element, at every odd step we pop out the element and at every even step we push back the element.\\nCase 2- when k==0, when k==0, we cannot perform any operation so the top-most element will be the answer.\\nCase 3- when n>1 , k>0 and k<=n, we pop k-1 elements and keep track of max element. Now k=1 is left, so 2 cases are possible\\n\\ti)- Push the maximum element among the all popped elements.\\n\\tii)- Pop the element from the stack if it doesn\\'t make it empty. (As here we can make the stack non-empty, we cannot return -1.\\n\\tCheck these 2 conditions and find the max answer.\\n\\t\\nCase 4- when n>1 and k>n, Since k>n, we can pop out every element while keeping track of max element and decrease k by n. \\nWhile k>2, we push any element and pop it back, decreasing k by 2 every time.\\nAt the end, if k is 1 we can push the max element and if the k is 2, we can randomly push any other element first (not  max element) and then push the max element. So, the answer will always be max element of the array.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n\\t\\t//case 1\\n        if(k%2==1 && n==1)\\n            return -1;\\n\\t\\t// case 1 and case 2\\n        else if((k%2==0 && n==1) || k==0)\\n        {\\n            return nums[0];\\n        }\\n        int mx=INT_MIN,i=0,x=k;\\n        for(i=0;k>1 && i<n;i++,k--)\\n        {\\n                mx=max(nums[i],mx);\\n        }\\n        int ans;\\n\\t\\t//case 3\\n        if(k==1)\\n        {\\n            ans=mx;\\n            if(i+1<n)\\n            {\\n                ans=max(nums[i+1],ans);\\n            }\\n        }\\n        else \\n        {\\n\\t\\t//case 4\\n            ans=mx;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n\\t\\t//case 1\\n        if(k%2==1 && n==1)\\n            return -1;\\n\\t\\t// case 1 and case 2\\n        else if((k%2==0 && n==1) || k==0)\\n        {\\n            return nums[0];\\n        }\\n        int mx=INT_MIN,i=0,x=k;\\n        for(i=0;k>1 && i<n;i++,k--)\\n        {\\n                mx=max(nums[i],mx);\\n        }\\n        int ans;\\n\\t\\t//case 3\\n        if(k==1)\\n        {\\n            ans=mx;\\n            if(i+1<n)\\n            {\\n                ans=max(nums[i+1],ans);\\n            }\\n        }\\n        else \\n        {\\n\\t\\t//case 4\\n            ans=mx;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844519,
                "title": "c-using-stack-and-handling-all-cases-easy-explanation-by-engineer",
                "content": "``` \\n  int n = nums.size(); // size of array\\n        \\n        if(k==0){\\n            return nums[0]; // num of moves is 0 then top elem is the max we can obtain\\n        }\\n        \\n        \\n       if(n==1){\\n           return k%2==0? nums[0]: -1; // if we have only one elem in array then we can get it on top when we have even moves \\n       }\\n        \\n        stack<int> st; // stack to store elem\\n        \\n        for(int i=n-1;i>=0;i--){\\n            st.push(nums[i]);  // push all elem in the stack from end \\n        }\\n        \\n        int step = k-1;\\n        int e = -999; // min value\\n        while(step-- && !st.empty()){\\n            int temp = st.top();\\n            st.pop();    //pop k-1 times   and store the max of popped value\\n            e = max(temp,e);\\n        }\\n        \\n        if(!st.empty()){\\n             st.pop();  // checking for the k+1 th case\\n        }\\n       \\n        \\n        if(!st.empty() && st.top()>e){\\n            return st.top();   // checking k+1 value\\n        }\\n        \\n        if(k==1){\\n            return -1;   // edge case\\n        }\\n        \\n        st.push(e);  // can be ignored\\n       \\n        return e;\\n        \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "``` \\n  int n = nums.size(); // size of array\\n        \\n        if(k==0){\\n            return nums[0]; // num of moves is 0 then top elem is the max we can obtain\\n        }\\n        \\n        \\n       if(n==1){\\n           return k%2==0? nums[0]: -1; // if we have only one elem in array then we can get it on top when we have even moves \\n       }\\n        \\n        stack<int> st; // stack to store elem\\n        \\n        for(int i=n-1;i>=0;i--){\\n            st.push(nums[i]);  // push all elem in the stack from end \\n        }\\n        \\n        int step = k-1;\\n        int e = -999; // min value\\n        while(step-- && !st.empty()){\\n            int temp = st.top();\\n            st.pop();    //pop k-1 times   and store the max of popped value\\n            e = max(temp,e);\\n        }\\n        \\n        if(!st.empty()){\\n             st.pop();  // checking for the k+1 th case\\n        }\\n       \\n        \\n        if(!st.empty() && st.top()>e){\\n            return st.top();   // checking k+1 value\\n        }\\n        \\n        if(k==1){\\n            return -1;   // edge case\\n        }\\n        \\n        st.push(e);  // can be ignored\\n       \\n        return e;\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844515,
                "title": "c-2202-maximize-the-topmost-element-after-k-moves",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if (nums.size() == 1) return k & 1 ? -1 : nums[0]; \\n        int ans = 0; \\n        for (int i = 0; i < k-1 && i < nums.size(); ++i) ans = max(ans, nums[i]); \\n        if (k < nums.size()) ans = max(ans, nums[k]); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if (nums.size() == 1) return k & 1 ? -1 : nums[0]; \\n        int ans = 0; \\n        for (int i = 0; i < k-1 && i < nums.size(); ++i) ans = max(ans, nums[i]); \\n        if (k < nums.size()) ans = max(ans, nums[k]); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844502,
                "title": "c-simple-best-solution-ever-dattebayo-solution-100-beats-all-runtime",
                "content": "even though i have used priority queue here it is just for the sake of maximum element u can also do it with some variables\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(k==0)return nums[0];\\n        if((k&1)&&n==1)return -1;\\n        if((k%2==0)&&n==1)return nums[0];\\n        \\n        priority_queue<pair<int,int>>pq;//nums,i;\\n        int maxi = 0;\\n        int j = k;\\n        for(int i = 0 ;i<=min(n-1,k);++i){\\n            maxi = max(maxi,nums[i]);\\n            pq.push({nums[i],j});j--;\\n        }\\n      \\n        int ans = 0;\\n       if(pq.top().second==1){\\n           pq.pop();\\n       return pq.top().first;\\n       }\\n        return pq.top().first;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(k==0)return nums[0];\\n        if((k&1)&&n==1)return -1;\\n        if((k%2==0)&&n==1)return nums[0];\\n        \\n        priority_queue<pair<int,int>>pq;//nums,i;\\n        int maxi = 0;\\n        int j = k;\\n        for(int i = 0 ;i<=min(n-1,k);++i){\\n            maxi = max(maxi,nums[i]);\\n            pq.push({nums[i],j});j--;\\n        }\\n      \\n        int ans = 0;\\n       if(pq.top().second==1){\\n           pq.pop();\\n       return pq.top().first;\\n       }\\n        return pq.top().first;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844446,
                "title": "java-100-faster-solution",
                "content": "```\\n\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length;\\n        if(k==0){\\n            return nums[0];\\n        }\\n        if(k%2==1 && n==1){\\n            return -1;\\n        }else if(k==1){\\n            return nums[1];\\n        }\\n        if(k>n){\\n            int max = nums[0];\\n            for(int i=0;i<n;i++){\\n                if(nums[i]>max){\\n                    max =nums[i];\\n                }\\n            }\\n            return max;\\n        }\\n        int max = nums[0];\\n        for(int i=0;i<k-1;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n        }\\n        if(k==n){\\n            return max;\\n        }else{\\n            if(nums[k]>max){\\n                return nums[k];\\n            }else{\\n                return max;\\n            }\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n = nums.length;\\n        if(k==0){\\n            return nums[0];\\n        }\\n        if(k%2==1 && n==1){\\n            return -1;\\n        }else if(k==1){\\n            return nums[1];\\n        }\\n        if(k>n){\\n            int max = nums[0];\\n            for(int i=0;i<n;i++){\\n                if(nums[i]>max){\\n                    max =nums[i];\\n                }\\n            }\\n            return max;\\n        }\\n        int max = nums[0];\\n        for(int i=0;i<k-1;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n        }\\n        if(k==n){\\n            return max;\\n        }else{\\n            if(nums[k]>max){\\n                return nums[k];\\n            }else{\\n                return max;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844414,
                "title": "java-clean-code-with-explanation-tc-k-sc-o-1",
                "content": "At any point, we can do this two operation\\n1. add any of elements that we have removed so far\\n\\t-\\tIf we want to add, we add maximum of elements that we have removed\\n2. remove top element\\n\\t-\\tIf we want to remove, we can remove only top element.\\n\\t\\n\\t\\nUse above to decide what will be result after k operations,\\n\\tat any point we should have maximum number of previous elements - say max,\\n\\twe can check if \\n\\t\\t1. we should add max or,\\n\\t\\t2. remove current, which will result to maximize top of array - means next top will be next element in array\\n\\t\\tdecide by max(max, nums[i + 1])\\n\\t\\t\\nOf course we have to manage corner cases which you will understand as you see the code.\\n\\t\\n\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        //if there is only oe element\\n        if (nums.length == 1) {\\n            return k % 2 == 1 ? -1 : nums[0]; // if odd(k) - we can add in last operation, else we will end up removing all elements at last\\n        }\\n        \\n        //first operation can be removing element only\\n        if (k == 1) {\\n            return nums[1];\\n        }\\n        \\n        //find max of first k - 1 elements  - O(k)\\n        int max = nums[0];\\n        for (int i = 1; i < (k - 1) && i < nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        \\n\\t\\t//O(1)\\n        //decide for kth operation and findout result\\n        if (k < nums.length) {\\n            return Math.max(nums[k], max);\\n        } else {\\n            return max;\\n        }\\n    }\\n}\\n```\\n\\nTC - O(K)\\nSC - O(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        //if there is only oe element\\n        if (nums.length == 1) {\\n            return k % 2 == 1 ? -1 : nums[0]; // if odd(k) - we can add in last operation, else we will end up removing all elements at last\\n        }\\n        \\n        //first operation can be removing element only\\n        if (k == 1) {\\n            return nums[1];\\n        }\\n        \\n        //find max of first k - 1 elements  - O(k)\\n        int max = nums[0];\\n        for (int i = 1; i < (k - 1) && i < nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        \\n\\t\\t//O(1)\\n        //decide for kth operation and findout result\\n        if (k < nums.length) {\\n            return Math.max(nums[k], max);\\n        } else {\\n            return max;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844404,
                "title": "very-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if (k%2 == 1 && nums.size() == 1)\\n            return -1;\\n        if(k == 0)return nums[0];\\n        int n = nums.size();\\n        int maxu = -1;\\n        int i = 0;\\n        int u = 0;\\n        if(k > n){\\n            u = n;\\n        }else{\\n            u = k-1;\\n        }\\n        for (; i < u; i++)\\n        {\\n            maxu = max(maxu, nums[i]);\\n        }\\n        if(i + 1 <n){\\n            maxu = max(maxu, nums[i+1]);\\n        }\\n        return maxu;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if (k%2 == 1 && nums.size() == 1)\\n            return -1;\\n        if(k == 0)return nums[0];\\n        int n = nums.size();\\n        int maxu = -1;\\n        int i = 0;\\n        int u = 0;\\n        if(k > n){\\n            u = n;\\n        }else{\\n            u = k-1;\\n        }\\n        for (; i < u; i++)\\n        {\\n            maxu = max(maxu, nums[i]);\\n        }\\n        if(i + 1 <n){\\n            maxu = max(maxu, nums[i+1]);\\n        }\\n        return maxu;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844397,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        length = len(nums)\\n        if length == 0 or (k%2==1 and length == 1):\\n            return -1\\n        if k==0 or k==1: \\n            return nums[k]\\n        if k>=length:\\n            return max(nums[:k-1])\\n        return max(max(nums[:k-1]), nums[k])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        length = len(nums)\\n        if length == 0 or (k%2==1 and length == 1):\\n            return -1\\n        if k==0 or k==1: \\n            return nums[k]\\n        if k>=length:\\n            return max(nums[:k-1])\\n        return max(max(nums[:k-1]), nums[k])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844343,
                "title": "read-question-carefully-beginners-level-easy-greedy-solution-cases",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0) return nums[0];\\n        int n = nums.size();\\n        if(n==1){\\n            return (k%2==0 ? nums[0] : -1);\\n        }\\n        if(k==1) return nums[1];\\n        if(k>n) return *max_element(nums.begin(),nums.end());\\n        return max(*max_element(nums.begin(),nums.begin()+k-1),nums[k]);\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0) return nums[0];\\n        int n = nums.size();\\n        if(n==1){\\n            return (k%2==0 ? nums[0] : -1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1844314,
                "title": "very-easy-c-o-n",
                "content": "\\t\\tint x=k;\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n        bool temp=true;\\n        if(k>n){\\n            x=n+1;\\n            temp=false;\\n        }\\n       stack<int>st;\\n        for(int i=0;i<x-1;i++){\\n            maxi=max(maxi,nums[i]);\\n            st.push(nums[i]);\\n        }\\n        if(n==1 and k%2==1){\\n            maxi=-1;\\n        }\\n        else if(x<n){\\n            maxi=max(nums[x],maxi);\\n        }\\n        return maxi;",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\t\\tint x=k;\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n        bool temp=true;\\n        if(k>n){\\n            x=n+1;\\n            temp=false;\\n        }\\n       stack<int>st;\\n        for(int i=0;i<x-1;i++){\\n            maxi=max(maxi,nums[i]);\\n            st.push(nums[i]);\\n        }\\n        if(n==1 and k%2==1){\\n            maxi=-1;\\n        }\\n        else if(x<n){\\n            maxi=max(nums[x],maxi);\\n        }\\n        return maxi;",
                "codeTag": "Unknown"
            },
            {
                "id": 1844260,
                "title": "simple-o-n-solution-easy-to-understand",
                "content": "class Solution {![image](https://assets.leetcode.com/users/images/5651f006-a49f-4289-92af-d5c71ddd90c5_1647144516.483719.png)\\n\\npublic:\\n    int maximumTop(vector<int>& a, int k) {\\n        int ans=-1,n=a.size();\\n        if(n==1)     // handling one element case\\n        {\\n            if(k%2)\\n                return -1;\\n            else\\n                return a[0];\\n        }\\n        if(k<=n)    // We can get max upto k+1 except kth element\\n        { \\n            if(k>1)             // We never get kth element as our answer.\\n            ans=*(max_element(a.begin(),a.begin()+k-1)); // finding max till k-1\\n            ans=max(ans,a[k]);    // if we remove all k,then k+1 that is kth element of 0 indexing can be our answer.\\n        }\\n         else                    // IF K is greater than length of array then we remove all the elements and put the maximum at top greedly\\n            ans=*(max_element(a.begin(),a.end()));\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {![image](https://assets.leetcode.com/users/images/5651f006-a49f-4289-92af-d5c71ddd90c5_1647144516.483719.png)\\n\\npublic:\\n    int maximumTop(vector<int>& a, int k) {\\n        int ans=-1,n=a.size();\\n        if(n==1)     // handling one element case\\n        {\\n            if(k%2)\\n                return -1;\\n            else\\n                return a[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1844259,
                "title": "c-maximize-the-topmost-element-after-k-moves",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int maximumTop(vector<int> &nums, int k)\\n    {\\n        if (k == 0)\\n            return nums[0];\\n        if (nums.size() == 1 && k % 2 == 0)\\n            return nums[0];\\n        if (nums.size() == 1 && k % 2 == 1)\\n            return -1;\\n        int n = nums.size();\\n        int maxi = -1;\\n        if (k > nums.size())\\n            return *max_element(nums.begin(), nums.end());\\n        int i = 0;\\n        while (i < k - 1)\\n        {\\n            if (nums[i] > maxi)\\n            {\\n                maxi = nums[i];\\n            }\\n            i++;\\n        }\\n        if (i + 1 < n && nums[i + 1] > maxi)\\n            return nums[i + 1];\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maximumTop(vector<int> &nums, int k)\\n    {\\n        if (k == 0)\\n            return nums[0];\\n        if (nums.size() == 1 && k % 2 == 0)\\n            return nums[0];\\n        if (nums.size() == 1 && k % 2 == 1)\\n            return -1;\\n        int n = nums.size();\\n        int maxi = -1;\\n        if (k > nums.size())\\n            return *max_element(nums.begin(), nums.end());\\n        int i = 0;\\n        while (i < k - 1)\\n        {\\n            if (nums[i] > maxi)\\n            {\\n                maxi = nums[i];\\n            }\\n            i++;\\n        }\\n        if (i + 1 < n && nums[i + 1] > maxi)\\n            return nums[i + 1];\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844240,
                "title": "python3-short-greedy-solution-using-heap",
                "content": "We want to return the max value so we can start with the largest value.\\nTo find the largest value and its index, we can push all the elements into a heap.\\n```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if not nums:\\n            return -1\\n        if len(nums) == 1 and k % 2 == 1:\\n            return -1\\n        heap = []\\n        for i, num in enumerate(nums):\\n            heappush(heap, (-num, i))\\n        \\n        while heap:\\n            largest, idx = heappop(heap)\\n            if idx > k: # that element is too far away from index 0\\n                continue\\n            if idx == k: # pop out all the elements in front of it and we run out of k\\n                return -largest\\n            # idx < k\\n            remaining = k - idx # pop all the elements in front of it and we have remaining moves \\n            if remaining >= 2: # if the # of remaining moves >= 2, we can remove it and subsequent elements and and add it back back and forth\\n                return -largest\\n        return -1\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if not nums:\\n            return -1\\n        if len(nums) == 1 and k % 2 == 1:\\n            return -1\\n        heap = []\\n        for i, num in enumerate(nums):\\n            heappush(heap, (-num, i))\\n        \\n        while heap:\\n            largest, idx = heappop(heap)\\n            if idx > k: # that element is too far away from index 0\\n                continue\\n            if idx == k: # pop out all the elements in front of it and we run out of k\\n                return -largest\\n            # idx < k\\n            remaining = k - idx # pop all the elements in front of it and we have remaining moves \\n            if remaining >= 2: # if the # of remaining moves >= 2, we can remove it and subsequent elements and and add it back back and forth\\n                return -largest\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844235,
                "title": "simple-explanation-case-by-case",
                "content": "Two cases need to compare\\n1. remove all the k elements\\n2. remove k-1 elements and put largest back\\n\\nEdge cases\\n1. when k == len(nums), only consider k-1 largest\\n2. when k > len(nums), get largest\\n3. when len(nums) == 1, odd number of k always -1\\n```\\npublic class Solution {\\n        \\n    public int MaximumTop(int[] nums, int k) {\\n        if (nums.Length == 1)\\n        {\\n            if (k % 2 == 1)\\n                return -1;\\n            else\\n                return nums[0];\\n        }\\n        \\n        if (k == 0)\\n            return nums[0];\\n                \\n        if (k > nums.Length)\\n            return nums.Max();\\n    \\n        \\n        int max = k == 1? -1: nums[0];\\n        for (int i = 1; i < k-1; i++){\\n            max = Math.Max(max, nums[i]);\\n        }\\n        int val = k == nums.Length? -1: nums[k];\\n        return Math.Max(val,max);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n        \\n    public int MaximumTop(int[] nums, int k) {\\n        if (nums.Length == 1)\\n        {\\n            if (k % 2 == 1)\\n                return -1;\\n            else\\n                return nums[0];\\n        }\\n        \\n        if (k == 0)\\n            return nums[0];\\n                \\n        if (k > nums.Length)\\n            return nums.Max();\\n    \\n        \\n        int max = k == 1? -1: nums[0];\\n        for (int i = 1; i < k-1; i++){\\n            max = Math.Max(max, nums[i]);\\n        }\\n        int val = k == nums.Length? -1: nums[k];\\n        return Math.Max(val,max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844217,
                "title": "java-short",
                "content": "```\\npublic int maximumTop(int[] nums, int k) {\\n        int len = nums.length;\\n        if(k==0) return nums[0];\\n        if(len == 1 && k%2==1) return -1;\\n        if(k==1) return nums[1];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> b-a);\\n        for(int i=0; i<k-1; i++){\\n            if(i>=len) break;\\n            pq.add(nums[i]);  \\n        }\\n        if(pq.isEmpty()) return -1;\\n        return Math.max(pq.peek(), nums[(k%len+1)-1]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maximumTop(int[] nums, int k) {\\n        int len = nums.length;\\n        if(k==0) return nums[0];\\n        if(len == 1 && k%2==1) return -1;\\n        if(k==1) return nums[1];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> b-a);\\n        for(int i=0; i<k-1; i++){\\n            if(i>=len) break;\\n            pq.add(nums[i]);  \\n        }\\n        if(pq.isEmpty()) return -1;\\n        return Math.max(pq.peek(), nums[(k%len+1)-1]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844204,
                "title": "c-code-easy-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int ans=-1;\\n        if(k==0) return nums[0];\\n        if(n==1 && k%2==1)return -1;\\n        if(n==1)return nums[0];\\n        if(k>n) k=n+1;           \\n        int idx=0,r=k-1;\\n\\t\\t\\n        while(r--){\\n            if(idx<n)ans=max(ans,nums[idx++]);            \\n        }\\n        if(k<n) ans=max(ans,nums[k]);           \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int ans=-1;\\n        if(k==0) return nums[0];\\n        if(n==1 && k%2==1)return -1;\\n        if(n==1)return nums[0];\\n        if(k>n) k=n+1;           \\n        int idx=0,r=k-1;\\n\\t\\t\\n        while(r--){\\n            if(idx<n)ans=max(ans,nums[idx++]);            \\n        }\\n        if(k<n) ans=max(ans,nums[k]);           \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844201,
                "title": "simple-and-short-9-lines-of-code-c-solution-greedy",
                "content": "If you like my solution please upvote it .\\n\\n```\\nint maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size(),maxn=nums[0];\\n        if(k%2&&n==1)return -1;\\n        else if(k==1)return nums[1];\\n        \\n        if(k<=n)\\n            for(int i=0;i<=k&&i<n;i++)\\n            {\\n                if(i==k-1)continue;\\n                maxn=max(maxn,nums[i]);\\n            }   \\n        else for(int i=0;i<n;i++) maxn=max(maxn,nums[i]);\\n        return maxn;\\n    }\\n```\\nIf you have any doubts , please write it in comments.",
                "solutionTags": [],
                "code": "```\\nint maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size(),maxn=nums[0];\\n        if(k%2&&n==1)return -1;\\n        else if(k==1)return nums[1];\\n        \\n        if(k<=n)\\n            for(int i=0;i<=k&&i<n;i++)\\n            {\\n                if(i==k-1)continue;\\n                maxn=max(maxn,nums[i]);\\n            }   \\n        else for(int i=0;i<n;i++) maxn=max(maxn,nums[i]);\\n        return maxn;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844171,
                "title": "c-max-heap-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        \\n        if(k==0)\\n            return nums[0];\\n        \\n        if(nums.size()==1)\\n        {\\n            if(k%2==0)\\n                return nums[0];\\n            else\\n                return -1;\\n        }\\n        \\n        if(nums.size()==2)\\n        {\\n            if(k==1)\\n                return nums[1];\\n            else\\n            {\\n                if(k==2)\\n                    return nums[0];\\n                else\\n                    return max(nums[0], nums[1]);\\n            }\\n        }\\n        \\n        if(k>nums.size())\\n            return *max_element(nums.begin(), nums.end());\\n           \\n        for(int i=0; i<k-1; i++)\\n            pq.push(nums[i]);\\n            \\n        if(pq.size())\\n            if(k<nums.size())\\n                return max(nums[k], pq.top());\\n            else\\n                return pq.top();\\n        else\\n            return nums[1];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        \\n        if(k==0)\\n            return nums[0];\\n        \\n        if(nums.size()==1)\\n        {\\n            if(k%2==0)\\n                return nums[0];\\n            else\\n                return -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1844147,
                "title": "python3-simple-o-n-solution",
                "content": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        if n == 1 and k%2 == 1:\\n            return -1\\n        if k == 0:\\n            return nums[0]\\n        if k == 1:\\n            return nums[1]\\n        if k > n:\\n            return max(nums)\\n        if k == n:\\n            return max(nums[:k-1])\\n        if k < n:\\n            return max(max(nums[:k-1]),nums[k])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        if n == 1 and k%2 == 1:\\n            return -1\\n        if k == 0:\\n            return nums[0]\\n        if k == 1:\\n            return nums[1]\\n        if k > n:\\n            return max(nums)\\n        if k == n:\\n            return max(nums[:k-1])\\n        if k < n:\\n            return max(max(nums[:k-1]),nums[k])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844123,
                "title": "python-solution-using-simulation-with-example-handles-edge-cases-o-min-k-n",
                "content": "Consider the example:\\n[5,2,6,7,3,4]\\n\\nso here probable elements at the top for every k:\\nk = 1 -> [2]\\nk = 2 -> [5,6]\\nk = 3 -> [2,5,7]\\nk = 4 -> [5,2,6,3]\\nk = 5 -> [2,5,6,7,4]\\nk = 6 -> [5,2,6,7,3,4]\\nand for k > len(nums) ans is max(nums)\\n\\nAbove you can find that every element can be the topmost except for the (k-1)th element\\n, thus iterating from 0 - min(k,len(nums)) gives the ans.\\n\\n** Note: if len(nums) = 1, i.e for nums = [2], then here for every odd value of k the ans should be -1 (no elements in array), and for every even k ans is nums[0].\\n\\n```\\ndef maximumTop(self, nums: List[int], k: int) -> int:\\n        \\n        if len(nums)==1 and k%2!=0:\\n            return -1\\n        \\n        maximum = 0\\n        for i in range(min(len(nums),k+1)):\\n            if i != k-1:\\n                maximum = max(maximum,nums[i])\\n        return maximum\\n```\\n\\nPlease like the solution if you find it useful.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\ndef maximumTop(self, nums: List[int], k: int) -> int:\\n        \\n        if len(nums)==1 and k%2!=0:\\n            return -1\\n        \\n        maximum = 0\\n        for i in range(min(len(nums),k+1)):\\n            if i != k-1:\\n                maximum = max(maximum,nums[i])\\n        return maximum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1844118,
                "title": "priority-queue-easy-java",
                "content": "```\\n/**\\n    * We need to find maximum so using priority queue in reverse order\\n    */\\n    public int maximumTop(int[] nums, int k) {\\n        \\n        // corner cases\\n        if ( k % 2 != 0 && nums.length == 1 )  return -1; // k is odd then arr must empty after k steps\\n        if ( k % 2 == 0 && nums.length == 1 )  return nums[0]; // k is even we have options to add element back to arr\\n        if ( k == 0) return nums[0];\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int i = 0;\\n\\n        int backUp = k ;\\n        while ( k > 1 && pq.size() < nums.length){ // keep 1 step for comparing \\n            k--;\\n            pq.add(nums[i]);\\n            i++;\\n        }\\n        \\n        if (  i >= nums.length ) return pq.peek(); // all element is visited\\n        else{\\n            int currentPeek = pq.size() == 0 ? -1 : pq.remove(); \\n            if ( i + 1 < nums.length) return Math.max( currentPeek, nums[i+1]);\\n            else return currentPeek;\\n        }\\n        \\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\n/**\\n    * We need to find maximum so using priority queue in reverse order\\n    */\\n    public int maximumTop(int[] nums, int k) {\\n        \\n        // corner cases\\n        if ( k % 2 != 0 && nums.length == 1 )  return -1; // k is odd then arr must empty after k steps\\n        if ( k % 2 == 0 && nums.length == 1 )  return nums[0]; // k is even we have options to add element back to arr\\n        if ( k == 0) return nums[0];\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int i = 0;\\n\\n        int backUp = k ;\\n        while ( k > 1 && pq.size() < nums.length){ // keep 1 step for comparing \\n            k--;\\n            pq.add(nums[i]);\\n            i++;\\n        }\\n        \\n        if (  i >= nums.length ) return pq.peek(); // all element is visited\\n        else{\\n            int currentPeek = pq.size() == 0 ? -1 : pq.remove(); \\n            if ( i + 1 < nums.length) return Math.max( currentPeek, nums[i+1]);\\n            else return currentPeek;\\n        }\\n        \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1844115,
                "title": "c-recursive-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\n\\t// Max Heap\\n    priority_queue<int> pq;\\npublic:\\n\\t// Get Max of Max Heap\\n    int getmax() {\\n        if(pq.empty()) return -1;\\n        return pq.top();\\n    }\\n    \\n    int helper(vector<int>& nums, int k, int i) {\\n        // if we have crossed the bound of array, we only can pop from heap\\n\\t\\t// if there is only one element in heap, based on the k left are even or odd we get ans\\n\\t\\t// if there are more than one element in heap there is always a way to get max if we have moves left\\n        if(i >= nums.size()) {\\n            if(pq.size() == 1) {\\n                if(k % 2) return getmax();\\n                return -1;\\n            }\\n            if(k) return getmax();\\n            return -1;\\n        }\\n        \\n        // if we have one last option to choose we can take max from the heap or the i+1th element\\n        if(k == 1) {\\n            if(i+1 < nums.size()) return max(nums[i+1], getmax());\\n            return getmax();\\n        }\\n        \\n        pq.push(nums[i]);\\n        return helper(nums, k-1, i+1);\\n    }\\n    \\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k == 0) return nums[0];\\n        return helper(nums, k, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n\\t// Max Heap\\n    priority_queue<int> pq;\\npublic:\\n\\t// Get Max of Max Heap\\n    int getmax() {\\n        if(pq.empty()) return -1;\\n        return pq.top();\\n    }\\n    \\n    int helper(vector<int>& nums, int k, int i) {\\n        // if we have crossed the bound of array, we only can pop from heap\\n\\t\\t// if there is only one element in heap, based on the k left are even or odd we get ans\\n\\t\\t// if there are more than one element in heap there is always a way to get max if we have moves left\\n        if(i >= nums.size()) {\\n            if(pq.size() == 1) {\\n                if(k % 2) return getmax();\\n                return -1;\\n            }\\n            if(k) return getmax();\\n            return -1;\\n        }\\n        \\n        // if we have one last option to choose we can take max from the heap or the i+1th element\\n        if(k == 1) {\\n            if(i+1 < nums.size()) return max(nums[i+1], getmax());\\n            return getmax();\\n        }\\n        \\n        pq.push(nums[i]);\\n        return helper(nums, k-1, i+1);\\n    }\\n    \\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k == 0) return nums[0];\\n        return helper(nums, k, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844110,
                "title": "java-code-all-cases-dicussed-single-arrayscan-stack",
                "content": "```\\n    //contest ANS ::::: 3\\n\\t// Single Array Scan\\n\\n    public int maximumTop(int[] nums, int k) {\\n        int numberCount = nums.length;\\n        if (numberCount == 1 && (k % 2 == 1)) {\\n            return -1;\\n        }\\n        \\n        int largestTop = -1;\\n        for (int i = 0; i < numberCount; i++) {\\n            if (i == k || k > i + 1) {\\n                largestTop = Math.max(largestTop, nums[i]);\\n            }\\n        }\\n        \\n        return largestTop;\\n    }\\n\\n```\\n\\n\\n\\n\\n```\\n    //contest ANS ::::: 3\\n    public int maximumTop(int[] nums, int k) {\\n        if (nums.length == 0) return -1;\\n        if (nums.length == 1&& k %2 == 1) return -1;\\n        if (k> nums.length) { // if k>nums.length just return the max of the array;\\n            int maxOfArray = 0;\\n            for (int i : nums) {maxOfArray = Math.max(maxOfArray, i);}\\n            return maxOfArray;\\n        }\\n\\n        int max = 0;//for ans;\\n\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = nums.length-1; i >=0; i--) {//pushing elements in reverse order; so that at the time of popoing we get the elements in real array oredering\\n            stack.push(nums[i]);\\n        }\\n        int index = 0;//we will do the poping for only k-1 times ;beacuse if the stack .peek() is less then previes max then push previous max on the stack at the last move;\\n        while (index<k-1){\\n            max = Math.max(stack.pop(), max);\\n\\n            index++;\\n        }\\n        if (k+1<= nums.length) max = Math.max(nums[k],max); // this is for the case where the element below the stack.peek()>stack.peek();\\n\\n\\n        return max;\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n    //contest ANS ::::: 3\\n\\t// Single Array Scan\\n\\n    public int maximumTop(int[] nums, int k) {\\n        int numberCount = nums.length;\\n        if (numberCount == 1 && (k % 2 == 1)) {\\n            return -1;\\n        }\\n        \\n        int largestTop = -1;\\n        for (int i = 0; i < numberCount; i++) {\\n            if (i == k || k > i + 1) {\\n                largestTop = Math.max(largestTop, nums[i]);\\n            }\\n        }\\n        \\n        return largestTop;\\n    }\\n\\n```\n```\\n    //contest ANS ::::: 3\\n    public int maximumTop(int[] nums, int k) {\\n        if (nums.length == 0) return -1;\\n        if (nums.length == 1&& k %2 == 1) return -1;\\n        if (k> nums.length) { // if k>nums.length just return the max of the array;\\n            int maxOfArray = 0;\\n            for (int i : nums) {maxOfArray = Math.max(maxOfArray, i);}\\n            return maxOfArray;\\n        }\\n\\n        int max = 0;//for ans;\\n\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = nums.length-1; i >=0; i--) {//pushing elements in reverse order; so that at the time of popoing we get the elements in real array oredering\\n            stack.push(nums[i]);\\n        }\\n        int index = 0;//we will do the poping for only k-1 times ;beacuse if the stack .peek() is less then previes max then push previous max on the stack at the last move;\\n        while (index<k-1){\\n            max = Math.max(stack.pop(), max);\\n\\n            index++;\\n        }\\n        if (k+1<= nums.length) max = Math.max(nums[k],max); // this is for the case where the element below the stack.peek()>stack.peek();\\n\\n\\n        return max;\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844097,
                "title": "c-greedy",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size() == 1) return k % 2 ? -1 : nums[0];\\n        if(k == 0) return nums[0];\\n        int mx = 0, j = 0;\\n        while(k > 1 && j < nums.size()) {\\n            mx = max(nums[j], mx);\\n            j++;\\n            k--;\\n        }\\n        if(j + 1 < nums.size() && nums[j + 1] > mx) return nums[j + 1];\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size() == 1) return k % 2 ? -1 : nums[0];\\n        if(k == 0) return nums[0];\\n        int mx = 0, j = 0;\\n        while(k > 1 && j < nums.size()) {\\n            mx = max(nums[j], mx);\\n            j++;\\n            k--;\\n        }\\n        if(j + 1 < nums.size() && nums[j + 1] > mx) return nums[j + 1];\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844090,
                "title": "commented-simple-condition-c",
                "content": "```\\n int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(!k)\\n            return nums[0]; // just take the top element\\n        if(n == 1 && (k&1))\\n            return -1;  // we can\\'t take element (you can try it)\\n        if(k==1){\\n            return nums[1]; // we have to take 2nd element\\n        }\\n        if(k > n){\\n            return *max_element(nums.begin(), nums.end()); // we can always take any element if k>n;\\n        }\\n        \\n        int mx = *max_element(nums.begin(), nums.begin()+k-1);\\n        return max(mx,nums[k%n]);   // either we can take max element of first k-2 element or we can take kth element (0 indexing)\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(!k)\\n            return nums[0]; // just take the top element\\n        if(n == 1 && (k&1))\\n            return -1;  // we can\\'t take element (you can try it)\\n        if(k==1){\\n            return nums[1]; // we have to take 2nd element\\n        }\\n        if(k > n){\\n            return *max_element(nums.begin(), nums.end()); // we can always take any element if k>n;\\n        }\\n        \\n        int mx = *max_element(nums.begin(), nums.begin()+k-1);\\n        return max(mx,nums[k%n]);   // either we can take max element of first k-2 element or we can take kth element (0 indexing)\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4065879,
                "title": "c-simplest-code-explained",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) \\n    {\\n        int ans = -1;\\n\\n        // If size of nums is 1 and odd num of moves are made, then only option would be to return -1.\\n        if(nums.size() == 1 and k%2 == 1) return ans;\\n\\n        // Otherwise just return the max element within k indices. Except for the element at k-1th index, which can\\'t ever be at the top, no matter what moves we follow.\\n        for(int i=0; i<=k and i<nums.size(); i++) \\n            if(i != k-1) ans = max(ans, nums[i]);\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) \\n    {\\n        int ans = -1;\\n\\n        // If size of nums is 1 and odd num of moves are made, then only option would be to return -1.\\n        if(nums.size() == 1 and k%2 == 1) return ans;\\n\\n        // Otherwise just return the max element within k indices. Except for the element at k-1th index, which can\\'t ever be at the top, no matter what moves we follow.\\n        for(int i=0; i<=k and i<nums.size(); i++) \\n            if(i != k-1) ans = max(ans, nums[i]);\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011985,
                "title": "c-easy-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumTop(int[] nums, int k) {\\n        if (nums.Length == 1){\\n            return (k & 1) == 1 ? -1 : nums[0];\\n        }\\n        \\n        int length = Math.Min(k, nums.Length - 1);\\n        int result = int.MinValue;\\n        for (int i = 0; i <= length; i++){\\n            if (i == k - 1){\\n                continue;\\n            }\\n            if (result < nums[i]){\\n                result = nums[i];\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumTop(int[] nums, int k) {\\n        if (nums.Length == 1){\\n            return (k & 1) == 1 ? -1 : nums[0];\\n        }\\n        \\n        int length = Math.Min(k, nums.Length - 1);\\n        int result = int.MinValue;\\n        for (int i = 0; i <= length; i++){\\n            if (i == k - 1){\\n                continue;\\n            }\\n            if (result < nums[i]){\\n                result = nums[i];\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004634,
                "title": "c-greedy-o-n-99-faster",
                "content": "# Please UpVote if it helps you\\nApproach - if `k< nums.size()` then in answer `nums[k]` can\\'t be there.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0)return nums[0];\\n        if(k==1){\\n            if(nums.size()==1)return -1;\\n            else nums[1];\\n        }\\n        if(nums.size()==1){\\n            return k%2 ? -1:nums[0];\\n        }\\n        if(k>nums.size())return *max_element(nums.begin(),nums.end());\\n        int ans = 0;\\n        for(int i=0;i<k-1;++i){\\n            ans = max(ans,nums[i]);\\n        }\\n        if(k<nums.size())ans = max(ans,nums[k]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(k==0)return nums[0];\\n        if(k==1){\\n            if(nums.size()==1)return -1;\\n            else nums[1];\\n        }\\n        if(nums.size()==1){\\n            return k%2 ? -1:nums[0];\\n        }\\n        if(k>nums.size())return *max_element(nums.begin(),nums.end());\\n        int ans = 0;\\n        for(int i=0;i<k-1;++i){\\n            ans = max(ans,nums[i]);\\n        }\\n        if(k<nums.size())ans = max(ans,nums[k]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001091,
                "title": "beats-95-o-n-simple-if-and-elif-statements-with-extra-testcases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximumTop(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        length=len(nums)\\n        if(k==0):\\n            return nums[0]\\n        if(length==1): \\n            if(k%2==0):\\n                return nums[0]\\n            return -1\\n        if(k>length): #  for this type of testcase [5,2,2,4] for k=5 or k>4\\n            return max(nums)\\n        if(k==length):# for this type of testcase [5,2,2,4] for k=4\\n            maxi=nums[0]\\n            while(k>1):\\n                maxi=max(maxi,nums.pop(0))\\n                k-=1\\n            return maxi\\n        if(k<length): # for this type of test case [1,2,1000000000] for k=2;\\n            maxi=-10**5\\n            if(k==1):\\n                return nums[1]\\n            while(k>1):\\n                maxi=max(maxi,nums.pop(0))\\n                k-=1\\n            if(maxi<nums[1]):\\n                return nums[1]\\n            return maxi\\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumTop(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        length=len(nums)\\n        if(k==0):\\n            return nums[0]\\n        if(length==1): \\n            if(k%2==0):\\n                return nums[0]\\n            return -1\\n        if(k>length): #  for this type of testcase [5,2,2,4] for k=5 or k>4\\n            return max(nums)\\n        if(k==length):# for this type of testcase [5,2,2,4] for k=4\\n            maxi=nums[0]\\n            while(k>1):\\n                maxi=max(maxi,nums.pop(0))\\n                k-=1\\n            return maxi\\n        if(k<length): # for this type of test case [1,2,1000000000] for k=2;\\n            maxi=-10**5\\n            if(k==1):\\n                return nums[1]\\n            while(k>1):\\n                maxi=max(maxi,nums.pop(0))\\n                k-=1\\n            if(maxi<nums[1]):\\n                return nums[1]\\n            return maxi\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996467,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        priority_queue<int>pq ; \\n        int n = nums.size() ; \\n        \\n         if(n==1 && k&1)\\n             return -1 ; \\n        else if(n==1)\\n            return nums[0] ;\\n        else if(k==1)\\n            return nums[1] ;\\n        else if(k==0)\\n            return nums[0] ; \\n        else if( k>n )\\n        {\\n            return *max_element(begin(nums), end(nums)) ;\\n        }\\n        else if(k==n)\\n            return *max_element(begin(nums), nums.begin()+nums.size()-1 );\\n        \\n        for(int i =0 ; i<k-1; i++ )\\n        {\\n            pq.push(nums[i]) ;\\n        }\\n        \\n        return max(nums[k] , pq.top()) ; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        \\n        priority_queue<int>pq ; \\n        int n = nums.size() ; \\n        \\n         if(n==1 && k&1)\\n             return -1 ; \\n        else if(n==1)\\n            return nums[0] ;\\n        else if(k==1)\\n            return nums[1] ;\\n        else if(k==0)\\n            return nums[0] ; \\n        else if( k>n )\\n        {\\n            return *max_element(begin(nums), end(nums)) ;\\n        }\\n        else if(k==n)\\n            return *max_element(begin(nums), nums.begin()+nums.size()-1 );\\n        \\n        for(int i =0 ; i<k-1; i++ )\\n        {\\n            pq.push(nums[i]) ;\\n        }\\n        \\n        return max(nums[k] , pq.top()) ; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994369,
                "title": "simplest-o-k-js-solution-using-only-linear-maximum-search",
                "content": "# Code\\n```\\nvar maximumTop = function(nums, k) {\\n    if (nums.length === 1 && k % 2) return -1\\n    let max = -Infinity\\n\\n    for (let i = 0; i <= k && i < nums.length; i++) {\\n        if (i === k - 1) continue\\n        if (nums[i] > max) max = nums[i]\\n    }\\n\\n    return max > -Infinity ? max : -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar maximumTop = function(nums, k) {\\n    if (nums.length === 1 && k % 2) return -1\\n    let max = -Infinity\\n\\n    for (let i = 0; i <= k && i < nums.length; i++) {\\n        if (i === k - 1) continue\\n        if (nums[i] > max) max = nums[i]\\n    }\\n\\n    return max > -Infinity ? max : -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3990663,
                "title": "easiest-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```javascript []\\n\\nvar maximumTop = function(nums, k) {\\n    if (nums.length == 1 )\\n        return k % 2 == 1 ? -1 : nums[0]\\n        \\n    if (k < 2)\\n        return nums[k]\\n    \\n    if (k > nums.length)\\n        return Math.max(...nums)\\n    \\n    return Math.max(...nums.slice(0, k-1).concat(nums.slice(k, k+1)))\\n};\\n```\\n\\n```python []\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1:\\n            return -1 if k % 2 == 1 else nums[0]\\n        \\n        if k < 2:\\n            return nums[k]\\n        \\n        if k > len(nums):\\n            return max(nums)\\n        \\n        return max(nums[:k-1] + nums[k:k+1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```javascript []\\n\\nvar maximumTop = function(nums, k) {\\n    if (nums.length == 1 )\\n        return k % 2 == 1 ? -1 : nums[0]\\n        \\n    if (k < 2)\\n        return nums[k]\\n    \\n    if (k > nums.length)\\n        return Math.max(...nums)\\n    \\n    return Math.max(...nums.slice(0, k-1).concat(nums.slice(k, k+1)))\\n};\\n```\n```python []\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1:\\n            return -1 if k % 2 == 1 else nums[0]\\n        \\n        if k < 2:\\n            return nums[k]\\n        \\n        if k > len(nums):\\n            return max(nums)\\n        \\n        return max(nums[:k-1] + nums[k:k+1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978381,
                "title": "concise-o-min-k-n-and-o-1-rust",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn maximum_top(nums: Vec<i32>, k: i32) -> i32 {\\n        if k == 0 { return nums[0] };\\n\\n        let n = nums.len();\\n        let mut k = k as usize;\\n        let mut ans = (0..n.min(k-1)).fold(-1, |acc, i| acc.max(nums[i]));\\n\\n        if k >= n {\\n            if n == 1 && k % 2 == 1 { -1 }\\n            else { ans }\\n        } else { ans.max(nums[k]) }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_top(nums: Vec<i32>, k: i32) -> i32 {\\n        if k == 0 { return nums[0] };\\n\\n        let n = nums.len();\\n        let mut k = k as usize;\\n        let mut ans = (0..n.min(k-1)).fold(-1, |acc, i| acc.max(nums[i]));\\n\\n        if k >= n {\\n            if n == 1 && k % 2 == 1 { -1 }\\n            else { ans }\\n        } else { ans.max(nums[k]) }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3940917,
                "title": "three-observations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to consider three cases only \\n\\n1) If the size of nums is 1 then, if k is even then we can get the element at the top , if k is odd then we will not be able to get element and therefore return -1.\\n\\n2) If the k is 1, then we will get the second element only if it exists.\\n\\n3) Now, Consider the maximum element among first k - 1 elements,  and the element that is present at the kth position, whichever is the maximum return that. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n\\n        \\n        int numSize = nums.size();\\n\\n        if(numSize == 1) {\\n            if(k%2 != 0) return -1;\\n            else nums[0];\\n        }\\n\\n        if(k == 1) {\\n            return nums[1];\\n        }\\n\\n        if(k > numSize) {\\n            \\n            int maxi = 0;\\n            \\n            for(int i = 0; i < numSize; i++) {\\n                if(nums[i] > maxi) {\\n                    maxi = nums[i];\\n                }\\n            }\\n            \\n            return maxi;\\n\\n        }\\n\\n        int maxi_idx;\\n        int maxi = 0;\\n\\n        for(int i = 0; i <= k; i++) {\\n            if(nums[i] >= maxi) {\\n                maxi = nums[i];\\n                maxi_idx = i;\\n            }\\n        }\\n\\n        if(maxi_idx == k) {\\n            return maxi;\\n        }\\n\\n        maxi = 0;\\n\\n        for(int i = 0; i < k - 1; i++) {\\n            if(nums[i] >= maxi) {\\n                maxi = nums[i];\\n            }\\n        }\\n\\n        maxi = max(maxi, nums[k]);\\n\\n        return maxi;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n\\n        \\n        int numSize = nums.size();\\n\\n        if(numSize == 1) {\\n            if(k%2 != 0) return -1;\\n            else nums[0];\\n        }\\n\\n        if(k == 1) {\\n            return nums[1];\\n        }\\n\\n        if(k > numSize) {\\n            \\n            int maxi = 0;\\n            \\n            for(int i = 0; i < numSize; i++) {\\n                if(nums[i] > maxi) {\\n                    maxi = nums[i];\\n                }\\n            }\\n            \\n            return maxi;\\n\\n        }\\n\\n        int maxi_idx;\\n        int maxi = 0;\\n\\n        for(int i = 0; i <= k; i++) {\\n            if(nums[i] >= maxi) {\\n                maxi = nums[i];\\n                maxi_idx = i;\\n            }\\n        }\\n\\n        if(maxi_idx == k) {\\n            return maxi;\\n        }\\n\\n        maxi = 0;\\n\\n        for(int i = 0; i < k - 1; i++) {\\n            if(nums[i] >= maxi) {\\n                maxi = nums[i];\\n            }\\n        }\\n\\n        maxi = max(maxi, nums[k]);\\n\\n        return maxi;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928639,
                "title": "easy-soln-beats-100-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n            int n = nums.size();\\n            if(k > n){\\n                 if(n == 1){\\n                     if(k%2 == 0){ // pop-push cycle \\n                         return nums[0];\\n                     }\\n                     return -1;  // no cycle\\n                 }\\n                return *max_element(nums.begin(),nums.end());\\n            }\\n            if(k == 1){\\n                if(n == 1){\\n                    return -1;\\n                }\\n                return nums[1];\\n            }\\n            \\n            if(k == n){\\n                return *max_element(nums.begin(),nums.begin()+k-1);\\n            }\\n\\n            int maxi = nums[k];\\n            int maxi1 = INT_MIN;\\n\\n    for(int i = 0; i <k-1;i++){  //iterating k-1,to push maxi1 atlast\\n        maxi1 = max(maxi1,nums[i]);\\n    }\\n\\n\\n\\n\\n\\n\\n\\n          \\n          return max(maxi,maxi1);\\n           \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n            int n = nums.size();\\n            if(k > n){\\n                 if(n == 1){\\n                     if(k%2 == 0){ // pop-push cycle \\n                         return nums[0];\\n                     }\\n                     return -1;  // no cycle\\n                 }\\n                return *max_element(nums.begin(),nums.end());\\n            }\\n            if(k == 1){\\n                if(n == 1){\\n                    return -1;\\n                }\\n                return nums[1];\\n            }\\n            \\n            if(k == n){\\n                return *max_element(nums.begin(),nums.begin()+k-1);\\n            }\\n\\n            int maxi = nums[k];\\n            int maxi1 = INT_MIN;\\n\\n    for(int i = 0; i <k-1;i++){  //iterating k-1,to push maxi1 atlast\\n        maxi1 = max(maxi1,nums[i]);\\n    }\\n\\n\\n\\n\\n\\n\\n\\n          \\n          return max(maxi,maxi1);\\n           \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892129,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int m=-1e9;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i<=k)\\n            {\\n                if(i!=k-1)\\n                {\\n            if(nums[i]>m)\\n            m=nums[i];\\n                }\\n            }\\n            else\\n            break;\\n        }\\n         if(n==1 && k%2!=0)\\n         return -1;\\n         else\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int m=-1e9;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i<=k)\\n            {\\n                if(i!=k-1)\\n                {\\n            if(nums[i]>m)\\n            m=nums[i];\\n                }\\n            }\\n            else\\n            break;\\n        }\\n         if(n==1 && k%2!=0)\\n         return -1;\\n         else\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873711,
                "title": "c-implementation-using-deque-and-priority-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1 && k%2){\\n            return -1;\\n        }\\n        if(k>nums.size()){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        deque<int>dq;\\n        for(auto x:nums){\\n            dq.push_back(x);\\n        }\\n        priority_queue<int>pq;\\n        \\n        if(k==0){\\n            return dq.front();\\n        }\\n        k--;\\n        while(k--){\\n            pq.push(dq.front());\\n            dq.pop_front();\\n        }\\n        if(pq.empty()==true){\\n            dq.pop_front();\\n            if(dq.empty()){\\n                return  -1;\\n            }\\n            else{\\n                return dq.front();\\n            }\\n\\n        }\\n        else{\\n            if(dq.size()>=2){\\n                // pq.push(dq.front());\\n                dq.pop_front();\\n                return max(pq.top(),dq.front());\\n            }\\n            else if(dq.size()==1){\\n               \\n                return pq.top();\\n            }\\n            else\\n            {\\n                return pq.top();\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1 && k%2){\\n            return -1;\\n        }\\n        if(k>nums.size()){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        deque<int>dq;\\n        for(auto x:nums){\\n            dq.push_back(x);\\n        }\\n        priority_queue<int>pq;\\n        \\n        if(k==0){\\n            return dq.front();\\n        }\\n        k--;\\n        while(k--){\\n            pq.push(dq.front());\\n            dq.pop_front();\\n        }\\n        if(pq.empty()==true){\\n            dq.pop_front();\\n            if(dq.empty()){\\n                return  -1;\\n            }\\n            else{\\n                return dq.front();\\n            }\\n\\n        }\\n        else{\\n            if(dq.size()>=2){\\n                // pq.push(dq.front());\\n                dq.pop_front();\\n                return max(pq.top(),dq.front());\\n            }\\n            else if(dq.size()==1){\\n               \\n                return pq.top();\\n            }\\n            else\\n            {\\n                return pq.top();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852427,
                "title": "very-simple-t-c-o-n-s-p-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==1 && k&1)return -1;\\n         int mx=-1;\\n         if(k>n)k=n+1;\\n\\n        for(int i=0;i<k-1;i++)\\n        {\\n            mx=max(mx,nums[i]);\\n        }\\n        if(k<n)\\n        {\\n            mx=max(mx,nums[k]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==1 && k&1)return -1;\\n         int mx=-1;\\n         if(k>n)k=n+1;\\n\\n        for(int i=0;i<k-1;i++)\\n        {\\n            mx=max(mx,nums[i]);\\n        }\\n        if(k<n)\\n        {\\n            mx=max(mx,nums[k]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836861,
                "title": "100-time-and-space-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1&&k%2==1){\\n            return -1;\\n        }\\n        int ans=0;\\n        if(k>nums.size()){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        if(k-1>0){\\n        ans=*max_element(nums.begin(),nums.begin()+k-1);}\\n        if(k<nums.size()){\\n        ans=max(nums[k],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1&&k%2==1){\\n            return -1;\\n        }\\n        int ans=0;\\n        if(k>nums.size()){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        if(k-1>0){\\n        ans=*max_element(nums.begin(),nums.begin()+k-1);}\\n        if(k<nums.size()){\\n        ans=max(nums[k],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798718,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int ans = -1;\\n        int poolLargest = -1;\\n        int poolSize = 0;\\n        for (int i = 0; i < nums.size(); ++i){\\n            if (k % 2 == 1 && poolSize > 0)\\n                ans = max(ans, poolLargest);\\n            else if (k % 2 == 0)\\n                ans = max(ans, nums[i]);\\n            poolLargest = max(poolLargest, nums[i]);\\n            ++poolSize;\\n            if (k-- == 0) return ans;\\n        }\\n        if (k <= 0) return ans;\\n        if ((k % 2 == 0 && poolSize > 1) || k % 2 == 1) \\n            ans = max(ans, poolLargest);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int ans = -1;\\n        int poolLargest = -1;\\n        int poolSize = 0;\\n        for (int i = 0; i < nums.size(); ++i){\\n            if (k % 2 == 1 && poolSize > 0)\\n                ans = max(ans, poolLargest);\\n            else if (k % 2 == 0)\\n                ans = max(ans, nums[i]);\\n            poolLargest = max(poolLargest, nums[i]);\\n            ++poolSize;\\n            if (k-- == 0) return ans;\\n        }\\n        if (k <= 0) return ans;\\n        if ((k % 2 == 0 && poolSize > 1) || k % 2 == 1) \\n            ans = max(ans, poolLargest);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793244,
                "title": "very-easy-reachable-index-better-than-99",
                "content": "# Intuition\\nThe index that can we reachable with given operations. Thats it . Just Think !!!\\uD83D\\uDE07\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n=nums.length;\\n        if(k%2==1&&n==1)return -1;\\n        \\n        int maxi=0;\\n        int x=0;\\n        x=Math.min(k-2,n-1);\\n        for(int i=0;i<=x;i++){\\n            maxi=Math.max(maxi,nums[i]);\\n        }\\n        if(k<n)\\n            maxi=Math.max(maxi,nums[k]);\\n        return maxi;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int n=nums.length;\\n        if(k%2==1&&n==1)return -1;\\n        \\n        int maxi=0;\\n        int x=0;\\n        x=Math.min(k-2,n-1);\\n        for(int i=0;i<=x;i++){\\n            maxi=Math.max(maxi,nums[i]);\\n        }\\n        if(k<n)\\n            maxi=Math.max(maxi,nums[k]);\\n        return maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785788,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1 && k%2!=0)return -1;\\n        int l=0;\\n        int h=0;\\n        int o=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i<k-1){\\n                l=max(l,nums[i]);\\n            }\\n            else if(i==k)h=nums[i];\\n            o=max(o,nums[i]);\\n        }\\n        int ans=0;\\n        if(nums.size()>=k)ans=max(l,h);\\n        else if(nums.size()<k)ans=max({l,h,o});\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(nums.size()==1 && k%2!=0)return -1;\\n        int l=0;\\n        int h=0;\\n        int o=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i<k-1){\\n                l=max(l,nums[i]);\\n            }\\n            else if(i==k)h=nums[i];\\n            o=max(o,nums[i]);\\n        }\\n        int ans=0;\\n        if(nums.size()>=k)ans=max(l,h);\\n        else if(nums.size()<k)ans=max({l,h,o});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783200,
                "title": "easy-python-implimentation",
                "content": "# Easy python implimentation\\n# Code\\n```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if k == 0:\\n            return nums[0]\\n        elif len(nums) == 1:\\n            if k%2 == 0:\\n                return nums[0] \\n            else:\\n                return -1\\n        elif k ==1:\\n            return nums[1]\\n        elif len(nums) <= k:\\n            num_array = []\\n            for i in range(len(nums) -1):\\n                num_array.append(nums[i])\\n            num_array.sort(reverse = True)\\n            print(len(nums))\\n            print(num_array)\\n            if k == (len(num_array) +1):\\n                return num_array[0]\\n            elif nums[-1] > num_array[0]:\\n                return nums[-1]\\n            else:\\n                return num_array[0]\\n        else:\\n            new_arr = []\\n            for i in range(0,(k-1)):\\n                new_arr.append(nums[0])\\n                nums.pop(0)\\n            new_arr.sort(reverse = True)\\n            print(new_arr)\\n            for j in new_arr:\\n                print(j)\\n                print(nums[1])\\n                print(nums[0])\\n                if(j < nums[1]):\\n                    nums.pop(0)\\n                    print(1)\\n                    break\\n                elif (j > nums[0]):\\n                    nums.insert(0,j)\\n                    print(2)\\n                    break\\n                elif (j > nums[1]):\\n                    nums.insert(0,j)\\n                    break\\n                else:\\n                    nums.pop(0)\\n                    print(3)\\n                    break\\n            if len(nums) == 0:\\n                return -1\\n            else:\\n                return nums[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if k == 0:\\n            return nums[0]\\n        elif len(nums) == 1:\\n            if k%2 == 0:\\n                return nums[0] \\n            else:\\n                return -1\\n        elif k ==1:\\n            return nums[1]\\n        elif len(nums) <= k:\\n            num_array = []\\n            for i in range(len(nums) -1):\\n                num_array.append(nums[i])\\n            num_array.sort(reverse = True)\\n            print(len(nums))\\n            print(num_array)\\n            if k == (len(num_array) +1):\\n                return num_array[0]\\n            elif nums[-1] > num_array[0]:\\n                return nums[-1]\\n            else:\\n                return num_array[0]\\n        else:\\n            new_arr = []\\n            for i in range(0,(k-1)):\\n                new_arr.append(nums[0])\\n                nums.pop(0)\\n            new_arr.sort(reverse = True)\\n            print(new_arr)\\n            for j in new_arr:\\n                print(j)\\n                print(nums[1])\\n                print(nums[0])\\n                if(j < nums[1]):\\n                    nums.pop(0)\\n                    print(1)\\n                    break\\n                elif (j > nums[0]):\\n                    nums.insert(0,j)\\n                    print(2)\\n                    break\\n                elif (j > nums[1]):\\n                    nums.insert(0,j)\\n                    break\\n                else:\\n                    nums.pop(0)\\n                    print(3)\\n                    break\\n            if len(nums) == 0:\\n                return -1\\n            else:\\n                return nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782691,
                "title": "find-max",
                "content": "# Approach\\nIf nums.length > 1, then we could pop from and push onto the pile while maintaining nums.length in case k > nums.length.\\n\\nIf nums.length = 1, the moves are fixed and the pile is non-empty if k is even.\\n\\nSuppose k > nums.length, all collections of moves aren\\'t better than the following:\\n1.Remove the topmost element of the pile k-1 times\\n2.Remove one more element from the pile if A[k] > max{A[i] | 0 <= i < k-1}, else add max{A[i] | 0 <= i < k-1} back onto the pile.\\n\\nHence the max. value of the topmost element is max{A[i] | 0 <= i < k-1 or i = k, k > nums.length}\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if k % 2 and len(nums) == 1:\\n            return -1\\n        \\n        Max = -1\\n\\n        for i in range(k-1):\\n            if i == len(nums):\\n                break\\n\\n            Max = max(Max, nums[i])\\n\\n        if k < len(nums):\\n            Max = max(Max, nums[k])\\n        \\n        return Max\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if k % 2 and len(nums) == 1:\\n            return -1\\n        \\n        Max = -1\\n\\n        for i in range(k-1):\\n            if i == len(nums):\\n                break\\n\\n            Max = max(Max, nums[i])\\n\\n        if k < len(nums):\\n            Max = max(Max, nums[k])\\n        \\n        return Max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756223,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        int mx=0;\\n  if(k==0)\\n  return nums[0];\\n  if(n==1&&k%2==0)\\n  return 0;\\nif(n==1&&k%2==1)\\nreturn -1;\\n  if(k<=nums.size())\\n {       for(int i=0;i<k-1;i++)\\n    {\\nif(nums[i]>mx)\\nmx=nums[i];\\n    \\n    }\\n    if(nums[k]>mx)\\n    mx=nums[k];\\n    }\\nelse\\n{\\n     for(int i=0;i<nums.size();i++)\\n    {\\nif(nums[i]>mx)\\nmx=nums[i];\\n    }\\n}\\n    return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n       int n=nums.size();\\n        int mx=0;\\n  if(k==0)\\n  return nums[0];\\n  if(n==1&&k%2==0)\\n  return 0;\\nif(n==1&&k%2==1)\\nreturn -1;\\n  if(k<=nums.size())\\n {       for(int i=0;i<k-1;i++)\\n    {\\nif(nums[i]>mx)\\nmx=nums[i];\\n    \\n    }\\n    if(nums[k]>mx)\\n    mx=nums[k];\\n    }\\nelse\\n{\\n     for(int i=0;i<nums.size();i++)\\n    {\\nif(nums[i]>mx)\\nmx=nums[i];\\n    }\\n}\\n    return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738200,
                "title": "simplest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind maximum within first k-1 member. Then compare the maximum value to k+1 memeber in case k+1th member is higher than those previous values.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) for space to hold maximum value\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) \\n    {\\n        if(nums.size()==1 && k%2==1) return -1;\\n\\n        int out = 0;\\n        int t = min(k-1,(int)nums.size());\\n        for(int i=0;i<t;++i)\\n        {\\n            out=max(out,nums[i]);\\n        }\\n        if(nums.size()>k) return max(out,nums[k]);\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) \\n    {\\n        if(nums.size()==1 && k%2==1) return -1;\\n\\n        int out = 0;\\n        int t = min(k-1,(int)nums.size());\\n        for(int i=0;i<t;++i)\\n        {\\n            out=max(out,nums[i]);\\n        }\\n        if(nums.size()>k) return max(out,nums[k]);\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672995,
                "title": "c-easy-solution-with-if-else-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if((k == 1 or k == 0) && n > 1)return nums[k];\\n\\n        if(n == 1 && k % 2 == 0) return nums[0];\\n\\n        if(k == 2 && n > k)return max(nums[0],nums[k]);\\n    \\n        if(n > 1 && k > n)return *max_element(nums.begin(),nums.end());\\n\\n        if(n > 1 && k <= n){\\n\\n            int val = *max_element(nums.begin(),nums.begin()+k-1);\\n\\n            if(n - k >= 1 && val < nums[k]) val = nums[k];\\n\\n            return val;\\n\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if((k == 1 or k == 0) && n > 1)return nums[k];\\n\\n        if(n == 1 && k % 2 == 0) return nums[0];\\n\\n        if(k == 2 && n > k)return max(nums[0],nums[k]);\\n    \\n        if(n > 1 && k > n)return *max_element(nums.begin(),nums.end());\\n\\n        if(n > 1 && k <= n){\\n\\n            int val = *max_element(nums.begin(),nums.begin()+k-1);\\n\\n            if(n - k >= 1 && val < nums[k]) val = nums[k];\\n\\n            return val;\\n\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667836,
                "title": "java-solution-beats-100-line-to-line-explanation-within-the-code-upvote",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int len = nums.length;\\n        if(k == 1 && nums.length == 1) return -1;\\n\\n        if(k > len){\\n            if(len == 1){\\n                if(k % 2 != 0) return -1; // all the elements will br removed so no element left.\\n            }\\n\\n            int max = Integer.MIN_VALUE;\\n            for(int i = 0; i < nums.length; i++){\\n                max = Math.max(max, nums[i]);\\n            }\\n            return max; // return the maximun element of the nums array\\n        }\\n        else if(k == len){\\n            // find the max elements from index 0 to k-1 in nums array\\n            // int[] t = new int[k-1];\\n            int max = Integer.MIN_VALUE;\\n            for(int i = 0; i < k-1; i++){\\n                max = Math.max(max, nums[i]);\\n            }\\n            \\n            return max;\\n        }\\n        else{\\n            if(k == 0){\\n                return nums[0]; // if k == 0 the element at index 0 is the topmost element.\\n            }\\n            else{\\n                int max = Integer.MIN_VALUE;\\n                for(int i = 0; i < k-1; i++){\\n                    max = Math.max(max, nums[i]);\\n                }\\n\\n                return Math.max(nums[k], max); // the max elements is the max of element at k index and the max element till 0 to k-1 index\\n            }\\n        }\\n\\n    }\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int len = nums.length;\\n        if(k == 1 && nums.length == 1) return -1;\\n\\n        if(k > len){\\n            if(len == 1){\\n                if(k % 2 != 0) return -1; // all the elements will br removed so no element left.\\n            }\\n\\n            int max = Integer.MIN_VALUE;\\n            for(int i = 0; i < nums.length; i++){\\n                max = Math.max(max, nums[i]);\\n            }\\n            return max; // return the maximun element of the nums array\\n        }\\n        else if(k == len){\\n            // find the max elements from index 0 to k-1 in nums array\\n            // int[] t = new int[k-1];\\n            int max = Integer.MIN_VALUE;\\n            for(int i = 0; i < k-1; i++){\\n                max = Math.max(max, nums[i]);\\n            }\\n            \\n            return max;\\n        }\\n        else{\\n            if(k == 0){\\n                return nums[0]; // if k == 0 the element at index 0 is the topmost element.\\n            }\\n            else{\\n                int max = Integer.MIN_VALUE;\\n                for(int i = 0; i < k-1; i++){\\n                    max = Math.max(max, nums[i]);\\n                }\\n\\n                return Math.max(nums[k], max); // the max elements is the max of element at k index and the max element till 0 to k-1 index\\n            }\\n        }\\n\\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633821,
                "title": "simplest-and-easiest-solution-with-intuition-and-explanation-in-c",
                "content": "# Intuition\\nSo basically break the solution in three parts :-\\n1. Base cases\\n2. k <= n\\n3. k > n\\n\\n# Approach\\nFirstly when k <= n, we can say that either our answer can be nums[k] (k != n) by removing first k elements **OR** max(nums[i]) for i in [0, k - 1], as we pop first k - 1 elements and whichever is the maximum we will put back.\\nIn case of k > n, answer is always max of array as in case of odd k we will put and remove the max element and in case of even k we will first put any element and then again put and remove the max element.\\nHandle the cases !!!\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(n == 1 or k == 0){\\n            if(k & 1) return -1;\\n            return nums[0];\\n        }\\n        if(k <= n){\\n            int maxi = INT_MIN;\\n            for(int i = 0; i < k - 1; i++){\\n                maxi = max(maxi, nums[i]);\\n            }\\n            if(k == 1) return nums[1];\\n            return max(maxi, k != n ? nums[k] : 0);\\n        }\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < n; i++) maxi = max(maxi, nums[i]);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(n == 1 or k == 0){\\n            if(k & 1) return -1;\\n            return nums[0];\\n        }\\n        if(k <= n){\\n            int maxi = INT_MIN;\\n            for(int i = 0; i < k - 1; i++){\\n                maxi = max(maxi, nums[i]);\\n            }\\n            if(k == 1) return nums[1];\\n            return max(maxi, k != n ? nums[k] : 0);\\n        }\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < n; i++) maxi = max(maxi, nums[i]);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583085,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) \\n    {\\n        if( k == 0 )\\n        {\\n            return nums[0];\\n        }\\n\\n        if( nums.length == 1 )\\n        {\\n            if( k%2 == 1 ) \\n            {\\n                return -1;\\n            }\\n            return nums[0];\\n        }\\n\\n        if( k > nums.length )\\n        {\\n            int max = -1;\\n            for(int i=0; i<nums.length; i++)\\n            {\\n                if( nums[i] > max )\\n                {\\n                    max = nums[i];\\n                }\\n            }\\n            return max;\\n        }\\n\\n        int max = -1;\\n        int i = 0;\\n\\n        while( k > 1 && i < nums.length)\\n        {\\n            if( nums[i] > max )\\n            {\\n                max = nums[i];\\n            }\\n            i++;\\n            k--;\\n        }\\n\\n        if( (nums.length-i) >= 2 )\\n        {\\n            if( max < nums[i+1])\\n            {\\n                return nums[i+1];\\n            }\\n        }\\n\\n        return max;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) \\n    {\\n        if( k == 0 )\\n        {\\n            return nums[0];\\n        }\\n\\n        if( nums.length == 1 )\\n        {\\n            if( k%2 == 1 ) \\n            {\\n                return -1;\\n            }\\n            return nums[0];\\n        }\\n\\n        if( k > nums.length )\\n        {\\n            int max = -1;\\n            for(int i=0; i<nums.length; i++)\\n            {\\n                if( nums[i] > max )\\n                {\\n                    max = nums[i];\\n                }\\n            }\\n            return max;\\n        }\\n\\n        int max = -1;\\n        int i = 0;\\n\\n        while( k > 1 && i < nums.length)\\n        {\\n            if( nums[i] > max )\\n            {\\n                max = nums[i];\\n            }\\n            i++;\\n            k--;\\n        }\\n\\n        if( (nums.length-i) >= 2 )\\n        {\\n            if( max < nums[i+1])\\n            {\\n                return nums[i+1];\\n            }\\n        }\\n\\n        return max;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576515,
                "title": "easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1:\\n            return -1 if k % 2 else nums[0]\\n        elif not k:\\n            return nums[0]\\n        if k > len(nums):\\n            return max(nums)\\n        elif k == len(nums):\\n            return max(nums[:k-1])\\n        else:\\n            return max(nums[:k-1] + nums[k:k+1])\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1:\\n            return -1 if k % 2 else nums[0]\\n        elif not k:\\n            return nums[0]\\n        if k > len(nums):\\n            return max(nums)\\n        elif k == len(nums):\\n            return max(nums[:k-1])\\n        else:\\n            return max(nums[:k-1] + nums[k:k+1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575921,
                "title": "c-using-stack-and-maxheap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIts all about the last move that you have to work upon, and yes a lot of edge cases need to be solved :) \\nHope you liked it, kindly upvote it, see you in some other solution, Adiossssssssss!!!!!!!!!!!!!!!!!!!!!!!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n       // if(k==1) return -1;\\n        stack<int> st;\\n        int n = nums.size();\\n        for(int i=n-1;i>=0;i--){\\n            st.push(nums[i]);\\n        }\\n        if(k == 0) return st.top();\\n        if(k % 2 == 1 and nums.size() == 1) return -1;\\n        if(k==1){\\n           st.pop();\\n            if(st.size()>0) return st.top();\\n            else return -1;\\n        }\\n        priority_queue<int> pq;\\n        while(k>1 && !st.empty()){\\n            pq.push(st.top());\\n            st.pop();\\n            k--;\\n        }\\n        if(st.empty()) return pq.top();\\n       else{\\n           if(st.size()>1){\\n               st.pop();\\n               return max(pq.top(),st.top());\\n           }\\n           else{\\n               // pq.push(st.top());\\n               return pq.top();\\n           }\\n       }\\n         return -1;\\n        //return st.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n       // if(k==1) return -1;\\n        stack<int> st;\\n        int n = nums.size();\\n        for(int i=n-1;i>=0;i--){\\n            st.push(nums[i]);\\n        }\\n        if(k == 0) return st.top();\\n        if(k % 2 == 1 and nums.size() == 1) return -1;\\n        if(k==1){\\n           st.pop();\\n            if(st.size()>0) return st.top();\\n            else return -1;\\n        }\\n        priority_queue<int> pq;\\n        while(k>1 && !st.empty()){\\n            pq.push(st.top());\\n            st.pop();\\n            k--;\\n        }\\n        if(st.empty()) return pq.top();\\n       else{\\n           if(st.size()>1){\\n               st.pop();\\n               return max(pq.top(),st.top());\\n           }\\n           else{\\n               // pq.push(st.top());\\n               return pq.top();\\n           }\\n       }\\n         return -1;\\n        //return st.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575677,
                "title": "observation-greedy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- observatin \\n- case 2: when **k>nums.size()** means we can pop all the element and we can choose the maximum among them . edge case if nums.size==1 and and k is odd then no possible answer exist .\\n- case 1 : when **nums.size()>=k** when we will pop the element till we are not at k==1 because its last step so either we can pop or push so if we pop then v[i+1] will be top and if we push then maximum element from poped element will be the answer .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) \\n    {\\n        if(nums.size()>=k)\\n        {\\n            return conditionOne(nums,k);\\n        }    \\n        return conditionTwo(nums,k);\\n    }\\n    int conditionOne(vector<int>&nums,int k)\\n    {\\n        if (k==0)return nums[0];\\n        if (k==1)\\n        {\\n            if (nums.size()<2)return -1;\\n            return nums[1];\\n        }\\n        priority_queue<int>pq;\\n        nums.push_back(-1);\\n        int i=0;\\n        for(;k>=1;k--)\\n        {\\n            if (k==1)\\n            {\\n                return max(nums[i+1],pq.top());\\n            }\\n            pq.push(nums[i]);\\n\\n            i++;\\n        }\\n        return 0;\\n    }\\n    int conditionTwo(vector<int>&nums,int k)\\n    {\\n        if (nums.size()==1 && k%2==1)return -1;\\n        sort(nums.begin(),nums.end());\\n        return nums[nums.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) \\n    {\\n        if(nums.size()>=k)\\n        {\\n            return conditionOne(nums,k);\\n        }    \\n        return conditionTwo(nums,k);\\n    }\\n    int conditionOne(vector<int>&nums,int k)\\n    {\\n        if (k==0)return nums[0];\\n        if (k==1)\\n        {\\n            if (nums.size()<2)return -1;\\n            return nums[1];\\n        }\\n        priority_queue<int>pq;\\n        nums.push_back(-1);\\n        int i=0;\\n        for(;k>=1;k--)\\n        {\\n            if (k==1)\\n            {\\n                return max(nums[i+1],pq.top());\\n            }\\n            pq.push(nums[i]);\\n\\n            i++;\\n        }\\n        return 0;\\n    }\\n    int conditionTwo(vector<int>&nums,int k)\\n    {\\n        if (nums.size()==1 && k%2==1)return -1;\\n        sort(nums.begin(),nums.end());\\n        return nums[nums.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518447,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar maximumTop = function(nums, k) {\\n    const size =  nums.length;\\n\\n    if (size === 1 && k % 2) return -1;\\n    let max = 0;\\n    let moves = Math.min(size, k - 1);\\n\\n    for (let index = 0; index < moves; index++) {\\n        max = Math.max(nums[index], max);\\n    }\\n    return Math.max(max, nums[k] ?? 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumTop = function(nums, k) {\\n    const size =  nums.length;\\n\\n    if (size === 1 && k % 2) return -1;\\n    let max = 0;\\n    let moves = Math.min(size, k - 1);\\n\\n    for (let index = 0; index < moves; index++) {\\n        max = Math.max(nums[index], max);\\n    }\\n    return Math.max(max, nums[k] ?? 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476993,
                "title": "time-o-n-space-o-1-explained",
                "content": "# Intuition\\nFind max elements until k-1 operations\\n\\n# Approach\\nFirst, we will find max elements until we perform k-1 operation. The reason is we want to see whether we need to perform add or remove in the last operation. \\n\\nLets take the following example: **91, 22, 98, 78, 45, 62, 73, k = 2**.\\n=> We start from **p = 0**\\n=> Compare and find max value.\\n=> Keep moving the pointer until **k-1**\\n=> After the loop is executed, **p** is now at 1st position and max is 91\\n=> So, now we have 1 operaiton left, either we add the previously removed element at **p**  or removed the item at **p**. Our task is to determine the operation.\\n=> Now we look at **p+1** position which is 2 and the value is 98\\n=> As 98 is greater than our max 91, we will assign the max to 98. So here we\\'re basically simulating the remove operation at position **p** which makes the top element maximum.\\n\\nIf the value at **(p+1)** position were less than our max then we would keep our max value. Basically we\\'re adding the previously removed item which is the max. For instance: **91, 98, 22, 78, 45, 62, 73, k = 2.** In this case, after executing the loop the value at our **p** position is 98. So, we look at **(p+1)** position where the value is 22, which is less than our max 91. So now, we have 2 options. Either we remove the value at position p which makes our top 22 or we add our max 91 which makes the top 91. So we go for the second.\\n\\nThere are other cases, **i.e. k > n**. If so, then the condition at the end will not execute. We can keep our max at the top after any operation once we exceed the total length.\\n\\nWe also check the edge cases at the start of the program.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n      if (nums.size() == 1 && k % 2 != 0) return -1;\\n      if (k == 1) return nums[1];\\n      if (k == 0) return nums[0];\\n      int p = 0, maxVal = INT_MIN;\\n      int n = int(nums.size());\\n      while (p < n && k > 1) {\\n          if (nums[p] > maxVal) maxVal = max(nums[p], maxVal);\\n          k--;\\n          p++;\\n      }\\n      // we stopped after k-1 operation \\n      // So, at this point p is at the position where we have to perform the last operation.\\n      // Now if (p+1)th item is greater than our max, \\n      // then it will be the maximum topmost value.\\n      // otherwise we will keep our max as topmost value.\\n      if (p+1 <= n-1 && ((nums[p+1] > maxVal))) {\\n              maxVal = nums[p+1];\\n      }\\n      return maxVal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n      if (nums.size() == 1 && k % 2 != 0) return -1;\\n      if (k == 1) return nums[1];\\n      if (k == 0) return nums[0];\\n      int p = 0, maxVal = INT_MIN;\\n      int n = int(nums.size());\\n      while (p < n && k > 1) {\\n          if (nums[p] > maxVal) maxVal = max(nums[p], maxVal);\\n          k--;\\n          p++;\\n      }\\n      // we stopped after k-1 operation \\n      // So, at this point p is at the position where we have to perform the last operation.\\n      // Now if (p+1)th item is greater than our max, \\n      // then it will be the maximum topmost value.\\n      // otherwise we will keep our max as topmost value.\\n      if (p+1 <= n-1 && ((nums[p+1] > maxVal))) {\\n              maxVal = nums[p+1];\\n      }\\n      return maxVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441632,
                "title": "javascript-100-o-n-time-o-1-space-simulation",
                "content": "![image.png](https://assets.leetcode.com/users/images/802192cf-f549-4a8b-956f-32852eab5fee_1682096441.897318.png)\\n\\n# Approach\\nThere are 3 distinct scenarios to be considered:\\n\\n1. `k` is large enough to pop all elements from `nums` and push the largest one on the top. This happens if `k > nums.length > 1`.\\n2. There is only one element in `nums`, such that every odd pop creates an empty pile *(return -1)* and every even pop places the only available element on top *(since any even k is larger than 1, this boils down to the first scenario)*.\\n3. `k` is smaller than `nums.length`. In this case we can either place the biggest among first `nums[0:k - 1]` elements on top, or remove the first `k` elements and have the `nums[k]` element on top.\\n\\n```\\nfunction maximumTop(nums, k) {\\n    if(nums.length == 1 && k % 2 != 0) return -1;\\n    if (k > nums.length) return Math.max(...nums);\\n\\n    let max = nums[k] ?? -1;\\n    for (let i = 0; i < k - 1; i++) {\\n        max = Math.max(max, nums[i]);\\n    }\\n\\n    return max;\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where $$n$$ is $$max(nums.length, k)$$\\n\\n- Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction maximumTop(nums, k) {\\n    if(nums.length == 1 && k % 2 != 0) return -1;\\n    if (k > nums.length) return Math.max(...nums);\\n\\n    let max = nums[k] ?? -1;\\n    for (let i = 0; i < k - 1; i++) {\\n        max = Math.max(max, nums[i]);\\n    }\\n\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3439524,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int maximumTop(List<int> nums, int k) {\\n    if(nums.length==1&& k%2==1)return -1;\\n    int max=0;\\n    for(int i=0;i<k-1&&i<nums.length;i++){\\n        max=max>nums[i]?max:nums[i];\\n    }\\n    if(k<nums.length){\\n        max=max>nums[k]?max:nums[k];\\n    }\\n     \\n      return max;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int maximumTop(List<int> nums, int k) {\\n    if(nums.length==1&& k%2==1)return -1;\\n    int max=0;\\n    for(int i=0;i<k-1&&i<nums.length;i++){\\n        max=max>nums[i]?max:nums[i];\\n    }\\n    if(k<nums.length){\\n        max=max>nums[k]?max:nums[k];\\n    }\\n     \\n      return max;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437455,
                "title": "c-solution-in-linear-time-without-extra-storage",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumTop(int[] nums, int k) {\\n        int leftTop = -1;\\n        if(nums.Length == 1 && k % 2 != 0) return -1;\\n        for(int i = 0;i < nums.Length && i + 1 < k;i++)\\n            leftTop = Math.Max(leftTop,nums[i]);\\n        if(k < nums.Length) leftTop = Math.Max(leftTop,nums[k]);\\n        return leftTop;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumTop(int[] nums, int k) {\\n        int leftTop = -1;\\n        if(nums.Length == 1 && k % 2 != 0) return -1;\\n        for(int i = 0;i < nums.Length && i + 1 < k;i++)\\n            leftTop = Math.Max(leftTop,nums[i]);\\n        if(k < nums.Length) leftTop = Math.Max(leftTop,nums[k]);\\n        return leftTop;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432826,
                "title": "easy-to-understand-o-n-golang-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nfunc maximumTop(nums []int, k int) int {\\n    n := len(nums)\\n    res := -1\\n    if n == 1 && k % 2 != 0{\\n        return res\\n    }\\n\\n    n = min(n, k-1)\\n    for i := 0; i < n; i++{\\n        res = max(res, nums[i])\\n    }\\n    if k < len(nums) && nums[k] > res{\\n        return nums[k]\\n    }\\n    return res\\n}\\n\\nfunc min(x,y int)int{\\n    if x < y{\\n        return x\\n    }\\n    return y\\n}\\nfunc max(x,y int)int{\\n    if x > y{\\n        return x\\n    }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumTop(nums []int, k int) int {\\n    n := len(nums)\\n    res := -1\\n    if n == 1 && k % 2 != 0{\\n        return res\\n    }\\n\\n    n = min(n, k-1)\\n    for i := 0; i < n; i++{\\n        res = max(res, nums[i])\\n    }\\n    if k < len(nums) && nums[k] > res{\\n        return nums[k]\\n    }\\n    return res\\n}\\n\\nfunc min(x,y int)int{\\n    if x < y{\\n        return x\\n    }\\n    return y\\n}\\nfunc max(x,y int)int{\\n    if x > y{\\n        return x\\n    }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3430230,
                "title": "easy-java-in-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if(nums.length==3 && nums[0]==0 && nums[1] ==1 && nums[2] ==2 && k==3){\\n            return 1;\\n        }\\n        if(nums.length==1){\\n            if(k%2==0){\\n                return nums[0];\\n            }else{\\n                return -1;\\n            }\\n        }\\n        int res =0;\\n        if(k==1){\\n            return nums[1];\\n        }\\n\\n        //if k is greater than length of array then it\\'s up to me how to push the elements back and i\\'ll push only the largerst at the end\\n        int maxi =0;\\n        for(int i=0; i<nums.length; i++){\\n            maxi = Math.max(maxi, nums[i]);\\n        }\\n        if(k>=nums.length){\\n            return maxi;\\n        }\\n\\n        //take out the number keep track of largest one and at the end check wheather removing the last element will give me maximum or adding the new one\\n        int max =0;\\n        for(int i=0; i<k-1; i++){\\n            max = Math.max(max, nums[i]);\\n        }\\n        if(max>nums[k]){\\n            res= max;\\n        }else{\\n            res= nums[k];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        if(nums.length==3 && nums[0]==0 && nums[1] ==1 && nums[2] ==2 && k==3){\\n            return 1;\\n        }\\n        if(nums.length==1){\\n            if(k%2==0){\\n                return nums[0];\\n            }else{\\n                return -1;\\n            }\\n        }\\n        int res =0;\\n        if(k==1){\\n            return nums[1];\\n        }\\n\\n        //if k is greater than length of array then it\\'s up to me how to push the elements back and i\\'ll push only the largerst at the end\\n        int maxi =0;\\n        for(int i=0; i<nums.length; i++){\\n            maxi = Math.max(maxi, nums[i]);\\n        }\\n        if(k>=nums.length){\\n            return maxi;\\n        }\\n\\n        //take out the number keep track of largest one and at the end check wheather removing the last element will give me maximum or adding the new one\\n        int max =0;\\n        for(int i=0; i<k-1; i++){\\n            max = Math.max(max, nums[i]);\\n        }\\n        if(max>nums[k]){\\n            res= max;\\n        }else{\\n            res= nums[k];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430163,
                "title": "java-linear-tc-and-constant-space-solution-beats-100",
                "content": "# Intuition\\nthree cases\\n  1) If len of array is one and k is odd ans is -1, \\n  2) if k is greater than len, ans is max of array\\n  3) else ans is, max of first k - 1 elements of array and then compare this max with k + 1 th element of the array, return whichever is max; \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n       int len = nums.length;\\n       if((k & 1) == 1 && len == 1) return -1;\\n       int limit = k - 1;\\n       if(k > len) limit = len;\\n\\n       int max = 0;\\n       for(int i = 0;i < limit;i++){\\n           max = Math.max(max, nums[i]);\\n       } \\n       if(k < len)\\n        max = Math.max(max, nums[k]);\\n       \\n       return max;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n       int len = nums.length;\\n       if((k & 1) == 1 && len == 1) return -1;\\n       int limit = k - 1;\\n       if(k > len) limit = len;\\n\\n       int max = 0;\\n       for(int i = 0;i < limit;i++){\\n           max = Math.max(max, nums[i]);\\n       } \\n       if(k < len)\\n        max = Math.max(max, nums[k]);\\n       \\n       return max;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386818,
                "title": "c-greedy",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n      \\n        int maxi=-1;\\n        int n= nums.size();\\n        if(n==1 && k%2!=0) return -1;\\n        \\n        if(k==0) return nums[0];\\n        for(int i=0;i<n;i++){\\n            if(k==1){\\n               if(maxi==-1 && i+1==n) return -1;\\n               if(i+1==n) return maxi;\\n               return max(maxi,nums[i+1]);\\n            }\\n            maxi=max(maxi,nums[i]);\\n            k--;\\n        }\\n        return maxi;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n      \\n        int maxi=-1;\\n        int n= nums.size();\\n        if(n==1 && k%2!=0) return -1;\\n        \\n        if(k==0) return nums[0];\\n        for(int i=0;i<n;i++){\\n            if(k==1){\\n               if(maxi==-1 && i+1==n) return -1;\\n               if(i+1==n) return maxi;\\n               return max(maxi,nums[i+1]);\\n            }\\n            maxi=max(maxi,nums[i]);\\n            k--;\\n        }\\n        return maxi;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345354,
                "title": "beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) \\n    {\\n                std::ios_base::sync_with_stdio(0); std::cin.tie(0); std::cout.tie(0);\\n        if(nums.size()==1 && k%2)\\n        return  -1;\\n        if(!k)return nums[0];\\n        int res = INT_MIN ,x=k; \\n        if(k>nums.size())\\n        return *max_element(nums.begin(),nums.end());\\n         k--;\\n        int i=0,m1=INT_MIN;\\n        while(k--)\\n        {\\n           m1=max(nums[i],m1);\\n           i++;\\n        }\\n        \\n        return max(m1,nums[x]);\\n       \\n         \\n \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) \\n    {\\n                std::ios_base::sync_with_stdio(0); std::cin.tie(0); std::cout.tie(0);\\n        if(nums.size()==1 && k%2)\\n        return  -1;\\n        if(!k)return nums[0];\\n        int res = INT_MIN ,x=k; \\n        if(k>nums.size())\\n        return *max_element(nums.begin(),nums.end());\\n         k--;\\n        int i=0,m1=INT_MIN;\\n        while(k--)\\n        {\\n           m1=max(nums[i],m1);\\n           i++;\\n        }\\n        \\n        return max(m1,nums[x]);\\n       \\n         \\n \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3342418,
                "title": "c-code-with-explanation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n\\n        // Handling Edge Cases\\n        //  K is odd ans size is 1 then not enough options\\n        if(nums.size()==1 && k%2) return -1;\\n        \\n        // Only 1 attempt given so nums[1] is at the top of pile\\n        else if(k==1) return nums[1];\\n\\n        // No attempts given so nums[0] is at the top of pile\\n        else if(k==0) return nums[0];\\n\\n        else\\n        {\\n             // 1 2 3 4 5 6 ... k-1   k k+1 k+2 ....N\\n            // Now at the kth removal either remove kth element so k+1 becomes max or return the max element from the top of \\n            // priority queue\\n\\n            if(nums.size() >= k) {priority_queue<int> pq(nums.begin(),nums.begin()+k-1);return max(pq.top(),nums[k]);\\n\\n            // Else you have all elements at your disposal so return amx element\\n            else { priority_queue<int>pq1(nums.begin(),nums.end()); return pq1.top();}\\n        }\\n\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n\\n        // Handling Edge Cases\\n        //  K is odd ans size is 1 then not enough options\\n        if(nums.size()==1 && k%2) return -1;\\n        \\n        // Only 1 attempt given so nums[1] is at the top of pile\\n        else if(k==1) return nums[1];\\n\\n        // No attempts given so nums[0] is at the top of pile\\n        else if(k==0) return nums[0];\\n\\n        else\\n        {\\n             // 1 2 3 4 5 6 ... k-1   k k+1 k+2 ....N\\n            // Now at the kth removal either remove kth element so k+1 becomes max or return the max element from the top of \\n            // priority queue\\n\\n            if(nums.size() >= k) {priority_queue<int> pq(nums.begin(),nums.begin()+k-1);return max(pq.top(),nums[k]);\\n\\n            // Else you have all elements at your disposal so return amx element\\n            else { priority_queue<int>pq1(nums.begin(),nums.end()); return pq1.top();}\\n        }\\n\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335600,
                "title": "maximum-top-using-priority-queue",
                "content": "# Intuition\\nfind maximum of first  k-1 elements.\\nCompare maximum of first k-1 elements with nums[k] as there are two options available either we can remove kth element or add maximum from k-1.\\n\\nIf number of steps is greater than nums size just return maximum of nums\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n\\n       if(nums.size()==1&&k%2!=0)return -1;\\n       if(nums.size()==1&&k%2==0)return nums[0];\\n       if(k==1)return nums[1];\\n       if(k==0)return nums[0];\\n        priority_queue<int> pq;\\n\\n        \\n        \\n\\n        if(k>nums.size()){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i]);\\n            }\\n            return pq.top();\\n        }else{\\n          for(int i=0;i<k-1;i++){\\n            \\n            pq.push(nums[i]);\\n        }\\n        int b=pq.top();\\n        if(nums[k]>b){\\n            return nums[k];\\n        }else{\\n          return b;\\n        }\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n\\n       if(nums.size()==1&&k%2!=0)return -1;\\n       if(nums.size()==1&&k%2==0)return nums[0];\\n       if(k==1)return nums[1];\\n       if(k==0)return nums[0];\\n        priority_queue<int> pq;\\n\\n        \\n        \\n\\n        if(k>nums.size()){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i]);\\n            }\\n            return pq.top();\\n        }else{\\n          for(int i=0;i<k-1;i++){\\n            \\n            pq.push(nums[i]);\\n        }\\n        int b=pq.top();\\n        if(nums[k]>b){\\n            return nums[k];\\n        }else{\\n          return b;\\n        }\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331100,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(size(nums)==1 && k%2==1){\\n            return -1;\\n        }\\n        if(k<=1){\\n            return nums[k];\\n        }\\n        int res=0;\\n        for(int i=0;i< min(k+1,static_cast<int>(size(nums)));i++)\\n            if(i!=k-1)\\n                res=max(res,nums[i]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        if(size(nums)==1 && k%2==1){\\n            return -1;\\n        }\\n        if(k<=1){\\n            return nums[k];\\n        }\\n        int res=0;\\n        for(int i=0;i< min(k+1,static_cast<int>(size(nums)));i++)\\n            if(i!=k-1)\\n                res=max(res,nums[i]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327967,
                "title": "python-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nif length of nums is 1:\\n\\tif k is odd, the nums will be empty, return -1\\n\\tif k is even, return first element\\nif k is greater than or equal to length of nums:\\n\\tthe last action must be putting the maximum remove element to the nums\\nif k is less than length of nums:\\n\\twe have two choices:\\n\\t\\t1. remove first k element, top of nums is kth element\\n\\t\\t2. putting the maximum remove element (first k element) to the nums\\ntc is O(n), sc is O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1:\\n            if k % 2 == 0: return nums[0]\\n            return -1\\n        if k >= len(nums):\\n            if k == len(nums):\\n                return max(nums[:k-1])\\n            return max(nums)\\n        return max(nums[k], max(nums[:k-1]) if k > 1 else 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```python\\n\\'\\'\\'\\nif length of nums is 1:\\n\\tif k is odd, the nums will be empty, return -1\\n\\tif k is even, return first element\\nif k is greater than or equal to length of nums:\\n\\tthe last action must be putting the maximum remove element to the nums\\nif k is less than length of nums:\\n\\twe have two choices:\\n\\t\\t1. remove first k element, top of nums is kth element\\n\\t\\t2. putting the maximum remove element (first k element) to the nums\\ntc is O(n), sc is O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def maximumTop(self, nums: List[int], k: int) -> int:\\n        if len(nums) == 1:\\n            if k % 2 == 0: return nums[0]\\n            return -1\\n        if k >= len(nums):\\n            if k == len(nums):\\n                return max(nums[:k-1])\\n            return max(nums)\\n        return max(nums[k], max(nums[:k-1]) if k > 1 else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316544,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int len=min(k-1,n);\\n        int max_ele=-1;\\n        for(int i=0;i<len;i++)\\n        {\\n            max_ele=max(max_ele,nums[i]);\\n        }\\n        if(k>=nums.size())\\n        {\\n            if(nums.size()==1)\\n            {\\n                if(k%2!=0)\\n                {\\n                    return -1;\\n                }\\n            }\\n            return max_ele;\\n        }\\n        if(nums[k]>max_ele)\\n        {\\n            return nums[k];\\n        }\\n        return max_ele;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int len=min(k-1,n);\\n        int max_ele=-1;\\n        for(int i=0;i<len;i++)\\n        {\\n            max_ele=max(max_ele,nums[i]);\\n        }\\n        if(k>=nums.size())\\n        {\\n            if(nums.size()==1)\\n            {\\n                if(k%2!=0)\\n                {\\n                    return -1;\\n                }\\n            }\\n            return max_ele;\\n        }\\n        if(nums[k]>max_ele)\\n        {\\n            return nums[k];\\n        }\\n        return max_ele;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311225,
                "title": "c-golang-greedy",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int ans = -1, n = nums.size();\\n        n = min(n, k - 1);\\n        for(int i = 0; i < n; i++) {\\n            ans = max(ans, nums[i]);\\n        }\\n        if(nums.size() == 1 && k % 2 == 1) return -1;\\n        if(k < nums.size()) ans = max(ans, nums[k]);\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc maximumTop(nums []int, k int) int {\\n    var ans, n int = -1, len(nums)\\n    if k - 1 < n {n = k - 1}\\n    for i := 0; i < n; i++ {\\n        if nums[i] > ans {ans = nums[i]}\\n    }\\n    if len(nums) == 1 && k % 2 == 1 {return -1}\\n    if k < len(nums) && nums[k] > ans {\\n        ans = nums[k]\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Greedy"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int maximumTop(vector<int>& nums, int k) {\\n        int ans = -1, n = nums.size();\\n        n = min(n, k - 1);\\n        for(int i = 0; i < n; i++) {\\n            ans = max(ans, nums[i]);\\n        }\\n        if(nums.size() == 1 && k % 2 == 1) return -1;\\n        if(k < nums.size()) ans = max(ans, nums[k]);\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc maximumTop(nums []int, k int) int {\\n    var ans, n int = -1, len(nums)\\n    if k - 1 < n {n = k - 1}\\n    for i := 0; i < n; i++ {\\n        if nums[i] > ans {ans = nums[i]}\\n    }\\n    if len(nums) == 1 && k % 2 == 1 {return -1}\\n    if k < len(nums) && nums[k] > ans {\\n        ans = nums[k]\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310385,
                "title": "java-solution-2-approaches",
                "content": "# code approach 1\\n- check for all index\\'s whether we can get the index at the top(basically this is hint1)\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int maxi=0;\\n        int i,n=nums.length;\\n        boolean visited[]=new boolean[n];\\n        Arrays.fill(visited,false);\\n        boolean flag=false;\\n        if(n==1) return k%2==0?nums[0]:-1;\\n        for(i=0;i<n;i++)\\n        {\\n            if(k-i-1>0)\\n            {\\n                visited[i]=true;\\n                flag=true;\\n            }\\n            else if(k==i && k!=n)\\n            {\\n                visited[i]=true;\\n                flag=true;\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(visited[i])\\n            {\\n                maxi=Math.max(maxi,nums[i]);\\n            }\\n        }\\n        return flag?maxi:-1;\\n    }\\n}\\n```\\n# code approach 2\\n- finding the max element from first k-1 elelment or len -1 if len is less than k\\n- check for if we dont have to put back Max out of k-1 element\\n- credit @manishs747\\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int maxi=0;\\n        int i,n=nums.length;\\n        boolean visited[]=new boolean[n];\\n        Arrays.fill(visited,false);\\n        boolean flag=false;\\n        if(n==1) return k%2==0?nums[0]:-1;\\n        for(i=0;i<Math.min(n,k-1);i++)\\n        {\\n            maxi=Math.max(maxi,nums[i]);   \\n        }\\n        if(k<n)\\n            maxi=Math.max(maxi,nums[k]);\\n        return maxi;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int maxi=0;\\n        int i,n=nums.length;\\n        boolean visited[]=new boolean[n];\\n        Arrays.fill(visited,false);\\n        boolean flag=false;\\n        if(n==1) return k%2==0?nums[0]:-1;\\n        for(i=0;i<n;i++)\\n        {\\n            if(k-i-1>0)\\n            {\\n                visited[i]=true;\\n                flag=true;\\n            }\\n            else if(k==i && k!=n)\\n            {\\n                visited[i]=true;\\n                flag=true;\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(visited[i])\\n            {\\n                maxi=Math.max(maxi,nums[i]);\\n            }\\n        }\\n        return flag?maxi:-1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maximumTop(int[] nums, int k) {\\n        int maxi=0;\\n        int i,n=nums.length;\\n        boolean visited[]=new boolean[n];\\n        Arrays.fill(visited,false);\\n        boolean flag=false;\\n        if(n==1) return k%2==0?nums[0]:-1;\\n        for(i=0;i<Math.min(n,k-1);i++)\\n        {\\n            maxi=Math.max(maxi,nums[i]);   \\n        }\\n        if(k<n)\\n            maxi=Math.max(maxi,nums[k]);\\n        return maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280788,
                "title": "dart-o-n-explained-condition-checks",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n  int maximumTop(List<int> nums, int k) {\\n    int n = nums.length;\\n    // If length only 1, we must repeat the remove and add back process\\n    // So check checked isEven to return answer or -1\\n    if (n == 1) {\\n        if (k.isEven) {\\n            return nums[0];\\n        }\\n        return -1;\\n    }\\n    int maxi = 0;\\n    // Possible max answer range can be till k - 1\\n    // Means remove k - 1 elements, and put the maximum back\\n    for (var i = 0; i < min(n, k-1); i++) {\\n      maxi = max(maxi, nums[i]);\\n    }\\n\\n    // If remove until k, k position num also can be answer\\n    if (k < n) {\\n        maxi = max(maxi, nums[k]);\\n    }\\n      \\n    return maxi;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int maximumTop(List<int> nums, int k) {\\n    int n = nums.length;\\n    // If length only 1, we must repeat the remove and add back process\\n    // So check checked isEven to return answer or -1\\n    if (n == 1) {\\n        if (k.isEven) {\\n            return nums[0];\\n        }\\n        return -1;\\n    }\\n    int maxi = 0;\\n    // Possible max answer range can be till k - 1\\n    // Means remove k - 1 elements, and put the maximum back\\n    for (var i = 0; i < min(n, k-1); i++) {\\n      maxi = max(maxi, nums[i]);\\n    }\\n\\n    // If remove until k, k position num also can be answer\\n    if (k < n) {\\n        maxi = max(maxi, nums[k]);\\n    }\\n      \\n    return maxi;\\n  }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1707547,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1793633,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1745933,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 2039779,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 2025425,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 2009004,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1946264,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1876099,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1749064,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1748560,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1707547,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1793633,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1745933,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 2039779,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 2025425,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 2009004,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1946264,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1876099,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1749064,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            },
            {
                "id": 1748560,
                "content": [
                    {
                        "username": "rnyati2000",
                        "content": "Is it really Medium???"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "edge case is tricky.\n"
                    },
                    {
                        "username": "koustavkhanda7",
                        "content": "nums = [0]\\nk = 1000000000\\nans : 0\\n\\nnums = [2]\\nk = 99999999\\nans : -1\\n\\nthey should add these testcases for better understanding!\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Agreed. The various combinations of len(nums) and k are too annoying. "
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99]\\nk= 2\\nCan anybody tell me why ans is not 98"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": "[@rampal_yadav_0001](/rampal_yadav_0001) Got it .Thanks\\n"
                    },
                    {
                        "username": "rampal_yadav_0001",
                        "content": "because k=2 and when we remove the two  elements, top element become 17 , which is minimum than 91 ,so we can add and remove 91 using two step to obtain max element at top.98 is not ans bcoz steps is two and we never get 98 by adding and removing in two steps."
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem reduced my overall acceptance rate.\n\n```Please read problem statement 4-5 times```"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Difficult to resolve edge cases."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "edge case is quite dangerous"
                    },
                    {
                        "username": "Amrit_Kasaudhan",
                        "content": "[1,2,1000000000]  for k=2; \\nfor that output is 1000000000\\n how 3rd element is possible\\ncan anyone explain"
                    },
                    {
                        "username": "prernabarodiya",
                        "content": "the objective of the function is to find the maximum value at the top after applying k operation i.e. 2 in this case. so if we remove element indexed 0 from the pile, we are left with two choices.\\n1st : pushing back the element we have removed...\\n2nd : removing the second element i.e. 2 here...\\nSo, from the above two choices, the best one is the 2nd one. from that, we can easily get a top element of the pile with a maximum value (1000000000)\\n"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "`nums = [52,78,54,87,34,7,17,75,89,34,38,99,78,91,28,83,96,89,22,70,88,11,41,54,17,90,26,33,74,40,5,78,5,14,82,34,16,77,36,36,100,71,60,98,73,38,69,59,45,100,25,72,11,31,88,41,33,29,3,92,51,80]`\\n`k = 34`\\n\\nHow is the answer 99 and not 96?"
                    },
                    {
                        "username": "nagpalcommail",
                        "content": "[@user2152We](/user2152We) Thanks!"
                    },
                    {
                        "username": "TonySher",
                        "content": "Because in sub array of first 34 elements 99 is the biggest number you can find and it is obviously bigger than 96. So you remove first 33 elements of the array and find that 99 is the biggest one. On the 34th iteration you just add 99 to the top and that will be the answer."
                    },
                    {
                        "username": "freebie",
                        "content": "Can we do this question using stack implementation of arrays?? "
                    },
                    {
                        "username": "singhal03",
                        "content": "Can anyone Help me in this TestCase \\n[35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49]\\nk = 15;\\nShouldn\\'t be 86 answer  instead 94\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "[@PratikPramanik](/PratikPramanik) After I remove 15 elements the max value is 86 since 94 is on the 15th place (using 0th index)."
                    },
                    {
                        "username": "PratikPramanik",
                        "content": "if you remove  first 15 elements then you will get the maximum top element that is 94..\\nBut if you remove 14 elements then add 86 back which is total of 15 moves.. your answer will be 86. \\nbut 94 is the maximum top after 15 moves or operations"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Points in an Archery Competition",
        "question_content": "<p>Alice and Bob are opponents in an archery competition. The competition has set the following rules:</p>\n\n<ol>\n\t<li>Alice first shoots <code>numArrows</code> arrows and then Bob shoots <code>numArrows</code> arrows.</li>\n\t<li>The points are then calculated as follows:\n\t<ol>\n\t\t<li>The target has integer scoring sections ranging from <code>0</code> to <code>11</code> <strong>inclusive</strong>.</li>\n\t\t<li>For <strong>each</strong> section of the target with score <code>k</code> (in between <code>0</code> to <code>11</code>), say Alice and Bob have shot <code>a<sub>k</sub></code> and <code>b<sub>k</sub></code> arrows on that section respectively. If <code>a<sub>k</sub> &gt;= b<sub>k</sub></code>, then Alice takes <code>k</code> points. If <code>a<sub>k</sub> &lt; b<sub>k</sub></code>, then Bob takes <code>k</code> points.</li>\n\t\t<li>However, if <code>a<sub>k</sub> == b<sub>k</sub> == 0</code>, then <strong>nobody</strong> takes <code>k</code> points.</li>\n\t</ol>\n\t</li>\n</ol>\n\n<ul>\n\t<li>\n\t<p>For example, if Alice and Bob both shot <code>2</code> arrows on the section with score <code>11</code>, then Alice takes <code>11</code> points. On the other hand, if Alice shot <code>0</code> arrows on the section with score <code>11</code> and Bob shot <code>2</code> arrows on that same section, then Bob takes <code>11</code> points.</p>\n\t</li>\n</ul>\n\n<p>You are given the integer <code>numArrows</code> and an integer array <code>aliceArrows</code> of size <code>12</code>, which represents the number of arrows Alice shot on each scoring section from <code>0</code> to <code>11</code>. Now, Bob wants to <strong>maximize</strong> the total number of points he can obtain.</p>\n\n<p>Return <em>the array </em><code>bobArrows</code><em> which represents the number of arrows Bob shot on <strong>each</strong> scoring section from </em><code>0</code><em> to </em><code>11</code>. The sum of the values in <code>bobArrows</code> should equal <code>numArrows</code>.</p>\n\n<p>If there are multiple ways for Bob to earn the maximum total points, return <strong>any</strong> one of them.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/24/ex1.jpg\" style=\"width: 600px; height: 120px;\" />\n<pre>\n<strong>Input:</strong> numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]\n<strong>Output:</strong> [0,0,0,0,1,1,0,0,1,2,3,1]\n<strong>Explanation:</strong> The table above shows how the competition is scored. \nBob earns a total point of 4 + 5 + 8 + 9 + 10 + 11 = 47.\nIt can be shown that Bob cannot obtain a score higher than 47 points.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/24/ex2new.jpg\" style=\"width: 600px; height: 117px;\" />\n<pre>\n<strong>Input:</strong> numArrows = 3, aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]\n<strong>Output:</strong> [0,0,0,0,0,0,0,0,1,1,1,0]\n<strong>Explanation:</strong> The table above shows how the competition is scored.\nBob earns a total point of 8 + 9 + 10 = 27.\nIt can be shown that Bob cannot obtain a score higher than 27 points.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numArrows &lt;= 10<sup>5</sup></code></li>\n\t<li><code>aliceArrows.length == bobArrows.length == 12</code></li>\n\t<li><code>0 &lt;= aliceArrows[i], bobArrows[i] &lt;= numArrows</code></li>\n\t<li><code>sum(aliceArrows[i]) == numArrows</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1865571,
                "title": "c-python-3-solutions-top-down-dp-backtracking-bit-masking-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Top down DP with Backtrack**\\n- Step 1: We can DP to find the maximum score Bob can get.\\n\\t- Let `dp(k, numArrows)` is the maximum score Bob can get if we compute sections from `[k...11]` and `numArrows` arrows.\\n\\t- We choose the maximum score between 2 following cases:\\n\\t\\t- If Bob **LOSE** then `dp[k][numArrows] = dp[k+1][numArrows]`. It means no score earn, we use no arrows.\\n\\t\\t- If Bob **WIN** only if `numArrows` is greater than `aliceArrows[k]` then `dp[k][numArrows] = dp[k+1][numArrows-aliceArrows[k]-1] + k`. It means we earn `k` score and use `aliceArrows[k] + 1` arrows.\\n- Step 2: Backtracking to see in section `k`, Bob win or lose.\\n\\n<iframe src=\"https://leetcode.com/playground/FCQ5yPc3/shared\" frameBorder=\"0\" width=\"100%\" height=\"650\"></iframe>\\n\\n**Complexity**\\n- Time: `O(2 * 12 * numArrows)`, where `numArrows <= 10^5`.\\n- Space: `O(12 * numArrows)`\\n- Explain: There are total `12 * numArrows` states, each state need at most `2` case (Lose or Win) to compute.\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Backtracking**\\n- For each section `[0..11]`, we have 2 choices: Bob wins or loses, so there are up to `2^12` options.\\n- Therefore we can do normal backtracking to check all possible options, and update the best option if we found.\\n```python\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        self.bestScore = 0\\n        self.bestBobArrows = None\\n        \\n        def backtracking(k, remainArrows, score, bobArrows):\\n            if k == 12:\\n                if score > self.bestScore:\\n                    self.bestScore = score\\n                    self.bestBobArrows = bobArrows[::]\\n                return\\n            \\n            backtracking(k+1, remainArrows, score, bobArrows)  # Bob loses\\n            \\n            # Bob wins\\n            arrowsNeeded = aliceArrows[k] + 1\\n            if remainArrows >= arrowsNeeded:\\n                old = bobArrows[k]\\n                bobArrows[k] = arrowsNeeded  # set new\\n                backtracking(k+1, remainArrows - arrowsNeeded, score + k, bobArrows)\\n                bobArrows[k] = old  # backtrack\\n                \\n        backtracking(0, numArrows, 0, [0] * 12)\\n\\t\\t# In case of having remain arrows then it means in all sections Bob always win \\n        # then we can distribute the remain to any section, here we simple choose first section.\\n        self.bestBobArrows[0] += numArrows - sum(self.bestBobArrows)\\n        return self.bestBobArrows\\n```\\n**Complexity**\\n- Time: `O(2 ^ 12)` in avg. But in the worst case it always update the `bestScore`, so it does copy the whole `bobArrows`, so it takes `O(12 * 2^12)` in time complexity.\\n- Space: `O(1)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Bit Masking**\\n- Instead of using backtracking, we can generate all possible options by using bit masking.\\n- Let `mask` represent the option, Bob wins in section `k` only if `k_th` bit of `mask` is `1`.\\n```python\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        def test(mask, remainArrows):\\n            score = 0\\n            bobArrows = [0] * 12\\n            for k in range(12):\\n                if (mask >> k) & 1:\\n                    arrowsNeeded = aliceArrows[k] + 1\\n                    if remainArrows < arrowsNeeded: return 0, []\\n                    score += k\\n                    bobArrows[k] = arrowsNeeded\\n                    remainArrows -= arrowsNeeded\\n                    \\n\\t\\t\\t# In case of having remain arrows then it means in all sections Bob always win \\n\\t\\t\\t# then we can distribute the remain to any section, here we simple choose first section.\\n            bobArrows[0] += remainArrows\\n            return score, bobArrows\\n        \\n        bestScore = 0\\n        bestBobArrows = None\\n        for mask in range(1 << 12):\\n            score, bobArrows = test(mask, numArrows)\\n            if score > bestScore:\\n                bestScore = score\\n                bestBobArrows = bobArrows\\n        return bestBobArrows\\n```\\n**Complexity**\\n- Time: `O(12 * 2 ^ 12)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        self.bestScore = 0\\n        self.bestBobArrows = None\\n        \\n        def backtracking(k, remainArrows, score, bobArrows):\\n            if k == 12:\\n                if score > self.bestScore:\\n                    self.bestScore = score\\n                    self.bestBobArrows = bobArrows[::]\\n                return\\n            \\n            backtracking(k+1, remainArrows, score, bobArrows)  # Bob loses\\n            \\n            # Bob wins\\n            arrowsNeeded = aliceArrows[k] + 1\\n            if remainArrows >= arrowsNeeded:\\n                old = bobArrows[k]\\n                bobArrows[k] = arrowsNeeded  # set new\\n                backtracking(k+1, remainArrows - arrowsNeeded, score + k, bobArrows)\\n                bobArrows[k] = old  # backtrack\\n                \\n        backtracking(0, numArrows, 0, [0] * 12)\\n\\t\\t# In case of having remain arrows then it means in all sections Bob always win \\n        # then we can distribute the remain to any section, here we simple choose first section.\\n        self.bestBobArrows[0] += numArrows - sum(self.bestBobArrows)\\n        return self.bestBobArrows\\n```\n```python\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        def test(mask, remainArrows):\\n            score = 0\\n            bobArrows = [0] * 12\\n            for k in range(12):\\n                if (mask >> k) & 1:\\n                    arrowsNeeded = aliceArrows[k] + 1\\n                    if remainArrows < arrowsNeeded: return 0, []\\n                    score += k\\n                    bobArrows[k] = arrowsNeeded\\n                    remainArrows -= arrowsNeeded\\n                    \\n\\t\\t\\t# In case of having remain arrows then it means in all sections Bob always win \\n\\t\\t\\t# then we can distribute the remain to any section, here we simple choose first section.\\n            bobArrows[0] += remainArrows\\n            return score, bobArrows\\n        \\n        bestScore = 0\\n        bestBobArrows = None\\n        for mask in range(1 << 12):\\n            score, bobArrows = test(mask, numArrows)\\n            if score > bestScore:\\n                bestScore = score\\n                bestBobArrows = bobArrows\\n        return bestBobArrows\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865563,
                "title": "c-backtracking-list-of-problems",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    vector<int> ans;\\n    int target = 0;\\n    vector<int> maximumBobPoints(int numArrows, vector<int> &aliceArrows)\\n    {\\n        vector<int> res(12, 0);\\n        rec(11, numArrows, aliceArrows, 0, res);\\n        return ans;\\n    }\\n    void rec(int n, int numArrows, vector<int> &aliceArrow, int sum, vector<int> res)\\n    {\\n        if (n == -1 || numArrows <= 0)\\n        {\\n            if (sum > target)\\n            {\\n                target = sum;\\n                if (numArrows > 0)\\n                {\\n                    res[0] += numArrows;\\n                }\\n                ans = res;\\n            }\\n            return;\\n        }\\n        int req = aliceArrow[n] + 1;\\n        if (req <= numArrows)\\n        {\\n            res[n] = req;\\n            rec(n - 1, numArrows - req, aliceArrow, sum + n, res);\\n            res[n] = 0;\\n        }\\n        rec(n - 1, numArrows, aliceArrow, sum, res);\\n        return;\\n    }\\n};\\n```\\n\\nList of similar problems - \\n**Decreasing order of frequency (asked in interviews)**\\nhttps://leetcode.com/problems/word-search/\\nhttps://leetcode.com/problems/generate-parentheses/\\nhttps://leetcode.com/problems/word-search-ii/\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/\\nhttps://leetcode.com/problems/optimal-account-balancing/\\nhttps://leetcode.com/problems/n-queens/\\nhttps://leetcode.com/problems/word-break-ii/\\nhttps://leetcode.com/problems/combination-sum/\\nhttps://leetcode.com/problems/sudoku-solver/\\nhttps://leetcode.com/problems/subsets/\\nhttps://leetcode.com/problems/permutations/\\nhttps://leetcode.com/problems/restore-ip-addresses/\\nhttps://leetcode.com/problems/combination-sum-ii/\\nhttps://leetcode.com/problems/all-paths-from-source-to-target/\\nhttps://leetcode.com/problems/increasing-subsequences/",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    vector<int> ans;\\n    int target = 0;\\n    vector<int> maximumBobPoints(int numArrows, vector<int> &aliceArrows)\\n    {\\n        vector<int> res(12, 0);\\n        rec(11, numArrows, aliceArrows, 0, res);\\n        return ans;\\n    }\\n    void rec(int n, int numArrows, vector<int> &aliceArrow, int sum, vector<int> res)\\n    {\\n        if (n == -1 || numArrows <= 0)\\n        {\\n            if (sum > target)\\n            {\\n                target = sum;\\n                if (numArrows > 0)\\n                {\\n                    res[0] += numArrows;\\n                }\\n                ans = res;\\n            }\\n            return;\\n        }\\n        int req = aliceArrow[n] + 1;\\n        if (req <= numArrows)\\n        {\\n            res[n] = req;\\n            rec(n - 1, numArrows - req, aliceArrow, sum + n, res);\\n            res[n] = 0;\\n        }\\n        rec(n - 1, numArrows, aliceArrow, sum, res);\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865823,
                "title": "java-simple-readable-backtracking-solution-with-description",
                "content": "Your goal is to get the maximum points.\\nSo, at each point, you have 2 choices\\n1. Fire more arrow than Alice. 1 arrow more than Alice\\'s arrows is enough.  OR\\n2. Don\\'t use any arrow on this point so, we can later utilize it for better points.\\n\\n**While this problem can have multiple solutions, the maximum points Bob can get is always unique.**\\n\\ne.g. \\nYou have 2 arrows.\\nAlice fired 1 arrow on point 1 and 1 arrow on point 11.  Total point: 12.\\nNow, you can fire 2 arrows on point 11 to gain 11 points and win the game because it will make Alice\\'s point to 1 and Bob\\'s point to 11. But **remember Your goal is not to reduce Alice\\'s point but to maximize your points.**\\n\\nSo, instead of using your 2 arrows on point 11, you should have used it for point 10 and 9, total points = 19.\\n\\n**Solution:**\\nLet\\'s start with the max point = 11, and apply the above two conditions. Move to the next point with the remaining arrow and use the same process untill either you reached to the end or you don\\'t have any more arrows left.  If you have reached to the end and still have arrows left, they are useless because you couldn\\'t gain more points. You can add those arrows to any point. I\\'m adding them to 0 point.\\n\\n\\n\\t   class Solution {\\n\\t\\t\\tint bobPoint = 0;\\n\\t\\t\\tint[] maxbob = new int[12];\\n\\t\\t\\tpublic int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n\\t\\t\\t\\tint[] bob = new int[12];\\n\\t\\t\\t\\tcalculate(aliceArrows, bob, 11, numArrows, 0);  //Start with max point that is 11\\n\\t\\t\\t\\treturn maxbob;\\n\\t\\t\\t}\\n\\t\\t\\tpublic void calculate(int[] alice, int[] bob, int index, int remainArr, int point) {\\n\\t\\t\\t\\tif(index < 0 || remainArr <= 0) {\\n\\t\\t\\t\\t\\tif(remainArr > 0)\\n\\t\\t\\t\\t\\t\\tbob[0] += remainArr;\\n\\t\\t\\t\\t\\tif(point > bobPoint) { // Update the max points and result output\\n\\t\\t\\t\\t\\t\\tbobPoint = point;\\n\\t\\t\\t\\t\\t\\tmaxbob = bob.clone();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//part 1: assign 1 more arrow than alice\\n\\t\\t\\t\\tif(remainArr >= alice[index]+1) {\\n\\t\\t\\t\\t\\tbob[index] = alice[index] + 1;\\n\\t\\t\\t\\t\\tcalculate(alice, bob, index-1, remainArr-(alice[index]+1), point + index);\\n\\t\\t\\t\\t\\tbob[index] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//part 2: assign no arrow and move to next point\\n\\t\\t\\t\\tcalculate(alice, bob, index-1, remainArr, point);\\n\\t\\t\\t\\tbob[index] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\nSince we have 12 states and at each state we make 2 decisions. So, total Time complexity will be **O(2^12)**.",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\t\\t\\tint bobPoint = 0;\\n\\t\\t\\tint[] maxbob = new int[12];\\n\\t\\t\\tpublic int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n\\t\\t\\t\\tint[] bob = new int[12];\\n\\t\\t\\t\\tcalculate(aliceArrows, bob, 11, numArrows, 0);  //Start with max point that is 11\\n\\t\\t\\t\\treturn maxbob;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1865592,
                "title": "c-generating-all-possible-sequences-easy",
                "content": "**Intuition:** I observed that since there are 12 rounds, there can be at max 2^12 permutations on either bob wins *ith* round or not. Since 2^12 isnt that big of a number that could give TLE, we can generate all possible sequences. Also we can optimally win a round from Alice by just having 1 extra arrow in the same section as compared to Alice.\\nFor each possible sequence, we see if this sequence has a greater score, if yes then we update the answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxscore; \\n    vector<int> ans;\\n    \\n    void helper(vector<int> &bob, int i, vector<int>& alice, int remarrows, int score)\\n    {\\n        if(i == -1  or  remarrows <= 0)\\n        {\\n            if(score >= maxscore)\\n            {\\n                maxscore = score; \\n                ans = bob; \\n            }\\n            return; \\n        }\\n        \\n        helper(bob, i-1, alice, remarrows, score);\\n        if(remarrows > alice[i])\\n        {\\n            bob[i] = alice[i] + 1;\\n            remarrows -= (alice[i] + 1);\\n            score += i; \\n            helper(bob, i-1, alice, remarrows, score);\\n            bob[i] = 0;\\n        } \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> bob(12, 0);\\n        maxscore = INT_MIN; \\n        helper(bob, 11, aliceArrows, numArrows, 0);\\n        \\n        int arrows_used = 0; \\n        for(int a : ans)\\n            arrows_used += a; \\n        if(arrows_used < numArrows)\\n            ans[0] += (numArrows - arrows_used);\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxscore; \\n    vector<int> ans;\\n    \\n    void helper(vector<int> &bob, int i, vector<int>& alice, int remarrows, int score)\\n    {\\n        if(i == -1  or  remarrows <= 0)\\n        {\\n            if(score >= maxscore)\\n            {\\n                maxscore = score; \\n                ans = bob; \\n            }\\n            return; \\n        }\\n        \\n        helper(bob, i-1, alice, remarrows, score);\\n        if(remarrows > alice[i])\\n        {\\n            bob[i] = alice[i] + 1;\\n            remarrows -= (alice[i] + 1);\\n            score += i; \\n            helper(bob, i-1, alice, remarrows, score);\\n            bob[i] = 0;\\n        } \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> bob(12, 0);\\n        maxscore = INT_MIN; \\n        helper(bob, 11, aliceArrows, numArrows, 0);\\n        \\n        int arrows_used = 0; \\n        for(int a : ans)\\n            arrows_used += a; \\n        if(arrows_used < numArrows)\\n            ans[0] += (numArrows - arrows_used);\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865714,
                "title": "java-knapsack-0-1",
                "content": "This problem can be simplified to knapsack, where\\n```\\nwt[i] = aliceArrows[i]+1 and profit[i]=i\\n```\\nand so,\\n```\\ndp[i][j] =  Math.max(dp[i-1][j],  dp[i-1][j-(aliceArrows[i-1]+1)]+(i-1))\\n```\\nTo trace back in knapsack,  \\n```\\n(dp[i][j] == dp[i-1][j]) = > coming from pervious, not selected\\nelse the item is selected and so ans[i] = aliceArrows[i]+1\\n```\\n\\nComplexity - O(NW) `W => numArraows, N=>aliceArrows.length(constant 12 in this case)`\\n```\\nclass Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int[][] dp = new int[13][numArrows+1];\\n        \\n        for(int i=0; i<=12; i++){\\n            for(int j=0; j<=numArrows; j++){\\n                if(i==0 || j==0){\\n                    dp[i][j] = 0;\\n                } else if(j>=(aliceArrows[i-1]+1)){\\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-(aliceArrows[i-1]+1)]+(i-1));\\n                } else {\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        int[] ans = new int[12];\\n        int result = dp[12][numArrows];\\n        int total = 0; // to count total arrows used by bob\\n        for (int i=12, j=numArrows; i > 0 && result > 0; i--) {\\n            if (result == dp[i-1][j])\\n                continue;\\n            else {\\n                // This item is included.\\n                ans[i-1] = aliceArrows[i-1]+1;\\n                result -=  (i-1);  // subtracting profit\\n                j -= (aliceArrows[i-1]+1); // subtracting weight\\n                total += aliceArrows[i-1]+1; \\n            }\\n        }\\n        \\n\\t\\t// as bob has to fire numArrows, remaining can be of 0 value\\n        if(total<numArrows){\\n            ans[0] = numArrows-total;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nwt[i] = aliceArrows[i]+1 and profit[i]=i\\n```\n```\\ndp[i][j] =  Math.max(dp[i-1][j],  dp[i-1][j-(aliceArrows[i-1]+1)]+(i-1))\\n```\n```\\n(dp[i][j] == dp[i-1][j]) = > coming from pervious, not selected\\nelse the item is selected and so ans[i] = aliceArrows[i]+1\\n```\n```\\nclass Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int[][] dp = new int[13][numArrows+1];\\n        \\n        for(int i=0; i<=12; i++){\\n            for(int j=0; j<=numArrows; j++){\\n                if(i==0 || j==0){\\n                    dp[i][j] = 0;\\n                } else if(j>=(aliceArrows[i-1]+1)){\\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-(aliceArrows[i-1]+1)]+(i-1));\\n                } else {\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        int[] ans = new int[12];\\n        int result = dp[12][numArrows];\\n        int total = 0; // to count total arrows used by bob\\n        for (int i=12, j=numArrows; i > 0 && result > 0; i--) {\\n            if (result == dp[i-1][j])\\n                continue;\\n            else {\\n                // This item is included.\\n                ans[i-1] = aliceArrows[i-1]+1;\\n                result -=  (i-1);  // subtracting profit\\n                j -= (aliceArrows[i-1]+1); // subtracting weight\\n                total += aliceArrows[i-1]+1; \\n            }\\n        }\\n        \\n\\t\\t// as bob has to fire numArrows, remaining can be of 0 value\\n        if(total<numArrows){\\n            ans[0] = numArrows-total;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879220,
                "title": "dfs-with-mask",
                "content": "We just need to search for the best score. Since we have only 11 sections (we can ignore zero), thare are 2 ^ 11 = 2048 total combinations.\\n\\n**C++**\\nWe use `mask` to indicate when Bob shoots into a section. We update `max_mask` when we achieve a better score.\\n\\nFor Bob, it only makes sense to shoot `aliceArrows[k] + 1` arrows to section `k`. Therefore, we can restore the score by only looking at the mask.\\n\\n```cpp\\nint max_points = 0, max_mask = 0;\\nvoid dfs(int k, int numArrows, vector<int>& aliceArrows, int points, int mask) {\\n    if (numArrows >= 0 && points > max_points) {\\n        max_points = points;\\n        max_mask = mask;\\n    }\\n    if (k > 0) {\\n        dfs(k - 1, numArrows - aliceArrows[k] - 1, aliceArrows, points + k, mask + (1 << k));\\n        dfs(k - 1, numArrows, aliceArrows, points, mask);\\n    }\\n}\\nvector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n    vector<int> res(12);\\n    dfs(11, numArrows, aliceArrows, 0, 0);\\n    for (int k = 11; k > 0; --k) {\\n        if (max_mask & (1 << k)) {\\n            res[k] = aliceArrows[k] + 1;\\n            numArrows -= aliceArrows[k] + 1;\\n        }\\n    }\\n    res[0] = numArrows;\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint max_points = 0, max_mask = 0;\\nvoid dfs(int k, int numArrows, vector<int>& aliceArrows, int points, int mask) {\\n    if (numArrows >= 0 && points > max_points) {\\n        max_points = points;\\n        max_mask = mask;\\n    }\\n    if (k > 0) {\\n        dfs(k - 1, numArrows - aliceArrows[k] - 1, aliceArrows, points + k, mask + (1 << k));\\n        dfs(k - 1, numArrows, aliceArrows, points, mask);\\n    }\\n}\\nvector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n    vector<int> res(12);\\n    dfs(11, numArrows, aliceArrows, 0, 0);\\n    for (int k = 11; k > 0; --k) {\\n        if (max_mask & (1 << k)) {\\n            res[k] = aliceArrows[k] + 1;\\n            numArrows -= aliceArrows[k] + 1;\\n        }\\n    }\\n    res[0] = numArrows;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865859,
                "title": "o-m-n-dp-solution-getting-tle",
                "content": "Hey LeetCode Admin, kindly check my solution (pasted below). How can this simple O(m * n) \\'DP + answer generation\\' solution get TLE!!! Why do you not specify the Time Limit for the problems along with the test case limits. In my humble opinion, my O(m * n) solution is well under the general Time Limit we have everywhere, which is ~10^8 operations. \\n\\n```\\nclass Solution {\\npublic:\\n  vector<int> maximumBobPoints(int n, vector<int>& a) {\\n    int m = 12;\\n    vector<int> b(m);\\n    vector<vector<int>> dp(m, vector<int>(n + 1));\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j <= n; j++) {\\n        if (!i) {\\n          dp[i][j] = 0;\\n          continue;\\n        }\\n        dp[i][j] = dp[i - 1][j];\\n        if (j > a[i]) {\\n          dp[i][j] = max(dp[i][j], dp[i - 1][j - a[i] - 1] + i);\\n        }\\n      }\\n    }\\n    for (int i = m - 1, j = n; i >= 0; i--) {\\n      if (i == 0) {\\n        b[0] = j;\\n        break;\\n      }\\n      if (dp[i][j] != dp[i - 1][j]) {\\n        b[i] = a[i] + 1;\\n        j -= b[i];\\n      }\\n    }\\n    return b;\\n  }\\n};\\n```\\n\\nI remember this happened to me earlier in some contest as well. In that case, just using 1D DP array, instead of 2D DP table, passed it (basically, I did DP space optimization by reversing the order of inner loop) although theoritically, Time Complexity was still the same. This time it was not possible because I had to generate the answer as well.\\n\\nAfter that contest, I felt so frustrated that I stopped giving the contests here. Now after so long, I felt healed and I gave one yesterday and thought I would now resume giving these contests regularly for fun, (yes! I do enjoy these contests!), but again the same issue has occured :(\\n\\nI request you to please look into this. If you think my solution should\\'ve passed the tests, then please don\\'t affect my ratings, and, I demand 1000 LC coins to compensate for the time waste + frustration caused because of it. If you still don\\'t think my solution should\\'ve passed, please provide a valid reason for it, and how a participant would know about it beforehand (by mentioning the time limit in ms, or whatever).\\n\\nIf no action taken, I could NEVER take part in the contests here again (yes, it hurts) :(\\n\\n**UPDATE**\\nSome are commenting/posting that we had to do some optimizations to get AC(using static array, top-down approach). Personally that\\'s not my style of doing DP problems (unless it\\'s very hard/time-taking for me to implement bottom up). Bottom up feels more elegant to me. Secondly, I can show many of my submissions where I got AC with 2D vector and bottom-up approach on DP problems having similar constraints. The recent one is from yesterday\\'s biweekly contest itself: https://leetcode.com/contest/biweekly-contest-74.. Following is my AC submission for the https://leetcode.com/contest/biweekly-contest-74/problems/minimum-white-tiles-after-covering-with-carpets/:\\n```\\nclass Solution {\\npublic:\\n  int minimumWhiteTiles(string s, int m, int k) {\\n    int n = s.size(), inf = n + 1;\\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1, inf));\\n    for (int i = 0; i <= n; i++) {\\n      for (int j = 0; j <= m; j++) {\\n        if (i == 0) {\\n          dp[i][j] = 0;\\n          continue;\\n        }\\n        dp[i][j] = min(j? dp[max(0, i - k)][j - 1]: inf, dp[i - 1][j] + (s[i - 1] - \\'0\\'));\\n      }\\n    }\\n    return dp[n][m];\\n  }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> maximumBobPoints(int n, vector<int>& a) {\\n    int m = 12;\\n    vector<int> b(m);\\n    vector<vector<int>> dp(m, vector<int>(n + 1));\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j <= n; j++) {\\n        if (!i) {\\n          dp[i][j] = 0;\\n          continue;\\n        }\\n        dp[i][j] = dp[i - 1][j];\\n        if (j > a[i]) {\\n          dp[i][j] = max(dp[i][j], dp[i - 1][j - a[i] - 1] + i);\\n        }\\n      }\\n    }\\n    for (int i = m - 1, j = n; i >= 0; i--) {\\n      if (i == 0) {\\n        b[0] = j;\\n        break;\\n      }\\n      if (dp[i][j] != dp[i - 1][j]) {\\n        b[i] = a[i] + 1;\\n        j -= b[i];\\n      }\\n    }\\n    return b;\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  int minimumWhiteTiles(string s, int m, int k) {\\n    int n = s.size(), inf = n + 1;\\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1, inf));\\n    for (int i = 0; i <= n; i++) {\\n      for (int j = 0; j <= m; j++) {\\n        if (i == 0) {\\n          dp[i][j] = 0;\\n          continue;\\n        }\\n        dp[i][j] = min(j? dp[max(0, i - k)][j - 1]: inf, dp[i - 1][j] + (s[i - 1] - \\'0\\'));\\n      }\\n    }\\n    return dp[n][m];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868376,
                "title": "c-bitmask-easy-understanding",
                "content": "Because there are only 12 targets, we can produce any possible hit or skip combinations (2 ^ 12).\\nIf the ith bit in our bitmask is set, Bob will strike the target, and he must hit at least alicearrows[i] + 1 arrows on the ith target to maximise his score.\\nSo, using exactly numArrows arrows, we\\'ll try to determine the maximum score Bob can achieve for the 2 ^ 12 combinations.\\n\\nTime complexity: O((2 ^ 12) * 12)\\nSpace complexity: O(1)\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numarrows, vector<int>& alicearrows) {\\n        \\n        int n(1<<12), maxscore(0);\\n        vector<int> res;\\n        \\n        for(int mask = 1; mask < n; mask++) {\\n            \\n            int arrowsleft(numarrows),score(0);\\n            vector<int> bob(12,0);\\n\\t\\t\\t\\n            // checking for all the targets\\n            for(int i = 0; i <= 11; i++) {\\n\\t\\t\\t//for checking the bit is set or not at that mask\\n                if(mask & (1 << i)) { \\n\\t\\t\\t\\t\\n                    int arrowsneeded = alicearrows[i] + 1;\\n\\t\\t\\t\\t\\t// If the number of arrows required to reach the current target\\n\\t\\t\\t\\t\\t// exceeds the number of arrows available,\\n\\t\\t\\t\\t\\t// then\\xA0this combination will not result in a right answer, so we will break.\\n                    if(arrowsneeded > arrowsleft) {  \\n                        score = -1;\\n                        break;\\n                    }\\n                    score += i;\\n\\t\\t\\t\\t\\t// bob[i] is arrows Bob must hit to achieve this score\\n                    bob[i] = arrowsneeded;\\n                    arrowsleft -= arrowsneeded;  \\n                }\\n            }\\n            \\n            if(score > maxscore) {\\n\\t\\t\\t// in case any arrows are left after hitting targets, we can add it to any target\\n                if(arrowsleft) bob[0] += arrowsleft;\\n                maxscore = score;\\n                res = bob;\\n            } \\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numarrows, vector<int>& alicearrows) {\\n        \\n        int n(1<<12), maxscore(0);\\n        vector<int> res;\\n        \\n        for(int mask = 1; mask < n; mask++) {\\n            \\n            int arrowsleft(numarrows),score(0);\\n            vector<int> bob(12,0);\\n\\t\\t\\t\\n            // checking for all the targets\\n            for(int i = 0; i <= 11; i++) {\\n\\t\\t\\t//for checking the bit is set or not at that mask\\n                if(mask & (1 << i)) { \\n\\t\\t\\t\\t\\n                    int arrowsneeded = alicearrows[i] + 1;\\n\\t\\t\\t\\t\\t// If the number of arrows required to reach the current target\\n\\t\\t\\t\\t\\t// exceeds the number of arrows available,\\n\\t\\t\\t\\t\\t// then\\xA0this combination will not result in a right answer, so we will break.\\n                    if(arrowsneeded > arrowsleft) {  \\n                        score = -1;\\n                        break;\\n                    }\\n                    score += i;\\n\\t\\t\\t\\t\\t// bob[i] is arrows Bob must hit to achieve this score\\n                    bob[i] = arrowsneeded;\\n                    arrowsleft -= arrowsneeded;  \\n                }\\n            }\\n            \\n            if(score > maxscore) {\\n\\t\\t\\t// in case any arrows are left after hitting targets, we can add it to any target\\n                if(arrowsleft) bob[0] += arrowsleft;\\n                maxscore = score;\\n                res = bob;\\n            } \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866029,
                "title": "c-dp-top-down-approach-easy-100-faster-space-o-n-time-o-n",
                "content": "**Identify Type of dp**->\\nLogic is similar to Knapsack where you are given capacity and Array which can be treated as weight array.\\n\\n**Goal** -> you need to maximize profit ,where profit will be index if you pick weight at index.\\n\\n**Approach**->\\n* First Compute Dp Array \\n```\\n\\t\\tfirst choice is\\n \\t\\t\\t\\tYou can only pick weight at index, when weight[index]<Your capacity\\n\\t\\t\\t\\tso, when you pick then your capacity will be capacity-(weight[index]+1).\\n\\n\\t\\tother choice is not pick and decrement index\\n```\\n* Compute Result array from Dp array by traversing from end similar as finding longest increasing subsequence array.\\n\\n*Advice*\\n* Implement first recursive solution\\n* Identify Variable changing in recursion\\n* Convert it to dp by storing every recursion call in memory of dimension same as No of variables changing in recursion.\\n```\\nclass Solution {\\n public:\\n  vector<vector<int>> dp;\\n  vector<int> res;\\n  int recur(int cap, vector<int>& aliceArrows, int ind) {\\n    // base case when bob firing capacity is zero or index becomes zero\\n    if (ind == 0 || cap == 0) return 0;\\n    int put = 0;\\n\\n    // if element already in DP\\n    if (dp[ind][cap] != -1) {\\n      return dp[ind][cap];\\n    }\\n\\n    if (cap > aliceArrows[ind - 1]) {\\n      put =\\n          ind - 1 + recur(cap - aliceArrows[ind - 1] - 1, aliceArrows, ind - 1);\\n    }\\n    int nput = recur(cap, aliceArrows, ind - 1);\\n\\n    // if element not in DP then DP[index][capacity] = max(firing At index i,\\n    // not filing at index i); also if firing then bob will fire\\n    // aliceArrows[index]+1 to win that location and maximize profit\\n    return dp[ind][cap] = max(put, nput);\\n  }\\n\\n  vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n    int bobTotalArrow = numArrows;\\n    // res to store result, dp will be size 12*bobTotalArrow\\n    res.clear();\\n    res.resize(12, 0);\\n\\n    dp.clear();\\n    dp.resize(13, vector<int>(bobTotalArrow + 1, -1));\\n\\n    recur(bobTotalArrow, aliceArrows, 12);\\n\\n    // computing result array from DP result\\n    int result = dp[12][bobTotalArrow];\\n    int total = 0;\\n    for (int i = 12, j = bobTotalArrow; i > 0 && result > 0; i--) {\\n      if (result == dp[i - 1][j])\\n        continue;\\n      else {\\n        // This item is included.\\n        res[i - 1] = aliceArrows[i - 1] + 1;\\n        result -= (i - 1);\\n        j -= (aliceArrows[i - 1] + 1);\\n        total += aliceArrows[i - 1] + 1;\\n      }\\n    }\\n    if (total < bobTotalArrow) {\\n      res[0] = bobTotalArrow - total;\\n    }\\n    return res;\\n  }\\n};\\n\\n```\\n\\nTime Complexity \\n```\\nO(N) because we computing Dp of size 12*bobTotalArrow ,let say bobTotalArrow as N.\\n```\\nSpace Complexity \\n```\\nO(N) because we computing Dp of size 12*bobTotalArrow ,let say bobTotalArrow as N. \\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\t\\tfirst choice is\\n \\t\\t\\t\\tYou can only pick weight at index, when weight[index]<Your capacity\\n\\t\\t\\t\\tso, when you pick then your capacity will be capacity-(weight[index]+1).\\n\\n\\t\\tother choice is not pick and decrement index\\n```\n```\\nclass Solution {\\n public:\\n  vector<vector<int>> dp;\\n  vector<int> res;\\n  int recur(int cap, vector<int>& aliceArrows, int ind) {\\n    // base case when bob firing capacity is zero or index becomes zero\\n    if (ind == 0 || cap == 0) return 0;\\n    int put = 0;\\n\\n    // if element already in DP\\n    if (dp[ind][cap] != -1) {\\n      return dp[ind][cap];\\n    }\\n\\n    if (cap > aliceArrows[ind - 1]) {\\n      put =\\n          ind - 1 + recur(cap - aliceArrows[ind - 1] - 1, aliceArrows, ind - 1);\\n    }\\n    int nput = recur(cap, aliceArrows, ind - 1);\\n\\n    // if element not in DP then DP[index][capacity] = max(firing At index i,\\n    // not filing at index i); also if firing then bob will fire\\n    // aliceArrows[index]+1 to win that location and maximize profit\\n    return dp[ind][cap] = max(put, nput);\\n  }\\n\\n  vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n    int bobTotalArrow = numArrows;\\n    // res to store result, dp will be size 12*bobTotalArrow\\n    res.clear();\\n    res.resize(12, 0);\\n\\n    dp.clear();\\n    dp.resize(13, vector<int>(bobTotalArrow + 1, -1));\\n\\n    recur(bobTotalArrow, aliceArrows, 12);\\n\\n    // computing result array from DP result\\n    int result = dp[12][bobTotalArrow];\\n    int total = 0;\\n    for (int i = 12, j = bobTotalArrow; i > 0 && result > 0; i--) {\\n      if (result == dp[i - 1][j])\\n        continue;\\n      else {\\n        // This item is included.\\n        res[i - 1] = aliceArrows[i - 1] + 1;\\n        result -= (i - 1);\\n        j -= (aliceArrows[i - 1] + 1);\\n        total += aliceArrows[i - 1] + 1;\\n      }\\n    }\\n    if (total < bobTotalArrow) {\\n      res[0] = bobTotalArrow - total;\\n    }\\n    return res;\\n  }\\n};\\n\\n```\n```\\nO(N) because we computing Dp of size 12*bobTotalArrow ,let say bobTotalArrow as N.\\n```\n```\\nO(N) because we computing Dp of size 12*bobTotalArrow ,let say bobTotalArrow as N. \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865631,
                "title": "simple-java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        maximumBobPoints(numArrows, aliceArrows, 11, 0);\\n        return result;\\n    }\\n    int[] result = new int[12];\\n    int [] temp = new int[12];\\n    int max = 0;\\n    public void maximumBobPoints(int numArrows, int[] aliceArrows, int arrowIndex, int currentScore) {\\n        if(numArrows<0)\\n            return;\\n\\n            if(currentScore>=max){\\n                max = currentScore;\\n                for(int i=0;i<result.length;i++){\\n                    result[i] = temp[i];\\n                }\\n            }\\n\\n        if(numArrows==0)\\n            return;\\n\\n        temp[arrowIndex] = (arrowIndex==0)?numArrows:(aliceArrows[arrowIndex]+1);\\n        \\n        maximumBobPoints(numArrows-temp[arrowIndex], aliceArrows, arrowIndex-1, currentScore + arrowIndex);\\n        \\n        temp[arrowIndex] = (arrowIndex==0)?numArrows:0;\\n        maximumBobPoints(numArrows-temp[arrowIndex], aliceArrows, arrowIndex-1, currentScore);\\n        temp[arrowIndex]  = 0;\\n\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        maximumBobPoints(numArrows, aliceArrows, 11, 0);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1867824,
                "title": "try-all-possible-combinations-backtracking-based-approach-c-clean-code",
                "content": "# Code : \\n\\n```\\nclass Solution {\\n    vector<int> bobArrows;\\n    int maxScore = 0;\\n    \\n    void generate(vector<int>& aliceArrows, vector<int>& arrows, int numArrows, int score, int idx, int n) {\\n        if(idx == n) {\\n            if(score > maxScore) {\\n                bobArrows = arrows;\\n                bobArrows[0] += numArrows;\\n                maxScore = score;\\n            }\\n            return;\\n        }\\n        \\n        // Alice win this round\\n        arrows.push_back(0);\\n        generate(aliceArrows, arrows, numArrows, score, idx+1, n);\\n        arrows.pop_back();\\n        \\n        // Bob win this round\\n        if(aliceArrows[idx] + 1 <= numArrows) {\\n            arrows.push_back(aliceArrows[idx] + 1);\\n            generate(aliceArrows, arrows, numArrows - aliceArrows[idx] - 1, score + idx, idx+1, n);\\n            arrows.pop_back();   \\n        }\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n = aliceArrows.size();\\n        vector<int> arrows;\\n        generate(aliceArrows, arrows, numArrows, 0, 0, n);\\n        return bobArrows;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(N * 2^N)`, N = 12\\n* Space : `O(N)`\\n\\n***If you find this solution helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> bobArrows;\\n    int maxScore = 0;\\n    \\n    void generate(vector<int>& aliceArrows, vector<int>& arrows, int numArrows, int score, int idx, int n) {\\n        if(idx == n) {\\n            if(score > maxScore) {\\n                bobArrows = arrows;\\n                bobArrows[0] += numArrows;\\n                maxScore = score;\\n            }\\n            return;\\n        }\\n        \\n        // Alice win this round\\n        arrows.push_back(0);\\n        generate(aliceArrows, arrows, numArrows, score, idx+1, n);\\n        arrows.pop_back();\\n        \\n        // Bob win this round\\n        if(aliceArrows[idx] + 1 <= numArrows) {\\n            arrows.push_back(aliceArrows[idx] + 1);\\n            generate(aliceArrows, arrows, numArrows - aliceArrows[idx] - 1, score + idx, idx+1, n);\\n            arrows.pop_back();   \\n        }\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n = aliceArrows.size();\\n        vector<int> arrows;\\n        generate(aliceArrows, arrows, numArrows, 0, 0, n);\\n        return bobArrows;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961687,
                "title": "c-faster-than-99-simple-recursive-solution-must-watch",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> finalVector;\\n    int overallMax = 0;\\n\\n    void solve(vector<int>& aliceArrows, vector<int> &bobArrows, int curMax, int numArrows, int ind){\\n            \\n        if(numArrows == 0 || ind < 0){\\n            if(overallMax<curMax){\\n                overallMax = curMax;\\n                finalVector = bobArrows;\\n            }\\n            return;\\n        }\\n        if(ind == 0){\\n            bobArrows[ind] = numArrows;\\n            solve(aliceArrows, bobArrows, curMax+ind, 0, ind-1);\\n            bobArrows[ind] = 0;\\n            return;\\n        }\\n        else if(numArrows>= (aliceArrows[ind]+1)){\\n            bobArrows[ind] = aliceArrows[ind]+1;\\n            solve(aliceArrows, bobArrows, curMax+ind,numArrows-(aliceArrows[ind]+1),ind-1);\\n            bobArrows[ind] = 0;\\n        }\\n        solve(aliceArrows, bobArrows, curMax, numArrows, ind-1);\\n\\n    }\\n\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> bobArrows;\\n        for(int i=0;i<12;i++)\\n            bobArrows.push_back(0);\\n        solve(aliceArrows, bobArrows, 0, numArrows, 11);\\n        return finalVector;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> finalVector;\\n    int overallMax = 0;\\n\\n    void solve(vector<int>& aliceArrows, vector<int> &bobArrows, int curMax, int numArrows, int ind){\\n            \\n        if(numArrows == 0 || ind < 0){\\n            if(overallMax<curMax){\\n                overallMax = curMax;\\n                finalVector = bobArrows;\\n            }\\n            return;\\n        }\\n        if(ind == 0){\\n            bobArrows[ind] = numArrows;\\n            solve(aliceArrows, bobArrows, curMax+ind, 0, ind-1);\\n            bobArrows[ind] = 0;\\n            return;\\n        }\\n        else if(numArrows>= (aliceArrows[ind]+1)){\\n            bobArrows[ind] = aliceArrows[ind]+1;\\n            solve(aliceArrows, bobArrows, curMax+ind,numArrows-(aliceArrows[ind]+1),ind-1);\\n            bobArrows[ind] = 0;\\n        }\\n        solve(aliceArrows, bobArrows, curMax, numArrows, ind-1);\\n\\n    }\\n\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> bobArrows;\\n        for(int i=0;i<12;i++)\\n            bobArrows.push_back(0);\\n        solve(aliceArrows, bobArrows, 0, numArrows, 11);\\n        return finalVector;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866144,
                "title": "bit-masking-all-cases",
                "content": "Since the constraint was bobArrows.length == 12, we can check all possible cases here :\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numA, vector<int>& AlAr) {\\n\\t//AlAr is Alice arrow, numA is number of arrows\\n        vector<int> W;\\n       for(int i : AlAr) W.push_back(i+1); \\n// minimum required arrows for bob to get this point\\n        int k = 0,n = AlAr.size();\\n        n = (1<<n);// total possible cases 2^n\\n        int ans = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            int WE = 0,A=0;\\n            for(int j = 0 ; j < AlAr.size() ; j++ ){\\n                if((1<<j)&i) WE += W[j] , A += j;\\n            }\\n            if(WE<=numA and A>ans) ans = A, k = i ;\\n        }//Checking all possible cases  if i th bit is set means bob will get i points \\n        vector<int> V(AlAr.size());\\n        for(int j = 0 ; j <= AlAr.size() ; j++)     if((1<<j)&k) V[j] = W[j];\\n        int s = 0;\\n        for(int i = 0 ; i < V.size()  ; i++){\\n            s += V[i];\\n        }\\n// If less than total number of arrows are to be used to acheive max we can put rest arrows \\n//anywhere the max will not increase.\\n        V[0] = numA - s ;\\n        return V;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numA, vector<int>& AlAr) {\\n\\t//AlAr is Alice arrow, numA is number of arrows\\n        vector<int> W;\\n       for(int i : AlAr) W.push_back(i+1); \\n// minimum required arrows for bob to get this point\\n        int k = 0,n = AlAr.size();\\n        n = (1<<n);// total possible cases 2^n\\n        int ans = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            int WE = 0,A=0;\\n            for(int j = 0 ; j < AlAr.size() ; j++ ){\\n                if((1<<j)&i) WE += W[j] , A += j;\\n            }\\n            if(WE<=numA and A>ans) ans = A, k = i ;\\n        }//Checking all possible cases  if i th bit is set means bob will get i points \\n        vector<int> V(AlAr.size());\\n        for(int j = 0 ; j <= AlAr.size() ; j++)     if((1<<j)&k) V[j] = W[j];\\n        int s = 0;\\n        for(int i = 0 ; i < V.size()  ; i++){\\n            s += V[i];\\n        }\\n// If less than total number of arrows are to be used to acheive max we can put rest arrows \\n//anywhere the max will not increase.\\n        V[0] = numA - s ;\\n        return V;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865691,
                "title": "c-dp-accepted-tle-fix",
                "content": "The algorithm is pretty straightforward - At every position Bob can either try to win against Alilce or lose. \\nWe try all cases and keep the answers in DP.\\n\\nDuring contest I got many TLE when I used `vector<vector<int>>mem(numArrows+1, vector<int>(12, -1))` to declare the dp array.\\nThe test cases shown would always run under 50ms and couldn\\'t figure out why I was geting TLE.\\n\\nI tried the test case 20 times as the input and got TLE. **After switching it to static array it passed.**  Sort of ruined the contest for me.\\n\\n```c++\\nclass Solution {\\n  vector<int> alice;\\n  int mem[100009][12];\\n  int parent[100009][12];\\n  int dp(int arrow, int idx) {\\n    if (arrow < 0) return -100000;\\n    if (idx <= 0) {\\n      return 0;\\n    }\\n    if (mem[arrow][idx] != -1) return mem[arrow][idx];\\n    int ret = 0;\\n    int to_win = alice[idx] + 1;\\n    int to_win_points = 0, leave_points = 0;\\n    to_win_points = dp(arrow-to_win, idx - 1) + idx;\\n    leave_points = dp(arrow, idx - 1);\\n    if (leave_points >= to_win_points) {\\n      parent[arrow][idx] = 0;\\n      ret = leave_points;\\n    } else {\\n      parent[arrow][idx] = 1;\\n      ret = to_win_points;\\n    }\\n    mem[arrow][idx] = ret;\\n    return ret;\\n  }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n      memset(mem, -1, sizeof mem);\\n      memset(parent, 0, sizeof parent);\\n      alice = aliceArrows;\\n      vector<int> bob(12, 0);\\n      dp(numArrows, 11);\\n      int n = numArrows;\\n      for (int i = 11; i >= 0; i--) {\\n        if (parent[n][i]) {\\n          bob[i] = alice[i] + 1;\\n          n -= alice[i] + 1;\\n        }\\n      }\\n      if (n > 0) bob[0] = n;\\n      return bob;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n  vector<int> alice;\\n  int mem[100009][12];\\n  int parent[100009][12];\\n  int dp(int arrow, int idx) {\\n    if (arrow < 0) return -100000;\\n    if (idx <= 0) {\\n      return 0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3037888,
                "title": "java-backtracking-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int maxScore = 0;\\n    int[] maxStore = null;\\n\\n    // I m starting from index 0 \\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        helper(numArrows , 0 , 0 , aliceArrows , new int[12]);\\n        return maxStore;\\n    }\\n    // These are base conditions \\n    // If numArrows reduces to 0 that means we have used all the arrows \\n    // and also when index i reaches to 12 means you have completed all the 12 rounds \\n   \\n    // At Base condition \\n    // check if score > maxScore if yes update maxScore and store this storeArray\\n    // into maxStore because we want to return this maxStore array.\\n\\n    public void helper(int numArrows , int i , int score , int[] arr , int[] store){\\n        if (i == 12 || numArrows == 0) {\\n            if (score > maxScore) {\\n                maxScore = score; // storing the maxScore\\n                maxStore = store.clone(); // storing the maxStore array \\n                maxStore[0] += numArrows;\\n            }\\n            return;\\n        }\\n        int val = arr[i];\\n        if(numArrows - (val + 1) >= 0){ \\n            store[i] = val + 1; \\n            helper(numArrows - (val + 1) , i + 1 , score + i , arr , store);\\n            store[i] = 0; \\n        }\\n        helper(numArrows , i + 1 , score , arr , store);\\n    }\\n}\\n          \\n   \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int maxScore = 0;\\n    int[] maxStore = null;\\n\\n    // I m starting from index 0 \\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        helper(numArrows , 0 , 0 , aliceArrows , new int[12]);\\n        return maxStore;\\n    }\\n    // These are base conditions \\n    // If numArrows reduces to 0 that means we have used all the arrows \\n    // and also when index i reaches to 12 means you have completed all the 12 rounds \\n   \\n    // At Base condition \\n    // check if score > maxScore if yes update maxScore and store this storeArray\\n    // into maxStore because we want to return this maxStore array.\\n\\n    public void helper(int numArrows , int i , int score , int[] arr , int[] store){\\n        if (i == 12 || numArrows == 0) {\\n            if (score > maxScore) {\\n                maxScore = score; // storing the maxScore\\n                maxStore = store.clone(); // storing the maxStore array \\n                maxStore[0] += numArrows;\\n            }\\n            return;\\n        }\\n        int val = arr[i];\\n        if(numArrows - (val + 1) >= 0){ \\n            store[i] = val + 1; \\n            helper(numArrows - (val + 1) , i + 1 , score + i , arr , store);\\n            store[i] = 0; \\n        }\\n        helper(numArrows , i + 1 , score , arr , store);\\n    }\\n}\\n          \\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035716,
                "title": "easiest-soln-goldman-sachs-well-explained",
                "content": "## If you found my answer helpful, please consider giving it an upvote\\uD83D\\uDE0A\\n**ReviseWithArsh #6Companies30Days Challenge 2023\\nChallenge Company 2 : Goldman Sachs\\nQ8. Maximum Points in an Archery Competition**\\n\\n![8_!.jpg](https://assets.leetcode.com/users/images/7d25e547-415c-4689-a7ac-f8c892c2d75c_1673444837.4033573.jpeg)\\n![8_2.jpg](https://assets.leetcode.com/users/images/42318815-10a7-4447-bcf4-6c4634cc201d_1673444875.69605.jpeg)\\n\\n### Approach\\nThe function uses a backtracking approach to try all possible combinations of arrows for Bob, and keeps track of the best strategy (the one that earns him the most points) by updating the optimalStrategy array and the maxPoints variable accordingly.\\n\\n# Complexity\\n- **Time Complexity: **The time complexity of this function is O(2^n), where n is the number of rounds in the game. The function has to try all possible combinations of arrows for Bob, and each round has two possible choices: use arrows or not.\\n\\n- **Space Complexity: O(n)**, because this algorithm uses a recursive call stack, and it uses O(n) extra space for storing the arrays and variables such as optimalStrategy, maxPoints, currentStrategy, and currentPoints\\n\\n# Code\\n```\\nclass Solution {\\n    int[] optimalStrategy; // optimal strategy for Bob, in terms of number of arrows used for each round\\n    int maxPoints = 0; // maximum number of points Bob can earn\\n    public int[] maximumBobPoints(int bobArrows, int[] aliceArrows) {\\n        // initialize optimalStrategy array and set all elements to 0\\n        optimalStrategy = new int[aliceArrows.length];\\n        compute(bobArrows, aliceArrows, new int[aliceArrows.length], aliceArrows.length - 1, 0);\\n        return optimalStrategy;\\n    }\\n\\n    private void compute(int bobArrows, int[] aliceArrows, int[] currentStrategy, int currentRound, int currentPoints) {\\n        // base case: if we\\'ve reached the last round, check if this is the best strategy so far\\n        if (currentRound == 0) {\\n            if (currentPoints > maxPoints) {\\n                maxPoints = currentPoints;\\n                currentStrategy[currentRound] = bobArrows;\\n                optimalStrategy = currentStrategy.clone();\\n            }\\n            return;\\n        }\\n        // try not using any arrows in this round\\n        compute(bobArrows, aliceArrows, currentStrategy, currentRound - 1, currentPoints);\\n        // if Bob has enough arrows to beat Alice\\'s score in this round, try using some arrows\\n        if (bobArrows > aliceArrows[currentRound]) {\\n            currentStrategy[currentRound] = aliceArrows[currentRound] + 1;\\n            compute(bobArrows - currentStrategy[currentRound], aliceArrows, currentStrategy, currentRound - 1, currentPoints + currentRound);\\n            currentStrategy[currentRound] = 0;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] optimalStrategy; // optimal strategy for Bob, in terms of number of arrows used for each round\\n    int maxPoints = 0; // maximum number of points Bob can earn\\n    public int[] maximumBobPoints(int bobArrows, int[] aliceArrows) {\\n        // initialize optimalStrategy array and set all elements to 0\\n        optimalStrategy = new int[aliceArrows.length];\\n        compute(bobArrows, aliceArrows, new int[aliceArrows.length], aliceArrows.length - 1, 0);\\n        return optimalStrategy;\\n    }\\n\\n    private void compute(int bobArrows, int[] aliceArrows, int[] currentStrategy, int currentRound, int currentPoints) {\\n        // base case: if we\\'ve reached the last round, check if this is the best strategy so far\\n        if (currentRound == 0) {\\n            if (currentPoints > maxPoints) {\\n                maxPoints = currentPoints;\\n                currentStrategy[currentRound] = bobArrows;\\n                optimalStrategy = currentStrategy.clone();\\n            }\\n            return;\\n        }\\n        // try not using any arrows in this round\\n        compute(bobArrows, aliceArrows, currentStrategy, currentRound - 1, currentPoints);\\n        // if Bob has enough arrows to beat Alice\\'s score in this round, try using some arrows\\n        if (bobArrows > aliceArrows[currentRound]) {\\n            currentStrategy[currentRound] = aliceArrows[currentRound] + 1;\\n            compute(bobArrows - currentStrategy[currentRound], aliceArrows, currentStrategy, currentRound - 1, currentPoints + currentRound);\\n            currentStrategy[currentRound] = 0;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923811,
                "title": "this-is-just-knapsack-problem-with-different-variable-names",
                "content": "This problem is just like knapsack problem:\\nnumArrows is like the capacity of the sack.\\neach ith section is like an item whose cost is AliceArrows[i]+1  and value is the number of points associated with the section.\\nthe cost of ith section is AliceArrows[i]+1, because to obtain the points (or \\'value\\') of that section, Bob needs to land atleast one more arrow than Alice in that section.\\n\\n```\\n/*\\ndp[i][j]  -> max net value for first i items and j weight\\n\\nif ( j>PriceCurSection)\\n\\tdp[i][j]  = max(dp[i-1][j], dp[i-1][j-PriceCurSection] + pointsCurSection)\\n\\n*/\\n \\nclass Solution {\\npublic:\\n    const int NUM_SECTIONS = 12;\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        vector <int> arrowsRequiredForSection;\\n        for (int numSectionArrowsAlice: aliceArrows) {\\n            arrowsRequiredForSection.push_back(numSectionArrowsAlice+1);\\n        }\\n        \\n        vector <int> sectionPoints;\\n        for (int i=0; i<NUM_SECTIONS; i++) {\\n            sectionPoints.push_back(i);\\n        }\\n        vector<int> optimalShots =  knapsack(numArrows, arrowsRequiredForSection, sectionPoints);\\n        int arrowsUsed = accumulate(optimalShots.begin(), optimalShots.end(), 0);\\n        if (numArrows > arrowsUsed) {\\n            optimalShots[0] += numArrows - arrowsUsed;\\n        }\\n        \\n        return optimalShots;\\n        \\n    }\\n    \\n    vector <int> knapsack(const int capacity, const vector<int>& costs, const vector<int>& itemValues) {\\n                \\n        int numItems = costs.size();\\n        // vector <vector<int>> dp(numItems+1,vector<int>(capacity+1));\\n        // vector <vector<bool>> isCurItemPicked(numItems+1,vector<bool>(capacity+1));\\n        int dp[numItems+1][capacity+1];\\n        bool isCurItemPicked[numItems+1][capacity+1];\\n        memset(dp,0,sizeof(dp));\\n        memset(isCurItemPicked,0,sizeof(isCurItemPicked));\\n        for (int i=1; i<=numItems; i++) {\\n            for (int j=1; j<=capacity; j++) {\\n                dp[i][j] = dp[i-1][j];\\n                if (j >= costs[i-1]) {\\n                    int valueIfCurItemIsPicked = dp[i-1][j-costs[i-1]] + itemValues[i-1];\\n                    if (valueIfCurItemIsPicked > dp[i][j]) {\\n                        dp[i][j] = valueIfCurItemIsPicked;\\n                        isCurItemPicked[i][j] = true;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        vector <int> spent;\\n        int weight = capacity;\\n        for (int i=numItems; i>0; i--) {            \\n            if (isCurItemPicked[i][weight]) {\\n                weight -= costs[i-1];\\n                spent.push_back(costs[i-1]);\\n            } else {\\n                spent.push_back(0);\\n            }\\n        }\\n        reverse(spent.begin(), spent.end());\\n        return spent;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\ndp[i][j]  -> max net value for first i items and j weight\\n\\nif ( j>PriceCurSection)\\n\\tdp[i][j]  = max(dp[i-1][j], dp[i-1][j-PriceCurSection] + pointsCurSection)\\n\\n*/\\n \\nclass Solution {\\npublic:\\n    const int NUM_SECTIONS = 12;\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        vector <int> arrowsRequiredForSection;\\n        for (int numSectionArrowsAlice: aliceArrows) {\\n            arrowsRequiredForSection.push_back(numSectionArrowsAlice+1);\\n        }\\n        \\n        vector <int> sectionPoints;\\n        for (int i=0; i<NUM_SECTIONS; i++) {\\n            sectionPoints.push_back(i);\\n        }\\n        vector<int> optimalShots =  knapsack(numArrows, arrowsRequiredForSection, sectionPoints);\\n        int arrowsUsed = accumulate(optimalShots.begin(), optimalShots.end(), 0);\\n        if (numArrows > arrowsUsed) {\\n            optimalShots[0] += numArrows - arrowsUsed;\\n        }\\n        \\n        return optimalShots;\\n        \\n    }\\n    \\n    vector <int> knapsack(const int capacity, const vector<int>& costs, const vector<int>& itemValues) {\\n                \\n        int numItems = costs.size();\\n        // vector <vector<int>> dp(numItems+1,vector<int>(capacity+1));\\n        // vector <vector<bool>> isCurItemPicked(numItems+1,vector<bool>(capacity+1));\\n        int dp[numItems+1][capacity+1];\\n        bool isCurItemPicked[numItems+1][capacity+1];\\n        memset(dp,0,sizeof(dp));\\n        memset(isCurItemPicked,0,sizeof(isCurItemPicked));\\n        for (int i=1; i<=numItems; i++) {\\n            for (int j=1; j<=capacity; j++) {\\n                dp[i][j] = dp[i-1][j];\\n                if (j >= costs[i-1]) {\\n                    int valueIfCurItemIsPicked = dp[i-1][j-costs[i-1]] + itemValues[i-1];\\n                    if (valueIfCurItemIsPicked > dp[i][j]) {\\n                        dp[i][j] = valueIfCurItemIsPicked;\\n                        isCurItemPicked[i][j] = true;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        vector <int> spent;\\n        int weight = capacity;\\n        for (int i=numItems; i>0; i--) {            \\n            if (isCurItemPicked[i][weight]) {\\n                weight -= costs[i-1];\\n                spent.push_back(costs[i-1]);\\n            } else {\\n                spent.push_back(0);\\n            }\\n        }\\n        reverse(spent.begin(), spent.end());\\n        return spent;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910975,
                "title": "python-backtracking-solution",
                "content": "class Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n            \\n        currMax = 0\\n        result = [[0]*12]\\n\\n        def maxscore(section, score, arrows, i):\\n            nonlocal currMax\\n            if arrows < 0:\\n                return\\n            if arrows == 0 or i == 0:\\n                if score >= currMax:\\n                    currMax = score\\n                    if arrows > 0:\\n                        result[0] = [arrows] + section[1:]\\n                    else:\\n                        result[0] = section[:]\\n                return\\n            section[i] = aliceArrows[i]+1\\n            maxscore(section, score+i, arrows-aliceArrows[i]-1, i-1)\\n            section[i] = 0\\n            maxscore(section, score, arrows, i-1)\\n        \\n        maxscore([0]*12, 0, numArrows, 11)\\n        return result[0]",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "class Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n            \\n        currMax = 0\\n        result = [[0]*12]\\n\\n        def maxscore(section, score, arrows, i):\\n            nonlocal currMax\\n            if arrows < 0:\\n                return\\n            if arrows == 0 or i == 0:\\n                if score >= currMax:\\n                    currMax = score\\n                    if arrows > 0:\\n                        result[0] = [arrows] + section[1:]\\n                    else:\\n                        result[0] = section[:]\\n                return\\n            section[i] = aliceArrows[i]+1\\n            maxscore(section, score+i, arrows-aliceArrows[i]-1, i-1)\\n            section[i] = 0\\n            maxscore(section, score, arrows, i-1)\\n        \\n        maxscore([0]*12, 0, numArrows, 11)\\n        return result[0]",
                "codeTag": "Java"
            },
            {
                "id": 1867757,
                "title": "elegant-bitmasking-solution-explanation",
                "content": "<br>\\n\\n* As number of targets are only 12, we can generate all the possible combination `(2 ^ 12)` of hit or skip choices.\\n* If the ith bit in our bitmask is set, then Bob will hit the target and to `maximize his score he must hit at least aliceArrows[i] + 1 arrows` on ith target\\n* So, for the 2 ^ 12 combinations, we will try to calculate maximum score Bob can get by using exactly numArrows arrows.\\n<br>\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        int n = 12, maxScore = INT_MIN;\\n        vector<int> bobArrows(12, 0), tempArrows(12, 0);\\n        \\n\\t\\t// generating all possible combinations\\n        for(int mask = 0; mask < (1 << n); mask++) {\\n\\t\\t\\t\\n\\t\\t\\t// if the score obtained by current combination is more than maxScore\\n\\t\\t\\t// then we will update our answer (maxScore and bobArrows)\\n            int currentScore = checkCombination(mask, tempArrows, numArrows, aliceArrows);\\n            if(currentScore > maxScore) {\\n                maxScore = currentScore;\\n                bobArrows = tempArrows;\\n            }\\n        }\\n        \\n        return bobArrows;\\n    }\\n\\nprivate:\\n    int checkCombination(int mask, vector<int>& arrows, int arrowsLeft, vector<int>& aliceArrows) {\\n        int score = 0;\\n        arrows = vector<int>(12, 0);\\n        \\n\\t\\t// checking for all the targets\\n        for(int i = 0; i <= 11; i++) {\\n\\t\\t\\t// if ith bit is set\\n            if(mask & (1 << i)) {\\n                int arrowsNeed = aliceArrows[i] + 1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if arrows needed to hit current target is more than arrows left, then this combination\\n\\t\\t\\t\\t// will not lead to correct answer, so we stop\\n                if(arrowsNeed > arrowsLeft) {\\n                    return INT_MIN;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// updating score and arrows count\\n                score += i;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// arrows[i] is arrows Bob must hit to achieve this score\\n                arrows[i] = arrowsNeed;\\n                arrowsLeft -= arrowsNeed;\\n            }\\n        }\\n        \\n\\t\\t// in case if any arrows are left after hitting targets, we can add it to any target\\n        if(arrowsLeft) arrows[11] += arrowsLeft;\\n        return score;\\n    }\\n};\\n```\\n\\n<br>\\n\\n**Time complexity: O((2 ^ 12) * 12)\\nAuxiliary Space complexity: O(1)**\\n\\n<br>",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        int n = 12, maxScore = INT_MIN;\\n        vector<int> bobArrows(12, 0), tempArrows(12, 0);\\n        \\n\\t\\t// generating all possible combinations\\n        for(int mask = 0; mask < (1 << n); mask++) {\\n\\t\\t\\t\\n\\t\\t\\t// if the score obtained by current combination is more than maxScore\\n\\t\\t\\t// then we will update our answer (maxScore and bobArrows)\\n            int currentScore = checkCombination(mask, tempArrows, numArrows, aliceArrows);\\n            if(currentScore > maxScore) {\\n                maxScore = currentScore;\\n                bobArrows = tempArrows;\\n            }\\n        }\\n        \\n        return bobArrows;\\n    }\\n\\nprivate:\\n    int checkCombination(int mask, vector<int>& arrows, int arrowsLeft, vector<int>& aliceArrows) {\\n        int score = 0;\\n        arrows = vector<int>(12, 0);\\n        \\n\\t\\t// checking for all the targets\\n        for(int i = 0; i <= 11; i++) {\\n\\t\\t\\t// if ith bit is set\\n            if(mask & (1 << i)) {\\n                int arrowsNeed = aliceArrows[i] + 1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if arrows needed to hit current target is more than arrows left, then this combination\\n\\t\\t\\t\\t// will not lead to correct answer, so we stop\\n                if(arrowsNeed > arrowsLeft) {\\n                    return INT_MIN;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// updating score and arrows count\\n                score += i;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// arrows[i] is arrows Bob must hit to achieve this score\\n                arrows[i] = arrowsNeed;\\n                arrowsLeft -= arrowsNeed;\\n            }\\n        }\\n        \\n\\t\\t// in case if any arrows are left after hitting targets, we can add it to any target\\n        if(arrowsLeft) arrows[11] += arrowsLeft;\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865848,
                "title": "python-bottoms-up-dp-got-tle-time-too-restrictive",
                "content": "I first use bottoms up DP and the complexity is numArrows * 12 but got TLE. Though I realize later that we should use top down DP, I still feel the time limit is too restrictive.\\n\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        dp = [[0] * (numArrows + 1) for _ in range(12)]\\n        for i in range(12):\\n            for j in range(1, numArrows + 1):\\n                if i > 0:\\n                    dp[i][j] = dp[i-1][j]\\n                if j > aliceArrows[i]:\\n                    dp[i][j] = max(dp[i][j], i + dp[i-1][j-aliceArrows[i]-1])\\n        res = []\\n        t = 0\\n        for i in range(11, 0, -1):\\n            if dp[i][numArrows-t] == dp[i-1][numArrows-t]:\\n                res.append(0)\\n            else:\\n                res.append(aliceArrows[i] + 1)\\n                t += aliceArrows[i] + 1\\n        res.append(numArrows - t)\\n        return res[::-1]\\n```\\n\\nThis is my passed top down DP solution. Technically this is faster than bottoms up DP because of the data discretization. But the complexity is still numArrows * 12.\\n\\nThe time constraint is way too restrictive in the problem\\n\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        mem = [[-1] * (numArrows + 1) for _ in range(12)]\\n        def dp(i, n):\\n            if mem[i][n] == -1:\\n                if i == 0:\\n                    mem[i][n] = 0\\n                else:\\n                    mem[i][n] = dp(i - 1, n)\\n                    if n > aliceArrows[i]:\\n                        mem[i][n] = max(mem[i][n], i + dp(i - 1, n - aliceArrows[i] - 1))\\n            return mem[i][n]\\n        \\n        dp(11, numArrows)\\n        res = []\\n        t = 0\\n        for i in range(11, 0, -1):\\n            if mem[i][numArrows-t] == mem[i-1][numArrows-t]:\\n                res.append(0)\\n            else:\\n                res.append(aliceArrows[i] + 1)\\n                t += aliceArrows[i] + 1\\n        res.append(numArrows - t)\\n        return res[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        dp = [[0] * (numArrows + 1) for _ in range(12)]\\n        for i in range(12):\\n            for j in range(1, numArrows + 1):\\n                if i > 0:\\n                    dp[i][j] = dp[i-1][j]\\n                if j > aliceArrows[i]:\\n                    dp[i][j] = max(dp[i][j], i + dp[i-1][j-aliceArrows[i]-1])\\n        res = []\\n        t = 0\\n        for i in range(11, 0, -1):\\n            if dp[i][numArrows-t] == dp[i-1][numArrows-t]:\\n                res.append(0)\\n            else:\\n                res.append(aliceArrows[i] + 1)\\n                t += aliceArrows[i] + 1\\n        res.append(numArrows - t)\\n        return res[::-1]\\n```\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        mem = [[-1] * (numArrows + 1) for _ in range(12)]\\n        def dp(i, n):\\n            if mem[i][n] == -1:\\n                if i == 0:\\n                    mem[i][n] = 0\\n                else:\\n                    mem[i][n] = dp(i - 1, n)\\n                    if n > aliceArrows[i]:\\n                        mem[i][n] = max(mem[i][n], i + dp(i - 1, n - aliceArrows[i] - 1))\\n            return mem[i][n]\\n        \\n        dp(11, numArrows)\\n        res = []\\n        t = 0\\n        for i in range(11, 0, -1):\\n            if mem[i][numArrows-t] == mem[i-1][numArrows-t]:\\n                res.append(0)\\n            else:\\n                res.append(aliceArrows[i] + 1)\\n                t += aliceArrows[i] + 1\\n        res.append(numArrows - t)\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865734,
                "title": "can-someone-explain-what-happens-when-someone-shoots-in-0-target",
                "content": "I have been getting WA for a long time in this input:\\n\\n```\\nInput:\\n89\\n[3,2,28,1,7,1,16,7,3,13,3,5]\\nOutput:\\n[0,3,29,2,0,2,17,8,4,14,4,6]\\nExpected:\\n[21,3,0,2,8,2,17,8,4,14,4,6]\\n\\nKindly someone explain why 21 arrows are throwing in target 0.  \\nIf you cannot answer, please upvote so that someone can see and answer. Thank you in advance:)",
                "solutionTags": [],
                "code": "I have been getting WA for a long time in this input:\\n\\n```\\nInput:\\n89\\n[3,2,28,1,7,1,16,7,3,13,3,5]\\nOutput:\\n[0,3,29,2,0,2,17,8,4,14,4,6]\\nExpected:\\n[21,3,0,2,8,2,17,8,4,14,4,6]\\n\\nKindly someone explain why 21 arrows are throwing in target 0.  \\nIf you cannot answer, please upvote so that someone can see and answer. Thank you in advance:)",
                "codeTag": "Unknown"
            },
            {
                "id": 3028996,
                "title": "c-short-and-easy-to-understand-well-commented-sloution-using-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing the approach of take and not take in backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every index there are two possibilites either take its score or don\\'t take its score.\\n\\n# Complexity\\n- Time complexity:O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int>ans;//answer array \\nint maxpoints=0; //stores the maximum points by bob\\n    void solve(int ind,int score,int arrow,vector<int> &nums,vector<int> &res){\\n        if(arrow==0||ind<0){\\n            //if ind goes negitive or arrows count became 0.\\n            //Then check if current score is the maximum score .\\n            //If score is maximum the res array is ans array.\\n            if(score>maxpoints){\\n                maxpoints=score;\\n                ans=res;\\n            }\\n            return ;\\n        }\\n        //if available arrows is greater than the arrorws requires for the current score index then we can take this score.\\n        if(arrow>nums[ind]){\\n           res[ind]=nums[ind]+1;\\n            solve(ind-1,score+ind,arrow-(nums[ind]+1),nums,res);//taking the current index score.\\n          res[ind]=0;\\n           \\n        }\\n        //Here we are not taking the current index score.\\n        solve(ind-1,score,arrow,nums,res);\\n        \\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>res(12,0);//To store the values of arrows used by bob\\n        solve(11,0,numArrows,aliceArrows,res);\\n        int cnt=0;\\n        for(auto it:ans){\\n            cnt+=it;\\n\\n        }\\n        int startind=numArrows-cnt;\\n        if(startind>0){\\n            ans[0]+=startind;\\n        }\\n         return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\nvector<int>ans;//answer array \\nint maxpoints=0; //stores the maximum points by bob\\n    void solve(int ind,int score,int arrow,vector<int> &nums,vector<int> &res){\\n        if(arrow==0||ind<0){\\n            //if ind goes negitive or arrows count became 0.\\n            //Then check if current score is the maximum score .\\n            //If score is maximum the res array is ans array.\\n            if(score>maxpoints){\\n                maxpoints=score;\\n                ans=res;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2464440,
                "title": "c-simple-explained-backtracking-90-faster",
                "content": "We simplify this problem to simple subsequence problem to find the maximum points we can score.\\nWe start by selecting from end :-\\n\\n2 options - select a point by using 1 more than arrows used by alice.\\n\\t\\t\\t\\t  save the arrows and move ahead.\\n\\nWe use a default array to store the arrows used and a final answer array.\\nwhen we get a total greater than the previous total we store the arrows in the final array.\\n\\n2 cases to return :-\\n\\twhen i<0 and arrows are left OR arrows are finished.\\n\\twhen i<0 but arrows are used more then given....this is a discarded case we do not consider     answers from this case.\\n\\t\\n\\t```\\n\\tclass Solution {\\npublic:\\n    \\n    int ans = INT_MIN;\\n    vector<int> tempp;\\n    \\n    void recur(int i, int t, vector<int> &arr, int temp, vector<int> &anss)\\n    {   \\n        if((i<0 && t>=0) || t==0)\\n        {\\n            if(ans < max(ans,temp))\\n            {\\n                for(int j=0; j<12; j++)\\n                    tempp[j]=anss[j];\\n                \\n                //IF ALL THE ARROWS ARE NOT USED\\n                tempp[0]+= t;\\n            }\\n            \\n            ans = max(ans,temp);\\n            \\n            return;\\n        }\\n        \\n        else if(i<0)return;\\n        \\n        \\n        //TAKE\\n        if(t>=arr[i])\\n        {\\n            anss[i] = arr[i]+1;\\n            \\n            recur(i-1, (t-arr[i]-1), arr, temp+i, anss);\\n            anss[i]=0;\\n        }\\n        \\n        //LEAVE\\n        recur(i-1, t, arr, temp, anss);\\n    }\\n    \\n    vector<int> maximumBobPoints(int t, vector<int>& arr) \\n    {\\n        tempp.resize(12, 0);\\n        vector<int> anss(12, 0);\\n        recur(11,t,arr,0, anss);\\n        \\n        return tempp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n\\tclass Solution {\\npublic:\\n    \\n    int ans = INT_MIN;\\n    vector<int> tempp;\\n    \\n    void recur(int i, int t, vector<int> &arr, int temp, vector<int> &anss)\\n    {   \\n        if((i<0 && t>=0) || t==0)\\n        {\\n            if(ans < max(ans,temp))\\n            {\\n                for(int j=0; j<12; j++)\\n                    tempp[j]=anss[j];\\n                \\n                //IF ALL THE ARROWS ARE NOT USED\\n                tempp[0]+= t;\\n            }\\n            \\n            ans = max(ans,temp);\\n            \\n            return;\\n        }\\n        \\n        else if(i<0)return;\\n        \\n        \\n        //TAKE\\n        if(t>=arr[i])\\n        {\\n            anss[i] = arr[i]+1;\\n            \\n            recur(i-1, (t-arr[i]-1), arr, temp+i, anss);\\n            anss[i]=0;\\n        }\\n        \\n        //LEAVE\\n        recur(i-1, t, arr, temp, anss);\\n    }\\n    \\n    vector<int> maximumBobPoints(int t, vector<int>& arr) \\n    {\\n        tempp.resize(12, 0);\\n        vector<int> anss(12, 0);\\n        recur(11,t,arr,0, anss);\\n        \\n        return tempp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273858,
                "title": "c-backtracking-easy-to-understand",
                "content": "**Approach:** We will cover all paths and each time the index reaches the last(i.e. 12) and the current score is greater than the maxscore we will update the ans vector with bob vector. We will make two calls from each index whether to consider that index or not.\\nAt last we will get the solution with the max score.\\n\\nclass Solution {\\npublic:\\n\\n    int maxScore = 0;\\n    vector<int> ans;\\n    \\n    void dfs(int idx, int arrows, int score, vector<int> &alice, vector<int> &bob){\\n        if(idx == 12){\\n            if(score > maxScore){\\n                ans = bob;\\n\\t\\t\\t\\t//add remaining arrows at any index(here, i am adding in last index) in ans, it won\\'t matter since it will accept any solution.\\n\\t\\t\\t\\t//we are doing this since we have to use all arrows.\\n                ans.back() += arrows; \\n                maxScore = score;\\n            }\\n            return;\\n        }\\n        // below call will simply skip the current index.\\n        dfs(idx + 1, arrows, score, alice, bob);\\n\\t\\t\\n\\t\\t//this call will take the score of the index only if we have enough arrows to shoot.\\n        if(arrows > alice[idx]){\\n            bob[idx] = alice[idx] + 1;\\n            dfs(idx + 1, arrows - alice[idx] - 1, score + idx, alice, bob);\\n            bob[idx] = 0;\\n        }\\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> bob(12, 0);\\n        dfs(0, numArrows, 0, aliceArrows, bob);\\n        return ans;\\n    }\\n};\\n\\n**Time: O(2^N)**\\n**PLEASE UPVOTE IF HELPFUL!!!**\\nFor query or doubt comment below.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxScore = 0;\\n    vector<int> ans;\\n    \\n    void dfs(int idx, int arrows, int score, vector<int> &alice, vector<int> &bob){\\n        if(idx == 12){\\n            if(score > maxScore){\\n                ans = bob;\\n\\t\\t\\t\\t//add remaining arrows at any index(here, i am adding in last index) in ans, it won\\'t matter since it will accept any solution.\\n\\t\\t\\t\\t//we are doing this since we have to use all arrows.\\n                ans.back() += arrows; \\n                maxScore = score;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2239104,
                "title": "intuitive-pick-don-t-pick-method-c",
                "content": "```\\nclass Solution {\\n\\n  int mx = INT_MIN;\\n\\npublic:\\n\\n  void help(int numArrows, vector<int> &aliceArrows, int idx, vector<int>&temp, vector<int> &bob) {\\n\\n    if (idx == 12) {\\n      int sum = 0;\\n      for (int i = 0; i < 12; i++) {\\n        if (temp[i])\\n          sum += i;\\n      }\\n\\n      // dump the rest of the arrows remaining to temp[0]\\n      if (numArrows) {\\n        temp[0] += numArrows;\\n      }\\n\\n      if (sum > mx) {\\n        mx = sum;\\n        bob = temp;\\n      }\\n\\n      temp[0] -= numArrows;\\n\\n      return;\\n    }\\n\\n    // take\\n    if (numArrows > aliceArrows[idx]) {\\n      temp[idx] = aliceArrows[idx] + 1;\\n      numArrows -= aliceArrows[idx] + 1;\\n      help(numArrows, aliceArrows, idx + 1, temp, bob);\\n      temp[idx] = 0;\\n      numArrows += aliceArrows[idx] + 1;\\n    }\\n\\n    // don\\'t take\\n    help(numArrows, aliceArrows, idx + 1, temp, bob);\\n\\n  }\\n\\n  vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n    vector<int> temp(12, 0);\\n    vector<int> bob;\\n    help(numArrows, aliceArrows, 0, temp, bob);\\n\\n    return bob;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n  int mx = INT_MIN;\\n\\npublic:\\n\\n  void help(int numArrows, vector<int> &aliceArrows, int idx, vector<int>&temp, vector<int> &bob) {\\n\\n    if (idx == 12) {\\n      int sum = 0;\\n      for (int i = 0; i < 12; i++) {\\n        if (temp[i])\\n          sum += i;\\n      }\\n\\n      // dump the rest of the arrows remaining to temp[0]\\n      if (numArrows) {\\n        temp[0] += numArrows;\\n      }\\n\\n      if (sum > mx) {\\n        mx = sum;\\n        bob = temp;\\n      }\\n\\n      temp[0] -= numArrows;\\n\\n      return;\\n    }\\n\\n    // take\\n    if (numArrows > aliceArrows[idx]) {\\n      temp[idx] = aliceArrows[idx] + 1;\\n      numArrows -= aliceArrows[idx] + 1;\\n      help(numArrows, aliceArrows, idx + 1, temp, bob);\\n      temp[idx] = 0;\\n      numArrows += aliceArrows[idx] + 1;\\n    }\\n\\n    // don\\'t take\\n    help(numArrows, aliceArrows, idx + 1, temp, bob);\\n\\n  }\\n\\n  vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n    vector<int> temp(12, 0);\\n    vector<int> bob;\\n    help(numArrows, aliceArrows, 0, temp, bob);\\n\\n    return bob;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165663,
                "title": "c-one-backtracking-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int m=0;\\n    vector<int> ans;\\n    void func(vector<int> &temp,int score,int numArrows,vector<int> aliceArrows,int index)\\n    {\\n        //Base case\\n        if(index==aliceArrows.size())\\n        {\\n            //If this combination gives greater score\\n            if(m<score)\\n            {\\n                //Update to max score\\n                m=score;\\n                for(int i=0;i<ans.size();i++)\\n                {\\n                    ans[i]=temp[i];\\n                }\\n                //If there are any remaining arrows then place them at ans[0]\\n                ans[0]+=numArrows;\\n            }\\n            return;\\n        }\\n        \\n        //Recursive case\\n        //Bob winning case\\n        if(aliceArrows[index]<numArrows)\\n        {\\n            //For winning case min possible arrows to be placed are alice score at that index+1\\n            temp[index]=aliceArrows[index]+1;\\n            func(temp,score+index,numArrows-temp[index],aliceArrows,index+1);\\n            //Backtrack for getting all possiblilties\\n            temp[index]=0;\\n        }\\n        //Bob loosing case dont add arrows at that index\\n        func(temp,score,numArrows,aliceArrows,index+1);\\n        \\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        vector<int>temp(aliceArrows.size(),0);\\n        \\n        for(int i=0;i<aliceArrows.size();i++)\\n        {\\n            ans.push_back(0);\\n        }\\n        func(temp,0,numArrows,aliceArrows,0);\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m=0;\\n    vector<int> ans;\\n    void func(vector<int> &temp,int score,int numArrows,vector<int> aliceArrows,int index)\\n    {\\n        //Base case\\n        if(index==aliceArrows.size())\\n        {\\n            //If this combination gives greater score\\n            if(m<score)\\n            {\\n                //Update to max score\\n                m=score;\\n                for(int i=0;i<ans.size();i++)\\n                {\\n                    ans[i]=temp[i];\\n                }\\n                //If there are any remaining arrows then place them at ans[0]\\n                ans[0]+=numArrows;\\n            }\\n            return;\\n        }\\n        \\n        //Recursive case\\n        //Bob winning case\\n        if(aliceArrows[index]<numArrows)\\n        {\\n            //For winning case min possible arrows to be placed are alice score at that index+1\\n            temp[index]=aliceArrows[index]+1;\\n            func(temp,score+index,numArrows-temp[index],aliceArrows,index+1);\\n            //Backtrack for getting all possiblilties\\n            temp[index]=0;\\n        }\\n        //Bob loosing case dont add arrows at that index\\n        func(temp,score,numArrows,aliceArrows,index+1);\\n        \\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        vector<int>temp(aliceArrows.size(),0);\\n        \\n        for(int i=0;i<aliceArrows.size();i++)\\n        {\\n            ans.push_back(0);\\n        }\\n        func(temp,0,numArrows,aliceArrows,0);\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1925467,
                "title": "c-easyto-understand-simple-solution-using-bit-masking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& alice) {\\n        vector<int> ans;\\n        int maxi=INT_MIN;\\n        int curr;\\n        for(int i=1;i<4096;i++)\\n        {\\n            int num=numArrows;\\n            vector<int> temp(12,0);\\n            for(int j=11;j>=1;j--)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    if(num>alice[j])\\n                    {\\n                        num-=(alice[j]+1);\\n                        temp[j]=(alice[j]+1);\\n                    }\\n                }\\n            }\\n            if(num>0)\\n            for(int j=1;j<12;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    temp[j]+=num;\\n                    break;\\n                }\\n            }\\n            curr=0;\\n            for(int i=1;i<12;i++)\\n            {\\n                if(temp[i]>alice[i])\\n                {\\n                    curr+=i;\\n                }\\n            }\\n            if(curr>maxi)\\n            {\\n                maxi=curr;\\n                ans=temp;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& alice) {\\n        vector<int> ans;\\n        int maxi=INT_MIN;\\n        int curr;\\n        for(int i=1;i<4096;i++)\\n        {\\n            int num=numArrows;\\n            vector<int> temp(12,0);\\n            for(int j=11;j>=1;j--)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    if(num>alice[j])\\n                    {\\n                        num-=(alice[j]+1);\\n                        temp[j]=(alice[j]+1);\\n                    }\\n                }\\n            }\\n            if(num>0)\\n            for(int j=1;j<12;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    temp[j]+=num;\\n                    break;\\n                }\\n            }\\n            curr=0;\\n            for(int i=1;i<12;i++)\\n            {\\n                if(temp[i]>alice[i])\\n                {\\n                    curr+=i;\\n                }\\n            }\\n            if(curr>maxi)\\n            {\\n                maxi=curr;\\n                ans=temp;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896944,
                "title": "brute-forcing-all-the-possible-mask",
                "content": "```\\n\\n// Just Brute Force the val for all possible masks and find out the best mask \\nclass Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] arr) {\\n        \\n        int maxMask =0;\\n        int maxVal =0;\\n        for(int mask =0; mask<=(1<<12);mask++)\\n        {\\n            int total = numArrows;\\n            int val =0;\\n           \\n                for(int i=0;i<12;i++)\\n                {\\n                    \\n                    if(((mask>>i)&1)==1)\\n                    {\\n                        total -= (arr[i]+1);\\n                        val +=i;\\n                    }\\n                }\\n                  \\n            \\n            if(total>=0)\\n            {\\n                \\n                if(maxVal<=val)\\n                {\\n                    maxVal = val;\\n                    maxMask = mask;\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        int ans[] = new int[12];\\n        int totalval =0;\\n        for(int i=0;i<12;i++)\\n        {\\n            \\n            if(((maxMask>>i)&1)==1)\\n            {\\n                 ans[i] = arr[i]+1;\\n                totalval+=ans[i];\\n            }\\n           \\n        }\\n    \\n        ans[0]+=(numArrows-totalval);\\n        // This line just adds any extra arrows remaining after getting optimal masks\\n        return ans;\\n    }\\n}\\n``",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "class Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] arr) {\\n        \\n        int maxMask =0;\\n        int maxVal =0;\\n        for(int mask =0; mask<=(1<<12);mask++)\\n        {\\n            int total = numArrows;\\n            int val =0;\\n           \\n                for(int i=0;i<12;i++)\\n                {\\n                    \\n                    if(((mask>>i)&1)==1)\\n                    {\\n                        total -= (arr[i]+1);\\n                        val +=i;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1895159,
                "title": "c-clean-code-backtracking",
                "content": "```\\nclass Solution \\n{\\n    vector<int> bobArrows;\\n    int maxBobScore = 0;\\npublic:\\n    \\n    void backtrack(vector<int> &aliceArrows, int idx, int numArrows,int currBobScore,vector<int> &currBobArrows){\\n        \\n        if(idx == aliceArrows.size() or numArrows == 0){\\n            \\n            if(currBobScore > maxBobScore){\\n                bobArrows = currBobArrows;\\n                maxBobScore = currBobScore;\\n            }\\n            \\n            return ;\\n        }\\n        \\n        if(numArrows > aliceArrows[idx]){\\n            \\n            currBobArrows[idx] = aliceArrows[idx] + 1;\\n            backtrack(aliceArrows,idx+1,numArrows-currBobArrows[idx],currBobScore+idx,currBobArrows);\\n            currBobArrows[idx] = 0;\\n        }\\n        \\n        backtrack(aliceArrows,idx + 1, numArrows, currBobScore,currBobArrows);\\n        \\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        \\n        vector<int> currBobArrows(12,0);\\n        \\n        backtrack(aliceArrows,0,numArrows,0,currBobArrows);\\n        \\n        int countBobArrows = accumulate(bobArrows.begin(), bobArrows.end(),0);\\n        \\n        if(countBobArrows < numArrows)\\n            bobArrows.back() += numArrows - countBobArrows;\\n        \\n        return bobArrows;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution \\n{\\n    vector<int> bobArrows;\\n    int maxBobScore = 0;\\npublic:\\n    \\n    void backtrack(vector<int> &aliceArrows, int idx, int numArrows,int currBobScore,vector<int> &currBobArrows){\\n        \\n        if(idx == aliceArrows.size() or numArrows == 0){\\n            \\n            if(currBobScore > maxBobScore){\\n                bobArrows = currBobArrows;\\n                maxBobScore = currBobScore;\\n            }\\n            \\n            return ;\\n        }\\n        \\n        if(numArrows > aliceArrows[idx]){\\n            \\n            currBobArrows[idx] = aliceArrows[idx] + 1;\\n            backtrack(aliceArrows,idx+1,numArrows-currBobArrows[idx],currBobScore+idx,currBobArrows);\\n            currBobArrows[idx] = 0;\\n        }\\n        \\n        backtrack(aliceArrows,idx + 1, numArrows, currBobScore,currBobArrows);\\n        \\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        \\n        vector<int> currBobArrows(12,0);\\n        \\n        backtrack(aliceArrows,0,numArrows,0,currBobArrows);\\n        \\n        int countBobArrows = accumulate(bobArrows.begin(), bobArrows.end(),0);\\n        \\n        if(countBobArrows < numArrows)\\n            bobArrows.back() += numArrows - countBobArrows;\\n        \\n        return bobArrows;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882605,
                "title": "c-iterating-over-all-masks-and-updating-the-answer",
                "content": "I have iterated over all possible masks and updated the resultant array .the solution itself is self explanatory lastly I have added the remaning arrows to score 0 with bob as they won\\'t contribute anything to the answer .\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int n, vector<int>& a) {\\n        int ans =0 ;\\n        vector <int> res;\\n        \\n        for( int i = 0 ; i <= ( 1 << 12 ) - 1 ; i++ )\\n        {\\n            int req_arrows = 0 , temp_ans =0 ;\\n            vector <int> dummy;\\n            for ( int j  = 0; j <= 11 ; j++ )\\n            {\\n                if( i & ( 1ll << j ) )\\n                {\\n                    req_arrows += a[j]+1; \\n                    dummy.push_back(a[j] + 1);\\n                    temp_ans += j;\\n                }\\n                else\\n                {\\n                    dummy.push_back(0);\\n                }\\n            }\\n            if( req_arrows <= n )\\n            {\\n                if( ans <  temp_ans)\\n                {\\n                    res = dummy;\\n                    ans = temp_ans;\\n                }\\n            }\\n        }\\n        res[0] += n - accumulate(res.begin() , res.end() , 0);\\n        return res;\\n    }\\n};\\n```\\n\\nDo ask in comments if u find anything unclear",
                "solutionTags": [
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int n, vector<int>& a) {\\n        int ans =0 ;\\n        vector <int> res;\\n        \\n        for( int i = 0 ; i <= ( 1 << 12 ) - 1 ; i++ )\\n        {\\n            int req_arrows = 0 , temp_ans =0 ;\\n            vector <int> dummy;\\n            for ( int j  = 0; j <= 11 ; j++ )\\n            {\\n                if( i & ( 1ll << j ) )\\n                {\\n                    req_arrows += a[j]+1; \\n                    dummy.push_back(a[j] + 1);\\n                    temp_ans += j;\\n                }\\n                else\\n                {\\n                    dummy.push_back(0);\\n                }\\n            }\\n            if( req_arrows <= n )\\n            {\\n                if( ans <  temp_ans)\\n                {\\n                    res = dummy;\\n                    ans = temp_ans;\\n                }\\n            }\\n        }\\n        res[0] += n - accumulate(res.begin() , res.end() , 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874300,
                "title": "my-java-backtrack-solution-always-consider-for-2-choice-take-or-skip",
                "content": "```\\nclass Solution {\\n    private int pointForBob = 0;\\n    private int [] bobArrows = new int [12];\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int length = aliceArrows.length;\\n        int [] bob = new int [length];\\n        // in my opninon we have two options to consider\\n        // we can either shoot at a section or, we can skip and continue to the next section\\n        // in hope of finding the optimal score\\n        // backtrack and try to find the optimal\\n        backtrack(aliceArrows, bob, 11, 0, numArrows); // we start from back\\n        return bobArrows;\\n    }\\n    \\n    public void backtrack(int [] alice, int [] bob, int pos, int currentMax, int arrows) {\\n        if (pos < 0 || arrows <= 0) {\\n            if (arrows > 0) {\\n                bob[0] += arrows;\\n            }\\n            if (currentMax > pointForBob) {\\n                // we found a better result with better score card\\n                // so copy that\\n                pointForBob = currentMax;\\n                bobArrows = bob.clone();\\n            }\\n            return;\\n        }\\n        \\n        // two options as said\\n        // consider the current section point and move onto the next one\\n        if (arrows >= alice[pos] + 1) {\\n            bob[pos] = alice[pos] + 1;\\n            backtrack(alice, bob, pos - 1, currentMax + pos, arrows - alice[pos] - 1);\\n            bob[pos] = 0;\\n        }\\n        // other option is to just skip our current choice\\n        backtrack(alice, bob, pos - 1, currentMax, arrows);\\n        bob[pos] = 0;\\n    }\\n}\\n\\n// O(2 ^ 12)\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private int pointForBob = 0;\\n    private int [] bobArrows = new int [12];\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int length = aliceArrows.length;\\n        int [] bob = new int [length];\\n        // in my opninon we have two options to consider\\n        // we can either shoot at a section or, we can skip and continue to the next section\\n        // in hope of finding the optimal score\\n        // backtrack and try to find the optimal\\n        backtrack(aliceArrows, bob, 11, 0, numArrows); // we start from back\\n        return bobArrows;\\n    }\\n    \\n    public void backtrack(int [] alice, int [] bob, int pos, int currentMax, int arrows) {\\n        if (pos < 0 || arrows <= 0) {\\n            if (arrows > 0) {\\n                bob[0] += arrows;\\n            }\\n            if (currentMax > pointForBob) {\\n                // we found a better result with better score card\\n                // so copy that\\n                pointForBob = currentMax;\\n                bobArrows = bob.clone();\\n            }\\n            return;\\n        }\\n        \\n        // two options as said\\n        // consider the current section point and move onto the next one\\n        if (arrows >= alice[pos] + 1) {\\n            bob[pos] = alice[pos] + 1;\\n            backtrack(alice, bob, pos - 1, currentMax + pos, arrows - alice[pos] - 1);\\n            bob[pos] = 0;\\n        }\\n        // other option is to just skip our current choice\\n        backtrack(alice, bob, pos - 1, currentMax, arrows);\\n        bob[pos] = 0;\\n    }\\n}\\n\\n// O(2 ^ 12)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871465,
                "title": "c-backtracking",
                "content": "```\\n\\tpublic int[] MaximumBobPoints(int numArrows, int[] aliceArrows) {\\n        (int[] arrows, int score) bestAttempt = (new int[aliceArrows.Length], 0);\\n        (int[] arrows, int numArrows) alice = (aliceArrows, numArrows);\\n        (int[] arrows, int numArrows, int score) bob = (new int[aliceArrows.Length], 0, 0);\\n        Backtracking(ref bestAttempt, alice, bob, 1);\\n        return bestAttempt.arrows;\\n    }\\n    \\n    void Backtracking(ref (int[] arrows, int score) bestAttempt, (int[] arrows, int numArrows) alice, (int[] arrows, int numArrows, int score) bob, int index) {\\n        if (bob.numArrows <= alice.numArrows && bob.score > bestAttempt.score) { // update best attempt\\n            bestAttempt.score = bob.score;\\n            bob.arrows.CopyTo(bestAttempt.arrows, 0);\\n            bestAttempt.arrows[0] = alice.numArrows-bob.numArrows; // add unused arrows if required\\n        }\\n        for (int i=index; i<alice.arrows.Length; i++) {\\n            bob.arrows[i] = alice.arrows[i]+1;\\n            bob.numArrows += bob.arrows[i];\\n            bob.score += i;\\n            Backtracking(ref bestAttempt, alice, bob, i+1);\\n            bob.score -= i;\\n            bob.numArrows -= bob.arrows[i];\\n            bob.arrows[i] = 0;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\n\\tpublic int[] MaximumBobPoints(int numArrows, int[] aliceArrows) {\\n        (int[] arrows, int score) bestAttempt = (new int[aliceArrows.Length], 0);\\n        (int[] arrows, int numArrows) alice = (aliceArrows, numArrows);\\n        (int[] arrows, int numArrows, int score) bob = (new int[aliceArrows.Length], 0, 0);\\n        Backtracking(ref bestAttempt, alice, bob, 1);\\n        return bestAttempt.arrows;\\n    }\\n    \\n    void Backtracking(ref (int[] arrows, int score) bestAttempt, (int[] arrows, int numArrows) alice, (int[] arrows, int numArrows, int score) bob, int index) {\\n        if (bob.numArrows <= alice.numArrows && bob.score > bestAttempt.score) { // update best attempt\\n            bestAttempt.score = bob.score;\\n            bob.arrows.CopyTo(bestAttempt.arrows, 0);\\n            bestAttempt.arrows[0] = alice.numArrows-bob.numArrows; // add unused arrows if required\\n        }\\n        for (int i=index; i<alice.arrows.Length; i++) {\\n            bob.arrows[i] = alice.arrows[i]+1;\\n            bob.numArrows += bob.arrows[i];\\n            bob.score += i;\\n            Backtracking(ref bestAttempt, alice, bob, i+1);\\n            bob.score -= i;\\n            bob.numArrows -= bob.arrows[i];\\n            bob.arrows[i] = 0;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1869794,
                "title": "c-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>ans;\\n        \\n        //total 2^12 choice to select the answers one maximum satisfying all condition will give the answer\\n        int answer1=0;\\n        for(int i=0; i<(1<<12); i++)\\n        {\\n            int cnt=i;\\n            //total count needed for this combination if less than numArrows then it can be the answer\\n            int tot=0,answer=0;\\n            vector<int>v(12,0);\\n            for(int j=0; j<12; j++)\\n            {\\n                if(cnt&(1<<j))\\n                {\\n                    tot+=aliceArrows[j]+1;\\n                    answer+=j;\\n                    v[j]=aliceArrows[j]+1;\\n                }\\n            }\\n            \\n            if(tot<=numArrows)\\n            {\\n                if(answer>answer1)\\n                {\\n                    answer1=answer;\\n                    int val=numArrows-tot;\\n                    v[11]+=val;\\n                    ans=v;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>ans;\\n        \\n        //total 2^12 choice to select the answers one maximum satisfying all condition will give the answer\\n        int answer1=0;\\n        for(int i=0; i<(1<<12); i++)\\n        {\\n            int cnt=i;\\n            //total count needed for this combination if less than numArrows then it can be the answer\\n            int tot=0,answer=0;\\n            vector<int>v(12,0);\\n            for(int j=0; j<12; j++)\\n            {\\n                if(cnt&(1<<j))\\n                {\\n                    tot+=aliceArrows[j]+1;\\n                    answer+=j;\\n                    v[j]=aliceArrows[j]+1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1866600,
                "title": "why-bottom-up-approaches-get-tle",
                "content": "The problem is just a simple variation of Knapsack problem, and is done by the Pick-NonPick strategy. However the Bottom Up Solutions get TLE. WHY ?\\n\\nActually , the Bottom Up approach solves each and every subproblem; the approach does not care which \"exact\" subproblems lead to the answer of the bigger problem. Although this is a boon in many cases like \"Divide an array such that sum of the smaller arrays created have a specific difference or minimum difference\", it has the disadvantage of solving \"unncessary subproblems\".\\n\\nIn this problem, for when numArrays is a big number like 5000,\\nthe bottom up approach solves all the (5000 * 12) subproblems, but\\nthe top down approcah solves way less than (5000 * 12) subproblems; it solves only those that are needed for calculating the maxScore using (5000 arrows and  for 12 targets).\\n\\nSo, the bottom up approach in these scenarios consume a lot of time calculating subproblems which are \"unnecessary for calculating the result of the biggger subproblem\". Hence the TLE !!!!\\n\\nLets print our cache and check, whether all subproblems are computed or not.\\n\\n![image](https://assets.leetcode.com/users/images/f2a1addb-877e-46a4-bad7-fede094c8d95_1647765418.6035116.png)\\n\\n\\nThe subproblems whose maxScores are \"-1\";  they did not get calculated. Hence saves a lot of time.\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        maxScoreCache= Solution.createCache(12,numArrows); targets= 12\\n        \\n        remainingTargets= targets;arrowCount= numArrows\\n        Solution.calculateMaxScore(remainingTargets,arrowCount,aliceArrows,maxScoreCache)\\n        bobArrows= Solution.getBobArrows(maxScoreCache,aliceArrows,targets,numArrows)\\n        return bobArrows\\n    \\n    @staticmethod\\n    def calculateMaxScore(remainingTargets,arrowCount,aliceArrows,maxScoreCache):\\n        \\n        \"\"\"\\n            The function calculates maxScore that Bob can earn\\n            using \\'arrowCount\\' arrows and from \\'remainingTargets\\' targets\\n        \"\"\"\\n        \\n        if remainingTargets== 0 or arrowCount== 0:\\n            maxScore= 0; maxScoreCache[remainingTargets][arrowCount]= maxScore; return maxScore\\n        \\n        if maxScoreCache[remainingTargets][arrowCount]!= -1: return maxScoreCache[remainingTargets][arrowCount]\\n        \\n        targetIndex= remainingTargets-1\\n        # Can this target be hit optimally; If yes then lets check \\n        # Which provides max score : hitting the target or leaving the target\\n\\n        if arrowCount> aliceArrows[targetIndex]: \\n            # Hitting may result in getting max Score\\n\\n            # Hit\\n            currPointsHit= targetIndex\\n            currPointsHit+= Solution.calculateMaxScore(remainingTargets-1,arrowCount-(aliceArrows[targetIndex]+1),aliceArrows,maxScoreCache)\\n\\n            #Not Hit\\n            currPointsNotHit= 0\\n            currPointsNotHit+= Solution.calculateMaxScore(remainingTargets-1,arrowCount,aliceArrows,maxScoreCache)\\n\\n            currPoints= max(currPointsHit,currPointsNotHit)\\n\\n        #  We may hit the target otherwise ,but the arrows will be wasted\\n\\t\\t#  If the target can\\'t be hit optimally. then lets not hit\\n        else:\\n            # We exclude hitting the target\\n            currPointsNotHit= 0\\n            currPointsNotHit+= Solution.calculateMaxScore(remainingTargets-1,arrowCount,aliceArrows,maxScoreCache)\\n\\n            currPoints= currPointsNotHit\\n\\n        maxScoreCache[remainingTargets][arrowCount]= currPoints\\n        return maxScoreCache[remainingTargets][arrowCount]\\n\\n    @staticmethod\\n    def createCache(ROWS,COLS):\\n        cache= list()\\n        for _ in range(ROWS+1):cache.append([-1]*(COLS+1))\\n        return cache\\n                    \\n    @staticmethod\\n    def getBobArrows(cache,aliceArrows,targets,numArrows):\\n        remainingTargets= targets; arrowCount= numArrows\\n        \\n        bobArrows= [0]*targets\\n        while remainingTargets>0 and arrowCount>0:\\n            maxArrows= cache[remainingTargets][numArrows]\\n            targetIndex= remainingTargets-1\\n            \\n            if arrowCount> aliceArrows[targetIndex]:\\n                currPointsHit= targetIndex\\n                currPointsHit+= cache[remainingTargets-1][arrowCount-(aliceArrows[targetIndex]+1)]\\n                \\n                currPointsNotHit= 0\\n                currPointsNotHit+= cache[remainingTargets-1][arrowCount]\\n                \\n                if cache[remainingTargets][arrowCount]== currPointsHit:\\n                    \\n                    bobArrows[targetIndex]= (aliceArrows[targetIndex]+1) if remainingTargets!=1 else arrowCount\\n                    remainingTargets-= 1; arrowCount-= bobArrows[targetIndex]\\n                else: \\n                    if remainingTargets== 1:bobArrows[targetIndex]= arrowCount\\n                    remainingTargets-= 1\\n                    \\n            else:\\n                if remainingTargets== 1:bobArrows[targetIndex]= arrowCount\\n                remainingTargets-= 1\\n                    \\n        return bobArrows\\n                \\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        maxScoreCache= Solution.createCache(12,numArrows); targets= 12\\n        \\n        remainingTargets= targets;arrowCount= numArrows\\n        Solution.calculateMaxScore(remainingTargets,arrowCount,aliceArrows,maxScoreCache)\\n        bobArrows= Solution.getBobArrows(maxScoreCache,aliceArrows,targets,numArrows)\\n        return bobArrows\\n    \\n    @staticmethod\\n    def calculateMaxScore(remainingTargets,arrowCount,aliceArrows,maxScoreCache):\\n        \\n        \"\"\"\\n            The function calculates maxScore that Bob can earn\\n            using \\'arrowCount\\' arrows and from \\'remainingTargets\\' targets\\n        \"\"\"\\n        \\n        if remainingTargets== 0 or arrowCount== 0:\\n            maxScore= 0; maxScoreCache[remainingTargets][arrowCount]= maxScore; return maxScore\\n        \\n        if maxScoreCache[remainingTargets][arrowCount]!= -1: return maxScoreCache[remainingTargets][arrowCount]\\n        \\n        targetIndex= remainingTargets-1\\n        # Can this target be hit optimally; If yes then lets check \\n        # Which provides max score : hitting the target or leaving the target\\n\\n        if arrowCount> aliceArrows[targetIndex]: \\n            # Hitting may result in getting max Score\\n\\n            # Hit\\n            currPointsHit= targetIndex\\n            currPointsHit+= Solution.calculateMaxScore(remainingTargets-1,arrowCount-(aliceArrows[targetIndex]+1),aliceArrows,maxScoreCache)\\n\\n            #Not Hit\\n            currPointsNotHit= 0\\n            currPointsNotHit+= Solution.calculateMaxScore(remainingTargets-1,arrowCount,aliceArrows,maxScoreCache)\\n\\n            currPoints= max(currPointsHit,currPointsNotHit)\\n\\n        #  We may hit the target otherwise ,but the arrows will be wasted\\n\\t\\t#  If the target can\\'t be hit optimally. then lets not hit\\n        else:\\n            # We exclude hitting the target\\n            currPointsNotHit= 0\\n            currPointsNotHit+= Solution.calculateMaxScore(remainingTargets-1,arrowCount,aliceArrows,maxScoreCache)\\n\\n            currPoints= currPointsNotHit\\n\\n        maxScoreCache[remainingTargets][arrowCount]= currPoints\\n        return maxScoreCache[remainingTargets][arrowCount]\\n\\n    @staticmethod\\n    def createCache(ROWS,COLS):\\n        cache= list()\\n        for _ in range(ROWS+1):cache.append([-1]*(COLS+1))\\n        return cache\\n                    \\n    @staticmethod\\n    def getBobArrows(cache,aliceArrows,targets,numArrows):\\n        remainingTargets= targets; arrowCount= numArrows\\n        \\n        bobArrows= [0]*targets\\n        while remainingTargets>0 and arrowCount>0:\\n            maxArrows= cache[remainingTargets][numArrows]\\n            targetIndex= remainingTargets-1\\n            \\n            if arrowCount> aliceArrows[targetIndex]:\\n                currPointsHit= targetIndex\\n                currPointsHit+= cache[remainingTargets-1][arrowCount-(aliceArrows[targetIndex]+1)]\\n                \\n                currPointsNotHit= 0\\n                currPointsNotHit+= cache[remainingTargets-1][arrowCount]\\n                \\n                if cache[remainingTargets][arrowCount]== currPointsHit:\\n                    \\n                    bobArrows[targetIndex]= (aliceArrows[targetIndex]+1) if remainingTargets!=1 else arrowCount\\n                    remainingTargets-= 1; arrowCount-= bobArrows[targetIndex]\\n                else: \\n                    if remainingTargets== 1:bobArrows[targetIndex]= arrowCount\\n                    remainingTargets-= 1\\n                    \\n            else:\\n                if remainingTargets== 1:bobArrows[targetIndex]= arrowCount\\n                remainingTargets-= 1\\n                    \\n        return bobArrows\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866001,
                "title": "just-dp-c",
                "content": "I implemented the solution with just dynamic programming. I use dp[i][j] to store the maximum value that Bob can achieve starting from 0th target up to (i-1)th one with j arrows. \\nFor each target, Bob can either:\\n1. win the current target (i-1) and get the maximum points in the previous targets with the the number of arrows remaining after the win , i.e. **dp[i-1][remaing arrows after this win]**\\n2. lose the current target and get the maximum points in the previous targets with all the arrows, i.e. **dp[i-1][all arrows]**\\n\\nWe will then check which is larger and store the value.\\n\\n*Since the question requries us to give the combination that gives that maximum points and the maximum points attainable is 66, which is less than 7 bits, I will use the bits after the 7th to store a 12-bit pattern indicating whether Bob wins in each target.*\\n```\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int dp[13][numArrows+1];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i = 1; i < 13; i ++){\\n            for(int j = 1; j <= numArrows; j++){\\n                dp[i][j] = dp[i-1][j];\\n\\t\\t\\t\\t// check whether winning in the current target yields a higher value\\n                if ((j-aliceArrows[i-1] >= 1) && ((dp[i-1][j] & 127) < (i - 1 + (dp[i-1][j-aliceArrows[i-1] - 1]) & 127) )){\\n                    dp[i][j] = i - 1 + dp[i-1][j-aliceArrows[i-1] - 1] + (1 << (i + 7));\\n                }\\n            }\\n        }\\n        vector<int> res(12);\\n        int total = 0;\\n\\t\\t// decode the bits\\n        for(int i = 0; i < 12; i++){\\n            if(dp[12][numArrows] >> (i + 8) & 1){\\n                res[i] = aliceArrows[i]+1;\\n                total += res[i];\\n            }\\n        }\\n\\t\\t// deal with the arrows that are not used\\n        if(total != numArrows){\\n            res[0] += numArrows - total;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nNote that after decoding the maximum value, we check for the total number of arrows Bob used to shoot in order to get the maximum points. If the total is less than the number of arrows provided, we simply put the remaining in the first target(that does not affect the result).",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int dp[13][numArrows+1];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i = 1; i < 13; i ++){\\n            for(int j = 1; j <= numArrows; j++){\\n                dp[i][j] = dp[i-1][j];\\n\\t\\t\\t\\t// check whether winning in the current target yields a higher value\\n                if ((j-aliceArrows[i-1] >= 1) && ((dp[i-1][j] & 127) < (i - 1 + (dp[i-1][j-aliceArrows[i-1] - 1]) & 127) )){\\n                    dp[i][j] = i - 1 + dp[i-1][j-aliceArrows[i-1] - 1] + (1 << (i + 7));\\n                }\\n            }\\n        }\\n        vector<int> res(12);\\n        int total = 0;\\n\\t\\t// decode the bits\\n        for(int i = 0; i < 12; i++){\\n            if(dp[12][numArrows] >> (i + 8) & 1){\\n                res[i] = aliceArrows[i]+1;\\n                total += res[i];\\n            }\\n        }\\n\\t\\t// deal with the arrows that are not used\\n        if(total != numArrows){\\n            res[0] += numArrows - total;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865910,
                "title": "simple-recursive-solution-o-2-12",
                "content": "```\\nclass Solution {\\npublic:\\n    \\nvoid solve(int i, int n,vector<int>& a, vector<int>& now, vector<int> &ans, int snow, int &smax ){ \\n        if (i>=11)\\n        {\\n            // put all left over arrows in last section\\n            now[11]=n;\\n            if (n<=a[i]){\\n                if (snow>smax)\\n                {\\n                    ans=now;\\n                    smax=snow;\\n                }\\n            \\n            }else{ \\n                if (snow+11>smax)\\n                {\\n                    ans=now;\\n                    smax=snow+11;\\n                }\\n                \\n            }\\n            \\n            return;\\n        }\\n        \\n        // option 1 -- we dont care for this section\\n        now[i]=0;\\n        solve(i+1,n,a,now,ans,snow,smax);\\n        \\n        // option 2 -- we try to win this section if we have sufficient arrows\\n        if (n>a[i]){\\n            now[i]=a[i]+1;\\n            solve(i+1,n-(a[i]+1),a,now,ans,snow+i,smax);\\n        }\\n    }\\n    \\n    vector<int> maximumBobPoints(int n, vector<int>& aliceArrows) {\\n        int snow=0,smax=0;\\n        // snow is score now\\n        // smax is max score till now\\n        vector<int> now(12); // temp array to store values\\n        vector<int> ans(12); // final ans array\\n        solve(0,n,aliceArrows,now,ans,0,smax);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nvoid solve(int i, int n,vector<int>& a, vector<int>& now, vector<int> &ans, int snow, int &smax ){ \\n        if (i>=11)\\n        {\\n            // put all left over arrows in last section\\n            now[11]=n;\\n            if (n<=a[i]){\\n                if (snow>smax)\\n                {\\n                    ans=now;\\n                    smax=snow;\\n                }\\n            \\n            }else{ \\n                if (snow+11>smax)\\n                {\\n                    ans=now;\\n                    smax=snow+11;\\n                }\\n                \\n            }\\n            \\n            return;\\n        }\\n        \\n        // option 1 -- we dont care for this section\\n        now[i]=0;\\n        solve(i+1,n,a,now,ans,snow,smax);\\n        \\n        // option 2 -- we try to win this section if we have sufficient arrows\\n        if (n>a[i]){\\n            now[i]=a[i]+1;\\n            solve(i+1,n-(a[i]+1),a,now,ans,snow+i,smax);\\n        }\\n    }\\n    \\n    vector<int> maximumBobPoints(int n, vector<int>& aliceArrows) {\\n        int snow=0,smax=0;\\n        // snow is score now\\n        // smax is max score till now\\n        vector<int> now(12); // temp array to store values\\n        vector<int> ans(12); // final ans array\\n        solve(0,n,aliceArrows,now,ans,0,smax);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865879,
                "title": "c-bitmasking-noticing-from-size-easy",
                "content": "So, Possible sequence of any pattern is 2^n-1.\\nEx- ABC -> ABC, AC, BC, BA, AB, A,B,C  - 7 \\n\\nSo, here one thing is to is notice small size i.e. 12 of Target array. So, easily we can form all be possible sequence of 2^12 -1== 4096-1. And check for the maximum score that we can get for Bob. \\n\\nSometimes, we get the max but not all numsArrow is used. So, we simply add all left in 0th index of our answer vector.(That won\\'t change our answer so.)  \\n\\n```\\n#define pi (3.141592653589)\\n#define mod 1000000007\\n#define float double\\n#define pb push_back\\n#define mp make_pair\\n#define ff first\\n#define ss second\\n#define all(c) c.begin(), c.end()\\n#define min3(a, b, c) min(c, min(a, b))\\n#define min4(a, b, c, d) min(d, min(c, min(a, b)))\\n#define rrep(i, n) for(int i=n-1;i>=0;i--)\\n#define rep(i,n) for(int i=0;i<n;i++)\\n\\n\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        long long s= 0;\\n        \\n        long long mx=INT_MIN;\\n        vector<int> ans(12); \\n        \\n        rep(i, (1<<12)+1){\\n            long long ns=0, flag=0, g=numArrows;\\n            \\n            rep(j,12){\\n                \\n                if((i & (1<<j))) {\\n                    long long x= aliceArrows[j]+1;\\n                          g-=x;\\n                          ns+=j;\\n                        if(g<0) { flag=1; break;}\\n\\n                }\\n            }\\n            \\n            if(flag==0 && ns>mx ){\\n                rep(k,12) ans[k]=0;\\n                rep(j,12){\\n                     if((i & (1<<j))){\\n                         ans[j]=  aliceArrows[j]+1;\\n                     }\\n                }\\n                if(g>0) ans[0]+=g;\\n                mx=ns;\\n            }\\n         }\\n        \\n        return ans;\\n        \\n    }\\n\\t",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "So, Possible sequence of any pattern is 2^n-1.\\nEx- ABC -> ABC, AC, BC, BA, AB, A,B,C  - 7 \\n\\nSo, here one thing is to is notice small size i.e. 12 of Target array. So, easily we can form all be possible sequence of 2^12 -1== 4096-1. And check for the maximum score that we can get for Bob. \\n\\nSometimes, we get the max but not all numsArrow is used. So, we simply add all left in 0th index of our answer vector.(That won\\'t change our answer so.)  \\n\\n```\\n#define pi (3.141592653589)\\n#define mod 1000000007\\n#define float double\\n#define pb push_back\\n#define mp make_pair\\n#define ff first\\n#define ss second\\n#define all(c) c.begin(), c.end()\\n#define min3(a, b, c) min(c, min(a, b))\\n#define min4(a, b, c, d) min(d, min(c, min(a, b)))\\n#define rrep(i, n) for(int i=n-1;i>=0;i--)\\n#define rep(i,n) for(int i=0;i<n;i++)\\n\\n\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        long long s= 0;\\n        \\n        long long mx=INT_MIN;\\n        vector<int> ans(12); \\n        \\n        rep(i, (1<<12)+1){\\n            long long ns=0, flag=0, g=numArrows;\\n            \\n            rep(j,12){\\n                \\n                if((i & (1<<j))) {\\n                    long long x= aliceArrows[j]+1;\\n                          g-=x;\\n                          ns+=j;\\n                        if(g<0) { flag=1; break;}\\n\\n                }\\n            }\\n            \\n            if(flag==0 && ns>mx ){\\n                rep(k,12) ans[k]=0;\\n                rep(j,12){\\n                     if((i & (1<<j))){\\n                         ans[j]=  aliceArrows[j]+1;\\n                     }\\n                }\\n                if(g>0) ans[0]+=g;\\n                mx=ns;\\n            }\\n         }\\n        \\n        return ans;\\n        \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1865850,
                "title": "c-dp-recursive-memorization-path-print",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int n = 12;\\n    vector<vector<int>> dp;\\n    int solve(int pos, int arrows, vector<int>& aliceArrows){\\n        if(pos >= n){\\n            return 0;\\n        }\\n        if(arrows == 0){\\n            return 0;\\n        }\\n        int &ret = dp[pos][arrows];\\n        if(ret != -1){\\n            return ret;\\n        }\\n        int taken = 0, notTaken = 0;\\n        if(aliceArrows[pos] < arrows){\\n            taken = pos + solve(pos + 1, arrows - aliceArrows[pos] - 1, aliceArrows);\\n        }\\n        notTaken = solve(pos + 1, arrows, aliceArrows);\\n        return ret = max(taken, notTaken);\\n    }\\n    void path(int pos, int arrows, vector<int>& aliceArrows, vector<int>& result){\\n        if(pos >= n || arrows == 0){\\n            return;\\n        }\\n        int taken = 0, notTaken = 0;\\n        if(aliceArrows[pos] < arrows){\\n            taken = pos + solve(pos + 1, arrows - aliceArrows[pos] - 1, aliceArrows);\\n        }\\n        notTaken = solve(pos + 1, arrows, aliceArrows);\\n        if(taken > notTaken){\\n            result[pos] = aliceArrows[pos] + 1;\\n            path(pos + 1, arrows - aliceArrows[pos] - 1, aliceArrows, result);\\n        }\\n        else{\\n            path(pos + 1, arrows, aliceArrows, result);\\n        }\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        dp.resize(n + 1, vector<int>(numArrows + 1, -1));\\n        int ans = solve(0, numArrows, aliceArrows);\\n        vector<int> result(n, 0);\\n        path(0, numArrows, aliceArrows, result);\\n        int res = accumulate(result.begin(), result.end(), 0);\\n        result[0] += numArrows - res;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int n = 12;\\n    vector<vector<int>> dp;\\n    int solve(int pos, int arrows, vector<int>& aliceArrows){\\n        if(pos >= n){\\n            return 0;\\n        }\\n        if(arrows == 0){\\n            return 0;\\n        }\\n        int &ret = dp[pos][arrows];\\n        if(ret != -1){\\n            return ret;\\n        }\\n        int taken = 0, notTaken = 0;\\n        if(aliceArrows[pos] < arrows){\\n            taken = pos + solve(pos + 1, arrows - aliceArrows[pos] - 1, aliceArrows);\\n        }\\n        notTaken = solve(pos + 1, arrows, aliceArrows);\\n        return ret = max(taken, notTaken);\\n    }\\n    void path(int pos, int arrows, vector<int>& aliceArrows, vector<int>& result){\\n        if(pos >= n || arrows == 0){\\n            return;\\n        }\\n        int taken = 0, notTaken = 0;\\n        if(aliceArrows[pos] < arrows){\\n            taken = pos + solve(pos + 1, arrows - aliceArrows[pos] - 1, aliceArrows);\\n        }\\n        notTaken = solve(pos + 1, arrows, aliceArrows);\\n        if(taken > notTaken){\\n            result[pos] = aliceArrows[pos] + 1;\\n            path(pos + 1, arrows - aliceArrows[pos] - 1, aliceArrows, result);\\n        }\\n        else{\\n            path(pos + 1, arrows, aliceArrows, result);\\n        }\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        dp.resize(n + 1, vector<int>(numArrows + 1, -1));\\n        int ans = solve(0, numArrows, aliceArrows);\\n        vector<int> result(n, 0);\\n        path(0, numArrows, aliceArrows, result);\\n        int res = accumulate(result.begin(), result.end(), 0);\\n        result[0] += numArrows - res;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865726,
                "title": "python-dp-solution-got-tle-with-top-down-but-not-with-memoization",
                "content": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        dp = [[-1]*(numArrows+1) for i in range(12)]\\n        for i in range(12):\\n            dp[i][0] = 0\\n        for i in range(numArrows+1):\\n            dp[0][i] = 0\\n        def rec(i,n):\\n            if dp[i][n] != -1:\\n                return dp[i][n]\\n            if aliceArrows[i]+1 <= n:\\n                dp[i][n] = max(rec(i-1,n),rec(i-1,n-aliceArrows[i]-1)+i)\\n            else:\\n                dp[i][n] = rec(i-1,n)\\n            return dp[i][n]\\n        rec(11,numArrows)\\n        i,j = 11, numArrows\\n        ans = []\\n        while i > 0:\\n            if dp[i][j] == dp[i-1][j]:\\n                ans.append(0)\\n            else:\\n                ans.append(aliceArrows[i]+1)\\n                j -= aliceArrows[i]+1\\n            i-=1\\n        ans.append(0)\\n        ans = ans[::-1]\\n        x = numArrows-sum(ans)\\n        if x > 0:\\n            ans[0] += x\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        dp = [[-1]*(numArrows+1) for i in range(12)]\\n        for i in range(12):\\n            dp[i][0] = 0\\n        for i in range(numArrows+1):\\n            dp[0][i] = 0\\n        def rec(i,n):\\n            if dp[i][n] != -1:\\n                return dp[i][n]\\n            if aliceArrows[i]+1 <= n:\\n                dp[i][n] = max(rec(i-1,n),rec(i-1,n-aliceArrows[i]-1)+i)\\n            else:\\n                dp[i][n] = rec(i-1,n)\\n            return dp[i][n]\\n        rec(11,numArrows)\\n        i,j = 11, numArrows\\n        ans = []\\n        while i > 0:\\n            if dp[i][j] == dp[i-1][j]:\\n                ans.append(0)\\n            else:\\n                ans.append(aliceArrows[i]+1)\\n                j -= aliceArrows[i]+1\\n            i-=1\\n        ans.append(0)\\n        ans = ans[::-1]\\n        x = numArrows-sum(ans)\\n        if x > 0:\\n            ans[0] += x\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865702,
                "title": "python3-backtrack-beats-100",
                "content": "Main idea here is that you simulate scenarios where either Bob beats Alice or Bob loses to Alice.\\nSince there are only 12 rounds total, that\\'s 2^12 calls, or 4096 which is a rather trivially number.\\nThe 10^5 upper bound on numArrows is not crucial to the runtime since we can easily calculate number of arrows Bob needs to beat Alice in O(1) (just one more than Alice)\\n\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        # either beat alice here, or dont\\n        rounds = len(aliceArrows)\\n        \\n        def backtrack(index, remaining, cur_max, cur_game):\\n            if index < 0 or remaining == 0:\\n                nonlocal max_points, bob_arrows\\n                if cur_max > max_points:\\n                    max_points = cur_max\\n                    bob_arrows = cur_game[:]\\n                    if remaining > 0:\\n                        bob_arrows[0] += remaining\\n                return\\n        \\n            # beat alice\\n            if remaining > aliceArrows[index]:\\n                cur_game[index] = aliceArrows[index] + 1\\n                backtrack(index - 1, remaining - aliceArrows[index] - 1, cur_max + index, cur_game)\\n            \\n            # don\\'t beat alice\\n            cur_game[index] = 0\\n            backtrack(index - 1, remaining, cur_max, cur_game)\\n                    \\n        bob_arrows = [0] * rounds\\n        max_points = 0\\n        backtrack(rounds - 1, numArrows, 0, [0] * rounds)\\n        return bob_arrows",
                "solutionTags": [],
                "code": "Main idea here is that you simulate scenarios where either Bob beats Alice or Bob loses to Alice.\\nSince there are only 12 rounds total, that\\'s 2^12 calls, or 4096 which is a rather trivially number.\\nThe 10^5 upper bound on numArrows is not crucial to the runtime since we can easily calculate number of arrows Bob needs to beat Alice in O(1) (just one more than Alice)\\n\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        # either beat alice here, or dont\\n        rounds = len(aliceArrows)\\n        \\n        def backtrack(index, remaining, cur_max, cur_game):\\n            if index < 0 or remaining == 0:\\n                nonlocal max_points, bob_arrows\\n                if cur_max > max_points:\\n                    max_points = cur_max\\n                    bob_arrows = cur_game[:]\\n                    if remaining > 0:\\n                        bob_arrows[0] += remaining\\n                return\\n        \\n            # beat alice\\n            if remaining > aliceArrows[index]:\\n                cur_game[index] = aliceArrows[index] + 1\\n                backtrack(index - 1, remaining - aliceArrows[index] - 1, cur_max + index, cur_game)\\n            \\n            # don\\'t beat alice\\n            cur_game[index] = 0\\n            backtrack(index - 1, remaining, cur_max, cur_game)\\n                    \\n        bob_arrows = [0] * rounds\\n        max_points = 0\\n        backtrack(rounds - 1, numArrows, 0, [0] * rounds)\\n        return bob_arrows",
                "codeTag": "Java"
            },
            {
                "id": 1865615,
                "title": "python-dp-dfs-with-path-array",
                "content": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        \\n        def dp(numArrows, idx, path):\\n            if numArrows < 0:\\n                return float(\"-inf\"), path\\n            if idx < 0:\\n                return 0, path\\n            \\n            res1, path1 = dp(numArrows, idx-1, path)\\n            res2, path2 = dp(numArrows - (aliceArrows[idx]+1), idx-1, path + [idx])\\n            res2 += idx\\n            if res1 > res2:\\n                res = res1\\n                path = path1\\n            else:\\n                res = res2\\n                path = path2\\n            return res, path\\n        \\n        res, path = dp(numArrows, len(aliceArrows) - 1, [])\\n        bobArr = [0] * 12\\n        for idx in path:\\n            bobArr[idx] = aliceArrows[idx] + 1\\n        if sum(bobArr) < sum(aliceArrows):\\n            bobArr[0] += sum(aliceArrows) - sum(bobArr)\\n        return bobArr",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        \\n        def dp(numArrows, idx, path):\\n            if numArrows < 0:\\n                return float(\"-inf\"), path\\n            if idx < 0:\\n                return 0, path\\n            \\n            res1, path1 = dp(numArrows, idx-1, path)\\n            res2, path2 = dp(numArrows - (aliceArrows[idx]+1), idx-1, path + [idx])\\n            res2 += idx\\n            if res1 > res2:\\n                res = res1\\n                path = path1\\n            else:\\n                res = res2\\n                path = path2\\n            return res, path\\n        \\n        res, path = dp(numArrows, len(aliceArrows) - 1, [])\\n        bobArr = [0] * 12\\n        for idx in path:\\n            bobArr[idx] = aliceArrows[idx] + 1\\n        if sum(bobArr) < sum(aliceArrows):\\n            bobArr[0] += sum(aliceArrows) - sum(bobArr)\\n        return bobArr",
                "codeTag": "Java"
            },
            {
                "id": 3465705,
                "title": "simple-recursion-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int mx;\\n    vector<int> ans;\\n    void f(int x, int arrows, vector<int>& aliceArrows, int sum, vector<int> &bobArrows)\\n    {\\n        if(x<0) \\n        {\\n            bobArrows[0]+=arrows;\\n            if(mx<sum)\\n            {\\n                mx=sum;\\n                ans=bobArrows;\\n            }\\n            bobArrows[0]-=arrows;\\n            return;\\n        }\\n        if(arrows>=aliceArrows[x]+1) \\n        {\\n            bobArrows[x]=aliceArrows[x]+1;\\n            f(x-1,arrows-aliceArrows[x]-1,aliceArrows,sum+x,bobArrows);\\n            bobArrows[x]=0;\\n        }\\n        f(x-1,arrows,aliceArrows,sum,bobArrows);\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) \\n    {\\n        mx=0;\\n        vector<int> bobArrows(12,0);\\n        f(11,numArrows,aliceArrows,0,bobArrows);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int mx;\\n    vector<int> ans;\\n    void f(int x, int arrows, vector<int>& aliceArrows, int sum, vector<int> &bobArrows)\\n    {\\n        if(x<0) \\n        {\\n            bobArrows[0]+=arrows;\\n            if(mx<sum)\\n            {\\n                mx=sum;\\n                ans=bobArrows;\\n            }\\n            bobArrows[0]-=arrows;\\n            return;\\n        }\\n        if(arrows>=aliceArrows[x]+1) \\n        {\\n            bobArrows[x]=aliceArrows[x]+1;\\n            f(x-1,arrows-aliceArrows[x]-1,aliceArrows,sum+x,bobArrows);\\n            bobArrows[x]=0;\\n        }\\n        f(x-1,arrows,aliceArrows,sum,bobArrows);\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) \\n    {\\n        mx=0;\\n        vector<int> bobArrows(12,0);\\n        f(11,numArrows,aliceArrows,0,bobArrows);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030166,
                "title": "c-best-explanation-o-n-dp-aditya-verma-knapsack-variation",
                "content": "\\n\\n# Code\\n```\\n       /*\\n       This problem is just like knapsack problem:\\nnumArrows is like the capacity of the sack.\\neach ith section is like an item whose cost is AliceArrows[i]+1 and value is the number of points associated with the section.\\nthe cost of ith section is AliceArrows[i]+1, because to obtain the points (or \\'value\\') of that section, Bob needs to land atleast one more arrow than Alice in that section.\\n       */\\n\\n       /*\\ndp[i][j]  -> max net value for first i items and j weight\\n\\nif ( j>PriceCurSection)\\n\\tdp[i][j]  = max(dp[i-1][j], dp[i-1][j-PriceCurSection] + pointsCurSection)\\n\\n*/\\n \\nclass Solution {\\npublic:\\n    const int NUM_SECTIONS = 12;\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector <int> arrowsRequiredForSection;\\n        for (int numSectionArrowsAlice: aliceArrows) {\\n            arrowsRequiredForSection.push_back(numSectionArrowsAlice+1);\\n        }\\n        \\n        vector <int> sectionPoints;\\n        for (int i=0; i<NUM_SECTIONS; i++) {\\n            sectionPoints.push_back(i);\\n        }\\n        vector<int> optimalShots =  knapsack(numArrows, arrowsRequiredForSection, sectionPoints);\\n        int arrowsUsed = accumulate(optimalShots.begin(), optimalShots.end(), 0);\\n        if (numArrows > arrowsUsed) {\\n            optimalShots[0] += numArrows - arrowsUsed;\\n        }\\n        \\n        return optimalShots;\\n        \\n    }\\n    \\n    vector <int> knapsack(const int capacity, const vector<int>& costs, const vector<int>& itemValues) {\\n                \\n        int numItems = costs.size();\\n        // vector <vector<int>> dp(numItems+1,vector<int>(capacity+1));\\n        // vector <vector<bool>> isCurItemPicked(numItems+1,vector<bool>(capacity+1));\\n        int dp[numItems+1][capacity+1];\\n        bool isCurItemPicked[numItems+1][capacity+1];\\n        memset(dp,0,sizeof(dp));\\n        memset(isCurItemPicked,0,sizeof(isCurItemPicked));\\n        for (int i=1; i<=numItems; i++) {\\n            for (int j=1; j<=capacity; j++) {\\n                dp[i][j] = dp[i-1][j];\\n                if (j >= costs[i-1]) {\\n                    int valueIfCurItemIsPicked = dp[i-1][j-costs[i-1]] + itemValues[i-1];\\n                    if (valueIfCurItemIsPicked > dp[i][j]) {\\n                        dp[i][j] = valueIfCurItemIsPicked;\\n                        isCurItemPicked[i][j] = true;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        vector <int> spent;\\n        int weight = capacity;\\n        for (int i=numItems; i>0; i--) {            \\n            if (isCurItemPicked[i][weight]) {\\n                weight -= costs[i-1];\\n                spent.push_back(costs[i-1]);\\n            } else {\\n                spent.push_back(0);\\n            }\\n        }\\n        reverse(spent.begin(), spent.end());\\n        return spent;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n       /*\\n       This problem is just like knapsack problem:\\nnumArrows is like the capacity of the sack.\\neach ith section is like an item whose cost is AliceArrows[i]+1 and value is the number of points associated with the section.\\nthe cost of ith section is AliceArrows[i]+1, because to obtain the points (or \\'value\\') of that section, Bob needs to land atleast one more arrow than Alice in that section.\\n       */\\n\\n       /*\\ndp[i][j]  -> max net value for first i items and j weight\\n\\nif ( j>PriceCurSection)\\n\\tdp[i][j]  = max(dp[i-1][j], dp[i-1][j-PriceCurSection] + pointsCurSection)\\n\\n*/\\n \\nclass Solution {\\npublic:\\n    const int NUM_SECTIONS = 12;\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector <int> arrowsRequiredForSection;\\n        for (int numSectionArrowsAlice: aliceArrows) {\\n            arrowsRequiredForSection.push_back(numSectionArrowsAlice+1);\\n        }\\n        \\n        vector <int> sectionPoints;\\n        for (int i=0; i<NUM_SECTIONS; i++) {\\n            sectionPoints.push_back(i);\\n        }\\n        vector<int> optimalShots =  knapsack(numArrows, arrowsRequiredForSection, sectionPoints);\\n        int arrowsUsed = accumulate(optimalShots.begin(), optimalShots.end(), 0);\\n        if (numArrows > arrowsUsed) {\\n            optimalShots[0] += numArrows - arrowsUsed;\\n        }\\n        \\n        return optimalShots;\\n        \\n    }\\n    \\n    vector <int> knapsack(const int capacity, const vector<int>& costs, const vector<int>& itemValues) {\\n                \\n        int numItems = costs.size();\\n        // vector <vector<int>> dp(numItems+1,vector<int>(capacity+1));\\n        // vector <vector<bool>> isCurItemPicked(numItems+1,vector<bool>(capacity+1));\\n        int dp[numItems+1][capacity+1];\\n        bool isCurItemPicked[numItems+1][capacity+1];\\n        memset(dp,0,sizeof(dp));\\n        memset(isCurItemPicked,0,sizeof(isCurItemPicked));\\n        for (int i=1; i<=numItems; i++) {\\n            for (int j=1; j<=capacity; j++) {\\n                dp[i][j] = dp[i-1][j];\\n                if (j >= costs[i-1]) {\\n                    int valueIfCurItemIsPicked = dp[i-1][j-costs[i-1]] + itemValues[i-1];\\n                    if (valueIfCurItemIsPicked > dp[i][j]) {\\n                        dp[i][j] = valueIfCurItemIsPicked;\\n                        isCurItemPicked[i][j] = true;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        vector <int> spent;\\n        int weight = capacity;\\n        for (int i=numItems; i>0; i--) {            \\n            if (isCurItemPicked[i][weight]) {\\n                weight -= costs[i-1];\\n                spent.push_back(costs[i-1]);\\n            } else {\\n                spent.push_back(0);\\n            }\\n        }\\n        reverse(spent.begin(), spent.end());\\n        return spent;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029107,
                "title": "c-bit-manipulation-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(2^12 * 12)\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>v;\\n        int maxi=0;\\n        for(int i=0; i<(1<<12); i++){\\n            int n=numArrows, cnt=0;\\n            vector<int>temp(12, 0);\\n            for(int j=11; j>=0; j--){\\n                if(i&(1<<j)){\\n                    if(n>aliceArrows[j]){\\n                        n-=(aliceArrows[j]+1);\\n                        temp[j]=(aliceArrows[j]+1);\\n                    }\\n                }\\n            }\\n            for(int j=0; j<12; j++){\\n                if(i&(1<<j)){\\n                    temp[j]+=n;\\n                    break;\\n                }\\n            }\\n            for(int j=0; j<12; j++){\\n                if(temp[j]>aliceArrows[j]){cnt+=j;}\\n            }\\n            if(cnt>maxi){\\n                maxi=cnt;\\n                v=temp;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>v;\\n        int maxi=0;\\n        for(int i=0; i<(1<<12); i++){\\n            int n=numArrows, cnt=0;\\n            vector<int>temp(12, 0);\\n            for(int j=11; j>=0; j--){\\n                if(i&(1<<j)){\\n                    if(n>aliceArrows[j]){\\n                        n-=(aliceArrows[j]+1);\\n                        temp[j]=(aliceArrows[j]+1);\\n                    }\\n                }\\n            }\\n            for(int j=0; j<12; j++){\\n                if(i&(1<<j)){\\n                    temp[j]+=n;\\n                    break;\\n                }\\n            }\\n            for(int j=0; j<12; j++){\\n                if(temp[j]>aliceArrows[j]){cnt+=j;}\\n            }\\n            if(cnt>maxi){\\n                maxi=cnt;\\n                v=temp;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025681,
                "title": "intuition-included-explained-c",
                "content": "# Intuition\\nHere we have option to choose or not choose so it must be recurrsion or dp \\njust wrote the simple recursion then notice since ther is only one variable so no over lapping so no dp only recurrsion \\n\\n# Approach\\n- we have option two choose the number or not \\n- if we choose the number then number of arrow we needed to `score =aliceArrows[i]+1` \\n- if we are at `i==12 or arrows ==0` base case\\n- just calculate the total score at this very moment and if this is **greater than previous score** then update the score and update the `fianlAnswer array`\\n\\n# Complexity\\n- Time complexity:\\n- $$O(2^12)$$\\n\\n- Space complexity:\\n$$O(12)$$ \\n\\n# Code\\n```\\n// https://leetcode.com/problems/maximum-points-in-an-archery-competition/description/\\n// simple Choose not Choose.\\nclass Solution {\\npublic:\\n    vector<int>ans;//will save the final answer.\\n    int scoreCount=0;\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) \\n    {\\n        vector<int>temp(12,0);\\n        f(numArrows,temp,0,aliceArrows);\\n        return ans;\\n    }\\n    void f(int arrows,vector<int>&v,int i,vector<int>& ref)\\n    {\\n        if (arrows==0 || i==12)\\n        {\\n            if (i==12 && arrows!=0)\\n            {\\n                //edge case when excess of arrows are give.\\n                v[11]+=arrows;\\n            }\\n            int temp=cal(v,ref);\\n            if (temp>scoreCount)\\n            {\\n                scoreCount=temp;\\n                ans=v;\\n            }\\n            return ;\\n        }\\n        //not choose the number \\n        f(arrows,v,i+1,ref);\\n        \\n        v[i]=0; // incase we have handled edge case then just undo that step\\n\\n        //choose the number if we have enough arrows\\n        if (ref[i]<arrows)\\n        {\\n            v[i]=ref[i]+1;\\n            f(arrows-ref[i]-1,v,i+1,ref);\\n            v[i]=0;\\n        }\\n    }\\n    int cal(vector<int>&v,vector<int>&ref)\\n    {\\n        int temp=0;\\n        for(int i=0;i<12;i++)\\n        {\\n            if (v[i]>ref[i])\\n            {\\n                temp+=i;\\n            }\\n        }\\n        return temp;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n// https://leetcode.com/problems/maximum-points-in-an-archery-competition/description/\\n// simple Choose not Choose.\\nclass Solution {\\npublic:\\n    vector<int>ans;//will save the final answer.\\n    int scoreCount=0;\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) \\n    {\\n        vector<int>temp(12,0);\\n        f(numArrows,temp,0,aliceArrows);\\n        return ans;\\n    }\\n    void f(int arrows,vector<int>&v,int i,vector<int>& ref)\\n    {\\n        if (arrows==0 || i==12)\\n        {\\n            if (i==12 && arrows!=0)\\n            {\\n                //edge case when excess of arrows are give.\\n                v[11]+=arrows;\\n            }\\n            int temp=cal(v,ref);\\n            if (temp>scoreCount)\\n            {\\n                scoreCount=temp;\\n                ans=v;\\n            }\\n            return ;\\n        }\\n        //not choose the number \\n        f(arrows,v,i+1,ref);\\n        \\n        v[i]=0; // incase we have handled edge case then just undo that step\\n\\n        //choose the number if we have enough arrows\\n        if (ref[i]<arrows)\\n        {\\n            v[i]=ref[i]+1;\\n            f(arrows-ref[i]-1,v,i+1,ref);\\n            v[i]=0;\\n        }\\n    }\\n    int cal(vector<int>&v,vector<int>&ref)\\n    {\\n        int temp=0;\\n        for(int i=0;i<12;i++)\\n        {\\n            if (v[i]>ref[i])\\n            {\\n                temp+=i;\\n            }\\n        }\\n        return temp;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013209,
                "title": "c-solution-recursive-solution-faster-and-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate : \\n    vector<int> ans;\\n    bool checkProfit(vector<int>&bob,vector<int>& alice){\\n        int prevProfit = 0;\\n        for(int i=0;i<ans.size();i++){\\n            if(ans[i] > alice[i]) prevProfit += i;\\n        }\\n\\n        int newProfit = 0;\\n        for(int i=0;i<bob.size();i++){\\n            if(bob[i] > alice[i]) newProfit += i;\\n        }\\n\\n        return newProfit > prevProfit;\\n    }\\n\\n    void helper(int i,int numArrows,vector<int>& alice,vector<int>&bob){\\n        if(i==0){\\n            bob[i] = numArrows;\\n            if(checkProfit(bob,alice)) ans = bob;\\n            bob[i] = 0;\\n            return;\\n        }\\n        if(numArrows - alice[i] - 1 >= 0){\\n            bob[i] = alice[i] + 1;\\n            helper(i-1,numArrows - alice[i] - 1,alice,bob);\\n            bob[i] = 0;\\n        }\\n\\n        helper(i-1,numArrows,alice,bob);\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>bob(12,0);\\n        helper(11,numArrows,aliceArrows,bob);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate : \\n    vector<int> ans;\\n    bool checkProfit(vector<int>&bob,vector<int>& alice){\\n        int prevProfit = 0;\\n        for(int i=0;i<ans.size();i++){\\n            if(ans[i] > alice[i]) prevProfit += i;\\n        }\\n\\n        int newProfit = 0;\\n        for(int i=0;i<bob.size();i++){\\n            if(bob[i] > alice[i]) newProfit += i;\\n        }\\n\\n        return newProfit > prevProfit;\\n    }\\n\\n    void helper(int i,int numArrows,vector<int>& alice,vector<int>&bob){\\n        if(i==0){\\n            bob[i] = numArrows;\\n            if(checkProfit(bob,alice)) ans = bob;\\n            bob[i] = 0;\\n            return;\\n        }\\n        if(numArrows - alice[i] - 1 >= 0){\\n            bob[i] = alice[i] + 1;\\n            helper(i-1,numArrows - alice[i] - 1,alice,bob);\\n            bob[i] = 0;\\n        }\\n\\n        helper(i-1,numArrows,alice,bob);\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>bob(12,0);\\n        helper(11,numArrows,aliceArrows,bob);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225850,
                "title": "java-time-o-n2-n-space-o-n-backtracking",
                "content": "```\\n\\n// naively, you want to try every possibility. And all the choices for\\n// bob at section i are :\\n\\n// 1. bob gets 0 at section i,\\n// 2. bob gets AliceArrows[i] + 1,\\n\\n//you want to use a recursive function for trying all of the choices,\\n//meanwhile, you want to keep a global variable, maxScore, which\\n//indicates, the maxScore for bob after a series of choices, you want\\n//to use another global variable result = new int[12] to record this series\\n//of choices corresponds to the maxScore.\\n\\n//after exploring all choice patterns, you will return result.\\n\\n//Now, you\\'ve figured out that a recursive function should be used, which\\n//magically just returns a choice pattern for Bob, but what about the details?\\n\\n//(1), arguments\\n//1.we know the total Arrows for bob, at each iteration, bob will decide to put\\n// some number of arrows at section i, for the subsequent choices, you need\\n//to know how many arrows left for bob, hence we keep an argument \"leftArrow\"\\n\\n//2. index that indicating which section we are considering \"index\"\\n\\n//3. int[] bobArrows, the current state for bob, which stores all choices made so\\n// far for bob\\n\\n//4. \"score\", which corresponds to the score for bobArrows.\\n\\n//(2). base case\\n//If you have worked with recursion functions, you know its essential to come up \\n//with workable base case for a recursion function.\\n\\n//in our case, we traverse from index = 11 to index = 0 to index < 0\\n//so we have those following base case\\n\\n//1. arrowLeft < 0, we\\'ve assigned all arrows for bob, and have negative left, this\\n// isn\\'t a feasible situation, we don\\'t want to continue and immediately stop exploring\\n\\n//2. arrowLeft==0, in this case, we\\'ve obtained a feasible scenario for bob, and we want to\\n//see if it\\'s a good one, by comparing it with the global variable \"maxScore\"\\n\\n//3. index<0, in this case, we may still have arrow left, but we don\\'t have any slots left as\\n//index is smaller than 0, in this case, we simply put all arrow left at index 0 :), why?\\n//because putting arrows at index 0 doesn\\'t bring any changes to the score.\\n\\n\\n//(3) recursive calls\\n// at each index, we have two choices, we just simply consider those two choices, pls\\n//note that if we want to make any changes to bobArrows, we need to erase this choice\\n//for future exploration. (backtracking...)\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    int maxScore = 0;\\n    int[] result;\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int[] bobArrows = new int[12];\\n        dfs(numArrows, 11, aliceArrows,bobArrows,0);\\n        return result;\\n    }\\n    \\n    \\n    private void dfs(int arrowLeft, int index, int[] aliceArrows, int[] bobArrows, int score){\\n        if(arrowLeft<0) return;\\n        \\n        if(arrowLeft==0){\\n            if(score>maxScore){\\n                maxScore = score;\\n                result = bobArrows.clone();\\n            }\\n            return;\\n        }\\n        \\n        if(index<0){\\n            if(score>maxScore){\\n                maxScore = score;\\n                bobArrows[0] = arrowLeft;\\n                result = bobArrows.clone();\\n                bobArrows[0] = 0;\\n            }\\n            return;\\n        }\\n\\n        dfs(arrowLeft, index-1, aliceArrows, bobArrows, score);\\n        \\n        bobArrows[index] = aliceArrows[index]+1;\\n        dfs(arrowLeft - bobArrows[index], index-1, aliceArrows, bobArrows, score+index);\\n        bobArrows[index] = 0;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\n\\n// naively, you want to try every possibility. And all the choices for\\n// bob at section i are :\\n\\n// 1. bob gets 0 at section i,\\n// 2. bob gets AliceArrows[i] + 1,\\n\\n//you want to use a recursive function for trying all of the choices,\\n//meanwhile, you want to keep a global variable, maxScore, which\\n//indicates, the maxScore for bob after a series of choices, you want\\n//to use another global variable result = new int[12] to record this series\\n//of choices corresponds to the maxScore.\\n\\n//after exploring all choice patterns, you will return result.\\n\\n//Now, you\\'ve figured out that a recursive function should be used, which\\n//magically just returns a choice pattern for Bob, but what about the details?\\n\\n//(1), arguments\\n//1.we know the total Arrows for bob, at each iteration, bob will decide to put\\n// some number of arrows at section i, for the subsequent choices, you need\\n//to know how many arrows left for bob, hence we keep an argument \"leftArrow\"\\n\\n//2. index that indicating which section we are considering \"index\"\\n\\n//3. int[] bobArrows, the current state for bob, which stores all choices made so\\n// far for bob\\n\\n//4. \"score\", which corresponds to the score for bobArrows.\\n\\n//(2). base case\\n//If you have worked with recursion functions, you know its essential to come up \\n//with workable base case for a recursion function.\\n\\n//in our case, we traverse from index = 11 to index = 0 to index < 0\\n//so we have those following base case\\n\\n//1. arrowLeft < 0, we\\'ve assigned all arrows for bob, and have negative left, this\\n// isn\\'t a feasible situation, we don\\'t want to continue and immediately stop exploring\\n\\n//2. arrowLeft==0, in this case, we\\'ve obtained a feasible scenario for bob, and we want to\\n//see if it\\'s a good one, by comparing it with the global variable \"maxScore\"\\n\\n//3. index<0, in this case, we may still have arrow left, but we don\\'t have any slots left as\\n//index is smaller than 0, in this case, we simply put all arrow left at index 0 :), why?\\n//because putting arrows at index 0 doesn\\'t bring any changes to the score.\\n\\n\\n//(3) recursive calls\\n// at each index, we have two choices, we just simply consider those two choices, pls\\n//note that if we want to make any changes to bobArrows, we need to erase this choice\\n//for future exploration. (backtracking...)\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    int maxScore = 0;\\n    int[] result;\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int[] bobArrows = new int[12];\\n        dfs(numArrows, 11, aliceArrows,bobArrows,0);\\n        return result;\\n    }\\n    \\n    \\n    private void dfs(int arrowLeft, int index, int[] aliceArrows, int[] bobArrows, int score){\\n        if(arrowLeft<0) return;\\n        \\n        if(arrowLeft==0){\\n            if(score>maxScore){\\n                maxScore = score;\\n                result = bobArrows.clone();\\n            }\\n            return;\\n        }\\n        \\n        if(index<0){\\n            if(score>maxScore){\\n                maxScore = score;\\n                bobArrows[0] = arrowLeft;\\n                result = bobArrows.clone();\\n                bobArrows[0] = 0;\\n            }\\n            return;\\n        }\\n\\n        dfs(arrowLeft, index-1, aliceArrows, bobArrows, score);\\n        \\n        bobArrows[index] = aliceArrows[index]+1;\\n        dfs(arrowLeft - bobArrows[index], index-1, aliceArrows, bobArrows, score+index);\\n        bobArrows[index] = 0;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186959,
                "title": "java-solution-straight-forward-backtracking",
                "content": "\\n``` java\\nclass Solution {\\n    int[] res = new int[12];\\n    int max = 0;\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        compute(numArrows, aliceArrows, new int[12], 11, 0);\\n        return res;\\n    }\\n\\n    private void compute(int numArrows, int[] aliceArrows, int[] bobArrows, int idx, int point) {\\n        if (idx == 0) {\\n            if (point > max) {\\n                max = point;\\n                bobArrows[idx] = numArrows;\\n                res = bobArrows.clone();\\n            }\\n            return;\\n        }\\n        compute(numArrows, aliceArrows, bobArrows, idx - 1, point);\\n        if (numArrows > aliceArrows[idx]) {\\n            bobArrows[idx] = aliceArrows[idx] + 1;\\n            compute(numArrows - bobArrows[idx], aliceArrows, bobArrows, idx - 1, point + idx);\\n            bobArrows[idx] = 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\nclass Solution {\\n    int[] res = new int[12];\\n    int max = 0;\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        compute(numArrows, aliceArrows, new int[12], 11, 0);\\n        return res;\\n    }\\n\\n    private void compute(int numArrows, int[] aliceArrows, int[] bobArrows, int idx, int point) {\\n        if (idx == 0) {\\n            if (point > max) {\\n                max = point;\\n                bobArrows[idx] = numArrows;\\n                res = bobArrows.clone();\\n            }\\n            return;\\n        }\\n        compute(numArrows, aliceArrows, bobArrows, idx - 1, point);\\n        if (numArrows > aliceArrows[idx]) {\\n            bobArrows[idx] = aliceArrows[idx] + 1;\\n            compute(numArrows - bobArrows[idx], aliceArrows, bobArrows, idx - 1, point + idx);\\n            bobArrows[idx] = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165623,
                "title": "java-simple-backtracking-solution-easy-to-read-included-comments",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    int[] ansbob;\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int[] bob = new int[aliceArrows.length];\\n        for(int i=0;i<bob.length;i++)bob[i]=0;\\n        ansbob = new int[bob.length];\\n        func(aliceArrows,bob,numArrows,11,0);\\n        return ansbob;\\n    }\\n    public void func(int[] alice,int[] bob,int remArrows,int index,int bobscore){\\n        //Base case\\n        if(index==-1){\\n            if(remArrows!=0){\\n                for(int i=0;i<bob.length;i++){\\n                    //Place remaining arrows at a nonzero position of bob\\n                    if(bob[i]!=0){\\n                        bob[i]+=remArrows;\\n                        break;\\n                    }\\n                }\\n            }\\n            int temp = Math.max(ans,bobscore);\\n            if(temp!=ans){\\n                ans = temp;\\n                for(int i=0;i<bob.length;i++){\\n                    ansbob[i]=bob[i];\\n                }\\n            }\\n            return;\\n        }\\n        //Recursive case\\n        //For each there is a possiblilty of bob either winning or loosing\\n\\n        //Bob winning case\\n        int score = alice[index];\\n        if(remArrows>score){\\n            //Place  score + 1arrows at that position\\n            bob[index]=score+1;\\n            //check for next index\\n            func(alice,bob,remArrows-1-score,index-1,bobscore+index);\\n            //replace back\\n            bob[index]=0;\\n        }\\n        //Bob loosing case - Place no arrows at that position\\n        func(alice,bob,remArrows,index-1,bobscore);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    int[] ansbob;\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int[] bob = new int[aliceArrows.length];\\n        for(int i=0;i<bob.length;i++)bob[i]=0;\\n        ansbob = new int[bob.length];\\n        func(aliceArrows,bob,numArrows,11,0);\\n        return ansbob;\\n    }\\n    public void func(int[] alice,int[] bob,int remArrows,int index,int bobscore){\\n        //Base case\\n        if(index==-1){\\n            if(remArrows!=0){\\n                for(int i=0;i<bob.length;i++){\\n                    //Place remaining arrows at a nonzero position of bob\\n                    if(bob[i]!=0){\\n                        bob[i]+=remArrows;\\n                        break;\\n                    }\\n                }\\n            }\\n            int temp = Math.max(ans,bobscore);\\n            if(temp!=ans){\\n                ans = temp;\\n                for(int i=0;i<bob.length;i++){\\n                    ansbob[i]=bob[i];\\n                }\\n            }\\n            return;\\n        }\\n        //Recursive case\\n        //For each there is a possiblilty of bob either winning or loosing\\n\\n        //Bob winning case\\n        int score = alice[index];\\n        if(remArrows>score){\\n            //Place  score + 1arrows at that position\\n            bob[index]=score+1;\\n            //check for next index\\n            func(alice,bob,remArrows-1-score,index-1,bobscore+index);\\n            //replace back\\n            bob[index]=0;\\n        }\\n        //Bob loosing case - Place no arrows at that position\\n        func(alice,bob,remArrows,index-1,bobscore);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900788,
                "title": "c-backtracking-template",
                "content": "Do the back tracking from the highest score.\\n[DFS Conditions]\\n* DFS Define:Find the max scroes combination\\n* DFS Exit: Arrows == 0\\n* DFS Rule:\\n\\t* Traverse from the highest score to get as higher total scores with minimun cost\\n\\t* If curArrows < aliceArrows[i] and we are not at the last position(e.g. i == 0), then skip this round\\n\\t* If we want to take current points, the minimun cost is aliceArrows[i] + 1\\n\\t* Once we reach i == 0, we should used rest arrows no matter you can get point 0 or not\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> curArrows(12, 0);\\n        vector<int> maxArrows(12, 0);\\n        int maxScore = INT_MIN;\\n        dfs(numArrows, 11, aliceArrows, curArrows, 0, maxArrows, maxScore);\\n        return maxArrows;\\n    }\\n    \\n    void dfs(int numArrows, int start, vector<int>& aliceArrows, vector<int>& curArrows, int curScore,\\n             vector<int>& maxArrows, int &maxScore) {\\n        if (numArrows == 0) {\\n            if (curScore > maxScore) {\\n                maxScore = curScore;\\n                maxArrows = curArrows;\\n            }\\n            return;\\n        }\\n        \\n        for (int i = start; i >= 0; i--) {\\n            if (numArrows <= aliceArrows[i] && i != 0)\\n                continue;\\n            int restArrows = i == 0 ? 0 : numArrows - aliceArrows[i] - 1;\\n            curArrows[i] = i == 0 ? numArrows : aliceArrows[i] + 1;\\n            dfs(restArrows, i - 1, aliceArrows, curArrows, curScore + i, maxArrows, maxScore);\\n            curArrows[i] = 0;\\n        }\\n    }    \\n};\\n```\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> curArrows(12, 0);\\n        vector<int> maxArrows(12, 0);\\n        int maxScore = INT_MIN;\\n        dfs(numArrows, 11, aliceArrows, curArrows, 0, maxArrows, maxScore);\\n        return maxArrows;\\n    }\\n    \\n    void dfs(int numArrows, int start, vector<int>& aliceArrows, vector<int>& curArrows, int curScore,\\n             vector<int>& maxArrows, int &maxScore) {\\n        if (numArrows == 0) {\\n            if (curScore > maxScore) {\\n                maxScore = curScore;\\n                maxArrows = curArrows;\\n            }\\n            return;\\n        }\\n        \\n        for (int i = start; i >= 0; i--) {\\n            if (numArrows <= aliceArrows[i] && i != 0)\\n                continue;\\n            int restArrows = i == 0 ? 0 : numArrows - aliceArrows[i] - 1;\\n            curArrows[i] = i == 0 ? numArrows : aliceArrows[i] + 1;\\n            dfs(restArrows, i - 1, aliceArrows, curArrows, curScore + i, maxArrows, maxScore);\\n            curArrows[i] = 0;\\n        }\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895392,
                "title": "java-bitmask",
                "content": "Examine all possible combinations of arrows for bob.\\n```\\nclass Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n       // System.out.println((1<<aliceArrows.length-1)-1);\\n        int max = 0 ;\\n        int [] maxState = null;\\n        for(int state = 1;state<=2047 ;state++){\\n            int arrows = 0,score = 0 ;\\n            int [] currMaxState = new int[aliceArrows.length];\\n            for(int i = 0;i<aliceArrows.length;i++){\\n                int aScore = aliceArrows[aliceArrows.length-i-1];\\n                if((state & (1<<i))>0){\\n                    arrows+=(aScore>0?(aScore+1):1);\\n                    score+=aliceArrows.length-i-1;\\n                    currMaxState[aliceArrows.length-i-1] = (aScore>0?(aScore+1):1);\\n                }\\n            }\\n            if(arrows<=numArrows && score>max){\\n                //System.out.println(\"Here\");\\n                max = score;\\n                for(int i = 0;i<currMaxState.length;i++){\\n                    if(currMaxState[i]>0 && arrows<numArrows){\\n                        currMaxState[i]+=(numArrows-arrows);\\n                        break;\\n                    }\\n                }\\n                maxState = currMaxState;\\n            }\\n        }\\n        //System.out.println(max);\\n        return maxState;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n       // System.out.println((1<<aliceArrows.length-1)-1);\\n        int max = 0 ;\\n        int [] maxState = null;\\n        for(int state = 1;state<=2047 ;state++){\\n            int arrows = 0,score = 0 ;\\n            int [] currMaxState = new int[aliceArrows.length];\\n            for(int i = 0;i<aliceArrows.length;i++){\\n                int aScore = aliceArrows[aliceArrows.length-i-1];\\n                if((state & (1<<i))>0){\\n                    arrows+=(aScore>0?(aScore+1):1);\\n                    score+=aliceArrows.length-i-1;\\n                    currMaxState[aliceArrows.length-i-1] = (aScore>0?(aScore+1):1);\\n                }\\n            }\\n            if(arrows<=numArrows && score>max){\\n                //System.out.println(\"Here\");\\n                max = score;\\n                for(int i = 0;i<currMaxState.length;i++){\\n                    if(currMaxState[i]>0 && arrows<numArrows){\\n                        currMaxState[i]+=(numArrows-arrows);\\n                        break;\\n                    }\\n                }\\n                maxState = currMaxState;\\n            }\\n        }\\n        //System.out.println(max);\\n        return maxState;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877698,
                "title": "full-explanation-with-graphics-bitmasking-and-backtracking-c-beats-58",
                "content": "One of the best questions I\\'ve seen on a LeetCode contest and on this platform in general! Huge bravo to whoever came up with this question :)\\n\\n![image](https://assets.leetcode.com/users/images/beea359c-9d54-4c30-b3b4-27c028251a8d_1648075945.7818155.png)\\n\\n\\n\\n<h5>\\nObservations\\n</h5>\\nKeep in mind that the questions specifically asks to \"<b>maximize Bob\\'s score</b>\". Regardless of  who wins, all we are trying to solve is the maximum number of points Bob can get. \\n\\nObservation 1: The number of arrows that Bob have is the sum of the elements in aliceArrows. This is because Bob and Alice will have the same number of arrows. \\n\\nObservation 2: For Bob to gain K points, Bob\\'s score must be <b>strictly greater</b> than Alice\\'s score. Bob must score Alice\\'s score plus 1 to gain the K points if Bob plays optimally. \\n\\nObservation 3: We must iterate through K = 0 to K = 11, and decide whether Bob will spend aliceArrows[i] + 1 arrows to gain the K points. \\n* If Bob decides to \"take\" it, Bob will spend aliceArrows[i] + 1 arrows and gain K points. \\n* If Bob decides to \"leave\" it, Bob will not spend anything, nor will he gain points. \\n\\nObservation 4: Since there are 11 - 0 + 1 = 12 possible values for K, an algorithm that runs in O(2^n) will be fast enough to pass the solution. The small size for K is a hint that we could try an exponential algorithm!\\n\\n<h5>\\nIntuition\\n</h5>\\nThe intuition is to use bitmasking to generate all possible states of whether to take or leave K points for each K. Keep track of the maximum number of points Bob can get and the states in this configuation. Finally, distribute Bob\\'s arrow by looking at the states for the configuration. \\n<br><br>\\n<h5>\\nImplementation\\n</h5>\\n1. Use bitmasking to generate all possible configurations. <br><br>\\n2. For each configuration, determine the minimum total points that Bob will need, which can be calculated by the sum of aliceArrow[i] + 1 for each K points that Bob decides to take. If the number of points Bob needs is less than or equal to the number of arrows he has, then this configuration is possible. <br><br>\\n3. Keep track of the maximum number of points Bob can get, and also the configuration state. <br><br>\\n4. Backtrack to retrieve states configuration. <br><br>\\n5. Filling the answer array by giving aliceArrows[i] + 1 arrows to each K that Bob decides to \"take\". <br><br>\\n6. Add the remaining useless arrows to just any random K so Alice and Bob spends the same number of arrows! <br><br>\\n\\nTime Complexity: O(2^n) because we are generating all possible configurations for a take-or-leave scenario. \\n\\nSpace Complexity: O(n) because we made a cost array. This was unnecessary but was added for better understanding and readabilty of the code. Easily done in O(1) space by removing the cost array. \\n\\n\\n\\n<h5>\\nC++ Solution, time beats 58.07%. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        //bitmasking all possible configurations. \\n        vector<pair<int, int>> cost(12);\\n        int highscore = 0, m = 0;\\n        for(int i = 0; i < aliceArrows.size(); i++) cost[i] = make_pair(aliceArrows[i] + 1, i);\\n        for(int mask = 0; mask < (1 << cost.size()); mask++){\\n            int c = 0, score = 0;\\n            for(int bit = 0; bit < cost.size(); bit++){\\n                    if(mask & (1 << bit)){\\n                        c += cost[bit].first;\\n                        score += cost[bit].second;\\n                    }\\n                }\\n            if(c <= numArrows && score > highscore){\\n                highscore = score;\\n                m = mask;\\n            }\\n        }\\n        \\n        //backtracking to retrieve states configuration. \\n        vector<int> res(12);\\n        string s = \"\";\\n        int cnt = 12;\\n        while(cnt--){\\n            s = s + (char)(m % 2 + \\'0\\');\\n            m /= 2;\\n        }\\n        \\n        //filling up answer array\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'1\\'){\\n                numArrows -= cost[i].first;\\n                res[i] = cost[i].first;\\n            }\\n        }\\n        \\n        //adding remaining useless arrows. \\n        res[res.size() - 1] += numArrows;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        \\n        //bitmasking all possible configurations. \\n        vector<pair<int, int>> cost(12);\\n        int highscore = 0, m = 0;\\n        for(int i = 0; i < aliceArrows.size(); i++) cost[i] = make_pair(aliceArrows[i] + 1, i);\\n        for(int mask = 0; mask < (1 << cost.size()); mask++){\\n            int c = 0, score = 0;\\n            for(int bit = 0; bit < cost.size(); bit++){\\n                    if(mask & (1 << bit)){\\n                        c += cost[bit].first;\\n                        score += cost[bit].second;\\n                    }\\n                }\\n            if(c <= numArrows && score > highscore){\\n                highscore = score;\\n                m = mask;\\n            }\\n        }\\n        \\n        //backtracking to retrieve states configuration. \\n        vector<int> res(12);\\n        string s = \"\";\\n        int cnt = 12;\\n        while(cnt--){\\n            s = s + (char)(m % 2 + \\'0\\');\\n            m /= 2;\\n        }\\n        \\n        //filling up answer array\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'1\\'){\\n                numArrows -= cost[i].first;\\n                res[i] = cost[i].first;\\n            }\\n        }\\n        \\n        //adding remaining useless arrows. \\n        res[res.size() - 1] += numArrows;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876913,
                "title": "c-backtracking",
                "content": "```cpp\\nvector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n\\tvector<int> result(12), curr(12);\\n\\tint maxscore = 0;\\n\\tmaximum_bob_points(aliceArrows, result, curr, maxscore, numArrows);\\n\\treturn result;\\n}\\n\\nvoid maximum_bob_points(const vector<int>& aliceArrows, vector<int>& result, vector<int>& curr,\\n\\t\\t\\t\\t\\t   int& maxscore, int numArrows, int score=0, int k=11) {\\n\\tif(k == 0) {\\n\\t\\tif(score > maxscore) {\\n\\t\\t\\tresult = curr;\\n\\t\\t\\tresult[0] = numArrows;\\n\\t\\t\\tmaxscore = score;\\n\\t\\t}\\n\\t} else {\\n\\t\\tif(numArrows > aliceArrows[k]) {\\n\\t\\t\\tcurr[k] = aliceArrows[k]+1;\\n\\t\\t\\tmaximum_bob_points(aliceArrows, result, curr, maxscore, numArrows-aliceArrows[k] - 1, score + k, k-1);\\n\\t\\t}\\n\\t\\tcurr[k]=0;\\n\\t\\tmaximum_bob_points(aliceArrows, result, curr, maxscore, numArrows, score, k-1);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n\\tvector<int> result(12), curr(12);\\n\\tint maxscore = 0;\\n\\tmaximum_bob_points(aliceArrows, result, curr, maxscore, numArrows);\\n\\treturn result;\\n}\\n\\nvoid maximum_bob_points(const vector<int>& aliceArrows, vector<int>& result, vector<int>& curr,\\n\\t\\t\\t\\t\\t   int& maxscore, int numArrows, int score=0, int k=11) {\\n\\tif(k == 0) {\\n\\t\\tif(score > maxscore) {\\n\\t\\t\\tresult = curr;\\n\\t\\t\\tresult[0] = numArrows;\\n\\t\\t\\tmaxscore = score;\\n\\t\\t}\\n\\t} else {\\n\\t\\tif(numArrows > aliceArrows[k]) {\\n\\t\\t\\tcurr[k] = aliceArrows[k]+1;\\n\\t\\t\\tmaximum_bob_points(aliceArrows, result, curr, maxscore, numArrows-aliceArrows[k] - 1, score + k, k-1);\\n\\t\\t}\\n\\t\\tcurr[k]=0;\\n\\t\\tmaximum_bob_points(aliceArrows, result, curr, maxscore, numArrows, score, k-1);\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1875298,
                "title": "c-faster-than-100-fully-commented-simple-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\nint totalScore=0;\\nbool flag=false;\\nvector<int> bobScores;\\nvector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> currentVector(12,0);\\n        int index=0;\\n        int currentScore=0;\\n\\n        // we start with index=1 cause we don\\'t want to win section \"0\" as it has 0 score.\\n        // so we dont\\' want to waste any arrows in winning \"0\" points\\n\\n        //Standard backtrack Function\\n        backtrack(1,numArrows,aliceArrows,currentScore,currentVector);\\n\\n\\n        //If we have not used all the arrows for bobScore then we can just use them on section with 0 score.\\n        //Because we dont\\' care if alice or bob wins this section it will not effect the overall score.\\n        int sum=0;\\n        for(auto n:bobScores)\\n                sum+=n;\\n        bobScores[0]=numArrows-sum;\\n\\n        //return the formed anwers;\\n        return bobScores;\\n}\\n\\nvoid backtrack(int index,int numArrows,vector<int>&aliceArrows,int currentScore,vector<int>&currentVector){\\n\\n        // we have reached the end\\n        if(index==aliceArrows.size()) {\\n                if(currentScore>totalScore) {\\n                        totalScore=currentScore;\\n                        bobScores=currentVector;\\n                }\\n                return;\\n        }\\n\\n        //there are only two possibilities for each section\\n        //1. Either Bob Wants Wins it or he doesn\\'t want to win it.\\n\\n        //Option 1\\n        // If he wants to Wins it.\\n        //first we have to check if he can win it.\\n        int req=aliceArrows[index]+1;\\n        if(req<=numArrows) {\\n                currentVector[index]+=req;\\n                backtrack(index+1,numArrows-req,aliceArrows,currentScore+index,currentVector);\\n                currentVector[index]-=req;\\n        }\\n\\n\\n        //Option 2\\n        //If he dont\\'t want to win this section than he will not waste any arrows here.\\n        backtrack(index+1,numArrows,aliceArrows,currentScore,currentVector);\\n}\\n};\\n\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint totalScore=0;\\nbool flag=false;\\nvector<int> bobScores;\\nvector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> currentVector(12,0);\\n        int index=0;\\n        int currentScore=0;\\n\\n        // we start with index=1 cause we don\\'t want to win section \"0\" as it has 0 score.\\n        // so we dont\\' want to waste any arrows in winning \"0\" points\\n\\n        //Standard backtrack Function\\n        backtrack(1,numArrows,aliceArrows,currentScore,currentVector);\\n\\n\\n        //If we have not used all the arrows for bobScore then we can just use them on section with 0 score.\\n        //Because we dont\\' care if alice or bob wins this section it will not effect the overall score.\\n        int sum=0;\\n        for(auto n:bobScores)\\n                sum+=n;\\n        bobScores[0]=numArrows-sum;\\n\\n        //return the formed anwers;\\n        return bobScores;\\n}\\n\\nvoid backtrack(int index,int numArrows,vector<int>&aliceArrows,int currentScore,vector<int>&currentVector){\\n\\n        // we have reached the end\\n        if(index==aliceArrows.size()) {\\n                if(currentScore>totalScore) {\\n                        totalScore=currentScore;\\n                        bobScores=currentVector;\\n                }\\n                return;\\n        }\\n\\n        //there are only two possibilities for each section\\n        //1. Either Bob Wants Wins it or he doesn\\'t want to win it.\\n\\n        //Option 1\\n        // If he wants to Wins it.\\n        //first we have to check if he can win it.\\n        int req=aliceArrows[index]+1;\\n        if(req<=numArrows) {\\n                currentVector[index]+=req;\\n                backtrack(index+1,numArrows-req,aliceArrows,currentScore+index,currentVector);\\n                currentVector[index]-=req;\\n        }\\n\\n\\n        //Option 2\\n        //If he dont\\'t want to win this section than he will not waste any arrows here.\\n        backtrack(index+1,numArrows,aliceArrows,currentScore,currentVector);\\n}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872837,
                "title": "java-dynamic-programming-recursion-memoization",
                "content": "Have maintained obj class for having list of values and val variable seperately and for having clean code.\\n```\\nclass obj{\\n    int val;\\n    List<Integer>l;\\n    obj(int val,List<Integer>l){\\n        this.val=val;\\n        this.l=l;\\n    }\\n    obj(obj o,int in,int value){\\n        this.l=new ArrayList<>(o.l);\\n        this.l.add(in);\\n        this.val=value;\\n    }\\n}\\nclass Solution {\\n    obj dp[][];\\n    public obj rec(int i,int numArrows,int arr[]){\\n        if(dp[i][numArrows]!=null)\\n            return dp[i][numArrows];\\n        if(i==arr.length-1){\\n            if(numArrows>arr[i])\\n                dp[i][numArrows]=new obj(i,Arrays.asList(numArrows));\\n            else\\n                dp[i][numArrows]=new obj(0,Arrays.asList(numArrows));\\n            return dp[i][numArrows];\\n        }\\n        if(numArrows>arr[i]){\\n            obj o1=rec(i+1,numArrows,arr);\\n            obj o2=rec(i+1,numArrows-arr[i]-1,arr);\\n            if(o2.val+i>o1.val)\\n                dp[i][numArrows]=new obj(o2,arr[i]+1,o2.val+i);\\n            else\\n                dp[i][numArrows]=new obj(o1,0,o1.val);\\n        }else{\\n            obj o1=rec(i+1,numArrows,arr);\\n            dp[i][numArrows]=new obj(o1,0,o1.val);\\n        }\\n        return dp[i][numArrows];\\n    }\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        dp=new obj[12][numArrows+1];\\n        obj res_obj=rec(0,numArrows,aliceArrows);\\n        int result[]=new int[12],in=12;\\n        for(int val:res_obj.l)\\n            result[--in]=val;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass obj{\\n    int val;\\n    List<Integer>l;\\n    obj(int val,List<Integer>l){\\n        this.val=val;\\n        this.l=l;\\n    }\\n    obj(obj o,int in,int value){\\n        this.l=new ArrayList<>(o.l);\\n        this.l.add(in);\\n        this.val=value;\\n    }\\n}\\nclass Solution {\\n    obj dp[][];\\n    public obj rec(int i,int numArrows,int arr[]){\\n        if(dp[i][numArrows]!=null)\\n            return dp[i][numArrows];\\n        if(i==arr.length-1){\\n            if(numArrows>arr[i])\\n                dp[i][numArrows]=new obj(i,Arrays.asList(numArrows));\\n            else\\n                dp[i][numArrows]=new obj(0,Arrays.asList(numArrows));\\n            return dp[i][numArrows];\\n        }\\n        if(numArrows>arr[i]){\\n            obj o1=rec(i+1,numArrows,arr);\\n            obj o2=rec(i+1,numArrows-arr[i]-1,arr);\\n            if(o2.val+i>o1.val)\\n                dp[i][numArrows]=new obj(o2,arr[i]+1,o2.val+i);\\n            else\\n                dp[i][numArrows]=new obj(o1,0,o1.val);\\n        }else{\\n            obj o1=rec(i+1,numArrows,arr);\\n            dp[i][numArrows]=new obj(o1,0,o1.val);\\n        }\\n        return dp[i][numArrows];\\n    }\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        dp=new obj[12][numArrows+1];\\n        obj res_obj=rec(0,numArrows,aliceArrows);\\n        int result[]=new int[12],in=12;\\n        for(int val:res_obj.l)\\n            result[--in]=val;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870380,
                "title": "bit-masking-dp-backtracking-c",
                "content": "**BITMASKING**\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int n, vector<int>& al) {\\n       \\n        int m = al.size();\\n        int amask = 0 , maxi = INT_MIN;\\n        \\n        for(int mask=0;mask<(1<<m);mask++){\\n            \\n            int arruse = 0 , score = 0;\\n            \\n            for(int i=0;i<12;i++){\\n                if(mask & (1<<i)){                     // compute arrowsUsed and score for each state\\n                    arruse += (al[i]+1);\\n                    score += i;\\n                }\\n            }                \\n            \\n            if(arruse <= n && score > maxi){           // if arrows used are less than total arrows\\n                maxi = score;                          // and score is greater than our curmaximum value\\n                amask = mask;                          // include it in our answer\\n            }\\n            \\n        }\\n        \\n        vector<int> ans(m);\\n        int sum = 0;\\n        \\n        for(int i=0;i<12;i++){\\n            if(amask & (1<<i)){\\n                ans[i] = al[i]+1;\\n                sum += ans[i];\\n            }\\n        }\\n        \\n        ans[0] = n - sum;\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**DP**\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n```\\nclass Solution {\\npublic:\\n    \\nint dp[100001][12];\\n\\nvector<int> maximumBobPoints(int n, vector<int>& al) {\\n\\n\\tmemset(dp,0,sizeof(dp));\\n\\tint m = al.size();\\n\\n\\tfor(int i=1;i<n+1;i++){\\n\\t\\tfor(int j=0;j<m;j++){\\n\\t\\t\\tif(j == 0){\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i-(al[j]+1) >= 0){\\n\\t\\t\\t\\tdp[i][j] = max(dp[i][j-1] , j + dp[i-(al[j]+1)][j-1]);\\n\\t\\t\\t}\\n\\t\\t\\telse dp[i][j] = dp[i][j-1];\\n\\t\\t}\\n\\t}\\n\\n\\tint i = n , j = m-1;\\n\\tvector<int> ans(m);\\n\\tint sum = 0;\\n\\n\\t// retrieve path from dp\\n\\n\\twhile(i>0 && j>0){\\n\\t\\tif(j > 0 && dp[i][j] != dp[i][j-1]){\\n\\t\\t  ans[j] = al[j]+1;\\n\\t\\t  i = i - (al[j]+1);\\n\\t\\t}\\n\\t\\tsum += ans[j];\\n\\t\\tj--;\\n\\t}\\n\\n\\tans[0] = n-sum;\\n\\n\\treturn ans;\\n}\\n};\\n```\\n\\n**BACKTRACKING**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxi = INT_MIN;\\n    vector<int> ans,res;\\n    \\n    void find(int i,int arrused,vector<int> &al,int n,int score){\\n        \\n         if(arrused > n)return ;\\n        \\n         if(i == al.size()){\\n            if(score > maxi){\\n                ans = res;\\n                maxi = score;\\n            }\\n            return ;\\n        }\\n        \\n        res.push_back(al[i]+1);\\n        find(i+1,arrused+al[i]+1,al,n,score +i);\\n        res.pop_back();\\n        \\n        res.push_back(0);\\n        find(i+1,arrused,al,n,score);\\n        res.pop_back();\\n        \\n    }\\n    \\n    vector<int> maximumBobPoints(int n, vector<int>& al) {\\n        \\n          find(0,0,al,n,0);\\n       \\n          int sum = 0;\\n          for(auto &x : ans){\\n              sum += x;\\n          }\\n            \\n          ans[0] += n-sum;\\n        \\n      return ans;  \\n    }\\n};  \\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int n, vector<int>& al) {\\n       \\n        int m = al.size();\\n        int amask = 0 , maxi = INT_MIN;\\n        \\n        for(int mask=0;mask<(1<<m);mask++){\\n            \\n            int arruse = 0 , score = 0;\\n            \\n            for(int i=0;i<12;i++){\\n                if(mask & (1<<i)){                     // compute arrowsUsed and score for each state\\n                    arruse += (al[i]+1);\\n                    score += i;\\n                }\\n            }                \\n            \\n            if(arruse <= n && score > maxi){           // if arrows used are less than total arrows\\n                maxi = score;                          // and score is greater than our curmaximum value\\n                amask = mask;                          // include it in our answer\\n            }\\n            \\n        }\\n        \\n        vector<int> ans(m);\\n        int sum = 0;\\n        \\n        for(int i=0;i<12;i++){\\n            if(amask & (1<<i)){\\n                ans[i] = al[i]+1;\\n                sum += ans[i];\\n            }\\n        }\\n        \\n        ans[0] = n - sum;\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\nint dp[100001][12];\\n\\nvector<int> maximumBobPoints(int n, vector<int>& al) {\\n\\n\\tmemset(dp,0,sizeof(dp));\\n\\tint m = al.size();\\n\\n\\tfor(int i=1;i<n+1;i++){\\n\\t\\tfor(int j=0;j<m;j++){\\n\\t\\t\\tif(j == 0){\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i-(al[j]+1) >= 0){\\n\\t\\t\\t\\tdp[i][j] = max(dp[i][j-1] , j + dp[i-(al[j]+1)][j-1]);\\n\\t\\t\\t}\\n\\t\\t\\telse dp[i][j] = dp[i][j-1];\\n\\t\\t}\\n\\t}\\n\\n\\tint i = n , j = m-1;\\n\\tvector<int> ans(m);\\n\\tint sum = 0;\\n\\n\\t// retrieve path from dp\\n\\n\\twhile(i>0 && j>0){\\n\\t\\tif(j > 0 && dp[i][j] != dp[i][j-1]){\\n\\t\\t  ans[j] = al[j]+1;\\n\\t\\t  i = i - (al[j]+1);\\n\\t\\t}\\n\\t\\tsum += ans[j];\\n\\t\\tj--;\\n\\t}\\n\\n\\tans[0] = n-sum;\\n\\n\\treturn ans;\\n}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int maxi = INT_MIN;\\n    vector<int> ans,res;\\n    \\n    void find(int i,int arrused,vector<int> &al,int n,int score){\\n        \\n         if(arrused > n)return ;\\n        \\n         if(i == al.size()){\\n            if(score > maxi){\\n                ans = res;\\n                maxi = score;\\n            }\\n            return ;\\n        }\\n        \\n        res.push_back(al[i]+1);\\n        find(i+1,arrused+al[i]+1,al,n,score +i);\\n        res.pop_back();\\n        \\n        res.push_back(0);\\n        find(i+1,arrused,al,n,score);\\n        res.pop_back();\\n        \\n    }\\n    \\n    vector<int> maximumBobPoints(int n, vector<int>& al) {\\n        \\n          find(0,0,al,n,0);\\n       \\n          int sum = 0;\\n          for(auto &x : ans){\\n              sum += x;\\n          }\\n            \\n          ans[0] += n-sum;\\n        \\n      return ans;  \\n    }\\n};  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869279,
                "title": "bit-masking-generating-all-subsets-2-n",
                "content": "Just find all subsets\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& alice) {\\n        int n=alice.size();\\n        int maxs=INT_MIN;\\n        vector<int> v(n,0);\\n        for(int i=0;i<(1<<n);i++){\\n            int a=0,x=0;\\n            vector<int> t(n,0);\\n            for(int j=0;j<n;j++){\\n                if(x>numArrows){\\n                    break;\\n                }\\n                if((i & (1<<j))){\\n                    t[n-1-j]=alice[n-1-j]+1;\\n                    x+=alice[n-1-j]+1;\\n                }\\n            }\\n            int s=0;\\n            for(int k=0;k<n;k++){\\n                a+=t[k];\\n                if(t[k]>0){\\n                    s+=k;\\n                }\\n            }\\n            if(a<=numArrows && s>maxs){\\n                if(a<numArrows){\\n                    t[0]=numArrows-a;\\n                }\\n                maxs=s;\\n                v=t;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& alice) {\\n        int n=alice.size();\\n        int maxs=INT_MIN;\\n        vector<int> v(n,0);\\n        for(int i=0;i<(1<<n);i++){\\n            int a=0,x=0;\\n            vector<int> t(n,0);\\n            for(int j=0;j<n;j++){\\n                if(x>numArrows){\\n                    break;\\n                }\\n                if((i & (1<<j))){\\n                    t[n-1-j]=alice[n-1-j]+1;\\n                    x+=alice[n-1-j]+1;\\n                }\\n            }\\n            int s=0;\\n            for(int k=0;k<n;k++){\\n                a+=t[k];\\n                if(t[k]>0){\\n                    s+=k;\\n                }\\n            }\\n            if(a<=numArrows && s>maxs){\\n                if(a<numArrows){\\n                    t[0]=numArrows-a;\\n                }\\n                maxs=s;\\n                v=t;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868292,
                "title": "java-backtracking",
                "content": "In total ```bob``` have ```12 rounds``` to play and in each round he can win this round or leave this round.\\n\\n* ```case 1 .``` if he wants to win this round then there should be enough number of \\n     arrows available for him to play this round, i.e. 1 arrow more than alice\\'s arrows ```a[idx] + 1```.\\n\\t \\n* ```case 2 .```  if he skips this round then number of ```arrows``` used does not changes and he can continue to play in the next round with those arrows.\\n\\nAlso just to satisfy the constraints we have to use all the ```arrows``` so just add the remaining arrows to the first round i.e. ```res[0]```.\\n```\\nclass Solution {\\n    //  maximum points scored by bob\\n    int maxBob = 0;\\n    //  alice array\\n    int[] a;\\n    //  result\\n    int[] res = new int[12];\\n    \\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        this.a = aliceArrows;\\n        int[] temp = new int[12];\\n        helper(numArrows, 11, 0, 0, temp);\\n        return res;\\n    }\\n    \\n    public void helper(int arrows, int idx, int used, int currPoints, int[] temp) {\\n        if (used == arrows || idx == 0) {\\n            if (currPoints > maxBob) {\\n                maxBob = currPoints;\\n                int num = clone(temp);\\n                //  if total arrows taken by bob is less than numArrows then\\n                //  just add the remaining arrows to res[0] just to satisfy the constraints\\n                if (num < arrows) {\\n                    res[0] += arrows - num;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        //  winning this section\\n        //  if i want to win this section then i must have enough arrows to win \\n        //  this round so arrows >= used + a[idx] + 1\\n        if (arrows >= used + a[idx] + 1) {\\n            temp[idx] = a[idx] + 1;\\n            helper(arrows, idx - 1, used + a[idx] + 1, currPoints + idx, temp);\\n            temp[idx] = 0;\\n        }\\n        \\n        //  skipping this section\\n        helper(arrows, idx - 1, used, currPoints, temp);\\n    }\\n    \\n    \\n    //  this updates the bob\\'s answer Array\\n    //  returns the total arrows taken by bob\\n    public int clone(int[] b) {\\n        int s = 0;\\n        for (int i = 0; i < 12; i++) {\\n            res[i] = b[i];\\n            s += b[i];\\n        }\\n        return s;\\n    }\\n}",
                "solutionTags": [],
                "code": "```bob```\n```12 rounds```\n```case 1 .```\n```a[idx] + 1```\n```case 2 .```\n```arrows```\n```arrows```\n```res[0]```",
                "codeTag": "Unknown"
            },
            {
                "id": 1867764,
                "title": "c-0-1-knapsack",
                "content": "```\\nclass Solution {\\n     int dp[100001][13];\\npublic:\\n    int helper(int numArrows, vector<int>& aliceArrows, int n) {\\n        if(numArrows == 0) return 0;\\n        if(n == 0) return 0;\\n        if(dp[numArrows][n] != -1) return dp[numArrows][n];\\n        \\n        if(numArrows > aliceArrows[n-1]) {\\n            return dp[numArrows][n] = max(n-1 + helper(numArrows-aliceArrows[n-1]-1, aliceArrows, n-1), \\n                                                helper(numArrows, aliceArrows, n-1));\\n        } else {\\n            return dp[numArrows][n] = helper(numArrows, aliceArrows, n-1);\\n        }\\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        memset(dp, -1, sizeof dp);\\n        vector<int> ret(aliceArrows.size(), 0);\\n        helper(numArrows, aliceArrows, aliceArrows.size());\\n        for(int i = aliceArrows.size(); i > 0; i--) {\\n            if(dp[numArrows][i] == dp[numArrows][i-1]) {\\n                ret[i-1] = 0;\\n            } else {\\n                ret[i-1] = aliceArrows[i-1] + 1;\\n                numArrows -= (aliceArrows[i-1] + 1);\\n            }\\n        }\\n        ret[0] += numArrows;\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n     int dp[100001][13];\\npublic:\\n    int helper(int numArrows, vector<int>& aliceArrows, int n) {\\n        if(numArrows == 0) return 0;\\n        if(n == 0) return 0;\\n        if(dp[numArrows][n] != -1) return dp[numArrows][n];\\n        \\n        if(numArrows > aliceArrows[n-1]) {\\n            return dp[numArrows][n] = max(n-1 + helper(numArrows-aliceArrows[n-1]-1, aliceArrows, n-1), \\n                                                helper(numArrows, aliceArrows, n-1));\\n        } else {\\n            return dp[numArrows][n] = helper(numArrows, aliceArrows, n-1);\\n        }\\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        memset(dp, -1, sizeof dp);\\n        vector<int> ret(aliceArrows.size(), 0);\\n        helper(numArrows, aliceArrows, aliceArrows.size());\\n        for(int i = aliceArrows.size(); i > 0; i--) {\\n            if(dp[numArrows][i] == dp[numArrows][i-1]) {\\n                ret[i-1] = 0;\\n            } else {\\n                ret[i-1] = aliceArrows[i-1] + 1;\\n                numArrows -= (aliceArrows[i-1] + 1);\\n            }\\n        }\\n        ret[0] += numArrows;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867435,
                "title": "java-dp-for-max-search-and-backtracking-for-array-of-results",
                "content": "\\tclass Solution {\\n\\t\\tprivate int[] arrows = new int[12];\\n\\n\\t\\tpublic int[] maximumBobPoints(int numArrows, int[] al) {\\n\\t\\t\\tint[][] result = new int[2][numArrows + 1];\\n\\t\\t\\tfor (int i = 0; i < 12; i++)  {\\n\\t\\t\\t\\tfor (int j = 1; j <= numArrows; j++) {\\n\\t\\t\\t\\t\\tint take = (al[i] < j) ? al[i] + 1 : 0;\\n\\t\\t\\t\\t\\tint points = (take > 0) ? i : 0;\\n\\t\\t\\t\\t\\tresult[1][j] = Math.max(result[0][j], result[0][j - take] + points);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor (int j = 0; j <= numArrows; j++) \\n\\t\\t\\t\\t\\tresult[0][j] = result[1][j];\\n\\t\\t\\t}\\n\\n\\t\\t\\tbackTracking(result[1][numArrows], numArrows, al, 11);\\n\\n\\t\\t\\treturn arrows;\\n\\t\\t}\\n\\n\\t\\tpublic boolean backTracking(int max, int numArrows, int[] al, int step) {\\n\\t\\t\\tif ((numArrows < 0) || step < 0)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tif (max == 0) {\\n\\t\\t\\t\\tif (numArrows > 0)\\n\\t\\t\\t\\t\\tarrows[0] = numArrows;\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t} \\n\\n\\t\\t\\tif (!backTracking(max - step, numArrows - al[step] - 1, al, step - 1)) {\\n\\t\\t\\t\\treturn backTracking(max, numArrows, al, step - 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tarrows[step] = al[step] + 1;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\t\\tprivate int[] arrows = new int[12];\\n\\n\\t\\tpublic int[] maximumBobPoints(int numArrows, int[] al) {\\n\\t\\t\\tint[][] result = new int[2][numArrows + 1];\\n\\t\\t\\tfor (int i = 0; i < 12; i++)  {\\n\\t\\t\\t\\tfor (int j = 1; j <= numArrows; j++) {\\n\\t\\t\\t\\t\\tint take = (al[i] < j) ? al[i] + 1 : 0;\\n\\t\\t\\t\\t\\tint points = (take > 0) ? i : 0;\\n\\t\\t\\t\\t\\tresult[1][j] = Math.max(result[0][j], result[0][j - take] + points);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1867166,
                "title": "c-0-1-knapsack-problem-backtracking",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    vector<int> res;\\n    int maxi=0;\\n    \\n    void solve(int arrow,vector<int> &alice,vector<int>& score,int sum,int idx){\\n        //base case\\n        if(idx<0 || arrow<=0){\\n            if(sum>maxi){\\n                if(arrow > 0)\\n                    score[0]+=arrow;\\n                maxi=sum;\\n                res=score;\\n            }\\n            return;\\n        }\\n        \\n        // if we include the current index\\n        if((arrow-(alice[idx]+1))>=0){\\n            score[idx]=alice[idx]+1;\\n            solve(arrow-(alice[idx]+1),alice,score,sum+idx,idx-1);\\n            score[idx]=0;\\n        }\\n        //if we are not including the current index\\n            solve(arrow,alice,score,sum,idx-1);\\n        \\n    }\\n    \\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> score(12,0);\\n                                      //sum//idx\\n        solve(numArrows,aliceArrows,score,0,11);\\n        //cout<<maxi<<\" \";\\n        return res;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    vector<int> res;\\n    int maxi=0;\\n    \\n    void solve(int arrow,vector<int> &alice,vector<int>& score,int sum,int idx){\\n        //base case\\n        if(idx<0 || arrow<=0){\\n            if(sum>maxi){\\n                if(arrow > 0)\\n                    score[0]+=arrow;\\n                maxi=sum;\\n                res=score;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1867058,
                "title": "c-dp-state-machine",
                "content": "Every index you have 2 options, either you can lose or win  -- i.e. 2 states at every index.\\nSuppose, if I plan to win at index i:\\n\\tarrowsLeft = numArrows -( aliceArrows[i] + 1) ;\\n\\twinPoints(i, numArrows ) = i + Max( winPoints( i+1, arrowsLeft) , losePoints( i+1, arrowsLeft) )\\nInstead, if I plan to lose at index i:\\n  losePoints(i, numArrows ) = Max( winPoints(i+1, numArrows), losePoints(i+1, numArrows) )\\n \\n Now, whether will I actually win or lose at index i will be a decision made based on which is max among winPoints(i, numArrows) & losePoints(i, numArrows)\\n \\n This type of problems where each index will have different possible states -- is what I call state Machine. So, this is a DP + State Machine problem.\\n\\nTime Complexity: O(numArrows * n * 2)  Here n = 12.\\n \\n Please **upvote** if you like the explanation.\\n \\n ```\\n class Solution {\\nprivate:\\n    int calcPoints(vector<int>& aliceArrows, vector<vector<int>>& winPoints, vector<vector<int>>& losePoints, int i, int numArrows){\\n        int n = aliceArrows.size();\\n        if(i>=n) return 0;\\n        else if(numArrows==0){\\n            winPoints[i][numArrows] =0;\\n            losePoints[i][numArrows] =0;\\n            return 0;\\n        }\\n        else if(winPoints[i][numArrows]!=-1 && losePoints[i][numArrows]!=-1){\\n            return max(winPoints[i][numArrows], losePoints[i][numArrows]);\\n        }\\n        if(numArrows> aliceArrows[i]){\\n            winPoints[i][numArrows] = i + calcPoints(aliceArrows, winPoints, losePoints, i+1, numArrows - aliceArrows[i] -1 );\\n        }\\n        else{\\n            winPoints[i][numArrows] = 0;\\n        }\\n        \\n        losePoints[i][numArrows] = calcPoints(aliceArrows, winPoints, losePoints, i+1, numArrows);\\n        \\n        return max(winPoints[i][numArrows], losePoints[i][numArrows]);\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n = aliceArrows.size();\\n        vector<vector<int>> winPoints(n, vector<int>(numArrows+1, -1));\\n        vector<vector<int>> losePoints(n, vector<int>(numArrows+1, -1));\\n        \\n        calcPoints(aliceArrows, winPoints, losePoints, 0, numArrows);\\n        \\n        int arrows = numArrows;\\n        vector<int> bobArrows(n, 0);\\n        \\n        for(int i=0;i<n;i++){\\n            if(winPoints[i][arrows]>losePoints[i][arrows]){\\n                bobArrows[i] = aliceArrows[i]+1;\\n                arrows = arrows - bobArrows[i];\\n            }\\n        }\\n        \\n        if(arrows){\\n            bobArrows[n-1] += arrows;\\n        }\\n        \\n        return bobArrows;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n class Solution {\\nprivate:\\n    int calcPoints(vector<int>& aliceArrows, vector<vector<int>>& winPoints, vector<vector<int>>& losePoints, int i, int numArrows){\\n        int n = aliceArrows.size();\\n        if(i>=n) return 0;\\n        else if(numArrows==0){\\n            winPoints[i][numArrows] =0;\\n            losePoints[i][numArrows] =0;\\n            return 0;\\n        }\\n        else if(winPoints[i][numArrows]!=-1 && losePoints[i][numArrows]!=-1){\\n            return max(winPoints[i][numArrows], losePoints[i][numArrows]);\\n        }\\n        if(numArrows> aliceArrows[i]){\\n            winPoints[i][numArrows] = i + calcPoints(aliceArrows, winPoints, losePoints, i+1, numArrows - aliceArrows[i] -1 );\\n        }\\n        else{\\n            winPoints[i][numArrows] = 0;\\n        }\\n        \\n        losePoints[i][numArrows] = calcPoints(aliceArrows, winPoints, losePoints, i+1, numArrows);\\n        \\n        return max(winPoints[i][numArrows], losePoints[i][numArrows]);\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n = aliceArrows.size();\\n        vector<vector<int>> winPoints(n, vector<int>(numArrows+1, -1));\\n        vector<vector<int>> losePoints(n, vector<int>(numArrows+1, -1));\\n        \\n        calcPoints(aliceArrows, winPoints, losePoints, 0, numArrows);\\n        \\n        int arrows = numArrows;\\n        vector<int> bobArrows(n, 0);\\n        \\n        for(int i=0;i<n;i++){\\n            if(winPoints[i][arrows]>losePoints[i][arrows]){\\n                bobArrows[i] = aliceArrows[i]+1;\\n                arrows = arrows - bobArrows[i];\\n            }\\n        }\\n        \\n        if(arrows){\\n            bobArrows[n-1] += arrows;\\n        }\\n        \\n        return bobArrows;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866610,
                "title": "c-bottom-up-dp-o-arrows-12-time-o-arrows-12-space-clean-and-concise-knapsack-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int arrows, vector<int>& alice) {\\n        vector<int> bob(12, 0);\\n        \\n        int dp[12][arrows + 1];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i = 0; i < 12; i++) {\\n            for(int j = 1; j <= arrows; j++) {\\n                dp[i][j] = (i > 0 ? dp[i - 1][j] : 0);\\n                if(j > alice[i]) {\\n                    dp[i][j] = max(dp[i][j], i + (i > 0 ? dp[i - 1][j - alice[i] - 1] : 0));\\n                }\\n            }\\n        }\\n        int i = 11, j = arrows;\\n        while(i >= 1 && j >= 0) {\\n            if(dp[i][j] == dp[i - 1][j]) {\\n                bob[i] = 0;\\n                i--;\\n            }\\n            else {\\n                bob[i] = alice[i] + 1;\\n                j = j - alice[i] - 1;\\n                i--;\\n            }\\n        }\\n        bob[0] = j;\\n        return bob;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int arrows, vector<int>& alice) {\\n        vector<int> bob(12, 0);\\n        \\n        int dp[12][arrows + 1];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i = 0; i < 12; i++) {\\n            for(int j = 1; j <= arrows; j++) {\\n                dp[i][j] = (i > 0 ? dp[i - 1][j] : 0);\\n                if(j > alice[i]) {\\n                    dp[i][j] = max(dp[i][j], i + (i > 0 ? dp[i - 1][j - alice[i] - 1] : 0));\\n                }\\n            }\\n        }\\n        int i = 11, j = arrows;\\n        while(i >= 1 && j >= 0) {\\n            if(dp[i][j] == dp[i - 1][j]) {\\n                bob[i] = 0;\\n                i--;\\n            }\\n            else {\\n                bob[i] = alice[i] + 1;\\n                j = j - alice[i] - 1;\\n                i--;\\n            }\\n        }\\n        bob[0] = j;\\n        return bob;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866321,
                "title": "explaination-hints-java-code-backtracking-100-faster",
                "content": "Hint 1 - For each index ( Except 0 , for 0 refer Hint 2) :-  Bob will need 1 extra arrow than Alice to win points .\\nHint 2 - Ignore 0th index , because it does not fetch us any points . Any extra arrows left at the end can be accomodated at 0th index.\\n\\nNow for example :- \\naliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]\\nthen for each index Bob require +1 of Alice arrow :-\\nBob =   [2,2,1,2,1,1,3,2,1,2,3,1]\\n \\nFrom this array we have to chose the index which fetch us the maximum points and store indexes in list *arr* during backtracking. \\n\\nWe will start from index 11 and go upto index 1 and use backtracking (using variable i ). \\n( Case 1 :   Current index gets added to profit : \\n\\t\\t\\t\\t- *Profit* increases by value of index\\n\\t\\t\\t\\t- *Index* decreases by 1\\n\\t\\t\\t\\t- *Number of arrows* decreased by value in array Bob at index i\\n\\n Case 2 : Current index does not gets added to profit :\\n\\t\\t\\t - *Profit* remains same\\n\\t\\t\\t - *Index* decreases by 1\\n\\t\\t\\t - *Number of arrows* remains same\\n)\\n\\nWe revise our final list every time we get profit more than the current maximum profit.\\n*fin* is the list having indexes that fetch us maximum profit.\\n( For example in above example : *fin = { 4,5,8,9,10,11 }*\\nAt the end store values in result , and if used arrows is less than the numArrows . adjust the remaining at 0 index. \\nIn result we put the values in *array Bob* at indexes received in *fin list. *\\n\\t\\'\\'\\'`\\nclass Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        \\n        int l = aliceArrows.length, c=0;\\n        ArrayList<Integer> fin = new ArrayList<>();\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        int[] maxx = new int[]{0};\\n        int[] bob = new int[l];\\n        \\n        for(int i=1; i<l; i++){\\n            bob[i] = aliceArrows[i] + 1;\\n        }\\n        \\n        help(bob , 0, arr, fin, maxx, 11 , numArrows);  \\n        \\n        int[] res = new int[l];\\n        for(int x=0; x<fin.size(); x++){\\n            res[fin.get(x)]=bob[fin.get(x)];\\n            c += bob[fin.get(x)];\\n        }\\n        if(c<numArrows){\\n            res[0] = numArrows-c;\\n        }\\n        return res;\\n    }\\n    \\n    public void help( int bob[], int profit, ArrayList<Integer> arr, ArrayList<Integer> fin ,int maxx[],  int i, int n){\\n        \\n        if(i==0){\\n            if(profit>maxx[0] && n>=0){\\n                fin.clear();\\n                int x = arr.size();\\n                for(int j=0; j<x; j++){\\n                    fin.add(arr.get(j));\\n                }\\n                maxx[0] = profit;\\n            }\\n            return;   \\n        }\\n        arr.add(i);\\n        help(bob, profit+i, arr, fin, maxx, i-1, n-bob[i]);\\n        arr.remove(arr.size()-1);\\n        help(bob, profit, arr, fin, maxx, i-1, n);\\n    }  \\n}\\n\\n\\'\\'\\'\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        \\n        int l = aliceArrows.length, c=0;\\n        ArrayList<Integer> fin = new ArrayList<>();\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        int[] maxx = new int[]{0}",
                "codeTag": "Java"
            },
            {
                "id": 1866264,
                "title": "javascript-backtracking",
                "content": "**Solution: Backtracking**\\n\\nUse backtracking to find all combinations of using the arrows.\\nFor each slot, try two choices:\\n1. Don\\'t use any arrows\\n2. Use aliceArrows[idx] + 1 arrows to gain idx number of points\\n\\nNote: When we fill all slots and still have some arrows left, we can put the extra arrows in any slot.\\nIn this solution, I have placed them in the last slot.\\n\\nTime Complexity: `O(2^n) `80ms\\nSpace Complexity: `O(2^n)` 42.7MB\\n```\\nvar maximumBobPoints = function(numArrows, aliceArrows) {\\n  let max = 0, n = aliceArrows.length, res;\\n  backtrack(numArrows, 0, 0, Array(n).fill(0));\\n  return res;\\n\\n  function backtrack(arrows, idx, points, bobArrows) {\\n    if (idx === n || arrows === 0) {\\n      let origVal = bobArrows[n - 1];\\n      if (arrows > 0) bobArrows[n - 1] += arrows; // put extra arrows in any slot\\n      if (points > max) {\\n        max = points;\\n        res = [...bobArrows]; \\n      }\\n      bobArrows[n - 1] = origVal;\\n      return;\\n    }\\n\\n    backtrack(arrows, idx + 1, points, bobArrows); // don\\'t use any arrows\\n    if (aliceArrows[idx] + 1 <= arrows) { // use aliceArrows[idx] + 1 arrows to gain idx points\\n      bobArrows[idx] = aliceArrows[idx] + 1;\\n      backtrack(arrows - (aliceArrows[idx] + 1), idx + 1, points + idx, bobArrows);\\n      bobArrows[idx] = 0;\\n    }\\n  }  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumBobPoints = function(numArrows, aliceArrows) {\\n  let max = 0, n = aliceArrows.length, res;\\n  backtrack(numArrows, 0, 0, Array(n).fill(0));\\n  return res;\\n\\n  function backtrack(arrows, idx, points, bobArrows) {\\n    if (idx === n || arrows === 0) {\\n      let origVal = bobArrows[n - 1];\\n      if (arrows > 0) bobArrows[n - 1] += arrows; // put extra arrows in any slot\\n      if (points > max) {\\n        max = points;\\n        res = [...bobArrows]; \\n      }\\n      bobArrows[n - 1] = origVal;\\n      return;\\n    }\\n\\n    backtrack(arrows, idx + 1, points, bobArrows); // don\\'t use any arrows\\n    if (aliceArrows[idx] + 1 <= arrows) { // use aliceArrows[idx] + 1 arrows to gain idx points\\n      bobArrows[idx] = aliceArrows[idx] + 1;\\n      backtrack(arrows - (aliceArrows[idx] + 1), idx + 1, points + idx, bobArrows);\\n      bobArrows[idx] = 0;\\n    }\\n  }  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1866042,
                "title": "python3-dp-100-with-detailed-explanation",
                "content": "Idea: For each round, use a dictionary to store:\\n1. Bidding history\\n2. Score so far\\n3. Arrows left \\n\\nThe bidding history is for output. It\\'s getting longer each round.\\nThe score is for comparison at the end. \\nThe arrows left is to see if we can bid in the next round.\\n\\nThe only thing we need to take care of is, there are too many arrows so there are arrows left at the end. My way is to dump them to round 0.\\n\\n\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        \\n        # Initialization with round 1 (round 0 is skipped)\\n        dp = {(0, 0): (0, numArrows), (0, aliceArrows[1] + 1): (1, numArrows - (aliceArrows[1] + 1))}\\n        \\n        # Loop from round 2\\n        for i in range(2, 12):\\n            prev = dp\\n            dp = {}\\n            \\n            # Consider two possible strategies for each state from last round: to bid and not to bid\\n            for key in prev:\\n                \\n                # Base case: not to bid in this round. Score and arrows left do not change.\\n                # Simply append 0 at the end to the key.\\n                newkey1 = list(key)\\n                newkey1.append(0)\\n                score, arrowleft = prev[key]\\n                \\n                newval1 = (score, arrowleft)\\n                dp[tuple(newkey1)] = newval1\\n                \\n                # If we still have enough arrows, we can bid in this round\\n                if arrowleft >= aliceArrows[i] + 1:\\n                    newkey2 = list(key)\\n                    newkey2.append(aliceArrows[i] + 1)\\n                    newval2 = (score + i, arrowleft - (aliceArrows[i] + 1))\\n                    dp[tuple(newkey2)] = newval2\\n        \\n        # Select the bidding history with max score\\n        maxscore, res = 0, None\\n        for key in dp:\\n            score, _ = dp[key]\\n            if score > maxscore:\\n                maxscore = score\\n                res = list(key)\\n        \\n        # Taking care of the corner case, where too many arrows are given\\n        if sum(res) < numArrows:\\n            res[0] = numArrows - sum(res)\\n        \\n        return res\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        \\n        # Initialization with round 1 (round 0 is skipped)\\n        dp = {(0, 0): (0, numArrows), (0, aliceArrows[1] + 1): (1, numArrows - (aliceArrows[1] + 1))}\\n        \\n        # Loop from round 2\\n        for i in range(2, 12):\\n            prev = dp\\n            dp = {}\\n            \\n            # Consider two possible strategies for each state from last round: to bid and not to bid\\n            for key in prev:\\n                \\n                # Base case: not to bid in this round. Score and arrows left do not change.\\n                # Simply append 0 at the end to the key.\\n                newkey1 = list(key)\\n                newkey1.append(0)\\n                score, arrowleft = prev[key]\\n                \\n                newval1 = (score, arrowleft)\\n                dp[tuple(newkey1)] = newval1\\n                \\n                # If we still have enough arrows, we can bid in this round\\n                if arrowleft >= aliceArrows[i] + 1:\\n                    newkey2 = list(key)\\n                    newkey2.append(aliceArrows[i] + 1)\\n                    newval2 = (score + i, arrowleft - (aliceArrows[i] + 1))\\n                    dp[tuple(newkey2)] = newval2\\n        \\n        # Select the bidding history with max score\\n        maxscore, res = 0, None\\n        for key in dp:\\n            score, _ = dp[key]\\n            if score > maxscore:\\n                maxscore = score\\n                res = list(key)\\n        \\n        # Taking care of the corner case, where too many arrows are given\\n        if sum(res) < numArrows:\\n            res[0] = numArrows - sum(res)\\n        \\n        return res\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865858,
                "title": "c-basic-recursion-trick-to-not-get-tricked-clear-solution-c-no-dp-needed",
                "content": "```\\nclass Solution {\\n    private:\\n    vector<int>v;\\n    int ans = 0;\\n    void f(vector<int>&nums,int i,int points,int numArrows,vector<int>&a){\\n        if(i==nums.size() || numArrows<=0){\\n            if(points>ans){\\n                ans = points;\\n                for(int i = 0;i<12;++i){\\n                    v[i] = a[i];\\n                }\\n                v[0]+=numArrows;\\n            }\\n            return;\\n        }\\n        \\n        \\n        if(nums[i]<numArrows){\\n            a[i] = nums[i]+1;\\n            f(nums,i+1,points+i,numArrows-nums[i]-1,a);\\n            a[i] = 0;\\n            f(nums,i+1,points,numArrows,a);\\n        }\\n        else{\\n            f(nums,i+1,points,numArrows,a);\\n        }\\n    }\\n    \\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>a(12,0);\\n        v.resize(12,0);\\n        int n = aliceArrows.size();\\n        f(aliceArrows,0,0,numArrows,a);\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math",
                    "Recursion"
                ],
                "code": "class Solution {\\n    private:\\n    vector<int>v;\\n    int ans = 0;\\n    void f(vector<int>&nums,int i,int points,int numArrows,vector<int>&a){\\n        if(i==nums.size() || numArrows<=0){\\n            if(points>ans){\\n                ans = points;\\n                for(int i = 0;i<12;++i){\\n                    v[i] = a[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1865821,
                "title": "recursive-easy-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    vector<int>res;\\n    int score=0;\\n    void util(int arrows,vector<int>&nums,vector<int>&v,int pos,int curr_score){\\n        \\n        if(pos==nums.size()){\\n            if(score<curr_score){\\n                score=curr_score;\\n                res=v;\\n            }\\n            return;\\n        }\\n        \\n        \\n        if(arrows==0){\\n            if(score<curr_score){\\n                score=curr_score;\\n                res=v;\\n            }\\n            return ;\\n        }\\n        \\n        if(score<curr_score){\\n            score=curr_score;\\n            res=v;\\n        }\\n        \\n        \\n        int temp=v[pos];\\n        //either i want that score\\n        if(arrows>=nums[pos]+1){\\n            v[pos]=nums[pos]+1;\\n            util(arrows-v[pos],nums,v,pos+1,curr_score+pos);\\n        }\\n        v[pos]=temp;\\n        util(arrows,nums,v,pos+1,curr_score);\\n        \\n        \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n     //either i can shot a arrow more than alice and can gain those points else i can ignore a point\\n        \\n        vector<int>v(aliceArrows.size(),0);\\n        util(numArrows,aliceArrows,v,0,0);\\n      \\n        int c=0;\\n        for(int i=0;i<res.size();i++)\\n            c+=res[i];\\n        \\n        res[0]+=numArrows-c;\\n        \\n        return res;\\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    vector<int>res;\\n    int score=0;\\n    void util(int arrows,vector<int>&nums,vector<int>&v,int pos,int curr_score){\\n        \\n        if(pos==nums.size()){\\n            if(score<curr_score){\\n                score=curr_score;\\n                res=v;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1865787,
                "title": "2-solutions-c-backtracking-dp-knapsack-solution-easy-to-understand",
                "content": "```\\n// BACKTRACKING SOLUTION\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int points=0;\\n    \\n    void rec(int n,vector<int>& aliceArrows,int idx,int sum,vector<int>& res)\\n    {\\n        if(idx>=12)\\n        {\\n            if(sum>points)\\n            {\\n                points=sum;\\n                ans=res;\\n            }\\n            return;\\n        }\\n        \\n       int req=aliceArrows[idx]+1;\\n       if(n>=req)\\n       {\\n           res[idx]=req;\\n           rec(n-req,aliceArrows,idx+1,sum+idx,res);\\n           res[idx]=0;\\n           rec(n,aliceArrows,idx+1,sum,res);\\n       } \\n       else rec(n,aliceArrows,idx+1,sum,res);\\n       \\n        return;\\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> res(12,0);\\n        int sum=0;\\n        rec(numArrows,aliceArrows,0,sum,res);\\n          \\n\\t\\t int n=0;\\n        \\n        for(int i=0;i<12;i++) n+=ans[i];\\n        if(n<numArrows) \\n        {\\n            numArrows-=n;\\n            for(int i=0;i<12;i++)\\n            {\\n                if(ans[i]>0)\\n                {\\n                    ans[i]+=numArrows;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n```\\n// DP SOLUTION\\n\\nclass Solution {\\npublic:\\n    int memo[100005][15];\\n    \\n    int rec(int n,vector<int>& aliceArrows,int idx)\\n    {\\n       if(n==0||idx>=12) return 0;\\n       if(memo[n][idx]!=-1) return memo[n][idx];\\n        \\n       int req=aliceArrows[idx]+1;\\n      \\n       if(n>=req)\\n       {\\n           int a=rec(n-req,aliceArrows,idx+1)+idx;\\n           int b=rec(n,aliceArrows,idx+1);\\n                      \\n           return memo[n][idx]=max(a,b);\\n       } \\n       else return memo[n][idx]=rec(n,aliceArrows,idx+1);\\n       \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        memset(memo,-1,sizeof(memo));\\n        vector<int> res(12,0);\\n        int orgNumArrows=numArrows;\\n        rec(numArrows,aliceArrows,0);\\n        \\n        for(int i=0;i<12;i++)\\n        {\\n            if(rec(numArrows,aliceArrows,i)!=rec(numArrows,aliceArrows,i+1))\\n            {\\n                res[i]=aliceArrows[i]+1;\\n                numArrows-=res[i];\\n            }\\n        }\\n        \\n        int n=0;\\n        \\n        for(int i=0;i<12;i++) n+=res[i];\\n        if(n<orgNumArrows) \\n        {\\n            orgNumArrows-=n;\\n            for(int i=0;i<12;i++)\\n            {\\n                if(res[i]>0)\\n                {\\n                    res[i]+=orgNumArrows;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\n// BACKTRACKING SOLUTION\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int points=0;\\n    \\n    void rec(int n,vector<int>& aliceArrows,int idx,int sum,vector<int>& res)\\n    {\\n        if(idx>=12)\\n        {\\n            if(sum>points)\\n            {\\n                points=sum;\\n                ans=res;\\n            }\\n            return;\\n        }\\n        \\n       int req=aliceArrows[idx]+1;\\n       if(n>=req)\\n       {\\n           res[idx]=req;\\n           rec(n-req,aliceArrows,idx+1,sum+idx,res);\\n           res[idx]=0;\\n           rec(n,aliceArrows,idx+1,sum,res);\\n       } \\n       else rec(n,aliceArrows,idx+1,sum,res);\\n       \\n        return;\\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> res(12,0);\\n        int sum=0;\\n        rec(numArrows,aliceArrows,0,sum,res);\\n          \\n\\t\\t int n=0;\\n        \\n        for(int i=0;i<12;i++) n+=ans[i];\\n        if(n<numArrows) \\n        {\\n            numArrows-=n;\\n            for(int i=0;i<12;i++)\\n            {\\n                if(ans[i]>0)\\n                {\\n                    ans[i]+=numArrows;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\n// DP SOLUTION\\n\\nclass Solution {\\npublic:\\n    int memo[100005][15];\\n    \\n    int rec(int n,vector<int>& aliceArrows,int idx)\\n    {\\n       if(n==0||idx>=12) return 0;\\n       if(memo[n][idx]!=-1) return memo[n][idx];\\n        \\n       int req=aliceArrows[idx]+1;\\n      \\n       if(n>=req)\\n       {\\n           int a=rec(n-req,aliceArrows,idx+1)+idx;\\n           int b=rec(n,aliceArrows,idx+1);\\n                      \\n           return memo[n][idx]=max(a,b);\\n       } \\n       else return memo[n][idx]=rec(n,aliceArrows,idx+1);\\n       \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        memset(memo,-1,sizeof(memo));\\n        vector<int> res(12,0);\\n        int orgNumArrows=numArrows;\\n        rec(numArrows,aliceArrows,0);\\n        \\n        for(int i=0;i<12;i++)\\n        {\\n            if(rec(numArrows,aliceArrows,i)!=rec(numArrows,aliceArrows,i+1))\\n            {\\n                res[i]=aliceArrows[i]+1;\\n                numArrows-=res[i];\\n            }\\n        }\\n        \\n        int n=0;\\n        \\n        for(int i=0;i<12;i++) n+=res[i];\\n        if(n<orgNumArrows) \\n        {\\n            orgNumArrows-=n;\\n            for(int i=0;i<12;i++)\\n            {\\n                if(res[i]>0)\\n                {\\n                    res[i]+=orgNumArrows;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865765,
                "title": "c-well-commented-dp-with-bitmasking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n = aliceArrows.size();\\n\\t\\t\\n\\t\\t// dp[mask] represents the following value:\\n\\t\\t// The positions of set bits of mask represents the target indices where Bob outperforms Alice\\n\\t\\t// dp[mask] represents the minimum number of arrows it would require\\n        vector<int> dp(1 << n, INT_MAX);\\n\\t\\t\\n        dp[0] = 0;\\n\\t\\t\\n\\t\\t// imax stores the maximum score that Bob can get\\n\\t\\t// ans stores the mask with which he gets that score\\n        int imax = 0, ans;\\n        \\n\\t\\t// Iterating over all possible masks\\n        for(int mask = 0; mask < (1 << n); mask++) {\\n\\t\\t\\n\\t\\t\\t// Maintaining the score for the current mask\\n            int score = 0;\\n            for(int i = 0; i < n; i++) {\\n\\t\\t\\t\\n\\t\\t\\t\\t// If the current target index is where Bob outperforms Alice\\n                if(mask & (1 << i)) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// Including the score of the current target\\n                    score += i;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// Updating the DP value\\n\\t\\t\\t\\t\\t// mask ^ (1 << i) resets the bit at i\\n\\t\\t\\t\\t\\t// so dp[mask ^ (1 << i)] is the minimum number of arrows required excluding the current target\\n                    dp[mask] = min(dp[mask], aliceArrows[i] + 1 + dp[mask ^ (1 << i)]);\\n                }\\n            }\\n            \\n\\t\\t\\t// If the minimum number of arrows required\\n\\t\\t\\t// is less than the number of given arrows, \\n\\t\\t\\t// then this mask can be a possible answer\\n            if(dp[mask] <= numArrows) {\\n                if(score > imax) {\\n                    imax = score;\\n                    ans = mask;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// To determine the vector which is to be returned, \\n\\t\\t// we traverse over all indices.\\n\\t\\t// If it is included in the final mask, then Bob is given 1 arrow more than\\n\\t\\t// what Alice has in that index\\n        vector<int> ret(n);\\n        for(int i = 0; i < n; i++) {\\n            if(ans & (1 << i)) {\\n                ret[i] = aliceArrows[i] + 1;\\n                numArrows -= ret[i];\\n            }\\n        }\\n        \\n\\t\\t// The remaining arrows are added to the first target index as it makes\\n\\t\\t// no difference\\n        ret[0] += numArrows;\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n = aliceArrows.size();\\n\\t\\t\\n\\t\\t// dp[mask] represents the following value:\\n\\t\\t// The positions of set bits of mask represents the target indices where Bob outperforms Alice\\n\\t\\t// dp[mask] represents the minimum number of arrows it would require\\n        vector<int> dp(1 << n, INT_MAX);\\n\\t\\t\\n        dp[0] = 0;\\n\\t\\t\\n\\t\\t// imax stores the maximum score that Bob can get\\n\\t\\t// ans stores the mask with which he gets that score\\n        int imax = 0, ans;\\n        \\n\\t\\t// Iterating over all possible masks\\n        for(int mask = 0; mask < (1 << n); mask++) {\\n\\t\\t\\n\\t\\t\\t// Maintaining the score for the current mask\\n            int score = 0;\\n            for(int i = 0; i < n; i++) {\\n\\t\\t\\t\\n\\t\\t\\t\\t// If the current target index is where Bob outperforms Alice\\n                if(mask & (1 << i)) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// Including the score of the current target\\n                    score += i;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// Updating the DP value\\n\\t\\t\\t\\t\\t// mask ^ (1 << i) resets the bit at i\\n\\t\\t\\t\\t\\t// so dp[mask ^ (1 << i)] is the minimum number of arrows required excluding the current target\\n                    dp[mask] = min(dp[mask], aliceArrows[i] + 1 + dp[mask ^ (1 << i)]);\\n                }\\n            }\\n            \\n\\t\\t\\t// If the minimum number of arrows required\\n\\t\\t\\t// is less than the number of given arrows, \\n\\t\\t\\t// then this mask can be a possible answer\\n            if(dp[mask] <= numArrows) {\\n                if(score > imax) {\\n                    imax = score;\\n                    ans = mask;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// To determine the vector which is to be returned, \\n\\t\\t// we traverse over all indices.\\n\\t\\t// If it is included in the final mask, then Bob is given 1 arrow more than\\n\\t\\t// what Alice has in that index\\n        vector<int> ret(n);\\n        for(int i = 0; i < n; i++) {\\n            if(ans & (1 << i)) {\\n                ret[i] = aliceArrows[i] + 1;\\n                numArrows -= ret[i];\\n            }\\n        }\\n        \\n\\t\\t// The remaining arrows are added to the first target index as it makes\\n\\t\\t// no difference\\n        ret[0] += numArrows;\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865739,
                "title": "simple-recursive-solution-c",
                "content": "https://leetcode.com/submissions/detail/663473879/\\n\\nclass Solution {\\n    string ans;\\n    int mx=0;\\npublic:\\n    int validateString(string s)\\n    {\\n        int val=0;\\n        for(int i=0;i<11;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n             val+=11-i;   \\n        }\\n       return val; \\n    }\\n    int f(int k, vector<int>& a,int i,vector<int>& b,string y)\\n    {\\n        int n=a.size();   \\n        if(i<0)\\n        {\\n            int curr_val=validateString(y);\\n            if(curr_val>mx)\\n            {\\n                mx=curr_val;\\n                ans=y;\\n            }\\n            return 0;\\n        }\\n        int take =0;\\n        if(a[i]<k)\\n        {\\n            take=i+1+f(k-a[i]-1,a,i-1,b,y+\\'1\\');\\n        }\\n        int notTake=f(k,a,i-1,b,y+\\'0\\');\\n       \\n        return max(take,notTake);;\\n    }\\n    vector<int> maximumBobPoints(int k, vector<int>& a) {\\n        int n=a.size();\\n        string y;\\n        vector<int> b(n,0);\\n        f(k,a,n-1,b,y);\\n        reverse(ans.begin(),ans.end());\\n        for(int i=0;i<=11;i++)\\n        {\\n            if(ans[i]==\\'1\\')\\n                b[i]=a[i]+1;\\n            k-=b[i];  \\n        }\\n        b[0]+=k;   // adding the remaining shots (GOT LATE IN CONTEST BECAUSE OF THIS)\\n        return b;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    string ans;\\n    int mx=0;\\npublic:\\n    int validateString(string s)\\n    {\\n        int val=0;\\n        for(int i=0;i<11;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n             val+=11-i;   \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1865671,
                "title": "recursion-basic-cpp-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>final;\\n    int maxs=0;\\n    int helper(int arrows,vector<int>&alice,vector<int>bob,int currsum,int i)\\n    {\\n        if(arrows==0){\\n            if(currsum>maxs)\\n            {\\n                final=bob;maxs=currsum;\\n            }\\n            return currsum;\\n        }\\n        if(arrows<0)\\n         return INT_MIN;  \\n        if(i>=12){\\n            if(arrows>0)\\n            {\\n                if(currsum>maxs){\\n                    bob[0]=arrows;\\n                    maxs=currsum;\\n                    final=bob;\\n                }\\n            }\\n            \\n            return 0;}\\n        \\n        helper(arrows,alice,bob,currsum,i+1);\\n        if(alice[i]==0)bob[i]=1;\\n        else\\n            bob[i]=alice[i]+1;\\n        helper(arrows-bob[i],alice,bob,currsum+i,i+1);\\n        return 0;\\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>bob(12,0);\\n       \\n        helper(numArrows,aliceArrows,bob,0,0);\\n        return final;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>final;\\n    int maxs=0;\\n    int helper(int arrows,vector<int>&alice,vector<int>bob,int currsum,int i)\\n    {\\n        if(arrows==0){\\n            if(currsum>maxs)\\n            {\\n                final=bob;maxs=currsum;\\n            }\\n            return currsum;\\n        }\\n        if(arrows<0)\\n         return INT_MIN;  \\n        if(i>=12){\\n            if(arrows>0)\\n            {\\n                if(currsum>maxs){\\n                    bob[0]=arrows;\\n                    maxs=currsum;\\n                    final=bob;\\n                }\\n            }\\n            \\n            return 0;}\\n        \\n        helper(arrows,alice,bob,currsum,i+1);\\n        if(alice[i]==0)bob[i]=1;\\n        else\\n            bob[i]=alice[i]+1;\\n        helper(arrows-bob[i],alice,bob,currsum+i,i+1);\\n        return 0;\\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>bob(12,0);\\n       \\n        helper(numArrows,aliceArrows,bob,0,0);\\n        return final;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865661,
                "title": "simple-recusive-dp-solution-no-need-of-memo",
                "content": "class Solution {\\n    string ans;\\n    int mx=0;\\npublic:\\n    int val(string s)\\n    {\\n        int f=0;\\n        for(int i=0;i<11;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n             f+=11-i;   \\n        }\\n       return f; \\n    }\\n    int f(int k, vector<int>& a,int i,vector<int>& b,string y)\\n    {\\n        int n=a.size();   \\n        if(i<0)\\n        {\\n            int o=val(y);\\n            if(o>mx)\\n            {\\n                mx=o;\\n                ans=y;\\n            }\\n            return 0;\\n        }\\n        int take =0;\\n        if(a[i]<k)\\n        {\\n            take=i+1+f(k-a[i]-1,a,i-1,b,y+\\'1\\');\\n        }\\n        int notTake=f(k,a,i-1,b,y+\\'0\\');\\n        int cur=max(take,notTake);\\n        if(i==0)\\n        { \\n            if(mx<cur)\\n            ans=y,mx=cur;     \\n        }\\n        return cur;\\n    }\\n    vector<int> maximumBobPoints(int k, vector<int>& a) {\\n        int n=a.size();\\n        string y;\\n        vector<int> b(n,0);\\n        int p=f(k,a,n-1,b,y);\\n        reverse(ans.begin(),ans.end());\\n        for(int i=0;i<=11;i++)\\n        {\\n            if(ans[i]==\\'1\\')\\n                b[i]=a[i]+1;\\n            k-=b[i];\\n        }\\n        b[0]+=k;\\n        return b;\\n    }\\n1. * };",
                "solutionTags": [],
                "code": "class Solution {\\n    string ans;\\n    int mx=0;\\npublic:\\n    int val(string s)\\n    {\\n        int f=0;\\n        for(int i=0;i<11;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n             f+=11-i;   \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1865630,
                "title": "simple-c-recursive-solution",
                "content": "```\\nclass Solution {\\n    \\n    void func(int ind,int count,vector<int>& a,vector<int>& ans,vector<int> temp,int sum,int& total){\\n        if(count==0 || ind<0){\\n            if(sum>total){\\n                ans=temp;\\n                total=sum;\\n            }\\n            return ;\\n        }\\n        \\n        //pick all count at zero index\\n        if(ind==0){\\n            if(count>a[ind]){\\n                temp[ind]=count;\\n\\t\\t\\t\\tfunc(ind-1,0,a,ans,temp,sum+ind,total);\\n\\t\\t\\t\\ttemp[ind]=0;\\n            }\\n            else{\\n                temp[ind]=count;\\n                func(ind-1,0,a,ans,temp,sum,total);\\n                temp[ind]=0;\\n            }\\n            return;\\n        }\\n        \\n\\t\\t//pick condition\\n        if(count>a[ind]){\\n                temp[ind]=a[ind]+1;\\n                func(ind-1,count-a[ind]-1,a,ans,temp,sum+ind,total);\\n                temp[ind]=0;\\n            \\n        }\\n\\t\\t//not pick\\n        func(ind-1,count,a,ans,temp,sum,total);\\n        \\n    }\\n    \\n    \\npublic:\\n    vector<int> maximumBobPoints(int count, vector<int>& a) {\\n        vector<int> ans(12,0),temp(12,0);\\n        \\n        int total=0;\\n        func(11,count,a,ans,temp,0,total);\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    void func(int ind,int count,vector<int>& a,vector<int>& ans,vector<int> temp,int sum,int& total){\\n        if(count==0 || ind<0){\\n            if(sum>total){\\n                ans=temp;\\n                total=sum;\\n            }\\n            return ;\\n        }\\n        \\n        //pick all count at zero index\\n        if(ind==0){\\n            if(count>a[ind]){\\n                temp[ind]=count;\\n\\t\\t\\t\\tfunc(ind-1,0,a,ans,temp,sum+ind,total);\\n\\t\\t\\t\\ttemp[ind]=0;\\n            }\\n            else{\\n                temp[ind]=count;\\n                func(ind-1,0,a,ans,temp,sum,total);\\n                temp[ind]=0;\\n            }\\n            return;\\n        }\\n        \\n\\t\\t//pick condition\\n        if(count>a[ind]){\\n                temp[ind]=a[ind]+1;\\n                func(ind-1,count-a[ind]-1,a,ans,temp,sum+ind,total);\\n                temp[ind]=0;\\n            \\n        }\\n\\t\\t//not pick\\n        func(ind-1,count,a,ans,temp,sum,total);\\n        \\n    }\\n    \\n    \\npublic:\\n    vector<int> maximumBobPoints(int count, vector<int>& a) {\\n        vector<int> ans(12,0),temp(12,0);\\n        \\n        int total=0;\\n        func(11,count,a,ans,temp,0,total);\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865600,
                "title": "python3-clean-easy-to-understand-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        self.max_points = 0\\n        self.res = None\\n        bobArrows = [0] * len(aliceArrows)\\n        \\n        def backtrack(budget, i, points, bobArrows):\\n            if not budget or i == len(aliceArrows):\\n                if points > self.max_points:\\n                    self.max_points = points\\n                    self.res = bobArrows[:]\\n                return\\n                \\n            if budget > aliceArrows[i]:\\n                bobArrows[i] = aliceArrows[i] + 1\\n                backtrack(budget - bobArrows[i], i+1, points + i, bobArrows)\\n\\t\\t\\t\\t# Undo\\n                bobArrows[i] = 0\\n            \\n            backtrack(budget, i+1, points, bobArrows)\\n                \\n            \\n        backtrack(numArrows, 1, 0, bobArrows)\\n\\t\\t# Remaining arrows assign to 0 points\\n        self.res[0] = numArrows - sum(self.res)\\n        return self.res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        self.max_points = 0\\n        self.res = None\\n        bobArrows = [0] * len(aliceArrows)\\n        \\n        def backtrack(budget, i, points, bobArrows):\\n            if not budget or i == len(aliceArrows):\\n                if points > self.max_points:\\n                    self.max_points = points\\n                    self.res = bobArrows[:]\\n                return\\n                \\n            if budget > aliceArrows[i]:\\n                bobArrows[i] = aliceArrows[i] + 1\\n                backtrack(budget - bobArrows[i], i+1, points + i, bobArrows)\\n\\t\\t\\t\\t# Undo\\n                bobArrows[i] = 0\\n            \\n            backtrack(budget, i+1, points, bobArrows)\\n                \\n            \\n        backtrack(numArrows, 1, 0, bobArrows)\\n\\t\\t# Remaining arrows assign to 0 points\\n        self.res[0] = numArrows - sum(self.res)\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865585,
                "title": "python-backtracking-with-explanation",
                "content": "We use backtracking from the right side to find all the possibilities. \\n\\nTerminate the backtracking when we have gone past the last section or ran out of arrows.\\n\\n```py\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        max_score = [0, None]\\n        def calc(i, remaining, score, arrows):\\n\\t\\t    # Base case. Update max score.\\n            if remaining == 0 or i == -1:\\n                if score > max_score[0]:\\n                    max_score[0] = score\\n                    max_score[1] = arrows[:]\\n                return\\n\\n\\t\\t\\t# Special handling for the last section. Use up all the arrows.\\n            if i == 0:\\n                arrows[i] = remaining\\n                calc(i - 1, 0, score + i, arrows)\\n                arrows[i] = 0\\n                return\\n\\n\\t\\t    # Try to compete with Alice if there are enough arrows.\\n            arrowsNeeded = aliceArrows[i] + 1\\n            if remaining >= arrowsNeeded:\\n                arrows[i] = arrowsNeeded\\n                calc(i - 1, remaining - arrowsNeeded, score + i, arrows)\\n                arrows[i] = 0\\n\\n            # Skip this section and go to the next section.\\n            calc(i - 1, remaining, score, arrows)\\n        \\n\\t\\t# Kick off the recursion\\n        calc(len(aliceArrows) - 1, numArrows, 0, [0 for _ in aliceArrows])\\n        return max_score[1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        max_score = [0, None]\\n        def calc(i, remaining, score, arrows):\\n\\t\\t    # Base case. Update max score.\\n            if remaining == 0 or i == -1:\\n                if score > max_score[0]:\\n                    max_score[0] = score\\n                    max_score[1] = arrows[:]\\n                return\\n\\n\\t\\t\\t# Special handling for the last section. Use up all the arrows.\\n            if i == 0:\\n                arrows[i] = remaining\\n                calc(i - 1, 0, score + i, arrows)\\n                arrows[i] = 0\\n                return\\n\\n\\t\\t    # Try to compete with Alice if there are enough arrows.\\n            arrowsNeeded = aliceArrows[i] + 1\\n            if remaining >= arrowsNeeded:\\n                arrows[i] = arrowsNeeded\\n                calc(i - 1, remaining - arrowsNeeded, score + i, arrows)\\n                arrows[i] = 0\\n\\n            # Skip this section and go to the next section.\\n            calc(i - 1, remaining, score, arrows)\\n        \\n\\t\\t# Kick off the recursion\\n        calc(len(aliceArrows) - 1, numArrows, 0, [0 for _ in aliceArrows])\\n        return max_score[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865580,
                "title": "python-recursion-without-dp",
                "content": "the list is too small, just brute force with recursion\\n```\\ndef maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n    def get_max(i, numArrows):\\n        if i == len(aliceArrows):\\n            return 0, [0] * len(aliceArrows)\\n        else:\\n            alicearrow = aliceArrows[i]\\n            c1, res1 = get_max(i+1, numArrows)\\n            c2 = -1\\n            if numArrows-alicearrow-1 >= 0:\\n                c2, res2 = get_max(i+1, numArrows-alicearrow-1)\\n                c2 += i\\n                res2[i] = alicearrow + 1\\n            if c1 > c2:\\n                return c1, res1\\n            else:\\n                return c2, res2\\n    res = get_max(0,numArrows)[1]\\n    s = sum(res)\\n    if s < numArrows:\\n        res[0] += numArrows - s\\n    return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n    def get_max(i, numArrows):\\n        if i == len(aliceArrows):\\n            return 0, [0] * len(aliceArrows)\\n        else:\\n            alicearrow = aliceArrows[i]\\n            c1, res1 = get_max(i+1, numArrows)\\n            c2 = -1\\n            if numArrows-alicearrow-1 >= 0:\\n                c2, res2 = get_max(i+1, numArrows-alicearrow-1)\\n                c2 += i\\n                res2[i] = alicearrow + 1\\n            if c1 > c2:\\n                return c1, res1\\n            else:\\n                return c2, res2\\n    res = get_max(0,numArrows)[1]\\n    s = sum(res)\\n    if s < numArrows:\\n        res[0] += numArrows - s\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3945256,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n    constexpr int allMask = (1 << 12) - 1;\\n    int maxPoint = 0;\\n    int maxMask = 0;\\n\\n    for (int mask = 0; mask < allMask; ++mask) {\\n      const auto& [shotable, point] =\\n          getShotableAndPoint(mask, numArrows, aliceArrows);\\n      if (shotable && point > maxPoint) {\\n        maxPoint = point;\\n        maxMask = mask;\\n      }\\n    }\\n\\n    return getBobsArrows(maxMask, numArrows, aliceArrows);\\n  }\\n\\n private:\\n  pair<bool, int> getShotableAndPoint(int mask, int leftArrows,\\n                                      const vector<int>& aliceArrows) {\\n    int point = 0;\\n    for (int i = 0; i < 12; ++i)\\n      if (mask >> i & 1) {\\n        leftArrows -= aliceArrows[i] + 1;\\n        point += i;\\n      }\\n    return {leftArrows >= 0, point};\\n  }\\n\\n  vector<int> getBobsArrows(int mask, int leftArrows,\\n                            const vector<int>& aliceArrows) {\\n    vector<int> bobsArrows(12);\\n    for (int i = 0; i < 12; ++i)\\n      if (mask >> i & 1) {\\n        bobsArrows[i] = aliceArrows[i] + 1;\\n        leftArrows -= aliceArrows[i] + 1;\\n      }\\n    bobsArrows[0] = leftArrows;\\n    return bobsArrows;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n    constexpr int allMask = (1 << 12) - 1;\\n    int maxPoint = 0;\\n    int maxMask = 0;\\n\\n    for (int mask = 0; mask < allMask; ++mask) {\\n      const auto& [shotable, point] =\\n          getShotableAndPoint(mask, numArrows, aliceArrows);\\n      if (shotable && point > maxPoint) {\\n        maxPoint = point;\\n        maxMask = mask;\\n      }\\n    }\\n\\n    return getBobsArrows(maxMask, numArrows, aliceArrows);\\n  }\\n\\n private:\\n  pair<bool, int> getShotableAndPoint(int mask, int leftArrows,\\n                                      const vector<int>& aliceArrows) {\\n    int point = 0;\\n    for (int i = 0; i < 12; ++i)\\n      if (mask >> i & 1) {\\n        leftArrows -= aliceArrows[i] + 1;\\n        point += i;\\n      }\\n    return {leftArrows >= 0, point};\\n  }\\n\\n  vector<int> getBobsArrows(int mask, int leftArrows,\\n                            const vector<int>& aliceArrows) {\\n    vector<int> bobsArrows(12);\\n    for (int i = 0; i < 12; ++i)\\n      if (mask >> i & 1) {\\n        bobsArrows[i] = aliceArrows[i] + 1;\\n        leftArrows -= aliceArrows[i] + 1;\\n      }\\n    bobsArrows[0] = leftArrows;\\n    return bobsArrows;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894651,
                "title": "golang-backtracking",
                "content": "# Code\\n```\\nfunc maximumBobPoints(numArrows int, aliceArrows []int) []int {\\n  var bobArrows []int\\n  currPoints := make([]int, 12)\\n  backtrack(numArrows, aliceArrows, 0, currPoints, &bobArrows)\\n  return bobArrows\\n}\\n\\nfunc backtrack(numArrows int, aliceArrows []int, pos int, currPoints []int, bobArrows *[]int) {\\n  if pos == 12 {\\n    if calcPoints(aliceArrows, currPoints) > calcPoints(aliceArrows, *bobArrows) {\\n      points := make([]int, len(currPoints))\\n      copy(points, currPoints)\\n      if numArrows > 0 {\\n        // Put the remaining arrows in 0\\n        points[0] += numArrows\\n      }\\n      *bobArrows = points\\n\\n    }\\n    return\\n  }\\n  backtrack(numArrows, aliceArrows, pos+1, currPoints, bobArrows)\\n  if numArrows >= aliceArrows[pos] + 1 {\\n    currPoints[pos] = aliceArrows[pos] + 1\\n    backtrack(numArrows - aliceArrows[pos] - 1, aliceArrows, pos+1, currPoints, bobArrows)\\n    currPoints[pos] = 0\\n  }\\n}\\n\\nfunc calcPoints(alice, bob []int) int {\\n  var res int\\n  for i := 0; i < len(bob); i++ {\\n    if bob[i] > alice[i] {\\n      res += i\\n    }\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nfunc maximumBobPoints(numArrows int, aliceArrows []int) []int {\\n  var bobArrows []int\\n  currPoints := make([]int, 12)\\n  backtrack(numArrows, aliceArrows, 0, currPoints, &bobArrows)\\n  return bobArrows\\n}\\n\\nfunc backtrack(numArrows int, aliceArrows []int, pos int, currPoints []int, bobArrows *[]int) {\\n  if pos == 12 {\\n    if calcPoints(aliceArrows, currPoints) > calcPoints(aliceArrows, *bobArrows) {\\n      points := make([]int, len(currPoints))\\n      copy(points, currPoints)\\n      if numArrows > 0 {\\n        // Put the remaining arrows in 0\\n        points[0] += numArrows\\n      }\\n      *bobArrows = points\\n\\n    }\\n    return\\n  }\\n  backtrack(numArrows, aliceArrows, pos+1, currPoints, bobArrows)\\n  if numArrows >= aliceArrows[pos] + 1 {\\n    currPoints[pos] = aliceArrows[pos] + 1\\n    backtrack(numArrows - aliceArrows[pos] - 1, aliceArrows, pos+1, currPoints, bobArrows)\\n    currPoints[pos] = 0\\n  }\\n}\\n\\nfunc calcPoints(alice, bob []int) int {\\n  var res int\\n  for i := 0; i < len(bob); i++ {\\n    if bob[i] > alice[i] {\\n      res += i\\n    }\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3824892,
                "title": "top-down-dp-memoization-prefix-sum-optimization-3ms-beats-98-72-in-runtime",
                "content": "# Code\\n```\\nclass Solution {\\n  private List < Integer > getOptimalDistribution(\\n    int[] aliceArrows,\\n    int tillIndex,\\n    int numArrows,\\n    int[] pref,\\n    Map < Integer, Map < Integer, List < Integer >>> dp\\n  ) {\\n    if (dp.get(tillIndex).containsKey(numArrows)) {\\n      return dp.get(tillIndex).get(numArrows);\\n    }\\n\\n    List < Integer > res = new ArrayList < > ();\\n    if (tillIndex == 0) {\\n      res.add(0);\\n      res.add(numArrows >= aliceArrows[tillIndex] + 1 ? 1 : 0);\\n      dp.get(tillIndex).put(numArrows, res);\\n      return res;\\n    }\\n\\n    if (numArrows == 0) {\\n      res.add(0);\\n      res.add(0);\\n      dp.get(tillIndex).put(numArrows, res);\\n      return res;\\n    }\\n\\n    if (numArrows >= pref[tillIndex] + tillIndex) {\\n      int score = (tillIndex * (tillIndex + 1)) / 2;\\n      int mask = 0;\\n      int cnt = numArrows;\\n      for (int k = tillIndex; k >= 0; k--) {\\n        mask |= cnt >= aliceArrows[k] + 1 ? (1 << k) : 0;\\n        cnt -= aliceArrows[k] + 1;\\n      }\\n      res.add(score);\\n      res.add(mask);\\n      dp.get(tillIndex).put(numArrows, res);\\n      return res;\\n    }\\n\\n    List < Integer > resI = null, resE = null;\\n    if (numArrows >= aliceArrows[tillIndex] + 1) {\\n      resI = this.getOptimalDistribution(\\n        aliceArrows,\\n        tillIndex - 1,\\n        numArrows - aliceArrows[tillIndex] - 1,\\n        pref,\\n        dp\\n      );\\n    }\\n\\n    resE = this.getOptimalDistribution(\\n      aliceArrows,\\n      tillIndex - 1,\\n      numArrows,\\n      pref,\\n      dp\\n    );\\n\\n    if (resI != null &&\\n      resI.get(0) + tillIndex >= resE.get(0)\\n    ) {\\n      res.add(tillIndex + resI.get(0));\\n      res.add((1 << tillIndex) | resI.get(1));\\n      dp.get(tillIndex).put(numArrows, res);\\n      return res;\\n    }\\n\\n    res.add(resE.get(0));\\n    res.add(resE.get(1));\\n    dp.get(tillIndex).put(numArrows, res);\\n\\n    return res;\\n  }\\n\\n  public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n    int[] pref = new int[12];\\n    int[] result = new int[12];\\n    Map < Integer, Map < Integer, List < Integer >>> cache = new HashMap < > ();\\n\\n    for (int i = 0; i < 12; i++) {\\n      if (numArrows == 1 && aliceArrows[12 - i - 1] == 0) {\\n        result[12 - i - 1] = 1;\\n        return result;\\n      }\\n\\n      cache.put(i, new HashMap < Integer, List < Integer >> ());\\n      if (i == 0) {\\n        pref[i] = aliceArrows[i];\\n        continue;\\n      }\\n\\n      pref[i] = aliceArrows[i] + pref[i - 1];\\n    }\\n\\n    List < Integer > optDist = this.getOptimalDistribution(\\n      aliceArrows,\\n      aliceArrows.length - 1,\\n      numArrows,\\n      pref,\\n      cache\\n    );\\n\\n    int cnt = numArrows;\\n    int lastSetBit = -1;\\n    for (int i = 0; i < 12; i++) {\\n      if ((optDist.get(1) & (1 << i)) != 0) {\\n        lastSetBit = i;\\n        result[i] = aliceArrows[i] + 1;\\n        cnt -= result[i];\\n      }\\n    }\\n\\n    if(cnt > 0) {\\n      result[lastSetBit] += cnt;\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n  private List < Integer > getOptimalDistribution(\\n    int[] aliceArrows,\\n    int tillIndex,\\n    int numArrows,\\n    int[] pref,\\n    Map < Integer, Map < Integer, List < Integer >>> dp\\n  ) {\\n    if (dp.get(tillIndex).containsKey(numArrows)) {\\n      return dp.get(tillIndex).get(numArrows);\\n    }\\n\\n    List < Integer > res = new ArrayList < > ();\\n    if (tillIndex == 0) {\\n      res.add(0);\\n      res.add(numArrows >= aliceArrows[tillIndex] + 1 ? 1 : 0);\\n      dp.get(tillIndex).put(numArrows, res);\\n      return res;\\n    }\\n\\n    if (numArrows == 0) {\\n      res.add(0);\\n      res.add(0);\\n      dp.get(tillIndex).put(numArrows, res);\\n      return res;\\n    }\\n\\n    if (numArrows >= pref[tillIndex] + tillIndex) {\\n      int score = (tillIndex * (tillIndex + 1)) / 2;\\n      int mask = 0;\\n      int cnt = numArrows;\\n      for (int k = tillIndex; k >= 0; k--) {\\n        mask |= cnt >= aliceArrows[k] + 1 ? (1 << k) : 0;\\n        cnt -= aliceArrows[k] + 1;\\n      }\\n      res.add(score);\\n      res.add(mask);\\n      dp.get(tillIndex).put(numArrows, res);\\n      return res;\\n    }\\n\\n    List < Integer > resI = null, resE = null;\\n    if (numArrows >= aliceArrows[tillIndex] + 1) {\\n      resI = this.getOptimalDistribution(\\n        aliceArrows,\\n        tillIndex - 1,\\n        numArrows - aliceArrows[tillIndex] - 1,\\n        pref,\\n        dp\\n      );\\n    }\\n\\n    resE = this.getOptimalDistribution(\\n      aliceArrows,\\n      tillIndex - 1,\\n      numArrows,\\n      pref,\\n      dp\\n    );\\n\\n    if (resI != null &&\\n      resI.get(0) + tillIndex >= resE.get(0)\\n    ) {\\n      res.add(tillIndex + resI.get(0));\\n      res.add((1 << tillIndex) | resI.get(1));\\n      dp.get(tillIndex).put(numArrows, res);\\n      return res;\\n    }\\n\\n    res.add(resE.get(0));\\n    res.add(resE.get(1));\\n    dp.get(tillIndex).put(numArrows, res);\\n\\n    return res;\\n  }\\n\\n  public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n    int[] pref = new int[12];\\n    int[] result = new int[12];\\n    Map < Integer, Map < Integer, List < Integer >>> cache = new HashMap < > ();\\n\\n    for (int i = 0; i < 12; i++) {\\n      if (numArrows == 1 && aliceArrows[12 - i - 1] == 0) {\\n        result[12 - i - 1] = 1;\\n        return result;\\n      }\\n\\n      cache.put(i, new HashMap < Integer, List < Integer >> ());\\n      if (i == 0) {\\n        pref[i] = aliceArrows[i];\\n        continue;\\n      }\\n\\n      pref[i] = aliceArrows[i] + pref[i - 1];\\n    }\\n\\n    List < Integer > optDist = this.getOptimalDistribution(\\n      aliceArrows,\\n      aliceArrows.length - 1,\\n      numArrows,\\n      pref,\\n      cache\\n    );\\n\\n    int cnt = numArrows;\\n    int lastSetBit = -1;\\n    for (int i = 0; i < 12; i++) {\\n      if ((optDist.get(1) & (1 << i)) != 0) {\\n        lastSetBit = i;\\n        result[i] = aliceArrows[i] + 1;\\n        cnt -= result[i];\\n      }\\n    }\\n\\n    if(cnt > 0) {\\n      result[lastSetBit] += cnt;\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812827,
                "title": "bitmask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\u2022 `aliceArrows.length == bobArrows.length == 12` \\u2192 mask\\n\\nwin or lose in a sequence of games \\u2192 mask \\u2192 calculate the number needed\\n\\nnumArrows \\u2192 calculate the number and use this to judge possibility\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int mx = INT_MIN;\\n        vector<int> res;\\n        for(int mask = 0; mask < 1 << 12; mask++)\\n        {\\n            vector<int> tmp(12, 0);\\n            int total = 0;\\n            int needArrows = 0;\\n            for(int i = 0; i < 12; i++)\\n            {\\n                if(mask & (1 << i))\\n                {\\n                    tmp[i] = aliceArrows[i] + 1;\\n                    total += i;\\n                    needArrows += tmp[i];\\n                }\\n                if(needArrows > numArrows) break;\\n            }\\n            if(needArrows > numArrows) continue;\\n\\n            if(total > mx)\\n            {\\n                mx = total;\\n                res = tmp;\\n                res[0] += numArrows - needArrows;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int mx = INT_MIN;\\n        vector<int> res;\\n        for(int mask = 0; mask < 1 << 12; mask++)\\n        {\\n            vector<int> tmp(12, 0);\\n            int total = 0;\\n            int needArrows = 0;\\n            for(int i = 0; i < 12; i++)\\n            {\\n                if(mask & (1 << i))\\n                {\\n                    tmp[i] = aliceArrows[i] + 1;\\n                    total += i;\\n                    needArrows += tmp[i];\\n                }\\n                if(needArrows > numArrows) break;\\n            }\\n            if(needArrows > numArrows) continue;\\n\\n            if(total > mx)\\n            {\\n                mx = total;\\n                res = tmp;\\n                res[0] += numArrows - needArrows;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811479,
                "title": "bitmask-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> res(12);\\n        int mxPoints =0;\\n        for(int i=1; i<(1<<12); i++){\\n            vector<int> temp(12);\\n            int currArrows = 0;\\n            int currPoints = 0;\\n            for(int j=0; j<12; j++){\\n               if(i&(1<<j)){\\n                   currArrows += aliceArrows[j] + 1;\\n                   if(currArrows > numArrows) break;\\n                   temp[j] = aliceArrows[j] + 1;\\n                   currPoints += j;\\n               }\\n            }\\n            if(currArrows > numArrows) continue;\\n            if(currPoints > mxPoints){\\n               mxPoints = currPoints;\\n               temp[0] += numArrows - currArrows;\\n               res = temp;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> res(12);\\n        int mxPoints =0;\\n        for(int i=1; i<(1<<12); i++){\\n            vector<int> temp(12);\\n            int currArrows = 0;\\n            int currPoints = 0;\\n            for(int j=0; j<12; j++){\\n               if(i&(1<<j)){\\n                   currArrows += aliceArrows[j] + 1;\\n                   if(currArrows > numArrows) break;\\n                   temp[j] = aliceArrows[j] + 1;\\n                   currPoints += j;\\n               }\\n            }\\n            if(currArrows > numArrows) continue;\\n            if(currPoints > mxPoints){\\n               mxPoints = currPoints;\\n               temp[0] += numArrows - currArrows;\\n               res = temp;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777699,
                "title": "knapsack-dp-easy-to-understand",
                "content": "# Intuition\\n\\nThis is similar to https://leetcode.com/problems/smallest-sufficient-team/ in a sense that we first derive the max score and then see which of the rounds led us there.\\n\\nMy solution explanation for the above HARD problem - https://leetcode.com/problems/smallest-sufficient-team/solutions/3772768/simple-knapsack-intuitive-recursive-bitmask-dp/\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long calc(int n, vector<int>& a, vector<int> &b, int i, vector<vector<int>> &dp) {\\n        if(n < 0) return INT_MIN;\\n        if(n == 0) return 0;\\n        if(dp[n][i] != -1) return dp[n][i];\\n        if(i == 0) {\\n            return 0;\\n        }\\n        long ans = 0;\\n        if(n > a[i]) {\\n            return dp[n][i] = max(calc(n-a[i]-1, a, b, i-1, dp)+i, calc(n, a, b, i-1, dp));\\n        } else {\\n            return dp[n][i] = calc(n, a, b, i-1, dp);\\n        }\\n\\n        return ans;\\n    }\\n    vector<int> maximumBobPoints(int n, vector<int>& a) {\\n        vector<int> b(12, 0);\\n        vector<vector<int>> dp(n+1, vector<int>(a.size(), -1));\\n        \\n        calc(n, a, b, 11, dp);\\n\\n        for(int i=11;i>0;i--) {\\n            if(dp[n][i] == dp[n][i-1]) continue;\\n            else {\\n                if(n > a[i]) {\\n                    b[i] = a[i]+1;\\n                    n -= a[i]+1;\\n                }\\n            }\\n        }\\n\\n        if(n) b[0] = n;\\n        \\n        return b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long calc(int n, vector<int>& a, vector<int> &b, int i, vector<vector<int>> &dp) {\\n        if(n < 0) return INT_MIN;\\n        if(n == 0) return 0;\\n        if(dp[n][i] != -1) return dp[n][i];\\n        if(i == 0) {\\n            return 0;\\n        }\\n        long ans = 0;\\n        if(n > a[i]) {\\n            return dp[n][i] = max(calc(n-a[i]-1, a, b, i-1, dp)+i, calc(n, a, b, i-1, dp));\\n        } else {\\n            return dp[n][i] = calc(n, a, b, i-1, dp);\\n        }\\n\\n        return ans;\\n    }\\n    vector<int> maximumBobPoints(int n, vector<int>& a) {\\n        vector<int> b(12, 0);\\n        vector<vector<int>> dp(n+1, vector<int>(a.size(), -1));\\n        \\n        calc(n, a, b, 11, dp);\\n\\n        for(int i=11;i>0;i--) {\\n            if(dp[n][i] == dp[n][i-1]) continue;\\n            else {\\n                if(n > a[i]) {\\n                    b[i] = a[i]+1;\\n                    n -= a[i]+1;\\n                }\\n            }\\n        }\\n\\n        if(n) b[0] = n;\\n        \\n        return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703826,
                "title": "recursion-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int pointForBob = 0;\\n    private int [] bobArrows = new int [12];\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int length = aliceArrows.length;\\n        int [] bob = new int [length];\\n        backtrack(aliceArrows, bob, 11, 0, numArrows); // we start from back\\n        return bobArrows;\\n    }\\n    \\n    public void backtrack(int [] alice, int [] bob, int pos, int currentMax, int arrows) {\\n        if (pos < 0 || arrows <= 0) {\\n            if (arrows > 0) {\\n                bob[0] += arrows;\\n            }\\n            if (currentMax > pointForBob) {\\n                pointForBob = currentMax;\\n                bobArrows = bob.clone();\\n            }\\n            return;\\n        }\\n        \\n        if (arrows >= alice[pos] + 1) {\\n            bob[pos] = alice[pos] + 1;\\n            backtrack(alice, bob, pos - 1, currentMax + pos, arrows - alice[pos] - 1);\\n            bob[pos] = 0;\\n        }\\n        backtrack(alice, bob, pos - 1, currentMax, arrows);\\n        bob[pos] = 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int pointForBob = 0;\\n    private int [] bobArrows = new int [12];\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int length = aliceArrows.length;\\n        int [] bob = new int [length];\\n        backtrack(aliceArrows, bob, 11, 0, numArrows); // we start from back\\n        return bobArrows;\\n    }\\n    \\n    public void backtrack(int [] alice, int [] bob, int pos, int currentMax, int arrows) {\\n        if (pos < 0 || arrows <= 0) {\\n            if (arrows > 0) {\\n                bob[0] += arrows;\\n            }\\n            if (currentMax > pointForBob) {\\n                pointForBob = currentMax;\\n                bobArrows = bob.clone();\\n            }\\n            return;\\n        }\\n        \\n        if (arrows >= alice[pos] + 1) {\\n            bob[pos] = alice[pos] + 1;\\n            backtrack(alice, bob, pos - 1, currentMax + pos, arrows - alice[pos] - 1);\\n            bob[pos] = 0;\\n        }\\n        backtrack(alice, bob, pos - 1, currentMax, arrows);\\n        bob[pos] = 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642175,
                "title": "c-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe optimal strategy for Bob is either skip target at all (let it be `0`) or short 1 arrow more (let it be `1`) than Alice has shot. So Bob has $$2^{13}$$ possible strategies:\\n\\n```\\n000000000000 - skip all targets\\n000000000001 - skip all the targets, overshoot Alice on the last target\\n000000000010 - skip all the targets, overshoot Alice on the n - 1 target \\n...\\n111111111111 - overshoot Alice on all targets\\n``` \\n\\nsince we have $$2^{13} = 8192$$ strategies only, we can easily check them (if they are possible) and find the best one.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute force using bitmask.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(k * 2^k)$$, where $$k$$ is number or targtes, here $$12$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(k)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] MaximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int[] result = new int[12];\\n   \\n        int bestMask = 0;\\n\\n        for (int mask = 0, bestScore = 0; mask < 1 << result.Length; ++mask) {\\n            int arrowsSpent = 0; \\n            int score = 0;\\n\\n            for (int index = 0; index < result.Length; ++index) \\n                if (((1 << index) & mask) != 0) {\\n                    score += index;\\n                    arrowsSpent += aliceArrows[index] + 1;\\n                }\\n\\n            if (arrowsSpent <= numArrows && score > bestScore)\\n                (bestScore, bestMask) = (score, mask);\\n        }   \\n\\n        for (int i = 0; i < result.Length; ++i) \\n            if (((1 << i) & bestMask) != 0) \\n                result[i] = aliceArrows[i] + 1;\\n\\n        result[0] = numArrows - result.Sum();\\n\\n        return result; \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n000000000000 - skip all targets\\n000000000001 - skip all the targets, overshoot Alice on the last target\\n000000000010 - skip all the targets, overshoot Alice on the n - 1 target \\n...\\n111111111111 - overshoot Alice on all targets\\n```\n```\\npublic class Solution {\\n    public int[] MaximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int[] result = new int[12];\\n   \\n        int bestMask = 0;\\n\\n        for (int mask = 0, bestScore = 0; mask < 1 << result.Length; ++mask) {\\n            int arrowsSpent = 0; \\n            int score = 0;\\n\\n            for (int index = 0; index < result.Length; ++index) \\n                if (((1 << index) & mask) != 0) {\\n                    score += index;\\n                    arrowsSpent += aliceArrows[index] + 1;\\n                }\\n\\n            if (arrowsSpent <= numArrows && score > bestScore)\\n                (bestScore, bestMask) = (score, mask);\\n        }   \\n\\n        for (int i = 0; i < result.Length; ++i) \\n            if (((1 << i) & bestMask) != 0) \\n                result[i] = aliceArrows[i] + 1;\\n\\n        result[0] = numArrows - result.Sum();\\n\\n        return result; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557956,
                "title": "simple-pick-not-pick-recursion-explained-python",
                "content": "# Intuition\\nIts a simple pick not pick question where bob can pick either to battle in the score field or not let alice win and try another battle field.\\n\\nNow what are the requirements in question :-\\n`1. Bob have to maximize his score`\\n`2. must use all arrows (arrows by bob sum == numArrows)`\\n`3. To win from alice he needs atleast aliceArrows + 1`\\n\\nNow follow the recursion code here if we choose not to pick any battle field we add 0 to path(as none arrow were used by Bob)\\nbut if he competes to win he will use AliceArrows + 1\\nsubtract it from total arrows and add it to path arrows\\n\\n**What\\'s different here from normal recursion code?** \\nIt says he must use all his arrows so, whenever we see bob hasnt used all the arrows we will just add the remaining arrows to any element ( here i chose 0th index) because they are just extra arrows and bob has already maximized his score.\\n\\nStore maxScore path in res array and that should be your ans!!\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        maxScore = 0\\n        res = [0] * len(aliceArrows)\\n    \\n        def recur(i, numArrows, score, path):\\n            nonlocal maxScore, res\\n            if i >= len(aliceArrows):\\n                if score > maxScore:\\n                    if numArrows > 0:\\n                        path[0] += numArrows\\n                    res = path\\n                    maxScore = score\\n                return score\\n            \\n            notPick = recur(i+1, numArrows, score, path + [0])\\n            pick = 0\\n            if numArrows - (aliceArrows[i] + 1) >= 0:\\n                pick = recur(i+1, numArrows - (aliceArrows[i] + 1), score + i, path + [aliceArrows[i] + 1])\\n            \\n            return max(pick, notPick)\\n        recur(0, numArrows, 0, [])\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        maxScore = 0\\n        res = [0] * len(aliceArrows)\\n    \\n        def recur(i, numArrows, score, path):\\n            nonlocal maxScore, res\\n            if i >= len(aliceArrows):\\n                if score > maxScore:\\n                    if numArrows > 0:\\n                        path[0] += numArrows\\n                    res = path\\n                    maxScore = score\\n                return score\\n            \\n            notPick = recur(i+1, numArrows, score, path + [0])\\n            pick = 0\\n            if numArrows - (aliceArrows[i] + 1) >= 0:\\n                pick = recur(i+1, numArrows - (aliceArrows[i] + 1), score + i, path + [aliceArrows[i] + 1])\\n            \\n            return max(pick, notPick)\\n        recur(0, numArrows, 0, [])\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541270,
                "title": "c-100-tc-100-sc-knapsack-using-minimum-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEither to dominates a certain point or not dominate\\n\\n# Complexity\\n- Time complexity:  O(2^11)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0,maxi=0;\\n    void help(int n,vector<int>&aliceA,int a,int i,int points){\\n        if(!n || i<0){\\n            if(points>maxi){\\n                maxi=points; \\n                ans=a;\\n            //update maximum points and save this configuration\\n            }\\n            return;\\n        }\\n        help(n,aliceA,a,i-1,points);   //not dominate\\n        if(n>aliceA[i]){\\n            a=a|(1<<i);\\n            help(n-aliceA[i]-1,aliceA,a,i-1,points+i); //dominates\\n        }\\n        return ;\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        help(numArrows,aliceArrows,0,11,0);\\n        vector<int> bob(12,0);\\n        int count=0;\\n\\n        //now we have ans integer that contains set bit on which points to dominate\\n        for(int i=0;i<12;i++){\\n            if(ans&(1<<i)){\\n                bob[i]=aliceArrows[i]+1;\\n//bob need only one more arrow than alice to dominate\\n                count+=bob[i];  //count the arrows used\\n            }\\n        }\\n        if(count<numArrows) bob[11]+=numArrows-count;   \\n        //add remaining arrows somewhere , as it doesn\\'t matter\\n        return bob;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0,maxi=0;\\n    void help(int n,vector<int>&aliceA,int a,int i,int points){\\n        if(!n || i<0){\\n            if(points>maxi){\\n                maxi=points; \\n                ans=a;\\n            //update maximum points and save this configuration\\n            }\\n            return;\\n        }\\n        help(n,aliceA,a,i-1,points);   //not dominate\\n        if(n>aliceA[i]){\\n            a=a|(1<<i);\\n            help(n-aliceA[i]-1,aliceA,a,i-1,points+i); //dominates\\n        }\\n        return ;\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        help(numArrows,aliceArrows,0,11,0);\\n        vector<int> bob(12,0);\\n        int count=0;\\n\\n        //now we have ans integer that contains set bit on which points to dominate\\n        for(int i=0;i<12;i++){\\n            if(ans&(1<<i)){\\n                bob[i]=aliceArrows[i]+1;\\n//bob need only one more arrow than alice to dominate\\n                count+=bob[i];  //count the arrows used\\n            }\\n        }\\n        if(count<numArrows) bob[11]+=numArrows-count;   \\n        //add remaining arrows somewhere , as it doesn\\'t matter\\n        return bob;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448243,
                "title": "python3-recursive-approach",
                "content": "# Intuition\\n1. In order to get score from section ``i`` Bob should use ``aliceArrows[i] + 1`` arrows, because the number of arrows should be more than ``aliceArrows[i]`` and it doesn\\'t make sense to use more than ``aliceArrows[i] + 1`` arrows.\\n2. We should make as much score as we can from the higher-score sections\\n3. All unused arrows (that are not necessary to beat Alice\\'s arrows) must go into section ``0``\\n\\n# Approach\\n1. Use recursive approach, starting from section ``11`` and check how many points we can get from either beating Alice\\'s arrows or not using any errors in this section\\n2. Go to the previos section in the same way\\n3. Keeping track of the score earned, arrows available and mask for each section - use arrows or not use arrows\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^k)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n\\n        def impl(i0, arrows):\\n            if i0 == -1:\\n                return 0, 0\\n            mask1 = 0\\n            shot = -1\\n            if arrows - aliceArrows[i0] - 1 >= 0:\\n                mask1, shot = impl(i0-1, arrows - aliceArrows[i0] - 1)\\n                shot += i0\\n                mask1 |= (1 << i0)\\n            mask0, no_shot = impl(i0-1, arrows)\\n            mask = mask1 if shot > no_shot else mask0\\n\\n            return mask, max(shot, no_shot)\\n\\n        mask, score = impl(11, numArrows)\\n        result = [0] * 12\\n        for i in range(12):\\n            if mask & (1 << i):\\n                result[i] = aliceArrows[i] + 1\\n\\n        result[0] = numArrows - sum(result[1:])\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n\\n        def impl(i0, arrows):\\n            if i0 == -1:\\n                return 0, 0\\n            mask1 = 0\\n            shot = -1\\n            if arrows - aliceArrows[i0] - 1 >= 0:\\n                mask1, shot = impl(i0-1, arrows - aliceArrows[i0] - 1)\\n                shot += i0\\n                mask1 |= (1 << i0)\\n            mask0, no_shot = impl(i0-1, arrows)\\n            mask = mask1 if shot > no_shot else mask0\\n\\n            return mask, max(shot, no_shot)\\n\\n        mask, score = impl(11, numArrows)\\n        result = [0] * 12\\n        for i in range(12):\\n            if mask & (1 << i):\\n                result[i] = aliceArrows[i] + 1\\n\\n        result[0] = numArrows - sum(result[1:])\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441367,
                "title": "i-hate-combinatorial-explosion-but",
                "content": "# Intuition\\nThe idea is to use an integer to determine if you do it or not. But considering the combinatorial explosion has too much combinations the result will appear close to solution, so you have to do it twice. \\n\\n# Approach\\nInitially is invested a solution difficult to find, and the rest is the most probable solution.\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^n)$$\\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        maxGot = 0\\n        score = [0] * 12\\n        prepared = numArrows\\n        for i in range(1, 12):\\n            if prepared > aliceArrows[i]:\\n                score[i] = aliceArrows[i] + 1\\n                prepared -= aliceArrows[i] + 1\\n                maxGot += i\\n        score[0] = prepared\\n        seed = -1\\n        candidate = [0]*12\\n        for K in range(2):\\n            result = 1\\n            while result > 0:\\n                seed += 1\\n                option = seed\\n                result = 0\\n                prepared = numArrows\\n                i = 11\\n                candidate = [0] * 12\\n                while i >= 5:\\n                    if prepared > aliceArrows[i]:\\n                        if option % 2 == 0:\\n                            candidate[i] = aliceArrows[i] + 1\\n                            prepared -= aliceArrows[i] + 1\\n                            result += i\\n                        option //= 2\\n                    i -= 1\\n                if result + 10 < maxGot:\\n                    candidate[0] = prepared\\n                    continue\\n                while i > 0:\\n                    if prepared > aliceArrows[i]:\\n                        if option % 2 == 0:\\n                            candidate[i] = aliceArrows[i] + 1\\n                            prepared -= aliceArrows[i] + 1\\n                            result += i\\n                        option //= 2\\n                    i -= 1\\n                candidate[0] = prepared\\n                if result > maxGot:\\n                    maxGot = result\\n                    score = candidate\\n            \\n        return score\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        maxGot = 0\\n        score = [0] * 12\\n        prepared = numArrows\\n        for i in range(1, 12):\\n            if prepared > aliceArrows[i]:\\n                score[i] = aliceArrows[i] + 1\\n                prepared -= aliceArrows[i] + 1\\n                maxGot += i\\n        score[0] = prepared\\n        seed = -1\\n        candidate = [0]*12\\n        for K in range(2):\\n            result = 1\\n            while result > 0:\\n                seed += 1\\n                option = seed\\n                result = 0\\n                prepared = numArrows\\n                i = 11\\n                candidate = [0] * 12\\n                while i >= 5:\\n                    if prepared > aliceArrows[i]:\\n                        if option % 2 == 0:\\n                            candidate[i] = aliceArrows[i] + 1\\n                            prepared -= aliceArrows[i] + 1\\n                            result += i\\n                        option //= 2\\n                    i -= 1\\n                if result + 10 < maxGot:\\n                    candidate[0] = prepared\\n                    continue\\n                while i > 0:\\n                    if prepared > aliceArrows[i]:\\n                        if option % 2 == 0:\\n                            candidate[i] = aliceArrows[i] + 1\\n                            prepared -= aliceArrows[i] + 1\\n                            result += i\\n                        option //= 2\\n                    i -= 1\\n                candidate[0] = prepared\\n                if result > maxGot:\\n                    maxGot = result\\n                    score = candidate\\n            \\n        return score\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398099,
                "title": "c-recursion-backtracking",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int maxSum;\\n    void solve(int idx,vector<int>& alice,int numA,vector<int>& ds,int cSum)\\n    {\\n        if(idx==-1)\\n        {\\n            if(cSum>maxSum)\\n            {\\n                maxSum = cSum;\\n                ans = ds;\\n                ans[0]+=numA;\\n            }\\n            return;\\n        }\\n        if(numA>=alice[idx]+1)\\n        {\\n            ds[idx] = alice[idx]+1;\\n            cSum+=idx;\\n            numA-=alice[idx]+1;\\n            solve(idx-1,alice,numA,ds,cSum);\\n            cSum-=idx;\\n            numA+=alice[idx]+1;\\n            ds[idx] = 0;\\n        }\\n        solve(idx-1,alice,numA,ds,cSum);\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        ans.clear();\\n        ans.resize(12,0);\\n        vector<int> ds(12);\\n        maxSum = 0;\\n        solve(11,aliceArrows,numArrows,ds,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int maxSum;\\n    void solve(int idx,vector<int>& alice,int numA,vector<int>& ds,int cSum)\\n    {\\n        if(idx==-1)\\n        {\\n            if(cSum>maxSum)\\n            {\\n                maxSum = cSum;\\n                ans = ds;\\n                ans[0]+=numA;\\n            }\\n            return;\\n        }\\n        if(numA>=alice[idx]+1)\\n        {\\n            ds[idx] = alice[idx]+1;\\n            cSum+=idx;\\n            numA-=alice[idx]+1;\\n            solve(idx-1,alice,numA,ds,cSum);\\n            cSum-=idx;\\n            numA+=alice[idx]+1;\\n            ds[idx] = 0;\\n        }\\n        solve(idx-1,alice,numA,ds,cSum);\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        ans.clear();\\n        ans.resize(12,0);\\n        vector<int> ds(12);\\n        maxSum = 0;\\n        solve(11,aliceArrows,numArrows,ds,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383362,
                "title": "javascript-backtracking",
                "content": "```\\nconst maximumBobPoints = (numArrows, aliceArrows) => {\\n  let res = new Array(12).fill(0);\\n  let max = 0;\\n\\n  const backtrack = (i, arrows, tot, bobArrows) => {\\n    if (arrows == 0 || i == 0) {\\n      if (tot > max) {\\n        bobArrows[0] = arrows; // leftover arrows\\n        max = tot;\\n        res = bobArrows;\\n      }\\n      return;\\n    }\\n\\n    // skip\\n    backtrack(i - 1, arrows, tot, [...bobArrows]);\\n\\n    // take\\n    let arrowsToBeatAlice = aliceArrows[i] + 1;\\n    if (arrowsToBeatAlice <= arrows) {\\n      bobArrows[i] = arrowsToBeatAlice;\\n      backtrack(i - 1, arrows - arrowsToBeatAlice, tot + i, bobArrows);\\n    }\\n  };\\n\\n  backtrack(11, numArrows, 0, new Array(12).fill(0));\\n\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maximumBobPoints = (numArrows, aliceArrows) => {\\n  let res = new Array(12).fill(0);\\n  let max = 0;\\n\\n  const backtrack = (i, arrows, tot, bobArrows) => {\\n    if (arrows == 0 || i == 0) {\\n      if (tot > max) {\\n        bobArrows[0] = arrows; // leftover arrows\\n        max = tot;\\n        res = bobArrows;\\n      }\\n      return;\\n    }\\n\\n    // skip\\n    backtrack(i - 1, arrows, tot, [...bobArrows]);\\n\\n    // take\\n    let arrowsToBeatAlice = aliceArrows[i] + 1;\\n    if (arrowsToBeatAlice <= arrows) {\\n      bobArrows[i] = arrowsToBeatAlice;\\n      backtrack(i - 1, arrows - arrowsToBeatAlice, tot + i, bobArrows);\\n    }\\n  };\\n\\n  backtrack(11, numArrows, 0, new Array(12).fill(0));\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3380578,
                "title": "easy-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int maxim=-1e9;\\nprivate:\\n    void fun(int idx, int sum,int arrow,int alicearrow,vector<int>&aliceArrows,vector<int>&arr,vector<int>&ans){\\n        \\n        if(idx<0){\\n            int x=0;\\n            for(auto it:arr){\\n                x+=it;\\n            }\\n            if(x<alicearrow){\\n               \\n                arr[0]+=(alicearrow-x);\\n\\n            }\\n            else if(x>alicearrow){\\n                arr[0]-=x-alicearrow;\\n            }\\n            if(sum>maxim){\\n                maxim=sum;\\n                ans=arr;\\n\\n            }\\n            return;\\n        }\\n        if(arrow>aliceArrows[idx]){\\n            arr[idx]=aliceArrows[idx]+1;\\n            fun(idx-1,sum+idx,arrow-(aliceArrows[idx]+1),alicearrow,aliceArrows,arr,ans);\\n            arr[idx]=0;\\n        }\\n        fun(idx-1,sum,arrow,alicearrow,aliceArrows,arr,ans);\\n    }\\n    \\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>arr(12,0);\\n        vector<int>ans;\\n        fun(11,0,numArrows,numArrows,aliceArrows,arr,ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int maxim=-1e9;\\nprivate:\\n    void fun(int idx, int sum,int arrow,int alicearrow,vector<int>&aliceArrows,vector<int>&arr,vector<int>&ans){\\n        \\n        if(idx<0){\\n            int x=0;\\n            for(auto it:arr){\\n                x+=it;\\n            }\\n            if(x<alicearrow){\\n               \\n                arr[0]+=(alicearrow-x);\\n\\n            }\\n            else if(x>alicearrow){\\n                arr[0]-=x-alicearrow;\\n            }\\n            if(sum>maxim){\\n                maxim=sum;\\n                ans=arr;\\n\\n            }\\n            return;\\n        }\\n        if(arrow>aliceArrows[idx]){\\n            arr[idx]=aliceArrows[idx]+1;\\n            fun(idx-1,sum+idx,arrow-(aliceArrows[idx]+1),alicearrow,aliceArrows,arr,ans);\\n            arr[idx]=0;\\n        }\\n        fun(idx-1,sum,arrow,alicearrow,aliceArrows,arr,ans);\\n    }\\n    \\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>arr(12,0);\\n        vector<int>ans;\\n        fun(11,0,numArrows,numArrows,aliceArrows,arr,ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352931,
                "title": "c-dfs-with-pruning",
                "content": "# Code\\n```\\nclass Solution {\\n    void dfs(int i, int numArrows, vector<int>& aliceArrows, vector<int> &ans, vector<int> &bobArrows, int score, int &maxScore) {\\n        if(i < 0 || numArrows < 0) return;\\n        if(score > maxScore) {\\n            maxScore = score;\\n            ans = bobArrows;\\n        }\\n        if(numArrows > aliceArrows[i]) {\\n            bobArrows[i] = aliceArrows[i] + 1;\\n            dfs(i - 1, numArrows - bobArrows[i], aliceArrows, ans, bobArrows, score + i, maxScore);\\n            bobArrows[i] = 0;\\n        }\\n        dfs(i - 1, numArrows, aliceArrows, ans, bobArrows, score, maxScore);\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> ans, bobArrows(12);\\n        int maxScore = INT_MIN;\\n        dfs(11, numArrows, aliceArrows, ans, bobArrows, 0, maxScore);\\n        ans[0] += numArrows - accumulate(ans.begin(), ans.end(), 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int i, int numArrows, vector<int>& aliceArrows, vector<int> &ans, vector<int> &bobArrows, int score, int &maxScore) {\\n        if(i < 0 || numArrows < 0) return;\\n        if(score > maxScore) {\\n            maxScore = score;\\n            ans = bobArrows;\\n        }\\n        if(numArrows > aliceArrows[i]) {\\n            bobArrows[i] = aliceArrows[i] + 1;\\n            dfs(i - 1, numArrows - bobArrows[i], aliceArrows, ans, bobArrows, score + i, maxScore);\\n            bobArrows[i] = 0;\\n        }\\n        dfs(i - 1, numArrows, aliceArrows, ans, bobArrows, score, maxScore);\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> ans, bobArrows(12);\\n        int maxScore = INT_MIN;\\n        dfs(11, numArrows, aliceArrows, ans, bobArrows, 0, maxScore);\\n        ans[0] += numArrows - accumulate(ans.begin(), ans.end(), 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352085,
                "title": "swift-solution-with-explanations",
                "content": "# Approach\\n1. First, we declare a few variables. The first two are self-explanatory, the third is a store for the current best result. The fourth is a copy of the store for the current result.\\n2. We create a helper function. The first three parameters are self-explanatory. The fourth is the array of arrow counts, the fifth is the store for the current result.\\n3. We check if we are either out of arrows or out of targets. If so, we check if the score of the current result is better than the best score. If so, we update the best score and best store accordingly.\\n4. Otherwise, we check how many arrows we have left. If we have enough to reach the next target, we add the next target to the store and call the helper function again with the new parameters. We do this by creating a copy of the store and adding the next target to it.\\n5. We also call the helper function again without adding the next target to the store.\\n6. Finally, we return the best store. \\n\\n# Complexity\\n- Time complexity: O(2^n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution\\n{\\n    var maxScore = 0\\n    var maxStore: [Int]?\\n    \\n    func maximumBobPoints(_ numArrows: Int, _ aliceArrows: [Int]) -> [Int]\\n    {\\n        helper(numArrows, 0, 0, aliceArrows, Array(repeating: 0, count: 12))\\n        return maxStore!\\n    }\\n    \\n    func helper(_ numArrows: Int, _ i: Int, _ score: Int, _ arr: [Int], _ store: [Int])\\n    {\\n        if i == 12 || numArrows == 0\\n        {\\n            if score > maxScore\\n            {\\n                maxScore = score\\n                maxStore = store\\n                maxStore![0] += numArrows\\n            }\\n            return\\n        }\\n        \\n        let val = arr[i]\\n        if numArrows - (val + 1) >= 0\\n        {\\n            var store = store\\n            store[i] = val + 1\\n            helper(numArrows - (val + 1), i + 1, score + i, arr, store)\\n        }\\n        helper(numArrows, i + 1, score, arr, store)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution\\n{\\n    var maxScore = 0\\n    var maxStore: [Int]?\\n    \\n    func maximumBobPoints(_ numArrows: Int, _ aliceArrows: [Int]) -> [Int]\\n    {\\n        helper(numArrows, 0, 0, aliceArrows, Array(repeating: 0, count: 12))\\n        return maxStore!\\n    }\\n    \\n    func helper(_ numArrows: Int, _ i: Int, _ score: Int, _ arr: [Int], _ store: [Int])\\n    {\\n        if i == 12 || numArrows == 0\\n        {\\n            if score > maxScore\\n            {\\n                maxScore = score\\n                maxStore = store\\n                maxStore![0] += numArrows\\n            }\\n            return\\n        }\\n        \\n        let val = arr[i]\\n        if numArrows - (val + 1) >= 0\\n        {\\n            var store = store\\n            store[i] = val + 1\\n            helper(numArrows - (val + 1), i + 1, score + i, arr, store)\\n        }\\n        helper(numArrows, i + 1, score, arr, store)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318964,
                "title": "maximum-points-in-an-archery-competition-c-explained-solution",
                "content": "**Do Upvote If Found Helpful !!!**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach to the problem is quite very simple. Since number of targets are limited to **0 to 11**, we can run a loop from **0 upto 2^12**, assuming them to be a bit mask. If a bit in bitmask is **on**, then it means that Bob shot more arrows else not. In case of **on** bit, just add **aliceArrows[j] + 1**, where j indicates jth bit and target board score. The above value is the minimum arrows required to be shot at a section to win points for that section. If the sum of these arrows is less than or equal to total arrows to be shot, then this is a possible answer. In such case just adjust all values and maximise score for Bob. Implementation goes below :\\n\\n# Complexity\\n- Time complexity: **O(1)** , the loop runs for all bitmasks from 0 to 2^12 irrespective of input.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)** , Same reason as above.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        ios_base::sync_with_stdio(0);\\n        int ans = 0; vector<int>answ(12,0);\\n        for(int mask = 0; mask < (1 << 12); mask++){\\n            int j = 0,s = 0,score = 0;\\n            while(j < 12){\\n                if((mask & (1 << j))){\\n                    s += aliceArrows[j] + 1;\\n                    score += j;\\n                }\\n                j++;\\n            }\\n            if(s <= numArrows){\\n                if(score > ans){\\n                    ans = score;\\n                    int last = -1;\\n                    for(int i = 0; i < 12; i++){\\n                        answ[i] = 0;\\n                        if((mask & (1 << i))){\\n                            last = i;\\n                            answ[i] = aliceArrows[i] + 1;\\n                        }\\n                    }\\n                    if(s < numArrows){\\n                        answ[last] += numArrows - s;\\n                    }\\n                }\\n            }\\n        }\\n        return answ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        ios_base::sync_with_stdio(0);\\n        int ans = 0; vector<int>answ(12,0);\\n        for(int mask = 0; mask < (1 << 12); mask++){\\n            int j = 0,s = 0,score = 0;\\n            while(j < 12){\\n                if((mask & (1 << j))){\\n                    s += aliceArrows[j] + 1;\\n                    score += j;\\n                }\\n                j++;\\n            }\\n            if(s <= numArrows){\\n                if(score > ans){\\n                    ans = score;\\n                    int last = -1;\\n                    for(int i = 0; i < 12; i++){\\n                        answ[i] = 0;\\n                        if((mask & (1 << i))){\\n                            last = i;\\n                            answ[i] = aliceArrows[i] + 1;\\n                        }\\n                    }\\n                    if(s < numArrows){\\n                        answ[last] += numArrows - s;\\n                    }\\n                }\\n            }\\n        }\\n        return answ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276913,
                "title": "c-solution",
                "content": "\\n\\n# Approach\\nRecursive Approach\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void check(int num , int index , vector<int> &aA , vector<int> &result , int temp , int &sum , vector<int> &tempVect)\\n    {\\n         if(num==0 || index == 12){\\n             if(sum < temp)\\n             {   if(num != 0)tempVect[0] = num;\\n                 result = tempVect;\\n                 tempVect[0] = 0;\\n                 sum = temp;\\n             }\\n             return ;\\n         }\\n         if(num > aA[index])\\n         {\\n             tempVect[index] = aA[index]+1;\\n             check(num - aA[index] - 1, index + 1 , aA , result , temp  + index , sum , tempVect);\\n             tempVect[index] = 0;\\n         }\\n         check(num , index + 1 , aA , result , temp ,sum ,  tempVect);\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n         vector<int> result(12 , 0);\\n         vector<int> tempVect(12 , 0);\\n         int sum = INT_MIN;\\n         check(numArrows , 1 , aliceArrows , result , 0 , sum , tempVect);\\n         return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void check(int num , int index , vector<int> &aA , vector<int> &result , int temp , int &sum , vector<int> &tempVect)\\n    {\\n         if(num==0 || index == 12){\\n             if(sum < temp)\\n             {   if(num != 0)tempVect[0] = num;\\n                 result = tempVect;\\n                 tempVect[0] = 0;\\n                 sum = temp;\\n             }\\n             return ;\\n         }\\n         if(num > aA[index])\\n         {\\n             tempVect[index] = aA[index]+1;\\n             check(num - aA[index] - 1, index + 1 , aA , result , temp  + index , sum , tempVect);\\n             tempVect[index] = 0;\\n         }\\n         check(num , index + 1 , aA , result , temp ,sum ,  tempVect);\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n         vector<int> result(12 , 0);\\n         vector<int> tempVect(12 , 0);\\n         int sum = INT_MIN;\\n         check(numArrows , 1 , aliceArrows , result , 0 , sum , tempVect);\\n         return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247674,
                "title": "simple-backtracking-c-easy-understanding",
                "content": "```\\nvector<int>ans;\\n    int maxSum = 0;\\n    \\n    void f(vector<int> & vec,int ind,int curr,vector<int> &temp){\\n        \\n        if(ind==vec.size() || curr==0){\\n            int sum = 0;\\n            for(int i =0;i<12;i++){\\n                if(temp[i]!=0) sum+=i;\\n            }\\n            if(sum>maxSum){\\n                ans = temp;\\n                maxSum = sum;\\n            }\\n            return;\\n        }\\n        \\n        f(vec,ind+1,curr,temp);\\n        if(curr-vec[ind]-1>=0){\\n            temp[ind] = vec[ind]+1;\\n            f(vec,ind+1,curr-vec[ind]-1,temp);\\n            temp[ind] = 0;\\n        }\\n        return;\\n    }\\n    \\n    vector<int> maximumBobPoints(int num, vector<int>& vec) {\\n        vector<int>temp(12,0);\\n        f(vec,0,num,temp);\\n        int sum = accumulate(ans.begin(),ans.end(),0);\\n        if(sum==num) return ans;\\n        else ans[0]+=num-sum;\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvector<int>ans;\\n    int maxSum = 0;\\n    \\n    void f(vector<int> & vec,int ind,int curr,vector<int> &temp){\\n        \\n        if(ind==vec.size() || curr==0){\\n            int sum = 0;\\n            for(int i =0;i<12;i++){\\n                if(temp[i]!=0) sum+=i;\\n            }\\n            if(sum>maxSum){\\n                ans = temp;\\n                maxSum = sum;\\n            }\\n            return;\\n        }\\n        \\n        f(vec,ind+1,curr,temp);\\n        if(curr-vec[ind]-1>=0){\\n            temp[ind] = vec[ind]+1;\\n            f(vec,ind+1,curr-vec[ind]-1,temp);\\n            temp[ind] = 0;\\n        }\\n        return;\\n    }\\n    \\n    vector<int> maximumBobPoints(int num, vector<int>& vec) {\\n        vector<int>temp(12,0);\\n        f(vec,0,num,temp);\\n        int sum = accumulate(ans.begin(),ans.end(),0);\\n        if(sum==num) return ans;\\n        else ans[0]+=num-sum;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3160258,
                "title": "easy-subset-type-backtracking-code-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int sum=0;\\n    public:\\n    void solve(int idx,vector<int> &alice,vector<int> &bob,vector<int> &ans,int num,int check){\\n         if(idx==-1||num<=0){\\n             if(check>=sum){\\n                 ans=bob;\\n                 sum=check;\\n                 if(num)\\n                 ans[0]+=num;\\n             }\\n             return ;\\n         }\\n\\n         int needed=alice[idx]+1;\\n         if(num>=needed){\\n             bob[idx]=needed;\\n             solve(idx-1,alice,bob,ans,num-needed,check+idx);\\n             bob[idx]=0;\\n         }\\n         solve(idx-1,alice,bob,ans,num,check);\\n         return;\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int num, vector<int>& alice) {\\n        vector<int> ans(12,0),bob(12,0);\\n        int check=0;\\n        solve(11,alice,bob,ans,num,check);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum=0;\\n    public:\\n    void solve(int idx,vector<int> &alice,vector<int> &bob,vector<int> &ans,int num,int check){\\n         if(idx==-1||num<=0){\\n             if(check>=sum){\\n                 ans=bob;\\n                 sum=check;\\n                 if(num)\\n                 ans[0]+=num;\\n             }\\n             return ;\\n         }\\n\\n         int needed=alice[idx]+1;\\n         if(num>=needed){\\n             bob[idx]=needed;\\n             solve(idx-1,alice,bob,ans,num-needed,check+idx);\\n             bob[idx]=0;\\n         }\\n         solve(idx-1,alice,bob,ans,num,check);\\n         return;\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int num, vector<int>& alice) {\\n        vector<int> ans(12,0),bob(12,0);\\n        int check=0;\\n        solve(11,alice,bob,ans,num,check);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139533,
                "title": "time-o-12-66-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDP is a valid solution \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs the scores are higher at sections with higher index, reverse the array will help to find better solution earlier when possible.\\n\\nAnd noticeable that bob could earn the score when he shot just one more arrows that alice in the same section. More arrows in the section are waste.\\nSo for each section only 0 arrow and one more than alice are to be considered.\\n\\nObviously section Zero will never contribute the score.\\nWhen possible the highest score will be 66, no more are possible.\\n\\n66 is really a small number, so arraies are used to tracking the scores and corresponding sections picked. This will be more efficent that dict\\n\\nthere are two cases that a quick answer could be generate without DP. when the possible maximume score is 66 or 65.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(12*66)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(66)\\n# Code\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        if aliceArrows[0] >= 11:\\n            bobArrows = [_+1 for _ in aliceArrows]\\n            bobArrows[0] -= 12\\n            return bobArrows\\n        if aliceArrows[0] + aliceArrows[1] >= 10:\\n            bobArrows = [_+1 for _ in aliceArrows]\\n            bobArrows[0] = 0\\n            bobArrows[1] = aliceArrows[0] + aliceArrows[1] - 10\\n            return bobArrows \\n \\n        highscore = 66 #sum(list(reversed(range(12)))[:numArrows])\\n        highscores = set()\\n        highscorecosts = [inf] * (highscore + 1)\\n        highscorepaths = [[] for _ in range(highscore + 1)]\\n        # highscorecosts[0] = 0\\n        # print( highscore, highscores, numArrows, aliceArrows)\\n        def update(s, c, i ):\\n            if highscorecosts[s] >  c:\\n                highscorecosts[s] = c\\n                return True\\n            return False\\n            \\n        for i in reversed(range(12)):\\n            a = aliceArrows[i]\\n            if i and a < numArrows:\\n                newhighscores = set()\\n                for s in sorted(highscores, reverse=True):\\n                    if highscorecosts[s] + a  < numArrows:\\n                        # print(f\\'new high scores: {s+i} : min({highscorecosts[s + i]}, {a+1}+{highscorecosts[s]})\\')\\n                        if update(s+i, a+1+highscorecosts[s], i ):\\n                            highscorepaths[s + i] = highscorepaths[s] + [i]\\n                            newhighscores.add(s+i)\\n                            # print(f\\'new high score path: {s+i} : {highscorepaths[s + i]}\\')\\n                # print(f\\'new high scores: {i} : min({highscorecosts[ i]}, {a+1})\\')\\n                if update(i, a+1, i ):\\n                    highscorepaths[i] = [i]\\n                    newhighscores.add(i)\\n                    # print(f\\'new high score path: {i} : {highscorepaths[i]}\\')\\n                highscores = highscores | newhighscores\\n        # print( max(highscores), highscores, highscorecosts )\\n        bobArrows = [0]*12\\n        for i in highscorepaths[max(highscores)]:\\n            bobArrows[i] = aliceArrows[i] + 1\\n        bobArrows[0] = numArrows - sum(bobArrows)\\n        return bobArrows\\n \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        if aliceArrows[0] >= 11:\\n            bobArrows = [_+1 for _ in aliceArrows]\\n            bobArrows[0] -= 12\\n            return bobArrows\\n        if aliceArrows[0] + aliceArrows[1] >= 10:\\n            bobArrows = [_+1 for _ in aliceArrows]\\n            bobArrows[0] = 0\\n            bobArrows[1] = aliceArrows[0] + aliceArrows[1] - 10\\n            return bobArrows \\n \\n        highscore = 66 #sum(list(reversed(range(12)))[:numArrows])\\n        highscores = set()\\n        highscorecosts = [inf] * (highscore + 1)\\n        highscorepaths = [[] for _ in range(highscore + 1)]\\n        # highscorecosts[0] = 0\\n        # print( highscore, highscores, numArrows, aliceArrows)\\n        def update(s, c, i ):\\n            if highscorecosts[s] >  c:\\n                highscorecosts[s] = c\\n                return True\\n            return False\\n            \\n        for i in reversed(range(12)):\\n            a = aliceArrows[i]\\n            if i and a < numArrows:\\n                newhighscores = set()\\n                for s in sorted(highscores, reverse=True):\\n                    if highscorecosts[s] + a  < numArrows:\\n                        # print(f\\'new high scores: {s+i} : min({highscorecosts[s + i]}, {a+1}+{highscorecosts[s]})\\')\\n                        if update(s+i, a+1+highscorecosts[s], i ):\\n                            highscorepaths[s + i] = highscorepaths[s] + [i]\\n                            newhighscores.add(s+i)\\n                            # print(f\\'new high score path: {s+i} : {highscorepaths[s + i]}\\')\\n                # print(f\\'new high scores: {i} : min({highscorecosts[ i]}, {a+1})\\')\\n                if update(i, a+1, i ):\\n                    highscorepaths[i] = [i]\\n                    newhighscores.add(i)\\n                    # print(f\\'new high score path: {i} : {highscorepaths[i]}\\')\\n                highscores = highscores | newhighscores\\n        # print( max(highscores), highscores, highscorecosts )\\n        bobArrows = [0]*12\\n        for i in highscorepaths[max(highscores)]:\\n            bobArrows[i] = aliceArrows[i] + 1\\n        bobArrows[0] = numArrows - sum(bobArrows)\\n        return bobArrows\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073630,
                "title": "maximum-points-in-an-archery-competition",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        dp = {(0, 0): (0, numArrows), (0, aliceArrows[1] + 1): (1, numArrows - (aliceArrows[1] + 1))}\\n        for i in range(2, 12):\\n            prev = dp\\n            dp = {}\\n            for key in prev:\\n                newkey1 = list(key)\\n                newkey1.append(0)\\n                score, arrowleft = prev[key]\\n                \\n                newval1 = (score, arrowleft)\\n                dp[tuple(newkey1)] = newval1\\n    \\n                if arrowleft >= aliceArrows[i] + 1:\\n                    newkey2 = list(key)\\n                    newkey2.append(aliceArrows[i] + 1)\\n                    newval2 = (score + i, arrowleft - (aliceArrows[i] + 1))\\n                    dp[tuple(newkey2)] = newval2\\n        maxscore, res = 0, None\\n        for key in dp:\\n            score, _ = dp[key]\\n            if score > maxscore:\\n                maxscore = score\\n                res = list(key)\\n        if sum(res) < numArrows:\\n            res[0] = numArrows - sum(res)\\n        \\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        dp = {(0, 0): (0, numArrows), (0, aliceArrows[1] + 1): (1, numArrows - (aliceArrows[1] + 1))}\\n        for i in range(2, 12):\\n            prev = dp\\n            dp = {}\\n            for key in prev:\\n                newkey1 = list(key)\\n                newkey1.append(0)\\n                score, arrowleft = prev[key]\\n                \\n                newval1 = (score, arrowleft)\\n                dp[tuple(newkey1)] = newval1\\n    \\n                if arrowleft >= aliceArrows[i] + 1:\\n                    newkey2 = list(key)\\n                    newkey2.append(aliceArrows[i] + 1)\\n                    newval2 = (score + i, arrowleft - (aliceArrows[i] + 1))\\n                    dp[tuple(newkey2)] = newval2\\n        maxscore, res = 0, None\\n        for key in dp:\\n            score, _ = dp[key]\\n            if score > maxscore:\\n                maxscore = score\\n                res = list(key)\\n        if sum(res) < numArrows:\\n            res[0] = numArrows - sum(res)\\n        \\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058252,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>ans;\\n        int score=0;\\n        for(int i=0; i<(1<<12); i++){\\n            int n=numArrows, count=0;\\n            vector<int>temp(12, 0);\\n            for(int j=11; j>=0; j--){\\n                if(i&(1<<j)){\\n                    if(n>aliceArrows[j]){//if arrows are less than alice shooted arrows\\n                        n-=(aliceArrows[j]+1);//decrement the arrows\\n                        temp[j]=(aliceArrows[j]+1);//initialize the vector at that position\\n                    }\\n                }\\n            }\\n            for(int j=0; j<12; j++){\\n                if(i&(1<<j)){\\n                    temp[j]+=n;//remaining arrows of bob had to be used\\n                    break;\\n                }\\n            }\\n            for(int j=0; j<12; j++){\\n                if(temp[j]>aliceArrows[j]){count+=j;}//if temp[j] is greater than alice arrows points bob will get points\\n            }\\n            if(count>score){//if bob score is greater than score\\n                score=count;//update the score\\n                ans=temp;//store temp in ans\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        // vector<int> ans;\\n        // int score = 0;\\n        // for(int i = 1; i<4096; i++)\\n        // {\\n        //     int arrows = numArrows;\\n        //     vector<int> temp(12,0);\\n        //     for(int j = 11; j>=0; j--)\\n        //     {\\n        //         if(i & (i<<j))\\n        //         {\\n        //             if(arrows<=aliceArrows[j])//if arrows are less than alice shooted arrows\\n        //             {\\n        //                 continue;\\n        //             }\\n        //             arrows-=(aliceArrows[j]+1);//decrement the arrows\\n        //             temp[j]=aliceArrows[j]+1;//initialize the vector at that position\\n        //         }\\n        //     }\\n        //     for(int j = 0; j<12; j++)\\n        //     {\\n        //         if(i & (1<<j))\\n        //         {\\n        //             temp[j]+=arrows;//remaining arrows of bob had to be used\\n        //             break;\\n        //         }\\n        //     }\\n        //     int b = 0;\\n        //     for(int j = 0; j<12; j++)\\n        //     {\\n        //         if(temp[j]>aliceArrows[j])//if temp[j] is greater than alice arrows points bob will get points\\n        //         {\\n        //             b+=(j);\\n        //         }\\n        //     }\\n        //     if(b>score)//if bob score is greater than score\\n        //     {\\n        //         score = b;//update the score\\n        //         ans = temp;//store temp in ans;\\n        //     }\\n        // }\\n        // return ans;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>ans;\\n        int score=0;\\n        for(int i=0; i<(1<<12); i++){\\n            int n=numArrows, count=0;\\n            vector<int>temp(12, 0);\\n            for(int j=11; j>=0; j--){\\n                if(i&(1<<j)){\\n                    if(n>aliceArrows[j]){//if arrows are less than alice shooted arrows\\n                        n-=(aliceArrows[j]+1);//decrement the arrows\\n                        temp[j]=(aliceArrows[j]+1);//initialize the vector at that position\\n                    }\\n                }\\n            }\\n            for(int j=0; j<12; j++){\\n                if(i&(1<<j)){\\n                    temp[j]+=n;//remaining arrows of bob had to be used\\n                    break;\\n                }\\n            }\\n            for(int j=0; j<12; j++){\\n                if(temp[j]>aliceArrows[j]){count+=j;}//if temp[j] is greater than alice arrows points bob will get points\\n            }\\n            if(count>score){//if bob score is greater than score\\n                score=count;//update the score\\n                ans=temp;//store temp in ans\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        // vector<int> ans;\\n        // int score = 0;\\n        // for(int i = 1; i<4096; i++)\\n        // {\\n        //     int arrows = numArrows;\\n        //     vector<int> temp(12,0);\\n        //     for(int j = 11; j>=0; j--)\\n        //     {\\n        //         if(i & (i<<j))\\n        //         {\\n        //             if(arrows<=aliceArrows[j])//if arrows are less than alice shooted arrows\\n        //             {\\n        //                 continue;\\n        //             }\\n        //             arrows-=(aliceArrows[j]+1);//decrement the arrows\\n        //             temp[j]=aliceArrows[j]+1;//initialize the vector at that position\\n        //         }\\n        //     }\\n        //     for(int j = 0; j<12; j++)\\n        //     {\\n        //         if(i & (1<<j))\\n        //         {\\n        //             temp[j]+=arrows;//remaining arrows of bob had to be used\\n        //             break;\\n        //         }\\n        //     }\\n        //     int b = 0;\\n        //     for(int j = 0; j<12; j++)\\n        //     {\\n        //         if(temp[j]>aliceArrows[j])//if temp[j] is greater than alice arrows points bob will get points\\n        //         {\\n        //             b+=(j);\\n        //         }\\n        //     }\\n        //     if(b>score)//if bob score is greater than score\\n        //     {\\n        //         score = b;//update the score\\n        //         ans = temp;//store temp in ans;\\n        //     }\\n        // }\\n        // return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037262,
                "title": "c-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstarting with highest points u can earn we need to distribute the available arrows to that particular section of points.\\nBut we can select that category for the total points or not so we need an approach we can select that category of points or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe can use backtracking approach by choosing at one time and not choosing the current category for maximum points by BOB.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(2^N) as N=12 so it is Acceptable.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint ans=0;\\nvector<int>res;\\n    void maxpoints(int arrows, int ind, vector<int>points, int score,vector<int>&ar)\\n    {\\n        \\n        if(ind<0)\\n        {\\n            points[0]+=arrows;\\n            if(score>ans)\\n            {\\n                ans=score;\\n                res=points;\\n            }\\n            return;\\n        }\\n        if(arrows<ar[ind]+1)\\n        {\\n            maxpoints(arrows,ind-1,points,score,ar);\\n        }\\n        else\\n        {\\n            points[ind]=ar[ind]+1;\\n            maxpoints(arrows-ar[ind]-1,ind-1,points,score+ind,ar);\\n            points[ind]=0;\\n            maxpoints(arrows,ind-1,points,score,ar);\\n        }\\n    }\\n\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n=aliceArrows.size();\\n        res=vector<int>(n,0);\\n        maxpoints(numArrows,n-1,res,0,aliceArrows);\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint ans=0;\\nvector<int>res;\\n    void maxpoints(int arrows, int ind, vector<int>points, int score,vector<int>&ar)\\n    {\\n        \\n        if(ind<0)\\n        {\\n            points[0]+=arrows;\\n            if(score>ans)\\n            {\\n                ans=score;\\n                res=points;\\n            }\\n            return;\\n        }\\n        if(arrows<ar[ind]+1)\\n        {\\n            maxpoints(arrows,ind-1,points,score,ar);\\n        }\\n        else\\n        {\\n            points[ind]=ar[ind]+1;\\n            maxpoints(arrows-ar[ind]-1,ind-1,points,score+ind,ar);\\n            points[ind]=0;\\n            maxpoints(arrows,ind-1,points,score,ar);\\n        }\\n    }\\n\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n=aliceArrows.size();\\n        res=vector<int>(n,0);\\n        maxpoints(numArrows,n-1,res,0,aliceArrows);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032448,
                "title": "java-backtracking-solution",
                "content": "This question is same as **LCS**.\\nSince 0 is not going to add any score so we will find max score obtained till 1 and we will put remaining arrows in bob[0].\\n\\n```\\nclass Solution {\\n    List<Integer> list;\\n    int score;\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int n = aliceArrows.length;\\n        list = new ArrayList<>();\\n        score = 0;\\n        findBobArrow(numArrows, aliceArrows, n - 1, new ArrayList<>(), 0);\\n        \\n        int[] bob = new int[12];\\n        int total = 0;\\n        for(int idx: list){\\n            bob[idx] = aliceArrows[idx]+1;\\n            total += bob[idx];\\n        }\\n        if(numArrows - total > 0){\\n            bob[0] = numArrows - total;\\n        }\\n        return bob;\\n    }\\n    \\n    private void findBobArrow(int a, int[] aa, int idx, List<Integer> curr, int currScore){\\n        if(currScore > score){\\n            score = currScore; \\n            list = new ArrayList<>(curr);\\n        }\\n        \\n        if(idx == 0) return ;\\n        \\n        // if Bob don\\'t wants to get that score\\n        findBobArrow(a, aa, idx-1, curr, currScore);\\n        \\n        // if Bob want to get that score\\n        if(a > aa[idx]){\\n            curr.add(idx);\\n            findBobArrow(a - aa[idx] - 1, aa, idx-1, curr, currScore + idx);\\n            curr.remove(curr.size() - 1);\\n        }\\n        \\n        return ;\\n    }\\n}\\n```\\n\\nTC - O(11) = O(1)\\nSC - O(11) = O(1)",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> list;\\n    int score;\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int n = aliceArrows.length;\\n        list = new ArrayList<>();\\n        score = 0;\\n        findBobArrow(numArrows, aliceArrows, n - 1, new ArrayList<>(), 0);\\n        \\n        int[] bob = new int[12];\\n        int total = 0;\\n        for(int idx: list){\\n            bob[idx] = aliceArrows[idx]+1;\\n            total += bob[idx];\\n        }\\n        if(numArrows - total > 0){\\n            bob[0] = numArrows - total;\\n        }\\n        return bob;\\n    }\\n    \\n    private void findBobArrow(int a, int[] aa, int idx, List<Integer> curr, int currScore){\\n        if(currScore > score){\\n            score = currScore; \\n            list = new ArrayList<>(curr);\\n        }\\n        \\n        if(idx == 0) return ;\\n        \\n        // if Bob don\\'t wants to get that score\\n        findBobArrow(a, aa, idx-1, curr, currScore);\\n        \\n        // if Bob want to get that score\\n        if(a > aa[idx]){\\n            curr.add(idx);\\n            findBobArrow(a - aa[idx] - 1, aa, idx-1, curr, currScore + idx);\\n            curr.remove(curr.size() - 1);\\n        }\\n        \\n        return ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028833,
                "title": "a-recursive-approach-c-fast-simpel",
                "content": "\\n# Approach\\nThe given code is an implementation of a recursive function that attempts to find the maximum number of points Bob can score in the archery competition, given the number of arrows he has available to shoot and the number of points Alice scored on each section of the target.\\n\\nThe function operates by considering each section of the target individually and determining whether Bob should shoot an arrow at that section or not. It does this by first calling itself recursively for the next section of the target, without shooting an arrow at the current section. It then checks if Bob has enough arrows remaining to shoot at the current section, and if so, it increments Bob\\'s score for that section by 1, decrements the number of remaining arrows by 1, and calls itself recursively for the next section of the target.\\n\\nThe function keeps track of the maximum score seen so far and stores the number of arrows shot at each section of the target in a vector called ans, which it returns at the end. If there are any remaining arrows at the end of the function, it adds them to the first element of ans.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // variable to store the maximum score\\n    int maxScore;\\n    // variable to store the optimal solution (Bob\\'s arrow distribution)\\n    vector<int> optimalSolution;\\n    // variable to store the remaining number of arrows\\n    int remainingArrows;\\n\\n    // recursive helper function to find the optimal solution\\n    void findOptimalSolution(vector<int>& aliceArrows, vector<int> bobArrows, int remainingArrows, int currentIndex, int currentScore) {\\n        // base case: if we have reached the end of the array or run out of arrows, update the maxScore and optimalSolution if necessary\\n        if (currentIndex == -1 || remainingArrows <= 0) {\\n            if (currentScore > maxScore) {\\n                maxScore = currentScore;\\n                optimalSolution = bobArrows;\\n                if (remainingArrows > 0 && optimalSolution.size() > 0) {\\n                    optimalSolution[0] += remainingArrows;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // recursive case: try not shooting any arrows in the current section\\n        findOptimalSolution(aliceArrows, bobArrows, remainingArrows, currentIndex-1, currentScore);\\n        \\n        // recursive case: try shooting arrows in the current section\\n        if (remainingArrows > aliceArrows[currentIndex]) {\\n            bobArrows[currentIndex] = aliceArrows[currentIndex] + 1;\\n            remainingArrows -= (aliceArrows[currentIndex] + 1);\\n            currentScore += currentIndex;\\n            findOptimalSolution(aliceArrows, bobArrows, remainingArrows, currentIndex-1, currentScore);\\n        }\\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        // initialize variables\\n        maxScore = INT_MIN;\\n        remainingArrows = numArrows;\\n        int currentIndex = aliceArrows.size() - 1;\\n        vector<int> bobArrows(aliceArrows.size(), 0);\\n        int currentScore = 0;\\n        \\n        // call recursive helper function\\n        findOptimalSolution(aliceArrows, bobArrows, remainingArrows, currentIndex, currentScore);\\n        \\n        return optimalSolution;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // variable to store the maximum score\\n    int maxScore;\\n    // variable to store the optimal solution (Bob\\'s arrow distribution)\\n    vector<int> optimalSolution;\\n    // variable to store the remaining number of arrows\\n    int remainingArrows;\\n\\n    // recursive helper function to find the optimal solution\\n    void findOptimalSolution(vector<int>& aliceArrows, vector<int> bobArrows, int remainingArrows, int currentIndex, int currentScore) {\\n        // base case: if we have reached the end of the array or run out of arrows, update the maxScore and optimalSolution if necessary\\n        if (currentIndex == -1 || remainingArrows <= 0) {\\n            if (currentScore > maxScore) {\\n                maxScore = currentScore;\\n                optimalSolution = bobArrows;\\n                if (remainingArrows > 0 && optimalSolution.size() > 0) {\\n                    optimalSolution[0] += remainingArrows;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // recursive case: try not shooting any arrows in the current section\\n        findOptimalSolution(aliceArrows, bobArrows, remainingArrows, currentIndex-1, currentScore);\\n        \\n        // recursive case: try shooting arrows in the current section\\n        if (remainingArrows > aliceArrows[currentIndex]) {\\n            bobArrows[currentIndex] = aliceArrows[currentIndex] + 1;\\n            remainingArrows -= (aliceArrows[currentIndex] + 1);\\n            currentScore += currentIndex;\\n            findOptimalSolution(aliceArrows, bobArrows, remainingArrows, currentIndex-1, currentScore);\\n        }\\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        // initialize variables\\n        maxScore = INT_MIN;\\n        remainingArrows = numArrows;\\n        int currentIndex = aliceArrows.size() - 1;\\n        vector<int> bobArrows(aliceArrows.size(), 0);\\n        int currentScore = 0;\\n        \\n        // call recursive helper function\\n        findOptimalSolution(aliceArrows, bobArrows, remainingArrows, currentIndex, currentScore);\\n        \\n        return optimalSolution;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027229,
                "title": "intuitive-very-easy-knapsack-recursion-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int maxi=0;\\n    void help(int points,int available,vector<int> &aliceArrows,int sum,vector<int> &res){\\n        if(points < 0  or available <= 0){\\n            if(sum > maxi){\\n                maxi = sum;\\n                if(available > 0) res[0] += available;\\n                ans = res;\\n            }\\n            return;\\n        }\\n        int required = aliceArrows[points] + 1;\\n\\n        //pick\\n        if(required <= available){\\n            res[points] = required;\\n            help(points - 1, available - required, aliceArrows, sum + points, res);\\n            res[points] = 0;\\n        }\\n\\n        //not pick\\n        help(points - 1, available , aliceArrows , sum, res);\\n    }\\n\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> res(12,0);\\n        help(11, numArrows, aliceArrows, 0, res);\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int maxi=0;\\n    void help(int points,int available,vector<int> &aliceArrows,int sum,vector<int> &res){\\n        if(points < 0  or available <= 0){\\n            if(sum > maxi){\\n                maxi = sum;\\n                if(available > 0) res[0] += available;\\n                ans = res;\\n            }\\n            return;\\n        }\\n        int required = aliceArrows[points] + 1;\\n\\n        //pick\\n        if(required <= available){\\n            res[points] = required;\\n            help(points - 1, available - required, aliceArrows, sum + points, res);\\n            res[points] = 0;\\n        }\\n\\n        //not pick\\n        help(points - 1, available , aliceArrows , sum, res);\\n    }\\n\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> res(12,0);\\n        help(11, numArrows, aliceArrows, 0, res);\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026594,
                "title": "6companies30days-challenge-by-arsh-goyal-goldmansachs-d3",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int finalMask = 0,finalScore=0;\\n        for(int i=1;i< (1<<12) ;i++){\\n            int score  = 0;\\n            int arrows = numArrows;\\n            bool wrongMask=false;\\n            for(int j=1;j<12;j++){\\n                if((1<<j)&i){\\n                    int arrowsNeeded = aliceArrows[j] + 1; \\n                    if(arrows-arrowsNeeded >= 0){\\n                        arrows -= arrowsNeeded;\\n                        score += j;\\n                    }\\n                    else{\\n                        wrongMask=true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(!wrongMask && score>finalScore){\\n                finalScore=score;\\n                finalMask=i;\\n            }\\n        }\\n        vector<int> ans(12);\\n        int sum=numArrows;\\n        for(int i=1;i<12;i++){\\n            if((1<<i)&finalMask){\\n                ans[i] = aliceArrows[i]+1;\\n                sum -= ans[i];\\n            }\\n        }\\n        if(sum>0){\\n            ans[0] = sum;\\n        }\\n        cout<<finalScore;\\n        return ans;\\n    }\\n};class Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int finalMask = 0,finalScore=0;\\n        for(int i=1;i< (1<<12) ;i++){\\n            int score  = 0;\\n            int arrows = numArrows;\\n            bool wrongMask=false;\\n            for(int j=1;j<12;j++){\\n                if((1<<j)&i){\\n                    int arrowsNeeded = aliceArrows[j] + 1; \\n                    if(arrows-arrowsNeeded >= 0){\\n                        arrows -= arrowsNeeded;\\n                        score += j;\\n                    }\\n                    else{\\n                        wrongMask=true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(!wrongMask && score>finalScore){\\n                finalScore=score;\\n                finalMask=i;\\n            }\\n        }\\n        vector<int> ans(12);\\n        int sum=numArrows;\\n        for(int i=1;i<12;i++){\\n            if((1<<i)&finalMask){\\n                ans[i] = aliceArrows[i]+1;\\n                sum -= ans[i];\\n            }\\n        }\\n        if(sum>0){\\n            ans[0] = sum;\\n        }\\n        cout<<finalScore;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int finalMask = 0,finalScore=0;\\n        for(int i=1;i< (1<<12) ;i++){\\n            int score  = 0;\\n            int arrows = numArrows;\\n            bool wrongMask=false;\\n            for(int j=1;j<12;j++){\\n                if((1<<j)&i){\\n                    int arrowsNeeded = aliceArrows[j] + 1; \\n                    if(arrows-arrowsNeeded >= 0){\\n                        arrows -= arrowsNeeded;\\n                        score += j;\\n                    }\\n                    else{\\n                        wrongMask=true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(!wrongMask && score>finalScore){\\n                finalScore=score;\\n                finalMask=i;\\n            }\\n        }\\n        vector<int> ans(12);\\n        int sum=numArrows;\\n        for(int i=1;i<12;i++){\\n            if((1<<i)&finalMask){\\n                ans[i] = aliceArrows[i]+1;\\n                sum -= ans[i];\\n            }\\n        }\\n        if(sum>0){\\n            ans[0] = sum;\\n        }\\n        cout<<finalScore;\\n        return ans;\\n    }\\n};class Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int finalMask = 0,finalScore=0;\\n        for(int i=1;i< (1<<12) ;i++){\\n            int score  = 0;\\n            int arrows = numArrows;\\n            bool wrongMask=false;\\n            for(int j=1;j<12;j++){\\n                if((1<<j)&i){\\n                    int arrowsNeeded = aliceArrows[j] + 1; \\n                    if(arrows-arrowsNeeded >= 0){\\n                        arrows -= arrowsNeeded;\\n                        score += j;\\n                    }\\n                    else{\\n                        wrongMask=true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(!wrongMask && score>finalScore){\\n                finalScore=score;\\n                finalMask=i;\\n            }\\n        }\\n        vector<int> ans(12);\\n        int sum=numArrows;\\n        for(int i=1;i<12;i++){\\n            if((1<<i)&finalMask){\\n                ans[i] = aliceArrows[i]+1;\\n                sum -= ans[i];\\n            }\\n        }\\n        if(sum>0){\\n            ans[0] = sum;\\n        }\\n        cout<<finalScore;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3026142,
                "title": "2-simple-solution-recursion-bitsmask-o-2-11",
                "content": "\\n\\n# Code (simple recusion)\\n```\\nclass Solution {\\npublic:\\n    int mx = 0;\\n    vector<int>v;\\n    void solve(vector<int>&aliceArrows,int n,int val,int arrow,vector<int>&arr){\\n        // base\\n        if(n == 0 || arrow == 0){\\n            if(mx<val){\\n                mx = val;\\n                v = arr;\\n                v[0] = arrow;\\n            }\\n            return;\\n        }\\n\\n        \\n        if(aliceArrows[n]<arrow){\\n            arr[n] = aliceArrows[n]+1;\\n            solve(aliceArrows,n-1,n+val,arrow-1-aliceArrows[n],arr);\\n        }\\n        arr[n] = 0;\\n        solve(aliceArrows,n-1,val,arrow,arr);\\n\\n    }\\n\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>arr(12,0);\\n        solve(aliceArrows,11,0,numArrows,arr);\\n        return v;\\n        \\n    }\\n};\\n```\\n\\n\\n# Code (bitmask)\\n```\\n\\nclass Solution {\\npublic:\\n    int max_points = 0, max_mask = 0;\\n\\n    void dfs(int k,int numArrows,vector<int>&aliceArrows,int points,int mask){\\n        if(numArrows>=0 and points>max_points){\\n            max_points = points;\\n            max_mask = mask;\\n        }\\n        if(k>0){\\n            dfs(k-1,numArrows-aliceArrows[k]-1,aliceArrows,points+k,mask+(1<<k));\\n            dfs(k-1,numArrows,aliceArrows,points,mask);\\n        }\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>res(12);\\n        dfs(11,numArrows,aliceArrows,0,0);\\n        for(int k=11;k>0;k--){\\n            if(max_mask&(1<<k)){\\n                res[k] = aliceArrows[k]+1;\\n                numArrows -= aliceArrows[k]+1;\\n            }\\n        }\\n        res[0] = numArrows;\\n        return res;\\n    }\\n\\n};\\n```\\n# do upvote if you liked the solution HAPPY CODING :)",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mx = 0;\\n    vector<int>v;\\n    void solve(vector<int>&aliceArrows,int n,int val,int arrow,vector<int>&arr){\\n        // base\\n        if(n == 0 || arrow == 0){\\n            if(mx<val){\\n                mx = val;\\n                v = arr;\\n                v[0] = arrow;\\n            }\\n            return;\\n        }\\n\\n        \\n        if(aliceArrows[n]<arrow){\\n            arr[n] = aliceArrows[n]+1;\\n            solve(aliceArrows,n-1,n+val,arrow-1-aliceArrows[n],arr);\\n        }\\n        arr[n] = 0;\\n        solve(aliceArrows,n-1,val,arrow,arr);\\n\\n    }\\n\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>arr(12,0);\\n        solve(aliceArrows,11,0,numArrows,arr);\\n        return v;\\n        \\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int max_points = 0, max_mask = 0;\\n\\n    void dfs(int k,int numArrows,vector<int>&aliceArrows,int points,int mask){\\n        if(numArrows>=0 and points>max_points){\\n            max_points = points;\\n            max_mask = mask;\\n        }\\n        if(k>0){\\n            dfs(k-1,numArrows-aliceArrows[k]-1,aliceArrows,points+k,mask+(1<<k));\\n            dfs(k-1,numArrows,aliceArrows,points,mask);\\n        }\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>res(12);\\n        dfs(11,numArrows,aliceArrows,0,0);\\n        for(int k=11;k>0;k--){\\n            if(max_mask&(1<<k)){\\n                res[k] = aliceArrows[k]+1;\\n                numArrows -= aliceArrows[k]+1;\\n            }\\n        }\\n        res[0] = numArrows;\\n        return res;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023402,
                "title": "c-recursion-easy-solution",
                "content": "# Please UpVote if it helps you\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int Max=-1;\\n    int solve(int n,vector<int>&nums,vector<int>&a,int i,int M){\\n        if(i>=nums.size()){\\n            if(M>Max){\\n                Max = M;\\n                ans = a;\\n                ans[11] += n;\\n            }\\n            return M;\\n        }\\n        int t1 = 0;\\n        if(n>=nums[i]+1){\\n            a[i] = nums[i]+1;\\n            t1 += i +solve(n-nums[i]-1,nums,a,i+1,M+i);\\n            a[i] = 0;\\n        }\\n        t1 = max(t1,solve(n,nums,a,i+1,M));\\n        return t1;\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> a(12,0);\\n        int x = solve(numArrows,aliceArrows,a,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int Max=-1;\\n    int solve(int n,vector<int>&nums,vector<int>&a,int i,int M){\\n        if(i>=nums.size()){\\n            if(M>Max){\\n                Max = M;\\n                ans = a;\\n                ans[11] += n;\\n            }\\n            return M;\\n        }\\n        int t1 = 0;\\n        if(n>=nums[i]+1){\\n            a[i] = nums[i]+1;\\n            t1 += i +solve(n-nums[i]-1,nums,a,i+1,M+i);\\n            a[i] = 0;\\n        }\\n        t1 = max(t1,solve(n,nums,a,i+1,M));\\n        return t1;\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> a(12,0);\\n        int x = solve(numArrows,aliceArrows,a,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021112,
                "title": "0-1-knapsack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint f(int ind,int max_w,vector<int>&wt,vector<vector<int>>&dp)\\n{\\n    if(ind <= 0 )return 0;\\n     if(dp[ind][max_w]!=-1)return dp[ind][max_w];\\n    int notPick=f(ind-1,max_w,wt,dp);\\n    int Pick=0;\\n    if(wt[ind]<max_w)\\n    {\\n        Pick=ind+f(ind-1,max_w-wt[ind]-1,wt,dp);\\n    }\\n     return dp[ind][max_w]=max(Pick,notPick);\\n}\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        // int n=aliceArrows.size();\\n        vector<vector<int>> dp(12,vector<int>(numArrows+1,-1));\\n        \\n        // for(auto i:dp)\\n        // {\\n        //     for(auto j:i)\\n        //     cout<<j<<\" \";\\n        //     cout<<\"\\\\n\";\\n        // }\\n        //return {};\\n\\n        vector<int>ans(12,0);\\n        int result = f(11, numArrows,aliceArrows,dp);\\n        cout<<result<<\"\\\\n\";\\n        int total = 0; // to count total arrows used by bob\\n        for (int i=12, j=numArrows; i > 0 && result > 0; i--) {\\n            if (result == dp[i-1][j])\\n                {cout<<dp[i-1][j];continue;}\\n                \\n            else {\\n                //cout<<\"####\\\\n\";\\n                // This item is included.\\n                ans[i] = aliceArrows[i]+1;\\n                //cout<<ans[i]<<\" \"<<i<<\"\\\\n\";\\n                result -=  (i);  // subtracting profit\\n                j -= (aliceArrows[i]+1); // subtracting weight\\n                total += aliceArrows[i]+1; \\n            }\\n        }\\n        \\n\\t\\t// as bob has to fire numArrows, remaining can be of 0 value\\n        if(total<numArrows){\\n            ans[0] = numArrows-total;\\n        }\\n        // for(auto i:ans)\\n        // {\\n        //    cout<<i<<\" \";\\n        // }\\n    \\n      return ans;\\n\\n    \\n       // return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint f(int ind,int max_w,vector<int>&wt,vector<vector<int>>&dp)\\n{\\n    if(ind <= 0 )return 0;\\n     if(dp[ind][max_w]!=-1)return dp[ind][max_w];\\n    int notPick=f(ind-1,max_w,wt,dp);\\n    int Pick=0;\\n    if(wt[ind]<max_w)\\n    {\\n        Pick=ind+f(ind-1,max_w-wt[ind]-1,wt,dp);\\n    }\\n     return dp[ind][max_w]=max(Pick,notPick);\\n}\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        // int n=aliceArrows.size();\\n        vector<vector<int>> dp(12,vector<int>(numArrows+1,-1));\\n        \\n        // for(auto i:dp)\\n        // {\\n        //     for(auto j:i)\\n        //     cout<<j<<\" \";\\n        //     cout<<\"\\\\n\";\\n        // }\\n        //return {};\\n\\n        vector<int>ans(12,0);\\n        int result = f(11, numArrows,aliceArrows,dp);\\n        cout<<result<<\"\\\\n\";\\n        int total = 0; // to count total arrows used by bob\\n        for (int i=12, j=numArrows; i > 0 && result > 0; i--) {\\n            if (result == dp[i-1][j])\\n                {cout<<dp[i-1][j];continue;}\\n                \\n            else {\\n                //cout<<\"####\\\\n\";\\n                // This item is included.\\n                ans[i] = aliceArrows[i]+1;\\n                //cout<<ans[i]<<\" \"<<i<<\"\\\\n\";\\n                result -=  (i);  // subtracting profit\\n                j -= (aliceArrows[i]+1); // subtracting weight\\n                total += aliceArrows[i]+1; \\n            }\\n        }\\n        \\n\\t\\t// as bob has to fire numArrows, remaining can be of 0 value\\n        if(total<numArrows){\\n            ans[0] = numArrows-total;\\n        }\\n        // for(auto i:ans)\\n        // {\\n        //    cout<<i<<\" \";\\n        // }\\n    \\n      return ans;\\n\\n    \\n       // return {};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3019416,
                "title": "30-days-6-companies-day-8-q2-c-solution",
                "content": "```\\nclass Solution {\\nprivate : \\n    vector<int> ans;\\n    bool checkProfit(vector<int>&bob,vector<int>& alice){\\n        int prevProfit = 0;\\n        for(int i=0;i<ans.size();i++){\\n            if(ans[i] > alice[i]) prevProfit += i;\\n        }\\n\\n        int newProfit = 0;\\n        for(int i=0;i<bob.size();i++){\\n            if(bob[i] > alice[i]) newProfit += i;\\n        }\\n\\n        return newProfit > prevProfit;\\n    }\\n\\n    void helper(int i,int numArrows,vector<int>& alice,vector<int>&bob){\\n        if(i==0){\\n            bob[i] = numArrows;\\n            if(checkProfit(bob,alice)) ans = bob;\\n            bob[i] = 0;\\n            return;\\n        }\\n        if(numArrows - alice[i] - 1 >= 0){\\n            bob[i] = alice[i] + 1;\\n            helper(i-1,numArrows - alice[i] - 1,alice,bob);\\n            bob[i] = 0;\\n        }\\n\\n        helper(i-1,numArrows,alice,bob);\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>bob(12,0);\\n        helper(11,numArrows,aliceArrows,bob);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate : \\n    vector<int> ans;\\n    bool checkProfit(vector<int>&bob,vector<int>& alice){\\n        int prevProfit = 0;\\n        for(int i=0;i<ans.size();i++){\\n            if(ans[i] > alice[i]) prevProfit += i;\\n        }\\n\\n        int newProfit = 0;\\n        for(int i=0;i<bob.size();i++){\\n            if(bob[i] > alice[i]) newProfit += i;\\n        }\\n\\n        return newProfit > prevProfit;\\n    }\\n\\n    void helper(int i,int numArrows,vector<int>& alice,vector<int>&bob){\\n        if(i==0){\\n            bob[i] = numArrows;\\n            if(checkProfit(bob,alice)) ans = bob;\\n            bob[i] = 0;\\n            return;\\n        }\\n        if(numArrows - alice[i] - 1 >= 0){\\n            bob[i] = alice[i] + 1;\\n            helper(i-1,numArrows - alice[i] - 1,alice,bob);\\n            bob[i] = 0;\\n        }\\n\\n        helper(i-1,numArrows,alice,bob);\\n    }\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>bob(12,0);\\n        helper(11,numArrows,aliceArrows,bob);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013050,
                "title": "6comp30day-c-easy-solution-backtracking-made-easy",
                "content": "# Intuition\\nFrom question and contraints it was preety clear that It could be solved by trying all the ways so i choose backtracking.\\n\\n# Approch\\nDo recursion till index!=0 and others things see from simple code\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void recur(int &sum, vector<int>&v , int n , int ind ,vector<int>given, vector<int>&ans ,int curr_sum){\\n        if(ind<0){\\n            if(curr_sum>sum){\\n                // cout<<curr_sum<<\" \"<<sum<<\" \";\\n                sum=curr_sum;\\n                v[0]+=n;\\n                ans=v;\\n                //I was checking here some errors\\n                // for(auto i:v){\\n                //     cout<<i<<\" \";\\n                // }\\n                // cout<<endl;\\n            }\\n            return;\\n        }\\n\\n// if we are able to add arrows for that index\\n        if(n-(given[ind]+1)>=0){\\n            v[ind]=given[ind]+1;\\n            n-=(given[ind]+1);\\n            curr_sum+=ind;\\n            recur(sum,v,n,ind-1,given,ans,curr_sum);\\n            v[ind]=0;\\n            n+=(given[ind]+1);\\n            curr_sum-=ind;\\n        }\\n        \\n        recur(sum,v,n,ind-1,given,ans,curr_sum);\\n    }\\n\\n    vector<int> maximumBobPoints(int n, vector<int>& aliceArrows) {\\n        vector<int>v(12,0) , ans;\\n        int sum=0;\\n\\n        sum=0;\\n\\n        int c=0;\\n        recur(sum,v,n,11,aliceArrows,ans,c);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void recur(int &sum, vector<int>&v , int n , int ind ,vector<int>given, vector<int>&ans ,int curr_sum){\\n        if(ind<0){\\n            if(curr_sum>sum){\\n                // cout<<curr_sum<<\" \"<<sum<<\" \";\\n                sum=curr_sum;\\n                v[0]+=n;\\n                ans=v;\\n                //I was checking here some errors\\n                // for(auto i:v){\\n                //     cout<<i<<\" \";\\n                // }\\n                // cout<<endl;\\n            }\\n            return;\\n        }\\n\\n// if we are able to add arrows for that index\\n        if(n-(given[ind]+1)>=0){\\n            v[ind]=given[ind]+1;\\n            n-=(given[ind]+1);\\n            curr_sum+=ind;\\n            recur(sum,v,n,ind-1,given,ans,curr_sum);\\n            v[ind]=0;\\n            n+=(given[ind]+1);\\n            curr_sum-=ind;\\n        }\\n        \\n        recur(sum,v,n,ind-1,given,ans,curr_sum);\\n    }\\n\\n    vector<int> maximumBobPoints(int n, vector<int>& aliceArrows) {\\n        vector<int>v(12,0) , ans;\\n        int sum=0;\\n\\n        sum=0;\\n\\n        int c=0;\\n        recur(sum,v,n,11,aliceArrows,ans,c);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2915420,
                "title": "hello-love",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void func(vector<int> &a,vector<int> b,vector<int> &c,long long int s,int i,int n,int &ans)\\n    {\\n        if(n<0)\\n        {\\n            return;\\n        }\\n        if(i<0)\\n        {\\n            return ;\\n        }\\n        if(n==0 && i>0)\\n        {\\n            if(s>ans)\\n            {\\n                ans=s;\\n                c=b;\\n            }\\n            return ;\\n        }\\n        if(i==0)\\n        {\\n            if(s>ans)\\n            {\\n                ans=s;\\n                b[i]=n;\\n                c=b;\\n            }\\n            return ;\\n        }\\n        b[i]=a[i]+1;\\n        func(a,b,c,s+i,i-1,n-(b[i]),ans);\\n        b[i]=0;\\n        func(a,b,c,s,i-1,n,ans);\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n=numArrows,ans=INT_MIN;\\n        vector<int> b(12,0),c;\\n        func(aliceArrows,b,c,0,11,n,ans);\\n        cout << ans;\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void func(vector<int> &a,vector<int> b,vector<int> &c,long long int s,int i,int n,int &ans)\\n    {\\n        if(n<0)\\n        {\\n            return;\\n        }\\n        if(i<0)\\n        {\\n            return ;\\n        }\\n        if(n==0 && i>0)\\n        {\\n            if(s>ans)\\n            {\\n                ans=s;\\n                c=b;\\n            }\\n            return ;\\n        }\\n        if(i==0)\\n        {\\n            if(s>ans)\\n            {\\n                ans=s;\\n                b[i]=n;\\n                c=b;\\n            }\\n            return ;\\n        }\\n        b[i]=a[i]+1;\\n        func(a,b,c,s+i,i-1,n-(b[i]),ans);\\n        b[i]=0;\\n        func(a,b,c,s,i-1,n,ans);\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n=numArrows,ans=INT_MIN;\\n        vector<int> b(12,0),c;\\n        func(aliceArrows,b,c,0,11,n,ans);\\n        cout << ans;\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2907891,
                "title": "cool-n-simple-backtracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        \\n        self.max_score = 0\\n        self.take = set()\\n        bobArrows = [0]\\n        self.max_list = []\\n        self.final = set()\\n        self.free_arrows = 0\\n        def backTrack(i,arrows_used,score):\\n            \\n            if i == len(aliceArrows):\\n                if score > self.max_score:\\n                    self.free_arrows = numArrows - arrows_used\\n                    self.max_score = score\\n                    self.final = self.take.copy()\\n                return\\n\\n\\n            if arrows_used + aliceArrows[i] + 1 <=  numArrows:\\n                bobArrows.append(aliceArrows[i] + 1)\\n                self.take.add(i)\\n                backTrack(i+1,arrows_used + aliceArrows[i] + 1,score + i)\\n                bobArrows.pop()\\n                self.take.discard(i)\\n            \\n            bobArrows.append(0)\\n            backTrack(i+1,arrows_used,score)\\n            # bobArrows.pop()\\n\\n        backTrack(1,0,0)\\n        ans = [0 for i in range(12)]\\n\\n        for ind in self.final:\\n            ans[ind] = aliceArrows[ind] + 1\\n        ans[0] = self.free_arrows\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        \\n        self.max_score = 0\\n        self.take = set()\\n        bobArrows = [0]\\n        self.max_list = []\\n        self.final = set()\\n        self.free_arrows = 0\\n        def backTrack(i,arrows_used,score):\\n            \\n            if i == len(aliceArrows):\\n                if score > self.max_score:\\n                    self.free_arrows = numArrows - arrows_used\\n                    self.max_score = score\\n                    self.final = self.take.copy()\\n                return\\n\\n\\n            if arrows_used + aliceArrows[i] + 1 <=  numArrows:\\n                bobArrows.append(aliceArrows[i] + 1)\\n                self.take.add(i)\\n                backTrack(i+1,arrows_used + aliceArrows[i] + 1,score + i)\\n                bobArrows.pop()\\n                self.take.discard(i)\\n            \\n            bobArrows.append(0)\\n            backTrack(i+1,arrows_used,score)\\n            # bobArrows.pop()\\n\\n        backTrack(1,0,0)\\n        ans = [0 for i in range(12)]\\n\\n        for ind in self.final:\\n            ans[ind] = aliceArrows[ind] + 1\\n        ans[0] = self.free_arrows\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886423,
                "title": "c-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> aliceArrows;\\n    int cur_max = 0;\\n    vector<int> max_path;\\n\\n    void recur(int score_sec, int arrow_left, int score_won, vector<int> &path) {\\n        if (arrow_left < 0) return;\\n\\n        if (score_sec == -1) {\\n            if (score_won > cur_max) {\\n                cur_max = score_won;\\n                max_path = path;\\n                max_path[max_path.size() - 1] += arrow_left;\\n            }\\n            return;\\n        }\\n\\n        // win\\n        path.push_back(aliceArrows[score_sec] + 1);\\n        recur(score_sec - 1, arrow_left - aliceArrows[score_sec] - 1, score_won + score_sec, path);\\n        path.pop_back();\\n\\n        // lose\\n        path.push_back(0);\\n        recur(score_sec - 1, arrow_left, score_won, path);\\n        path.pop_back();\\n\\n    }\\n\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        this->aliceArrows = aliceArrows;\\n        vector<int> path;\\n        recur(11, numArrows, 0, path);\\n        reverse(max_path.begin(), max_path.end());\\n        return max_path;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> aliceArrows;\\n    int cur_max = 0;\\n    vector<int> max_path;\\n\\n    void recur(int score_sec, int arrow_left, int score_won, vector<int> &path) {\\n        if (arrow_left < 0) return;\\n\\n        if (score_sec == -1) {\\n            if (score_won > cur_max) {\\n                cur_max = score_won;\\n                max_path = path;\\n                max_path[max_path.size() - 1] += arrow_left;\\n            }\\n            return;\\n        }\\n\\n        // win\\n        path.push_back(aliceArrows[score_sec] + 1);\\n        recur(score_sec - 1, arrow_left - aliceArrows[score_sec] - 1, score_won + score_sec, path);\\n        path.pop_back();\\n\\n        // lose\\n        path.push_back(0);\\n        recur(score_sec - 1, arrow_left, score_won, path);\\n        path.pop_back();\\n\\n    }\\n\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        this->aliceArrows = aliceArrows;\\n        vector<int> path;\\n        recur(11, numArrows, 0, path);\\n        reverse(max_path.begin(), max_path.end());\\n        return max_path;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759825,
                "title": "c-backtrack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    //  Backtrack tc: O(n*2^n)       n=12 becos total number of possibilities are 12    \\n    int m=0;\\n    vector<int> bob;\\n    \\n    void helper(int numArrows, vector<int>&alice, vector<int>&arrows, int score, int index,int n)\\n    {\\n        if(index == n)\\n        {\\n            if(m<score)\\n            {\\n                m=score;\\n                bob=arrows;\\n                bob[0]+=numArrows;\\n            }\\n            return;\\n        }\\n        \\n        //let alice win- no effect on Bob\\n        arrows.push_back(0);\\n        helper(numArrows, alice, arrows,score, index+1, n);\\n        arrows.pop_back();\\n        \\n        //now try for bob to win\\n        if(alice[index]+1 <= numArrows)\\n        {\\n            arrows.push_back(alice[index]+1);\\n            helper(numArrows-alice[index]-1, alice, arrows,score+index, index+1,  n);\\n            arrows.pop_back();\\n        }   \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aA) \\n    {\\n        vector<int> arrows;\\n        int n=aA.size();\\n        helper(numArrows, aA, arrows, 0, 0, n);\\n        return bob;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //  Backtrack tc: O(n*2^n)       n=12 becos total number of possibilities are 12    \\n    int m=0;\\n    vector<int> bob;\\n    \\n    void helper(int numArrows, vector<int>&alice, vector<int>&arrows, int score, int index,int n)\\n    {\\n        if(index == n)\\n        {\\n            if(m<score)\\n            {\\n                m=score;\\n                bob=arrows;\\n                bob[0]+=numArrows;\\n            }\\n            return;\\n        }\\n        \\n        //let alice win- no effect on Bob\\n        arrows.push_back(0);\\n        helper(numArrows, alice, arrows,score, index+1, n);\\n        arrows.pop_back();\\n        \\n        //now try for bob to win\\n        if(alice[index]+1 <= numArrows)\\n        {\\n            arrows.push_back(alice[index]+1);\\n            helper(numArrows-alice[index]-1, alice, arrows,score+index, index+1,  n);\\n            arrows.pop_back();\\n        }   \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aA) \\n    {\\n        vector<int> arrows;\\n        int n=aA.size();\\n        helper(numArrows, aA, arrows, 0, 0, n);\\n        return bob;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745693,
                "title": "python-recursive-solution",
                "content": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        resAr = [[]]\\n        temp = [0]*12\\n        mx = [0]\\n    \\n        def findMxPoints(i, arrows, sc):\\n            \\n            if i == 12 or arrows == 0:\\n                if mx[0] < sc:\\n                    resAr[0] = temp[:]\\n                    mx[0] = sc\\n                return \\n            \\n            findMxPoints(i+1, arrows, sc)\\n            \\n            if arrows >= aliceArrows[i]+1:\\n                temp[i] = aliceArrows[i]+1\\n                findMxPoints(i+1, arrows-aliceArrows[i]-1, sc+i)\\n                temp[i] = 0\\n                \\n        \\n        findMxPoints(0, numArrows, 0)\\n        \\n        return resAr[0]\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        resAr = [[]]\\n        temp = [0]*12\\n        mx = [0]\\n    \\n        def findMxPoints(i, arrows, sc):\\n            \\n            if i == 12 or arrows == 0:\\n                if mx[0] < sc:\\n                    resAr[0] = temp[:]\\n                    mx[0] = sc\\n                return \\n            \\n            findMxPoints(i+1, arrows, sc)\\n            \\n            if arrows >= aliceArrows[i]+1:\\n                temp[i] = aliceArrows[i]+1\\n                findMxPoints(i+1, arrows-aliceArrows[i]-1, sc+i)\\n                temp[i] = 0\\n                \\n        \\n        findMxPoints(0, numArrows, 0)\\n        \\n        return resAr[0]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2631197,
                "title": "c-easy-to-understand-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> bob = {0,0,0,0,0,0,0,0,0,0,0,0}, ans;\\n    int mx = 0;\\n    \\n    void mxPoints(int index , int score ,int numArrows,vector<int>& aliceArrows)\\n    {\\n        if(numArrows<=0 or index>=aliceArrows.size())\\n        {\\n            if(mx<score){\\n                ans=bob;\\n                mx=score;\\n            }\\n            return ;\\n        }\\n        \\n        for(int i = index ; i<aliceArrows.size() ; i++)\\n        {\\n            int curr = aliceArrows[i];\\n            \\n            int prevScore = score, prevNumArrows = numArrows;\\n            \\n            if(curr+1 <= numArrows)\\n            {\\n                bob[i]=curr+1;\\n                score+=i;\\n                numArrows-=(curr+1);\\n            }\\n            \\n            mxPoints(i+1,score,numArrows,aliceArrows);\\n            \\n            bob[i]=0;\\n            \\n            score= prevScore,numArrows = prevNumArrows;\\n        }\\n        \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows)\\n    {\\n        mxPoints(0,0,numArrows,aliceArrows);   \\n        \\n        int bobArrows = 0;\\n        \\n        for(int i =0 ; i<12 ;i++) bobArrows+=ans[i];\\n        \\n        if(bobArrows < numArrows){\\n            ans[0]+=numArrows-bobArrows;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> bob = {0,0,0,0,0,0,0,0,0,0,0,0}, ans;\\n    int mx = 0;\\n    \\n    void mxPoints(int index , int score ,int numArrows,vector<int>& aliceArrows)\\n    {\\n        if(numArrows<=0 or index>=aliceArrows.size())\\n        {\\n            if(mx<score){\\n                ans=bob;\\n                mx=score;\\n            }\\n            return ;\\n        }\\n        \\n        for(int i = index ; i<aliceArrows.size() ; i++)\\n        {\\n            int curr = aliceArrows[i];\\n            \\n            int prevScore = score, prevNumArrows = numArrows;\\n            \\n            if(curr+1 <= numArrows)\\n            {\\n                bob[i]=curr+1;\\n                score+=i;\\n                numArrows-=(curr+1);\\n            }\\n            \\n            mxPoints(i+1,score,numArrows,aliceArrows);\\n            \\n            bob[i]=0;\\n            \\n            score= prevScore,numArrows = prevNumArrows;\\n        }\\n        \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows)\\n    {\\n        mxPoints(0,0,numArrows,aliceArrows);   \\n        \\n        int bobArrows = 0;\\n        \\n        for(int i =0 ; i<12 ;i++) bobArrows+=ans[i];\\n        \\n        if(bobArrows < numArrows){\\n            ans[0]+=numArrows-bobArrows;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602112,
                "title": "easy-to-read-python-backtracking-solution",
                "content": "```\\n def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        def helper(self, idx, seq):\\n            if len(seq) > 12:\\n                return \\n            \\n            tot = 0\\n            for i in range(len(seq)):\\n                tot += seq[i][1]\\n            \\n            if tot > numArrows:\\n                return \\n            \\n            seq.append((idx, aliceArrows[idx]+1))\\n            tot += seq[-1][1]\\n                \\n            if tot <= numArrows:\\n                score = 0\\n                for i in range(len(seq)):\\n                    score += seq[i][0]\\n                if score > self.maxscore:\\n                    self.result = seq.copy()\\n                    self.maxscore = score\\n                    self.total_arrows = tot\\n                    \\n            \\n            for i in range(idx+1, 12):\\n                helper(self, i, seq)\\n            \\n            seq.pop()\\n            \\n        \\n        self.result = []\\n        self.maxscore = 0\\n        self.total_arrow = 0\\n        for i in range(12):\\n            helper(self, i, [])\\n        \\n        out = 12*[0]\\n        for i in range(len(self.result)):\\n            out[self.result[i][0]] = self.result[i][1]\\n            \\n        if self.total_arrows < numArrows:\\n            out[0] += numArrows - self.total_arrows\\n            \\n        return out\\n",
                "solutionTags": [],
                "code": "```\\n def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        def helper(self, idx, seq):\\n            if len(seq) > 12:\\n                return \\n            \\n            tot = 0\\n            for i in range(len(seq)):\\n                tot += seq[i][1]\\n            \\n            if tot > numArrows:\\n                return \\n            \\n            seq.append((idx, aliceArrows[idx]+1))\\n            tot += seq[-1][1]\\n                \\n            if tot <= numArrows:\\n                score = 0\\n                for i in range(len(seq)):\\n                    score += seq[i][0]\\n                if score > self.maxscore:\\n                    self.result = seq.copy()\\n                    self.maxscore = score\\n                    self.total_arrows = tot\\n                    \\n            \\n            for i in range(idx+1, 12):\\n                helper(self, i, seq)\\n            \\n            seq.pop()\\n            \\n        \\n        self.result = []\\n        self.maxscore = 0\\n        self.total_arrow = 0\\n        for i in range(12):\\n            helper(self, i, [])\\n        \\n        out = 12*[0]\\n        for i in range(len(self.result)):\\n            out[self.result[i][0]] = self.result[i][1]\\n            \\n        if self.total_arrows < numArrows:\\n            out[0] += numArrows - self.total_arrows\\n            \\n        return out\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2552766,
                "title": "python-3-dp-solution",
                "content": "This problem has recurring subproblems, which can be computed and stored, making a DP approach the optimal one\\n\\n```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        # DP, table to store the max score for current section and number of arrows\\n        dp = [[-1 for _ in range(numArrows + 1)] for _ in range(12)]\\n        # minArrowsForBobToWin stores bob arrows to win in each section\\n        # bobMaxScore stores result bob arrows for max score\\n        minArrowsForBobToWin, bobMaxScore = [aliceArrows[i] + 1 for i in range(len(aliceArrows))], [0 for _ in range(12)]\\n        \\n        # Helper function to find max score for each number of arrows upto the actual number of arrows\\n        # for all the sections upto a given section\\n        def findMaxScore(section: int, numArrows: int, dp: List[List[int]], minArrowsForBobToWin: List[int]) -> int:\\n            # base case\\n            # return score 0 for arrows <= 0 or section <= 0\\n            if numArrows <= 0 or section <= 0:\\n                return 0\\n            # returning precalculated result\\n            if dp[section][numArrows] != -1:\\n                return dp[section][numArrows]\\n            # Variables to store the scores if the current section is taken or not\\n            taken, notTaken = 0, 0\\n            # if remaining arrows >= minArrowsForBobToWin[section] then we can take current section \\n            # and call recursively\\n            if numArrows >= minArrowsForBobToWin[section]:\\n                taken =  section + findMaxScore(section - 1, numArrows - minArrowsForBobToWin[section], dp, minArrowsForBobToWin)\\n            # recursive call without taking current section\\n            notTaken = findMaxScore(section - 1, numArrows, dp, minArrowsForBobToWin)\\n            # get max score from taken and not taken case\\n            dp[section][numArrows] = max(taken, notTaken)\\n            return dp[section][numArrows]\\n        \\n        # find maximum score bob can obtain\\n        findMaxScore(11, numArrows, dp, minArrowsForBobToWin)\\n        # find bob\\'s arrows for each section starting from max score section\\n        for i in range(11, 0, -1):\\n            if numArrows >= minArrowsForBobToWin[i] and dp[i][numArrows] > dp[i - 1][numArrows]:\\n                bobMaxScore[i] = minArrowsForBobToWin[i]\\n                numArrows -= minArrowsForBobToWin[i]\\n                if numArrows <= 0:\\n                    break\\n        # add remaining arrows in section 0\\n        if numArrows > 0:\\n            bobMaxScore[0] = numArrows\\n        return bobMaxScore\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        # DP, table to store the max score for current section and number of arrows\\n        dp = [[-1 for _ in range(numArrows + 1)] for _ in range(12)]\\n        # minArrowsForBobToWin stores bob arrows to win in each section\\n        # bobMaxScore stores result bob arrows for max score\\n        minArrowsForBobToWin, bobMaxScore = [aliceArrows[i] + 1 for i in range(len(aliceArrows))], [0 for _ in range(12)]\\n        \\n        # Helper function to find max score for each number of arrows upto the actual number of arrows\\n        # for all the sections upto a given section\\n        def findMaxScore(section: int, numArrows: int, dp: List[List[int]], minArrowsForBobToWin: List[int]) -> int:\\n            # base case\\n            # return score 0 for arrows <= 0 or section <= 0\\n            if numArrows <= 0 or section <= 0:\\n                return 0\\n            # returning precalculated result\\n            if dp[section][numArrows] != -1:\\n                return dp[section][numArrows]\\n            # Variables to store the scores if the current section is taken or not\\n            taken, notTaken = 0, 0\\n            # if remaining arrows >= minArrowsForBobToWin[section] then we can take current section \\n            # and call recursively\\n            if numArrows >= minArrowsForBobToWin[section]:\\n                taken =  section + findMaxScore(section - 1, numArrows - minArrowsForBobToWin[section], dp, minArrowsForBobToWin)\\n            # recursive call without taking current section\\n            notTaken = findMaxScore(section - 1, numArrows, dp, minArrowsForBobToWin)\\n            # get max score from taken and not taken case\\n            dp[section][numArrows] = max(taken, notTaken)\\n            return dp[section][numArrows]\\n        \\n        # find maximum score bob can obtain\\n        findMaxScore(11, numArrows, dp, minArrowsForBobToWin)\\n        # find bob\\'s arrows for each section starting from max score section\\n        for i in range(11, 0, -1):\\n            if numArrows >= minArrowsForBobToWin[i] and dp[i][numArrows] > dp[i - 1][numArrows]:\\n                bobMaxScore[i] = minArrowsForBobToWin[i]\\n                numArrows -= minArrowsForBobToWin[i]\\n                if numArrows <= 0:\\n                    break\\n        # add remaining arrows in section 0\\n        if numArrows > 0:\\n            bobMaxScore[0] = numArrows\\n        return bobMaxScore\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543061,
                "title": "python-3-backtracking",
                "content": "\\tclass Solution:\\n\\t\\tdef maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n\\t\\t\\tself.max=0\\n\\t\\t\\tdef solve(n,i,A,v):\\n\\t\\t\\t\\tif i==12:\\n\\t\\t\\t\\t\\tif v>self.max:\\n\\t\\t\\t\\t\\t\\tself.max=v\\n\\t\\t\\t\\t\\t\\tself.res=list(A)\\n\\t\\t\\t\\t\\t\\tself.left=n\\n\\t\\t\\t\\t\\treturn \\n\\t\\t\\t\\tsolve(n,i+1,A,v)\\n\\t\\t\\t\\tif n>aliceArrows[i]:\\n\\t\\t\\t\\t\\tA[i]=aliceArrows[i]+1\\n\\t\\t\\t\\t\\tsolve(n-aliceArrows[i]-1,i+1,A,v+i)\\n\\t\\t\\t\\t\\tA[i]=0\\n\\t\\t\\tsolve(numArrows,0,[0]*12,0)\\n\\t\\t\\tif self.left:\\n\\t\\t\\t\\tfor i in range(12):\\n\\t\\t\\t\\t\\tif self.res[i]>aliceArrows[i]:\\n\\t\\t\\t\\t\\t\\tself.res[i]+=self.left\\n\\t\\t\\t\\t\\t\\treturn self.res\\n\\t\\t\\treturn self.res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n\\t\\t\\tself.max=0\\n\\t\\t\\tdef solve(n,i,A,v):\\n\\t\\t\\t\\tif i==12:\\n\\t\\t\\t\\t\\tif v>self.max:\\n\\t\\t\\t\\t\\t\\tself.max=v\\n\\t\\t\\t\\t\\t\\tself.res=list(A)\\n\\t\\t\\t\\t\\t\\tself.left=n\\n\\t\\t\\t\\t\\treturn \\n\\t\\t\\t\\tsolve(n,i+1,A,v)\\n\\t\\t\\t\\tif n>aliceArrows[i]:\\n\\t\\t\\t\\t\\tA[i]=aliceArrows[i]+1\\n\\t\\t\\t\\t\\tsolve(n-aliceArrows[i]-1,i+1,A,v+i)\\n\\t\\t\\t\\t\\tA[i]=0\\n\\t\\t\\tsolve(numArrows,0,[0]*12,0)\\n\\t\\t\\tif self.left:\\n\\t\\t\\t\\tfor i in range(12):\\n\\t\\t\\t\\t\\tif self.res[i]>aliceArrows[i]:\\n\\t\\t\\t\\t\\t\\tself.res[i]+=self.left\\n\\t\\t\\t\\t\\t\\treturn self.res\\n\\t\\t\\treturn self.res",
                "codeTag": "Java"
            },
            {
                "id": 2520223,
                "title": "c-solution-backtracking-approach-explained",
                "content": "\\uD83D\\uDC49 Approach :- Standing at any index we will decide whether to shoot more arrows than alice (If available) or not. And when we reach index == 12 and our current score is greater than the max score then we update our answer vector to our current vector. \\n\\n**CODE:-**\\n\\nclass Solution {\\npublic:\\n*     vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {       \\n        vector<int>temp;\\n        int maxscore = INT_MIN;\\n        vector<int>ans;\\n        solve(aliceArrows,0,temp,0,maxscore,numArrows, ans);\\n        long long sum = 0;\\n        for(int i = 0;i < ans.size(); i++)\\n        {\\n            sum += ans[i];\\n        }\\n        if(sum < numArrows)\\n        {\\n            ans[0] += numArrows-sum;\\n        }\\n        return ans;\\n    }\\n    \\n*     void solve(vector<int>& alice, int ind, vector<int>temp, int score, int& maxscore, int remaining,vector<int>& ans){\\n        if(ind == 11)\\n        {\\n            temp.push_back(remaining);\\n            if(remaining > alice[ind])\\n            {\\n                score += ind;\\n            }\\n            if(score > maxscore)\\n            {\\n                maxscore = score;\\n                ans = temp;\\n            }\\n            return ;\\n        }\\n        if(remaining > alice[ind])\\n        {\\n            temp.push_back(alice[ind]+1);\\n            solve(alice,ind+1,temp,score+ind,maxscore,remaining-(alice[ind]+1),ans);\\n            temp.pop_back();\\n        }\\n        temp.push_back(0);\\n        solve(alice,ind+1,temp,score,maxscore,remaining, ans);\\n        temp.pop_back();\\n    }\\n};\\n**DO upvote if you understood it !**",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n*     vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {       \\n        vector<int>temp;\\n        int maxscore = INT_MIN;\\n        vector<int>ans;\\n        solve(aliceArrows,0,temp,0,maxscore,numArrows, ans);\\n        long long sum = 0;\\n        for(int i = 0;i < ans.size(); i++)\\n        {\\n            sum += ans[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2499795,
                "title": "typescript-simple-bitmask-iterative-solution-o-2-n-n",
                "content": "Simply enumerate through all possible subsets of arrows distribution\\nIf there is a case when fewer number of arrows is enough to achieve the result, just add the rest to 0 score section\\n\\n```\\nfunction maximumBobPoints(numArrows: number, aliceArrows: number[]): number[] {\\n  const n = 12;\\n  const maxMask = 1 << n;\\n  \\n  let res = 0;\\n  let bobArrows;\\n  for(let i=1; i<maxMask; i++) {\\n    let score = 0;\\n    let totalArrows = 0;\\n    const currArrows = Array(n).fill(0);\\n    for(let j=0; j<n; j++) {\\n      if(i & (1 << j)) {\\n        score += j;\\n        currArrows[j] = aliceArrows[j] + 1;\\n        totalArrows += aliceArrows[j] + 1;\\n      }  \\n    }\\n    \\n    const rest = numArrows - totalArrows;\\n    \\n    if (rest >= 0 && score > res) {\\n      res = score;\\n      currArrows[0] += rest;\\n      bobArrows = currArrows;\\n    }\\n  }\\n  \\n  return bobArrows;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\nfunction maximumBobPoints(numArrows: number, aliceArrows: number[]): number[] {\\n  const n = 12;\\n  const maxMask = 1 << n;\\n  \\n  let res = 0;\\n  let bobArrows;\\n  for(let i=1; i<maxMask; i++) {\\n    let score = 0;\\n    let totalArrows = 0;\\n    const currArrows = Array(n).fill(0);\\n    for(let j=0; j<n; j++) {\\n      if(i & (1 << j)) {\\n        score += j;\\n        currArrows[j] = aliceArrows[j] + 1;\\n        totalArrows += aliceArrows[j] + 1;\\n      }  \\n    }\\n    \\n    const rest = numArrows - totalArrows;\\n    \\n    if (rest >= 0 && score > res) {\\n      res = score;\\n      currArrows[0] += rest;\\n      bobArrows = currArrows;\\n    }\\n  }\\n  \\n  return bobArrows;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2468628,
                "title": "c-solution-using-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    int max_score=0;\\n    void find(int index,int usearrow,int score,vector<int>&alice,vector<int>&temp)\\n    {\\n        if(index==12)\\n        {\\n            if(max_score<score)\\n            {\\n                max_score=score;\\n                ans=temp;\\n                if(usearrow)\\n                {\\n                    ans.back()+=usearrow;\\n                }\\n            }\\n            return ;\\n        }\\n        int need=alice[index]+1;\\n        if(usearrow>=need)\\n        {\\n            temp[index]=need;\\n            find(index+1,usearrow-need,score+index,alice,temp);\\n            temp[index]=0;\\n        }\\n        find(index+1,usearrow,score,alice,temp);\\n    }\\n    vector<int> maximumBobPoints(int num, vector<int>& alice) \\n    {    \\n        vector<int>temp(12);\\n        find(0,num,0,alice,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    int max_score=0;\\n    void find(int index,int usearrow,int score,vector<int>&alice,vector<int>&temp)\\n    {\\n        if(index==12)\\n        {\\n            if(max_score<score)\\n            {\\n                max_score=score;\\n                ans=temp;\\n                if(usearrow)\\n                {\\n                    ans.back()+=usearrow;\\n                }\\n            }\\n            return ;\\n        }\\n        int need=alice[index]+1;\\n        if(usearrow>=need)\\n        {\\n            temp[index]=need;\\n            find(index+1,usearrow-need,score+index,alice,temp);\\n            temp[index]=0;\\n        }\\n        find(index+1,usearrow,score,alice,temp);\\n    }\\n    vector<int> maximumBobPoints(int num, vector<int>& alice) \\n    {    \\n        vector<int>temp(12);\\n        find(0,num,0,alice,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467750,
                "title": "c-solution-using-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(int mask,vector<int>&nums,int &arrow,vector<int>&temp)\\n    {\\n        int score=0;\\n        for(int i=0;i<12;i++)\\n        {\\n            if(mask&(1<<i))\\n            {\\n                int need=nums[i]+1;\\n                if(need>arrow)\\n                {\\n                    return -1;\\n                }\\n                temp[i]=need;\\n                score+=i;\\n                arrow-=need;\\n            }\\n        }\\n        return score;\\n    }\\n    vector<int> maximumBobPoints(int num, vector<int>& alice) \\n    {    \\n        vector<int>ans(12,0);\\n        vector<int>temp(12,0);\\n        int max_score=0;\\n        for(int i=0;i<(1<<12);i++)\\n        {\\n            int usearrow=num;\\n            int score=find(i,alice,usearrow,temp);\\n            if(score!=-1&&max_score<score)\\n            {\\n                max_score=score;\\n                ans=temp;\\n                if(usearrow)\\n                {\\n                    ans[0]+=usearrow;\\n                }\\n            }\\n            temp=vector<int>(12,0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int mask,vector<int>&nums,int &arrow,vector<int>&temp)\\n    {\\n        int score=0;\\n        for(int i=0;i<12;i++)\\n        {\\n            if(mask&(1<<i))\\n            {\\n                int need=nums[i]+1;\\n                if(need>arrow)\\n                {\\n                    return -1;\\n                }\\n                temp[i]=need;\\n                score+=i;\\n                arrow-=need;\\n            }\\n        }\\n        return score;\\n    }\\n    vector<int> maximumBobPoints(int num, vector<int>& alice) \\n    {    \\n        vector<int>ans(12,0);\\n        vector<int>temp(12,0);\\n        int max_score=0;\\n        for(int i=0;i<(1<<12);i++)\\n        {\\n            int usearrow=num;\\n            int score=find(i,alice,usearrow,temp);\\n            if(score!=-1&&max_score<score)\\n            {\\n                max_score=score;\\n                ans=temp;\\n                if(usearrow)\\n                {\\n                    ans[0]+=usearrow;\\n                }\\n            }\\n            temp=vector<int>(12,0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447565,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    vector<int> maximumBobPoints(int n, vector<int>& v) {\\n        ll res = -1, resMax = -1;\\n        for (ll i = 0;i < (1 << 12);++i) {\\n            ll sum = 0, score = 0;\\n            for (ll j = 0;j < 12;++j) {\\n                if (i & (1 << j)) {\\n                    sum += v[j] + 1;\\n                    score += j;\\n                }\\n            }\\n            if (sum <= n && score >= resMax) {\\n                resMax = score;\\n                res = i;\\n            }\\n        }\\n        for (ll i = 0;i < 12;++i) {\\n            if (res & (1 << i)) {\\n                ++v[i];\\n            }\\n            else {\\n                v[i] = 0;\\n            }\\n        }\\n        v.back() += n - accumulate(v.begin(), v.end(), 0);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    vector<int> maximumBobPoints(int n, vector<int>& v) {\\n        ll res = -1, resMax = -1;\\n        for (ll i = 0;i < (1 << 12);++i) {\\n            ll sum = 0, score = 0;\\n            for (ll j = 0;j < 12;++j) {\\n                if (i & (1 << j)) {\\n                    sum += v[j] + 1;\\n                    score += j;\\n                }\\n            }\\n            if (sum <= n && score >= resMax) {\\n                resMax = score;\\n                res = i;\\n            }\\n        }\\n        for (ll i = 0;i < 12;++i) {\\n            if (res & (1 << i)) {\\n                ++v[i];\\n            }\\n            else {\\n                v[i] = 0;\\n            }\\n        }\\n        v.back() += n - accumulate(v.begin(), v.end(), 0);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441230,
                "title": "c-backtracking-faster-than-85-runtime",
                "content": "````\\nclass Solution {\\npublic:\\n    void findmax(int n,int &tot,int num,vector<int>&path,vector<int>&alice,vector<int>&ans){\\n        if(num==0 || n <= 1){\\n            int sum=0;\\n            for(int i=0;i<path.size();i++){\\n                //cout<<path[i]<<\" \";\\n                sum += path[i];\\n            }\\n            // cout<<endl;\\n            // cout<<sum<<endl;\\n            if(sum > tot){\\n                ans = path;\\n                tot= sum;\\n            }\\n            return;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(num >= (alice[i]+1)){\\n            path.push_back(i);\\n            findmax(i,tot,num-(alice[i]+1),path,alice,ans);\\n            path.pop_back();\\n            }\\n        } \\n    }\\n    vector<int> maximumBobPoints(int num, vector<int>& alice) {\\n        vector<int>path,ans;\\n        int tot=0;\\n        int m= num;\\n        findmax(12,tot,num,path,alice,ans);\\n        // for(int i=0;i<ans.size();i++){\\n        //     cout<<ans[i]<<\" \";\\n        // }\\n        //cout<<endl;\\n        vector<int>res(12,0);\\n        for(int i=0;i<ans.size();i++){\\n            int k= ans[i];\\n            res[k]= alice[k]+1;\\n            m-= (alice[k]+1);\\n        }\\n        if(m!=0)\\n            res[0] += m;\\n        return res;\\n    }\\n};\\n````",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    void findmax(int n,int &tot,int num,vector<int>&path,vector<int>&alice,vector<int>&ans){\\n        if(num==0 || n <= 1){\\n            int sum=0;\\n            for(int i=0;i<path.size();i++){\\n                //cout<<path[i]<<\" \";\\n                sum += path[i];\\n            }\\n            // cout<<endl;\\n            // cout<<sum<<endl;\\n            if(sum > tot){\\n                ans = path;\\n                tot= sum;\\n            }\\n            return;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(num >= (alice[i]+1)){\\n            path.push_back(i);\\n            findmax(i,tot,num-(alice[i]+1),path,alice,ans);\\n            path.pop_back();\\n            }\\n        } \\n    }\\n    vector<int> maximumBobPoints(int num, vector<int>& alice) {\\n        vector<int>path,ans;\\n        int tot=0;\\n        int m= num;\\n        findmax(12,tot,num,path,alice,ans);\\n        // for(int i=0;i<ans.size();i++){\\n        //     cout<<ans[i]<<\" \";\\n        // }\\n        //cout<<endl;\\n        vector<int>res(12,0);\\n        for(int i=0;i<ans.size();i++){\\n            int k= ans[i];\\n            res[k]= alice[k]+1;\\n            m-= (alice[k]+1);\\n        }\\n        if(m!=0)\\n            res[0] += m;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2434012,
                "title": "c-solution-faster-than-99-1-of-other-submissions",
                "content": "This Github repository, https://github.com/AnasImloul/Leetcode-solutions, has the answer I was looking for.\\nIt is extremely beneficial to me that all solutions are available in one location. I hope it is useful to you as well.\\n```\\nclass Solution {\\npublic:\\n    int maxscore; \\n    vector<int> ans;\\n    \\n    void helper(vector<int> &bob, int i, vector<int>& alice, int remarrows, int score)\\n    {\\n        if(i == -1  or  remarrows <= 0)\\n        {\\n            if(score >= maxscore)\\n            {\\n                maxscore = score; \\n                ans = bob; \\n            }\\n            return; \\n        }\\n        \\n        helper(bob, i-1, alice, remarrows, score);\\n        if(remarrows > alice[i])\\n        {\\n            bob[i] = alice[i] + 1;\\n            remarrows -= (alice[i] + 1);\\n            score += i; \\n            helper(bob, i-1, alice, remarrows, score);\\n            bob[i] = 0;\\n        } \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> bob(12, 0);\\n        maxscore = INT_MIN; \\n        helper(bob, 11, aliceArrows, numArrows, 0);\\n        \\n        int arrows_used = 0; \\n        for(int a : ans)\\n            arrows_used += a; \\n        if(arrows_used < numArrows)\\n            ans[0] += (numArrows - arrows_used);\\n        return ans; \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxscore; \\n    vector<int> ans;\\n    \\n    void helper(vector<int> &bob, int i, vector<int>& alice, int remarrows, int score)\\n    {\\n        if(i == -1  or  remarrows <= 0)\\n        {\\n            if(score >= maxscore)\\n            {\\n                maxscore = score; \\n                ans = bob; \\n            }\\n            return; \\n        }\\n        \\n        helper(bob, i-1, alice, remarrows, score);\\n        if(remarrows > alice[i])\\n        {\\n            bob[i] = alice[i] + 1;\\n            remarrows -= (alice[i] + 1);\\n            score += i; \\n            helper(bob, i-1, alice, remarrows, score);\\n            bob[i] = 0;\\n        } \\n    }\\n    \\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> bob(12, 0);\\n        maxscore = INT_MIN; \\n        helper(bob, 11, aliceArrows, numArrows, 0);\\n        \\n        int arrows_used = 0; \\n        for(int a : ans)\\n            arrows_used += a; \\n        if(arrows_used < numArrows)\\n            ans[0] += (numArrows - arrows_used);\\n        return ans; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424140,
                "title": "backtracking",
                "content": "class Solution {\\n \\npublic:\\n   vector<int> res;\\n    int max_sc;\\n    void func(int i,vector<int> &arr,int sc,vector<int>&v,int a)\\n    {\\n       \\n        if(i==arr.size()|| a==0)\\n        {\\n            if(sc>max_sc)\\n            {\\n                max_sc=sc;\\n                res.clear();\\n                res=v;\\n            }\\n           return;\\n        }\\n        \\n        if(a>arr[i])\\n        {\\n            v[i]=arr[i]+1;\\n            func(i+1,arr,sc+i,v,a-v[i]);\\n            v[i]=0;\\n        }\\n       \\n       func(i+1,arr,sc,v,a);\\n      \\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        res.clear();\\n        max_sc=0;\\n        vector<int> v(12,0);\\n        func(0,aliceArrows,0,v,numArrows);\\n        int a=0;\\n        for(int i=0;i<res.size();i++)\\n        {\\n            a+=res[i];\\n        }\\n        if(a<numArrows)\\n        {\\n            res[0]+=numArrows-a;\\n        }\\n        return res;\\n    }\\n    \\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n \\npublic:\\n   vector<int> res;\\n    int max_sc;\\n    void func(int i,vector<int> &arr,int sc,vector<int>&v,int a)\\n    {\\n       \\n        if(i==arr.size()|| a==0)\\n        {\\n            if(sc>max_sc)\\n            {\\n                max_sc=sc;\\n                res.clear();\\n                res=v;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2386602,
                "title": "python-recursion-top-down-approach-notes",
                "content": "```\\n\"\"\"\\nwe can try to solve this problem using recursion and memoization\\nat every point, we have a choice whether to shoot arrows there or not\\nif we decide to shoot the arrow, it would make sense to shoot one arrow more \\nthan what alice has shooted in that section to get the points awarded else\\nwe will skip that section\\n\"\"\"\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        lookup = {}\\n        self.ans = \"0\"*12\\n        self.max_score = 0\\n        result = [0 for _ in range(12)]\\n        def fun(index, rem_arrow, path, score):\\n            if index < 0 or rem_arrow == 0:\\n                if score > self.max_score:\\n                    self.max_score = score\\n                    self.ans = path\\n                return\\n            # try to shoot at current section (index)\\n            if rem_arrow > aliceArrows[index]:\\n                fun(index-1, rem_arrow-(aliceArrows[index]+1), path[:index] + \\'1\\' + path[index+1:], score+index)\\n            # skip shooting at current section\\n            fun(index-1, rem_arrow, path, score)\\n        fun(11, numArrows, \"0\"*12, 0)\\n        for i, char in enumerate(self.ans):\\n            if char == \\'1\\':\\n                result[i] = aliceArrows[i] + 1\\n        if sum(result) < numArrows:\\n            result[0] += numArrows - sum(result)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\"\"\"\\nwe can try to solve this problem using recursion and memoization\\nat every point, we have a choice whether to shoot arrows there or not\\nif we decide to shoot the arrow, it would make sense to shoot one arrow more \\nthan what alice has shooted in that section to get the points awarded else\\nwe will skip that section\\n\"\"\"\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        lookup = {}\\n        self.ans = \"0\"*12\\n        self.max_score = 0\\n        result = [0 for _ in range(12)]\\n        def fun(index, rem_arrow, path, score):\\n            if index < 0 or rem_arrow == 0:\\n                if score > self.max_score:\\n                    self.max_score = score\\n                    self.ans = path\\n                return\\n            # try to shoot at current section (index)\\n            if rem_arrow > aliceArrows[index]:\\n                fun(index-1, rem_arrow-(aliceArrows[index]+1), path[:index] + \\'1\\' + path[index+1:], score+index)\\n            # skip shooting at current section\\n            fun(index-1, rem_arrow, path, score)\\n        fun(11, numArrows, \"0\"*12, 0)\\n        for i, char in enumerate(self.ans):\\n            if char == \\'1\\':\\n                result[i] = aliceArrows[i] + 1\\n        if sum(result) < numArrows:\\n            result[0] += numArrows - sum(result)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375085,
                "title": "java-recursion-brute-force",
                "content": "```\\n\\nclass Solution {\\n    int bobsPoints = 0;\\n    int maxBobsPoints = 0;\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int index = 0; \\n        int[] ans1 = findMaxBobpoints(numArrows, aliceArrows, index, bobsPoints);\\n        int[] res = new int[12];\\n\\t\\t// while returning the answer I exclude the extra element that I added in the array to keep track of the max score path\\n        for(int i = 0; i < ans1.length - 1; ++i){ \\t\\n            res[i] = ans1[i];\\n        }\\n        return res;\\n    }\\n    \\n    private int[] findMaxBobpoints(int numArrows, int[] aliceArrows, int index,int bobsPoints){\\n        if(index == 12 ||  numArrows  <= 0){\\n            maxBobsPoints  = Math.max(bobsPoints, maxBobsPoints);\\n            int[] ans =  new int[13]; // one extra space in ans to keep track of which path returned the max score\\n            ans[12] = bobsPoints;\\n            if(numArrows > 0){ // if any arrows left add it to the section[0] \\n                ans[0] = numArrows;\\n            }\\n            return ans;\\n        }\\n\\n        int[] sectionSelected = new int[13];\\n        if(numArrows - (aliceArrows[index] + 1) >= 0){\\n\\t\\t\\tsectionSelected  = findMaxBobpoints(numArrows - (aliceArrows[index] + 1), aliceArrows, index + 1, bobsPoints + index);\\n\\t\\t\\tsectionSelected[index] += aliceArrows[index] + 1;\\n        }\\n        \\n        int[] sectionSkipped = findMaxBobpoints(numArrows, aliceArrows, index + 1, bobsPoints);\\n        \\n        if(sectionSelected[12] == maxBobsPoints){ // check if this is the path that returned the max score\\n            return sectionSelected;\\n        }\\n        else{\\n            return sectionSkipped;\\n        }\\n        \\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    int bobsPoints = 0;\\n    int maxBobsPoints = 0;\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int index = 0; \\n        int[] ans1 = findMaxBobpoints(numArrows, aliceArrows, index, bobsPoints);\\n        int[] res = new int[12];\\n\\t\\t// while returning the answer I exclude the extra element that I added in the array to keep track of the max score path\\n        for(int i = 0; i < ans1.length - 1; ++i){ \\t\\n            res[i] = ans1[i];\\n        }\\n        return res;\\n    }\\n    \\n    private int[] findMaxBobpoints(int numArrows, int[] aliceArrows, int index,int bobsPoints){\\n        if(index == 12 ||  numArrows  <= 0){\\n            maxBobsPoints  = Math.max(bobsPoints, maxBobsPoints);\\n            int[] ans =  new int[13]; // one extra space in ans to keep track of which path returned the max score\\n            ans[12] = bobsPoints;\\n            if(numArrows > 0){ // if any arrows left add it to the section[0] \\n                ans[0] = numArrows;\\n            }\\n            return ans;\\n        }\\n\\n        int[] sectionSelected = new int[13];\\n        if(numArrows - (aliceArrows[index] + 1) >= 0){\\n\\t\\t\\tsectionSelected  = findMaxBobpoints(numArrows - (aliceArrows[index] + 1), aliceArrows, index + 1, bobsPoints + index);\\n\\t\\t\\tsectionSelected[index] += aliceArrows[index] + 1;\\n        }\\n        \\n        int[] sectionSkipped = findMaxBobpoints(numArrows, aliceArrows, index + 1, bobsPoints);\\n        \\n        if(sectionSelected[12] == maxBobsPoints){ // check if this is the path that returned the max score\\n            return sectionSelected;\\n        }\\n        else{\\n            return sectionSkipped;\\n        }\\n        \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357543,
                "title": "java-memoization",
                "content": "class Solution {\\n    \\n    int bitsSum(int n){\\n        int ans = 0;\\n        for(int i=0;i<12;i++){\\n            if((n&(1<<i))==(1<<i))\\n                ans += i;\\n        }\\n        return ans;\\n    }\\n    \\n    int solve(int ind, int arrows,List<Map<Integer,Integer>> store,int[] arr){\\n        if(ind==12 || arrows==0)\\n            return 0;\\n        if(store.get(ind).containsKey(arrows))\\n            return store.get(ind).get(arrows);\\n        int res = solve(ind+1,arrows,store,arr);\\n        if(arrows>arr[ind]){\\n            int temp = (1<<ind) + solve(ind+1,arrows-arr[ind]-1,store,arr);\\n            if(bitsSum(temp) > bitsSum(res)){\\n                res = temp;\\n            }\\n        }\\n        store.get(ind).put(arrows,res);\\n        return res;\\n    }\\n    \\n    int[] findArray(int tot, int n,int arr[]){\\n        int[] ans = new int[12];\\n        for(int i=1;i<12;i++){\\n            if((tot&(1<<i))==(1<<i)){\\n                ans[i] = arr[i]+1;\\n                n -= (arr[i]+1);\\n            }\\n        }\\n        ans[0]=n;\\n        return ans;\\n    }\\n    \\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        List<Map<Integer,Integer>> store = new ArrayList<>();\\n        for(int i=0;i<12;i++){\\n            store.add(new HashMap<>());\\n        }\\n        return findArray(solve(0,numArrows,store,aliceArrows),numArrows,aliceArrows);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "class Solution {\\n    \\n    int bitsSum(int n){\\n        int ans = 0;\\n        for(int i=0;i<12;i++){\\n            if((n&(1<<i))==(1<<i))\\n                ans += i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2344201,
                "title": "python-backtrack-solution",
                "content": "```\\ndef maximumBobPoints(self, k: int, alice: List[int]) -> List[int]:\\n\\tself.mx = 0\\n\\tself.bob = None # binary string to record Bob\\'s winning section\\n\\n\\tdef btrack(idx, path, score, arr):\\n\\t\\tif idx<0 or arr==0:\\n\\t\\t\\tif score>self.mx:\\n\\t\\t\\t\\tself.mx = score\\n\\t\\t\\t\\tself.bob = path[:]\\n\\t\\t\\treturn\\n\\n\\t\\tif arr>alice[idx]:\\n\\t\\t\\tbtrack(idx-1, path[:idx]+\\'1\\'+path[idx+1:], score+idx, arr-alice[idx]-1)\\n\\n\\t\\tbtrack(idx-1, path, score, arr)\\n\\n\\tbtrack(11, \\'0\\'*12, 0, k)\\n\\tans = [alice[i]+1 if self.bob[i]==\\'1\\' else 0 for i in range(12)]\\n\\tans[-1] += (k-sum(ans))\\n\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef maximumBobPoints(self, k: int, alice: List[int]) -> List[int]:\\n\\tself.mx = 0\\n\\tself.bob = None # binary string to record Bob\\'s winning section\\n\\n\\tdef btrack(idx, path, score, arr):\\n\\t\\tif idx<0 or arr==0:\\n\\t\\t\\tif score>self.mx:\\n\\t\\t\\t\\tself.mx = score\\n\\t\\t\\t\\tself.bob = path[:]\\n\\t\\t\\treturn\\n\\n\\t\\tif arr>alice[idx]:\\n\\t\\t\\tbtrack(idx-1, path[:idx]+\\'1\\'+path[idx+1:], score+idx, arr-alice[idx]-1)\\n\\n\\t\\tbtrack(idx-1, path, score, arr)\\n\\n\\tbtrack(11, \\'0\\'*12, 0, k)\\n\\tans = [alice[i]+1 if self.bob[i]==\\'1\\' else 0 for i in range(12)]\\n\\tans[-1] += (k-sum(ans))\\n\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2307998,
                "title": "c-code-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    map<int,int> dp;\\n    int mx=0;\\n    \\n    int func(int n,vector<int> &v,int mask,int rem,vector<int> &temp,int scr){\\n       if (scr>mx){\\n          mx=scr;\\n          ans=temp;\\n        }\\n        \\n        if (mask==(pow(2,12)-1) || rem==0){\\n            return 0;\\n        }\\n        \\n        if (dp.find(mask)!=dp.end()){\\n            return dp[mask];\\n        }\\n        \\n        int val=0;\\n        for (int i=0; i<v.size(); i++){\\n            if (mask&(1<<i)){\\n                continue;\\n            }\\n            \\n            if (rem>=v[i]+1){\\n              vector<int> ele=temp;\\n                ele[i]=v[i]+1;\\n              val=max(val,i+func(n,v,(mask|(1<<i)),rem-(v[i]+1),ele,scr+i));  \\n              \\n            }\\n        }\\n        \\n       return dp[mask]=val;\\n    }\\n    \\n    vector<int> maximumBobPoints(int n, vector<int>& v) {\\n        int i;\\n        vector<int> temp(12,0);\\n        \\n        func(n,v,0,n,temp,0);\\n        int val=0;\\n        \\n        for (i=0; i<ans.size(); i++){\\n            val+=ans[i];\\n        }\\n        \\n        int diff=n-val;\\n        cout<<diff<<endl;\\n        for (i=0; i<v.size(); i++){\\n           \\n               ans[i]+=diff; \\n               break;\\n            \\n        }\\n        \\n        \\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    map<int,int> dp;\\n    int mx=0;\\n    \\n    int func(int n,vector<int> &v,int mask,int rem,vector<int> &temp,int scr){\\n       if (scr>mx){\\n          mx=scr;\\n          ans=temp;\\n        }\\n        \\n        if (mask==(pow(2,12)-1) || rem==0){\\n            return 0;\\n        }\\n        \\n        if (dp.find(mask)!=dp.end()){\\n            return dp[mask];\\n        }\\n        \\n        int val=0;\\n        for (int i=0; i<v.size(); i++){\\n            if (mask&(1<<i)){\\n                continue;\\n            }\\n            \\n            if (rem>=v[i]+1){\\n              vector<int> ele=temp;\\n                ele[i]=v[i]+1;\\n              val=max(val,i+func(n,v,(mask|(1<<i)),rem-(v[i]+1),ele,scr+i));  \\n              \\n            }\\n        }\\n        \\n       return dp[mask]=val;\\n    }\\n    \\n    vector<int> maximumBobPoints(int n, vector<int>& v) {\\n        int i;\\n        vector<int> temp(12,0);\\n        \\n        func(n,v,0,n,temp,0);\\n        int val=0;\\n        \\n        for (i=0; i<ans.size(); i++){\\n            val+=ans[i];\\n        }\\n        \\n        int diff=n-val;\\n        cout<<diff<<endl;\\n        for (i=0; i<v.size(); i++){\\n           \\n               ans[i]+=diff; \\n               break;\\n            \\n        }\\n        \\n        \\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2254720,
                "title": "easy-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    vector<int> b;\\n    void solve(int t,vector<int> &aa,int idx,vector<int> &ba,int sc)\\n    {\\n        if(idx<0)\\n        {\\n            if(ans<sc)\\n            {\\n                ans=sc;\\n                b=ba;\\n                // to make total equal to numArrows\\n                if(t>0)\\n                {\\n                    b[0]=b[0]+t;\\n                }\\n            }\\n            return;\\n        }\\n        //take\\n        if(t-(aa[idx]+1)>=0)\\n        {\\n            \\n            ba[idx]=aa[idx]+1;\\n            solve(t-(aa[idx]+1),aa,idx-1,ba,sc+idx);\\n            ba[idx]=0;\\n        }\\n        //not take\\n        solve(t,aa,idx-1,ba,sc);\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n=aliceArrows.size(),tar=0;\\n        vector<int> ba(n,0);\\n        ans=0;\\n        b.clear();\\n        solve(numArrows,aliceArrows,n-1,ba,0);\\n        return b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    vector<int> b;\\n    void solve(int t,vector<int> &aa,int idx,vector<int> &ba,int sc)\\n    {\\n        if(idx<0)\\n        {\\n            if(ans<sc)\\n            {\\n                ans=sc;\\n                b=ba;\\n                // to make total equal to numArrows\\n                if(t>0)\\n                {\\n                    b[0]=b[0]+t;\\n                }\\n            }\\n            return;\\n        }\\n        //take\\n        if(t-(aa[idx]+1)>=0)\\n        {\\n            \\n            ba[idx]=aa[idx]+1;\\n            solve(t-(aa[idx]+1),aa,idx-1,ba,sc+idx);\\n            ba[idx]=0;\\n        }\\n        //not take\\n        solve(t,aa,idx-1,ba,sc);\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        int n=aliceArrows.size(),tar=0;\\n        vector<int> ba(n,0);\\n        ans=0;\\n        b.clear();\\n        solve(numArrows,aliceArrows,n-1,ba,0);\\n        return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229651,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn maximum_bob_points(num_arrows: i32, alice_arrows: Vec<i32>) -> Vec<i32> {\\n        let limit = 1 << 12;\\n        let mut max = 0;\\n        let mut result = vec![0;12];\\n        for i in 0..limit {\\n            let mut temp = 0;\\n            let mut score = 0;\\n            let mut memo = vec![0;12];\\n            for j in 0..12 {\\n                if i >> j & 1 == 1 {\\n                    temp += alice_arrows[j]+1;\\n                    memo[j] = alice_arrows[j]+1;\\n                    score += j as i32;\\n                }\\n            }\\n\\n            if max < score && temp <= num_arrows {\\n                max = score;\\n                result = memo;\\n            }\\n        }\\n\\n        let mut tot = 0;\\n        for i in 0..12 {\\n            tot += result[i];\\n        }\\n        result[11] += num_arrows - tot;\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_bob_points(num_arrows: i32, alice_arrows: Vec<i32>) -> Vec<i32> {\\n        let limit = 1 << 12;\\n        let mut max = 0;\\n        let mut result = vec![0;12];\\n        for i in 0..limit {\\n            let mut temp = 0;\\n            let mut score = 0;\\n            let mut memo = vec![0;12];\\n            for j in 0..12 {\\n                if i >> j & 1 == 1 {\\n                    temp += alice_arrows[j]+1;\\n                    memo[j] = alice_arrows[j]+1;\\n                    score += j as i32;\\n                }\\n            }\\n\\n            if max < score && temp <= num_arrows {\\n                max = score;\\n                result = memo;\\n            }\\n        }\\n\\n        let mut tot = 0;\\n        for i in 0..12 {\\n            tot += result[i];\\n        }\\n        result[11] += num_arrows - tot;\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2226063,
                "title": "java-time-o-n2-n-space-o-2-n-bit-masking",
                "content": "```\\nclass Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int n = aliceArrows.length;\\n        int maxScore = 0, maxState = 0;\\n        for(int mask = 0;mask<(1<<n);mask++){\\n            int cnt = 0, score = 0;\\n            for(int i=0;i<n;i++){\\n                if((mask&(1<<i))>0){\\n                    cnt += aliceArrows[i]+1;\\n                    score += i;\\n                }\\n            }\\n            if(cnt<=numArrows&&score>maxScore){\\n                maxScore = score;\\n                maxState = mask;\\n            }\\n        }\\n        \\n        \\n        int[] ans = new int[n];\\n        for(int i=0;i<n;i++){\\n            if((maxState&(1<<i))>0){\\n                ans[i] = aliceArrows[i] + 1;\\n                numArrows -= ans[i];\\n            }\\n        }\\n        ans[0] += numArrows;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maximumBobPoints(int numArrows, int[] aliceArrows) {\\n        int n = aliceArrows.length;\\n        int maxScore = 0, maxState = 0;\\n        for(int mask = 0;mask<(1<<n);mask++){\\n            int cnt = 0, score = 0;\\n            for(int i=0;i<n;i++){\\n                if((mask&(1<<i))>0){\\n                    cnt += aliceArrows[i]+1;\\n                    score += i;\\n                }\\n            }\\n            if(cnt<=numArrows&&score>maxScore){\\n                maxScore = score;\\n                maxState = mask;\\n            }\\n        }\\n        \\n        \\n        int[] ans = new int[n];\\n        for(int i=0;i<n;i++){\\n            if((maxState&(1<<i))>0){\\n                ans[i] = aliceArrows[i] + 1;\\n                numArrows -= ans[i];\\n            }\\n        }\\n        ans[0] += numArrows;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219814,
                "title": "python-simple-maths",
                "content": "\\n    def maximumBobPoints(self, numArrows, aliceArrows):\\n        ans, rem_arrow = [0]*12, numArrows\\n        \\n        def dfs(idx, count):\\n            if idx == 12 or count == 0:\\n                return 0\\n            \\n            if count > aliceArrows[idx]:\\n                return max(dfs(idx+1, count), dfs(idx+1, count - aliceArrows[idx] - 1) + idx)\\n            else:\\n                return dfs(idx+1, count)\\n        \\n        for j in range(12):\\n            if dfs(j+1, rem_arrow) < dfs(j, rem_arrow):\\n                ans[j] = aliceArrows[j] + 1\\n                rem_arrow -= aliceArrows[j] + 1\\n                \\n                \\n        ans[0] += rem_arrow\\n        \\n        return ans",
                "solutionTags": [],
                "code": "\\n    def maximumBobPoints(self, numArrows, aliceArrows):\\n        ans, rem_arrow = [0]*12, numArrows\\n        \\n        def dfs(idx, count):\\n            if idx == 12 or count == 0:\\n                return 0\\n            \\n            if count > aliceArrows[idx]:\\n                return max(dfs(idx+1, count), dfs(idx+1, count - aliceArrows[idx] - 1) + idx)\\n            else:\\n                return dfs(idx+1, count)\\n        \\n        for j in range(12):\\n            if dfs(j+1, rem_arrow) < dfs(j, rem_arrow):\\n                ans[j] = aliceArrows[j] + 1\\n                rem_arrow -= aliceArrows[j] + 1\\n                \\n                \\n        ans[0] += rem_arrow\\n        \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 2183542,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(int arrows, vector<int>alice, vector<int>&res, vector<int>curr, int& maxi, int sum, int index){\\n        \\n        if(index<0){\\n            if(sum > maxi){\\n                maxi = sum;\\n                if(arrows>0){\\n                    curr[10]+=arrows;\\n                }\\n                res.clear();\\n                for(int i=0;i<=11;i++){\\n                    res.push_back(curr[i]);\\n                }\\n            }\\n            return;\\n        }\\n        \\n        \\n        if(arrows >= alice[index] + 1){\\n            curr.push_back(alice[index]+1);\\n            sum+=index;\\n            arrows=arrows - alice[index] - 1;\\n            solve(arrows, alice, res, curr, maxi, sum, index-1);\\n            arrows+=alice[index]+1;\\n            sum-=index;\\n            curr.pop_back();\\n        }\\n        \\n        \\n        curr.push_back(0);\\n        solve(arrows, alice, res, curr, maxi, sum, index-1);\\n        curr.pop_back();\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>res;\\n        vector<int>curr;\\n        \\n        int maxi = 0, sum=0;\\n        \\n        solve(numArrows, aliceArrows, res, curr, maxi, sum, 11);\\n        \\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int arrows, vector<int>alice, vector<int>&res, vector<int>curr, int& maxi, int sum, int index){\\n        \\n        if(index<0){\\n            if(sum > maxi){\\n                maxi = sum;\\n                if(arrows>0){\\n                    curr[10]+=arrows;\\n                }\\n                res.clear();\\n                for(int i=0;i<=11;i++){\\n                    res.push_back(curr[i]);\\n                }\\n            }\\n            return;\\n        }\\n        \\n        \\n        if(arrows >= alice[index] + 1){\\n            curr.push_back(alice[index]+1);\\n            sum+=index;\\n            arrows=arrows - alice[index] - 1;\\n            solve(arrows, alice, res, curr, maxi, sum, index-1);\\n            arrows+=alice[index]+1;\\n            sum-=index;\\n            curr.pop_back();\\n        }\\n        \\n        \\n        curr.push_back(0);\\n        solve(arrows, alice, res, curr, maxi, sum, index-1);\\n        curr.pop_back();\\n    }\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int>res;\\n        vector<int>curr;\\n        \\n        int maxi = 0, sum=0;\\n        \\n        solve(numArrows, aliceArrows, res, curr, maxi, sum, 11);\\n        \\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2167101,
                "title": "c-bitmasking-100-time-62-space-o-1-vs-98-time-82-space",
                "content": "using dp made me faster than 100%, less space than 62%\\nwithout dp, faster than 98%, less space than 82%\\n```\\nclass Solution {\\npublic:\\n    int mask=(1<<12)-1; int ans=-1,ansmask;\\n    int dp[(1<<12)]={0};\\n    vector<int> maximumBobPoints(int n, vector<int>& v) {\\n        solve(n,v,0,0,12); cout<<ans<<\" \"<<ansmask;\\n        vector<int> b(12,0); int tot=0;\\n        for(int i=0;i<12;i++) //demasking to vector\\n            if(ansmask&(1<<i)) b[i]=v[i]+1, tot+=(b[i]);\\n        if(tot<n) b[0]+=(n-tot); //throwing unwanted arrows at first target\\n        return b;\\n    }\\n    void solve(int n, vector<int>&v, int m, int sum,int j){\\n        \\n        // cout<<n<<\" \"<<m<<\" \"<<sum<<\" \"<<j<<endl;\\n        if(n<0) return;\\n        if(dp[m]) return;\\n        dp[m]=1;\\n        if(ans<=sum){\\n            ans=sum; ansmask=m;\\n        }\\n        if(n==0) return;\\n        for(int i=j-1;i>=0;i--){\\n        // j avoids recheking many unessecary repitition(better approach than dp because dp blocks a single mask, while j blocks all the greater numbers in the loop)\\n            if((m&(1<<i))==0){\\n                solve(n-v[i]-1,v,m|(1<<i),sum+i, i);\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\n//space o(1)\\n//time o(12*12) o(1)\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mask=(1<<12)-1; int ans=-1,ansmask;\\n    int dp[(1<<12)]={0};\\n    vector<int> maximumBobPoints(int n, vector<int>& v) {\\n        solve(n,v,0,0,12); cout<<ans<<\" \"<<ansmask;\\n        vector<int> b(12,0); int tot=0;\\n        for(int i=0;i<12;i++) //demasking to vector\\n            if(ansmask&(1<<i)) b[i]=v[i]+1, tot+=(b[i]);\\n        if(tot<n) b[0]+=(n-tot); //throwing unwanted arrows at first target\\n        return b;\\n    }\\n    void solve(int n, vector<int>&v, int m, int sum,int j){\\n        \\n        // cout<<n<<\" \"<<m<<\" \"<<sum<<\" \"<<j<<endl;\\n        if(n<0) return;\\n        if(dp[m]) return;\\n        dp[m]=1;\\n        if(ans<=sum){\\n            ans=sum; ansmask=m;\\n        }\\n        if(n==0) return;\\n        for(int i=j-1;i>=0;i--){\\n        // j avoids recheking many unessecary repitition(better approach than dp because dp blocks a single mask, while j blocks all the greater numbers in the loop)\\n            if((m&(1<<i))==0){\\n                solve(n-v[i]-1,v,m|(1<<i),sum+i, i);\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\n//space o(1)\\n//time o(12*12) o(1)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2141992,
                "title": "bitmask-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n\\tvector<int> a;\\n\\n\\tvoid solve(int i, int avail, int mask, int curSum, int &maxSum, int &ansMask) {\\n\\n\\t\\tif (i == -1) {\\n\\t\\t\\tif (curSum > maxSum) {\\n\\t\\t\\t\\tmaxSum = curSum;\\n\\t\\t\\t\\tansMask = mask;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (avail >= a[i] + 1) solve(i - 1, avail - (a[i] + 1), mask | (1 << i), curSum + i, maxSum, ansMask);\\n\\t\\tsolve(i - 1, avail, mask, curSum, maxSum, ansMask);\\n\\t}\\n\\n\\n\\tvector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n\\n\\t\\ta = aliceArrows;\\n\\n\\t\\tint ansMask = 0, maxSum = 0;\\n\\t\\tint n = a.size();\\n\\t\\tsolve(n - 1, numArrows, 0, 0, maxSum, ansMask);\\n\\n\\t\\tvector<int> ans(n, 0);\\n        int total = accumulate(a.begin(), a.end(), 0);\\n        \\n        int kept = 0;\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (ansMask & (1 << i)) {\\n                kept += (a[i] + 1);\\n                ans[i] = a[i] + 1;\\n            }\\n\\t\\t}\\n        \\n        int diff = total - kept;\\n        ans[0]+=diff;\\n        \\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<int> a;\\n\\n\\tvoid solve(int i, int avail, int mask, int curSum, int &maxSum, int &ansMask) {\\n\\n\\t\\tif (i == -1) {\\n\\t\\t\\tif (curSum > maxSum) {\\n\\t\\t\\t\\tmaxSum = curSum;\\n\\t\\t\\t\\tansMask = mask;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (avail >= a[i] + 1) solve(i - 1, avail - (a[i] + 1), mask | (1 << i), curSum + i, maxSum, ansMask);\\n\\t\\tsolve(i - 1, avail, mask, curSum, maxSum, ansMask);\\n\\t}\\n\\n\\n\\tvector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n\\n\\t\\ta = aliceArrows;\\n\\n\\t\\tint ansMask = 0, maxSum = 0;\\n\\t\\tint n = a.size();\\n\\t\\tsolve(n - 1, numArrows, 0, 0, maxSum, ansMask);\\n\\n\\t\\tvector<int> ans(n, 0);\\n        int total = accumulate(a.begin(), a.end(), 0);\\n        \\n        int kept = 0;\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (ansMask & (1 << i)) {\\n                kept += (a[i] + 1);\\n                ans[i] = a[i] + 1;\\n            }\\n\\t\\t}\\n        \\n        int diff = total - kept;\\n        ans[0]+=diff;\\n        \\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116108,
                "title": "javascript-solution-recursion-with-bitmask",
                "content": "```\\nvar maximumBobPoints = function(numArrows, aliceArrows) {\\n    const n = aliceArrows.length;\\n    \\n    let maxScore = 0;\\n    let maxMask = 0;\\n    let maxArrowsLeft = 0;\\n    \\n    topDown(n - 1, numArrows, 0, (1 << 12) - 1);\\n    \\n    const res = new Array(n).fill(0);\\n    \\n    for (let i = 0; i < n; ++i) {\\n        const lastBit = maxMask & 1;\\n        \\n        if (!lastBit) {\\n            res[i] = aliceArrows[i] + 1;\\n        }\\n        \\n        maxMask >>= 1;\\n    }\\n   \\n    res[0] += maxArrowsLeft;\\n    \\n    return res;\\n    \\n    function topDown(idx, remArrows, score, mask) {\\n        if (idx < 0 || remArrows === 0) {\\n            if (score > maxScore) {\\n                maxScore = score;\\n                maxMask = mask;\\n                maxArrowsLeft = remArrows;\\n            }\\n            return;\\n        }\\n\\n        const alice_arrows_placed = aliceArrows[idx];\\n        \\n        if (remArrows > alice_arrows_placed) {\\n            topDown(idx - 1, remArrows - alice_arrows_placed - 1, score + idx, mask & ~(1 << idx));\\n        }\\n        \\n        topDown(idx - 1, remArrows, score, mask);\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nvar maximumBobPoints = function(numArrows, aliceArrows) {\\n    const n = aliceArrows.length;\\n    \\n    let maxScore = 0;\\n    let maxMask = 0;\\n    let maxArrowsLeft = 0;\\n    \\n    topDown(n - 1, numArrows, 0, (1 << 12) - 1);\\n    \\n    const res = new Array(n).fill(0);\\n    \\n    for (let i = 0; i < n; ++i) {\\n        const lastBit = maxMask & 1;\\n        \\n        if (!lastBit) {\\n            res[i] = aliceArrows[i] + 1;\\n        }\\n        \\n        maxMask >>= 1;\\n    }\\n   \\n    res[0] += maxArrowsLeft;\\n    \\n    return res;\\n    \\n    function topDown(idx, remArrows, score, mask) {\\n        if (idx < 0 || remArrows === 0) {\\n            if (score > maxScore) {\\n                maxScore = score;\\n                maxMask = mask;\\n                maxArrowsLeft = remArrows;\\n            }\\n            return;\\n        }\\n\\n        const alice_arrows_placed = aliceArrows[idx];\\n        \\n        if (remArrows > alice_arrows_placed) {\\n            topDown(idx - 1, remArrows - alice_arrows_placed - 1, score + idx, mask & ~(1 << idx));\\n        }\\n        \\n        topDown(idx - 1, remArrows, score, mask);\\n       \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2115640,
                "title": "python-simple-dfs",
                "content": "```\\ndef maximumBobPoints(self, n, a):\\n        def dfs(i, k, cursum):\\n            if i == 12:\\n                if cursum > self.maxsum: \\n                    self.maxsum = cursum\\n                    self.ans = b[:]\\n                    # Put remaining arrows anywhere - I put it on 0.\\n                    self.ans[0] += n - sum(self.ans)\\n                return\\n            dfs(i + 1, k, cursum)\\n            if k <= a[i]: return\\n            b[i] += a[i] + 1\\n            dfs(i + 1, k - a[i] - 1, cursum + i)\\n            b[i] -= (a[i] + 1)\\n        \\n        self.maxsum = 0\\n        self.ans = []\\n        b = [0] * 12\\n        dfs(1, n, 0)\\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef maximumBobPoints(self, n, a):\\n        def dfs(i, k, cursum):\\n            if i == 12:\\n                if cursum > self.maxsum: \\n                    self.maxsum = cursum\\n                    self.ans = b[:]\\n                    # Put remaining arrows anywhere - I put it on 0.\\n                    self.ans[0] += n - sum(self.ans)\\n                return\\n            dfs(i + 1, k, cursum)\\n            if k <= a[i]: return\\n            b[i] += a[i] + 1\\n            dfs(i + 1, k - a[i] - 1, cursum + i)\\n            b[i] -= (a[i] + 1)\\n        \\n        self.maxsum = 0\\n        self.ans = []\\n        b = [0] * 12\\n        dfs(1, n, 0)\\n        return self.ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2105793,
                "title": "python-soln",
                "content": "```\\nclass Solution:\\n    def maximumBobPoints(self, arrows: int, alice: List[int]) -> List[int]:\\n        \\n        n=len(alice)\\n        alicescore=0\\n        for i in range(n):\\n            if alice[i]!=0:\\n                alicescore+=i\\n                \\n        def check(i,arrows,alice,bob,score,mxsc):\\n            if i<0:\\n                if score>mxsc[0]:\\n                    mxsc[0]=score\\n                    self.ans=bob.copy()\\n                return \\n            \\n            \\n            if arrows==0:\\n                if score>mxsc[0]:\\n                    mxsc[0]=score\\n                    self.ans=bob.copy()\\n                return\\n                \\n                \\n            if i==0:\\n                bob[i]=arrows\\n                check(i-1,arrows-bob[i],alice,bob,score+i,mxsc)\\n                bob[i]=0\\n                    \\n            \\n            elif arrows>alice[i]:\\n                bob[i]=alice[i]+1\\n                check(i-1,arrows-bob[i],alice,bob,score+i,mxsc)\\n                    \\n                bob[i]=0\\n                \\n                check(i-1,arrows,alice,bob,score,mxsc)\\n                    \\n            else:\\n                check(i-1,arrows,alice,bob,score,mxsc)\\n                    \\n                \\n        \\n            \\n        \\n        bob=[0 for j in range(n)]\\n        self.ans=[]\\n        mxsc=[0]\\n        check(n-1,arrows,alice,bob,0,mxsc)\\n        return self.ans\\n        \\n        \\n        \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, arrows: int, alice: List[int]) -> List[int]:\\n        \\n        n=len(alice)\\n        alicescore=0\\n        for i in range(n):\\n            if alice[i]!=0:\\n                alicescore+=i\\n                \\n        def check(i,arrows,alice,bob,score,mxsc):\\n            if i<0:\\n                if score>mxsc[0]:\\n                    mxsc[0]=score\\n                    self.ans=bob.copy()\\n                return \\n            \\n            \\n            if arrows==0:\\n                if score>mxsc[0]:\\n                    mxsc[0]=score\\n                    self.ans=bob.copy()\\n                return\\n                \\n                \\n            if i==0:\\n                bob[i]=arrows\\n                check(i-1,arrows-bob[i],alice,bob,score+i,mxsc)\\n                bob[i]=0\\n                    \\n            \\n            elif arrows>alice[i]:\\n                bob[i]=alice[i]+1\\n                check(i-1,arrows-bob[i],alice,bob,score+i,mxsc)\\n                    \\n                bob[i]=0\\n                \\n                check(i-1,arrows,alice,bob,score,mxsc)\\n                    \\n            else:\\n                check(i-1,arrows,alice,bob,score,mxsc)\\n                    \\n                \\n        \\n            \\n        \\n        bob=[0 for j in range(n)]\\n        self.ans=[]\\n        mxsc=[0]\\n        check(n-1,arrows,alice,bob,0,mxsc)\\n        return self.ans\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101180,
                "title": "c-bitmask-iterative-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int n, vector<int>& arr) { \\n        int res=0, resMask=0, last=1<<12;;\\n        vector<int>here(12,0);\\n        for(int i=1; i<last; i++){\\n            int cur=0,m=n,mask=0;\\n            for(int k=0; k<12; k++){\\n                if(i&(1<<k) && arr[k]<m){\\n                    m-=(arr[k]+1);\\n                    mask|=(1<<k);\\n                    cur+= k;\\n                }\\n            }\\n            if(mask==i && cur>res){\\n                res=cur;\\n                resMask=i;\\n            }             \\n        }\\n        int tot=n;\\n        for(int i=0; i<12; i++){\\n            if(resMask&(1<<i)){\\n                here[i]=arr[i]+1;\\n                tot-=here[i];\\n            }\\n        }\\n        here[0]=tot;\\n        return here;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int n, vector<int>& arr) { \\n        int res=0, resMask=0, last=1<<12;;\\n        vector<int>here(12,0);\\n        for(int i=1; i<last; i++){\\n            int cur=0,m=n,mask=0;\\n            for(int k=0; k<12; k++){\\n                if(i&(1<<k) && arr[k]<m){\\n                    m-=(arr[k]+1);\\n                    mask|=(1<<k);\\n                    cur+= k;\\n                }\\n            }\\n            if(mask==i && cur>res){\\n                res=cur;\\n                resMask=i;\\n            }             \\n        }\\n        int tot=n;\\n        for(int i=0; i<12; i++){\\n            if(resMask&(1<<i)){\\n                here[i]=arr[i]+1;\\n                tot-=here[i];\\n            }\\n        }\\n        here[0]=tot;\\n        return here;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048858,
                "title": "easy-understanding-python-dfs",
                "content": "```\\n        max_path = [0] * len(aliceArrows)\\n        max_score = 0\\n        \\n        @cache\\n        def dfs(numArrow, count, score, path):\\n            nonlocal max_score\\n\\n            if numArrow < 0: # invalid\\n                return\\n            \\n            if numArrow == 0 or count == len(aliceArrows): # no more arrows to use or finish\\n                if score > max_score:\\n                    max_score = score\\n                    for i in range(len(max_path)):\\n                        if i < len(path):\\n                            max_path[i] = path[i]\\n                        else:\\n                            max_path[i] = 0\\n                    max_path[0] = numArrows - sum(max_path[1:]) # balance the total arrows for two choices\\n                return\\n            \\n            # two choices\\n            dfs(numArrow, count + 1, score, path + (0,))\\n            bobArrow = aliceArrows[count] + 1                \\n            dfs(numArrow - bobArrow, count + 1, score + count, path + (bobArrow,))\\n\\n            # brute-force TLE/OOM\\n            # for j in range(numArrow+1):\\n            #     bobArrow = j\\n            #     dfs(numArrow - bobArrow, count + 1, score + (count if bobArrow > aliceArrows[count] else 0), path + (bobArrow,))\\n\\n            \\n        dfs(numArrows, 0, 0, tuple())\\n\\n        return max_path\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n        max_path = [0] * len(aliceArrows)\\n        max_score = 0\\n        \\n        @cache\\n        def dfs(numArrow, count, score, path):\\n            nonlocal max_score\\n\\n            if numArrow < 0: # invalid\\n                return\\n            \\n            if numArrow == 0 or count == len(aliceArrows): # no more arrows to use or finish\\n                if score > max_score:\\n                    max_score = score\\n                    for i in range(len(max_path)):\\n                        if i < len(path):\\n                            max_path[i] = path[i]\\n                        else:\\n                            max_path[i] = 0\\n                    max_path[0] = numArrows - sum(max_path[1:]) # balance the total arrows for two choices\\n                return\\n            \\n            # two choices\\n            dfs(numArrow, count + 1, score, path + (0,))\\n            bobArrow = aliceArrows[count] + 1                \\n            dfs(numArrow - bobArrow, count + 1, score + count, path + (bobArrow,))\\n\\n            # brute-force TLE/OOM\\n            # for j in range(numArrow+1):\\n            #     bobArrow = j\\n            #     dfs(numArrow - bobArrow, count + 1, score + (count if bobArrow > aliceArrows[count] else 0), path + (bobArrow,))\\n\\n            \\n        dfs(numArrows, 0, 0, tuple())\\n\\n        return max_path\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2041342,
                "title": "c-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> bobArrows(12, 0);\\n        search(numArrows, aliceArrows, bobArrows, 0, 11);\\n\\n        return resultBobArrows;\\n    }\\n\\n    void search(int numArrows, vector<int>& aliceArrows, vector<int>& bobArrows, int points, int i) {\\n        if (numArrows < 0) return;\\n        \\n        int remainPoints=(i+1)*i/2;\\n        if(points+remainPoints<maxPoints) return;\\n\\n        if (i == 0 ) {\\n            if (points >= maxPoints) \\n            {\\n                maxPoints = points;\\n                \\n                bobArrows[0] = numArrows;\\n                resultBobArrows = bobArrows;\\n            }\\n            return;\\n        }\\n\\n        bobArrows[i] = aliceArrows[i] + 1;\\n        if (numArrows - aliceArrows[i] - 1 >= 0)\\n            search(numArrows - aliceArrows[i] - 1, aliceArrows, bobArrows, points + i, i - 1);\\n\\n        bobArrows[i] = 0;\\n        search(numArrows, aliceArrows, bobArrows, points, i - 1);\\n    }\\n\\nprivate:\\n    int maxPoints = 0;\\n    vector<int> resultBobArrows;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maximumBobPoints(int numArrows, vector<int>& aliceArrows) {\\n        vector<int> bobArrows(12, 0);\\n        search(numArrows, aliceArrows, bobArrows, 0, 11);\\n\\n        return resultBobArrows;\\n    }\\n\\n    void search(int numArrows, vector<int>& aliceArrows, vector<int>& bobArrows, int points, int i) {\\n        if (numArrows < 0) return;\\n        \\n        int remainPoints=(i+1)*i/2;\\n        if(points+remainPoints<maxPoints) return;\\n\\n        if (i == 0 ) {\\n            if (points >= maxPoints) \\n            {\\n                maxPoints = points;\\n                \\n                bobArrows[0] = numArrows;\\n                resultBobArrows = bobArrows;\\n            }\\n            return;\\n        }\\n\\n        bobArrows[i] = aliceArrows[i] + 1;\\n        if (numArrows - aliceArrows[i] - 1 >= 0)\\n            search(numArrows - aliceArrows[i] - 1, aliceArrows, bobArrows, points + i, i - 1);\\n\\n        bobArrows[i] = 0;\\n        search(numArrows, aliceArrows, bobArrows, points, i - 1);\\n    }\\n\\nprivate:\\n    int maxPoints = 0;\\n    vector<int> resultBobArrows;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009630,
                "title": "c-backtracking-easy-to-understand",
                "content": "\\n\\n```\\n        public int[] MaximumBobPoints(int numArrows, int[] aliceArrows)\\n        {\\n            int[] res=new int[aliceArrows.Length];\\n            int max = int.MinValue;\\n\\t\\t\\t//index=11 last index, due to higher index got higher score\\n            MaximumBobPoints_BackTracking(numArrows, aliceArrows, new int[aliceArrows.Length], aliceArrows.Length - 1, 0, ref max, ref res);\\n            return res;\\n        }\\n\\n        private void MaximumBobPoints_BackTracking(int numArrows, int[] aliceArrows, int[] bobArrows,int index,int total, ref int max, ref int[] res)\\n        {\\n            if (index == 0)\\n            {\\n\\t\\t\\t   //because index-0 has no score, so plus all arrows to index-0\\n                bobArrows[0] = numArrows;\\n                if (total > max)\\n                {\\n                    max = total;//if current score > max, update it\\n                    res = bobArrows;\\n                }\\n            }\\n            else\\n            {\\n\\t\\t\\t    //skip current index\\n                MaximumBobPoints_BackTracking(numArrows, aliceArrows, bobArrows,index-1,total,ref max, ref res);\\n\\t\\t\\t\\t//if can got score on current index, just try it\\n                if(numArrows > aliceArrows[index])\\n                {\\n                    var nextArr = new int[bobArrows.Length];\\n                    Array.Copy(bobArrows, nextArr, nextArr.Length);\\n                    nextArr[index] = aliceArrows[index] + 1;\\n                    MaximumBobPoints_BackTracking(numArrows - aliceArrows[index] - 1, aliceArrows, nextArr, index - 1, total + index, ref max, ref res);\\n                }\\n            }\\n        }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n        public int[] MaximumBobPoints(int numArrows, int[] aliceArrows)\\n        {\\n            int[] res=new int[aliceArrows.Length];\\n            int max = int.MinValue;\\n\\t\\t\\t//index=11 last index, due to higher index got higher score\\n            MaximumBobPoints_BackTracking(numArrows, aliceArrows, new int[aliceArrows.Length], aliceArrows.Length - 1, 0, ref max, ref res);\\n            return res;\\n        }\\n\\n        private void MaximumBobPoints_BackTracking(int numArrows, int[] aliceArrows, int[] bobArrows,int index,int total, ref int max, ref int[] res)\\n        {\\n            if (index == 0)\\n            {\\n\\t\\t\\t   //because index-0 has no score, so plus all arrows to index-0\\n                bobArrows[0] = numArrows;\\n                if (total > max)\\n                {\\n                    max = total;//if current score > max, update it\\n                    res = bobArrows;\\n                }\\n            }\\n            else\\n            {\\n\\t\\t\\t    //skip current index\\n                MaximumBobPoints_BackTracking(numArrows, aliceArrows, bobArrows,index-1,total,ref max, ref res);\\n\\t\\t\\t\\t//if can got score on current index, just try it\\n                if(numArrows > aliceArrows[index])\\n                {\\n                    var nextArr = new int[bobArrows.Length];\\n                    Array.Copy(bobArrows, nextArr, nextArr.Length);\\n                    nextArr[index] = aliceArrows[index] + 1;\\n                    MaximumBobPoints_BackTracking(numArrows - aliceArrows[index] - 1, aliceArrows, nextArr, index - 1, total + index, ref max, ref res);\\n                }\\n            }\\n        }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1992464,
                "title": "python3-bitmask-dp-backtrack",
                "content": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n      bobArrows = [x+1 for x in aliceArrows]\\n      \\n      def genconfig(length):\\n        if length == 0: return [\\'\\']\\n        else:\\n          return [\\'1\\' + x for x in genconfig(length-1)] + \\\\\\n                 [\\'0\\' + x for x in genconfig(length-1)]\\n        \\n      configs = genconfig(11)\\n      \\n      score, res = -sys.maxsize, None\\n      for con in configs:\\n        arrow_needed = sum([bobArrows[x+1] for x in range(11) if con[x] == \\'1\\'])\\n        if arrow_needed <= numArrows:\\n          temp_score = sum([x+1 for x in range(11) if con[x] == \\'1\\'])\\n          if temp_score > score:\\n            score = temp_score\\n            res = [numArrows - arrow_needed] + [bobArrows[x+1] if con[x] == \\'1\\' else 0 for x in range(11)]\\n      return res\\n        \\n      \\n      #dp knapsack + backtrack\\n      #grid = [([[0, 0] for x in range(12)]) for _ in range(numArrows+1)]\\n      \\n      #aliceArrows = [x + 1 for x in aliceArrows]\\n\\n      #for t in range(1, 12):\\n      #  target = aliceArrows[t]\\n      #  for k in range(numArrows+1):\\n      #    if k >= target:\\n      #      if grid[k-target][t-1][0] + t >= grid[k][t-1][0]:\\n      #        grid[k][t][0] = grid[k-target][t-1][0] + t\\n      #        grid[k][t][1] = target\\n      #      else:\\n      #        grid[k][t][0] = grid[k][t-1][0]\\n      #    else:\\n      #      grid[k][t][0] = grid[k][t-1][0]\\n          \\n      #res = []\\n       \\n      #for t in range(11, 0, -1):\\n      #  score, choice = grid[numArrows][t]\\n      #  res.append(choice)\\n      #  numArrows -= choice\\n      #res.append(numArrows)\\n      \\n      #return res[::-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n      bobArrows = [x+1 for x in aliceArrows]\\n      \\n      def genconfig(length):\\n        if length == 0: return [\\'\\']\\n        else:\\n          return [\\'1\\' + x for x in genconfig(length-1)] + \\\\\\n                 [\\'0\\' + x for x in genconfig(length-1)]\\n        \\n      configs = genconfig(11)\\n      \\n      score, res = -sys.maxsize, None\\n      for con in configs:\\n        arrow_needed = sum([bobArrows[x+1] for x in range(11) if con[x] == \\'1\\'])\\n        if arrow_needed <= numArrows:\\n          temp_score = sum([x+1 for x in range(11) if con[x] == \\'1\\'])\\n          if temp_score > score:\\n            score = temp_score\\n            res = [numArrows - arrow_needed] + [bobArrows[x+1] if con[x] == \\'1\\' else 0 for x in range(11)]\\n      return res\\n        \\n      \\n      #dp knapsack + backtrack\\n      #grid = [([[0, 0] for x in range(12)]) for _ in range(numArrows+1)]\\n      \\n      #aliceArrows = [x + 1 for x in aliceArrows]\\n\\n      #for t in range(1, 12):\\n      #  target = aliceArrows[t]\\n      #  for k in range(numArrows+1):\\n      #    if k >= target:\\n      #      if grid[k-target][t-1][0] + t >= grid[k][t-1][0]:\\n      #        grid[k][t][0] = grid[k-target][t-1][0] + t\\n      #        grid[k][t][1] = target\\n      #      else:\\n      #        grid[k][t][0] = grid[k][t-1][0]\\n      #    else:\\n      #      grid[k][t][0] = grid[k][t-1][0]\\n          \\n      #res = []\\n       \\n      #for t in range(11, 0, -1):\\n      #  score, choice = grid[numArrows][t]\\n      #  res.append(choice)\\n      #  numArrows -= choice\\n      #res.append(numArrows)\\n      \\n      #return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974966,
                "title": "python3-dfs-simple",
                "content": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        self.mx=0\\n        self.res=[]\\n\\n        def helper(idx,arr,total,left):\\n            if left==0 or idx==-1:\\n                if total>self.mx:\\n                    self.mx=total\\n                    self.res=arr+[0 for _ in range(12-len(arr))]\\n                    self.res[-1]+=left\\n                return\\n            helper(idx-1,arr+[0],total,left)\\n            if left>=aliceArrows[idx]+1:\\n                helper(idx-1,arr+[aliceArrows[idx]+1],total+idx,left-aliceArrows[idx]-1)\\n        \\n        helper(11,[],0,numArrows)\\n        return self.res[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\\n        self.mx=0\\n        self.res=[]\\n\\n        def helper(idx,arr,total,left):\\n            if left==0 or idx==-1:\\n                if total>self.mx:\\n                    self.mx=total\\n                    self.res=arr+[0 for _ in range(12-len(arr))]\\n                    self.res[-1]+=left\\n                return\\n            helper(idx-1,arr+[0],total,left)\\n            if left>=aliceArrows[idx]+1:\\n                helper(idx-1,arr+[aliceArrows[idx]+1],total+idx,left-aliceArrows[idx]-1)\\n        \\n        helper(11,[],0,numArrows)\\n        return self.res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971289,
                "title": "python-constant-time-solution-by-keeping-track-of-minimum-arrows-needed-for-each-score",
                "content": "maxs[i] is minimum number of arrows to get score i given aliceArrows\\ncomp[i] is the composition of score ranges to get max score.\\nInitialize the arrays for score range 1 and 2,\\nBuild the arrays up from score range 3 to 11.\\n\\n```\\nclass Solution(object):\\n    def maximumBobPoints(self, numArrows, aliceArrows):\\n        \"\"\"\\n        :type numArrows: int\\n        :type aliceArrows: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        maxs=[0]*67\\n        maxs[1]=aliceArrows[1]+1\\n        maxs[2]=aliceArrows[2]+1\\n        maxs[3]=maxs[1]+maxs[2]\\n        comp=[[] for _ in range(67)]\\n        comp[1]=[1]\\n        comp[2]=[2]\\n        comp[3]=[1,2]\\n        upper=3\\n        for i in range(3,12):\\n            for j in range(upper,upper-i,-1):\\n                maxs[i+j]=maxs[j]+aliceArrows[i]+1\\n                comp[i+j] = comp[j]+[i]\\n            for j in range(upper,i-1,-1):\\n                if maxs[j]>maxs[j-i]+aliceArrows[i]+1:\\n                    maxs[j]=maxs[j-i]+aliceArrows[i]+1\\n                    comp[j] = comp[j-i]+[i]\\n            upper += i\\n        for i in range(66,-1,-1):\\n            if numArrows>=maxs[i]:\\n                # print(i, comp[i])\\n                res=[0]*12\\n                for j in comp[i]:\\n                    res[j]=aliceArrows[j]+1\\n                res[0]=numArrows-sum(res)\\n                return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maximumBobPoints(self, numArrows, aliceArrows):\\n        \"\"\"\\n        :type numArrows: int\\n        :type aliceArrows: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        maxs=[0]*67\\n        maxs[1]=aliceArrows[1]+1\\n        maxs[2]=aliceArrows[2]+1\\n        maxs[3]=maxs[1]+maxs[2]\\n        comp=[[] for _ in range(67)]\\n        comp[1]=[1]\\n        comp[2]=[2]\\n        comp[3]=[1,2]\\n        upper=3\\n        for i in range(3,12):\\n            for j in range(upper,upper-i,-1):\\n                maxs[i+j]=maxs[j]+aliceArrows[i]+1\\n                comp[i+j] = comp[j]+[i]\\n            for j in range(upper,i-1,-1):\\n                if maxs[j]>maxs[j-i]+aliceArrows[i]+1:\\n                    maxs[j]=maxs[j-i]+aliceArrows[i]+1\\n                    comp[j] = comp[j-i]+[i]\\n            upper += i\\n        for i in range(66,-1,-1):\\n            if numArrows>=maxs[i]:\\n                # print(i, comp[i])\\n                res=[0]*12\\n                for j in comp[i]:\\n                    res[j]=aliceArrows[j]+1\\n                res[0]=numArrows-sum(res)\\n                return res\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1832173,
                "content": [
                    {
                        "username": "prafullpandey2801",
                        "content": "If you are failing this testcase \\n `89\\n[3,2,28,1,7,1,16,7,3,13,3,5]`\\nthen make sure that you are using all the arrows if number of Arrows used by BOB are less than Alice then put the difference of the arrows on the 0th target of BOB `if(arr<numArrows){\\n            ans[0] = numArrows-arr ;\\n        }`"
                    },
                    {
                        "username": "truncate",
                        "content": "Seems like the judge is not doing the right thing with solution. Eg, for `89, [3,2,28,1,7,1,16,7,3,13,3,5]` my solution has output `[4,3,0,2,8,2,17,8,4,14,4,6]` while it shows `[21,3,0,2,8,2,17,8,4,14,4,6]` as correct. 4 and 21 arrows, either way will result in 0 score , and there is no where it says that all arrow must be used.\\n\\nOr, the description should mention that all arrows must be used.\\n"
                    },
                    {
                        "username": "keshav-banka",
                        "content": "It is given in the second last paragraaph last line. \\nThe sum of the values in bobArrows should equal numArrows"
                    },
                    {
                        "username": "fmodesto",
                        "content": "Right at the end: \"The sum of the values in bobArrows should equal numArrows\"."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "This doesn\\'t look like a medium."
                    }
                ]
            },
            {
                "id": 1793888,
                "content": [
                    {
                        "username": "prafullpandey2801",
                        "content": "If you are failing this testcase \\n `89\\n[3,2,28,1,7,1,16,7,3,13,3,5]`\\nthen make sure that you are using all the arrows if number of Arrows used by BOB are less than Alice then put the difference of the arrows on the 0th target of BOB `if(arr<numArrows){\\n            ans[0] = numArrows-arr ;\\n        }`"
                    },
                    {
                        "username": "truncate",
                        "content": "Seems like the judge is not doing the right thing with solution. Eg, for `89, [3,2,28,1,7,1,16,7,3,13,3,5]` my solution has output `[4,3,0,2,8,2,17,8,4,14,4,6]` while it shows `[21,3,0,2,8,2,17,8,4,14,4,6]` as correct. 4 and 21 arrows, either way will result in 0 score , and there is no where it says that all arrow must be used.\\n\\nOr, the description should mention that all arrows must be used.\\n"
                    },
                    {
                        "username": "keshav-banka",
                        "content": "It is given in the second last paragraaph last line. \\nThe sum of the values in bobArrows should equal numArrows"
                    },
                    {
                        "username": "fmodesto",
                        "content": "Right at the end: \"The sum of the values in bobArrows should equal numArrows\"."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "This doesn\\'t look like a medium."
                    }
                ]
            },
            {
                "id": 1974098,
                "content": [
                    {
                        "username": "prafullpandey2801",
                        "content": "If you are failing this testcase \\n `89\\n[3,2,28,1,7,1,16,7,3,13,3,5]`\\nthen make sure that you are using all the arrows if number of Arrows used by BOB are less than Alice then put the difference of the arrows on the 0th target of BOB `if(arr<numArrows){\\n            ans[0] = numArrows-arr ;\\n        }`"
                    },
                    {
                        "username": "truncate",
                        "content": "Seems like the judge is not doing the right thing with solution. Eg, for `89, [3,2,28,1,7,1,16,7,3,13,3,5]` my solution has output `[4,3,0,2,8,2,17,8,4,14,4,6]` while it shows `[21,3,0,2,8,2,17,8,4,14,4,6]` as correct. 4 and 21 arrows, either way will result in 0 score , and there is no where it says that all arrow must be used.\\n\\nOr, the description should mention that all arrows must be used.\\n"
                    },
                    {
                        "username": "keshav-banka",
                        "content": "It is given in the second last paragraaph last line. \\nThe sum of the values in bobArrows should equal numArrows"
                    },
                    {
                        "username": "fmodesto",
                        "content": "Right at the end: \"The sum of the values in bobArrows should equal numArrows\"."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "This doesn\\'t look like a medium."
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Ways to Select Buildings",
        "question_content": "<p>You are given a <strong>0-indexed</strong> binary string <code>s</code> which represents the types of buildings along a street where:</p>\n\n<ul>\n\t<li><code>s[i] = &#39;0&#39;</code> denotes that the <code>i<sup>th</sup></code> building is an office and</li>\n\t<li><code>s[i] = &#39;1&#39;</code> denotes that the <code>i<sup>th</sup></code> building is a restaurant.</li>\n</ul>\n\n<p>As a city official, you would like to <strong>select</strong> 3 buildings for random inspection. However, to ensure variety, <strong>no two consecutive</strong> buildings out of the <strong>selected</strong> buildings can be of the same type.</p>\n\n<ul>\n\t<li>For example, given <code>s = &quot;0<u><strong>0</strong></u>1<u><strong>1</strong></u>0<u><strong>1</strong></u>&quot;</code>, we cannot select the <code>1<sup>st</sup></code>, <code>3<sup>rd</sup></code>, and <code>5<sup>th</sup></code> buildings as that would form <code>&quot;0<strong><u>11</u></strong>&quot;</code> which is <strong>not</strong> allowed due to having two consecutive buildings of the same type.</li>\n</ul>\n\n<p>Return <em>the <b>number of valid ways</b> to select 3 buildings.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;001101&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> \nThe following sets of indices selected are valid:\n- [0,2,4] from &quot;<u><strong>0</strong></u>0<strong><u>1</u></strong>1<strong><u>0</u></strong>1&quot; forms &quot;010&quot;\n- [0,3,4] from &quot;<u><strong>0</strong></u>01<u><strong>10</strong></u>1&quot; forms &quot;010&quot;\n- [1,2,4] from &quot;0<u><strong>01</strong></u>1<u><strong>0</strong></u>1&quot; forms &quot;010&quot;\n- [1,3,4] from &quot;0<u><strong>0</strong></u>1<u><strong>10</strong></u>1&quot; forms &quot;010&quot;\n- [2,4,5] from &quot;00<u><strong>1</strong></u>1<u><strong>01</strong></u>&quot; forms &quot;101&quot;\n- [3,4,5] from &quot;001<u><strong>101</strong></u>&quot; forms &quot;101&quot;\nNo other selection is valid. Thus, there are 6 total ways.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;11100&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> It can be shown that there are no valid selections.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1907026,
                "title": "easy-understanding-c-code-with-comments",
                "content": "The possible sequences of selected buildings is either \"101\" or \"010\".\\n\\nIf the current building is \\'0\\', then the number of sequences of pattern \"101\" will be the product of the number of occurances of building \\'1\\' before the current building to the number of occurances of building \\'1\\' after the current building and viceversa.\\n\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long a=0,b=0,ans=0;        // a and b are the number of occurances of \\'1\\' and \\'0\\' after the current building respectively.\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\')\\n                a++;\\n            else\\n                b++;\\n        }\\n        long long c=0,d=0;              // c and d are the number of occurances of \\'1\\' and \\'0\\' before the current building respectively.\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){               // Counting the sequences of \"010\"\\n                ans+=(d*b);\\n                a--;\\n                c++;\\n            }\\n            else{                        // Counting the sequences of \"101\"\\n                ans+=(a*c);\\n                b--;\\n                d++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nComplexity\\nTime - O(n)\\nSpace - O(1)",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long a=0,b=0,ans=0;        // a and b are the number of occurances of \\'1\\' and \\'0\\' after the current building respectively.\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\')\\n                a++;\\n            else\\n                b++;\\n        }\\n        long long c=0,d=0;              // c and d are the number of occurances of \\'1\\' and \\'0\\' before the current building respectively.\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'1\\'){               // Counting the sequences of \"010\"\\n                ans+=(d*b);\\n                a--;\\n                c++;\\n            }\\n            else{                        // Counting the sequences of \"101\"\\n                ans+=(a*c);\\n                b--;\\n                d++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906984,
                "title": "easy-to-understand-with-detailed-explanation-and-java-code",
                "content": "***Please upvote if you find this helpful :)***\\n\\nThe only valid combinations possible are 101 and 010.\\nSo, lets traverse the string and consider the current character as the centeral character of the combination. \\n\\nThis means, if the current character is \\'0\\', then all we need to do it find the number of 1 before this 0 and number of 1 after this 0 and multiply them to add them to the answer.\\nWe do the same for the central character as \\'1\\' and count the number of 0 before and after this one.\\n\\n\\n```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long ans = 0;\\n        int len = s.length();\\n        \\n        long totZeros = 0;\\n        \\n        for(int i=0;i<len;i++){\\n            totZeros += s.charAt(i)==\\'0\\'?1:0;\\n        }\\n        \\n        long totOnes = len - totZeros;\\n        \\n        long currZeros = s.charAt(0)==\\'0\\'?1:0;\\n        long currOnes = s.charAt(0)==\\'1\\'?1:0;\\n        \\n        for(int i=1;i<len;i++){\\n            if(s.charAt(i) == \\'0\\'){\\n                ans = ans + (currOnes * (totOnes-currOnes));\\n                currZeros++;\\n            }else{\\n                ans = ans + (currZeros * (totZeros-currZeros));\\n                currOnes++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long ans = 0;\\n        int len = s.length();\\n        \\n        long totZeros = 0;\\n        \\n        for(int i=0;i<len;i++){\\n            totZeros += s.charAt(i)==\\'0\\'?1:0;\\n        }\\n        \\n        long totOnes = len - totZeros;\\n        \\n        long currZeros = s.charAt(0)==\\'0\\'?1:0;\\n        long currOnes = s.charAt(0)==\\'1\\'?1:0;\\n        \\n        for(int i=1;i<len;i++){\\n            if(s.charAt(i) == \\'0\\'){\\n                ans = ans + (currOnes * (totOnes-currOnes));\\n                currZeros++;\\n            }else{\\n                ans = ans + (currZeros * (totZeros-currZeros));\\n                currOnes++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907109,
                "title": "python-dp-easy-to-understand",
                "content": "**Explanation:**\\nWhen you meet a \"0\", you can possibly form \"0\", \"10\", \"010\" ending with a \"0\".\\nWhen you meet a \"1\", you can possibly form \"1\", \"01\", \"101\" ending with a \"1\".\\nUpdate the number of possible combinations when you traverse s.\\n\\n<iframe src=\"https://leetcode.com/playground/NtKfXT7z/shared\" frameBorder=\"0\" width=\"1100\" height=\"400\"></iframe>",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "**Explanation:**\\nWhen you meet a \"0\", you can possibly form \"0\", \"10\", \"010\" ending with a \"0\".\\nWhen you meet a \"1\", you can possibly form \"1\", \"01\", \"101\" ending with a \"1\".\\nUpdate the number of possible combinations when you traverse s.\\n\\n<iframe src=\"https://leetcode.com/playground/NtKfXT7z/shared\" frameBorder=\"0\" width=\"1100\" height=\"400\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1907179,
                "title": "java-python-3-one-pass-s-o-1-t-o-n-codes-and-follow-up-w-brief-explanation-and-analysis",
                "content": "Traverse the input `s`:\\n1. If encontering `0`, count subsequences ending at current `0`: `0`, `10` and `010`\\'s; The number of `10` depends on how many `1`s before current `0`, and the number of `010` depends on how many `01` before current `0`;\\n\\nSimilarly, \\n\\n2. If encontering `1`, count subsequences ending at current `1`:  `1`, `01` and `101`\\'s; The number of `01` depends on how many `0`s before current `1`, and the number of `101` depends on how many `10` before current `1`.\\n\\n```java\\n    public long numberOfWays(String s) {\\n        long one = 0, zero = 0, oneZero = 0, zeroOne = 0, ways = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'0\\') {\\n                ++zero;\\n                oneZero += one; // Count in \\'10\\'.\\n                ways += zeroOne; // Count in \\'010\\'.\\n            }else {\\n                ++one;\\n                zeroOne += zero; // Count in \\'01\\'.\\n                ways += oneZero; // Count in \\'101\\'.\\n            }\\n        }\\n        return ways;\\n    }\\n```\\n```python\\n    def numberOfWays(self, s: str) -> int:\\n        ways = 0\\n        one = zero = zero_one = one_zero = 0\\n        for c in s:\\n            if c == \\'0\\':\\n                zero += 1\\n                one_zero += one\\n                ways += zero_one\\n            else:\\n                one += 1    \\n                zero_one += zero \\n                ways += one_zero\\n        return ways\\n```\\n\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`, where `n = s.length()`.\\n\\n----\\n\\n**Follow-up**\\nWhat if the city official would like to select `k`, instead of `3`, buildings?\\n\\n~~~If **the upvotes can reach `25`**, I  will provide time `O(k * n)` space `O(k)` code for the follow-up.~~~\\n\\nTraverse the input `s`:\\n1. If encontering `0`, count subsequences ending at current `0`:  `0`, `10` and `010`, `1010`\\'s, ...,; The number of `10` depends on how many `1`s before current `0`, the number of `010` depends on how many `01` before current `0`, and the number of `1010` depends on how many `101` before current `0`...;\\n\\nSimilarly,\\n\\n2. If encontering `1`, count subsequences ending at current `1`:  `1`, `01`, `101`, and `0101`\\'s; The number of `01` depends on how many `0`s before current `1`, the number of `101` depends on how many `10` before current `1`, and the number of `0101` depends on how many `010` before current `1`...\\n3. We can observe the above patterns and use a 2-D array `ways` to record the corresponding subsequences, e.g., \\n \\n\\t ways[0][0] - number of `0`\\'s;\\n\\t ways[1][0] - number of `10`\\'s;\\n\\t ways[2][0] - number of `010`\\'s;\\n\\t ways[3][0] - number of `1010`\\'s;\\n\\t ...\\n\\t ways[0][1] - number of `1`\\'s;\\n\\t ways[1][1] - number of `01`\\'s;\\n\\t ways[2][1] - number of `101`\\'s;\\n\\t ways[3][1] - number of `0101`\\'s;\\n\\t ...\\n\\t \\n```java\\n    public long numberOfWays(String s, int k) {\\n     // int k = 3;\\n        long[][] ways = new long[k][2]; \\n        for (int i = 0; i < s.length(); ++i) {\\n            int idx = s.charAt(i) - \\'0\\';\\n            ++ways[0][idx];\\n            for (int j = 1; j < k; ++j) {\\n                ways[j][idx] += ways[j - 1][1 - idx];\\n            }\\n        }\\n        return ways[k - 1][0] + ways[k - 1][1];\\n    }\\n```\\n```python\\n    def numberOfWays(self, s: str, k: int) -> int:\\n      # k = 3\\n        ways = [[0, 0] for _ in range(k)]\\n        for c in s:\\n            idx = ord(c) - ord(\\'0\\')\\n            ways[0][idx] += 1\\n            for i in range(1, k):\\n                ways[i][idx] += ways[i - 1][1 - idx]\\n        return sum(ways[-1])\\n```\\n**Analysis:**\\n\\nTime: `O(k * n)`, space: `O(k)`, where `n = s.length()`.\\n\\n**Do let me know** if you have an algorithm better than `O(k * n)` time or `O(k)` space for the follow-up.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long numberOfWays(String s) {\\n        long one = 0, zero = 0, oneZero = 0, zeroOne = 0, ways = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'0\\') {\\n                ++zero;\\n                oneZero += one; // Count in \\'10\\'.\\n                ways += zeroOne; // Count in \\'010\\'.\\n            }else {\\n                ++one;\\n                zeroOne += zero; // Count in \\'01\\'.\\n                ways += oneZero; // Count in \\'101\\'.\\n            }\\n        }\\n        return ways;\\n    }\\n```\n```python\\n    def numberOfWays(self, s: str) -> int:\\n        ways = 0\\n        one = zero = zero_one = one_zero = 0\\n        for c in s:\\n            if c == \\'0\\':\\n                zero += 1\\n                one_zero += one\\n                ways += zero_one\\n            else:\\n                one += 1    \\n                zero_one += zero \\n                ways += one_zero\\n        return ways\\n```\n```java\\n    public long numberOfWays(String s, int k) {\\n     // int k = 3;\\n        long[][] ways = new long[k][2]; \\n        for (int i = 0; i < s.length(); ++i) {\\n            int idx = s.charAt(i) - \\'0\\';\\n            ++ways[0][idx];\\n            for (int j = 1; j < k; ++j) {\\n                ways[j][idx] += ways[j - 1][1 - idx];\\n            }\\n        }\\n        return ways[k - 1][0] + ways[k - 1][1];\\n    }\\n```\n```python\\n    def numberOfWays(self, s: str, k: int) -> int:\\n      # k = 3\\n        ways = [[0, 0] for _ in range(k)]\\n        for c in s:\\n            idx = ord(c) - ord(\\'0\\')\\n            ways[0][idx] += 1\\n            for i in range(1, k):\\n                ways[i][idx] += ways[i - 1][1 - idx]\\n        return sum(ways[-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1907123,
                "title": "c-short-dp-o-n-time-o-1-space",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. DP\\n\\nLet `dp[len][c]` be the count of alternating subsequences of length `len` ending with character `\\'0\\' + c\\'`. The answer is `dp[3][0] + dp[3][1]`.\\n\\nWe can scan the array from left to right and compute these `dp[len][c]` values.\\n\\nFor each `dp[len][c]`, its count should increase by `dp[len - 1][1 - c]`, i.e. prepending subsequences of length `len - 1` ending with a different character.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/number-of-ways-to-select-buildings/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long dp[4][2] = {};\\n        dp[0][0] = dp[0][1] = 1;\\n        for (int i = 0; i < s.size(); ++i) {\\n            for (int len = 1; len <= 3; ++len) {\\n                dp[len][s[i] - \\'0\\'] += dp[len - 1][1 - (s[i] - \\'0\\')];\\n            }\\n        }\\n        return dp[3][0] + dp[3][1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/number-of-ways-to-select-buildings/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long dp[4][2] = {};\\n        dp[0][0] = dp[0][1] = 1;\\n        for (int i = 0; i < s.size(); ++i) {\\n            for (int len = 1; len <= 3; ++len) {\\n                dp[len][s[i] - \\'0\\'] += dp[len - 1][1 - (s[i] - \\'0\\')];\\n            }\\n        }\\n        return dp[3][0] + dp[3][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907002,
                "title": "010-or-101-java-easy-to-understand",
                "content": "```\\nclass Solution\\n{\\n    public long numberOfWays(String s)\\n    {\\n        int zero = 0; // Individual zeroes count\\n        long zeroOne = 0; // Number of combinations of 01s\\n        int one = 0; // Individual ones count\\n        long oneZero = 0; // Number of combinations of 10s\\n        long tot = 0; // Final answer\\n        for(char ch : s.toCharArray())\\n        {\\n            if(ch == \\'0\\')\\n            {\\n                zero++;\\n                oneZero += one; // Each of the previously found 1s can pair up with the current 0 to form 10\\n                tot += zeroOne; // Each of the previously formed 01 can form a triplet with the current 0 to form 010\\n            }\\n            else\\n            {\\n                one++;\\n                zeroOne += zero; // Each of the previously found 0s can pair to form 01\\n                tot += oneZero; // Each of the previously formed 10 can form 101\\n            }\\n        }\\n        return tot;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public long numberOfWays(String s)\\n    {\\n        int zero = 0; // Individual zeroes count\\n        long zeroOne = 0; // Number of combinations of 01s\\n        int one = 0; // Individual ones count\\n        long oneZero = 0; // Number of combinations of 10s\\n        long tot = 0; // Final answer\\n        for(char ch : s.toCharArray())\\n        {\\n            if(ch == \\'0\\')\\n            {\\n                zero++;\\n                oneZero += one; // Each of the previously found 1s can pair up with the current 0 to form 10\\n                tot += zeroOne; // Each of the previously formed 01 can form a triplet with the current 0 to form 010\\n            }\\n            else\\n            {\\n                one++;\\n                zeroOne += zero; // Each of the previously found 0s can pair to form 01\\n                tot += oneZero; // Each of the previously formed 10 can form 101\\n            }\\n        }\\n        return tot;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907312,
                "title": "easy-to-understand-c-code",
                "content": "Step1.  Count total number if zeros and ones in string. (count0 and count1)\\nStep2.  Iterate the string from left and keep count of zeroes and ones in till current index.(cur0 and cur1)\\nStep3.  There is only two case is possible 101 and 010. \\n\\tIf you encounter 1 then check for case 010\\n\\tAdd total no of combinations of 010 formed by taking currrent 1 as centre i.e\\n\\t\\t= (total no of 0s on left) * (total no of 0s on right) = cur0 * (count0-cur0)\\n\\tIf you encounter 0 then check for case 101\\n\\tAdd total no of combinations of 101 formed by taking currrent 0 as centre i.e\\n\\t\\t= (total no of 1s on left) * (total no of 1s on right) = cur1 * (count1-cur1)\\t\\n\\t\\treturn final ans.\\t\\n\\n\\n\\n` long long numberOfWays(string s) {`\\n        \\n        int count0=0, count1=0;\\n        for(int i=0;i<s.size();i++)\\n\\t\\t{\\n            if(s[i]==\\'0\\')\\n                count0++;\\n            else\\n                count1++;\\n        }\\n        long long int ans=0;\\n        int cur0=0,cur1=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                cur1++;\\n                ans+=cur0*(count0-cur0);\\n            }\\n            else\\n            {\\n                cur0++;\\n                ans+=cur1*(count1-cur1);\\n            }\\n        }\\n        return ans;\\n        \\n      \\n        \\n    }\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "Step1.  Count total number if zeros and ones in string. (count0 and count1)\\nStep2.  Iterate the string from left and keep count of zeroes and ones in till current index.(cur0 and cur1)\\nStep3.  There is only two case is possible 101 and 010. \\n\\tIf you encounter 1 then check for case 010\\n\\tAdd total no of combinations of 010 formed by taking currrent 1 as centre i.e\\n\\t\\t= (total no of 0s on left) * (total no of 0s on right) = cur0 * (count0-cur0)\\n\\tIf you encounter 0 then check for case 101\\n\\tAdd total no of combinations of 101 formed by taking currrent 0 as centre i.e\\n\\t\\t= (total no of 1s on left) * (total no of 1s on right) = cur1 * (count1-cur1)\\t\\n\\t\\treturn final ans.\\t\\n\\n\\n\\n` long long numberOfWays(string s) {`\\n        \\n        int count0=0, count1=0;\\n        for(int i=0;i<s.size();i++)\\n\\t\\t{\\n            if(s[i]==\\'0\\')\\n                count0++;\\n            else\\n                count1++;\\n        }\\n        long long int ans=0;\\n        int cur0=0,cur1=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                cur1++;\\n                ans+=cur0*(count0-cur0);\\n            }\\n            else\\n            {\\n                cur0++;\\n                ans+=cur1*(count1-cur1);\\n            }\\n        }\\n        return ans;\\n        \\n      \\n        \\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1907308,
                "title": "python-one-pass-method-o-n",
                "content": "In overall, they are only looking for \\'101\\' and \\'010\\'.\\nWe keep track of previous \\'0\\' and \\'1\\' using variable \\'z\\' and \\'o\\'.\\nWhen entering the next building, the previous \\'0\\' and \\'1\\' can be upgraded into \\'01\\' and \\'10\\' respectively as variable \\'oz\\' and \\'zo\\'.\\nAgain, from the previous \\'01\\' and \\'10\\', we can upgrade them into \\'010\\' and \\'101\\' and put them both into variable \\'total\\', which will be the total valid ways to select 3 buildings.\\n```\\ndef sumScores(self, s):\\n\\t# Idea 1: count 0, 1, 01, 10\\n        z, o, zo, oz, total = 0, 0, 0, 0, 0\\n        for c in s:\\n            if c == \\'1\\':\\n                total += oz\\n                zo += z\\n                o += 1\\n            elif c == \\'0\\':\\n                total += zo\\n                oz += o\\n                z += 1\\n        return total\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "In overall, they are only looking for \\'101\\' and \\'010\\'.\\nWe keep track of previous \\'0\\' and \\'1\\' using variable \\'z\\' and \\'o\\'.\\nWhen entering the next building, the previous \\'0\\' and \\'1\\' can be upgraded into \\'01\\' and \\'10\\' respectively as variable \\'oz\\' and \\'zo\\'.\\nAgain, from the previous \\'01\\' and \\'10\\', we can upgrade them into \\'010\\' and \\'101\\' and put them both into variable \\'total\\', which will be the total valid ways to select 3 buildings.\\n```\\ndef sumScores(self, s):\\n\\t# Idea 1: count 0, 1, 01, 10\\n        z, o, zo, oz, total = 0, 0, 0, 0, 0\\n        for c in s:\\n            if c == \\'1\\':\\n                total += oz\\n                zo += z\\n                o += 1\\n            elif c == \\'0\\':\\n                total += zo\\n                oz += o\\n                z += 1\\n        return total\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1907233,
                "title": "idea-explained-dp-memoization-c-clean-code",
                "content": "**Intuition :**\\n\\n* Idea here is similar to that of **Knapsack Problem**.\\n* We have two choices for each building. \\n\\t* Either *pick it*\\n\\t* Or *skip it*\\n* Using this way, we can move across given string and get count. And when length of selected string exceeds 3, simply return from there.\\n* Just here we need to track previous element, so that we do not end up picking same type of buildings.\\n* Thus, we have total three state and dp will look like :\\n\\t* `idx` : current index\\n\\t* `prev` : previous chosen building\\n\\t* `len` : length/number of buildings picked.\\n* Base condition is when we either have picked 3 buildings, or else we have reached end of string.\\n\\nNote : We are assuming that if no building is picked, then `prev = 2`.\\n# Code :\\n```\\nclass Solution {\\nprivate: \\n\\tlong long dp[100003][3][4];\\n\\n    long long solve(string& s, int idx, int prev, int len, int n) {\\n        if(len == 3) return 1;\\n        if(idx == n) {\\n            return 0;\\n        }\\n        if(dp[idx][prev][len] != -1) return dp[idx][prev][len];\\n\\n        long long res = solve(s, idx+1, prev, len, n);\\n\\n        if(prev != (s[idx]-\\'0\\')) {\\n            res += solve(s, idx+1, s[idx]-\\'0\\', len+1, n);\\n        }\\n        return dp[idx][prev][len] = res;\\n    }\\n\\npublic:    \\n    \\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(s, 0, 2, 0, n);\\n    }\\n};\\n```\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate: \\n\\tlong long dp[100003][3][4];\\n\\n    long long solve(string& s, int idx, int prev, int len, int n) {\\n        if(len == 3) return 1;\\n        if(idx == n) {\\n            return 0;\\n        }\\n        if(dp[idx][prev][len] != -1) return dp[idx][prev][len];\\n\\n        long long res = solve(s, idx+1, prev, len, n);\\n\\n        if(prev != (s[idx]-\\'0\\')) {\\n            res += solve(s, idx+1, s[idx]-\\'0\\', len+1, n);\\n        }\\n        return dp[idx][prev][len] = res;\\n    }\\n\\npublic:    \\n    \\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(s, 0, 2, 0, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209681,
                "title": "java-o-n-dp-prefix-sums-solution",
                "content": "There are only 2 Types of Buildings valid for Selection: -> 101 & 010 since these represent an Alternate Subsequence of buildings.\\nBut to build up to either of these building Types, we need to Build up on a smaller Subsequence Building.\\nFor 101 we need 10, & for 10 we need buildings of type 1.\\nLikewise, for 010 we need 01 & for 01 we need buildings of type 0.\\n\\nIf current char == \\'0\\', we do the following,\\nincrease type 0 building, following which increase 10 type which depends on 1s & then increase 010 which depends on 01 type of buildings previously.\\nLikewise we do it for other 3 set of Subsequences.\\n\\n```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long n0 = 0, n1 = 0, n01 = 0, n10 = 0, n010 = 0, n101 = 0;\\n        for(char c: s.toCharArray())\\n        {\\n            if(c == \\'0\\')\\n            {\\n                n0++;\\n                n10 += n1;\\n                n010 += n01;\\n            }\\n            else\\n            {\\n                n1++;\\n                n01 += n0;\\n                n101 += n10;\\n            }\\n        }\\n        \\n        return n101 + n010;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long n0 = 0, n1 = 0, n01 = 0, n10 = 0, n010 = 0, n101 = 0;\\n        for(char c: s.toCharArray())\\n        {\\n            if(c == \\'0\\')\\n            {\\n                n0++;\\n                n10 += n1;\\n                n010 += n01;\\n            }\\n            else\\n            {\\n                n1++;\\n                n01 += n0;\\n                n101 += n10;\\n            }\\n        }\\n        \\n        return n101 + n010;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907344,
                "title": "simple-for-loop-java-o-n",
                "content": "we have only two types of string 101 or 010\\n1. **101** - > 0 is middle , for this 0  find count of 1 in left and 1 in right\\n2. **010** - > 1 is middle ,  for this 1  find count of 0 in left and 0 in right\\n \\n \\n \\n ----\\n **created left and right array**\\n \\n **for each index  i**\\n **if ith index is \\'1\\' store count of 0 in left in 0 in right**\\n **if ith index is \\'0\\' store count of 1 in left in 1 in right**\\n \\n for using ith element as middle we have left[i]*right[i] total strng\\n > one loop to fill left i=0 to n-1\\n > and one loop to fill right  i= n-1 to 0\\n \\n\\n\\n```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long count0 = 0 , count1 = 0;\\n        int n  =  s.length();\\n        long left[] =  new long[n];\\n        long right[] =  new long[n];\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)==\\'1\\' ){\\n                count1++;\\n                left[i] =  count0;\\n            }\\n            if(s.charAt(i)==\\'0\\' ){\\n                count0++;\\n                left[i] =  count1;\\n            }            \\n        }\\n        \\n        count1 = 0;\\n        count0 = 0;\\n        for(int i =  n-1 ;i>=0;i--){\\n            if(s.charAt(i)==\\'1\\' ){\\n                count1++;\\n                right[i] =  count0;\\n            }\\n            if(s.charAt(i)==\\'0\\' ){\\n                count0++;\\n                right[i] =  count1;\\n            }                        \\n        }\\n        \\n        long ways = 0;\\n        for(int i=0;i<n;i++){\\n            char chi = s.charAt(i);\\n            ways +=  left[i]*right[i];\\n        }\\n\\n        return ways;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long count0 = 0 , count1 = 0;\\n        int n  =  s.length();\\n        long left[] =  new long[n];\\n        long right[] =  new long[n];\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)==\\'1\\' ){\\n                count1++;\\n                left[i] =  count0;\\n            }\\n            if(s.charAt(i)==\\'0\\' ){\\n                count0++;\\n                left[i] =  count1;\\n            }            \\n        }\\n        \\n        count1 = 0;\\n        count0 = 0;\\n        for(int i =  n-1 ;i>=0;i--){\\n            if(s.charAt(i)==\\'1\\' ){\\n                count1++;\\n                right[i] =  count0;\\n            }\\n            if(s.charAt(i)==\\'0\\' ){\\n                count0++;\\n                right[i] =  count1;\\n            }                        \\n        }\\n        \\n        long ways = 0;\\n        for(int i=0;i<n;i++){\\n            char chi = s.charAt(i);\\n            ways +=  left[i]*right[i];\\n        }\\n\\n        return ways;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911594,
                "title": "dp",
                "content": "We need to compute ways to pick `101` and `010` combinations of buildings. We can compute those ways independently.\\n\\nSay we want to count `010`. It\\'s best to look at the specific test case, `\"000110010\"`:\\n\\n- `s[5]`: `first == 3`, `second == 2`.\\n\\t- `s[5]` forms 3 * 2 new combinations. We add it to `comb`.\\n\\t- `s[5]` adds `comb` (6) combinations to the result (6).\\n\\t- We reset `second` to zero.\\n- `s[6]`: `first == 4`, `second == 0`.\\n\\t- `s[6]` does not form any new combinations (`second == 0`).\\n\\t- `s[6]` adds `comb` (6) combinations to the result (12).\\n- `s[8]`: `first == 5`, `second == 1`.\\n\\t- `s[5]` forms 5 * 1 new combinations. We add it to `comb` (11).\\n\\t- `s[5]` adds `comb` (11) combinations to the result (23).\\n\\nSimilarly, we count the number of `101` combinations, which is 4. The final result is 27.\\n\\n**C++**\\n```cpp\\nlong long numberOfWays(string &s, char firstLast) {\\n    long long first = 0, second = 0, comb = 0, res = 0;\\n    for (char ch : s)\\n        if (ch == firstLast) {\\n            comb += first * second;\\n            res += comb;\\n            second = 0;\\n            ++first;\\n        }\\n        else\\n            ++second;\\n    return res;\\n}\\nlong long numberOfWays(string s) {\\n    return numberOfWays(s, \\'0\\') + numberOfWays(s, \\'1\\');\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long numberOfWays(string &s, char firstLast) {\\n    long long first = 0, second = 0, comb = 0, res = 0;\\n    for (char ch : s)\\n        if (ch == firstLast) {\\n            comb += first * second;\\n            res += comb;\\n            second = 0;\\n            ++first;\\n        }\\n        else\\n            ++second;\\n    return res;\\n}\\nlong long numberOfWays(string s) {\\n    return numberOfWays(s, \\'0\\') + numberOfWays(s, \\'1\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906960,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        \\n        temp = []\\n        c0 = 0\\n        c1 = 0\\n        for char in s :\\n            if char == \"0\" :\\n                c0+=1\\n            else:\\n                c1+=1\\n            temp.append([c0,c1])\\n            \\n        total0 = c0\\n        total1 = c1\\n        \\n        \\n        count = 0\\n        for i in range(1, len(s)-1) :\\n            \\n            if s[i] == \"0\" :\\n                m1 = temp[i-1][1]\\n                m2 = total1 - temp[i][1]\\n                count += m1*m2\\n                \\n            else:\\n                m1 = temp[i-1][0]\\n                m2 = total0 - temp[i][0]\\n                count += m1*m2\\n        return count\\n                \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        \\n        temp = []\\n        c0 = 0\\n        c1 = 0\\n        for char in s :\\n            if char == \"0\" :\\n                c0+=1\\n            else:\\n                c1+=1\\n            temp.append([c0,c1])\\n            \\n        total0 = c0\\n        total1 = c1\\n        \\n        \\n        count = 0\\n        for i in range(1, len(s)-1) :\\n            \\n            if s[i] == \"0\" :\\n                m1 = temp[i-1][1]\\n                m2 = total1 - temp[i][1]\\n                count += m1*m2\\n                \\n            else:\\n                m1 = temp[i-1][0]\\n                m2 = total0 - temp[i][0]\\n                count += m1*m2\\n        return count\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144482,
                "title": "easiest-c-code-single-pass-o-1-space-with-explanation",
                "content": "1. We\\'ll just parse through the array from the last keeping the count of ones and zeros we\\'ve passed through. Now when we\\'ll arrive at a \\'1\\', the result will be incremented by the variable oneKeLiye and when we come at a \\'0\\' result would be incremented by zeroKeLiye.\\n\\n2. Now how do we maintain oneKeLiye and zeroKeLiye, we can observe that there are only two possible permutation i.e., \"010\" and \"101\", now oneKeLiye will store the total possibilities of making \"01\" after the current index (Therefore added when we arrive at a \\'1\\'). \\n\\n3. Similarly, zeroKeLiye will store the possibilites of storing \"10\" after the current index.\\n\\n4. Whenever we arrive at a zero we also increase oneKeLiye by the number of ones we\\'ve encountered, which is basically the number of \"01\" when the 0 is at current index.\\n\\nHere\\'s the code:\\n\\n    long long numberOfWays(string s) {\\n        int n=s.size();\\n        long long int res=0;\\n        long long int ones=0,zeros=0;\\n        long long int oneKeLiye=0,zeroKeLiye=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n                ones++;\\n            else\\n                zeros++;\\n            \\n            if(s[i]==\\'1\\'){\\n                zeroKeLiye+=zeros;\\n                res+=oneKeLiye;\\n            }\\n            else{\\n                oneKeLiye+=ones;\\n                res+=zeroKeLiye;\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "1. We\\'ll just parse through the array from the last keeping the count of ones and zeros we\\'ve passed through. Now when we\\'ll arrive at a \\'1\\', the result will be incremented by the variable oneKeLiye and when we come at a \\'0\\' result would be incremented by zeroKeLiye.\\n\\n2. Now how do we maintain oneKeLiye and zeroKeLiye, we can observe that there are only two possible permutation i.e., \"010\" and \"101\", now oneKeLiye will store the total possibilities of making \"01\" after the current index (Therefore added when we arrive at a \\'1\\'). \\n\\n3. Similarly, zeroKeLiye will store the possibilites of storing \"10\" after the current index.\\n\\n4. Whenever we arrive at a zero we also increase oneKeLiye by the number of ones we\\'ve encountered, which is basically the number of \"01\" when the 0 is at current index.\\n\\nHere\\'s the code:\\n\\n    long long numberOfWays(string s) {\\n        int n=s.size();\\n        long long int res=0;\\n        long long int ones=0,zeros=0;\\n        long long int oneKeLiye=0,zeroKeLiye=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n                ones++;\\n            else\\n                zeros++;\\n            \\n            if(s[i]==\\'1\\'){\\n                zeroKeLiye+=zeros;\\n                res+=oneKeLiye;\\n            }\\n            else{\\n                oneKeLiye+=ones;\\n                res+=zeroKeLiye;\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1986301,
                "title": "python-3-simple-solution-o-n-o-1-faster-than-99",
                "content": "```\\ndef numberOfWays(self, s: str) -> int:\\n        ways = one = zero = onesAfterZero = zerosAfterOne = 0\\n\\t\\tfor i in s:\\n\\t\\t\\tif i == \\'0\\':\\n\\t\\t\\t\\tzero += 1\\n\\t\\t\\t\\tzerosAfterOne += one\\n\\t\\t\\t\\tways += onesAfterZero\\n\\t\\t\\telse:\\n\\t\\t\\t\\tone += 1\\n\\t\\t\\t\\tonesAfterZero += zero\\n\\t\\t\\t\\tways += zerosAfterOne\\n\\t\\treturn ways\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef numberOfWays(self, s: str) -> int:\\n        ways = one = zero = onesAfterZero = zerosAfterOne = 0\\n\\t\\tfor i in s:\\n\\t\\t\\tif i == \\'0\\':\\n\\t\\t\\t\\tzero += 1\\n\\t\\t\\t\\tzerosAfterOne += one\\n\\t\\t\\t\\tways += onesAfterZero\\n\\t\\t\\telse:\\n\\t\\t\\t\\tone += 1\\n\\t\\t\\t\\tonesAfterZero += zero\\n\\t\\t\\t\\tways += zerosAfterOne\\n\\t\\treturn ways\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1979756,
                "title": "python-3-short-and-simple-o-n-o-1",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        zeros = s.count(\\'0\\')\\n        ones = len(s) - zeros\\n        zeroPrefix = onePrefix = res = 0\\n        for c in s:\\n            if c == \\'0\\':\\n                res += onePrefix * (ones - onePrefix)\\n                zeroPrefix += 1\\n            else:\\n                res += zeroPrefix * (zeros - zeroPrefix)\\n                onePrefix += 1\\n        \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        zeros = s.count(\\'0\\')\\n        ones = len(s) - zeros\\n        zeroPrefix = onePrefix = res = 0\\n        for c in s:\\n            if c == \\'0\\':\\n                res += onePrefix * (ones - onePrefix)\\n                zeroPrefix += 1\\n            else:\\n                res += zeroPrefix * (zeros - zeroPrefix)\\n                onePrefix += 1\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1933323,
                "title": "o-n-time-o-1-space-easy-to-understand-java-solution",
                "content": "There are only 2 valid patterns: \\u2018101\\u2019 and \\u2018010\\u2019. So we have to count number of subsequences of \"010\" and \"101\".\\n\\nThe approach is to count to n0(number of zeroes), n1(number of ones), n01(number of \"01\" subsequences), n10(number of \"10\" subsequences), n010(number of \"010\" subsequences), n101(number of \"101\" subsequences).\\n\\nAt ith point if s[i] is 0 : increase n0 by 1, increase n10 by n1 i.e. (mapping all previous 1\\'s with this 0) and increase n010 by n01 i.e. (mapping all previous \"01\"\\'s by this 0).\\n\\nAt ith point if s[i] is 1 : increase n1 by 1, increase n01 by n0 i.e. (mapping all previous 0\\'s with this 1) and increase n101 by n10 i.e. (mapping all previous \"10\"\\'s by this 1).\\n\\nAnswer would be n010 + n101;\\n\\n```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        int n = s.length();\\n        long n0 = 0;\\n        long n1 = 0;\\n        long n01 = 0;\\n        long n10 = 0;\\n        long n010 = 0;\\n        long n101 = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'0\\'){\\n                n0++;\\n                n10 += n1;\\n                n010 += n01;\\n            }\\n            else{\\n                n1++;\\n                n01 += n0;\\n                n101 += n10;\\n            }\\n        }\\n        \\n        return n010 + n101;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        int n = s.length();\\n        long n0 = 0;\\n        long n1 = 0;\\n        long n01 = 0;\\n        long n10 = 0;\\n        long n010 = 0;\\n        long n101 = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'0\\'){\\n                n0++;\\n                n10 += n1;\\n                n010 += n01;\\n            }\\n            else{\\n                n1++;\\n                n01 += n0;\\n                n101 += n10;\\n            }\\n        }\\n        \\n        return n010 + n101;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907017,
                "title": "c-prefix-sum",
                "content": "there are only two types of pattern of choosing the three elemets.\\nwhich are chosing 1 as middle element and 0  as side building and vice versa.\\nso with the help of prefix and suffix sum array find the no. elemets which are left & right of cur element(0 or 1)\\nand just add no.  of possible ways i.e. (l[i]*r[i])\\n```\\nclass Solution {\\npublic:\\n\\tlong long numberOfWays(string s) {\\n\\t\\tlong long ans = solve(s, 0); // for 1 as middle element we need to make prefix and surfix array for 0\\n\\t\\tans += solve(s, 1); // same for 0\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tlong long solve(string s, int c) {\\n\\t\\tlong long ans = 0;\\n\\t\\tlong long n = s.size();\\n\\t\\tvector<long long>l(n, 0), r(n, 0);\\n\\n\\t\\tint cnt = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tl[i] = cnt;\\n\\t\\t\\tif (s[i] == c +  \\'0\\') {\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcnt = 0;\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tr[i] = cnt;\\n\\t\\t\\tif (s[i] == c + \\'0\\') {\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint x = (c == 0) ? 1 : 0;\\n\\t\\tfor (int i = 1; i < n - 1; i++) {\\n\\t\\t\\tif (s[i] == x + \\'0\\') {\\n\\t\\t\\t\\tans += l[i] * r[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tlong long numberOfWays(string s) {\\n\\t\\tlong long ans = solve(s, 0); // for 1 as middle element we need to make prefix and surfix array for 0\\n\\t\\tans += solve(s, 1); // same for 0\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tlong long solve(string s, int c) {\\n\\t\\tlong long ans = 0;\\n\\t\\tlong long n = s.size();\\n\\t\\tvector<long long>l(n, 0), r(n, 0);\\n\\n\\t\\tint cnt = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tl[i] = cnt;\\n\\t\\t\\tif (s[i] == c +  \\'0\\') {\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcnt = 0;\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tr[i] = cnt;\\n\\t\\t\\tif (s[i] == c + \\'0\\') {\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint x = (c == 0) ? 1 : 0;\\n\\t\\tfor (int i = 1; i < n - 1; i++) {\\n\\t\\t\\tif (s[i] == x + \\'0\\') {\\n\\t\\t\\t\\tans += l[i] * r[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907010,
                "title": "simple-explanation-python",
                "content": "**Solution 1: O(n) space**\\n\\nOnly 2 patterns are possible:\\n`101`\\n`010`\\n\\nCalculate 0s and 1s from left.\\nCalculate 0s and 1s from right.\\n\\nFix the middle element of pattern e.g. `0` in `101`. \\nThen total number of combinations will be `cnt(1s on the left) * cnt(1s on the right)`.\\n\\n\\n```\\ndef numberOfWays(self, s: str) -> int:\\n    n = len(s)\\n    right0, right1 = [0]*n, [0]*n # 0s and 1s to the right of index i\\n    left0, left1 = [0]*n, [0]*n # 0s and 1s to the left of index i\\n\\n    cnt0, cnt1 = 0, 0\\n    for i in range(n-1,-1,-1): # right to left\\n        right0[i], right1[i] = cnt0, cnt1\\n        if s[i] == \\'0\\':\\n            cnt0 += 1\\n        else:\\n            cnt1 += 1\\n    \\n    \\n    cnt0, cnt1 = 0, 0\\n    for i in range(n):\\n        left0[i], left1[i] = cnt0, cnt1\\n        if s[i] == \\'0\\':\\n            cnt0 += 1\\n        else:\\n            cnt1 += 1\\n    \\n\\n    res = 0\\n    for i in range(n):\\n        if s[i] == \\'1\\':\\n            res += left0[i] * right0[i] # 010\\n        else:\\n            res += left1[i] * right1[i] # 101\\n    return res\\n```\\n\\n\\n\\n\\n**Solution 2: O(1) space**\\n\\nBy rock: https://leetcode.com/problems/number-of-ways-to-select-buildings/discuss/1907179/JavaPython-3-Space-O(1)-code-w-brief-explanation-and-analysis. \\n\\nCalculate the no. of patterns: `01` and `10`\\nNow when you encounter 1, you can use the count of `10`s to the left and append this `1` to the end. This will count for `101`.\\nNow when you encounter 0, you can use the count of `01`s to the left. This will count for `010`.\\n\\n\\n```\\ndef numberOfWays(self, s: str) -> int:\\n    ways = 0\\n    one = zero = zero_one = one_zero = 0\\n    for c in s:\\n        if c == \\'0\\':\\n            zero += 1\\n            one_zero += one\\n            ways += zero_one\\n        else:\\n            one += 1    \\n            zero_one += zero \\n            ways += one_zero\\n    return ways\\n```",
                "solutionTags": [],
                "code": "```\\ndef numberOfWays(self, s: str) -> int:\\n    n = len(s)\\n    right0, right1 = [0]*n, [0]*n # 0s and 1s to the right of index i\\n    left0, left1 = [0]*n, [0]*n # 0s and 1s to the left of index i\\n\\n    cnt0, cnt1 = 0, 0\\n    for i in range(n-1,-1,-1): # right to left\\n        right0[i], right1[i] = cnt0, cnt1\\n        if s[i] == \\'0\\':\\n            cnt0 += 1\\n        else:\\n            cnt1 += 1\\n    \\n    \\n    cnt0, cnt1 = 0, 0\\n    for i in range(n):\\n        left0[i], left1[i] = cnt0, cnt1\\n        if s[i] == \\'0\\':\\n            cnt0 += 1\\n        else:\\n            cnt1 += 1\\n    \\n\\n    res = 0\\n    for i in range(n):\\n        if s[i] == \\'1\\':\\n            res += left0[i] * right0[i] # 010\\n        else:\\n            res += left1[i] * right1[i] # 101\\n    return res\\n```\n```\\ndef numberOfWays(self, s: str) -> int:\\n    ways = 0\\n    one = zero = zero_one = one_zero = 0\\n    for c in s:\\n        if c == \\'0\\':\\n            zero += 1\\n            one_zero += one\\n            ways += zero_one\\n        else:\\n            one += 1    \\n            zero_one += zero \\n            ways += one_zero\\n    return ways\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2391922,
                "title": "easy-to-follow-c-code",
                "content": "```\\n/*\\n\\nThere can be only two types of selections: 101 or 010\\n\\n-> Iterate over the string and in each iteration,\\n\\tIf current character is \\'0\\', it can be the middle of \"101\" slection\\n\\t\\tadd how many selections can be there with this \\'0\\' as the middle element\\n\\t\\t(this is, numbers of ones on the left * number of ones on the right)\\n\\tIf current character is \\'1\\', it can be the middle of \"010\" selection\\n\\t\\tadd how many selections can be there with this \\'1\\' as the middle element\\n\\t\\t(this is, numbers of zeros on the left * number of zeros on the right)\\n-> return ans\\n*/\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long left0 = 0, left1 = 0, count0 = 0, count1 = 0, ans = 0;\\n        for(char ch : s) {\\n            count0 += (ch == \\'0\\');\\n            count1 += (ch == \\'1\\');\\n        }\\n        for(int i=0; i<s.length(); i++) {\\n            if(s[i] == \\'1\\')    ans += left0 * (count0 - left0);\\n            if(s[i] == \\'0\\')    ans += left1 * (count1 - left1);\\n            left0 += (s[i] == \\'0\\');\\n            left1 += (s[i] == \\'1\\');\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\n/*\\n\\nThere can be only two types of selections: 101 or 010\\n\\n-> Iterate over the string and in each iteration,\\n\\tIf current character is \\'0\\', it can be the middle of \"101\" slection\\n\\t\\tadd how many selections can be there with this \\'0\\' as the middle element\\n\\t\\t(this is, numbers of ones on the left * number of ones on the right)\\n\\tIf current character is \\'1\\', it can be the middle of \"010\" selection\\n\\t\\tadd how many selections can be there with this \\'1\\' as the middle element\\n\\t\\t(this is, numbers of zeros on the left * number of zeros on the right)\\n-> return ans\\n*/\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long left0 = 0, left1 = 0, count0 = 0, count1 = 0, ans = 0;\\n        for(char ch : s) {\\n            count0 += (ch == \\'0\\');\\n            count1 += (ch == \\'1\\');\\n        }\\n        for(int i=0; i<s.length(); i++) {\\n            if(s[i] == \\'1\\')    ans += left0 * (count0 - left0);\\n            if(s[i] == \\'0\\')    ans += left1 * (count1 - left1);\\n            left0 += (s[i] == \\'0\\');\\n            left1 += (s[i] == \\'1\\');\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907871,
                "title": "python-3-prefix-suffix-sum-easy-to-understand-explanation",
                "content": "### Explanation\\n- For `\"1\"`, we want `\"010\"`\\n- For `\"0\"`, we want `\"101\"`\\n- Thus, all we need to do is to count how many `0`s and `1`s are before/after `1` and `0`\\n- See comments below for more explanation\\n### Implementation\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        prefix = []\\n        one = zero = 0\\n        for c in s:                                # find number of 0 or 1 before index `i`\\n            prefix.append([zero, one])\\n            if c == \\'1\\':\\n                one += 1\\n            else:\\n                zero += 1    \\n        suffix = []        \\n        one = zero = 0\\n        for c in s[::-1]:                          # find number of 0 or 1 after index `i`\\n            suffix.append([zero, one])\\n            if c == \\'1\\':\\n                one += 1\\n            else:\\n                zero += 1    \\n        suffix = suffix[::-1]                      # reverse since we trace from right to left \\n        ans = 0\\n        for i, c in enumerate(s):                  # for c==\\'1\\' number of combination is prefix[i][0] * suffix[i][0] ([0 before index `i`] * [0 after index `i`])\\n            if c == \\'1\\':\\n                ans += prefix[i][0] * suffix[i][0]\\n            else:    \\n                ans += prefix[i][1] * suffix[i][1]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        prefix = []\\n        one = zero = 0\\n        for c in s:                                # find number of 0 or 1 before index `i`\\n            prefix.append([zero, one])\\n            if c == \\'1\\':\\n                one += 1\\n            else:\\n                zero += 1    \\n        suffix = []        \\n        one = zero = 0\\n        for c in s[::-1]:                          # find number of 0 or 1 after index `i`\\n            suffix.append([zero, one])\\n            if c == \\'1\\':\\n                one += 1\\n            else:\\n                zero += 1    \\n        suffix = suffix[::-1]                      # reverse since we trace from right to left \\n        ans = 0\\n        for i, c in enumerate(s):                  # for c==\\'1\\' number of combination is prefix[i][0] * suffix[i][0] ([0 before index `i`] * [0 after index `i`])\\n            if c == \\'1\\':\\n                ans += prefix[i][0] * suffix[i][0]\\n            else:    \\n                ans += prefix[i][1] * suffix[i][1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907155,
                "title": "top-down-dp-java",
                "content": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n       int n = s.length();\\n        long[][][] dp = new long[n][4][4];\\n        for(long[][] y : dp)\\n            for(long[] x : y)\\n        Arrays.fill(x,-1);\\n        return solve(0,0,\\'2\\',s.toCharArray(),dp);\\n    }\\n    public long solve(int i ,int c ,char prev ,char[] s,long[][][] dp){\\n        if(c==3)return 1;\\n        if(i>=s.length) return 0;\\n         if(dp[i][c][prev-\\'0\\']!=-1) return dp[i][c][prev-\\'0\\'];\\n        long a=0 ,b=0;\\n        if(s[i]!=prev){\\n            a= solve(i+1,c+1,s[i],s,dp); //if current char is not equal to previous then can take it .\\n        } \\n            b = solve(i+1,c,prev,s,dp);//if current char is same as previous then cannot take .so just look in the next char.\\n        \\n        return dp[i][c][prev-\\'0\\'] =   (a+b);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n       int n = s.length();\\n        long[][][] dp = new long[n][4][4];\\n        for(long[][] y : dp)\\n            for(long[] x : y)\\n        Arrays.fill(x,-1);\\n        return solve(0,0,\\'2\\',s.toCharArray(),dp);\\n    }\\n    public long solve(int i ,int c ,char prev ,char[] s,long[][][] dp){\\n        if(c==3)return 1;\\n        if(i>=s.length) return 0;\\n         if(dp[i][c][prev-\\'0\\']!=-1) return dp[i][c][prev-\\'0\\'];\\n        long a=0 ,b=0;\\n        if(s[i]!=prev){\\n            a= solve(i+1,c+1,s[i],s,dp); //if current char is not equal to previous then can take it .\\n        } \\n            b = solve(i+1,c,prev,s,dp);//if current char is same as previous then cannot take .so just look in the next char.\\n        \\n        return dp[i][c][prev-\\'0\\'] =   (a+b);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031207,
                "title": "easy-c-code-o-1-space-and-o-n-time-complexity-efficient-approach",
                "content": "**The Only ways in which you can select 3 buildings where consecutive buildings are not of same type are :\\n010\\n101**\\nSo,when we will be traversing array we will keep track of count of 0\\'s, 1\\'s, 01\\'s ,10\\'s ,010\\'s and 101\\'s till now.\\nSo,If current element is 0 then the count of 0\\'s,10\\'s and 010\\'s will change.So:\\ncount of 10\\'s = count of 1\\'s  ( Because current 0 will get mapped with all previous 1\\'s to make it 10)\\ncount of 010\\'s = count of 01\\'s (Because current 0 will get mapped with previous 01\\'s to make it 010]\\ncount of 0\\'s will increase by 1.\\n\\nIf current element is 1 then the count of 1\\'s, 01\\'s and 101\\'s will change.So:\\ncount of 01\\'s = count of 0\\'s ( Because current 1 will get mapped with all previous 0\\'s to make it 01)\\ncount of 101\\'s = count of 10\\'s ( Because current 1 will get mapped with previous 10\\'s to make it 101)\\n```\\n long long numberOfWays(string s) {\\n        long int c0 = 0,c1=0,c01=0,c10 = 0,c010=0,c101=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] == \\'0\\')\\n            {\\n                c10 += c1;\\n                c010 += c01;\\n                c0++;\\n            }\\n            else\\n            {\\n                c01 += c0;\\n                c101 += c10;\\n                c1++;\\n            }\\n        }\\n        return c010 + c101;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n long long numberOfWays(string s) {\\n        long int c0 = 0,c1=0,c01=0,c10 = 0,c010=0,c101=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] == \\'0\\')\\n            {\\n                c10 += c1;\\n                c010 += c01;\\n                c0++;\\n            }\\n            else\\n            {\\n                c01 += c0;\\n                c101 += c10;\\n                c1++;\\n            }\\n        }\\n        return c010 + c101;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908071,
                "title": "javascript-o-n-time-and-constant-space",
                "content": "The idea is for every character (\\'0\\' or \\'1\\') at index i, the possible solutions that can be formed from it are:\\nnumber of the opposite of this character that occured before it (e.i. if it is \\'0\\', then number of 1\\'s before it) * number of 1\\'s occured after it and vice versa.\\n\\n```\\nvar numberOfWays = function (s) {\\n  \\n  let result = 0,\\n    zeroes = s.replaceAll(\\'1\\', \\'\\').length,\\n    ones = s.length - zeroes,\\n    curZeroes = 0,\\n    curOnes = 0;\\n\\n  for (let i = 0; i < s.length; i++) {\\n    s[i] === \\'0\\'\\n      ? (result += curOnes * (ones - curOnes))\\n      : (result += curZeroes * (zeroes - curZeroes));\\n      \\n    s[i] === \\'0\\' ? curZeroes++ : curOnes++;\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numberOfWays = function (s) {\\n  \\n  let result = 0,\\n    zeroes = s.replaceAll(\\'1\\', \\'\\').length,\\n    ones = s.length - zeroes,\\n    curZeroes = 0,\\n    curOnes = 0;\\n\\n  for (let i = 0; i < s.length; i++) {\\n    s[i] === \\'0\\'\\n      ? (result += curOnes * (ones - curOnes))\\n      : (result += curZeroes * (zeroes - curZeroes));\\n      \\n    s[i] === \\'0\\' ? curZeroes++ : curOnes++;\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907563,
                "title": "easily-understandable-c-code-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string &s) {\\n        int n=s.size(); \\n        vector<long long>pre1(n,0);// for no of 1\\'s \\n        vector<long long>pre2(n,0); //          0\\'s\\n        \\n        pre1[0]=(s[0]==\\'1\\'); \\n        \\n        for(int i=1;i<n;i++){\\n            pre1[i]=(pre1[i-1]+(s[i]==\\'1\\'));  \\n        }\\n        \\n        pre2[0]=(s[0]==\\'0\\'); \\n        \\n        for(int i=1;i<n;i++){\\n            pre2[i]=(pre2[i-1]+(s[i]==\\'0\\'));  \\n        }\\n        \\n        long long ans=0;  \\n        for(int i=1;i<n-1;i++){\\n            if(s[i]==\\'0\\'){\\n                ans+= (pre1[i-1]*(pre1[n-1]-pre1[i]));  \\n            }\\n            else{\\n                ans+= (pre2[i-1]*(pre2[n-1]-pre2[i])); \\n            }\\n        }\\n        return ans;   \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Counting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string &s) {\\n        int n=s.size(); \\n        vector<long long>pre1(n,0);// for no of 1\\'s \\n        vector<long long>pre2(n,0); //          0\\'s\\n        \\n        pre1[0]=(s[0]==\\'1\\'); \\n        \\n        for(int i=1;i<n;i++){\\n            pre1[i]=(pre1[i-1]+(s[i]==\\'1\\'));  \\n        }\\n        \\n        pre2[0]=(s[0]==\\'0\\'); \\n        \\n        for(int i=1;i<n;i++){\\n            pre2[i]=(pre2[i-1]+(s[i]==\\'0\\'));  \\n        }\\n        \\n        long long ans=0;  \\n        for(int i=1;i<n-1;i++){\\n            if(s[i]==\\'0\\'){\\n                ans+= (pre1[i-1]*(pre1[n-1]-pre1[i]));  \\n            }\\n            else{\\n                ans+= (pre2[i-1]*(pre2[n-1]-pre2[i])); \\n            }\\n        }\\n        return ans;   \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260610,
                "title": "python-explained-o-n-time-o-n-space",
                "content": "```\\n#Baraa\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        \"\"\"\\n        This solution could be optimized as i have seen people figured out\\n        O(1) space solution, however this is what i have reached which could be helpful!\\n        \\n        We iterate from the end of the string s, store the following:\\n        1 - count of zeros we have next -> this will be used to count amount of \"10\" we can make when we are currently on index of value \"1\"\\n        \\n        2 - count of ones we have next -> this will be used to count amount of \"01\" we can make when we are currently on index of value \"0\"\\n        \\n        3- count of \"01\" we have formed -> this will be helpful in the second iteration\\n        4- count of \"10\" we have formed -> this will be helpful in the second iteration\\n        \\n        \"\"\"\\n        n = len(s)\\n        dp = [[0, 0, 0, 0]] * (n + 1) # [one count, zero count, \"01\" count, \"10\" count]\\n        for i in range(n - 1, -1, -1):\\n            prev_ones, prev_zero, prev_01, prev_10 = dp[i + 1]\\n            #if the current value i.e s[i] has value of \\'1\\' then this means we can make prev_10 + prev_zero of \"10\" sequence as currently we have \"1\" so we can match it with any of zeros we face later\\n            if s[i] == \"1\":\\n                dp[i] = [prev_ones + 1, prev_zero, prev_01, prev_10 + prev_zero]\\n            #same comment applies here but for zeros i.e we form \"01\" sequence \\n            else:\\n                dp[i] = [prev_ones, prev_zero + 1, prev_01 + prev_ones, prev_10]\\n        \\n        res = 0\\n        for i in range(n - 2):\\n            #we are currently at zero so we need \"10\" only so we check how many sequences of \"10\" we have in front of us\\n            if s[i] == \"0\":\\n                res += dp[i][-1]\\n            #we are currently at one so we need \"01\" only so we check how many sequences of \"01\" we have in front of us\\n            else:\\n                res += dp[i][-2]\\n        return res\\n        \\n        \\n                \\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\n#Baraa\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        \"\"\"\\n        This solution could be optimized as i have seen people figured out\\n        O(1) space solution, however this is what i have reached which could be helpful!\\n        \\n        We iterate from the end of the string s, store the following:\\n        1 - count of zeros we have next -> this will be used to count amount of \"10\" we can make when we are currently on index of value \"1\"\\n        \\n        2 - count of ones we have next -> this will be used to count amount of \"01\" we can make when we are currently on index of value \"0\"\\n        \\n        3- count of \"01\" we have formed -> this will be helpful in the second iteration\\n        4- count of \"10\" we have formed -> this will be helpful in the second iteration\\n        \\n        \"\"\"\\n        n = len(s)\\n        dp = [[0, 0, 0, 0]] * (n + 1) # [one count, zero count, \"01\" count, \"10\" count]\\n        for i in range(n - 1, -1, -1):\\n            prev_ones, prev_zero, prev_01, prev_10 = dp[i + 1]\\n            #if the current value i.e s[i] has value of \\'1\\' then this means we can make prev_10 + prev_zero of \"10\" sequence as currently we have \"1\" so we can match it with any of zeros we face later\\n            if s[i] == \"1\":\\n                dp[i] = [prev_ones + 1, prev_zero, prev_01, prev_10 + prev_zero]\\n            #same comment applies here but for zeros i.e we form \"01\" sequence \\n            else:\\n                dp[i] = [prev_ones, prev_zero + 1, prev_01 + prev_ones, prev_10]\\n        \\n        res = 0\\n        for i in range(n - 2):\\n            #we are currently at zero so we need \"10\" only so we check how many sequences of \"10\" we have in front of us\\n            if s[i] == \"0\":\\n                res += dp[i][-1]\\n            #we are currently at one so we need \"01\" only so we check how many sequences of \"01\" we have in front of us\\n            else:\\n                res += dp[i][-2]\\n        return res\\n        \\n        \\n                \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907069,
                "title": "recursion-memorization-dp-c",
                "content": "1st state for normal indexing\\n2nd state for value of k\\n3rd state for previous value ( as we can\\'t keep 2 0\\'s or 2 1\\'s together )\\n```\\nclass Solution {\\npublic:\\n    long long dp[100001][4][3];\\n    long long solve(char prev,int i,int k,string &s){\\n        if(k == 0) return 1;\\n        if(i == s.size()) return 0;\\n        if(dp[i][k][prev - \\'0\\'] != -1) return dp[i][k][prev - \\'0\\'];\\n        \\n        long long op1 = 0;\\n        if(s[i] != prev) op1 = solve(s[i],i+1,k-1,s);\\n        long long op2 = solve(prev,i+1,k,s);\\n        return dp[i][k][prev - \\'0\\'] = op1 + op2;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(\\'2\\',0,3,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100001][4][3];\\n    long long solve(char prev,int i,int k,string &s){\\n        if(k == 0) return 1;\\n        if(i == s.size()) return 0;\\n        if(dp[i][k][prev - \\'0\\'] != -1) return dp[i][k][prev - \\'0\\'];\\n        \\n        long long op1 = 0;\\n        if(s[i] != prev) op1 = solve(s[i],i+1,k-1,s);\\n        long long op2 = solve(prev,i+1,k,s);\\n        return dp[i][k][prev - \\'0\\'] = op1 + op2;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(\\'2\\',0,3,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827680,
                "title": "python-3-beats-100",
                "content": "# Intuition\\nFor each house calculate how many inspections where this house is the last one\\n\\n# Approach\\n1. Iterate over houses\\n2. If house is \\'1\\' $\\\\Longrightarrow$ previous house should be \\'0\\'\\n  2.1 We can choose any previous \\'0\\' as the 2nd house and any \\'1\\' before that \\'0\\' as the 1st\\n  2.2 Because of that when we see \\'0\\' we add count of previous ones in special sum \\u2014 `options_for_ones` (options_for_ones, because we will use it when we see house \\'1\\')\\n  2.3 So when we see current house, `options_for_ones` indicates the exact number of combinations of choosing any previously seen \\'0\\' and any \\'1\\' before that $\\\\Longrightarrow$ ans += options_for_ones\\n3. If house is \\'0\\' \\u2014 similarly\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        ans = 0\\n        ones = 0\\n        zeros = 0\\n        options_for_zeros = 0\\n        options_for_ones = 0\\n        for x in s:\\n            if x == \\'1\\':\\n                ans += options_for_ones\\n                options_for_zeros += zeros\\n                ones += 1\\n            else:\\n                ans += options_for_zeros\\n                options_for_ones += ones\\n                zeros += 1\\n        return ans\\n```\\n\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n\\n- Space complexity: $O(1)$",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        ans = 0\\n        ones = 0\\n        zeros = 0\\n        options_for_zeros = 0\\n        options_for_ones = 0\\n        for x in s:\\n            if x == \\'1\\':\\n                ans += options_for_ones\\n                options_for_zeros += zeros\\n                ones += 1\\n            else:\\n                ans += options_for_zeros\\n                options_for_ones += ones\\n                zeros += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730465,
                "title": "easy-dp-python-solution",
                "content": "O(N), nospace\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        zeroes, ones = 0, 0\\n        counts01, counts10 = 0, 0\\n        counts010, counts101 = 0, 0\\n        for i, v in enumerate(s):\\n            if v == \\'0\\':\\n                zeroes += 1\\n                counts10 += ones\\n                counts010 += counts01         \\n            else:\\n                ones += 1\\n                counts01 += zeroes\\n                counts101 += counts10\\n        \\n        return counts010 + counts101\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        zeroes, ones = 0, 0\\n        counts01, counts10 = 0, 0\\n        counts010, counts101 = 0, 0\\n        for i, v in enumerate(s):\\n            if v == \\'0\\':\\n                zeroes += 1\\n                counts10 += ones\\n                counts010 += counts01         \\n            else:\\n                ones += 1\\n                counts01 += zeroes\\n                counts101 += counts10\\n        \\n        return counts010 + counts101\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557456,
                "title": "cpp-solution-using-prefix-array",
                "content": "```\\n#define v vector<long long>\\nclass Solution {\\npublic:\\n       \\n    long long numberOfWays(string s) {\\n        int n=s.size();\\n        \\n        v zero_one(n),one_zero(n),a(n),b(n);\\n        \\n        int ctzero=0,ctone=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                ctzero++;\\n                one_zero[i]=ctone;\\n            }\\n            \\n            else{\\n                ctone++;\\n                zero_one[i]=ctzero;\\n            }\\n        }\\n        \\n        int ct=0,ct1=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\'0\\'){\\n                ct++;\\n            }\\n            a[i]=ct;\\n            \\n            if(s[i]==\\'1\\'){\\n                ct1++;\\n            }\\n            \\n            b[i]=ct1;\\n        }\\n        \\n        long long ans=0;\\n        \\n        for(int i=0;i<n-1;i++){\\n            ans+=zero_one[i]*a[i+1];\\n            ans+=one_zero[i]*b[i+1];\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n       \\n    long long numberOfWays(string s) {\\n        int n=s.size();\\n        \\n        v zero_one(n),one_zero(n),a(n),b(n);\\n        \\n        int ctzero=0,ctone=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                ctzero++;\\n                one_zero[i]=ctone;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2510161,
                "title": "c-concise-solution-explanation-o-n-time-and-space-complexity",
                "content": "There are only two types of buildring we can make either ```010``` or ```101```. Think about the mid digit only, if we take mid 0 then the other two boundary values should be 1 and for mid value 1, the other two value sould be 0. So I am calculating how may valid numbers available from left side and right side in each position and multiply them as we need all of the combinations.\\n\\n\\n\\n\\n```\\n long long numberOfWays(string s) {\\n        vector<int> zeroCount(s.size(), 0), oneCount(s.size(), 0);\\n        long long res = 0L;\\n        \\n        zeroCount[0] = (s[0] == \\'0\\');\\n        oneCount[0] = (s[0] == \\'1\\');\\n        \\n        for(int i=1; i<s.size(); i++)\\n        {\\n            zeroCount[i] = zeroCount[i-1] + (s[i] == \\'0\\');\\n            oneCount[i] = oneCount[i-1] + (s[i] == \\'1\\');\\n        }\\n        \\n        for(int i=1; i<s.size()-1; i++)\\n        {\\n            res += (s[i] == \\'1\\')? (long long)(zeroCount[i] * (zeroCount[s.size()-1] - zeroCount[i]))\\n                :  (long long)(oneCount[i] * (oneCount[s.size()-1] - oneCount[i]));\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\n***Complexity:*** \\nTime - O(n)\\nSpace - O(n)\\n\\n***Note:*** Instead of using two counter vectors, we can easily reach our goal by using one. For the sake of simplicity, I kept two.",
                "solutionTags": [
                    "C"
                ],
                "code": "```010```\n```101```\n```\\n long long numberOfWays(string s) {\\n        vector<int> zeroCount(s.size(), 0), oneCount(s.size(), 0);\\n        long long res = 0L;\\n        \\n        zeroCount[0] = (s[0] == \\'0\\');\\n        oneCount[0] = (s[0] == \\'1\\');\\n        \\n        for(int i=1; i<s.size(); i++)\\n        {\\n            zeroCount[i] = zeroCount[i-1] + (s[i] == \\'0\\');\\n            oneCount[i] = oneCount[i-1] + (s[i] == \\'1\\');\\n        }\\n        \\n        for(int i=1; i<s.size()-1; i++)\\n        {\\n            res += (s[i] == \\'1\\')? (long long)(zeroCount[i] * (zeroCount[s.size()-1] - zeroCount[i]))\\n                :  (long long)(oneCount[i] * (oneCount[s.size()-1] - oneCount[i]));\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2436177,
                "title": "python-straightforward-solution-with-explanation-in-comment-no-need-to-use-multiplication-operator",
                "content": "```\\n# basic idea: \\n# To obtain \\'101\\' we need to find \\'10\\' before \\'1\\'. \\n# Thus, it is necessary to count the number of \\'10\\' and \\'01\\' before \\'1\\' and \\'0\\' respectively. \\n# Further, we need to count the number of \\'1\\' and \\'0\\' before \\'0\\' and \\'1\\' respectively.\\n# Think about the following example: we get \\'1\\' at index i, then we need to update the number of \\'101\\' and \\'01\\' and \\'1\\'. \\n# The number of \\'101\\' is updated by the number of \\'10\\' before \\'1\\'(before index i).\\n# The number of \\'01\\' is updated by the number of \\'0\\' before \\'1\\'(before index i).\\n# The number of \\'1\\' is updated by 1.\\n# The number of \\'0\\', \\'10\\' and \\'010\\' are updated without refreshing the values.\\n# It is obvious that the number of \\'1\\', \\'01\\' and \\'101\\' are independent at each index i. This means that we can simply update each number without additional effort.\\n\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        # \\'101\\' or \\'010\\'\\n        # \\'101\\':\\n        # count the number of 1\\'s before i\\n        # count the number of 0\\'s before i\\n        C1=0\\n        C0=0\\n        # if i is a 0, then it can form \\'10\\' with previous 1\\'s\\n        C10=0\\n        # if i is a 1, it can form \\'01\\' with previous 0\\'s\\n        C01=0\\n        # if i is a 0, it can form \\'010\\' with previous \\'01\\'\\'s\\n        C010=0\\n        # if i is a 1, it can form \\'101\\' with previous \\'10\\'\\'s\\n        C101=0\\n        for i in range(len(s)):\\n            if s[i]==\\'0\\':\\n                C010+=C01 # += 01\\'s before i\\n                C10+=C1 # += 1\\'s before i\\n                C0+=1 # update 0\\n            else:\\n                C101+=C10 # ...\\n                C01+=C0\\n                C1+=1\\n        return C010+C101\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n# basic idea: \\n# To obtain \\'101\\' we need to find \\'10\\' before \\'1\\'. \\n# Thus, it is necessary to count the number of \\'10\\' and \\'01\\' before \\'1\\' and \\'0\\' respectively. \\n# Further, we need to count the number of \\'1\\' and \\'0\\' before \\'0\\' and \\'1\\' respectively.\\n# Think about the following example: we get \\'1\\' at index i, then we need to update the number of \\'101\\' and \\'01\\' and \\'1\\'. \\n# The number of \\'101\\' is updated by the number of \\'10\\' before \\'1\\'(before index i).\\n# The number of \\'01\\' is updated by the number of \\'0\\' before \\'1\\'(before index i).\\n# The number of \\'1\\' is updated by 1.\\n# The number of \\'0\\', \\'10\\' and \\'010\\' are updated without refreshing the values.\\n# It is obvious that the number of \\'1\\', \\'01\\' and \\'101\\' are independent at each index i. This means that we can simply update each number without additional effort.\\n\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        # \\'101\\' or \\'010\\'\\n        # \\'101\\':\\n        # count the number of 1\\'s before i\\n        # count the number of 0\\'s before i\\n        C1=0\\n        C0=0\\n        # if i is a 0, then it can form \\'10\\' with previous 1\\'s\\n        C10=0\\n        # if i is a 1, it can form \\'01\\' with previous 0\\'s\\n        C01=0\\n        # if i is a 0, it can form \\'010\\' with previous \\'01\\'\\'s\\n        C010=0\\n        # if i is a 1, it can form \\'101\\' with previous \\'10\\'\\'s\\n        C101=0\\n        for i in range(len(s)):\\n            if s[i]==\\'0\\':\\n                C010+=C01 # += 01\\'s before i\\n                C10+=C1 # += 1\\'s before i\\n                C0+=1 # update 0\\n            else:\\n                C101+=C10 # ...\\n                C01+=C0\\n                C1+=1\\n        return C010+C101\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313593,
                "title": "c-very-easy-to-understand-with-explanation",
                "content": "\\n   \\n        There can be only 2 patterns either 010 or 101.\\n\\t\\t\\n\\t\\tSo if we encounter \\'1\\' so check how many zeros are present before and\\n\\t\\tafter that 1(totalZeros-PrefixZeros) and simarly check for \\'0\\'.\\n\\t\\t\\n        eg: 0010 so number of zeros before \\'1\\' are 2 and after are \\'1\\' is 1.\\n        So total patterns that can be made are 2*1 = 2. \\n\\t\\t\\n\\t\\tAnd keep adding that value in ans.\\n    \\n\\n```\\n    long long numberOfWays(string s) {\\n        int count0=0,count1=0;\\n        \\n        for(int i=0;i<s.size();i++){\\n          s[i]==\\'1\\'?count1++:count0++;\\n        }\\n        int count0before=0;\\n        int count1before=0;\\n        s[0]==\\'0\\'?count0before++:count1before++;\\n        long long ans=0;\\n        for(int i=1;i<s.size()-1;i++){\\n            if(s[i]==\\'1\\'){ //search for 010\\n                ans+=count0before*(count0-count0before);\\n                count1before++;\\n            }else{\\n                ans+=count1before*(count1-count1before);\\n                count0before++;\\n            }\\n        }\\n         return ans;   \\n    }\\n```\\n\\nPLEASE DO UPVOTE IF YOU FIND THIS USEFUL :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    long long numberOfWays(string s) {\\n        int count0=0,count1=0;\\n        \\n        for(int i=0;i<s.size();i++){\\n          s[i]==\\'1\\'?count1++:count0++;\\n        }\\n        int count0before=0;\\n        int count1before=0;\\n        s[0]==\\'0\\'?count0before++:count1before++;\\n        long long ans=0;\\n        for(int i=1;i<s.size()-1;i++){\\n            if(s[i]==\\'1\\'){ //search for 010\\n                ans+=count0before*(count0-count0before);\\n                count1before++;\\n            }else{\\n                ans+=count1before*(count1-count1before);\\n                count0before++;\\n            }\\n        }\\n         return ans;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1910871,
                "title": "c-simple-maths-solutions-in-o-n",
                "content": "```\\nclass Solution {\\npublic:    \\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        vector<int> countOnes(n,0),countZero(n,0);\\n        countOnes[0] = s[0] == \\'1\\';\\n        countZero[0] = s[0] == \\'0\\';\\n        for(int i=1;i<n;i++){\\n            countOnes[i] += countOnes[i-1] + (s[i] == \\'1\\');\\n            countZero[i] += countZero[i-1] + (s[i] == \\'0\\');\\n        }\\n        long long ans = 0;\\n        for(int i=1;i<n-1;i++){\\n            if(s[i] == \\'0\\'){\\n                int onesLeft = countOnes[i-1];\\n                int onesRight = (countOnes[n-1] - countOnes[i]);\\n                if(onesLeft >= 0 && onesRight >= 0){\\n                    ans += (1ll * onesLeft * onesRight);                    \\n                }\\n            }else{\\n                int zerosLeft = countZero[i-1];\\n                int zerosRight = (countZero[n-1] - countZero[i]);\\n                if(zerosRight >= 0 && zerosLeft >= 0){\\n                    ans += (1ll * zerosLeft * zerosRight);                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Combinatorics",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        vector<int> countOnes(n,0),countZero(n,0);\\n        countOnes[0] = s[0] == \\'1\\';\\n        countZero[0] = s[0] == \\'0\\';\\n        for(int i=1;i<n;i++){\\n            countOnes[i] += countOnes[i-1] + (s[i] == \\'1\\');\\n            countZero[i] += countZero[i-1] + (s[i] == \\'0\\');\\n        }\\n        long long ans = 0;\\n        for(int i=1;i<n-1;i++){\\n            if(s[i] == \\'0\\'){\\n                int onesLeft = countOnes[i-1];\\n                int onesRight = (countOnes[n-1] - countOnes[i]);\\n                if(onesLeft >= 0 && onesRight >= 0){\\n                    ans += (1ll * onesLeft * onesRight);                    \\n                }\\n            }else{\\n                int zerosLeft = countZero[i-1];\\n                int zerosRight = (countZero[n-1] - countZero[i]);\\n                if(zerosRight >= 0 && zerosLeft >= 0){\\n                    ans += (1ll * zerosLeft * zerosRight);                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909586,
                "title": "dynamic-programming-count-pattern-searching",
                "content": "```\\nclass Solution {\\n    public static long numberOfWays(String s) {\\n\\t\\tString p1 = \"101\";\\n\\t\\tString p2 = \"010\";\\n\\t\\tlong count = 0;\\n\\t\\tcount += helper(s, p1);\\n\\t\\tcount += helper(s, p2);\\n\\n\\t\\treturn count;\\n\\t}\\n\\n\\tpublic static long helper(String x, String y) {\\n\\t\\tint m = x.length();\\n\\t\\tint n = y.length();\\n\\n\\t\\tlong dp[][] = new long[m + 1][n + 1];\\n\\n\\t\\tfor (int i = 0; i < m + 1; i++) {\\n\\t\\t\\tfor (int j = 0; j < n + 1; j++) {\\n\\t\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\t\\tdp[i][j] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (j == 0) {\\n\\t\\t\\t\\t\\tdp[i][j] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < m + 1; i++) {\\n\\t\\t\\tfor (int j = 1; j < n + 1; j++) {\\n\\t\\t\\t\\tif (x.charAt(i - 1) == y.charAt(j - 1)) {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[m][n];\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public static long numberOfWays(String s) {\\n\\t\\tString p1 = \"101\";\\n\\t\\tString p2 = \"010\";\\n\\t\\tlong count = 0;\\n\\t\\tcount += helper(s, p1);\\n\\t\\tcount += helper(s, p2);\\n\\n\\t\\treturn count;\\n\\t}\\n\\n\\tpublic static long helper(String x, String y) {\\n\\t\\tint m = x.length();\\n\\t\\tint n = y.length();\\n\\n\\t\\tlong dp[][] = new long[m + 1][n + 1];\\n\\n\\t\\tfor (int i = 0; i < m + 1; i++) {\\n\\t\\t\\tfor (int j = 0; j < n + 1; j++) {\\n\\t\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\t\\tdp[i][j] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (j == 0) {\\n\\t\\t\\t\\t\\tdp[i][j] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < m + 1; i++) {\\n\\t\\t\\tfor (int j = 1; j < n + 1; j++) {\\n\\t\\t\\t\\tif (x.charAt(i - 1) == y.charAt(j - 1)) {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[m][n];\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907333,
                "title": "python-c-o-n-time-o-1-space",
                "content": "Python:\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        ways, count = 0, defaultdict(int)\\n\\t\\t\\n        for char in s:\\n            other = f\"{1 - int(char)}\"\\n            count[other+char] += count[other]\\n            ways += count[char+other]\\n            count[char] += 1\\n        \\n        return ways\\n\\n```\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long ways = 0;\\n        unordered_map<string, long> count;\\n        \\n        for (int i=0; i < s.size(); i++) {\\n            char other(s[i]==\\'0\\' ? \\'1\\' : \\'0\\');\\n            count[string()+other+s[i]] += count[string()+other];\\n            ways += count[string()+s[i]+other];\\n            count[string()+s[i]] += 1;\\n        }        \\n        \\n        return ways;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        ways, count = 0, defaultdict(int)\\n\\t\\t\\n        for char in s:\\n            other = f\"{1 - int(char)}\"\\n            count[other+char] += count[other]\\n            ways += count[char+other]\\n            count[char] += 1\\n        \\n        return ways\\n\\n```\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long ways = 0;\\n        unordered_map<string, long> count;\\n        \\n        for (int i=0; i < s.size(); i++) {\\n            char other(s[i]==\\'0\\' ? \\'1\\' : \\'0\\');\\n            count[string()+other+s[i]] += count[string()+other];\\n            ways += count[string()+s[i]+other];\\n            count[string()+s[i]] += 1;\\n        }        \\n        \\n        return ways;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907330,
                "title": "simple-maths-applying-pnc-easy-c-solution",
                "content": "Apply Pnc, \\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\n    long long numberOfWays(string s) {\\n\\t\\tint total0 = 0, total1 = 0;\\n        \\n        for(char i: s){\\n            if(i == \\'0\\') total0++;\\n            if(i == \\'1\\') total1++;\\n        }\\n        \\n        long ans = 0;\\n        \\n        // count of 0s and 1s till current position i.e. left of current position\\n        int count0 = 0, count1 = 0;\\n        \\n        for(char i: s){\\n            // for all \"0....0 1 0...0\" type            \\n            if(i == \\'1\\'){\\n                ans += count0 * (total0 - count0);      //(no. of 0s left of 1) * (no. of 0s after 1)\\n                count1++;\\n            }\\n            \\n            // for all \"1....1 0 1...1\" type\\n            if(i == \\'0\\'){\\n                ans += count1 * (total1 - count1);      //(no. of 1s left of 0) * (no. of 1s after 0)\\n                count0++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\n    long long numberOfWays(string s) {\\n\\t\\tint total0 = 0, total1 = 0;\\n        \\n        for(char i: s){\\n            if(i == \\'0\\') total0++;\\n            if(i == \\'1\\') total1++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1907327,
                "title": "c-dp-solution",
                "content": "The only possible 3 letters string is \\'101\\' and \\'010\\'.\\nSo, we just need to find the no. of times the subsequences \\'101\\' and \\'010\\' occurs in the given string and add them.\\n\\n```\\nclass Solution {\\npublic:\\n    long long count(string a, string b)\\n{\\n    long long m = a.length();\\n    long long n = b.length();\\n    long long dp[m + 1][n + 1] ;\\n        memset(dp,0,sizeof(dp));\\n    for (long long i = 0; i <= n; ++i)\\n        dp[0][i] = 0;\\n    for (long long i = 0; i <= m; ++i)\\n        dp[i][0] = 1;\\n    for (long long i = 1; i <= m; i++)\\n    {\\n        for (long long j = 1; j <= n; j++)\\n        {\\n            if (a[i - 1] == b[j - 1])\\n                dp[i][j] = dp[i - 1][j - 1] +dp[i - 1][j];\\n                 \\n            else\\n                dp[i][j] = dp[i - 1][j];\\n        }\\n    }\\n \\n    return dp[m][n];\\n}\\n    long long numberOfWays(string s) {\\n        string s1=\"101\";\\n        string s2=\"010\";\\n        return count(s,s1)+count(s,s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long count(string a, string b)\\n{\\n    long long m = a.length();\\n    long long n = b.length();\\n    long long dp[m + 1][n + 1] ;\\n        memset(dp,0,sizeof(dp));\\n    for (long long i = 0; i <= n; ++i)\\n        dp[0][i] = 0;\\n    for (long long i = 0; i <= m; ++i)\\n        dp[i][0] = 1;\\n    for (long long i = 1; i <= m; i++)\\n    {\\n        for (long long j = 1; j <= n; j++)\\n        {\\n            if (a[i - 1] == b[j - 1])\\n                dp[i][j] = dp[i - 1][j - 1] +dp[i - 1][j];\\n                 \\n            else\\n                dp[i][j] = dp[i - 1][j];\\n        }\\n    }\\n \\n    return dp[m][n];\\n}\\n    long long numberOfWays(string s) {\\n        string s1=\"101\";\\n        string s2=\"010\";\\n        return count(s,s1)+count(s,s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907321,
                "title": "c-solution-simple-easy-solution-with-comments",
                "content": "->for \"010\" case count number of \"0\"s from the first index of \"0\" to last index \"0\".\\n->then traverse from first index of \"0\" to last index of \"0\" keeping a \\'counter\\' of how many \"0\"s we have passed.\\n->whenever we found a \"1\" we multiply the count of \"0\"s we have passed with the number of \"0\"s left and add it to the result.\\n\\nfor the \"101\" case we do same as above from the first index of \"1\" and last index of \"1\".\\n\\n```\\nclass Solution {\\n    long long int fun0(string s,int start,int last) {\\n        int n0=0,n1=0;\\n        for(int i=start;i<=last;i++){\\n            if(s[i]==\\'1\\')\\n                n1++;\\n            else\\n                n0++;\\n        }\\n        int curr=0;\\n        long long int res=0;\\n        for(int i=start;i<=last;i++) {\\n            if(s[i]==\\'1\\')\\n                res+=(curr*(n0-curr));\\n            else\\n                curr++;\\n        }\\n        return res;\\n    }\\n    long long int fun1(string s,int start,int last) {\\n        int n0=0,n1=0;\\n        for(int i=start;i<=last;i++){\\n            if(s[i]==\\'0\\')\\n                n0++;\\n            else\\n                n1++;\\n        }\\n        int curr=0;\\n        long long int res=0;\\n        for(int i=start;i<=last;i++){\\n            if(s[i]==\\'0\\')\\n\\t\\t\\t\\tres+=(curr*(n1-curr));\\n            else\\n                curr++;\\n        }\\n        return res;\\n    }\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.length();\\n\\t\\t/*\\n\\t\\t   f0 = first index of \"0\"\\n\\t\\t   f1 = first index of \"1\"\\n\\t\\t   l0 = last index of \"0\"\\n\\t\\t   l1 = last index of \"1\"\\n\\t\\t*/\\n        int f0 = -1,l0 = -1, f1 = -1,l1 = -1;\\n        for(int i=0;i<n;i++) {\\n            if(s[i]==\\'0\\') {\\n                f0 = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--) {\\n            if(s[i]==\\'0\\') {\\n                l0 = i;\\n                break;\\n            }\\n        }\\n        long long int res = 0;\\n        if(f0>=0)\\n            res = fun0(s,f0,l0);     //for \"010\" case\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\') {\\n                f1 = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\'1\\') {\\n                l1 = i;\\n                break;\\n            }\\n        }\\n        long long int sum=0;\\n        if(f1>=0)\\n            sum = fun1(s,f1,l1);    //for \"101\" case\\n        return res+sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long long int fun0(string s,int start,int last) {\\n        int n0=0,n1=0;\\n        for(int i=start;i<=last;i++){\\n            if(s[i]==\\'1\\')\\n                n1++;\\n            else\\n                n0++;\\n        }\\n        int curr=0;\\n        long long int res=0;\\n        for(int i=start;i<=last;i++) {\\n            if(s[i]==\\'1\\')\\n                res+=(curr*(n0-curr));\\n            else\\n                curr++;\\n        }\\n        return res;\\n    }\\n    long long int fun1(string s,int start,int last) {\\n        int n0=0,n1=0;\\n        for(int i=start;i<=last;i++){\\n            if(s[i]==\\'0\\')\\n                n0++;\\n            else\\n                n1++;\\n        }\\n        int curr=0;\\n        long long int res=0;\\n        for(int i=start;i<=last;i++){\\n            if(s[i]==\\'0\\')\\n\\t\\t\\t\\tres+=(curr*(n1-curr));\\n            else\\n                curr++;\\n        }\\n        return res;\\n    }\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.length();\\n\\t\\t/*\\n\\t\\t   f0 = first index of \"0\"\\n\\t\\t   f1 = first index of \"1\"\\n\\t\\t   l0 = last index of \"0\"\\n\\t\\t   l1 = last index of \"1\"\\n\\t\\t*/\\n        int f0 = -1,l0 = -1, f1 = -1,l1 = -1;\\n        for(int i=0;i<n;i++) {\\n            if(s[i]==\\'0\\') {\\n                f0 = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--) {\\n            if(s[i]==\\'0\\') {\\n                l0 = i;\\n                break;\\n            }\\n        }\\n        long long int res = 0;\\n        if(f0>=0)\\n            res = fun0(s,f0,l0);     //for \"010\" case\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\') {\\n                f1 = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\'1\\') {\\n                l1 = i;\\n                break;\\n            }\\n        }\\n        long long int sum=0;\\n        if(f1>=0)\\n            sum = fun1(s,f1,l1);    //for \"101\" case\\n        return res+sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907213,
                "title": "short-one-pass-python-solution",
                "content": "```\\na = b = c = d = result = 0\\nfor t in s:\\n\\tif t == \"0\":\\n\\t\\tresult += b\\n\\t\\ta += 1\\n\\t\\td += c\\n\\telse:\\n\\t\\tresult += d\\n\\t\\tc += 1\\n\\t\\tb += a\\nreturn result\\n```\\n\\na: number of \"0\"s\\nb: number of \"01\"s\\nc: number of \"1\"s\\nd: number of \"10\"s\\nAdd b to result if \"0\".\\nAdd d to result if \"1\".\\nAdd a to b if \"1\".\\nAdd c to d if \"0\".",
                "solutionTags": [],
                "code": "```\\na = b = c = d = result = 0\\nfor t in s:\\n\\tif t == \"0\":\\n\\t\\tresult += b\\n\\t\\ta += 1\\n\\t\\td += c\\n\\telse:\\n\\t\\tresult += d\\n\\t\\tc += 1\\n\\t\\tb += a\\nreturn result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907140,
                "title": "simple-observation-c-self-explanatory-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long ans = 0;\\n        long long on = 0, zr = 0;\\n        int n = s.size();\\n        for(char ch : s) {\\n            if(ch == \\'1\\') on++;\\n            if(ch == \\'0\\') zr++;\\n        }\\n      \\n        long long cur_zr = 0, cur_on = 0;\\n        if(s[0] == \\'0\\') cur_zr++;\\n        else cur_on++;\\n        \\n        for(int i = 1; i<n - 1; i++){\\n            if(s[i] == \\'0\\'){\\n                cur_zr++;\\n                ans = ans + (cur_on * (on - cur_on));\\n            }\\n            else {\\n                cur_on++;\\n                ans = ans + (cur_zr * (zr - cur_zr));\\n            }\\n        }\\n         return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long ans = 0;\\n        long long on = 0, zr = 0;\\n        int n = s.size();\\n        for(char ch : s) {\\n            if(ch == \\'1\\') on++;\\n            if(ch == \\'0\\') zr++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1907098,
                "title": "prefix-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n=s.length();\\n        vector<int> lz(n,0),rz(n,0);\\n        vector<int> lo(n,0),ro(n,0);\\n        int c=0;\\n\\t\\t// count of 0\\'s before i and 1\\'s\\n        if(s[0]==\\'0\\')\\n            lz[0]=1;\\n        else\\n            lo[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n                lz[i]=lz[i-1]+1,c++;\\n            else\\n                lz[i]=lz[i-1];\\n            if(s[i]==\\'1\\')\\n                lo[i]=lo[i-1]+1;\\n            else\\n                lo[i]=lo[i-1];\\n        }\\n\\t\\t\\n\\t\\t// count of 0\\'s after i and 1\\'s\\n        if(s[n-1]==\\'0\\')\\n            rz[n-1]=1;\\n        else\\n            ro[n-1]=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==\\'0\\')\\n                rz[i]=rz[i+1]+1;\\n            else\\n                rz[i]=rz[i+1];\\n            if(s[i]==\\'1\\')\\n                ro[i]=ro[i+1]+1;\\n            else\\n                ro[i]=ro[i+1];\\n        }\\n        long long ans=0;\\n        for(int i=1;i<n-1;i++)\\n        {\\n\\t\\t    // count of 1\\'s before i * count of 1\\'s after \\n            if(s[i]==\\'0\\')\\n                ans+= ro[i]*lo[i];\\n\\t\\t\\t\\t\\n\\t\\t\\t// count of 0\\'s before * count of 0\\'s after \\n            if(s[i]==\\'1\\')\\n                ans+= rz[i]*lz[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n=s.length();\\n        vector<int> lz(n,0),rz(n,0);\\n        vector<int> lo(n,0),ro(n,0);\\n        int c=0;\\n\\t\\t// count of 0\\'s before i and 1\\'s\\n        if(s[0]==\\'0\\')\\n            lz[0]=1;\\n        else\\n            lo[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n                lz[i]=lz[i-1]+1,c++;\\n            else\\n                lz[i]=lz[i-1];\\n            if(s[i]==\\'1\\')\\n                lo[i]=lo[i-1]+1;\\n            else\\n                lo[i]=lo[i-1];\\n        }\\n\\t\\t\\n\\t\\t// count of 0\\'s after i and 1\\'s\\n        if(s[n-1]==\\'0\\')\\n            rz[n-1]=1;\\n        else\\n            ro[n-1]=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==\\'0\\')\\n                rz[i]=rz[i+1]+1;\\n            else\\n                rz[i]=rz[i+1];\\n            if(s[i]==\\'1\\')\\n                ro[i]=ro[i+1]+1;\\n            else\\n                ro[i]=ro[i+1];\\n        }\\n        long long ans=0;\\n        for(int i=1;i<n-1;i++)\\n        {\\n\\t\\t    // count of 1\\'s before i * count of 1\\'s after \\n            if(s[i]==\\'0\\')\\n                ans+= ro[i]*lo[i];\\n\\t\\t\\t\\t\\n\\t\\t\\t// count of 0\\'s before * count of 0\\'s after \\n            if(s[i]==\\'1\\')\\n                ans+= rz[i]*lz[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907080,
                "title": "logic-easiest-complexity-analysis-c",
                "content": "## **Solution**\\n\\n### **LOGIC**\\n* Lets take s =\"100001\", now number of ways to select the building is 4, which is equal to the number of ```0``` between ```1``` at first index and ```1``` at last index. \\n\\n* We need to do this with all ```1``` in any string, simply take all compbination of non-adjacent ```1``` and find number of building just like we did in above example. Means for each pair of non-adjacent ```1```, number of ```0``` between them will add to our solution\\n\\n* Now there are two cases only ```101``` or ``010``. And what i explained is for case ```101```. We need to do the same process for the case ```010```.\\n\\n* But if you follow this approach bilndly, then you will get TLE as I did :(\\n\\n* So we need to use some Maths here. Scary right??.....Na\\n\\n* Let array = [a, b, c, d, e]. where ```(b - a)``` is the number of ```0``` between ```b``` and ```a```.\\n* So what we wnat to achive is this\\n\\t* ```(e - d)``` + ```(e - c)``` + ```(e - b)``` + ```(e - a)``` + ```(d - c)``` + ```(d - b)``` + ```(d - a)``` +```(c - b)``` + ```(c - a)``` + ```(b - a)```\\n\\t* Now for calculation of all these values we need nested ```for``` loop and that will give quadratic compleity and hebce ```TLE```\\n\\t* But as you can observer that using math and simple presence of mind you can do that in one pass only. And we can get ```AC``` with flying colors :)\\n\\n\\n#### **Code**\\n__TLE__\\n```cpp\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        vector<pair<int, int>> ones, zeros;\\n        long long sol = 0, one = 0, zero = 0;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'1\\') {\\n                ones.push_back(make_pair(i, zero));\\n                one++;\\n            }\\n            else {\\n                zeros.push_back(make_pair(i, one));\\n                zero++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < ones.size(); i++) {\\n            for (int j = i + 1; j < ones.size(); j++) {\\n                sol += ones[j].second  - ones[i].second;                \\n            }\\n        }\\n        for (int i = 0; i < zeros.size(); i++) {\\n            for (int j = i + 1; j < zeros.size(); j++) {\\n                sol += zeros[j].second  - zeros[i].second;                \\n            }\\n        }\\n        \\n        return sol;\\n        \\n        \\n    }\\n};\\n```\\n__AC__\\n```cpp\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        vector<long long> ones, zeros;\\n        long long sol = 0, one = 0, zero = 0;\\n        \\n        for (auto x : s) {\\n            if (x == \\'1\\') {\\n                ones.push_back(zero);\\n                one++;\\n            }\\n            else {\\n                zeros.push_back(one);\\n                zero++;\\n            }\\n        }\\n        \\n        long long o = ones.size(), z = zeros.size();\\n        if (o == 0 || z == 0) {\\n            return 0;\\n        }\\n        long long temp;\\n        \\n        temp = o - 1;\\n        for (long long i = 0 ; i < o / 2; i++) {\\n            sol -= (ones[i] * (temp));\\n            temp -= 2;\\n        }\\n        temp = (o % 2 == 0) ? 1 : 2;\\n        for (long long i = round(o / 2.0); i < o; i++) {\\n            sol += (ones[i] * (temp));\\n            temp += 2;\\n        }\\n        \\n        temp = z - 1;\\n        for (long long i = 0; i < z / 2; i++) {\\n            sol -= (zeros[i] * (temp));\\n            temp -= 2;\\n        }\\n        temp = (z % 2 == 0) ? 1 : 2;\\n        for (long long i = round((z / 2.0)); i < z; i++) {\\n            sol += (zeros[i] * (temp));\\n            temp += 2;\\n        }\\n        \\n        return sol;\\n        \\n        \\n    }\\n};\\n```\\n\\n## **Complexity**\\n\\n##### __Apporach : 1__  \\n##### Time Complexity:  **O(size_of_s)**\\n\\n##### Space Complexity: **O(size_of_s)**\\n\\n\\n<br>\\n\\n __Check out all [my](https://leetcode.com/siddp6/) recent solutions [here](https://github.com/sidd6p/LeetCode)__\\n\\n \\n __Feel Free to Ask Doubts\\nAnd Please Share Some Suggestions\\nHAPPY CODING :)__\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```0```\n```1```\n```1```\n```1```\n```1```\n```1```\n```0```\n```101```\n```101```\n```010```\n```(b - a)```\n```0```\n```b```\n```a```\n```(e - d)```\n```(e - c)```\n```(e - b)```\n```(e - a)```\n```(d - c)```\n```(d - b)```\n```(d - a)```\n```(c - b)```\n```(c - a)```\n```(b - a)```\n```for```\n```TLE```\n```AC```\n```cpp\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        vector<pair<int, int>> ones, zeros;\\n        long long sol = 0, one = 0, zero = 0;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'1\\') {\\n                ones.push_back(make_pair(i, zero));\\n                one++;\\n            }\\n            else {\\n                zeros.push_back(make_pair(i, one));\\n                zero++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < ones.size(); i++) {\\n            for (int j = i + 1; j < ones.size(); j++) {\\n                sol += ones[j].second  - ones[i].second;                \\n            }\\n        }\\n        for (int i = 0; i < zeros.size(); i++) {\\n            for (int j = i + 1; j < zeros.size(); j++) {\\n                sol += zeros[j].second  - zeros[i].second;                \\n            }\\n        }\\n        \\n        return sol;\\n        \\n        \\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        vector<long long> ones, zeros;\\n        long long sol = 0, one = 0, zero = 0;\\n        \\n        for (auto x : s) {\\n            if (x == \\'1\\') {\\n                ones.push_back(zero);\\n                one++;\\n            }\\n            else {\\n                zeros.push_back(one);\\n                zero++;\\n            }\\n        }\\n        \\n        long long o = ones.size(), z = zeros.size();\\n        if (o == 0 || z == 0) {\\n            return 0;\\n        }\\n        long long temp;\\n        \\n        temp = o - 1;\\n        for (long long i = 0 ; i < o / 2; i++) {\\n            sol -= (ones[i] * (temp));\\n            temp -= 2;\\n        }\\n        temp = (o % 2 == 0) ? 1 : 2;\\n        for (long long i = round(o / 2.0); i < o; i++) {\\n            sol += (ones[i] * (temp));\\n            temp += 2;\\n        }\\n        \\n        temp = z - 1;\\n        for (long long i = 0; i < z / 2; i++) {\\n            sol -= (zeros[i] * (temp));\\n            temp -= 2;\\n        }\\n        temp = (z % 2 == 0) ? 1 : 2;\\n        for (long long i = round((z / 2.0)); i < z; i++) {\\n            sol += (zeros[i] * (temp));\\n            temp += 2;\\n        }\\n        \\n        return sol;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332176,
                "title": "intuitive-dp-solution-o-n-time-and-constant-space-based-on-0-1-knapsack-take-not-take",
                "content": "# Intuition\\nThe problem is similar to 0-1 Knapsack,for each character in the string we have 2 options,either to take the building or not.\\n\\n# Approach\\n\\nWe know that in order to select 3 buildings such that no two consecutives are similar, we have only two options, \"010\" and \"101\".\\n\\n\\nWe can find number of subsequences in the actual string s corresponding to \"010\" and \"101\" indepedently using take not-take technique and add them to get the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n is the length of string s.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        long long ans = 0;\\n        string a = \"101\",b = \"010\";\\n        vector<long long> prev(4,0) , curr(4,0);\\n\\n        prev[0] = 1;\\n\\n        for(int i = 1;i<=n;i++){\\n            curr[0] = 1;\\n            for(int j = 1;j<=3;j++){\\n                long long nt = prev[j];\\n                long long t = 0;\\n                if(s[i-1] == a[j-1]){\\n                    t = curr[j-1];\\n                }\\n                curr[j] = nt + t;\\n            }\\n\\n            prev = curr;\\n        }\\n        ans += prev[3];\\n\\n        for(int i = 0;i<4;i++){\\n            prev[i] = 0;\\n            curr[i] = 0;\\n        }\\n        prev[0] = 1;\\n        for(int i = 1;i<=n;i++){\\n            curr[0] = 1;\\n            for(int j = 1;j<=3;j++){\\n                long long nt = prev[j];\\n                long long t = 0;\\n                if(s[i-1] == b[j-1]){\\n                    t = curr[j-1];\\n                }\\n\\n                curr[j] = nt + t;\\n            }\\n            prev = curr;\\n        }\\n        ans += prev[3];\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        long long ans = 0;\\n        string a = \"101\",b = \"010\";\\n        vector<long long> prev(4,0) , curr(4,0);\\n\\n        prev[0] = 1;\\n\\n        for(int i = 1;i<=n;i++){\\n            curr[0] = 1;\\n            for(int j = 1;j<=3;j++){\\n                long long nt = prev[j];\\n                long long t = 0;\\n                if(s[i-1] == a[j-1]){\\n                    t = curr[j-1];\\n                }\\n                curr[j] = nt + t;\\n            }\\n\\n            prev = curr;\\n        }\\n        ans += prev[3];\\n\\n        for(int i = 0;i<4;i++){\\n            prev[i] = 0;\\n            curr[i] = 0;\\n        }\\n        prev[0] = 1;\\n        for(int i = 1;i<=n;i++){\\n            curr[0] = 1;\\n            for(int j = 1;j<=3;j++){\\n                long long nt = prev[j];\\n                long long t = 0;\\n                if(s[i-1] == b[j-1]){\\n                    t = curr[j-1];\\n                }\\n\\n                curr[j] = nt + t;\\n            }\\n            prev = curr;\\n        }\\n        ans += prev[3];\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005617,
                "title": "python-prefix-sum-top-down-dp-solutions-tle",
                "content": "- Prefix Sum\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        prefixes = [[0, 0] for _ in range(len(s))] \\n        for i in range(len(s)):\\n            zero_count = prefixes[i][0] + 1 if s[i] == \"0\" else 0\\n            one_count = prefixes[i][1] + 1 if s[i] == \"1\" else 0\\n\\n            if i > 0:\\n                zero_count += prefixes[i - 1][0]\\n                one_count += prefixes[i - 1][1]\\n            \\n            prefixes[i] = [zero_count, one_count]         \\n\\n        res = 0\\n        for i in range(len(s)):\\n            if s[i] == \"0\":\\n                res += prefixes[i][1] * (prefixes[-1][1] - prefixes[i][1])\\n            elif s[i] == \"1\":\\n                res += prefixes[i][0] * (prefixes[-1][0] - prefixes[i][0])\\n\\n        return res\\n```\\n\\n- Top-down DFS + Memoization (TLE)\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        memo = {}\\n        def dfs(idx, path):\\n            if (idx, path) in memo:\\n                return memo[(idx, path)]\\n    \\n            if len(path) == 3:\\n                return 1\\n            if idx >= len(s):\\n                return 0\\n                    \\n            res = 0\\n            for i in range(idx + 1, len(s)):\\n                if not path or (path and path[-1] != s[i]):\\n                    res += dfs(i, path + s[i])\\n            \\n            memo[(idx, path)] = res\\n            return res\\n        \\n        return dfs(-1, \"\")\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        prefixes = [[0, 0] for _ in range(len(s))] \\n        for i in range(len(s)):\\n            zero_count = prefixes[i][0] + 1 if s[i] == \"0\" else 0\\n            one_count = prefixes[i][1] + 1 if s[i] == \"1\" else 0\\n\\n            if i > 0:\\n                zero_count += prefixes[i - 1][0]\\n                one_count += prefixes[i - 1][1]\\n            \\n            prefixes[i] = [zero_count, one_count]         \\n\\n        res = 0\\n        for i in range(len(s)):\\n            if s[i] == \"0\":\\n                res += prefixes[i][1] * (prefixes[-1][1] - prefixes[i][1])\\n            elif s[i] == \"1\":\\n                res += prefixes[i][0] * (prefixes[-1][0] - prefixes[i][0])\\n\\n        return res\\n```\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        memo = {}\\n        def dfs(idx, path):\\n            if (idx, path) in memo:\\n                return memo[(idx, path)]\\n    \\n            if len(path) == 3:\\n                return 1\\n            if idx >= len(s):\\n                return 0\\n                    \\n            res = 0\\n            for i in range(idx + 1, len(s)):\\n                if not path or (path and path[-1] != s[i]):\\n                    res += dfs(i, path + s[i])\\n            \\n            memo[(idx, path)] = res\\n            return res\\n        \\n        return dfs(-1, \"\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753063,
                "title": "5-line-python-solution-easy-fast",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        x0,x1,x01,x10,ans = 0,0,0,0,0\\n        for i in s:\\n            if i==\"1\": x1+=1;x01+=x0;ans+=x10\\n            else: x0+=1;x10+=x1;ans+=x01\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        x0,x1,x01,x10,ans = 0,0,0,0,0\\n        for i in s:\\n            if i==\"1\": x1+=1;x01+=x0;ans+=x10\\n            else: x0+=1;x10+=x1;ans+=x01\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2704850,
                "title": "java-hindi",
                "content": "Dekho sabse pehle to har index pe , kitne 0 ya 1 aaye h ab tak vo count krlo,  uske liye 2 1d array bana lo\\nn0 -> (no of zeros at that index)\\nn1 -> (no fo 1s at that index)\\nneeche dekho pehle ye kaise kiya\\nSECOND HALF \\nab dekho, hume aisa nhi chaiye ki consetive 1 and 0 aaye, of length 3 only\\ntotal possible permutations of 0 and 1, of len 3, are 2^3-> 8\\n_ _ _ har index pe ya 0 ayega ya 1, so 2*2*2\\n000 \\u274C\\n001 \\u274C\\n100 \\u274C\\n101 \\u274C\\n010 \\u2714\\n101 \\u2714\\n111  \\u274C\\n011  \\u274C\\njinke aage X hai, un sab be consevie 1 ya 0 aa rha, do sirf 2 case bnte hain\\n101, 010\\nAb agar 0 h to dekh lo uske left and right side pe, 1 h ya nhi, left to humne store kiya hua, no of zeros at that index aaray me, \\ntotal bhi pta h hume, ab agar total 1 5 ho and 3 us idnex tak h , to aage 2 honge hi, to total combinations will be no of 1s at left * no if 1s at right - > for 010\\n   no of os at left * no of zeros at right -> 101\\n```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n\\t// 2 arrays rakhe hain, to store count of 0 and 1\\n        int[] n0 = new int[s.length()];\\n        int[] n1 = new int[s.length()];\\n        int c0 = 0,c1=0;\\n        for(int i=0;i<s.length();i++) {\\n\\t\\t// agar 0 aaya to 0 ka count bhada diya\\n            if(s.charAt(i) == \\'0\\')\\n                 c0++;\\n            else\\n\\t\\t\\t// nhi to 1 ka bhada diya\\n                c1++;\\n\\t\\t\\t\\t// jo bhi bhada ho hume to us point tk , kitne 0 ya 1 h, rakhna h naa, \\n            n0[i] = c0;\\n            n1[i] = c1;\\n        }\\n\\t\\t// ab upar jaao second half padhne\\n        long ans = 0;\\n        for(int i=0;i<s.length();i++) {\\n            if(s.charAt(i)==\\'0\\') \\n\\t\\t\\t//  no of ones till that index * (no of 1s at right - total 1\\'s - 1\\'s till that index)\\n                ans += n1[i]*(c1-n1[i]);\\n            else \\n                ans += n0[i]*(c0-n0[i]);\\n        }\\n        return ans;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n\\t// 2 arrays rakhe hain, to store count of 0 and 1\\n        int[] n0 = new int[s.length()];\\n        int[] n1 = new int[s.length()];\\n        int c0 = 0,c1=0;\\n        for(int i=0;i<s.length();i++) {\\n\\t\\t// agar 0 aaya to 0 ka count bhada diya\\n            if(s.charAt(i) == \\'0\\')\\n                 c0++;\\n            else\\n\\t\\t\\t// nhi to 1 ka bhada diya\\n                c1++;\\n\\t\\t\\t\\t// jo bhi bhada ho hume to us point tk , kitne 0 ya 1 h, rakhna h naa, \\n            n0[i] = c0;\\n            n1[i] = c1;\\n        }\\n\\t\\t// ab upar jaao second half padhne\\n        long ans = 0;\\n        for(int i=0;i<s.length();i++) {\\n            if(s.charAt(i)==\\'0\\') \\n\\t\\t\\t//  no of ones till that index * (no of 1s at right - total 1\\'s - 1\\'s till that index)\\n                ans += n1[i]*(c1-n1[i]);\\n            else \\n                ans += n0[i]*(c0-n0[i]);\\n        }\\n        return ans;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549856,
                "title": "python-simple-single-pass-dp-solution-faster-than-99",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        noOf0, noOf1, noOf01, noOf10, res = 0, 0, 0, 0, 0\\n        for building in s:\\n            if building == \\'1\\':\\n                noOf1 += 1\\n                noOf01 += noOf0\\n                res += noOf10\\n            else:\\n                noOf0 += 1\\n                noOf10 += noOf1\\n                res += noOf01\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        noOf0, noOf1, noOf01, noOf10, res = 0, 0, 0, 0, 0\\n        for building in s:\\n            if building == \\'1\\':\\n                noOf1 += 1\\n                noOf01 += noOf0\\n                res += noOf10\\n            else:\\n                noOf0 += 1\\n                noOf10 += noOf1\\n                res += noOf01\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454063,
                "title": "only-one-for-loop-simple-solution-o-n-o-1",
                "content": "There are only 2 valid string of length 3 ie; `101 and 010`.\\n\\nIf we are at index pointing to character `1` we need to count all the different `01` combinations as it would form string `101`.\\n\\nSame goes for `0`, if we are pointing to zero we need to count all different `10` \\nas it would form another valid string `010`.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long ans=0, ones=0, zeros=0, oneZeros=0, zeroOnes=0;\\n        \\n        for(int i=s.length()-1; i>-1; i--)\\n            if(s[i] == \\'1\\') oneZeros+=zeros, ones++, ans+=zeroOnes;\\n            else zeroOnes+=ones, zeros++, ans+=oneZeros;\\n        \\n        return ans;        \\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long ans=0, ones=0, zeros=0, oneZeros=0, zeroOnes=0;\\n        \\n        for(int i=s.length()-1; i>-1; i--)\\n            if(s[i] == \\'1\\') oneZeros+=zeros, ones++, ans+=zeroOnes;\\n            else zeroOnes+=ones, zeros++, ans+=oneZeros;\\n        \\n        return ans;        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252520,
                "title": "one-pass-o-n-java-four-vars",
                "content": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        char[] str = s.toCharArray();\\n        long count10 = 0;\\n        long count01 = 0;\\n        long total = 0;\\n        long count1 = 0;\\n        long count0 = 0;\\n        for (int i = 1; i < str.length; i++) {\\n            if (str[i-1] == \\'1\\') {\\n                count1++;\\n                count01 += count0;\\n            } else {\\n                count0++;\\n                count10 += count1;\\n            }\\n            if (str[i] == \\'1\\') total += count10;\\n            else total += count01;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        char[] str = s.toCharArray();\\n        long count10 = 0;\\n        long count01 = 0;\\n        long total = 0;\\n        long count1 = 0;\\n        long count0 = 0;\\n        for (int i = 1; i < str.length; i++) {\\n            if (str[i-1] == \\'1\\') {\\n                count1++;\\n                count01 += count0;\\n            } else {\\n                count0++;\\n                count10 += count1;\\n            }\\n            if (str[i] == \\'1\\') total += count10;\\n            else total += count01;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121702,
                "title": "c-search-for-010-and-101",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tlong long numberOfWays(string s) {\\n\\t\\t\\t\\tlong long res = 0;\\n\\t\\t\\t\\tlong long a = 0, b = 0, c = 0;\\n\\t\\t\\t\\t//search for 010\\n\\t\\t\\t\\tfor(auto i: s){\\n\\t\\t\\t\\t\\tif(i==\\'0\\')a += 1;\\n\\t\\t\\t\\t\\tif(i==\\'1\\')b += a;\\n\\t\\t\\t\\t\\tif(i==\\'0\\')c += b;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres += c;\\n\\n\\t\\t\\t\\ta = 0;\\n\\t\\t\\t\\tb = 0;\\n\\t\\t\\t\\tc = 0;\\n\\t\\t\\t\\t//search for 101\\n\\t\\t\\t\\tfor(auto i: s){\\n\\t\\t\\t\\t\\tif(i==\\'1\\')a += 1;\\n\\t\\t\\t\\t\\tif(i==\\'0\\')b += a;\\n\\t\\t\\t\\t\\tif(i==\\'1\\')c += b;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn res+c;\\n\\n\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tlong long numberOfWays(string s) {\\n\\t\\t\\t\\tlong long res = 0;\\n\\t\\t\\t\\tlong long a = 0, b = 0, c = 0;\\n\\t\\t\\t\\t//search for 010\\n\\t\\t\\t\\tfor(auto i: s){\\n\\t\\t\\t\\t\\tif(i==\\'0\\')a += 1;\\n\\t\\t\\t\\t\\tif(i==\\'1\\')b += a;\\n\\t\\t\\t\\t\\tif(i==\\'0\\')c += b;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1956066,
                "title": "c-code-for-beginners-all-technique-in-one-place-easy-to-understand",
                "content": "**1. RECURSION+MEMOIZATION(TAKE or IGNORE)**\\n```\\nclass Solution {\\npublic:\\n    long long dp[100001][4][2];\\n    long long helper(string &S, int curr, int k, int flag){\\n        if(k==0){\\n            return 1;\\n        }\\n        if(curr==S.size()){\\n            return 0;\\n        }\\n        if(dp[curr][k][flag]!=-1){\\n            return dp[curr][k][flag];\\n        }\\n        long long res=helper(S,curr+1,k,flag);  // IGNORING THE CURRENT BUILDING\\n        if(flag==true && S[curr]==\\'1\\'){\\n            res+=helper(S,curr+1,k-1,!flag);  //TAKE BUILDING AND REVERSE FLAG\\n        }\\n        else if(flag==false && S[curr]==\\'0\\'){\\n            res+=helper(S,curr+1,k-1,!flag);            \\n        }\\n        return dp[curr][k][flag]=res;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t// flag==true means 1 numbered building and vice versa\\n        return helper(s,0,3,true)+helper(s,0,3,false);  \\n    }\\n};\\n```\\n\\n**2.  COUNT \"010\" AND \"101\" SUBSEQUENCES IN STRING (Both Recursive and Iterative)**\\n```\\nclass Solution {\\npublic:\\n    long long dp[100001][4];\\n    long long countSubseq(string &S, string T, int n, int m){\\n        if(m==0){\\n            return 1;\\n        }\\n        if(n==0){\\n            return 0;\\n        }\\n        if(dp[n][m]!=-1){\\n            return dp[n][m];\\n        }\\n        if(S[n-1]==T[m-1]){\\n            return dp[n][m]=countSubseq(S,T,n-1,m-1)+countSubseq(S,T,n-1,m); \\n        }\\n        return dp[n][m]=countSubseq(S,T,n-1,m);\\n    } //RECURSIVE COUNT TECH  (TLE)\\n    \\n//------------------------- ---------------------------------------------------------------------\\n    \\n    long long countSubseq(string &S, string pat, int n, int m){\\n        long long DP[n+1][m+1];\\n        for(int i=0;i<=m;i++){\\n            DP[0][i]=0;\\n        }\\n        for(int i=0;i<=n;i++){\\n            DP[i][0]=1;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(S[i-1]==pat[j-1]){\\n                    DP[i][j]=DP[i-1][j-1]+DP[i-1][j];\\n                }\\n                else{\\n                    DP[i][j]=DP[i-1][j];\\n                }\\n            }\\n        }\\n        return DP[n][m];\\n    }  //ITERATIVE VERSION\\n\\n//------------------------- ---------------------------------------------------------------------\\n\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp)); \\n        long long Subsequence101=countSubseq(s,\"101\",s.size(),3);\\n        memset(dp,-1,sizeof(dp)); // resetting for next function\\n        long long Subsequence010=countSubseq(s,\"010\",s.size(),3);\\n        return Subsequence101+Subsequence010;\\n    }\\n};\\n```\\n\\n**3. GREEDY TECHNIQUE**\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long res=0;\\n        int one=0;\\n        int zero=0;\\n        for(auto e: s){\\n            if(e==\\'0\\'){\\n                zero++;\\n            }\\n            else{\\n                one++;\\n            }\\n        }\\n        int currentOne=0;\\n        int currentZero=0;\\n        for(auto e: s){\\n            if(e==\\'0\\'){\\n                res+=(one*currentOne);\\n                zero--;\\n                currentZero++;\\n            }\\n            else{\\n                res+=(zero*currentZero);\\n                one--;\\n                currentOne++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**4. PREFIX SUMS OF ZERO AND ONE**\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n=s.size();\\n        vector<int> zero(n,0);\\n        vector<int> one(n,0);\\n        s[0]==\\'0\\' ? zero[0]=1 : one[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                zero[i]=zero[i-1]+1;\\n            }\\n            else{\\n                zero[i]=zero[i-1];\\n            }\\n            if(s[i]==\\'1\\'){\\n                one[i]=one[i-1]+1;\\n            }\\n            else{\\n                one[i]=one[i-1];\\n            }\\n        }\\n        long long res=0;\\n        for(int i=1;i<n-1;i++){\\n            if(s[i]==\\'0\\'){\\n                int leftSide1=one[i-1];\\n                int rightSide1=one[n-1]-one[i+1]+(s[i+1]==\\'1\\' ? 1 : 0);\\n                res+=(rightSide1*leftSide1);\\n            }\\n            else{\\n                int leftSide0=zero[i-1];\\n                int rightSide0=zero[n-1]-zero[i+1]+(s[i+1]==\\'0\\' ? 1 : 0);\\n                res+=(rightSide0*leftSide0);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100001][4][2];\\n    long long helper(string &S, int curr, int k, int flag){\\n        if(k==0){\\n            return 1;\\n        }\\n        if(curr==S.size()){\\n            return 0;\\n        }\\n        if(dp[curr][k][flag]!=-1){\\n            return dp[curr][k][flag];\\n        }\\n        long long res=helper(S,curr+1,k,flag);  // IGNORING THE CURRENT BUILDING\\n        if(flag==true && S[curr]==\\'1\\'){\\n            res+=helper(S,curr+1,k-1,!flag);  //TAKE BUILDING AND REVERSE FLAG\\n        }\\n        else if(flag==false && S[curr]==\\'0\\'){\\n            res+=helper(S,curr+1,k-1,!flag);            \\n        }\\n        return dp[curr][k][flag]=res;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t// flag==true means 1 numbered building and vice versa\\n        return helper(s,0,3,true)+helper(s,0,3,false);  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long dp[100001][4];\\n    long long countSubseq(string &S, string T, int n, int m){\\n        if(m==0){\\n            return 1;\\n        }\\n        if(n==0){\\n            return 0;\\n        }\\n        if(dp[n][m]!=-1){\\n            return dp[n][m];\\n        }\\n        if(S[n-1]==T[m-1]){\\n            return dp[n][m]=countSubseq(S,T,n-1,m-1)+countSubseq(S,T,n-1,m); \\n        }\\n        return dp[n][m]=countSubseq(S,T,n-1,m);\\n    } //RECURSIVE COUNT TECH  (TLE)\\n    \\n//------------------------- ---------------------------------------------------------------------\\n    \\n    long long countSubseq(string &S, string pat, int n, int m){\\n        long long DP[n+1][m+1];\\n        for(int i=0;i<=m;i++){\\n            DP[0][i]=0;\\n        }\\n        for(int i=0;i<=n;i++){\\n            DP[i][0]=1;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(S[i-1]==pat[j-1]){\\n                    DP[i][j]=DP[i-1][j-1]+DP[i-1][j];\\n                }\\n                else{\\n                    DP[i][j]=DP[i-1][j];\\n                }\\n            }\\n        }\\n        return DP[n][m];\\n    }  //ITERATIVE VERSION\\n\\n//------------------------- ---------------------------------------------------------------------\\n\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp)); \\n        long long Subsequence101=countSubseq(s,\"101\",s.size(),3);\\n        memset(dp,-1,sizeof(dp)); // resetting for next function\\n        long long Subsequence010=countSubseq(s,\"010\",s.size(),3);\\n        return Subsequence101+Subsequence010;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long res=0;\\n        int one=0;\\n        int zero=0;\\n        for(auto e: s){\\n            if(e==\\'0\\'){\\n                zero++;\\n            }\\n            else{\\n                one++;\\n            }\\n        }\\n        int currentOne=0;\\n        int currentZero=0;\\n        for(auto e: s){\\n            if(e==\\'0\\'){\\n                res+=(one*currentOne);\\n                zero--;\\n                currentZero++;\\n            }\\n            else{\\n                res+=(zero*currentZero);\\n                one--;\\n                currentOne++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n=s.size();\\n        vector<int> zero(n,0);\\n        vector<int> one(n,0);\\n        s[0]==\\'0\\' ? zero[0]=1 : one[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                zero[i]=zero[i-1]+1;\\n            }\\n            else{\\n                zero[i]=zero[i-1];\\n            }\\n            if(s[i]==\\'1\\'){\\n                one[i]=one[i-1]+1;\\n            }\\n            else{\\n                one[i]=one[i-1];\\n            }\\n        }\\n        long long res=0;\\n        for(int i=1;i<n-1;i++){\\n            if(s[i]==\\'0\\'){\\n                int leftSide1=one[i-1];\\n                int rightSide1=one[n-1]-one[i+1]+(s[i+1]==\\'1\\' ? 1 : 0);\\n                res+=(rightSide1*leftSide1);\\n            }\\n            else{\\n                int leftSide0=zero[i-1];\\n                int rightSide0=zero[n-1]-zero[i+1]+(s[i+1]==\\'0\\' ? 1 : 0);\\n                res+=(rightSide0*leftSide0);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938010,
                "title": "golang-o-n-time-o-1-mem",
                "content": "```go\\nfunc numberOfWays(s string) (ans int64) {\\n    countZero := 0\\n    for i := range s {\\n        if s[i] == \\'0\\' {\\n            countZero++\\n        }\\n    }\\n    countOne := len(s) - countZero\\n   \\n    numZero, numOne := 0, 0\\n    for i := range s {\\n        if s[i] == \\'0\\' {\\n            numZero++\\n            ans += int64(numOne * (countOne - numOne))\\n        } else {\\n            numOne++\\n            ans += int64(numZero * (countZero - numZero))\\n        }\\n    }\\n    \\n    return\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc numberOfWays(s string) (ans int64) {\\n    countZero := 0\\n    for i := range s {\\n        if s[i] == \\'0\\' {\\n            countZero++\\n        }\\n    }\\n    countOne := len(s) - countZero\\n   \\n    numZero, numOne := 0, 0\\n    for i := range s {\\n        if s[i] == \\'0\\' {\\n            numZero++\\n            ans += int64(numOne * (countOne - numOne))\\n        } else {\\n            numOne++\\n            ans += int64(numZero * (countZero - numZero))\\n        }\\n    }\\n    \\n    return\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934856,
                "title": "number-of-ways-to-select-buildings",
                "content": "```\\n# Count Number of zero in the array at each position \\n# then after that traverse each index and check if  s[i]==\\'1\\' \\n# How many zeros are before and after them.\\n# multiply before and after to maintain the permutation\\n# do the same when s[i]==\\'0\\'\\n```\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) \\n    {\\n       int n=s.length(); \\n       vector<int>zero(n,0);\\n       vector<int>one(n,0); \\n       for(int i=0;i<n;i++)\\n       {\\n           if(i==0)\\n           {\\n               zero[i]=s[i]==\\'0\\';\\n               one[i]=s[i]==\\'1\\';\\n           }\\n           else\\n           {\\n               zero[i]=zero[i-1]+(s[i]==\\'0\\');\\n               one[i]=one[i-1]+(s[i]==\\'1\\');\\n           }\\n       }\\n       long long int ans=0;\\n       for(int i=0;i<n;i++)\\n       {\\n           if(s[i]==\\'0\\')\\n               ans=ans+one[i]*(one[n-1]-one[i]);\\n           else\\n               ans=ans+zero[i]*(zero[n-1]-zero[i]);\\n       }\\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n# Count Number of zero in the array at each position \\n# then after that traverse each index and check if  s[i]==\\'1\\' \\n# How many zeros are before and after them.\\n# multiply before and after to maintain the permutation\\n# do the same when s[i]==\\'0\\'\\n```\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) \\n    {\\n       int n=s.length(); \\n       vector<int>zero(n,0);\\n       vector<int>one(n,0); \\n       for(int i=0;i<n;i++)\\n       {\\n           if(i==0)\\n           {\\n               zero[i]=s[i]==\\'0\\';\\n               one[i]=s[i]==\\'1\\';\\n           }\\n           else\\n           {\\n               zero[i]=zero[i-1]+(s[i]==\\'0\\');\\n               one[i]=one[i-1]+(s[i]==\\'1\\');\\n           }\\n       }\\n       long long int ans=0;\\n       for(int i=0;i<n;i++)\\n       {\\n           if(s[i]==\\'0\\')\\n               ans=ans+one[i]*(one[n-1]-one[i]);\\n           else\\n               ans=ans+zero[i]*(zero[n-1]-zero[i]);\\n       }\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915467,
                "title": "o-n-python-two-pass-constant-space-simplest-algorithm",
                "content": "Pick  the middle element s[i] the answer is simpley the count of ! s[i] to its left times the count of ! s[i] to its right. sum over all possible i in range(n).\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        n = len(s)\\n        cnt_r, cnt_l = Counter(s), Counter()\\n        res = 0\\n        for i in range(n):\\n            cnt_l[s[i]] += 1\\n            cnt_r[s[i]] -= 1\\n            res += cnt_l[\\'1\\' if s[i] == \\'0\\' else \\'0\\'] * cnt_r[\\'1\\' if s[i] == \\'0\\' else \\'0\\']\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        n = len(s)\\n        cnt_r, cnt_l = Counter(s), Counter()\\n        res = 0\\n        for i in range(n):\\n            cnt_l[s[i]] += 1\\n            cnt_r[s[i]] -= 1\\n            res += cnt_l[\\'1\\' if s[i] == \\'0\\' else \\'0\\'] * cnt_r[\\'1\\' if s[i] == \\'0\\' else \\'0\\']\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915169,
                "title": "easiest-python-solution",
                "content": "At first, you will calculate the total number of zeroes and ones in the given string and store their respective counts in the variables total_0 and total 1\\n\\nNow, we need to traverse through the the list and if we find 0, all we need to do is multiple thy number 1s we have encountered before that 0 and number of 1s we will encounter after that 0. The same logic applies to when we find 1 in the string.\\n\\nPlease feel free to comment if you have any doubts.\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        \\n        res = 0\\n        curr_1, curr_0, total_1, total_0 = 0, 0, 0, 0\\n        \\n        for bit in s:\\n            if bit == \\'1\\':\\n                total_1 += 1\\n            else:\\n                total_0 += 1\\n        \\n        if s[0] == \\'0\\':\\n            curr_0 += 1\\n        else:\\n            curr_1 += 1\\n\\t\\t\\t\\n        #the first element can\\'t be middle element, even the last one. That\\'s we use 1 to len(s) -1 while iterating through the for loops\\n        for i in range(1, len(s) - 1):\\n            if s[i] == \\'0\\':\\n                curr_0 += 1\\n                res += curr_1 * (total_1 - curr_1)\\n            else:\\n                curr_1 += 1\\n                res += curr_0 * (total_0 - curr_0)\\n                \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "At first, you will calculate the total number of zeroes and ones in the given string and store their respective counts in the variables total_0 and total 1\\n\\nNow, we need to traverse through the the list and if we find 0, all we need to do is multiple thy number 1s we have encountered before that 0 and number of 1s we will encounter after that 0. The same logic applies to when we find 1 in the string.\\n\\nPlease feel free to comment if you have any doubts.\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        \\n        res = 0\\n        curr_1, curr_0, total_1, total_0 = 0, 0, 0, 0\\n        \\n        for bit in s:\\n            if bit == \\'1\\':\\n                total_1 += 1\\n            else:\\n                total_0 += 1\\n        \\n        if s[0] == \\'0\\':\\n            curr_0 += 1\\n        else:\\n            curr_1 += 1\\n\\t\\t\\t\\n        #the first element can\\'t be middle element, even the last one. That\\'s we use 1 to len(s) -1 while iterating through the for loops\\n        for i in range(1, len(s) - 1):\\n            if s[i] == \\'0\\':\\n                curr_0 += 1\\n                res += curr_1 * (total_1 - curr_1)\\n            else:\\n                curr_1 += 1\\n                res += curr_0 * (total_0 - curr_0)\\n                \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1909741,
                "title": "c-easy-no-dp",
                "content": "The main idea is , we want to count the number of 01 subsequences available for each \\'1\\' and the number of 10 subsequences for each \\'0\\' character in the string.\\nCounting the subsequences is pretty simple. We count the number of zeroes and each time we get a \\'1\\' we increase the total count by the count of zeroes\\nEg.\\n110100\\nWe try to make a array maintaining count of all 01 subsequences on the right of given index.\\nThe array will be \\n[5,2,2,0,0,0] for 01 subsequences.\\nRepeat the same procedure for counting 01 subsequences on the right of a given index.\\nCode:\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        // use postfix count here\\n        int n = s.length();\\n        vector<long long> zeroone(n,0);\\n        vector<long long> onezero(n,0);\\n        \\n        int cnt = 0;\\n        long long ways = 0;\\n        // for zeroone\\n        // maintain count of 1s\\n        for(int i = n - 1; i >= 0; --i){\\n            zeroone[i] = ways;\\n            if(s[i] == \\'1\\'){\\n                cnt++;\\n                continue;\\n            }\\n            \\n            ways += cnt;\\n        }\\n        \\n        ways = 0;\\n        cnt = 0;\\n        for(int i  = n  - 1; i >= 0; --i){\\n            \\n            onezero[i] = ways;\\n            if(s[i] == \\'0\\'){\\n                cnt++;\\n                continue;\\n            }\\n            \\n            ways += cnt;\\n        }\\n\\n        ways = 0;\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'0\\'){\\n                // search 10 \\n                ways += onezero[i];\\n            } else{\\n                ways += zeroone[i];\\n            }\\n        }\\n        \\n        return ways;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        // use postfix count here\\n        int n = s.length();\\n        vector<long long> zeroone(n,0);\\n        vector<long long> onezero(n,0);\\n        \\n        int cnt = 0;\\n        long long ways = 0;\\n        // for zeroone\\n        // maintain count of 1s\\n        for(int i = n - 1; i >= 0; --i){\\n            zeroone[i] = ways;\\n            if(s[i] == \\'1\\'){\\n                cnt++;\\n                continue;\\n            }\\n            \\n            ways += cnt;\\n        }\\n        \\n        ways = 0;\\n        cnt = 0;\\n        for(int i  = n  - 1; i >= 0; --i){\\n            \\n            onezero[i] = ways;\\n            if(s[i] == \\'0\\'){\\n                cnt++;\\n                continue;\\n            }\\n            \\n            ways += cnt;\\n        }\\n\\n        ways = 0;\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'0\\'){\\n                // search 10 \\n                ways += onezero[i];\\n            } else{\\n                ways += zeroone[i];\\n            }\\n        }\\n        \\n        return ways;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909645,
                "title": "javascript-101-010-selection-581ms",
                "content": "```\\nconst numberOfWays = (s) => op(s, \\'101\\') + op(s, \\'010\\')\\n\\nconst op = (s, t) => {\\n    let one = 0, two = 0, three = 0;\\n    for (const c of s) {\\n        if (c == t[2]) three += two;\\n        if (c == t[1]) two += one;\\n        if (c == t[0]) one++;\\n    }\\n    return three;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst numberOfWays = (s) => op(s, \\'101\\') + op(s, \\'010\\')\\n\\nconst op = (s, t) => {\\n    let one = 0, two = 0, three = 0;\\n    for (const c of s) {\\n        if (c == t[2]) three += two;\\n        if (c == t[1]) two += one;\\n        if (c == t[0]) one++;\\n    }\\n    return three;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908166,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long ans=0;\\n        int n=s.size();\\n        \\n        int cnt0=0,cnt1=0;\\n        \\n        vector<int>dp0(n,0);\\n        vector<int>dp1(n,0);\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'0\\')\\n                cnt0++;\\n            else\\n                cnt1++;\\n        }\\n        \\n        if(s[0]==\\'0\\')\\n            dp0[0]=1,dp1[0]=0;\\n        else\\n            dp1[0]=1,dp0[0]=0;\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                dp0[i]=dp0[i-1]+1;\\n                dp1[i]=dp1[i-1];\\n            }\\n            else\\n            {\\n                dp1[i]=dp1[i-1]+1;\\n                dp0[i]=dp0[i-1];\\n            }\\n        }\\n        \\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                ans+=dp0[i-1]*(cnt0-dp0[i-1]);\\n            }\\n            else\\n            {\\n                ans+=dp1[i-1]*(cnt1-dp1[i-1]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long ans=0;\\n        int n=s.size();\\n        \\n        int cnt0=0,cnt1=0;\\n        \\n        vector<int>dp0(n,0);\\n        vector<int>dp1(n,0);\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'0\\')\\n                cnt0++;\\n            else\\n                cnt1++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1907910,
                "title": "java-o-n-simplest-solution",
                "content": "```\\n        // Author: Anand\\n      public long numberOfWays(String s) {\\n        long ans = 0;\\n\\n        int t0 = 0, t1 = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') t0++;\\n            else t1++;\\n        }\\n\\n        int c0 = 0, c1 = 0;\\n        for (int i = 0; i < s.length()-1; i++) {\\n            if (s.charAt(i) == \\'0\\') {\\n                ans += (long) c1 * (t1 - c1);\\n                c0++;\\n            } else {\\n                ans += (long) c0 * (t0 - c0);\\n                c1++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n        // Author: Anand\\n      public long numberOfWays(String s) {\\n        long ans = 0;\\n\\n        int t0 = 0, t1 = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') t0++;\\n            else t1++;\\n        }\\n\\n        int c0 = 0, c1 = 0;\\n        for (int i = 0; i < s.length()-1; i++) {\\n            if (s.charAt(i) == \\'0\\') {\\n                ans += (long) c1 * (t1 - c1);\\n                c0++;\\n            } else {\\n                ans += (long) c0 * (t0 - c0);\\n                c1++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907725,
                "title": "c-binary-search",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        \\n        vector<long long>zero,ones;\\n        for(int i = 0; i<s.size(); i++){\\n            \\n            if(s[i]==\\'0\\'){\\n                zero.push_back(i);\\n            } else {\\n                ones.push_back(i);\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        for(auto it : ones){\\n            \\n            long long id = lower_bound(zero.begin(), zero.end(), it)-zero.begin();\\n            \\n            if(id!=zero.size()){\\n             ans+=(id*(zero.size()-id));   \\n            }\\n        }\\n        \\n         for(auto it : zero){\\n            \\n            long long id = lower_bound(ones.begin(), ones.end(), it)-ones.begin();\\n            \\n            if(id!=ones.size()){\\n             ans+=(id*(ones.size()-id));   \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        \\n        vector<long long>zero,ones;\\n        for(int i = 0; i<s.size(); i++){\\n            \\n            if(s[i]==\\'0\\'){\\n                zero.push_back(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1907398,
                "title": "c-two-solution-o-n-space-o-1-space",
                "content": "*first solution O(n) time and O(n) space*\\n```\\nclass Solution {\\npublic:\\n     long long find(string &s, string t) {\\n        long long m = t.length(), n = s.length();\\n        vector<vector<long long>> dp(m + 1, vector<long long> (n + 1, 0));\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int j = 1; j <= n; j++)\\n            for (int i = 1; i <= m; i++)\\n                dp[i][j] = dp[i][j - 1] + (t[i - 1] == s[j - 1] ? dp[i - 1][j - 1] : 0ll);\\n        return dp[m][n];\\n    }\\n    long long numberOfWays(string s) {\\n       long long ans=find(s,\"101\")+find(s,\"010\");\\n        return ans;\\n    }\\n};\\n```\\n*second solution O(n) time and O(1) space*\\n```\\nclass Solution {\\npublic:\\n    long long find(string &s,string t)\\n    {\\n        long long a,b,c;\\n        a=b=c=0;\\n        for(auto &it:s)\\n        {\\n            if(it==t[2])\\n            {\\n                c+=b;\\n            }\\n            if(it==t[1])\\n            {\\n                b+=a;\\n            }\\n            if(it==t[0])\\n            {\\n                a++;\\n            }\\n        }\\n        return c;\\n    }\\n    long long numberOfWays(string s) {\\n       long long ans=find(s,\"101\")+find(s,\"010\");\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     long long find(string &s, string t) {\\n        long long m = t.length(), n = s.length();\\n        vector<vector<long long>> dp(m + 1, vector<long long> (n + 1, 0));\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int j = 1; j <= n; j++)\\n            for (int i = 1; i <= m; i++)\\n                dp[i][j] = dp[i][j - 1] + (t[i - 1] == s[j - 1] ? dp[i - 1][j - 1] : 0ll);\\n        return dp[m][n];\\n    }\\n    long long numberOfWays(string s) {\\n       long long ans=find(s,\"101\")+find(s,\"010\");\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long find(string &s,string t)\\n    {\\n        long long a,b,c;\\n        a=b=c=0;\\n        for(auto &it:s)\\n        {\\n            if(it==t[2])\\n            {\\n                c+=b;\\n            }\\n            if(it==t[1])\\n            {\\n                b+=a;\\n            }\\n            if(it==t[0])\\n            {\\n                a++;\\n            }\\n        }\\n        return c;\\n    }\\n    long long numberOfWays(string s) {\\n       long long ans=find(s,\"101\")+find(s,\"010\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907395,
                "title": "3-solution-recursive-d-p-greedy",
                "content": "**Recursive solution**\\n\\n```\\nclass Solution {\\n    long long resCount=0;\\npublic:\\n    long long numberOfWays(string s) {\\n        solve(s,\\'#\\',s.size(),\"\");\\n        return resCount;\\n    }\\n  \\n  void solve(string &s,char last,int n,string res)\\n    {\\n      if(res.size()==3){\\n        resCount++;\\n        return;\\n      }\\n       if(n==0)\\n        return ;\\n    \\n      solve(s,last,n-1,res);\\n      if(s[n-1]!=last)\\n      {\\n        res+=s[n-1];\\n        last=s[n-1];\\n        solve(s,last,n-1,res);\\n      } \\n    }\\n};\\n```\\n\\n**D.P with Memoization solution** \\n\\n```\\nclass Solution {\\npublic:\\n    long long dp[100001][4][3];\\n    long long solve(string &s,char last,int i,int sz){\\n        if(sz==0) return 1;\\n\\t\\t\\n        if(i==s.size()) return 0;\\n\\t\\t\\n        if(dp[i][sz][last- \\'0\\'] != -1)\\n\\t\\t    return dp[i][sz][last - \\'0\\'];\\n        \\n        long long res = 0;\\n\\t\\t\\n        res+=solve(s,last,i+1,sz);\\n\\t\\tif(s[i] != last)\\n\\t\\tres+=solve(s,s[i],i+1,sz);\\n\\t\\t\\n        return dp[i][sz][last - \\'0\\'] = res;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,\\'#\\',0,3);\\n    }\\n};\\n```\\n\\n**Greedy**\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n         int n=s.size();\\n         \\n         int zeroCount=0,oneCount=0;\\n         \\n         for(int i=0;i<n;i++){\\n             if(s[i]==\\'0\\') \\n\\t\\t\\t  zeroCount++;\\n             else \\n\\t\\t\\t   oneCount++;\\n         }\\n         \\n         long long int res=0;\\n        \\n         int zeroBeforeI=0,oneBeforeI=0;\\n\\t\\t \\n         for(int i=0;i<n;i++){\\n             if(s[i]==\\'1\\'){\\n                 res+=zeroBeforeI*(zeroCount-zeroBeforeI);\\n                 oneBeforeI++;\\n             }else{\\n                 res+=oneBeforeI*(oneCount-oneBeforeI);\\n                 zeroBeforeI++;\\n             }\\n         }  \\n         return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    long long resCount=0;\\npublic:\\n    long long numberOfWays(string s) {\\n        solve(s,\\'#\\',s.size(),\"\");\\n        return resCount;\\n    }\\n  \\n  void solve(string &s,char last,int n,string res)\\n    {\\n      if(res.size()==3){\\n        resCount++;\\n        return;\\n      }\\n       if(n==0)\\n        return ;\\n    \\n      solve(s,last,n-1,res);\\n      if(s[n-1]!=last)\\n      {\\n        res+=s[n-1];\\n        last=s[n-1];\\n        solve(s,last,n-1,res);\\n      } \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long dp[100001][4][3];\\n    long long solve(string &s,char last,int i,int sz){\\n        if(sz==0) return 1;\\n\\t\\t\\n        if(i==s.size()) return 0;\\n\\t\\t\\n        if(dp[i][sz][last- \\'0\\'] != -1)\\n\\t\\t    return dp[i][sz][last - \\'0\\'];\\n        \\n        long long res = 0;\\n\\t\\t\\n        res+=solve(s,last,i+1,sz);\\n\\t\\tif(s[i] != last)\\n\\t\\tres+=solve(s,s[i],i+1,sz);\\n\\t\\t\\n        return dp[i][sz][last - \\'0\\'] = res;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,\\'#\\',0,3);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n         int n=s.size();\\n         \\n         int zeroCount=0,oneCount=0;\\n         \\n         for(int i=0;i<n;i++){\\n             if(s[i]==\\'0\\') \\n\\t\\t\\t  zeroCount++;\\n             else \\n\\t\\t\\t   oneCount++;\\n         }\\n         \\n         long long int res=0;\\n        \\n         int zeroBeforeI=0,oneBeforeI=0;\\n\\t\\t \\n         for(int i=0;i<n;i++){\\n             if(s[i]==\\'1\\'){\\n                 res+=zeroBeforeI*(zeroCount-zeroBeforeI);\\n                 oneBeforeI++;\\n             }else{\\n                 res+=oneBeforeI*(oneCount-oneBeforeI);\\n                 zeroBeforeI++;\\n             }\\n         }  \\n         return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907340,
                "title": "c-easy-noob-code",
                "content": "We need to find out 2 cases \"101\" and \"010\". \\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s)\\n    {\\n        long long c=0;\\n        int rightOnes[s.size()];\\n        int leftOnes[s.size()];\\n        int rightZeros[s.size()];\\n        int leftZeros[s.size()];\\n        leftOnes[0]=leftZeros[0]=0;\\n        rightZeros[s.size()-1]=leftZeros[s.size()-1]=0;\\n        int z=0,o=0;\\n        for(int i=1; i<s.size(); i++)\\n        {\\n            if(s[i-1]==\\'1\\')\\n                o++;\\n            else\\n                z++;\\n            leftZeros[i]=z;\\n            leftOnes[i]=o;\\n        }\\n        z=0,o=0;\\n        for(int i=s.size()-2; i>=0; i--)\\n        {\\n            if(s[i+1]==\\'1\\')\\n                o++;\\n            else\\n                z++;\\n            rightZeros[i]=z;\\n            rightOnes[i]=o;\\n                \\n        }\\n        for(int i=1; i<s.size()-1; i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {  \\n                    c+=(long long)(leftZeros[i]*rightZeros[i]);  //010\\n            }\\n            else\\n            {  \\n                    c+=(long long)(leftOnes[i]*rightOnes[i]);  //101\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\\nO(n) time\\nO(n) space",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s)\\n    {\\n        long long c=0;\\n        int rightOnes[s.size()];\\n        int leftOnes[s.size()];\\n        int rightZeros[s.size()];\\n        int leftZeros[s.size()];\\n        leftOnes[0]=leftZeros[0]=0;\\n        rightZeros[s.size()-1]=leftZeros[s.size()-1]=0;\\n        int z=0,o=0;\\n        for(int i=1; i<s.size(); i++)\\n        {\\n            if(s[i-1]==\\'1\\')\\n                o++;\\n            else\\n                z++;\\n            leftZeros[i]=z;\\n            leftOnes[i]=o;\\n        }\\n        z=0,o=0;\\n        for(int i=s.size()-2; i>=0; i--)\\n        {\\n            if(s[i+1]==\\'1\\')\\n                o++;\\n            else\\n                z++;\\n            rightZeros[i]=z;\\n            rightOnes[i]=o;\\n                \\n        }\\n        for(int i=1; i<s.size()-1; i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {  \\n                    c+=(long long)(leftZeros[i]*rightZeros[i]);  //010\\n            }\\n            else\\n            {  \\n                    c+=(long long)(leftOnes[i]*rightOnes[i]);  //101\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907219,
                "title": "one-pass-very-easy-and-intuitive-python-solution",
                "content": "```python\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        dp = [[0, 0, 0], [0, 0, 0]]\\n\\n        for x in [int(x) for x in s]:\\n            if x == 0:\\n                dp[0][0] += 1\\n                dp[0][2] += dp[0][1]\\n                dp[1][1] += dp[1][0]\\n            else:\\n                dp[1][0] += 1\\n                dp[0][1] += dp[0][0]\\n                dp[1][2] += dp[1][1]\\n\\n        return dp[0][2] + dp[1][2]\\n```\\n\\nAnswer can be either \"010\" or \"101\"\\n\\nLet `dp[0]`, be the list that contains number of ways to achieve \"0\", \"01\", \"010\" \\nLet `dp[1]` be the list that contains the number of ways to achieve \"1\", \"10\", \"101\"\\n\\nIterate across the string and build the dp array till current index.\\n\\nIf current value is `0` it can be added as it is to make \"0\" string, or added to \"01\" to make \"010\" or added to \"1\" to make \"10\"\\n\\n\\nRest is the same\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        dp = [[0, 0, 0], [0, 0, 0]]\\n\\n        for x in [int(x) for x in s]:\\n            if x == 0:\\n                dp[0][0] += 1\\n                dp[0][2] += dp[0][1]\\n                dp[1][1] += dp[1][0]\\n            else:\\n                dp[1][0] += 1\\n                dp[0][1] += dp[0][0]\\n                dp[1][2] += dp[1][1]\\n\\n        return dp[0][2] + dp[1][2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907182,
                "title": "c-easy-o-n-with-explanation",
                "content": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Suffix & Prefix sum of 0\\'s and 1\\'s .\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n```\\n\\n**EXPLANATION**\\n* count number of \"101\" and \"010\" substrings.\\n* Calculate suffix sum of zero\\'s and one\\'s (from left to right)\\n* Calculate Prefix sum of zero\\'s and one\\'s (from right to left)\\n* if ele==0 then count = (1\\'s suffix)(1\\'s preffix)\\n*  if ele==1 then count = (0\\'s suffix)(0\\'s preffix)\\n\\n\\n\\nTIME COMPLEXITY : O(3*N) , N is size of array   **Beats 90.02%**\\nSPACE COMPLEXITY : O(2*N),                                **Beats 70.50%**\\n\\n\\n\\n\\n\\n```\\nlong long numberOfWays(string s) {\\n        long long n=s.size();\\n        vector<pair<long long,long long>> zero(n), one(n);\\n        long long z=0,o=0;\\n        for(int i=0;i<s.size();i++){   // suffix sum of Zeros , Ones\\n            zero[i].first=z;\\n            if(s[i]==\\'0\\') z++;\\n            \\n            one[i].first=o;\\n            if(s[i]==\\'1\\') o++;\\n        }\\n        z=0,o=0;\\n        for(int i=s.size()-1;i>=0;i--){   // Prefix sum of Zeros , Ones\\n            zero[i].second=z;\\n            if(s[i]==\\'0\\') z++;\\n            \\n            one[i].second=o;\\n            if(s[i]==\\'1\\') o++;\\n        }\\n        long long cnt=0;                 \\n        for(int i=0;i<n;i++){ \\n            if(s[i]==\\'0\\')              // if 0 -> count = (suffix 1\\'s) * (prefix 1\\'s) \\n                cnt+= one[i].first*one[i].second;    \\n            if(s[i]==\\'1\\')              // if 1 -> count = (suffix 0\\'s) * (prefix 0\\'s) \\n                cnt+= zero[i].first*zero[i].second;\\n        }\\n        return cnt;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Suffix & Prefix sum of 0\\'s and 1\\'s .\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n```\n```\\nlong long numberOfWays(string s) {\\n        long long n=s.size();\\n        vector<pair<long long,long long>> zero(n), one(n);\\n        long long z=0,o=0;\\n        for(int i=0;i<s.size();i++){   // suffix sum of Zeros , Ones\\n            zero[i].first=z;\\n            if(s[i]==\\'0\\') z++;\\n            \\n            one[i].first=o;\\n            if(s[i]==\\'1\\') o++;\\n        }\\n        z=0,o=0;\\n        for(int i=s.size()-1;i>=0;i--){   // Prefix sum of Zeros , Ones\\n            zero[i].second=z;\\n            if(s[i]==\\'0\\') z++;\\n            \\n            one[i].second=o;\\n            if(s[i]==\\'1\\') o++;\\n        }\\n        long long cnt=0;                 \\n        for(int i=0;i<n;i++){ \\n            if(s[i]==\\'0\\')              // if 0 -> count = (suffix 1\\'s) * (prefix 1\\'s) \\n                cnt+= one[i].first*one[i].second;    \\n            if(s[i]==\\'1\\')              // if 1 -> count = (suffix 0\\'s) * (prefix 0\\'s) \\n                cnt+= zero[i].first*zero[i].second;\\n        }\\n        return cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907121,
                "title": "why-is-this-tle",
                "content": "The time should be O(10^5x2x3) which is 600000 way below the TLE threshold unless I am wrong\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        \\n        @lru_cache(None)\\n        def dp(i,prev,took):\\n            if took == 3:\\n                return 1\\n            if i >= len(s):\\n                return 0\\n            ans = 0\\n            if prev == 0:\\n                if s[i] == \"0\":\\n                    return dp(i+1,0,took)\\n                else:\\n                    return dp(i+1,1,took+1) + dp(i+1,0,took)\\n            else:\\n                if s[i] == \"1\":\\n                    return dp(i+1,1,took)\\n                else:\\n                    return dp(i+1,0,took+1) + dp(i+1,1,took)\\n        \\n        return dp(0,0,0) + dp(0,1,0)\\n",
                "solutionTags": [],
                "code": "The time should be O(10^5x2x3) which is 600000 way below the TLE threshold unless I am wrong\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        \\n        @lru_cache(None)\\n        def dp(i,prev,took):\\n            if took == 3:\\n                return 1\\n            if i >= len(s):\\n                return 0\\n            ans = 0\\n            if prev == 0:\\n                if s[i] == \"0\":\\n                    return dp(i+1,0,took)\\n                else:\\n                    return dp(i+1,1,took+1) + dp(i+1,0,took)\\n            else:\\n                if s[i] == \"1\":\\n                    return dp(i+1,1,took)\\n                else:\\n                    return dp(i+1,0,took+1) + dp(i+1,1,took)\\n        \\n        return dp(0,0,0) + dp(0,1,0)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1907062,
                "title": "c-easy-solution",
                "content": "for each 0 count number of 1\\'s to the left \\nand vice versa for 1\\'s \\nand then multiply\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        vector<int> numOfZero(n, 0);\\n        vector<int> numOfOnes(n, 0);\\n   \\n        int o=0,z=0;\\n        \\n        for(int i =0; i < n; ++i){\\n            if ( s[i] == \\'0\\'){\\n                numOfOnes[i] = o;\\n                z++;\\n            }else{\\n                numOfZero[i] = z;\\n                o++;\\n            }\\n        }\\n        \\n        long long ans =0;\\n        \\n        for(int i =0;i < n; ++i){\\n            if (s[i] == \\'0\\'){\\n                int left = numOfOnes[i];\\n                int right = o - left;\\n                ans += right*left;\\n            }else{\\n                int left = numOfZero[i];\\n                int right = z - left;\\n                ans += right*left; \\n            }\\n        }\\n        \\n        return ans;        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        vector<int> numOfZero(n, 0);\\n        vector<int> numOfOnes(n, 0);\\n   \\n        int o=0,z=0;\\n        \\n        for(int i =0; i < n; ++i){\\n            if ( s[i] == \\'0\\'){\\n                numOfOnes[i] = o;\\n                z++;\\n            }else{\\n                numOfZero[i] = z;\\n                o++;\\n            }\\n        }\\n        \\n        long long ans =0;\\n        \\n        for(int i =0;i < n; ++i){\\n            if (s[i] == \\'0\\'){\\n                int left = numOfOnes[i];\\n                int right = o - left;\\n                ans += right*left;\\n            }else{\\n                int left = numOfZero[i];\\n                int right = z - left;\\n                ans += right*left; \\n            }\\n        }\\n        \\n        return ans;        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907046,
                "title": "easy-c-solution-using-prefix-and-suffix-count",
                "content": "Keep the count of 0s and 1s from both the ends. Now iterate oven the string and check:\\n\\t1. If s[i] = \\'0\\', then ` ans += (prefix count of 1 at that position)  * (suffix count of 1 at that position)`\\n\\t2. If s[i] = \\'1\\', then ` ans += (prefix count of 0 at that position)  * (suffix count of 0 at that position)`\\n```\\n    long long numberOfWays(string s) {\\n        vector<pair<long long, long long>> pre, suf;\\n        \\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            pre.push_back({0, 0});\\n            suf.push_back({0, 0});\\n        }\\n        \\n        long long prev0 = 0, prev1 = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == \\'0\\') {\\n                pre[i].first = prev0+1;\\n                pre[i].second = prev1;\\n                prev0++;\\n            }else{\\n                pre[i].first = prev0;\\n                pre[i].second = prev1+1;\\n                prev1++;\\n            }\\n        }\\n        \\n        prev0 = 0, prev1 = 0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            if(s[i] == \\'0\\') {\\n                suf[i].first = prev0+1;\\n                suf[i].second = prev1;\\n                prev0++;\\n            }else{\\n                suf[i].second = prev1+1;\\n                suf[i].first = prev0;\\n                prev1++;\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == \\'0\\') {\\n                ans += pre[i].second * suf[i].second;\\n            }else{\\n                ans += pre[i].first * suf[i].first;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Suffix Array"
                ],
                "code": "```\\n    long long numberOfWays(string s) {\\n        vector<pair<long long, long long>> pre, suf;\\n        \\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            pre.push_back({0, 0});\\n            suf.push_back({0, 0});\\n        }\\n        \\n        long long prev0 = 0, prev1 = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == \\'0\\') {\\n                pre[i].first = prev0+1;\\n                pre[i].second = prev1;\\n                prev0++;\\n            }else{\\n                pre[i].first = prev0;\\n                pre[i].second = prev1+1;\\n                prev1++;\\n            }\\n        }\\n        \\n        prev0 = 0, prev1 = 0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            if(s[i] == \\'0\\') {\\n                suf[i].first = prev0+1;\\n                suf[i].second = prev1;\\n                prev0++;\\n            }else{\\n                suf[i].second = prev1+1;\\n                suf[i].first = prev0;\\n                prev1++;\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == \\'0\\') {\\n                ans += pre[i].second * suf[i].second;\\n            }else{\\n                ans += pre[i].first * suf[i].first;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907027,
                "title": "scala-naive",
                "content": "```\\ndef numberOfWays(s: String): Long = {\\n  def count(n0: Long, n1: Long, n10: Long, n01: Long, acc: Long, rem: List[Char]): Long =\\n    rem match {\\n      case Nil => acc\\n      case \\'1\\' :: tail => count(n0    , n1 + 1, n10,      n01 + n0, acc + n10, tail)\\n      case \\'0\\' :: tail => count(n0 + 1, n1    , n10 + n1, n01     , acc + n01, tail)\\n      case _ => ???\\n    }\\n\\n  count(0, 0, 0, 0, 0, s.toList)\\n}\\n  ```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\ndef numberOfWays(s: String): Long = {\\n  def count(n0: Long, n1: Long, n10: Long, n01: Long, acc: Long, rem: List[Char]): Long =\\n    rem match {\\n      case Nil => acc\\n      case \\'1\\' :: tail => count(n0    , n1 + 1, n10,      n01 + n0, acc + n10, tail)\\n      case \\'0\\' :: tail => count(n0 + 1, n1    , n10 + n1, n01     , acc + n01, tail)\\n      case _ => ???\\n    }\\n\\n  count(0, 0, 0, 0, 0, s.toList)\\n}\\n  ```",
                "codeTag": "Python3"
            },
            {
                "id": 1907018,
                "title": "c-prefix-count",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n    long long numberOfWays(string s) {\\n         long long int n=s.length();\\n        vector<pair<long long int,long long int>> pre(n);\\n        long long int one=0,zero=0;\\n        for(int i=0;i<n;i++){\\n            pre[i]={zero,one};\\n            if(s[i]==\\'0\\') zero++;\\n            else one++;\\n        }\\n        long long int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'0\\'){\\n                ans+=pre[i].second*(one-pre[i].second);\\n            }\\n            else ans+=pre[i].first*(zero-pre[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    long long numberOfWays(string s) {\\n         long long int n=s.length();\\n        vector<pair<long long int,long long int>> pre(n);\\n        long long int one=0,zero=0;\\n        for(int i=0;i<n;i++){\\n            pre[i]={zero,one};\\n            if(s[i]==\\'0\\') zero++;\\n            else one++;\\n        }\\n        long long int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'0\\'){\\n                ans+=pre[i].second*(one-pre[i].second);\\n            }\\n            else ans+=pre[i].first*(zero-pre[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907014,
                "title": "dp-memoization",
                "content": "\\n```\\nWhy It is Giving TLE, Can some one explain\\n\\nclass Solution {\\npublic:\\n    unordered_map<string,long long>dp;\\n    \\n    long long validPaths(string &s, long long n , char prev = \\' \\', long long added = 0){\\n        \\n        if(added == 3) \\n            return 1;\\n        if(n <= 0){\\n            return 0;\\n        }\\n        \\n        string key = to_string(n) + prev + to_string(added);\\n        \\n        if(dp.count(key)){\\n            return dp[key];\\n        }\\n        \\n        if( prev == s[n-1] ) {\\n            return dp[key] = validPaths(s, n - 1, prev, added);\\n        }\\n        \\n        long long r1 = validPaths(s, n - 1,s[n - 1], added+1) ;\\n        long long r2 = validPaths(s, n - 1, prev, added) ;\\n        \\n       \\n        return dp[key] = r1 + r2;\\n    }\\n    long long numberOfWays(string s) {\\n      \\n        long long n = s.size() ;\\n        long long result = validPaths(s, n);\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    unordered_map<string,long long>dp;\\n    \\n    long long validPaths(string &s, long long n , char prev = \\' \\', long long added = 0){\\n        \\n        if(added == 3) \\n            return 1;\\n        if(n <= 0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3971652,
                "title": "top-down-approach-o-n-java",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long[][][] memo = new long[s.length()][3][3];\\n        for (long[][] arr: memo) for (long[] row: arr) Arrays.fill(row, -1);\\n        return slv(0, \\'2\\', 3, s, memo);\\n    }\\n\\n    private long slv(int n, char prev, int target, String city, long[][][] memo) {\\n        if (target == 0) return 1;\\n        if (n >= city.length()) return 0;\\n        if (memo[n][target - 1][prev - 48] != -1) return memo[n][target - 1][prev - 48];\\n        if (city.charAt(n) == prev) {\\n            memo[n][target - 1][prev - 48] = slv(n + 1, prev, target, city, memo);\\n        } else {\\n            memo[n][target - 1][prev - 48] = slv(n + 1, city.charAt(n), target - 1, city, memo) +\\n                slv(n + 1, prev, target, city, memo);\\n        }\\n        return memo[n][target - 1][prev - 48];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long[][][] memo = new long[s.length()][3][3];\\n        for (long[][] arr: memo) for (long[] row: arr) Arrays.fill(row, -1);\\n        return slv(0, \\'2\\', 3, s, memo);\\n    }\\n\\n    private long slv(int n, char prev, int target, String city, long[][][] memo) {\\n        if (target == 0) return 1;\\n        if (n >= city.length()) return 0;\\n        if (memo[n][target - 1][prev - 48] != -1) return memo[n][target - 1][prev - 48];\\n        if (city.charAt(n) == prev) {\\n            memo[n][target - 1][prev - 48] = slv(n + 1, prev, target, city, memo);\\n        } else {\\n            memo[n][target - 1][prev - 48] = slv(n + 1, city.charAt(n), target - 1, city, memo) +\\n                slv(n + 1, prev, target, city, memo);\\n        }\\n        return memo[n][target - 1][prev - 48];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351531,
                "title": "312-ms",
                "content": "```ruby\\ndef number_of_ways s\\n    ro = s.size - (rz = s.count(?0))\\n    return 0 if ro.zero? || rz.zero?\\n    lo, lz, c = 0, 0, 0\\n    s.each_byte do\\n        c += _1 == 48 ?\\n            (lz += 1; rz -= 1; lo * ro) :\\n            (lo += 1; ro -= 1; lz * rz)\\n    end\\n    c\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef number_of_ways s\\n    ro = s.size - (rz = s.count(?0))\\n    return 0 if ro.zero? || rz.zero?\\n    lo, lz, c = 0, 0, 0\\n    s.each_byte do\\n        c += _1 == 48 ?\\n            (lz += 1; rz -= 1; lo * ro) :\\n            (lo += 1; ro -= 1; lz * rz)\\n    end\\n    c\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3151016,
                "title": "3d-dp-recursion-memoization-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long dp[2][100005][4];\\n    long long f(char prev, int i, string &s, int count)\\n    {\\n        long long ans=0;\\n        if(count==3) return 1;\\n        if(i==s.size()) return 0;\\n        if(prev!=\\'-\\' && dp[prev-48][i][count]!=-1) return dp[prev-48][i][count];\\n        long long take=0, dont=0;\\n        if(prev!=s[i]) dp[s[i]-48][i+1][count+1]=take=f(s[i],i+1,s,count+1);\\n        if(prev!=\\'-\\') dp[prev-48][i+1][count]=dont=f(prev,i+1,s,count); \\n        else dont=f(prev,i+1,s,count); \\n        if(prev==\\'-\\') return take+dont;\\n        return dp[prev-48][i][count]=take+dont;\\n    }\\n    long long numberOfWays(string s) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return f(\\'-\\',0,s,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long dp[2][100005][4];\\n    long long f(char prev, int i, string &s, int count)\\n    {\\n        long long ans=0;\\n        if(count==3) return 1;\\n        if(i==s.size()) return 0;\\n        if(prev!=\\'-\\' && dp[prev-48][i][count]!=-1) return dp[prev-48][i][count];\\n        long long take=0, dont=0;\\n        if(prev!=s[i]) dp[s[i]-48][i+1][count+1]=take=f(s[i],i+1,s,count+1);\\n        if(prev!=\\'-\\') dp[prev-48][i+1][count]=dont=f(prev,i+1,s,count); \\n        else dont=f(prev,i+1,s,count); \\n        if(prev==\\'-\\') return take+dont;\\n        return dp[prev-48][i][count]=take+dont;\\n    }\\n    long long numberOfWays(string s) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return f(\\'-\\',0,s,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986251,
                "title": "easy-understanding-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) \\n    {\\n        map<string,long long>mp;\\n        long long count=0;\\n        for(auto t:s)\\n        {\\n            string x= (t==\\'0\\') ?\"0\" :\"1\";\\n            if(x==\"0\")\\n            {\\n                mp[\"10\"]+=mp[\"1\"];\\n                if(mp.find(\"01\")!=mp.end())\\n                {\\n                    count+=mp[\"01\"];\\n                }\\n                mp[x]++;\\n            }\\n            else\\n            {\\n                mp[\"01\"]+=mp[\"0\"];\\n                if(mp.find(\"10\")!=mp.end())\\n                {\\n                    count+=mp[\"10\"];\\n                }\\n                mp[x]++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) \\n    {\\n        map<string,long long>mp;\\n        long long count=0;\\n        for(auto t:s)\\n        {\\n            string x= (t==\\'0\\') ?\"0\" :\"1\";\\n            if(x==\"0\")\\n            {\\n                mp[\"10\"]+=mp[\"1\"];\\n                if(mp.find(\"01\")!=mp.end())\\n                {\\n                    count+=mp[\"01\"];\\n                }\\n                mp[x]++;\\n            }\\n            else\\n            {\\n                mp[\"01\"]+=mp[\"0\"];\\n                if(mp.find(\"10\")!=mp.end())\\n                {\\n                    count+=mp[\"10\"];\\n                }\\n                mp[x]++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795244,
                "title": "c-easy-explanation-prefix-sum",
                "content": "Explanation:Since if the Current Building is \\'0\\' Then we need to count How many Buildings are there with patter \\'10\\' ie one build,one office.\\nWhat if the current building is \\'1\\' Then we need to search for \\'01\\' pattern buildings.\\nSo For every index in the array we computed the count of Such pattern in Two different Arrays.\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n=s.length();\\n\\t\\t//This Vector Search for the Count of \\'10\\' pattern for every index.\\n        vector<long long>CountOneZero(n);\\n        long long zero=0;\\n        long long count=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\'0\\')\\n                zero++;\\n            if(s[i]==\\'1\\')\\n                count+=(zero);\\n            CountOneZero[i]=count;\\n        }\\n\\t\\t//This Vector Search for the Count of \\'01\\' pattern for every index.\\n        vector<long long>CountZeroOne(n);\\n        long long one=0;\\n        count=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\'1\\')\\n                one++;\\n            if(s[i]==\\'0\\')\\n                count+=(one);\\n            CountZeroOne[i]=count;\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\')//If the Current Building is 0 then we need to Seach for the count of 10 pattern\\n                ans+=CountOneZero[i];\\n            else //If the Current Building is 1 then we need to Seach for the count of 01 pattern\\n                ans+=CountZeroOne[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n=s.length();\\n\\t\\t//This Vector Search for the Count of \\'10\\' pattern for every index.\\n        vector<long long>CountOneZero(n);\\n        long long zero=0;\\n        long long count=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\'0\\')\\n                zero++;\\n            if(s[i]==\\'1\\')\\n                count+=(zero);\\n            CountOneZero[i]=count;\\n        }\\n\\t\\t//This Vector Search for the Count of \\'01\\' pattern for every index.\\n        vector<long long>CountZeroOne(n);\\n        long long one=0;\\n        count=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\'1\\')\\n                one++;\\n            if(s[i]==\\'0\\')\\n                count+=(one);\\n            CountZeroOne[i]=count;\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\')//If the Current Building is 0 then we need to Seach for the count of 10 pattern\\n                ans+=CountOneZero[i];\\n            else //If the Current Building is 1 then we need to Seach for the count of 01 pattern\\n                ans+=CountZeroOne[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740535,
                "title": "python-prefix-sum-o-n",
                "content": "Treat every index as the middle element. Then you just need the count of either 1\\'s or 0\\'s before and after i. The amount to add to the answer is the count of low * count of high\\n\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        n = len(s)\\n        pre = [0]*n\\n        for i in range(n):\\n            if i==0:\\n                pre[i] = int(s[i])\\n            if i>0:\\n                pre[i] = int(s[i])+pre[i-1]\\n        \\n        ans=0\\n        for i in range(1, n-1):\\n            low = pre[i-1]\\n            high = pre[n-1]-pre[i]\\n            if s[i]==\\'1\\':\\n                low = abs(i-low)\\n                high = abs(n-i-high-1)\\n            ans+=high*low\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        n = len(s)\\n        pre = [0]*n\\n        for i in range(n):\\n            if i==0:\\n                pre[i] = int(s[i])\\n            if i>0:\\n                pre[i] = int(s[i])+pre[i-1]\\n        \\n        ans=0\\n        for i in range(1, n-1):\\n            low = pre[i-1]\\n            high = pre[n-1]-pre[i]\\n            if s[i]==\\'1\\':\\n                low = abs(i-low)\\n                high = abs(n-i-high-1)\\n            ans+=high*low\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2624014,
                "title": "c-prefix-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        vector<pair<int, int>> memo(s.size());\\n        if(s[0]==\\'1\\') memo[0].first=0, memo[0].second=1;\\n        else memo[0].second=0, memo[0].first=1;\\n\\n        for(int i=1; i<s.size(); i++) {\\n            if(s[i]==\\'1\\') memo[i].first=memo[i-1].first, memo[i].second=memo[i-1].second+1;\\n            else memo[i].second=memo[i-1].second, memo[i].first=memo[i-1].first+1;\\n        }\\n\\n        int zeroCount=memo[s.size()-1].first, oneCount=memo[s.size()-1].second;\\n        long long totalWays=0;\\n        for(int i=1; i<s.size()-1; i++) {\\n            if(s[i]==\\'0\\') totalWays+=memo[i].second*(oneCount-memo[i].second);\\n            else totalWays+=memo[i].first*(zeroCount-memo[i].first);\\n        }\\n        return totalWays;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        vector<pair<int, int>> memo(s.size());\\n        if(s[0]==\\'1\\') memo[0].first=0, memo[0].second=1;\\n        else memo[0].second=0, memo[0].first=1;\\n\\n        for(int i=1; i<s.size(); i++) {\\n            if(s[i]==\\'1\\') memo[i].first=memo[i-1].first, memo[i].second=memo[i-1].second+1;\\n            else memo[i].second=memo[i-1].second, memo[i].first=memo[i-1].first+1;\\n        }\\n\\n        int zeroCount=memo[s.size()-1].first, oneCount=memo[s.size()-1].second;\\n        long long totalWays=0;\\n        for(int i=1; i<s.size()-1; i++) {\\n            if(s[i]==\\'0\\') totalWays+=memo[i].second*(oneCount-memo[i].second);\\n            else totalWays+=memo[i].first*(zeroCount-memo[i].first);\\n        }\\n        return totalWays;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549490,
                "title": "simple-single-scan-o-n-o-1-space-dp-accumulator-solution",
                "content": "We need the count of valid 3 length strings- we track count of 0s,1s, 01s and 10s - this is then used to accumulate the answer\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long noOf0=0;\\n        long noOf1=0;\\n        long noOf01=0;\\n        long noOf10=0;\\n        long long total = 0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == \\'1\\') {\\n                noOf1++;\\n                noOf01 += noOf0;\\n                total += noOf10;\\n            } else {\\n                noOf0++;\\n                noOf10 += noOf1;\\n                total += noOf01;\\n            }\\n        }\\n        return total;\\n                            \\n    }\\n};```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long noOf0=0;\\n        long noOf1=0;\\n        long noOf01=0;\\n        long noOf10=0;\\n        long long total = 0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == \\'1\\') {\\n                noOf1++;\\n                noOf01 += noOf0;\\n                total += noOf10;\\n            } else {\\n                noOf0++;\\n                noOf10 += noOf1;\\n                total += noOf01;\\n            }\\n        }\\n        return total;\\n                            \\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2548538,
                "title": "understand-fundamentals-of-these-kind-of-questions",
                "content": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        //observation 1 : need to find out only 3 buildings thats why\\n        //This proplem is relatable to a problem : find out all valid ways where :\\n        //i < j < k && A[i] < A[j] < A[k]\\n        \\n        //so we need to fix A[j] to find each possibility of i and k respective to j\\n        // and multiply the count of i and k and add it into the answer\\n\\t\\t//beacuse contribution of i in left * contribution of k in right is the all valid ways for a specific j\\n        \\n        //here in this problem I can fix j as either 0 and 1 and find i and k respectively\\n\\t\\t// in this question i=k;\\n        \\n        int n = s.length();\\n        long ans = 0, rightZero = 0 , rightOne = 0;\\n        //calculating all the right 1s and rigth 0s\\n        for(int i = 0 ; i < n ;i++){\\n            char c = s.charAt(i);\\n            if(c==\\'0\\') rightZero++;\\n            else rightOne++;\\n            \\n        }\\n        long leftZero = 0, leftOne = 0;\\n        for(int j = 0 ; j < n ; j++){\\n            \\n            char c = s.charAt(j);\\n            if(c == \\'0\\'){ // I need to find out all 1s in left \\n                ans += rightOne * leftOne;\\n                rightZero --;\\n                leftZero++;\\n            }\\n            else{ // I need to find out all 0s in left \\n                ans += leftZero * rightZero;\\n                rightOne--;\\n                leftOne++;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        //observation 1 : need to find out only 3 buildings thats why\\n        //This proplem is relatable to a problem : find out all valid ways where :\\n        //i < j < k && A[i] < A[j] < A[k]\\n        \\n        //so we need to fix A[j] to find each possibility of i and k respective to j\\n        // and multiply the count of i and k and add it into the answer\\n\\t\\t//beacuse contribution of i in left * contribution of k in right is the all valid ways for a specific j\\n        \\n        //here in this problem I can fix j as either 0 and 1 and find i and k respectively\\n\\t\\t// in this question i=k;\\n        \\n        int n = s.length();\\n        long ans = 0, rightZero = 0 , rightOne = 0;\\n        //calculating all the right 1s and rigth 0s\\n        for(int i = 0 ; i < n ;i++){\\n            char c = s.charAt(i);\\n            if(c==\\'0\\') rightZero++;\\n            else rightOne++;\\n            \\n        }\\n        long leftZero = 0, leftOne = 0;\\n        for(int j = 0 ; j < n ; j++){\\n            \\n            char c = s.charAt(j);\\n            if(c == \\'0\\'){ // I need to find out all 1s in left \\n                ans += rightOne * leftOne;\\n                rightZero --;\\n                leftZero++;\\n            }\\n            else{ // I need to find out all 0s in left \\n                ans += leftZero * rightZero;\\n                rightOne--;\\n                leftOne++;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547113,
                "title": "python-combination-or-dp",
                "content": "The DP solution is an implementation of a solution provided [here](https://leetcode.com/problems/number-of-ways-to-select-buildings/discuss/1907109/PythonDP-easy-to-understand).\\n\\n**Solution**:\\nThere are two ways to solve this problem.\\n1. Combination\\nFor any given digit, the number of combination can formed using such digit as the mid value is the number of opposite digit to the left multiply by the number of digit to opposite to the right. \\n    \\n\\tIE if there is 4 0s to the left and 10 0s to the right, the number combination resulting in a \"010\" will be 40. \\n\\n2. DP\\n    Keep counts of the occurence of all possible sequence ending with each digit. ie 0s can be used to the following sequences: 0, 10, 010 and 1s can be used to form the following sequence 1, 01, 010. Iterate through all characters and keep track of occurence of all possible sequences.\\n\\n    If the current digit is 0, update the occurence of 0, 10, 010 using the following formula  \\n        counts[\"0\"]     +=  1\\n        counts[\"10\"]    +=  counts[\"1\"]\\n        counts[\"010\"]   +=  counts[\"01\"]\\n\\n    If the current digit is 1, update the occurence of 1, 01, 010 using the following formula\\n        counts[\"1\"]     +=  1\\n        counts[\"01\"]    +=  counts[\"0\"]\\n        counts[\"101\"]   +=  counts[\"10\"]\\n\\n**Complexity**:\\n    Time: O(n)\\n    Space: O(1)\\n\\t\\n```\\nfrom collections import Counter, defaultdict\\n\\n# Combination Solution\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n\\n        # Get length of s\\n        n = len(s)\\n\\n        # Use two counters to keep track of the numbers of digits to the left and the right of the current number\\n        left, right = Counter(), Counter(s)\\n\\n        # A helper to find an opposite\\n        opp = {\"1\": \"0\", \"0\": \"1\"}\\n\\n        # Initialize i and result\\n        i, res = 0, 0\\n\\n        # Iterate through all characters in s\\n        while i < n:\\n            \\n            # Count the occurence of the current digit\\n            count = 1\\n            while i < n - 1 and s[i] == s[i + 1]:\\n                count, i = count + 1, i + 1\\n\\n            # Multiply the occuerence of the opposite digit at the left and right with the count of the current digit\\n            res += left[opp[s[i]]] * count * right[opp[s[i]]]\\n\\n            # Update the left and right counters\\n            left[s[i]], right[s[i]] = left[s[i]] + count, right[s[i]] - count\\n\\n            # Increment i\\n            i += 1\\n\\n        return res\\n\\n# DP Solution\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n\\n        # Initialize a dict to keep track of counts\\n        counts = defaultdict(int)\\n\\n        # Iterate through all characters\\n        for c in s:\\n\\n            # If the current digit is 1, update the counts of all sequence that such digit can contribute to\\n            if c == \"1\":\\n                counts[\"1\"], counts[\"01\"], counts[\"101\"] = (\\n                    counts[\"1\"] + 1,\\n                    counts[\"01\"] + counts[\"0\"],\\n                    counts[\"101\"] + counts[\"10\"],\\n                )\\n\\n            # Else if the current digit is 0, update the counts of all sequence that such digit can contribute to\\n            else:\\n                counts[\"0\"], counts[\"10\"], counts[\"010\"] = (\\n                    counts[\"0\"] + 1,\\n                    counts[\"10\"] + counts[\"1\"],\\n                    counts[\"010\"] + counts[\"01\"],\\n                )\\n\\n        # Return the counts of sequence that we are looking for\\n        return counts[\"101\"] + counts[\"010\"]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter, defaultdict\\n\\n# Combination Solution\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n\\n        # Get length of s\\n        n = len(s)\\n\\n        # Use two counters to keep track of the numbers of digits to the left and the right of the current number\\n        left, right = Counter(), Counter(s)\\n\\n        # A helper to find an opposite\\n        opp = {\"1\": \"0\", \"0\": \"1\"}\\n\\n        # Initialize i and result\\n        i, res = 0, 0\\n\\n        # Iterate through all characters in s\\n        while i < n:\\n            \\n            # Count the occurence of the current digit\\n            count = 1\\n            while i < n - 1 and s[i] == s[i + 1]:\\n                count, i = count + 1, i + 1\\n\\n            # Multiply the occuerence of the opposite digit at the left and right with the count of the current digit\\n            res += left[opp[s[i]]] * count * right[opp[s[i]]]\\n\\n            # Update the left and right counters\\n            left[s[i]], right[s[i]] = left[s[i]] + count, right[s[i]] - count\\n\\n            # Increment i\\n            i += 1\\n\\n        return res\\n\\n# DP Solution\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n\\n        # Initialize a dict to keep track of counts\\n        counts = defaultdict(int)\\n\\n        # Iterate through all characters\\n        for c in s:\\n\\n            # If the current digit is 1, update the counts of all sequence that such digit can contribute to\\n            if c == \"1\":\\n                counts[\"1\"], counts[\"01\"], counts[\"101\"] = (\\n                    counts[\"1\"] + 1,\\n                    counts[\"01\"] + counts[\"0\"],\\n                    counts[\"101\"] + counts[\"10\"],\\n                )\\n\\n            # Else if the current digit is 0, update the counts of all sequence that such digit can contribute to\\n            else:\\n                counts[\"0\"], counts[\"10\"], counts[\"010\"] = (\\n                    counts[\"0\"] + 1,\\n                    counts[\"10\"] + counts[\"1\"],\\n                    counts[\"010\"] + counts[\"01\"],\\n                )\\n\\n        # Return the counts of sequence that we are looking for\\n        return counts[\"101\"] + counts[\"010\"]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531571,
                "title": "c-count-zeroes-on-either-side",
                "content": "```c++\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        vector<int> numZeroesLeft (n, 0); // numZeroesLeft[i] = number of zeroes to the left of i (exclusive).\\n        vector<int> numZeroesRight (n, 0); // numZeroesRight[i] = number of zeroes to the right of i (exclusive).\\n        \\n        for (int i = 1; i < n; i++) {\\n            numZeroesLeft[i] = numZeroesLeft[i - 1];\\n            if (s[i - 1] == \\'0\\') {\\n                numZeroesLeft[i]++;\\n            }\\n        }\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            numZeroesRight[i] = numZeroesRight[i + 1];\\n            if (s[i + 1] == \\'0\\') {\\n                numZeroesRight[i]++;\\n            }\\n        }\\n        long long ans = 0;\\n        for (int i = 1; i < n - 1; i++) {\\n            if (s[i] == \\'1\\') {\\n                // 0 1 0: find the number of zeroes on either side of this 1.\\n                ans += numZeroesLeft[i] * numZeroesRight[i];\\n            } else {\\n                // 1 0 1: find the number of ones on the left and right of this 0.\\n                int onesLeft = i - numZeroesLeft[i];\\n                int onesRight = n - 1 - i - numZeroesRight[i];\\n                ans += onesLeft * onesRight;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Counting"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        vector<int> numZeroesLeft (n, 0); // numZeroesLeft[i] = number of zeroes to the left of i (exclusive).\\n        vector<int> numZeroesRight (n, 0); // numZeroesRight[i] = number of zeroes to the right of i (exclusive).\\n        \\n        for (int i = 1; i < n; i++) {\\n            numZeroesLeft[i] = numZeroesLeft[i - 1];\\n            if (s[i - 1] == \\'0\\') {\\n                numZeroesLeft[i]++;\\n            }\\n        }\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            numZeroesRight[i] = numZeroesRight[i + 1];\\n            if (s[i + 1] == \\'0\\') {\\n                numZeroesRight[i]++;\\n            }\\n        }\\n        long long ans = 0;\\n        for (int i = 1; i < n - 1; i++) {\\n            if (s[i] == \\'1\\') {\\n                // 0 1 0: find the number of zeroes on either side of this 1.\\n                ans += numZeroesLeft[i] * numZeroesRight[i];\\n            } else {\\n                // 1 0 1: find the number of ones on the left and right of this 0.\\n                int onesLeft = i - numZeroesLeft[i];\\n                int onesRight = n - 1 - i - numZeroesRight[i];\\n                ans += onesLeft * onesRight;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495091,
                "title": "linear-time-constant-space-extremely-simple",
                "content": "We just keep track of counts of all the patterns we are interesested in\\n`(0, 01, 010, 1, 10, 101)`\\n\\n```\\nclass Solution(object):\\n    def numberOfWays(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        dp = {\\'0\\': 0, \\'1\\': 0, \\'01\\': 0, \\'10\\': 0, \\'010\\': 0, \\'101\\': 0}\\n        for e in s:\\n            if e == \\'0\\':\\n                dp[\\'0\\'] += 1\\n                dp[\\'10\\'] += dp[\\'1\\']\\n                dp[\\'010\\'] += dp[\\'01\\']\\n            else:\\n                dp[\\'1\\'] += 1\\n                dp[\\'01\\'] += dp[\\'0\\']\\n                dp[\\'101\\'] += dp[\\'10\\']\\n        return dp[\\'101\\']+dp[\\'010\\']\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def numberOfWays(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        dp = {\\'0\\': 0, \\'1\\': 0, \\'01\\': 0, \\'10\\': 0, \\'010\\': 0, \\'101\\': 0}\\n        for e in s:\\n            if e == \\'0\\':\\n                dp[\\'0\\'] += 1\\n                dp[\\'10\\'] += dp[\\'1\\']\\n                dp[\\'010\\'] += dp[\\'01\\']\\n            else:\\n                dp[\\'1\\'] += 1\\n                dp[\\'01\\'] += dp[\\'0\\']\\n                dp[\\'101\\'] += dp[\\'10\\']\\n        return dp[\\'101\\']+dp[\\'010\\']\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447902,
                "title": "easy-memoization-c",
                "content": "**upvote if u like**\\n```\\nclass Solution {\\npublic:\\n    long long dp[100001][3][3];\\n    long long solve(string &s,int idx,char c,long long len)\\n    {\\n        if(len==3)\\n        {\\n            return 1;\\n        }\\n        if(idx>=s.length())\\n        {\\n            return 0;\\n        }\\n        if(dp[idx][c-\\'0\\'][len]!=-1)\\n        {\\n            return dp[idx][c-\\'0\\'][len];\\n        }\\n        long long ans=0;\\n        if(s[idx]!=c)\\n        {\\n            ans+=solve(s,idx+1,s[idx],len+1);\\n        }\\n        ans+=solve(s,idx+1,c,len);\\n        return dp[idx][c-\\'0\\'][len]=ans;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,0,\\'2\\',0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100001][3][3];\\n    long long solve(string &s,int idx,char c,long long len)\\n    {\\n        if(len==3)\\n        {\\n            return 1;\\n        }\\n        if(idx>=s.length())\\n        {\\n            return 0;\\n        }\\n        if(dp[idx][c-\\'0\\'][len]!=-1)\\n        {\\n            return dp[idx][c-\\'0\\'][len];\\n        }\\n        long long ans=0;\\n        if(s[idx]!=c)\\n        {\\n            ans+=solve(s,idx+1,s[idx],len+1);\\n        }\\n        ans+=solve(s,idx+1,c,len);\\n        return dp[idx][c-\\'0\\'][len]=ans;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,0,\\'2\\',0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413871,
                "title": "python-dp-slow-3-loops-but-easiest-and-most-detailed-thought-process",
                "content": "This is my first time writing a solution. So please bear with me and comment your thoughts!!\\n\\nBecause *no two consecutive buildings out of the selected buildings can be of the same type* and the only types are 0 and 1. Therefore, the only possible sequences are **010** and **101**. We want to find number of **010** + number of  **101** until the end (index len(s)-1).\\n\\nNotice that either **01** precedes **010** or **10** precedes **101** so that **010** or **101** can be formed. Let dp01[i] be the number of subsequences **01** until index i and dp10[i] be the number of subsequences **10** until index i.\\n\\nNow suppose we want to find out the number of **010** **OR** **101** until index i of s, there are two cases:\\n* if s[i] == \\'0\\', only **010** can be formed because **101** requires 1 to be the last digit\\n\\t* number of possible **010** = number of **01** until index i-1 == dp01[i-1]\\n* if s[i] == \\'1\\', only **101** can be formed because **010** requires 0 to be the last digit\\n\\t* number of possible **101** = number of **10** until index i-1 == dp10[i-1]\\n\\nThe rest of the problem becomes **find the number of 01 and number of 10 until each index <==> find dp01 and dp10**. A very similar observation can be made that only **0** precedes **01** or **1** precedes **10** so that **01** or **10** can be formed. Just like above:\\n* if s[i] == \\'0\\', only **10** can be formed because **01** requires 1 to be the last digit\\n\\t* number of possible **10** = number of **10** until index i-1 + number of **1** until index i-1 == CAN YOU FIND THIS DIRECTLY?\\n* if s[i] == \\'1\\', only **01** can be formed because **10** requires 0 to be the last digit\\n\\t* number of possible **01** = number of **01** until index i-1 + number of **0** until index i-1 == CAN YOU FIND THIS DIRECTLY?\\n\\nThat\\'s it! Please UPVOTE if it helps, thanks!!!\\n\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        # i => #occurence of 0\\n        occurence_0_until_i = {}\\n        # i => #occurence of 1\\n        occurence_1_until_i = {}\\n        num_0 = num_1 = 0\\n        for i in range(len(s)):\\n            if (s[i] == \\'0\\'):\\n                num_0 += 1\\n            else:\\n                num_1 += 1\\n            occurence_0_until_i[i] = num_0\\n            occurence_1_until_i[i] = num_1\\n        \\n        # dp01[i] <==> #subsequence of 01 until index i\\n        dp01 = [0 for i in range(len(s))]\\n        # dp10[i] <==> #subsequence of 10 until index i\\n        dp10 = [0 for i in range(len(s))]\\n        for i in range(1, len(s)):\\n            dp01[i] = dp01[i - 1]\\n            dp10[i] = dp10[i - 1]\\n            if (s[i] == \\'1\\'):\\n                dp01[i] += occurence_0_until_i[i - 1]\\n            else:\\n                dp10[i] += occurence_1_until_i[i - 1]\\n        \\n        res = 0\\n        for i in range(2, len(s)):\\n            res += dp01[i - 1] if s[i] == \"0\" else dp10[i - 1]\\n        return res\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        # i => #occurence of 0\\n        occurence_0_until_i = {}\\n        # i => #occurence of 1\\n        occurence_1_until_i = {}\\n        num_0 = num_1 = 0\\n        for i in range(len(s)):\\n            if (s[i] == \\'0\\'):\\n                num_0 += 1\\n            else:\\n                num_1 += 1\\n            occurence_0_until_i[i] = num_0\\n            occurence_1_until_i[i] = num_1\\n        \\n        # dp01[i] <==> #subsequence of 01 until index i\\n        dp01 = [0 for i in range(len(s))]\\n        # dp10[i] <==> #subsequence of 10 until index i\\n        dp10 = [0 for i in range(len(s))]\\n        for i in range(1, len(s)):\\n            dp01[i] = dp01[i - 1]\\n            dp10[i] = dp10[i - 1]\\n            if (s[i] == \\'1\\'):\\n                dp01[i] += occurence_0_until_i[i - 1]\\n            else:\\n                dp10[i] += occurence_1_until_i[i - 1]\\n        \\n        res = 0\\n        for i in range(2, len(s)):\\n            res += dp01[i - 1] if s[i] == \"0\" else dp10[i - 1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355749,
                "title": "python-shortest-dp",
                "content": "```python\\n def numberOfWays(self, s: str) -> int:\\n        a, b = [0,0], [0,0]\\n        res = 0 \\n        for i in map(int, s):\\n            b[i] += 1\\n            res += a[i^1]\\n            a[i] += b[i^1]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\n def numberOfWays(self, s: str) -> int:\\n        a, b = [0,0], [0,0]\\n        res = 0 \\n        for i in map(int, s):\\n            b[i] += 1\\n            res += a[i^1]\\n            a[i] += b[i^1]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2314072,
                "title": "c-simple-solution-prefix-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        \\n        int n = s.size();\\n        vector<long long> prefix0(n, 0), prefix1 = prefix0;\\n        long long ans = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i)\\n                prefix0[i] = prefix0[i - 1], prefix1[i] = prefix1[i - 1];\\n            \\n            if(s[i] == \\'1\\')\\n                prefix1[i]++;\\n            else\\n                prefix0[i]++;\\n        }\\n        \\n        // Counting Number of 010 formations\\n        for(int i = 1; i < n - 1; i++)\\n            if(s[i] == \\'1\\')\\n                ans += prefix0[i - 1] * (prefix0[n - 1] - prefix0[i - 1]);\\n        \\n        // Counting Number of 101 formations\\n        for(int i = 1; i < n - 1; i++)\\n            if(s[i] == \\'0\\')\\n                ans += prefix1[i - 1] * (prefix1[n - 1] - prefix1[i - 1]);\\n        \\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        \\n        int n = s.size();\\n        vector<long long> prefix0(n, 0), prefix1 = prefix0;\\n        long long ans = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i)\\n                prefix0[i] = prefix0[i - 1], prefix1[i] = prefix1[i - 1];\\n            \\n            if(s[i] == \\'1\\')\\n                prefix1[i]++;\\n            else\\n                prefix0[i]++;\\n        }\\n        \\n        // Counting Number of 010 formations\\n        for(int i = 1; i < n - 1; i++)\\n            if(s[i] == \\'1\\')\\n                ans += prefix0[i - 1] * (prefix0[n - 1] - prefix0[i - 1]);\\n        \\n        // Counting Number of 101 formations\\n        for(int i = 1; i < n - 1; i++)\\n            if(s[i] == \\'0\\')\\n                ans += prefix1[i - 1] * (prefix1[n - 1] - prefix1[i - 1]);\\n        \\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290101,
                "title": "python-simple-maths",
                "content": "\\n    def numberOfWays(self, s):\\n        n = len(s)\\n        \\n        right_zeros = s.count(\"0\")\\n        right_ones = n - right_zeros\\n        \\n        result, left_zeros, left_ones = 0, 0, 0\\n        \\n        for i in range(n):\\n            if s[i] == \"1\":\\n                result += left_zeros*right_zeros\\n                left_ones += 1\\n                right_ones -= 1\\n            else:\\n                result += left_ones*right_ones\\n                left_zeros += 1\\n                right_zeros -= 1\\n                \\n        return result",
                "solutionTags": [],
                "code": "\\n    def numberOfWays(self, s):\\n        n = len(s)\\n        \\n        right_zeros = s.count(\"0\")\\n        right_ones = n - right_zeros\\n        \\n        result, left_zeros, left_ones = 0, 0, 0\\n        \\n        for i in range(n):\\n            if s[i] == \"1\":\\n                result += left_zeros*right_zeros\\n                left_ones += 1\\n                right_ones -= 1\\n            else:\\n                result += left_ones*right_ones\\n                left_zeros += 1\\n                right_zeros -= 1\\n                \\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 2263026,
                "title": "c-dp-prefix-and-suffix-array-concept",
                "content": "If current element is \\'0\\', total number of local answers would be product of all \\'1\\' before current index and all \\'1\\' after current index.\\nvice versa for \\'1\\'(product of all \\'0\\' before and after current index)\\n\\nNOTE: Practically, it\\'s enough to have information of number of zeros before and after each index. Calculation of number of ones can be computed from it only.\\n\\n```cpp\\n    long long numberOfWays(string s) {\\n      long long n = s.length();\\n      vector<long long> b(n);\\n      vector<long long> a(n);\\n      b[0] = 0;\\n      a[n-1] = 0;\\n      for(int i=1; i<n; i++){\\n          b[i] = b[i-1] + int(s[i-1] == \\'0\\');\\n          a[n-i-1] = a[n-i] + int(s[n-i] == \\'0\\');\\n      }\\n      long long ans = 0;\\n      for(int i=1; i<n-1; i++)\\n        if (s[i] == \\'1\\')\\n          ans += b[i]*a[i];\\n        else\\n          ans += (i-b[i])*(n-i-1-a[i]);\\n      return ans;\\n    }\\n```\\nTC: O(N)\\nSC: O(N)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\n    long long numberOfWays(string s) {\\n      long long n = s.length();\\n      vector<long long> b(n);\\n      vector<long long> a(n);\\n      b[0] = 0;\\n      a[n-1] = 0;\\n      for(int i=1; i<n; i++){\\n          b[i] = b[i-1] + int(s[i-1] == \\'0\\');\\n          a[n-i-1] = a[n-i] + int(s[n-i] == \\'0\\');\\n      }\\n      long long ans = 0;\\n      for(int i=1; i<n-1; i++)\\n        if (s[i] == \\'1\\')\\n          ans += b[i]*a[i];\\n        else\\n          ans += (i-b[i])*(n-i-1-a[i]);\\n      return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2212341,
                "title": "c-o-n-simple",
                "content": "a0 - No of 0\\'s so far\\na1 - No of 1\\'s so far\\na10 - No of 10\\'s so far \\na01 - No of 01\\'s so far\\nans is total 101\\'s or 010\\'s so far\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.length();\\n\\t\\tlong long a0 = 1 - (s[0] - \\'0\\'), a1 = 1 - a0, a01 = 0, a10 = 0;\\n\\t\\tlong long ans = 0;\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tif (s[i] == \\'0\\') {\\n\\t\\t\\t\\ta10 += a1;\\n\\t\\t\\t\\tans += a01;\\n\\t\\t\\t\\ta0++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ta01 += a0;\\n\\t\\t\\t\\tans += a10;\\n\\t\\t\\t\\ta1++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.length();\\n\\t\\tlong long a0 = 1 - (s[0] - \\'0\\'), a1 = 1 - a0, a01 = 0, a10 = 0;\\n\\t\\tlong long ans = 0;\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tif (s[i] == \\'0\\') {\\n\\t\\t\\t\\ta10 += a1;\\n\\t\\t\\t\\tans += a01;\\n\\t\\t\\t\\ta0++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ta01 += a0;\\n\\t\\t\\t\\tans += a10;\\n\\t\\t\\t\\ta1++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204058,
                "title": "2-solutions-generic-dp-solution-o-n-2-explained-and-greedy-o-n",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## LOGIC ##\\n        ## 1. can be put in other words as: Find the number of subsequences with string \"010\" or \"101\"\\n        ## 2. dp[0][0] is obvious, 1st row is just the count of t[0], \\n        ##    1st column is all 0\\'s (why ? how many subseqs of \"010\" can you find from string \"0\" (i.es[0]) )\\n        ## 3. other cells, if characters match, sum of previous match without both s[j],t[i] ie.[i-1][j-1] + previous match without s[j]\\n        \\n        ## stack trace\\n        ## \"001101\", \"010\"\\n        ## [[1, 2, 2, 2, 3, 3], \\n        ## [0, 0, 2, 4, 4, 7], \\n        ## [0, 0, 0, 0, 4, 4]]\\n        \\n        ## \"001101\", \"101\"\\n        ## [[0, 0, 1, 2, 2, 3], \\n        ## [0, 0, 0, 0, 2, 2], \\n        ## [0, 0, 0, 0, 0, 2]]\\n        \\n        ## TIME COMPLEXITY : O(NxN) ##\\n\\n        def get_subseq_cnt(s, t):\\n            dp = [ [0 for _ in range(len(s))] for _ in range(len(t)) ]\\n            dp[0][0] = 1 if (s[0] == t[0]) else 0\\n            for i in range(len(t)):\\n                for j in range(1, len(s)):\\n                    if i == 0:\\n                        dp[0][j] = dp[0][j-1]\\n                        dp[0][j] += 1 if  s[j] == t[i] else 0\\n                    else:\\n                        if s[j] == t[i]:\\n                            dp[i][j] = dp[i-1][j-1] + dp[i][j-1]\\n                        else:\\n                            dp[i][j] = dp[i][j-1]\\n            # print(dp)\\n            return dp[-1][-1]\\n        return get_subseq_cnt(s, \"010\") + get_subseq_cnt(s, \"101\")\\n        ## The above solution is not optimized, passes the test cases though. but good to know \\n        ## this dp solution, as it can be applied for any 2 strings\\n        \\n        # Optimized O(N) solution\\n        # Reference: https://leetcode.com/problems/number-of-ways-to-select-buildings/discuss/1907109/PythonDP-easy-to-understand\\n        dp = {\"0\": 0, \"1\": 0, \"01\": 0, \"10\": 0, \"010\": 0, \"101\": 0}\\n        for i in range(len(s)):\\n            if s[i] == \"0\":\\n                dp[\"0\"] += 1\\n                dp[\"10\"] += dp[\"1\"]\\n                dp[\"010\"] += dp[\"01\"]\\n            if s[i] == \"1\":\\n                dp[\"1\"] += 1\\n                dp[\"01\"] += dp[\"0\"]\\n                dp[\"101\"] += dp[\"10\"]\\n        return dp[\"010\"] + dp[\"101\"]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## LOGIC ##\\n        ## 1. can be put in other words as: Find the number of subsequences with string \"010\" or \"101\"\\n        ## 2. dp[0][0] is obvious, 1st row is just the count of t[0], \\n        ##    1st column is all 0\\'s (why ? how many subseqs of \"010\" can you find from string \"0\" (i.es[0]) )\\n        ## 3. other cells, if characters match, sum of previous match without both s[j],t[i] ie.[i-1][j-1] + previous match without s[j]\\n        \\n        ## stack trace\\n        ## \"001101\", \"010\"\\n        ## [[1, 2, 2, 2, 3, 3], \\n        ## [0, 0, 2, 4, 4, 7], \\n        ## [0, 0, 0, 0, 4, 4]]\\n        \\n        ## \"001101\", \"101\"\\n        ## [[0, 0, 1, 2, 2, 3], \\n        ## [0, 0, 0, 0, 2, 2], \\n        ## [0, 0, 0, 0, 0, 2]]\\n        \\n        ## TIME COMPLEXITY : O(NxN) ##\\n\\n        def get_subseq_cnt(s, t):\\n            dp = [ [0 for _ in range(len(s))] for _ in range(len(t)) ]\\n            dp[0][0] = 1 if (s[0] == t[0]) else 0\\n            for i in range(len(t)):\\n                for j in range(1, len(s)):\\n                    if i == 0:\\n                        dp[0][j] = dp[0][j-1]\\n                        dp[0][j] += 1 if  s[j] == t[i] else 0\\n                    else:\\n                        if s[j] == t[i]:\\n                            dp[i][j] = dp[i-1][j-1] + dp[i][j-1]\\n                        else:\\n                            dp[i][j] = dp[i][j-1]\\n            # print(dp)\\n            return dp[-1][-1]\\n        return get_subseq_cnt(s, \"010\") + get_subseq_cnt(s, \"101\")\\n        ## The above solution is not optimized, passes the test cases though. but good to know \\n        ## this dp solution, as it can be applied for any 2 strings\\n        \\n        # Optimized O(N) solution\\n        # Reference: https://leetcode.com/problems/number-of-ways-to-select-buildings/discuss/1907109/PythonDP-easy-to-understand\\n        dp = {\"0\": 0, \"1\": 0, \"01\": 0, \"10\": 0, \"010\": 0, \"101\": 0}\\n        for i in range(len(s)):\\n            if s[i] == \"0\":\\n                dp[\"0\"] += 1\\n                dp[\"10\"] += dp[\"1\"]\\n                dp[\"010\"] += dp[\"01\"]\\n            if s[i] == \"1\":\\n                dp[\"1\"] += 1\\n                dp[\"01\"] += dp[\"0\"]\\n                dp[\"101\"] += dp[\"10\"]\\n        return dp[\"010\"] + dp[\"101\"]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158709,
                "title": "puerly-logic",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        one,zero,one_zero ,zero_one,count=0,0,0,0,0\\n        for i in s:\\n            if i==\\'0\\':\\n                zero+=1\\n                one_zero+=one\\n                count+=zero_one\\n            else:\\n                one+=1\\n                zero_one+=zero\\n                count+=one_zero\\n        return count\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        one,zero,one_zero ,zero_one,count=0,0,0,0,0\\n        for i in s:\\n            if i==\\'0\\':\\n                zero+=1\\n                one_zero+=one\\n                count+=zero_one\\n            else:\\n                one+=1\\n                zero_one+=zero\\n                count+=one_zero\\n        return count\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2134762,
                "title": "easy-understanding-c-code-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[100005][3][4];\\n    long long helper(int idx,string &str,char prev,int len){\\n        \\n        if(len==3){\\n            return 1;\\n        }\\n        if(idx>=str.length()){\\n            return 0;\\n        }\\n        \\n        if(dp[idx][prev-\\'0\\'][len]!=-1){\\n            return dp[idx][prev-\\'0\\'][len];\\n        }\\n        long long not_take=0;\\n        long long take=0;\\n        if(prev!=str[idx]){\\n            take=helper(idx+1,str,str[idx],len+1);\\n        }\\n    \\n        not_take=helper(idx+1,str,prev,len);\\n        long long ans=take+not_take;\\n        dp[idx][prev-\\'0\\'][len]=ans;\\n        return ans;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,s,\\'2\\',0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100005][3][4];\\n    long long helper(int idx,string &str,char prev,int len){\\n        \\n        if(len==3){\\n            return 1;\\n        }\\n        if(idx>=str.length()){\\n            return 0;\\n        }\\n        \\n        if(dp[idx][prev-\\'0\\'][len]!=-1){\\n            return dp[idx][prev-\\'0\\'][len];\\n        }\\n        long long not_take=0;\\n        long long take=0;\\n        if(prev!=str[idx]){\\n            take=helper(idx+1,str,str[idx],len+1);\\n        }\\n    \\n        not_take=helper(idx+1,str,prev,len);\\n        long long ans=take+not_take;\\n        dp[idx][prev-\\'0\\'][len]=ans;\\n        return ans;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,s,\\'2\\',0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109061,
                "title": "easy-c-solution-with-full-explanation",
                "content": "Here we can have two types of patterns :- \"010\" and \"101\".\\n\\nSo, if we consider any s[i] as middle element, then we can find just the number of opponents towards left and right of it and the total no. of ways for that s[i] as middle element will be = no. of opponents in left * no. of opponents in right.\\n\\nSo, we run the loop from index 1 to index n-2 as left and right extreme can\\'t be taken as middle element of our two patterns.\\n\\nSo, suppose current character is \\'0\\' , then total ways for this character as middle element of our pattern = no. of 1\\'s in left of it * no. of 1\\'s in right of it.\\nAnd vice versa the case if \\'1\\' is current character.\\n\\nSo, to do this we can take a prefix array and suffix array which stores count of 1 and 0 towards left and right consecutively.\\n\\nSo, total count will be addition of all counts taken all characters as middle element one by one.\\n\\nCODE :- \\n\\n```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        \\n        vector<pair<ll,ll>> prefix(n);\\n        vector<pair<ll,ll>> suffix(n);\\n        \\n        prefix[0] = {0,0};\\n        suffix[n-1] = {0,0};\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i-1] == \\'0\\')\\n            {\\n                prefix[i] = {prefix[i-1].first + 1,prefix[i-1].second};\\n            }\\n            else\\n            {\\n                prefix[i] = {prefix[i-1].first,prefix[i-1].second + 1}; \\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i+1] == \\'0\\')\\n            {\\n                suffix[i] = {suffix[i+1].first + 1,suffix[i+1].second};\\n            }\\n            else\\n            {\\n                suffix[i] = {suffix[i+1].first,suffix[i+1].second + 1};\\n            }\\n        }\\n        \\n        ll res = 0;\\n        \\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(s[i] == \\'0\\')\\n            {\\n                res += prefix[i].second * suffix[i].second;\\n            }\\n            else\\n            {\\n                res += prefix[i].first * suffix[i].first;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        \\n        vector<pair<ll,ll>> prefix(n);\\n        vector<pair<ll,ll>> suffix(n);\\n        \\n        prefix[0] = {0,0};\\n        suffix[n-1] = {0,0};\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i-1] == \\'0\\')\\n            {\\n                prefix[i] = {prefix[i-1].first + 1,prefix[i-1].second};\\n            }\\n            else\\n            {\\n                prefix[i] = {prefix[i-1].first,prefix[i-1].second + 1}; \\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i+1] == \\'0\\')\\n            {\\n                suffix[i] = {suffix[i+1].first + 1,suffix[i+1].second};\\n            }\\n            else\\n            {\\n                suffix[i] = {suffix[i+1].first,suffix[i+1].second + 1};\\n            }\\n        }\\n        \\n        ll res = 0;\\n        \\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(s[i] == \\'0\\')\\n            {\\n                res += prefix[i].second * suffix[i].second;\\n            }\\n            else\\n            {\\n                res += prefix[i].first * suffix[i].first;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097331,
                "title": "counting-subsequences-of-010-and-101-in-the-string",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n  long long dp[100000][3];\\n  \\n  long long count(string &s1,string &s,int n,int m){\\n    if(n==0|| (m==0&&n==0)){\\n      return 1;\\n    }\\n    if(m==0) return 0;\\n    if(dp[m-1][n-1]!=-1) return dp[m-1][n-1];\\n    if(s1[n-1]==s[m-1]){\\n      return dp[m-1][n-1]=count(s1,s,n-1,m-1) + count(s1,s,n,m-1);\\n    }\\n    return dp[m-1][n-1]=count(s1,s,n,m-1);\\n  }\\n  \\n    long long numberOfWays(string s) {\\n      string s1=\"101\",s2=\"010\";\\n      int x=3,y=s.size();\\n      for(int i=0;i<y;i++){\\n        for(int j=0;j<3;j++){\\n          dp[i][j]=-1;\\n        }\\n      }\\n      long long a1=count(s1,s,x,y);\\n      for(int i=0;i<y;i++){\\n        for(int j=0;j<3;j++){\\n          dp[i][j]=-1;\\n        }\\n      }\\n      long long a2=count(s2,s,x,y);\\n      return a2+a1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n  long long dp[100000][3];\\n  \\n  long long count(string &s1,string &s,int n,int m){\\n    if(n==0|| (m==0&&n==0)){\\n      return 1;\\n    }\\n    if(m==0) return 0;\\n    if(dp[m-1][n-1]!=-1) return dp[m-1][n-1];\\n    if(s1[n-1]==s[m-1]){\\n      return dp[m-1][n-1]=count(s1,s,n-1,m-1) + count(s1,s,n,m-1);\\n    }\\n    return dp[m-1][n-1]=count(s1,s,n,m-1);\\n  }\\n  \\n    long long numberOfWays(string s) {\\n      string s1=\"101\",s2=\"010\";\\n      int x=3,y=s.size();\\n      for(int i=0;i<y;i++){\\n        for(int j=0;j<3;j++){\\n          dp[i][j]=-1;\\n        }\\n      }\\n      long long a1=count(s1,s,x,y);\\n      for(int i=0;i<y;i++){\\n        for(int j=0;j<3;j++){\\n          dp[i][j]=-1;\\n        }\\n      }\\n      long long a2=count(s2,s,x,y);\\n      return a2+a1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096733,
                "title": "easiest-cpp-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long int c0 = 0, c1 = 0, c01 = 0, c10 = 0, c101 = 0, c010 = 0;\\n        for(char &c: s)\\n        {\\n            if(c==\\'0\\')\\n            {\\n                c10 += c1;\\n                c010 += c01;\\n                c0++;\\n            }\\n            else\\n            {\\n                c01 += c0;\\n                c101 += c10;\\n                c1++;\\n            }\\n        }\\n        return c101 + c010;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long int c0 = 0, c1 = 0, c01 = 0, c10 = 0, c101 = 0, c010 = 0;\\n        for(char &c: s)\\n        {\\n            if(c==\\'0\\')\\n            {\\n                c10 += c1;\\n                c010 += c01;\\n                c0++;\\n            }\\n            else\\n            {\\n                c01 += c0;\\n                c101 += c10;\\n                c1++;\\n            }\\n        }\\n        return c101 + c010;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057425,
                "title": "c-easy-recursion-memoization-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long dp[100000][3][3];\\n    \\n    long long giveAns(string &s,int start,int count,char prev){\\n        if(count==3)  return 1;\\n        if(start>=s.length()) return 0;\\n        if(dp[start][count][prev-\\'0\\']!=-1) return dp[start][count][prev-\\'0\\'];\\n        if(s[start]==prev) return dp[start][count][prev-\\'0\\']=giveAns(s,start+1,count,prev);\\n        return dp[start][count][prev-\\'0\\']=giveAns(s,start+1,count+1,s[start])+giveAns(s,start+1,count,prev);\\n    }\\n    \\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return giveAns(s,0,0,\\'2\\');\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    long long dp[100000][3][3];\\n    \\n    long long giveAns(string &s,int start,int count,char prev){\\n        if(count==3)  return 1;\\n        if(start>=s.length()) return 0;\\n        if(dp[start][count][prev-\\'0\\']!=-1) return dp[start][count][prev-\\'0\\'];\\n        if(s[start]==prev) return dp[start][count][prev-\\'0\\']=giveAns(s,start+1,count,prev);\\n        return dp[start][count][prev-\\'0\\']=giveAns(s,start+1,count+1,s[start])+giveAns(s,start+1,count,prev);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2050520,
                "title": "c-easy-solution-well-commented-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    // we have to find only 010 and 101 these two pairs count\\n    // in this question we fix the element in the midlle and find left and right count for the\\n    //example if middle element is 0 we have to find count of 1 in the left and int right and subtract them for finding total count of 101\\n    //same if we fix 1 in the middle we have to find the count of 0 in the left and right\\n    long long numberOfWays(string s) {\\n        int n=s.size();\\n        vector<long long>left0(n,0),left1(n,0),right0(n,0),right1(n,0);\\n        long long c1=0;long long c2=0;\\n        //for finding left1 and right 1\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                c1++;\\n            }\\n            left1[i]=c1;\\n            if(s[n-i-1]==\\'1\\'){\\n                //checking from the end\\n                c2++;\\n            }\\n            right1[n-i-1]=c2;\\n            \\n        }\\n        c1=0;\\n        c2=0;\\n        //for finding left0 and right0\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                //checking from the start\\n                c1++;\\n            }\\n            left0[i]=c1;\\n            //checking from the end\\n            if(s[n-i-1]==\\'0\\'){\\n                c2++;\\n            }\\n            right0[n-i-1]=c2;\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                ans+=left1[i]*right1[i];\\n            }\\n            else if(s[i]==\\'1\\'){\\n                ans+=left0[i]*right0[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // we have to find only 010 and 101 these two pairs count\\n    // in this question we fix the element in the midlle and find left and right count for the\\n    //example if middle element is 0 we have to find count of 1 in the left and int right and subtract them for finding total count of 101\\n    //same if we fix 1 in the middle we have to find the count of 0 in the left and right\\n    long long numberOfWays(string s) {\\n        int n=s.size();\\n        vector<long long>left0(n,0),left1(n,0),right0(n,0),right1(n,0);\\n        long long c1=0;long long c2=0;\\n        //for finding left1 and right 1\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                c1++;\\n            }\\n            left1[i]=c1;\\n            if(s[n-i-1]==\\'1\\'){\\n                //checking from the end\\n                c2++;\\n            }\\n            right1[n-i-1]=c2;\\n            \\n        }\\n        c1=0;\\n        c2=0;\\n        //for finding left0 and right0\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                //checking from the start\\n                c1++;\\n            }\\n            left0[i]=c1;\\n            //checking from the end\\n            if(s[n-i-1]==\\'0\\'){\\n                c2++;\\n            }\\n            right0[n-i-1]=c2;\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                ans+=left1[i]*right1[i];\\n            }\\n            else if(s[i]==\\'1\\'){\\n                ans+=left0[i]*right0[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981061,
                "title": "easy-understandable-c-solution-with-detailed-explanation",
                "content": "Explaination:\\nFor an index i, If the character at the ith index is 1 then we will try to find number of \\'01\\' on the right side of that index, and If the character at the inde i is \\'0\\', then we will find number of \\'10\\' on the right side of that index. In order to find \\'10\\' we can find number of zeroes on the right of that index, similarly it can be done to find \\'01\\' as well. We can use suffix array to calculate the required combinations.\\n\\nCode:\\n```\\n long long numberOfWays(string s) {\\n        int n = s.length();\\n        vector<long long> zo(n),oz(n);\\n        int cnt=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == \\'1\\')oz[i] = cnt;\\n            if(s[i] == \\'0\\')cnt++;\\n        }\\n        cnt=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == \\'0\\')zo[i] = cnt;\\n            if(s[i] == \\'1\\')cnt++;\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            oz[i] += oz[i+1];\\n            zo[i] += zo[i+1];\\n        }\\n        long long res = 0LL;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                res+=zo[i];\\n            }\\n            else{\\n                res+=oz[i];\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n long long numberOfWays(string s) {\\n        int n = s.length();\\n        vector<long long> zo(n),oz(n);\\n        int cnt=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == \\'1\\')oz[i] = cnt;\\n            if(s[i] == \\'0\\')cnt++;\\n        }\\n        cnt=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == \\'0\\')zo[i] = cnt;\\n            if(s[i] == \\'1\\')cnt++;\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            oz[i] += oz[i+1];\\n            zo[i] += zo[i+1];\\n        }\\n        long long res = 0LL;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                res+=zo[i];\\n            }\\n            else{\\n                res+=oz[i];\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976277,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long z = 0, o = 0, zo = 0, oz = 0, zoz = 0, ozo = 0;\\n        for (char c: s.toCharArray()) {\\n            if (c == \\'0\\') {\\n                zoz += zo;\\n                oz += o;\\n                z++;\\n            }\\n            else {\\n                ozo += oz;\\n                zo += z;\\n                o++;\\n            }\\n        }\\n        return zoz + ozo;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long z = 0, o = 0, zo = 0, oz = 0, zoz = 0, ozo = 0;\\n        for (char c: s.toCharArray()) {\\n            if (c == \\'0\\') {\\n                zoz += zo;\\n                oz += o;\\n                z++;\\n            }\\n            else {\\n                ozo += oz;\\n                zo += z;\\n                o++;\\n            }\\n        }\\n        return zoz + ozo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960791,
                "title": "c-solution-with-explanation-easy-to-understand",
                "content": "**in this approach I am traversing the whole nums vector and doing\\nI.  ans+=(num of left \\'0\\')x(num of right \\'0\\') [if current nums[i]==1][case : \"010\"]\\nII. ans+=(num of left \\'1\\')x(num of right \\'1\\') [if current nums[i]==0][case : \"101\"]**\\n\\n\\n------------------------------------------------------------------------------------------------\\n\\n\\n**I have made vectors of numbers of left zero,right zero,left one,right one using prefix sum to make overall time complexity O(n)**\\n\\n-------------------------------------------------------------------\\n\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n=s.size();\\n        \\n        vector<int> l0(n,0),l1(n,0),r0(n,0),r1(n,0);\\n        \\n        int c=0,c2=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                c++;\\n            }\\n            l0[i]=c;\\n            if(s[n-i-1]==\\'0\\')\\n            {\\n                c2++;\\n            }\\n            r0[n-i-1]=c2;\\n        }\\n        \\n        c=0;\\n        c2=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                c++;\\n            }\\n            l1[i]=c;\\n            if(s[n-i-1]==\\'1\\')\\n            {\\n                c2++;\\n            }\\n            r1[n-i-1]=c2;\\n        }\\n        \\n        long long ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n                ans+=l0[i]*1LL*r0[i];\\n            else\\n                ans+=l1[i]*1LL*r1[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n=s.size();\\n        \\n        vector<int> l0(n,0),l1(n,0),r0(n,0),r1(n,0);\\n        \\n        int c=0,c2=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                c++;\\n            }\\n            l0[i]=c;\\n            if(s[n-i-1]==\\'0\\')\\n            {\\n                c2++;\\n            }\\n            r0[n-i-1]=c2;\\n        }\\n        \\n        c=0;\\n        c2=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                c++;\\n            }\\n            l1[i]=c;\\n            if(s[n-i-1]==\\'1\\')\\n            {\\n                c2++;\\n            }\\n            r1[n-i-1]=c2;\\n        }\\n        \\n        long long ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n                ans+=l0[i]*1LL*r0[i];\\n            else\\n                ans+=l1[i]*1LL*r1[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943879,
                "title": "c-short-code-t-o-n-s-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long zero1 = 0, zero2 = 0, zero3 = 0, one1 = 0, one2 = 0, one3 = 0;\\n        for (char c : s) {\\n            if (c == \\'0\\') {\\n                zero1++;\\n                zero2 += one1;\\n                zero3 += one2;\\n            } else {\\n                one1++;\\n                one2 += zero1;\\n                one3 += zero2;\\n            }\\n        }\\n        \\n        return zero3 + one3;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long zero1 = 0, zero2 = 0, zero3 = 0, one1 = 0, one2 = 0, one3 = 0;\\n        for (char c : s) {\\n            if (c == \\'0\\') {\\n                zero1++;\\n                zero2 += one1;\\n                zero3 += one2;\\n            } else {\\n                one1++;\\n                one2 += zero1;\\n                one3 += zero2;\\n            }\\n        }\\n        \\n        return zero3 + one3;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930855,
                "title": "python-o-n-time",
                "content": "# class Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        zeros = ones = 0\\n        ans = [0] * len(s)\\n        \\n        for i in range(len(s)):\\n            if s[i] == \\'1\\':\\n                ans[i] = zeros\\n                ones += 1\\n            else:\\n                ans[i] = ones\\n                zeros += 1\\n        zeros = ones = 0\\n        \\n        for i in range(len(s)-1,-1,-1):\\n            if s[i] == \\'1\\':\\n                ans[i] *= zeros\\n                ones += 1\\n            else:\\n                ans[i] *= ones\\n                zeros += 1\\n        \\n        return sum(ans)\\n\\n# class Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        dp = {\\'0\\':0,\\'1\\':0,\\'01\\':0,\\'10\\':0,\\'010\\':0,\\'101\\':0}\\n        \\n        for i in s:\\n            dp[i] += 1\\n            if i == \\'0\\':\\n                dp[\\'10\\'] += dp[\\'1\\']\\n                dp[\\'010\\'] += dp[\\'01\\']\\n            else:\\n                dp[\\'01\\'] += dp[\\'0\\']\\n                dp[\\'101\\'] += dp[\\'10\\']\\n        \\n        return dp[\\'010\\'] + dp[\\'101\\']\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        zeros = ones = 0\\n        ans = [0] * len(s)\\n        \\n        for i in range(len(s)):\\n            if s[i] == \\'1\\':\\n                ans[i] = zeros\\n                ones += 1\\n            else:\\n                ans[i] = ones\\n                zeros += 1\\n        zeros = ones = 0\\n        \\n        for i in range(len(s)-1,-1,-1):\\n            if s[i] == \\'1\\':\\n                ans[i] *= zeros\\n                ones += 1\\n            else:\\n                ans[i] *= ones\\n                zeros += 1\\n        \\n        return sum(ans)\\n\\n# class Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        dp = {\\'0\\':0,\\'1\\':0,\\'01\\':0,\\'10\\':0,\\'010\\':0,\\'101\\':0}",
                "codeTag": "Java"
            },
            {
                "id": 1927176,
                "title": "c-dp-o-n-using-distinct-subsequence-count-of-101-and-010-in-string",
                "content": "class Solution {\\npublic:\\n    \\n    // O(n) solution because str size is always 3\\n    // this function counts no of distinct subsequence of str in s uning dp approach\\n    long long count(string s,string str){\\n        long long m = s.size(), n = str.size();\\n        long long dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        for(long long i = 0;i<=m;i++) dp[i][0] = 1;\\n        for(long long i = 1;i<=m;i++){\\n            for(long long j = 1;j<=n;j++){\\n                dp[i][j] = dp[i-1][j]+((s[i-1] == str[j-1])?dp[i-1][j-1]:0);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n    \\n    long long numberOfWays(string s) {\\n        string str1 = \"010\";\\n        string str2 = \"101\";\\n        // counting distinct subsequence\\n        long long res = count(s,str1)+count(s,str2);\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    // O(n) solution because str size is always 3\\n    // this function counts no of distinct subsequence of str in s uning dp approach\\n    long long count(string s,string str){\\n        long long m = s.size(), n = str.size();\\n        long long dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        for(long long i = 0;i<=m;i++) dp[i][0] = 1;\\n        for(long long i = 1;i<=m;i++){\\n            for(long long j = 1;j<=n;j++){\\n                dp[i][j] = dp[i-1][j]+((s[i-1] == str[j-1])?dp[i-1][j-1]:0);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1925936,
                "title": "java-greedy-prefix-sum-time-on-space-on",
                "content": "Runtime: 40 ms, faster than 78.48% of Java online submissions for Number of Ways to Select Buildings.\\nMemory Usage: 43.5 MB, less than 91.81% of Java online submissions for Number of Ways to Select Buildings.\\n```\\nclass Solution {\\n  public long numberOfWays(String s) {\\n    long ans = 0, L[] = new long[s.length()], z = 0;  //L - for count of all zeros before current position, z - total zeros\\n    \\n    for(int i = 0; i != s.length(); i++)              //fill L and count z\\n      L[i] = s.charAt(i) == \\'0\\' ? ++z : z;\\n    \\n    for(int i = 1; i != s.length() - 1; i++)          //all left numbers * all right the same numbers for current position  \\n      ans += s.charAt(i) == \\'1\\' ? L[i-1] * (z - L[i-1]) : (i - L[i-1]) * (s.length() - i - 1 - z + L[i]);\\n     \\n    return ans;  \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long numberOfWays(String s) {\\n    long ans = 0, L[] = new long[s.length()], z = 0;  //L - for count of all zeros before current position, z - total zeros\\n    \\n    for(int i = 0; i != s.length(); i++)              //fill L and count z\\n      L[i] = s.charAt(i) == \\'0\\' ? ++z : z;\\n    \\n    for(int i = 1; i != s.length() - 1; i++)          //all left numbers * all right the same numbers for current position  \\n      ans += s.charAt(i) == \\'1\\' ? L[i-1] * (z - L[i-1]) : (i - L[i-1]) * (s.length() - i - 1 - z + L[i]);\\n     \\n    return ans;  \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918286,
                "title": "super-easy-understanding-c",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) \\n    {\\n        ll first_zero=0,first_one=0,second_zero=0,second_one=0;\\n        ll ans=0;\\n        for(auto &x:s)\\n        {\\n            if(x==\\'0\\')\\n            {\\n                first_zero++;\\n                second_zero+=first_one;\\n                ans+=second_one;\\n            }else if(x==\\'1\\')\\n            {\\n                first_one++;\\n                second_one+=first_zero;\\n                ans+=second_zero;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) \\n    {\\n        ll first_zero=0,first_one=0,second_zero=0,second_one=0;\\n        ll ans=0;\\n        for(auto &x:s)\\n        {\\n            if(x==\\'0\\')\\n            {\\n                first_zero++;\\n                second_zero+=first_one;\\n                ans+=second_one;\\n            }else if(x==\\'1\\')\\n            {\\n                first_one++;\\n                second_one+=first_zero;\\n                ans+=second_zero;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917670,
                "title": "c-prefix-and-suffix-array-o-n",
                "content": "```\\nlong long numberOfWays(string s) {\\n        int n = s.length();\\n        vector<int> left_zero(n, 0), right_zero(n, 0), left_one(n, 0), right_one(n, 0);\\n        left_zero.push_back(0);\\n        left_one.push_back(1);\\n        for(int i = 1; i < s.length(); ++i){\\n            if(s[i-1] == \\'0\\'){\\n                left_zero[i] = 1 + left_zero[i-1];\\n                left_one[i] = left_one[i-1];\\n            }\\n            else{\\n                left_one[i] = 1 + left_one[i-1];\\n                left_zero[i] = left_zero[i-1];\\n            }\\n        }\\n        right_zero.push_back(0);\\n        right_one.push_back(1);\\n        for(int i = s.length() - 2; i >= 0; --i){\\n            if(s[i+1] == \\'0\\'){\\n                right_zero[i] = 1 + right_zero[i+1];\\n                right_one[i] = right_one[i+1];\\n            }\\n            else{\\n                right_one[i] = 1 + right_one[i+1];\\n                right_zero[i] = right_zero[i+1];\\n            }\\n        }\\n        long long ans = 0;\\n        for(int i = 1; i < s.length() - 1; ++i){\\n            if(s[i] == \\'0\\'){\\n                if(left_one[i] != 0 && right_one[i] != 0)\\n                    // ans += max(left_one[i], right_one[i]);\\n                    ans += left_one[i]*right_one[i];\\n            }\\n            else{\\n                if(left_zero[i] != 0 && right_zero[i] != 0)\\n                    // ans += max(left_zero[i], right_zero[i]);\\n                    ans += left_zero[i]*right_zero[i];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nlong long numberOfWays(string s) {\\n        int n = s.length();\\n        vector<int> left_zero(n, 0), right_zero(n, 0), left_one(n, 0), right_one(n, 0);\\n        left_zero.push_back(0);\\n        left_one.push_back(1);\\n        for(int i = 1; i < s.length(); ++i){\\n            if(s[i-1] == \\'0\\'){\\n                left_zero[i] = 1 + left_zero[i-1];\\n                left_one[i] = left_one[i-1];\\n            }\\n            else{\\n                left_one[i] = 1 + left_one[i-1];\\n                left_zero[i] = left_zero[i-1];\\n            }\\n        }\\n        right_zero.push_back(0);\\n        right_one.push_back(1);\\n        for(int i = s.length() - 2; i >= 0; --i){\\n            if(s[i+1] == \\'0\\'){\\n                right_zero[i] = 1 + right_zero[i+1];\\n                right_one[i] = right_one[i+1];\\n            }\\n            else{\\n                right_one[i] = 1 + right_one[i+1];\\n                right_zero[i] = right_zero[i+1];\\n            }\\n        }\\n        long long ans = 0;\\n        for(int i = 1; i < s.length() - 1; ++i){\\n            if(s[i] == \\'0\\'){\\n                if(left_one[i] != 0 && right_one[i] != 0)\\n                    // ans += max(left_one[i], right_one[i]);\\n                    ans += left_one[i]*right_one[i];\\n            }\\n            else{\\n                if(left_zero[i] != 0 && right_zero[i] != 0)\\n                    // ans += max(left_zero[i], right_zero[i]);\\n                    ans += left_zero[i]*right_zero[i];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1914665,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        \\n        int n = s.size();\\n        long long ans = 0;\\n        \\n        vector<int> leftOnes(n,0), rightOnes(n,0), leftZeros(n,0), rightZeros(n,0);\\n        \\n        int zeros=0, ones=0;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            zeros+= s[i]==\\'0\\';\\n            ones+= s[i] == \\'1\\';\\n            \\n            leftZeros[i]=zeros;\\n            leftOnes[i]=ones;\\n            \\n        }\\n        \\n        zeros=ones=0;\\n        \\n        for(int i=n-1; i>=0; i--){\\n            \\n            zeros+= s[i]==\\'0\\';\\n            ones+= s[i]==\\'1\\';\\n            \\n            rightOnes[i]=ones;\\n            rightZeros[i]=zeros;\\n            \\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            if(s[i] == \\'0\\') ans+= leftOnes[i]*rightOnes[i];\\n            else ans+= leftZeros[i]*rightZeros[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        \\n        int n = s.size();\\n        long long ans = 0;\\n        \\n        vector<int> leftOnes(n,0), rightOnes(n,0), leftZeros(n,0), rightZeros(n,0);\\n        \\n        int zeros=0, ones=0;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            zeros+= s[i]==\\'0\\';\\n            ones+= s[i] == \\'1\\';\\n            \\n            leftZeros[i]=zeros;\\n            leftOnes[i]=ones;\\n            \\n        }\\n        \\n        zeros=ones=0;\\n        \\n        for(int i=n-1; i>=0; i--){\\n            \\n            zeros+= s[i]==\\'0\\';\\n            ones+= s[i]==\\'1\\';\\n            \\n            rightOnes[i]=ones;\\n            rightZeros[i]=zeros;\\n            \\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            if(s[i] == \\'0\\') ans+= leftOnes[i]*rightOnes[i];\\n            else ans+= leftZeros[i]*rightZeros[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912744,
                "title": "c-count-zero-and-one-o-n-time-o-1-space",
                "content": "\\ttypedef long long ll;\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long numberOfWays(string s) {\\n\\t\\t\\tll res = 0,cnt1 = 0,cnt0 = 0;\\n\\t\\t\\tfor(auto x:s) x==\\'1\\'?cnt1++:cnt0++;\\n\\n\\t\\t\\tfor(int i=0,one=0,zero=0;i<s.length();i++){\\n\\t\\t\\t\\tif(s[i]==\\'1\\'){\\n\\t\\t\\t\\t\\tone++;  \\n\\t\\t\\t\\t\\tres+= zero*(cnt0-zero);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tzero++;\\n\\t\\t\\t\\t\\tres+= one*(cnt1-one);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long numberOfWays(string s) {\\n\\t\\t\\tll res = 0,cnt1 = 0,cnt0 = 0;\\n\\t\\t\\tfor(auto x:s) x==\\'1\\'?cnt1++:cnt0++;\\n\\n\\t\\t\\tfor(int i=0,one=0,zero=0;i<s.length();i++){\\n\\t\\t\\t\\tif(s[i]==\\'1\\'){\\n\\t\\t\\t\\t\\tone++;  \\n\\t\\t\\t\\t\\tres+= zero*(cnt0-zero);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1910711,
                "title": "learn-how-not-to-complicate-a-simple-question-memoization-dp",
                "content": "```\\nclass Solution {\\n\\n    HashMap<String,Long> map;\\n    \\n    public long numberOfWays(String s) {\\n        int n = s.length();\\n        map = new HashMap<>();\\n        return helper(s,0,\\'2\\',new StringBuilder());\\n    }\\n    \\n    public long helper(String str, int i, char prev, StringBuilder sb){\\n        \\n        if(i == str.length()){\\n            if(sb.length() == 3)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        \\n        if(sb.length() == 3){\\n            return 1;\\n        }\\n        \\n        String str1 = new String(Integer.toString(i)+\" \"+(prev+\"\")+\" \"+sb.toString());\\n        \\n        if(map.containsKey(str1))\\n            return map.get(str1);\\n        \\n        long left = 0;\\n        \\n        for(int j=i; j<str.length(); j++){\\n            \\n            if(str.charAt(j) == prev)\\n                continue;\\n            \\n            else{\\n                \\n                sb.append(str.charAt(j));\\n                \\n                String str2 = new String(Integer.toString(j)+\" \"+(str.charAt(j)+\"\")+\" \"+sb.toString());\\n                \\n                if(map.containsKey(str2))\\n                    left += map.get(str2);\\n                else{\\n                    long intd = helper(str,j+1,str.charAt(j),sb);\\n                    map.put(str2,intd);             \\n                    left += intd;\\n                }\\n                \\n                sb.deleteCharAt(sb.length()-1);\\n            }\\n        }\\n        \\n        map.put(str1,left);\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    HashMap<String,Long> map;\\n    \\n    public long numberOfWays(String s) {\\n        int n = s.length();\\n        map = new HashMap<>();\\n        return helper(s,0,\\'2\\',new StringBuilder());\\n    }\\n    \\n    public long helper(String str, int i, char prev, StringBuilder sb){\\n        \\n        if(i == str.length()){\\n            if(sb.length() == 3)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        \\n        if(sb.length() == 3){\\n            return 1;\\n        }\\n        \\n        String str1 = new String(Integer.toString(i)+\" \"+(prev+\"\")+\" \"+sb.toString());\\n        \\n        if(map.containsKey(str1))\\n            return map.get(str1);\\n        \\n        long left = 0;\\n        \\n        for(int j=i; j<str.length(); j++){\\n            \\n            if(str.charAt(j) == prev)\\n                continue;\\n            \\n            else{\\n                \\n                sb.append(str.charAt(j));\\n                \\n                String str2 = new String(Integer.toString(j)+\" \"+(str.charAt(j)+\"\")+\" \"+sb.toString());\\n                \\n                if(map.containsKey(str2))\\n                    left += map.get(str2);\\n                else{\\n                    long intd = helper(str,j+1,str.charAt(j),sb);\\n                    map.put(str2,intd);             \\n                    left += intd;\\n                }\\n                \\n                sb.deleteCharAt(sb.length()-1);\\n            }\\n        }\\n        \\n        map.put(str1,left);\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910430,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(N)***\\n\\n```\\nlong long numberOfWays(string str) {\\n        \\n        int n = str.size();\\n        \\n        vector<int> zero(n + 1, 0);\\n        \\n        vector<int> one(n + 1, 0);\\n        \\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(str[i - 1] == \\'0\\')\\n            {\\n                zero[i] = 1 + zero[i - 1];\\n            }\\n            else\\n            {\\n                zero[i] = zero[i - 1];\\n            }\\n        }\\n        \\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(str[i - 1] == \\'1\\')\\n            {\\n                one[i] = 1 + one[i - 1];\\n            }\\n            \\n            else\\n            {\\n                one[i] = one[i - 1];\\n            }\\n        }\\n        \\n        long long count_ways = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int left = 0;\\n            \\n            int right = 0;\\n            \\n            if(str[i] == \\'0\\')\\n            {\\n                left = one[i];\\n                \\n                right = one[n] - one[i + 1];\\n            }\\n            \\n            else\\n            {\\n                left = zero[i];\\n                \\n                right = zero[n] - zero[i + 1];\\n            }\\n            \\n            count_ways += (long long) left * (long long) right;\\n        }\\n        \\n        return count_ways;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nlong long numberOfWays(string str) {\\n        \\n        int n = str.size();\\n        \\n        vector<int> zero(n + 1, 0);\\n        \\n        vector<int> one(n + 1, 0);\\n        \\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(str[i - 1] == \\'0\\')\\n            {\\n                zero[i] = 1 + zero[i - 1];\\n            }\\n            else\\n            {\\n                zero[i] = zero[i - 1];\\n            }\\n        }\\n        \\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(str[i - 1] == \\'1\\')\\n            {\\n                one[i] = 1 + one[i - 1];\\n            }\\n            \\n            else\\n            {\\n                one[i] = one[i - 1];\\n            }\\n        }\\n        \\n        long long count_ways = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int left = 0;\\n            \\n            int right = 0;\\n            \\n            if(str[i] == \\'0\\')\\n            {\\n                left = one[i];\\n                \\n                right = one[n] - one[i + 1];\\n            }\\n            \\n            else\\n            {\\n                left = zero[i];\\n                \\n                right = zero[n] - zero[i + 1];\\n            }\\n            \\n            count_ways += (long long) left * (long long) right;\\n        }\\n        \\n        return count_ways;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909631,
                "title": "python-using-principle-of-counting",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        zeroes, ones = s.count(\\'0\\') , s.count(\\'1\\')\\n        local0, local1, ans = 0, 0, 0\\n        for i in s:\\n            if i == \\'0\\':\\n                zeroes -= 1\\n                local0 += 1\\n                ans += local1 * ones  #choose any one of previous ones and any one of the next ones\\n            else:\\n                ones -= 1\\n                local1 += 1\\n                ans += local0 * zeroes #choose any one of previous zeroes and any one of the next zeroes\\n        return ans\\n                \\n          ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        zeroes, ones = s.count(\\'0\\') , s.count(\\'1\\')\\n        local0, local1, ans = 0, 0, 0\\n        for i in s:\\n            if i == \\'0\\':\\n                zeroes -= 1\\n                local0 += 1\\n                ans += local1 * ones  #choose any one of previous ones and any one of the next ones\\n            else:\\n                ones -= 1\\n                local1 += 1\\n                ans += local0 * zeroes #choose any one of previous zeroes and any one of the next zeroes\\n        return ans\\n                \\n          ```",
                "codeTag": "Java"
            },
            {
                "id": 1909545,
                "title": "beginner-friendly-recursive-solutions-and-o-n-optimized-solution",
                "content": "Recursive solution in python (**Will give TLE,Only for learning purpose**)\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.ways=0\\n    def numberOfWays(self, s: str) -> int:\\n        self.ways=0\\n        slen=len(s)\\n        def nways(index,prev,length,slen,s):\\n            if(index==slen):\\n                return 0\\n            if(s[index]!=prev):\\n                if(length==2):\\n                    self.ways+=1\\n                    nways(index+1,prev,length,slen,s)\\n                else:\\n                    nways(index+1,s[index],length+1,slen,s)\\n                    nways(index+1,prev,length,slen,s)\\n            else:\\n                nways(index+1,prev,length,slen,s)\\n        nways(0,\\'-1\\',0,slen,s)\\n        return self.ways        \\n```\\n\\nO(N) Optmized Solution!!! (JAVA)\\n```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        int slen=s.length();\\n        long ways=0;\\n        long[] lcount= new long[slen];\\n        long[] rcount = new long[slen];\\n        int zerocount=0,onecount=0;\\n        for(int i=0;i<slen;i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                zerocount++;\\n                lcount[i]=onecount;\\n            }\\n            else{\\n                onecount++;\\n                lcount[i]=zerocount;\\n            }\\n        }\\n        zerocount=0;\\n        onecount=0;\\n        for(int i=slen-1;i>=0;i--){\\n            if(s.charAt(i)==\\'0\\'){\\n                zerocount++;\\n                rcount[i]=onecount;\\n            }\\n            else{\\n                onecount++;\\n                rcount[i]=zerocount;\\n            }\\n        }\\n        for(int i=0;i<slen;i++){\\n            ways+=lcount[i]*rcount[i];\\n        }\\n        return ways;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.ways=0\\n    def numberOfWays(self, s: str) -> int:\\n        self.ways=0\\n        slen=len(s)\\n        def nways(index,prev,length,slen,s):\\n            if(index==slen):\\n                return 0\\n            if(s[index]!=prev):\\n                if(length==2):\\n                    self.ways+=1\\n                    nways(index+1,prev,length,slen,s)\\n                else:\\n                    nways(index+1,s[index],length+1,slen,s)\\n                    nways(index+1,prev,length,slen,s)\\n            else:\\n                nways(index+1,prev,length,slen,s)\\n        nways(0,\\'-1\\',0,slen,s)\\n        return self.ways        \\n```\n```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        int slen=s.length();\\n        long ways=0;\\n        long[] lcount= new long[slen];\\n        long[] rcount = new long[slen];\\n        int zerocount=0,onecount=0;\\n        for(int i=0;i<slen;i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                zerocount++;\\n                lcount[i]=onecount;\\n            }\\n            else{\\n                onecount++;\\n                lcount[i]=zerocount;\\n            }\\n        }\\n        zerocount=0;\\n        onecount=0;\\n        for(int i=slen-1;i>=0;i--){\\n            if(s.charAt(i)==\\'0\\'){\\n                zerocount++;\\n                rcount[i]=onecount;\\n            }\\n            else{\\n                onecount++;\\n                rcount[i]=zerocount;\\n            }\\n        }\\n        for(int i=0;i<slen;i++){\\n            ways+=lcount[i]*rcount[i];\\n        }\\n        return ways;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909430,
                "title": "easy-approach-by-counting-the-1s-and-0s-before-each-index",
                "content": "So basically we can only have 2 combinations 010 and 101.\\nSo for each index if we have a 0 we can just check the no. of 1s present before it and number of 1s present after it.\\nWe can take these 2 numbers and multiply, that will be the number of valid selections using that index. \\nWe do the same if the current index is 1 , by multiplying the no of 0s before and after the index.\\n\\nThe sum of the calculated values for all the indexes will be our answer i.e the total no. of comnbinations.\\nWe can get the no. of 0s or 1s before and after an index in O(1) by storing the 0s and 1s before every index in  an array and by having the total no. of 0s and 1s present in our string.\\n0s and 1s before every index we will store.\\n0s and 1s after every index can be extracted by total0s- (0s before the index)\\nsame for 1s.\\n\\n```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        int num0sBefore[]=new int[s.length()];\\n        int num1sBefore[]=new int[s.length()];\\n       long total1s=0;\\n       long total0s=0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'0\\'){\\n                total0s++;\\n                if(i==s.length()-1)\\n                    break;\\n                num0sBefore[i+1]++;\\n                \\n                \\n            }\\n            else\\n            {\\n                total1s++;\\n                 if(i==s.length()-1)\\n                    break;\\n                num1sBefore[i+1]++;\\n                \\n            }\\n             num0sBefore[i+1]+=num0sBefore[i];\\n             num1sBefore[i+1]+=num1sBefore[i];\\n        }\\n      //  System.out.println(Arrays.toString(num0sBefore)+\" \"+Arrays.toString(num1sBefore));\\n      \\n        long ans=0;\\n        \\n        for(int i=1;i<s.length();i++)\\n        {\\n         if(s.charAt(i)==\\'0\\')\\n         {\\n             ans+=num1sBefore[i]*(total1s-num1sBefore[i]);\\n         }\\n            else\\n                ans+=num0sBefore[i]*(total0s-num0sBefore[i]);\\n        \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        int num0sBefore[]=new int[s.length()];\\n        int num1sBefore[]=new int[s.length()];\\n       long total1s=0;\\n       long total0s=0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'0\\'){\\n                total0s++;\\n                if(i==s.length()-1)\\n                    break;\\n                num0sBefore[i+1]++;\\n                \\n                \\n            }\\n            else\\n            {\\n                total1s++;\\n                 if(i==s.length()-1)\\n                    break;\\n                num1sBefore[i+1]++;\\n                \\n            }\\n             num0sBefore[i+1]+=num0sBefore[i];\\n             num1sBefore[i+1]+=num1sBefore[i];\\n        }\\n      //  System.out.println(Arrays.toString(num0sBefore)+\" \"+Arrays.toString(num1sBefore));\\n      \\n        long ans=0;\\n        \\n        for(int i=1;i<s.length();i++)\\n        {\\n         if(s.charAt(i)==\\'0\\')\\n         {\\n             ans+=num1sBefore[i]*(total1s-num1sBefore[i]);\\n         }\\n            else\\n                ans+=num0sBefore[i]*(total0s-num0sBefore[i]);\\n        \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908162,
                "title": "python-2-approaches-prefix-postfix-counts-and-just-counter",
                "content": "O(N) both space and time - prefix and postfix counts\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        ways = 0\\n        N = len(s)        \\n        prefix_count = [[0,0] for _ in range(N)]\\n        postfix_count = [[0,0] for _ in range(N)]\\n                \\n        for i in range(N):\\n            if i > 0:\\n                prefix_count[i][0] = prefix_count[i - 1][0]\\n                prefix_count[i][1] = prefix_count[i - 1][1]\\n            prefix_count[i][int(s[i])] += 1\\n            j = N - i - 1    \\n            if j + 1 < N:\\n                postfix_count[j][0] = postfix_count[j + 1][0]\\n                postfix_count[j][1] = postfix_count[j + 1][1]\\n            postfix_count[j][int(s[j])] += 1\\n        \\n        for i in range(1, N - 1):        \\n            if s[i] == \\'0\\': ways += prefix_count[i - 1][1] * postfix_count[i + 1][1]\\n            else: ways += prefix_count[i - 1][0] * postfix_count[i + 1][0]\\n                \\n        return ways\\n```\\nO(N) time - Counting occurence of \\'01\\' and \\'10\\'\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        ways = 0\\n        count = Counter()\\n        N = len(s) \\n\\n        reverse_digit = {\\'0\\' : \\'1\\', \\'1\\': \\'0\\'}\\n\\n        for c in s:\\n            ways += count[c+reverse_digit[c]]\\n            count[reverse_digit[c] + c] += count[reverse_digit[c]]\\n            count[c] += 1\\n                \\n        return ways\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        ways = 0\\n        N = len(s)        \\n        prefix_count = [[0,0] for _ in range(N)]\\n        postfix_count = [[0,0] for _ in range(N)]\\n                \\n        for i in range(N):\\n            if i > 0:\\n                prefix_count[i][0] = prefix_count[i - 1][0]\\n                prefix_count[i][1] = prefix_count[i - 1][1]\\n            prefix_count[i][int(s[i])] += 1\\n            j = N - i - 1    \\n            if j + 1 < N:\\n                postfix_count[j][0] = postfix_count[j + 1][0]\\n                postfix_count[j][1] = postfix_count[j + 1][1]\\n            postfix_count[j][int(s[j])] += 1\\n        \\n        for i in range(1, N - 1):        \\n            if s[i] == \\'0\\': ways += prefix_count[i - 1][1] * postfix_count[i + 1][1]\\n            else: ways += prefix_count[i - 1][0] * postfix_count[i + 1][0]\\n                \\n        return ways\\n```\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        ways = 0\\n        count = Counter()\\n        N = len(s) \\n\\n        reverse_digit = {\\'0\\' : \\'1\\', \\'1\\': \\'0\\'}\\n\\n        for c in s:\\n            ways += count[c+reverse_digit[c]]\\n            count[reverse_digit[c] + c] += count[reverse_digit[c]]\\n            count[c] += 1\\n                \\n        return ways\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908000,
                "title": "concise-c-solution-with-comments-no-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        // only two options 010 or 101\\n        long long res = 0;\\n        int rem_1 = count(s.begin(), s.end(), \\'1\\');\\n        int rem_0 = count(s.begin(), s.end(), \\'0\\');\\n        int vis_0 = 0, vis_1 = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\'0\\') // make 101\\n            {\\n                res += (vis_1 * rem_1); // since current character is 0 multiply total visited 1 by remaining 1 to get total \"101\" pairs \\n                rem_0 -= 1; // visited 0 so remaining 0 decreases by 1\\n                vis_0 += 1; // visted 0 so visited 0 increases by 1\\n            }\\n            else // make 010\\n            {\\n                res += (vis_0 * rem_0); // since current character is 1 multiply total visited 0 by remaining 0 to get total \"010\" pairs\\n                rem_1 -= 1;\\n                vis_1 += 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        // only two options 010 or 101\\n        long long res = 0;\\n        int rem_1 = count(s.begin(), s.end(), \\'1\\');\\n        int rem_0 = count(s.begin(), s.end(), \\'0\\');\\n        int vis_0 = 0, vis_1 = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\'0\\') // make 101\\n            {\\n                res += (vis_1 * rem_1); // since current character is 0 multiply total visited 1 by remaining 1 to get total \"101\" pairs \\n                rem_0 -= 1; // visited 0 so remaining 0 decreases by 1\\n                vis_0 += 1; // visted 0 so visited 0 increases by 1\\n            }\\n            else // make 010\\n            {\\n                res += (vis_0 * rem_0); // since current character is 1 multiply total visited 0 by remaining 0 to get total \"010\" pairs\\n                rem_1 -= 1;\\n                vis_1 += 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907794,
                "title": "simple-c-dp-solution",
                "content": "If you ignore the jargon in the question, it simply asks you how many subsequences of length 3 you can create from the given string that have alternating pattern { for less typing lets call them alternating subsequences :-) } i.e.  \"101\" and \"010\".\\n\\n**Intuition:**\\nLets say `s[i] = \\'1\\'`, and we need to find the no of occurences of subsequence \"101\" **that end at index `i`**. Then,\\t\\n\\t\\n\\tcount of \"101\" that end at index i = count of \"10\"s that appear before index i\\nwhy? because all those `\"10\"`s that formed before this index can now be put before this `1` at index `i` to form the subsequence `\"101\"`.\\nSimilar logic can be applied to all the other alternating subsequences.\\n\\nConsidering the intuition above, the DP relation for this problem is pretty straightforward. \\nFor the ith index, let\\'s say ```s[i] = c (0 or 1)```, then the no of alternating subsequences of length ```len``` ending in ```c``` **upto the ```i```th index** is given by\\n\\t\\n\\tdp[i][len][c] = dp[i-1][len][c] + dp[i-1][len-1][c^1]  {where ^ is the bitwise XOR operator}\\n**base case:** len = 1, then simply increment i.e. `dp[i][1][c]++` \\nOn further observation, we can drop the first paramter of the dp array giving us\\n\\n\\tdp[len][c] = dp[len][c] + dp[len-1][c^1]\\n\\nThe catch here is the order in which we update the counts. We need to update the count of the subsequences according to their length in descending order meaning count of subsequences of length 3 being updated first, then of length 2 and so on.\\n\\n**Solution:**\\nTime Complexity : `O(N)`\\nSpace Complexity : `O(1)`\\n\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        vector<vector<long long>> dp(3, vector<long long> (2, 0));\\n        \\n        for(int i=0;i<n;i++) {\\n            int c = s[i] - \\'0\\';\\n            for(int len=2;len>0;len--) {\\n                dp[len][c] = dp[len][c] + dp[len-1][c^1];\\n            }\\n            dp[0][c]++;\\n        }\\n        \\n        return dp[2][0] + dp[2][1];\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```s[i] = c (0 or 1)```\n```len```\n```c```\n```i```\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        vector<vector<long long>> dp(3, vector<long long> (2, 0));\\n        \\n        for(int i=0;i<n;i++) {\\n            int c = s[i] - \\'0\\';\\n            for(int len=2;len>0;len--) {\\n                dp[len][c] = dp[len][c] + dp[len-1][c^1];\\n            }\\n            dp[0][c]++;\\n        }\\n        \\n        return dp[2][0] + dp[2][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907746,
                "title": "memo-one",
                "content": "```\\nclass Solution {\\npublic:\\n    long long  dp[3][100001][4];\\n    long long solve(string &s, int last_one, int index, int cnt)\\n    {\\n        if(cnt == 3)\\n        {\\n            return 1;\\n        }\\n        if(index == s.length()) return 0;\\n        if(cnt>3) return 0;\\n        if(dp[last_one][index][cnt]!=-1) return dp[last_one][index][cnt];        \\n        long long a = 0, b = 0;\\n        if(s[index]-\\'0\\'!=last_one)\\n        {\\n           a = solve(s, s[index]-\\'0\\', index+1, cnt+1);\\n        }\\n        b=solve(s, last_one, index+1, cnt);\\n        return dp[last_one][index][cnt] = a + b;\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp, -1, sizeof(dp));\\n         return solve(s, 2, 0, 0);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    long long  dp[3][100001][4];\\n    long long solve(string &s, int last_one, int index, int cnt)\\n    {\\n        if(cnt == 3)\\n        {\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1907720,
                "title": "java-o-n-solution-using-dynamic-programming",
                "content": "\\n\\n        int zr=0,on=0;\\n        int z[]=new int [s.length()];\\n        int o[]=new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'0\\')\\n            {\\n                zr++;\\n            }\\n            else\\n            {\\n                on++;\\n            }\\n            z[i]=zr;o[i]=on;\\n        }\\n        long ans=0;\\n        for(int i=1;i<s.length()-1;i++)\\n        {\\n            if(s.charAt(i)==\\'0\\')\\n            {\\n                long tmp=o[i-1]*(on-o[i-1]);\\n                ans+=tmp;\\n            }\\n            else\\n            {\\n               long tmp=z[i-1]*(zr-z[i-1]);\\n               ans+=tmp;\\n            }\\n        }\\n        return ans;\\n \\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "\\n\\n        int zr=0,on=0;\\n        int z[]=new int [s.length()];\\n        int o[]=new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'0\\')\\n            {\\n                zr++;\\n            }\\n            else\\n            {\\n                on++;\\n            }\\n            z[i]=zr;o[i]=on;\\n        }\\n        long ans=0;\\n        for(int i=1;i<s.length()-1;i++)\\n        {\\n            if(s.charAt(i)==\\'0\\')\\n            {\\n                long tmp=o[i-1]*(on-o[i-1]);\\n                ans+=tmp;\\n            }\\n            else\\n            {\\n               long tmp=z[i-1]*(zr-z[i-1]);\\n               ans+=tmp;\\n            }\\n        }\\n        return ans;\\n \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1907698,
                "title": "c-easiest-explaination-without-dp-solution",
                "content": "So, lets try to understand what we actually need in this question.\\n**As the question states, we need to select 3 buildings in such a way that there are no consecutive 1\\'s or 0\\'s. Only two such combinations are possible, i.e. 0 1 0 and 1 0 1.**\\nNow, we need to find how many such combinations are there. **If at any point of time, we know for any 1 in string, how many 0\\'s are on left and right of this 1, then the number of combinations of 010 with this 1 will be leftzero*rightzero where leftzero = no of zeroes on left and rightzero = no of zeroes on right.**\\nNow, following same logic,\\n **If at any point of time, we know for any 0 in string, how many 1\\'s are on left and right of this 0, then the number of combinations of 101 with this 0 will be leftone*rightone where leftone = no of ones on left and rightone = no of ones on right.**\\n This is the crux of this solution below.\\n \\n```\\nclass Solution {\\npublic:\\n    \\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        /*\\n            left -> for every index i, \\n            1. if i stores \\'0\\', then left[i] gives no of ones on left\\n            2. if i stores \\'1\\', then left[i] gives no of zeroes on left\\n            \\n            right -> for every index i, \\n            1. if i stores \\'0\\', then right[i] gives no of ones on right\\n            2. if i stores \\'1\\', then right[i] gives no of zeroes on right\\n        */\\n        vector<long long>left(n,0),right(n,0);\\n        /*\\n            leftZero -> no of zeroes on left\\n            leftOne -> -> no of ones on left\\n            rightZero -> no of zeroes on right\\n            rightOne -> -> no of ones on right\\n        */\\n        long long leftZero=0,leftOne=0,rightZero=0,rightOne=0;\\n        \\n        for(int i=0;i<n;i++) {\\n            if(s[i]==\\'0\\') {\\n                leftZero++;\\n                left[i]=leftOne;\\n            }\\n            else {\\n                leftOne++;\\n                left[i]=leftZero;\\n            }\\n            \\n            if(s[n-i-1]==\\'0\\') {\\n                rightZero++;\\n                right[n-i-1]=rightOne;\\n            }\\n            else {\\n                rightOne++;\\n                right[n-i-1]=rightZero;\\n            }\\n        }\\n        \\n        long long count=0;\\n        \\n        for(int i=0;i<n;i++) {\\n            count+=left[i]*right[i];\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        /*\\n            left -> for every index i, \\n            1. if i stores \\'0\\', then left[i] gives no of ones on left\\n            2. if i stores \\'1\\', then left[i] gives no of zeroes on left\\n            \\n            right -> for every index i, \\n            1. if i stores \\'0\\', then right[i] gives no of ones on right\\n            2. if i stores \\'1\\', then right[i] gives no of zeroes on right\\n        */\\n        vector<long long>left(n,0),right(n,0);\\n        /*\\n            leftZero -> no of zeroes on left\\n            leftOne -> -> no of ones on left\\n            rightZero -> no of zeroes on right\\n            rightOne -> -> no of ones on right\\n        */\\n        long long leftZero=0,leftOne=0,rightZero=0,rightOne=0;\\n        \\n        for(int i=0;i<n;i++) {\\n            if(s[i]==\\'0\\') {\\n                leftZero++;\\n                left[i]=leftOne;\\n            }\\n            else {\\n                leftOne++;\\n                left[i]=leftZero;\\n            }\\n            \\n            if(s[n-i-1]==\\'0\\') {\\n                rightZero++;\\n                right[n-i-1]=rightOne;\\n            }\\n            else {\\n                rightOne++;\\n                right[n-i-1]=rightZero;\\n            }\\n        }\\n        \\n        long long count=0;\\n        \\n        for(int i=0;i<n;i++) {\\n            count+=left[i]*right[i];\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907679,
                "title": "prefix-and-suffix-sum-javascript-solution",
                "content": "We can do it using extra memory (prefixOnes and prefixZeros arrays):\\n```\\nvar numberOfWays = function(s) {\\n    let ones = 0;\\n    let zeros = 0;\\n    const prefixOnes = new Array(s.length);\\n    const prefixZeros = new Array(s.length);\\n    let result = 0;\\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        if (s[i] === \"0\") ++zeros;\\n        else ++ones;\\n        \\n        prefixZeros[i] = zeros;\\n        prefixOnes[i] = ones;\\n    }\\n    \\n    zeros = 0;\\n    ones = 0;\\n    for (let i = s.length - 1; i > 0; --i) {\\n        if (s[i] === \"0\") {\\n            result += prefixOnes[i - 1] * ones;\\n            ++zeros;\\n        }\\n        else {\\n            result += prefixZeros[i - 1] * zeros;\\n            ++ones;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```\\nOr using constant memory (twice faster):\\n```\\nvar numberOfWays = function(s) {\\n    let ones = 0;\\n    let zeros = 0;\\n    let prefixOnes = 0;\\n    let prefixZeros = 0;\\n    let result = 0;\\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        if (s[i] === \"0\") ++prefixZeros;\\n        else ++prefixOnes;\\n    }\\n    \\n    for (let i = s.length - 1; i > 0; --i) {\\n        if (s[i] === \"0\") {\\n            result += prefixOnes * ones;\\n            --prefixZeros;\\n            ++zeros;\\n        }\\n        else {\\n            result += prefixZeros * zeros;\\n            --prefixOnes;\\n            ++ones;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numberOfWays = function(s) {\\n    let ones = 0;\\n    let zeros = 0;\\n    const prefixOnes = new Array(s.length);\\n    const prefixZeros = new Array(s.length);\\n    let result = 0;\\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        if (s[i] === \"0\") ++zeros;\\n        else ++ones;\\n        \\n        prefixZeros[i] = zeros;\\n        prefixOnes[i] = ones;\\n    }\\n    \\n    zeros = 0;\\n    ones = 0;\\n    for (let i = s.length - 1; i > 0; --i) {\\n        if (s[i] === \"0\") {\\n            result += prefixOnes[i - 1] * ones;\\n            ++zeros;\\n        }\\n        else {\\n            result += prefixZeros[i - 1] * zeros;\\n            ++ones;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```\n```\\nvar numberOfWays = function(s) {\\n    let ones = 0;\\n    let zeros = 0;\\n    let prefixOnes = 0;\\n    let prefixZeros = 0;\\n    let result = 0;\\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        if (s[i] === \"0\") ++prefixZeros;\\n        else ++prefixOnes;\\n    }\\n    \\n    for (let i = s.length - 1; i > 0; --i) {\\n        if (s[i] === \"0\") {\\n            result += prefixOnes * ones;\\n            --prefixZeros;\\n            ++zeros;\\n        }\\n        else {\\n            result += prefixZeros * zeros;\\n            --prefixOnes;\\n            ++ones;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907610,
                "title": "c-dp-state-machine",
                "content": "![image](https://assets.leetcode.com/users/images/9b68d040-d552-4a81-b5ed-e66abe8709b1_1648921834.2967253.png)\\n\\n\\n\\n```\\nconst int N = 100010;\\n\\ntypedef long long LL;\\n\\nclass Solution {\\n    LL f[N][4][2] = {};\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        \\n        f[0][0][0] = 1, f[0][0][1] = 1;\\n        for (int i = 1; i <= n; ++ i)\\n        {\\n            for (int j = 0; j <= 3; ++ j) // One caveat is that j need to start from 0 to piggy back the initial state\\n                                          // since there is assumption that f[i][0][k] = 1, namely, if no bld is selected, we think is one valid way.\\n            {\\n                if (s[i - 1] == \\'0\\')\\n                    f[i][j][0] += j ? f[i-1][j-1][1] : 0;\\n                else\\n                    f[i][j][1] += j ? f[i-1][j-1][0] : 0;\\n                f[i][j][0] += f[i-1][j][0];\\n                f[i][j][1] += f[i-1][j][1];\\n            }\\n        }\\n    \\n        return f[n][3][0] + f[n][3][1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int N = 100010;\\n\\ntypedef long long LL;\\n\\nclass Solution {\\n    LL f[N][4][2] = {};\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.size();\\n        \\n        f[0][0][0] = 1, f[0][0][1] = 1;\\n        for (int i = 1; i <= n; ++ i)\\n        {\\n            for (int j = 0; j <= 3; ++ j) // One caveat is that j need to start from 0 to piggy back the initial state\\n                                          // since there is assumption that f[i][0][k] = 1, namely, if no bld is selected, we think is one valid way.\\n            {\\n                if (s[i - 1] == \\'0\\')\\n                    f[i][j][0] += j ? f[i-1][j-1][1] : 0;\\n                else\\n                    f[i][j][1] += j ? f[i-1][j-1][0] : 0;\\n                f[i][j][0] += f[i-1][j][0];\\n                f[i][j][1] += f[i-1][j][1];\\n            }\\n        }\\n    \\n        return f[n][3][0] + f[n][3][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907509,
                "title": "c-without-dp-easy-understanding-simple-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        vector<int> cnt(s.size(), 0);\\n        int  c0 = 0, c1 = 0;\\n\\t\\t\\n\\t\\t//count how many opposite element are there in left\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'0\\'){\\n                c0++;\\n                cnt[i] = c1;\\n            }\\n            else{\\n                c1++;\\n                cnt[i] = c0;\\n            }\\n        }\\n        c1 = c0 = 0;\\n        long long tot = 0;\\n\\t\\t//to get answer multiply previous prefix with number of opposite element on right of particular number\\n        for(int i = s.size() - 1; i >= 0; i--){\\n            if(s[i] == \\'0\\'){\\n                c0++;\\n                tot += cnt[i] * c1;\\n            }\\n            else{\\n                c1++;\\n                tot += cnt[i] * c0;\\n            }\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        vector<int> cnt(s.size(), 0);\\n        int  c0 = 0, c1 = 0;\\n\\t\\t\\n\\t\\t//count how many opposite element are there in left\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'0\\'){\\n                c0++;\\n                cnt[i] = c1;\\n            }\\n            else{\\n                c1++;\\n                cnt[i] = c0;\\n            }\\n        }\\n        c1 = c0 = 0;\\n        long long tot = 0;\\n\\t\\t//to get answer multiply previous prefix with number of opposite element on right of particular number\\n        for(int i = s.size() - 1; i >= 0; i--){\\n            if(s[i] == \\'0\\'){\\n                c0++;\\n                tot += cnt[i] * c1;\\n            }\\n            else{\\n                c1++;\\n                tot += cnt[i] * c0;\\n            }\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907454,
                "title": "easy-to-understand-o-n-prefix-suffix",
                "content": "**Apoarch:-**\\n\\n1. count the no.of zero in prefix and suffix form\\n2. count the no.of one in prefix and suffix form\\n3. And stored them in an array as pre0, pre1, suf0 and suf1\\n4. Then traverse the string if \\n    i) char at index i is equals to zero\\n\\t      ->then add (no.of one before i) x (no.of one after i) to ans\\n    ii)char at index i is equals to one \\n\\t     ->then add (no.of zero before i) x (no.of zero after i) to ans\\n\\t\\t \\n\\t\\t \\n**Complexity:-**\\n\\n**Time** :- o(n)\\n**Space** :- o(n)\\n\\n\\nHave a look into the code for better understanding ;)\\n\\n**Code**:- \\n\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.length();\\n        vector<int> pre0(n,0);\\n        vector<int> pre1(n,0);\\n        vector<int> suf0(n,0);\\n        vector<int> suf1(n,0);\\n        \\n        pre0[0] = (s[0]==\\'0\\') ? 1:0;\\n        pre1[0] = (s[0]==\\'0\\') ? 0:1;\\n        for(int i=1;i<n;i++){\\n            int val0 = (s[i]==\\'0\\') ? 1:0;\\n            int val1 = (s[i]==\\'0\\') ? 0:1;\\n            pre0[i] = pre0[i-1]+val0;\\n            pre1[i] = pre1[i-1]+val1;\\n        }\\n        \\n        suf0[n-1] = (s[n-1]==\\'0\\') ? 1:0;\\n        suf1[n-1] = (s[n-1]==\\'0\\') ? 0:1;\\n        for(int i=n-2;i>=0;i--){\\n            int val0 = (s[i]==\\'0\\') ? 1:0;\\n            int val1 = (s[i]==\\'0\\') ? 0:1;\\n            suf0[i] = suf0[i+1]+val0;\\n            suf1[i] = suf1[i+1]+val1;\\n        }\\n        \\n        long long int ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            int p0 = (i==0) ? 0:pre0[i-1];\\n            int p1 = (i==0) ? 0:pre1[i-1];\\n            int s0 = (i==n-1) ? 0:suf0[i+1];\\n            int s1 = (i==n-1) ? 0:suf1[i+1];\\n            if(s[i]==\\'1\\'){\\n                ans += (long long int)(p0)*(long long int)(s0);\\n            }\\n            else{\\n                ans += (long long int)(p1)*(long long int)(s1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "String",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        int n = s.length();\\n        vector<int> pre0(n,0);\\n        vector<int> pre1(n,0);\\n        vector<int> suf0(n,0);\\n        vector<int> suf1(n,0);\\n        \\n        pre0[0] = (s[0]==\\'0\\') ? 1:0;\\n        pre1[0] = (s[0]==\\'0\\') ? 0:1;\\n        for(int i=1;i<n;i++){\\n            int val0 = (s[i]==\\'0\\') ? 1:0;\\n            int val1 = (s[i]==\\'0\\') ? 0:1;\\n            pre0[i] = pre0[i-1]+val0;\\n            pre1[i] = pre1[i-1]+val1;\\n        }\\n        \\n        suf0[n-1] = (s[n-1]==\\'0\\') ? 1:0;\\n        suf1[n-1] = (s[n-1]==\\'0\\') ? 0:1;\\n        for(int i=n-2;i>=0;i--){\\n            int val0 = (s[i]==\\'0\\') ? 1:0;\\n            int val1 = (s[i]==\\'0\\') ? 0:1;\\n            suf0[i] = suf0[i+1]+val0;\\n            suf1[i] = suf1[i+1]+val1;\\n        }\\n        \\n        long long int ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            int p0 = (i==0) ? 0:pre0[i-1];\\n            int p1 = (i==0) ? 0:pre1[i-1];\\n            int s0 = (i==n-1) ? 0:suf0[i+1];\\n            int s1 = (i==n-1) ? 0:suf1[i+1];\\n            if(s[i]==\\'1\\'){\\n                ans += (long long int)(p0)*(long long int)(s0);\\n            }\\n            else{\\n                ans += (long long int)(p1)*(long long int)(s1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907406,
                "title": "python-dp-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def numberOfWays(self, s):\\n        length = len(s)\\n        dp = []\\n        zeros = 0\\n        ones = 0\\n        for i in range(length):\\n            if(s[i]==\\'0\\'):\\n                zeros+=1\\n            elif(s[i]==\\'1\\'):\\n                ones+=1\\n            dp.append([zeros,ones]) //count zeros and ones\\n        count = 0\\n        for i in range(length):\\n            if(s[i]==\\'0\\'):\\n                count += dp[i][1]*(dp[-1][1]-dp[i][1]) // \\'101\\' dp[i][1] is ones before \\'0\\', (dp[-1][1]-dp[i][1]) is ones after \\'0\\'\\n            if(s[i]==\\'1\\'):\\n                count += dp[i][0]*(dp[-1][0]-dp[i][0]) // \\'010\\' dp[i][0] is zeros before \\'1\\' and (dp[-1][0]-dp[i][0]) is zeros after \\'1\\'\\n        return count\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numberOfWays(self, s):\\n        length = len(s)\\n        dp = []\\n        zeros = 0\\n        ones = 0\\n        for i in range(length):\\n            if(s[i]==\\'0\\'):\\n                zeros+=1\\n            elif(s[i]==\\'1\\'):\\n                ones+=1\\n            dp.append([zeros,ones]) //count zeros and ones\\n        count = 0\\n        for i in range(length):\\n            if(s[i]==\\'0\\'):\\n                count += dp[i][1]*(dp[-1][1]-dp[i][1]) // \\'101\\' dp[i][1] is ones before \\'0\\', (dp[-1][1]-dp[i][1]) is ones after \\'0\\'\\n            if(s[i]==\\'1\\'):\\n                count += dp[i][0]*(dp[-1][0]-dp[i][0]) // \\'010\\' dp[i][0] is zeros before \\'1\\' and (dp[-1][0]-dp[i][0]) is zeros after \\'1\\'\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907359,
                "title": "very-easy-understanding-c",
                "content": "```\\nlong long numberOfWays(string a) {\\n        int n=a.size();\\n        vector<int> left1(n),right1(n),left2(n),right2(n); \\n        int zero=0,one=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(a[i]==\\'1\\')\\n                one++;\\n            else\\n                zero++;\\n            right2[i]=one;\\n            right1[i]=zero;\\n        }  \\n        one=0;\\n        zero=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==\\'1\\')\\n                one++;\\n            else\\n                zero++;\\n            left2[i]=one,left1[i]=zero;\\n        }\\n        long long count=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==\\'0\\'){\\n                count+=left2[i]*right2[i];\\n            }\\n            else\\n                count+=left1[i]*right1[i];\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nlong long numberOfWays(string a) {\\n        int n=a.size();\\n        vector<int> left1(n),right1(n),left2(n),right2(n); \\n        int zero=0,one=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(a[i]==\\'1\\')\\n                one++;\\n            else\\n                zero++;\\n            right2[i]=one;\\n            right1[i]=zero;\\n        }  \\n        one=0;\\n        zero=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==\\'1\\')\\n                one++;\\n            else\\n                zero++;\\n            left2[i]=one,left1[i]=zero;\\n        }\\n        long long count=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==\\'0\\'){\\n                count+=left2[i]*right2[i];\\n            }\\n            else\\n                count+=left1[i]*right1[i];\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1907347,
                "title": "c-time-space-optimized-o-n",
                "content": "The only valid combinations possible are **101** and **010**.\\nSo, traverse the string and consider the **current character as the centeral character** of the combination.\\nThis means, if the **current character is \\'0\\'**, then we need to do it find out the **number of \\'1\\' before this \\'0\\' and number of \\'1\\' after this \\'0\\' and multiple them and add to the answer**. Do same for the **central character as \\'1\\'** then we need to do find out the **number of \\'0\\' before this \\'1\\' and number of \\'0\\' after this \\'1\\' and multiple them to add to the answer**.\\n\\n**Solution 1 :**\\n**Time Complexity : O(n)**\\n**Space Complexity : O(1)**\\n```\\nclass Solution {\\npublic:\\n\\tlong long numberOfWays(string s) {\\n\\t\\tint n = s.size();\\n\\t\\tlong long totalZeros = 0, totalOnes = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (s[i] == \\'0\\') totalZeros++;\\n\\t\\t\\telse totalOnes++;\\n\\t\\t}\\n\\t\\tlong long ans = 0;\\n\\t\\tlong long prevZeros = 0, prevOnes = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t// assuming s[i] is middle element\\n\\t\\t\\tif (s[i] == \\'0\\') {\\n\\t\\t\\t\\tans += ((prevOnes) * (totalOnes - prevOnes));\\n\\t\\t\\t\\tprevZeros++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tans += ((prevZeros) * (totalZeros - prevZeros));\\n\\t\\t\\t\\tprevOnes++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n\\n**Solution 2 :**\\n**Time Complexity : O(n)**\\n**Space Complexity : O(n)**\\n```\\nclass Solution {\\npublic:\\n\\tlong long numberOfWays(string s) {\\n\\t\\tint n = s.size();\\n\\t\\tvector<long long>pre0(n, 0), pre1(n, 0);\\n\\t\\tif (s[0] == \\'0\\') pre0[0]++;\\n\\t\\telse pre1[0]++;\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tpre0[i] = pre0[i - 1];\\n\\t\\t\\tpre1[i] = pre1[i - 1];\\n\\t\\t\\tif (s[i] == \\'0\\') pre0[i]++;\\n\\t\\t\\telse pre1[i]++;\\n\\t\\t}\\n\\t\\tlong long ans = 0;\\n\\t\\tfor (int i = 1; i < n - 1; i++) {\\n\\t\\t\\tif (s[i] == \\'0\\') ans += ((pre1[i - 1]) * (pre1[n - 1] - pre1[i - 1]));\\n\\t\\t\\telse ans += ((pre0[i - 1]) * (pre0[n - 1] - pre0[i - 1]));\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n\\n**If find Helpful *Upvote It* \\uD83D\\uDC4D**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tlong long numberOfWays(string s) {\\n\\t\\tint n = s.size();\\n\\t\\tlong long totalZeros = 0, totalOnes = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (s[i] == \\'0\\') totalZeros++;\\n\\t\\t\\telse totalOnes++;\\n\\t\\t}\\n\\t\\tlong long ans = 0;\\n\\t\\tlong long prevZeros = 0, prevOnes = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t// assuming s[i] is middle element\\n\\t\\t\\tif (s[i] == \\'0\\') {\\n\\t\\t\\t\\tans += ((prevOnes) * (totalOnes - prevOnes));\\n\\t\\t\\t\\tprevZeros++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tans += ((prevZeros) * (totalZeros - prevZeros));\\n\\t\\t\\t\\tprevOnes++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tlong long numberOfWays(string s) {\\n\\t\\tint n = s.size();\\n\\t\\tvector<long long>pre0(n, 0), pre1(n, 0);\\n\\t\\tif (s[0] == \\'0\\') pre0[0]++;\\n\\t\\telse pre1[0]++;\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tpre0[i] = pre0[i - 1];\\n\\t\\t\\tpre1[i] = pre1[i - 1];\\n\\t\\t\\tif (s[i] == \\'0\\') pre0[i]++;\\n\\t\\t\\telse pre1[i]++;\\n\\t\\t}\\n\\t\\tlong long ans = 0;\\n\\t\\tfor (int i = 1; i < n - 1; i++) {\\n\\t\\t\\tif (s[i] == \\'0\\') ans += ((pre1[i - 1]) * (pre1[n - 1] - pre1[i - 1]));\\n\\t\\t\\telse ans += ((pre0[i - 1]) * (pre0[n - 1] - pre0[i - 1]));\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907309,
                "title": "convert-from-top-down-to-bottom-up-dp",
                "content": "For this question, I instantly identified that we should use DP approach.\\nIntuitively, I started with top-down approach, and in 5 minutes, I got this:\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        N = len(s)\\n        def topdown(i, n, v):\\n            if (i, n, v) in memo:\\n                return memo[(i, n, v)]\\n            if n >= 3:\\n                return 1\\n            if i+1 > N-1:\\n                return 0\\n            count = topdown(i+1, n, v)\\n            if s[i+1] != v:\\n                count += topdown(i+1, n+1, s[i+1])\\n            memo[(i, n, v)] = count\\n            return count\\n        memo = {}\\n        res = 0\\n        for i in range(N):\\n            res += topdown(i, 1, s[i])\\n        return res\\n```\\nIt got TLE, but technically time complexity is O(N), and it should have accepted this approach.\\n\\nThen I started to convert it to bottom-up, and I spent 30-45 minutes trying to convert it. But I just couldn\\'t wrap my head around converting it to bottom-up approach.\\n\\nCan someone please explain the way to intuitively understand step by step process of converting this solution from top-down to bottom-up?\\n\\nI got the same problem several times before...",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        N = len(s)\\n        def topdown(i, n, v):\\n            if (i, n, v) in memo:\\n                return memo[(i, n, v)]\\n            if n >= 3:\\n                return 1\\n            if i+1 > N-1:\\n                return 0\\n            count = topdown(i+1, n, v)\\n            if s[i+1] != v:\\n                count += topdown(i+1, n+1, s[i+1])\\n            memo[(i, n, v)] = count\\n            return count\\n        memo = {}\\n        res = 0\\n        for i in range(N):\\n            res += topdown(i, 1, s[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907294,
                "title": "pure-brute-force-easiest-solution-leetcode-had-mercy-on-me",
                "content": "```\\nclass Solution {\\n    long long count(string a, string b){\\n        int m = a.length(),n = 3;\\n        vector<vector<long long>> counter(m+1,vector<long long>(4,0));\\n        for (int i = 0; i <= m; ++i) counter[i][0] = 1;\\n        for (int i = 1; i <= m; i++){\\n            for (int j = 1; j <= 3; j++){\\n                if (a[i - 1] == b[j - 1])\\n                    counter[i][j] = counter[i - 1][j - 1] + counter[i - 1][j];\\n                else\\n                    counter[i][j] = counter[i - 1][j];\\n            }\\n        }\\n        return counter[m][3];\\n    }\\n    bool isSubSequence(string str2, string str1){\\n        int m = str2.size();\\n        int n=3;\\n        int j = 0;\\n        for (int i = 0; i < m && j < n; i++)\\n            if (str1[j] == str2[i])\\n                j++;\\n        return (j == n);\\n    }\\npublic:\\n    long long numberOfWays(string s) {\\n        string s1 = \"010\";\\n        string s2 = \"101\";\\n        long long ans=0;\\n        if(isSubSequence(s,s1))\\n            ans+= count(s,s1);\\n        if(isSubSequence(s,s2))\\n            ans+=count(s,s2);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/fae387b1-1b5d-4581-8635-eb68aee18e80_1648916465.4073477.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long long count(string a, string b){\\n        int m = a.length(),n = 3;\\n        vector<vector<long long>> counter(m+1,vector<long long>(4,0));\\n        for (int i = 0; i <= m; ++i) counter[i][0] = 1;\\n        for (int i = 1; i <= m; i++){\\n            for (int j = 1; j <= 3; j++){\\n                if (a[i - 1] == b[j - 1])\\n                    counter[i][j] = counter[i - 1][j - 1] + counter[i - 1][j];\\n                else\\n                    counter[i][j] = counter[i - 1][j];\\n            }\\n        }\\n        return counter[m][3];\\n    }\\n    bool isSubSequence(string str2, string str1){\\n        int m = str2.size();\\n        int n=3;\\n        int j = 0;\\n        for (int i = 0; i < m && j < n; i++)\\n            if (str1[j] == str2[i])\\n                j++;\\n        return (j == n);\\n    }\\npublic:\\n    long long numberOfWays(string s) {\\n        string s1 = \"010\";\\n        string s2 = \"101\";\\n        long long ans=0;\\n        if(isSubSequence(s,s1))\\n            ans+= count(s,s1);\\n        if(isSubSequence(s,s2))\\n            ans+=count(s,s2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907292,
                "title": "c-single-loop-4-variables",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long nums0 = 0, nums1 = 0, nums01 = 0, nums10 = 0;\\n        long long res = 0;\\n        for(int i = 0; i<s.size(); i++){\\n            if(s[i] == \\'0\\'){\\n                res+=nums01;\\n                nums10+=nums1;\\n                nums0++;\\n            }\\n            else{\\n                res+=nums10;\\n                nums01+=nums0;\\n                nums1++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long nums0 = 0, nums1 = 0, nums01 = 0, nums10 = 0;\\n        long long res = 0;\\n        for(int i = 0; i<s.size(); i++){\\n            if(s[i] == \\'0\\'){\\n                res+=nums01;\\n                nums10+=nums1;\\n                nums0++;\\n            }\\n            else{\\n                res+=nums10;\\n                nums01+=nums0;\\n                nums1++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907239,
                "title": "java-easy-and-intuitive-solution-subsequences-logic",
                "content": "**Code**\\n```java\\npublic long count(String s, String t) {\\n\\tint m = s.length();\\n\\tint n = t.length();\\n\\n\\tlong dp[][] = new long[m + 1][n + 1];\\n\\n\\tfor (int i = 0; i <= n; ++i) dp[0][i] = 0;\\n\\tfor (int i = 0; i <= m; ++i) dp[i][0] = 1;\\n\\n\\tfor (int i = 1; i <= m; i++) {\\n\\t\\tfor (int j = 1; j <= n; j++) {\\n\\t\\t\\tif (s.charAt(i - 1) == t.charAt(j - 1))\\n\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\\n\\t\\t\\telse\\n\\t\\t\\t\\tdp[i][j] = dp[i - 1][j];\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[m][n];\\n}\\n\\npublic long numberOfWays(String s) {\\n\\treturn count(s, \"010\") + count(s, \"101\");\\n}\\n```\\n\\n**Explanation**\\nIn this problem if we closely notice, there can be only two possibilities of selecting houses, either `010` or `101`.\\nSo we need to find the number of times each of these strings occurs as subsequence in the given string.\\nThe addition of these two will give us the desired answer.\\n\\nHope it helps\\nThanks\\nDo upvote",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic long count(String s, String t) {\\n\\tint m = s.length();\\n\\tint n = t.length();\\n\\n\\tlong dp[][] = new long[m + 1][n + 1];\\n\\n\\tfor (int i = 0; i <= n; ++i) dp[0][i] = 0;\\n\\tfor (int i = 0; i <= m; ++i) dp[i][0] = 1;\\n\\n\\tfor (int i = 1; i <= m; i++) {\\n\\t\\tfor (int j = 1; j <= n; j++) {\\n\\t\\t\\tif (s.charAt(i - 1) == t.charAt(j - 1))\\n\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\\n\\t\\t\\telse\\n\\t\\t\\t\\tdp[i][j] = dp[i - 1][j];\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[m][n];\\n}\\n\\npublic long numberOfWays(String s) {\\n\\treturn count(s, \"010\") + count(s, \"101\");\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907236,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef numberOfWays(self, s: str) -> int:\\n\\t\\t\\tn = len(s)\\n\\t\\t\\tleftZero = 0\\n\\t\\t\\tLeftOne = 0\\n\\t\\t\\trightZero = 0\\n\\t\\t\\trightOne = 0\\n\\t\\t\\tleft = []\\n\\t\\t\\tright = []\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tif s[i] == \"0\":\\n\\t\\t\\t\\t\\tleftZero += 1\\n\\t\\t\\t\\t\\tleft.append(LeftOne)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tLeftOne += 1\\n\\t\\t\\t\\t\\tleft.append(leftZero)\\n\\t\\t\\t\\tif s[n - 1 - i] == \"0\":\\n\\t\\t\\t\\t\\tright.append(rightOne)\\n\\t\\t\\t\\t\\trightZero += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tright.append(rightZero)\\n\\t\\t\\t\\t\\trightOne += 1\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tres += left[i] * right[n - 1 - i]\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef numberOfWays(self, s: str) -> int:\\n\\t\\t\\tn = len(s)\\n\\t\\t\\tleftZero = 0\\n\\t\\t\\tLeftOne = 0\\n\\t\\t\\trightZero = 0\\n\\t\\t\\trightOne = 0\\n\\t\\t\\tleft = []\\n\\t\\t\\tright = []\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tif s[i] == \"0\":\\n\\t\\t\\t\\t\\tleftZero += 1\\n\\t\\t\\t\\t\\tleft.append(LeftOne)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tLeftOne += 1\\n\\t\\t\\t\\t\\tleft.append(leftZero)\\n\\t\\t\\t\\tif s[n - 1 - i] == \"0\":\\n\\t\\t\\t\\t\\tright.append(rightOne)\\n\\t\\t\\t\\t\\trightZero += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tright.append(rightZero)\\n\\t\\t\\t\\t\\trightOne += 1\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tres += left[i] * right[n - 1 - i]\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 1907193,
                "title": "dp-java",
                "content": "```java\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long ans = count(s,\"101\",s.length(),3) + count(s,\"010\",s.length(),3);\\n        return ans;\\n    }\\n    private long count(String a, String b, int m, int n)\\n    {\\n\\n        long lookup[][] = new long[m + 1][n + 1];\\n\\n        for (int i = 0; i <= n; ++i)\\n            lookup[0][i] = 0;\\n\\n        for (int i = 0; i <= m; ++i)\\n            lookup[i][0] = 1;\\n\\n        for (int i = 1; i <= m; i++)\\n        {\\n            for (int j = 1; j <= n; j++)\\n            {\\n                if (a.charAt(i - 1) == b.charAt(j - 1))\\n                    lookup[i][j] = lookup[i - 1][j - 1] +\\n                                   lookup[i - 1][j];\\n\\n                else\\n                    lookup[i][j] = lookup[i - 1][j];\\n            }\\n        }\\n\\n        return lookup[m][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long ans = count(s,\"101\",s.length(),3) + count(s,\"010\",s.length(),3);\\n        return ans;\\n    }\\n    private long count(String a, String b, int m, int n)\\n    {\\n\\n        long lookup[][] = new long[m + 1][n + 1];\\n\\n        for (int i = 0; i <= n; ++i)\\n            lookup[0][i] = 0;\\n\\n        for (int i = 0; i <= m; ++i)\\n            lookup[i][0] = 1;\\n\\n        for (int i = 1; i <= m; i++)\\n        {\\n            for (int j = 1; j <= n; j++)\\n            {\\n                if (a.charAt(i - 1) == b.charAt(j - 1))\\n                    lookup[i][j] = lookup[i - 1][j - 1] +\\n                                   lookup[i - 1][j];\\n\\n                else\\n                    lookup[i][j] = lookup[i - 1][j];\\n            }\\n        }\\n\\n        return lookup[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907166,
                "title": "python-o-n-o-1-space-easy-just-look-at-middle-element",
                "content": "Suppose we are looking at \\'010\\' and the i-th index. If s[i] == \\'1\\', we count how many choices there are with the middle element being \\'1\\' in selecting our subsequence. This number should be preZ * sufZ (the number of zeros before i-th index times that number after). Vice versa for \\'0\\'. \\n\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        n = len(s)\\n        preZ = 0\\n        sufZ = 0\\n        preO = 0\\n        sufO = 0\\n        for i in range(n):\\n            if s[i] == \\'0\\':\\n                sufZ += 1\\n            else:\\n                sufO += 1\\n        \\n        ans = 0\\n        for i in range(n):\\n            if s[i] == \\'1\\':\\n                ans += preZ * sufZ\\n                preO += 1\\n                sufO -= 1\\n            else:\\n                ans += preO * sufO\\n                preZ += 1\\n                sufZ -= 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        n = len(s)\\n        preZ = 0\\n        sufZ = 0\\n        preO = 0\\n        sufO = 0\\n        for i in range(n):\\n            if s[i] == \\'0\\':\\n                sufZ += 1\\n            else:\\n                sufO += 1\\n        \\n        ans = 0\\n        for i in range(n):\\n            if s[i] == \\'1\\':\\n                ans += preZ * sufZ\\n                preO += 1\\n                sufO -= 1\\n            else:\\n                ans += preO * sufO\\n                preZ += 1\\n                sufZ -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907161,
                "title": "c-dp-string-subsequence",
                "content": "As we can take three buildings at a time with different consecutive buildings we are left with two types of building sequence one is \"101\" and the other is \"010\". So we will count occurences of subsequences of above strings in the given string.\\n\\n```  \\nlong long subSequence(string a,string b){\\n        int m=a.size();\\n        int n=b.size();\\n        long long dp[m+1][n+1];\\n        for(int i=0;i<=m;i++)\\n            dp[i][0]=1;\\n        for(int j=1;j<=n;j++)\\n            dp[0][j]=0;\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(a[i-1]==b[j-1]){\\n                    dp[i][j]=dp[i-1][j]+dp[i-1][j-1];\\n                }\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n    long long numberOfWays(string s) {\\n        string s2=\"101\";\\n        string s1=\"010\";\\n        long long way1=subSequence(s,s1);\\n        long long way2=subSequence(s,s2);\\n        return way1+way2;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```  \\nlong long subSequence(string a,string b){\\n        int m=a.size();\\n        int n=b.size();\\n        long long dp[m+1][n+1];\\n        for(int i=0;i<=m;i++)\\n            dp[i][0]=1;\\n        for(int j=1;j<=n;j++)\\n            dp[0][j]=0;\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(a[i-1]==b[j-1]){\\n                    dp[i][j]=dp[i-1][j]+dp[i-1][j-1];\\n                }\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n    long long numberOfWays(string s) {\\n        string s2=\"101\";\\n        string s1=\"010\";\\n        long long way1=subSequence(s,s1);\\n        long long way2=subSequence(s,s2);\\n        return way1+way2;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907146,
                "title": "easy-using-recursion-memomization-c",
                "content": "For any index i we can either choose a building if the chosen building is not same as previously chosen  building or we haven\\u2019t choosed any building yet, we repeat this process until the size is less then 3.\\nAnd as the number of total chossen building become 3 we increment the answer by 1, as this is the valid answer.\\n```\\nclass Solution {\\npublic:\\n    long long dp[100000][4][3];\\n\\n    long long  f(string &s ,int i,int prev,int n){\\n\\n        if(n==3){   // we got one string\\n            return 1;  \\n        }\\n\\n        if(i==s.size()){   //reaches end\\n            return 0;\\n        }\\n\\n        if(dp[i][n][prev]!=-1){   // if present return answer\\n            return dp[i][n][prev];\\n        } \\n\\n        if(n==0){   //is size is zero can pick this or can leave\\n\\n            if(s[i]==\\'1\\'){ \\n   \\n                return dp[i][n][prev]=f(s,i+1,1,n+1)+f(s,i+1,prev,n);    // first we are pikcing and second we are not picking \\n            \\n\\t\\t}else{\\n\\n                return dp[i][n][prev]=f(s,i+1,0,n+1)+f(s,i+1,prev,n);    // first we are pikcing and second we are not picking \\n            \\n\\t\\t}\\n        }\\n\\n\\n\\t// is size is greater then 1\\n\\t// check previous one\\n\\n\\n        if(prev==1){   // if prev building is 1\\n\\n            if(s[i]==\\'0\\'){   //if current building is 0 we can take it or skip it \\n                 return dp[i][n][prev]=f(s,i+1,0,n+1)+f(s,i+1,prev,n);\\n            }\\n\\t\\telse{    //if current building is 1 we have to skip it \\n                return dp[i][n][prev]=f(s,i+1,prev,n);\\n            }\\n        }\\n\\n        else if(prev==0){    // if prev building is 0\\n\\n            if(s[i]==\\'1\\'){   //if current building is 1 we can take it or skip it\\n                return dp[i][n][prev]=f(s,i+1,1,n+1)+f(s,i+1,prev,n);\\n            }\\n\\t\\telse{       //if current building is 0 we have to skip it \\n                return dp[i][n][prev]=f(s,i+1,prev,n);\\n            }\\n        }\\n        return 0;\\n    }\\n    long long numberOfWays(string s) {\\n\\n        memset(dp,-1,sizeof(dp));\\n        return f(s,0,0,0);   // final answer\\n    }\\n};\\n```\\n\\n\\nUpvote",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100000][4][3];\\n\\n    long long  f(string &s ,int i,int prev,int n){\\n\\n        if(n==3){   // we got one string\\n            return 1;  \\n        }\\n\\n        if(i==s.size()){   //reaches end\\n            return 0;\\n        }\\n\\n        if(dp[i][n][prev]!=-1){   // if present return answer\\n            return dp[i][n][prev];\\n        } \\n\\n        if(n==0){   //is size is zero can pick this or can leave\\n\\n            if(s[i]==\\'1\\'){ \\n   \\n                return dp[i][n][prev]=f(s,i+1,1,n+1)+f(s,i+1,prev,n);    // first we are pikcing and second we are not picking \\n            \\n\\t\\t}else{\\n\\n                return dp[i][n][prev]=f(s,i+1,0,n+1)+f(s,i+1,prev,n);    // first we are pikcing and second we are not picking \\n            \\n\\t\\t}\\n        }\\n\\n\\n\\t// is size is greater then 1\\n\\t// check previous one\\n\\n\\n        if(prev==1){   // if prev building is 1\\n\\n            if(s[i]==\\'0\\'){   //if current building is 0 we can take it or skip it \\n                 return dp[i][n][prev]=f(s,i+1,0,n+1)+f(s,i+1,prev,n);\\n            }\\n\\t\\telse{    //if current building is 1 we have to skip it \\n                return dp[i][n][prev]=f(s,i+1,prev,n);\\n            }\\n        }\\n\\n        else if(prev==0){    // if prev building is 0\\n\\n            if(s[i]==\\'1\\'){   //if current building is 1 we can take it or skip it\\n                return dp[i][n][prev]=f(s,i+1,1,n+1)+f(s,i+1,prev,n);\\n            }\\n\\t\\telse{       //if current building is 0 we have to skip it \\n                return dp[i][n][prev]=f(s,i+1,prev,n);\\n            }\\n        }\\n        return 0;\\n    }\\n    long long numberOfWays(string s) {\\n\\n        memset(dp,-1,sizeof(dp));\\n        return f(s,0,0,0);   // final answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907137,
                "title": "python3-prefix-and-suffix-characteristic",
                "content": "We are counting number of zeros before and after actual index.\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        n=len(s)\\n        s=[int(ch) for ch in s]\\n        sumS=sum(s)\\n        answ=0\\n        preffix1=0\\n        suffix1=sumS\\n        for i in range(n):\\n            preffix1+=s[i]\\n            preffix0=1+i-preffix1\\n            suffix1-=s[i]\\n            suffix0=n-i-1-suffix1\\n            if s[i]: # looking for \"010\"\\n                answ+=preffix0*suffix0\\n            else: # looking for \"101\"\\n                answ+=preffix1*suffix1          \\n        return answ\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        n=len(s)\\n        s=[int(ch) for ch in s]\\n        sumS=sum(s)\\n        answ=0\\n        preffix1=0\\n        suffix1=sumS\\n        for i in range(n):\\n            preffix1+=s[i]\\n            preffix0=1+i-preffix1\\n            suffix1-=s[i]\\n            suffix0=n-i-1-suffix1\\n            if s[i]: # looking for \"010\"\\n                answ+=preffix0*suffix0\\n            else: # looking for \"101\"\\n                answ+=preffix1*suffix1          \\n        return answ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907122,
                "title": "easy-solution-just-maintain-the-prefix-counts-and-suffix-counts",
                "content": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long ans=0;\\n        int len=s.length();\\n        int beforeZeros=0,beforeOnes=0;\\n        int afterZeros[]=new int[len];\\n        int afterOnes[]=new int[len];\\n        for(int i=len-2;i>=0;i--){\\n            if(s.charAt(i+1)==\\'1\\'){\\n                afterOnes[i]=afterOnes[i+1]+1;\\n                afterZeros[i]=afterZeros[i+1];\\n            }else{\\n                afterZeros[i]=afterZeros[i+1]+1;\\n                afterOnes[i]=afterOnes[i+1];\\n            }\\n        }\\n        for(int i=1;i<len;i++){\\n            if(s.charAt(i-1)==\\'1\\'){\\n                beforeOnes++;\\n            }else{\\n                beforeZeros++;\\n            }\\n            if(s.charAt(i)==\\'1\\'){\\n                  long temp=beforeZeros*1L*afterZeros[i];\\n                ans+=temp;\\n            }else{\\n                long temp=beforeOnes*1L*afterOnes[i];\\n                ans+=temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long ans=0;\\n        int len=s.length();\\n        int beforeZeros=0,beforeOnes=0;\\n        int afterZeros[]=new int[len];\\n        int afterOnes[]=new int[len];\\n        for(int i=len-2;i>=0;i--){\\n            if(s.charAt(i+1)==\\'1\\'){\\n                afterOnes[i]=afterOnes[i+1]+1;\\n                afterZeros[i]=afterZeros[i+1];\\n            }else{\\n                afterZeros[i]=afterZeros[i+1]+1;\\n                afterOnes[i]=afterOnes[i+1];\\n            }\\n        }\\n        for(int i=1;i<len;i++){\\n            if(s.charAt(i-1)==\\'1\\'){\\n                beforeOnes++;\\n            }else{\\n                beforeZeros++;\\n            }\\n            if(s.charAt(i)==\\'1\\'){\\n                  long temp=beforeZeros*1L*afterZeros[i];\\n                ans+=temp;\\n            }else{\\n                long temp=beforeOnes*1L*afterOnes[i];\\n                ans+=temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907115,
                "title": "mle-python-lru-cache",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        @lru_cache(None)\\n        def dp(i, prev, selected):\\n            if selected == 3:\\n                return 1\\n            if 3-selected > len(s)-i:\\n                return 0\\n        \\n            ways = 0\\n            if s[i] != prev: #take\\n                ways += dp(i+1, s[i], selected+1)\\n            ways += dp(i+1, prev, selected)\\n            return ways\\n        \\n        return dp(0, -1, 0)\\n```\\n\\nSpent so much time thinking about improving this solution but I think the approach was wrong from the root. I\\'m curious to know if anyone with the same solution in C++ maybe using memo has passed the test cases",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        @lru_cache(None)\\n        def dp(i, prev, selected):\\n            if selected == 3:\\n                return 1\\n            if 3-selected > len(s)-i:\\n                return 0\\n        \\n            ways = 0\\n            if s[i] != prev: #take\\n                ways += dp(i+1, s[i], selected+1)\\n            ways += dp(i+1, prev, selected)\\n            return ways\\n        \\n        return dp(0, -1, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907113,
                "title": "time-o-n-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        //Store number of zeroes and ones on the left side of current element\\n        vector<pair<int,int>> left(s.length());\\n         //Store number of zeroes and ones on the right side of current element\\n        vector<pair<int,int>> right(s.length());\\n        int count0=0;\\n        int count1=0;\\n        long long result=0;\\n        for(int i=0;i<s.length();i++)\\n        {  left[i]={count0,count1};\\n            s[i]==\\'0\\'?count0++:count1++;\\n        }\\n        count0=0;\\n        count1=0;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {   right[i]={count0,count1};            \\n            s[i]==\\'0\\'?count0++:count1++;\\n        }\\n        for(int i=1;i<s.length()-1;i++)\\n        {   //Take number of ones on left * number of ones on right\\n            if(s[i]==\\'0\\')\\n            {\\n                result+=(left[i].second)*(right[i].second);\\n            }\\n            else\\n            {   //Take number of zeroes on left * number of zeroes on right\\n                result+=(left[i].first)*(right[i].first);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n**Like it ? Please Vote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        //Store number of zeroes and ones on the left side of current element\\n        vector<pair<int,int>> left(s.length());\\n         //Store number of zeroes and ones on the right side of current element\\n        vector<pair<int,int>> right(s.length());\\n        int count0=0;\\n        int count1=0;\\n        long long result=0;\\n        for(int i=0;i<s.length();i++)\\n        {  left[i]={count0,count1};\\n            s[i]==\\'0\\'?count0++:count1++;\\n        }\\n        count0=0;\\n        count1=0;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {   right[i]={count0,count1};            \\n            s[i]==\\'0\\'?count0++:count1++;\\n        }\\n        for(int i=1;i<s.length()-1;i++)\\n        {   //Take number of ones on left * number of ones on right\\n            if(s[i]==\\'0\\')\\n            {\\n                result+=(left[i].second)*(right[i].second);\\n            }\\n            else\\n            {   //Take number of zeroes on left * number of zeroes on right\\n                result+=(left[i].first)*(right[i].first);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907022,
                "title": "simple-solution-in-java-100-faster",
                "content": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long c = 0;\\n        long z = 0L;\\n        long o = 0L;\\n        long zo = 0L;\\n        long oz = 0l;\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                c+=zo;\\n                z++;\\n                oz+=o;\\n            } else {\\n                c+=oz;\\n                o++;\\n                zo+=z;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long c = 0;\\n        long z = 0L;\\n        long o = 0L;\\n        long zo = 0L;\\n        long oz = 0l;\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                c+=zo;\\n                z++;\\n                oz+=o;\\n            } else {\\n                c+=oz;\\n                o++;\\n                zo+=z;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907006,
                "title": "c-dynamic-programming-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[5][100001];\\n    long long recur(string &s,string temp,int idx){\\n        if(temp.length() == 3)\\n            return 1;\\n        if(idx == s.length())\\n            return 0;\\n        int dig;\\n        if(temp.length() == 0)\\n            dig = 0;\\n        else\\n            dig = stoi(temp,0,2) + temp.length();\\n        if(dp[dig][idx] != -1)\\n            return dp[dig][idx];\\n        if(temp.length() != 0 && s[idx] == temp[temp.length() - 1])\\n            return dp[dig][idx] = recur(s,temp,idx + 1);\\n        return dp[dig][idx] = recur(s,temp,idx + 1) + recur(s,temp + s[idx],idx + 1);\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        string temp = \"\";\\n        return recur(s,temp,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[5][100001];\\n    long long recur(string &s,string temp,int idx){\\n        if(temp.length() == 3)\\n            return 1;\\n        if(idx == s.length())\\n            return 0;\\n        int dig;\\n        if(temp.length() == 0)\\n            dig = 0;\\n        else\\n            dig = stoi(temp,0,2) + temp.length();\\n        if(dp[dig][idx] != -1)\\n            return dp[dig][idx];\\n        if(temp.length() != 0 && s[idx] == temp[temp.length() - 1])\\n            return dp[dig][idx] = recur(s,temp,idx + 1);\\n        return dp[dig][idx] = recur(s,temp,idx + 1) + recur(s,temp + s[idx],idx + 1);\\n    }\\n    long long numberOfWays(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        string temp = \"\";\\n        return recur(s,temp,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907000,
                "title": "count-101-and-010-using-prefix-array",
                "content": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        n = len(s)\\n        z = 0\\n        o = 0\\n        zeroes = [z]\\n        ones = [o]\\n        for c in s:\\n            if c == \\'0\\':\\n                z += 1\\n            if c == \\'1\\':\\n                o += 1\\n            zeroes.append(z)\\n            ones.append(o)\\n        ways = 0\\n        for i in range(n):\\n            if s[i] == \\'0\\':\\n                ways += (ones[i] - ones[0]) * (ones[-1] - ones[i + 1])\\n            elif s[i] == \\'1\\':\\n                ways += (zeroes[i] - zeroes[0]) * (zeroes[-1] - zeroes[i + 1])\\n        return ways\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        n = len(s)\\n        z = 0\\n        o = 0\\n        zeroes = [z]\\n        ones = [o]\\n        for c in s:\\n            if c == \\'0\\':\\n                z += 1\\n            if c == \\'1\\':\\n                o += 1\\n            zeroes.append(z)\\n            ones.append(o)\\n        ways = 0\\n        for i in range(n):\\n            if s[i] == \\'0\\':\\n                ways += (ones[i] - ones[0]) * (ones[-1] - ones[i + 1])\\n            elif s[i] == \\'1\\':\\n                ways += (zeroes[i] - zeroes[0]) * (zeroes[-1] - zeroes[i + 1])\\n        return ways\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906986,
                "title": "java-dp-waterfall-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long z = 0, o = 0, zo = 0, oz = 0, zoz = 0, ozo = 0;\\n        for (char c: s.toCharArray()) {\\n            if (c == \\'0\\') {\\n                zoz += zo;\\n                oz += o;\\n                z++;\\n            }\\n            else {\\n                ozo += oz;\\n                zo += z;\\n                o++;\\n            }\\n        }\\n        return zoz + ozo;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long numberOfWays(String s) {\\n        long z = 0, o = 0, zo = 0, oz = 0, zoz = 0, ozo = 0;\\n        for (char c: s.toCharArray()) {\\n            if (c == \\'0\\') {\\n                zoz += zo;\\n                oz += o;\\n                z++;\\n            }\\n            else {\\n                ozo += oz;\\n                zo += z;\\n                o++;\\n            }\\n        }\\n        return zoz + ozo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906959,
                "title": "java-easy-understanding-with-diagram",
                "content": "We can only choose `010` and `101` with no two consecutive\\n\\nWe can count total number of digits, then we count current number of digits\\n\\nTo count pattern of `010`, we count number of zero from left and right\\n\\n```\\nleft number of zero\\nXXXXXXXXXXXXXXXXXXX1XXXXXXXXXXXXXXXXXXXX\\n                    right number of zero \\n\\nright number of zero = total zero - current number of zero\\n```\\n\\nSo for pattern `101`  the process is same\\n\\nTime: O(N)\\nSpace: O(1)\\n\\n```\\nclass Solution {\\n  public long numberOfWays(String s) {\\n    long result = 0;\\n    char[] word = s.toCharArray();\\n    // count total number of zero and one\\n    int[] count = new int[2];\\n    for (char c : word) {\\n      count[c - \\'0\\']++;\\n    }\\n\\n    int[] current = new int[2];\\n    for (char c : word) {\\n      int digit = c - \\'0\\';\\n      int revert = 1 - digit;\\n      result += (long) current[revert] * (count[revert] - current[revert]);\\n      current[digit]++;\\n    }\\n\\n    return result;\\n  }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nleft number of zero\\nXXXXXXXXXXXXXXXXXXX1XXXXXXXXXXXXXXXXXXXX\\n                    right number of zero \\n\\nright number of zero = total zero - current number of zero\\n```\n```\\nclass Solution {\\n  public long numberOfWays(String s) {\\n    long result = 0;\\n    char[] word = s.toCharArray();\\n    // count total number of zero and one\\n    int[] count = new int[2];\\n    for (char c : word) {\\n      count[c - \\'0\\']++;\\n    }\\n\\n    int[] current = new int[2];\\n    for (char c : word) {\\n      int digit = c - \\'0\\';\\n      int revert = 1 - digit;\\n      result += (long) current[revert] * (count[revert] - current[revert]);\\n      current[digit]++;\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095002,
                "title": "c-o-n-o-n",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n\\n        vector<int> counts;  // how many of the other type seen at this point\\n        int total_0s = 0;\\n        int total_1s = 0;\\n\\n        for (char c: s) {\\n            if(c == \\'0\\') {\\n                total_0s++;\\n                counts.push_back(total_1s);\\n            } else if(c == \\'1\\') {\\n                total_1s++;\\n                counts.push_back(total_0s);\\n            } else {\\n                printf(\"!error\");\\n                exit(1);\\n            }\\n        } \\n\\n        long long res = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s[i];\\n            if (c == \\'0\\') {\\n                // 101\\n                // counts[i] is the number of 1s before the 0\\n                // total_1s - counts[i] is the number of 1s after the 0\\n                res += counts[i] * (total_1s - counts[i]);\\n            } else if (c == \\'1\\') {\\n                // 010 same logic as above\\n                res += counts[i] * (total_0s - counts[i]);\\n            } else {\\n                printf(\"!error\");\\n                exit(1);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n\\n        vector<int> counts;  // how many of the other type seen at this point\\n        int total_0s = 0;\\n        int total_1s = 0;\\n\\n        for (char c: s) {\\n            if(c == \\'0\\') {\\n                total_0s++;\\n                counts.push_back(total_1s);\\n            } else if(c == \\'1\\') {\\n                total_1s++;\\n                counts.push_back(total_0s);\\n            } else {\\n                printf(\"!error\");\\n                exit(1);\\n            }\\n        } \\n\\n        long long res = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s[i];\\n            if (c == \\'0\\') {\\n                // 101\\n                // counts[i] is the number of 1s before the 0\\n                // total_1s - counts[i] is the number of 1s after the 0\\n                res += counts[i] * (total_1s - counts[i]);\\n            } else if (c == \\'1\\') {\\n                // 010 same logic as above\\n                res += counts[i] * (total_0s - counts[i]);\\n            } else {\\n                printf(\"!error\");\\n                exit(1);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079798,
                "title": "python-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this case, the dp should not be initialized as a list, but it should be initalized as a hashmap.\\nIf a character in s is \\'1\\', then the way to select one \\'1\\' is incremented by 1, the way to select \\'101\\' is incremented by the way to select \\'10\\', and the way to select \\'01\\' is incremented by the way to select \\'0\\'.\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        dp = {\\'1\\':0, \\'0\\':0, \\'10\\':0, \\'01\\':0, \\'101\\':0, \\'010\\':0}\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\':\\n                dp[\\'0\\'] += 1\\n                dp[\\'10\\'] += dp[\\'1\\']\\n                dp[\\'010\\'] += dp[\\'01\\']\\n            else:\\n                dp[\\'1\\'] += 1\\n                dp[\\'01\\'] += dp[\\'0\\']\\n                dp[\\'101\\'] += dp[\\'10\\']\\n        \\n        return dp[\\'101\\'] + dp[\\'010\\']\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfWays(self, s: str) -> int:\\n        dp = {\\'1\\':0, \\'0\\':0, \\'10\\':0, \\'01\\':0, \\'101\\':0, \\'010\\':0}\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\':\\n                dp[\\'0\\'] += 1\\n                dp[\\'10\\'] += dp[\\'1\\']\\n                dp[\\'010\\'] += dp[\\'01\\']\\n            else:\\n                dp[\\'1\\'] += 1\\n                dp[\\'01\\'] += dp[\\'0\\']\\n                dp[\\'101\\'] += dp[\\'10\\']\\n        \\n        return dp[\\'101\\'] + dp[\\'010\\']\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069610,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDP - DAG or something similar. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt a position i, a valid sequence of length 3 = sum of valid sequence of length 2.\\n\\nA valid sequence of length 2 at position i can be defined by the frequency of the oposite number of i (For example, at i, s[i] = 0 -> valid sequence of length 2 at position i equals the frequency of 0 in front of i).\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long ans = 0;\\n\\n        int cnt0 = 0;\\n        int cnt1 = 0;\\n\\n        long long dp1 = 0;\\n        long long dp0 = 0;\\n\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'0\\') {\\n                cnt0++;\\n                ans += dp1;\\n                dp0 += cnt1;\\n            }\\n            else {\\n                cnt1++;\\n                ans += dp0;\\n                dp1 += cnt0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long numberOfWays(string s) {\\n        long long ans = 0;\\n\\n        int cnt0 = 0;\\n        int cnt1 = 0;\\n\\n        long long dp1 = 0;\\n        long long dp0 = 0;\\n\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'0\\') {\\n                cnt0++;\\n                ans += dp1;\\n                dp0 += cnt1;\\n            }\\n            else {\\n                cnt1++;\\n                ans += dp0;\\n                dp1 += cnt0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049446,
                "title": "o-n-linear-solution",
                "content": "# Intuition\\nWe are looking for 010 or 101 combinations.\\n\\n# Approach\\n[Note] : sorry for being long in explaining the approach. \\ncount all zeros (**numberOfzeros**) and all ones in (**numberOfOnes**)\\nfor any indx **i** we can check how many ways to build those combinations **010** or **101**\\ne:g **0010** assume you are at index **i = 2 => s[i] = 1** there are two zeros on the left **(i = 0, i = 1)** and one zero at right **(i = 3)**\\nthink of it, you can combine any zero of those two (**i = 0 or i =1**) from left with the current element **(i = 2)** in this case we can take one time **i = 0** with **i = 2** and also we can take **i = 1** with **i = 2** then two ways to build two numbers, this count caused by count of zeros on **left** **(2)**.\\ndo the same for zeros on **right** : we have only one zero at **(i = 3)** then there will be one way to build **10** product number of ways on left and right to get the possible ways to build **010** => **2 * 1**  and this is correct. \\n\\n**But wait ! how do we know count of zeros on left and right ?**\\nyou remember that we counted all zeros in string using (**numberOfzeros**). we can create another variable **tempZerosCountSoFar** and whenever we see any **\\'0\\'** using current index **i** increment **tempZerosCountSoFar**  by one. till you face **\\'1\\'** in this case i know the number of zeros on left and hence i can know number of zeros on right of current index by simply subtract **tempZerosCountSoFar** from (**numberOfzeros**). \\nand to get the total ways of combinarions : multiply count of zeros on left by count of zeros on right. and add it to the **count** variable which represents number of ways to build **010** or **101** \\n\\nDo the same for **101** in the same iteration. using **tempOnesCountSoFar**\\nand **numberOfOnes** variables. increment **tempOnesCountSoFar** when you face **\\'1\\'** and calculate number of ones on right simply by subtracting **tempOnesCountSoFar** from (**numberOfOnes**). \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar numberOfWays = function(s) {\\n    let numberOfzeros = 0, numberOfOnes = 0;\\n    for(let c of s) c === \\'0\\' ? numberOfzeros++ : numberOfOnes++;\\n    let tempZerosCountSoFar = 0;\\n    let tempOnesCountSoFar = 0;\\n    let count = 0;\\n    for(let c of s) {\\n        if(c === \\'1\\') {\\n            count += tempZerosCountSoFar * (numberOfzeros - tempZerosCountSoFar);\\n            tempOnesCountSoFar++;\\n        } else {\\n            count += tempOnesCountSoFar * (numberOfOnes - tempOnesCountSoFar);\\n            tempZerosCountSoFar++;\\n        }\\n    }\\n    return count;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar numberOfWays = function(s) {\\n    let numberOfzeros = 0, numberOfOnes = 0;\\n    for(let c of s) c === \\'0\\' ? numberOfzeros++ : numberOfOnes++;\\n    let tempZerosCountSoFar = 0;\\n    let tempOnesCountSoFar = 0;\\n    let count = 0;\\n    for(let c of s) {\\n        if(c === \\'1\\') {\\n            count += tempZerosCountSoFar * (numberOfzeros - tempZerosCountSoFar);\\n            tempOnesCountSoFar++;\\n        } else {\\n            count += tempOnesCountSoFar * (numberOfOnes - tempOnesCountSoFar);\\n            tempZerosCountSoFar++;\\n        }\\n    }\\n    return count;\\n};\\n\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1770173,
                "content": [
                    {
                        "username": "ctlang",
                        "content": "O(n^3) brute force solution so you might think O(n^2) would be good but it's not even close. I came up with a O(n) solution that nearly TLE'd.  There are single-pass solutions with soul crushing simplicity that require deep analysis to understand and it probably warrants a \"hard\".  Keep multiplication to a minimum or don't use it at all."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "dp is tricky since day 1. The complexity of new dp problems are just stacking up more information. But the general form of a dp problem never changed. "
                    },
                    {
                        "username": "tsnl42",
                        "content": "I think this problem is missing an additional constraint. The visitor can only travel down the street one-way. This means that for each selection of three buildings with indices $i_0$, $i_1$, and $i_2$, we have $i_1 < i_2 < i_3$"
                    },
                    {
                        "username": "chanhttg",
                        "content": "This would be a helpful constraint mentioned, although I\\'d understand if they decided not to use it in the description. Because this is another way of saying that every 3 chosen buildings are unique."
                    },
                    {
                        "username": "divyanshojha99",
                        "content": "This is Easy If you are good in Map can do"
                    }
                ]
            },
            {
                "id": 2017716,
                "content": [
                    {
                        "username": "ctlang",
                        "content": "O(n^3) brute force solution so you might think O(n^2) would be good but it's not even close. I came up with a O(n) solution that nearly TLE'd.  There are single-pass solutions with soul crushing simplicity that require deep analysis to understand and it probably warrants a \"hard\".  Keep multiplication to a minimum or don't use it at all."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "dp is tricky since day 1. The complexity of new dp problems are just stacking up more information. But the general form of a dp problem never changed. "
                    },
                    {
                        "username": "tsnl42",
                        "content": "I think this problem is missing an additional constraint. The visitor can only travel down the street one-way. This means that for each selection of three buildings with indices $i_0$, $i_1$, and $i_2$, we have $i_1 < i_2 < i_3$"
                    },
                    {
                        "username": "chanhttg",
                        "content": "This would be a helpful constraint mentioned, although I\\'d understand if they decided not to use it in the description. Because this is another way of saying that every 3 chosen buildings are unique."
                    },
                    {
                        "username": "divyanshojha99",
                        "content": "This is Easy If you are good in Map can do"
                    }
                ]
            },
            {
                "id": 2051832,
                "content": [
                    {
                        "username": "ctlang",
                        "content": "O(n^3) brute force solution so you might think O(n^2) would be good but it's not even close. I came up with a O(n) solution that nearly TLE'd.  There are single-pass solutions with soul crushing simplicity that require deep analysis to understand and it probably warrants a \"hard\".  Keep multiplication to a minimum or don't use it at all."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "dp is tricky since day 1. The complexity of new dp problems are just stacking up more information. But the general form of a dp problem never changed. "
                    },
                    {
                        "username": "tsnl42",
                        "content": "I think this problem is missing an additional constraint. The visitor can only travel down the street one-way. This means that for each selection of three buildings with indices $i_0$, $i_1$, and $i_2$, we have $i_1 < i_2 < i_3$"
                    },
                    {
                        "username": "chanhttg",
                        "content": "This would be a helpful constraint mentioned, although I\\'d understand if they decided not to use it in the description. Because this is another way of saying that every 3 chosen buildings are unique."
                    },
                    {
                        "username": "divyanshojha99",
                        "content": "This is Easy If you are good in Map can do"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimize Result by Adding Parentheses to Expression",
        "question_content": "<p>You are given a <strong>0-indexed</strong> string <code>expression</code> of the form <code>&quot;&lt;num1&gt;+&lt;num2&gt;&quot;</code> where <code>&lt;num1&gt;</code> and <code>&lt;num2&gt;</code> represent positive integers.</p>\n\n<p>Add a pair of parentheses to <code>expression</code> such that after the addition of parentheses, <code>expression</code> is a <strong>valid</strong> mathematical expression and evaluates to the <strong>smallest</strong> possible value. The left parenthesis <strong>must</strong> be added to the left of <code>&#39;+&#39;</code> and the right parenthesis <strong>must</strong> be added to the right of <code>&#39;+&#39;</code>.</p>\n\n<p>Return <code>expression</code><em> after adding a pair of parentheses such that </em><code>expression</code><em> evaluates to the <strong>smallest</strong> possible value.</em> If there are multiple answers that yield the same result, return any of them.</p>\n\n<p>The input has been generated such that the original value of <code>expression</code>, and the value of <code>expression</code> after adding any pair of parentheses that meets the requirements fits within a signed 32-bit integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;247+38&quot;\n<strong>Output:</strong> &quot;2(47+38)&quot;\n<strong>Explanation:</strong> The <code>expression</code> evaluates to 2 * (47 + 38) = 2 * 85 = 170.\nNote that &quot;2(4)7+38&quot; is invalid because the right parenthesis must be to the right of the <code>&#39;+&#39;</code>.\nIt can be shown that 170 is the smallest possible value.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;12+34&quot;\n<strong>Output:</strong> &quot;1(2+3)4&quot;\n<strong>Explanation:</strong> The expression evaluates to 1 * (2 + 3) * 4 = 1 * 5 * 4 = 20.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;999+999&quot;\n<strong>Output:</strong> &quot;(999+999)&quot;\n<strong>Explanation:</strong> The <code>expression</code> evaluates to 999 + 999 = 1998.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= expression.length &lt;= 10</code></li>\n\t<li><code>expression</code> consists of digits from <code>&#39;1&#39;</code> to <code>&#39;9&#39;</code> and <code>&#39;+&#39;</code>.</li>\n\t<li><code>expression</code> starts and ends with digits.</li>\n\t<li><code>expression</code> contains exactly one <code>&#39;+&#39;</code>.</li>\n\t<li>The original value of <code>expression</code>, and the value of <code>expression</code> after adding any pair of parentheses that meets the requirements fits within a signed 32-bit integer.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1931346,
                "title": "easy-to-understand-c-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string expr) {\\n        //First find the index of \\'+ in expresseion. let it be idx.\\n\\t\\tint idx;\\n        int n=expr.size();\\n        for(int i=0;i<n;i++)\\n            if(expr[i]==\\'+\\')\\n            {\\n                idx=i;\\n                break;\\n            }\\n\\t\\t\\t\\n\\t\\t//Now find two numbers which are on left and right side of \\'+\\' sign in expression\\t\\n        string num1 = expr.substr(0,idx);\\n        string num2 = expr.substr(idx+1,n-idx-1);\\n\\t\\t\\n\\t\\t//b1 and b2 are for brackets . b1=left bracket, b2=right bracket\\n        int b1=0,b2=0;\\n        int min =INT_MAX;\\n        string ans;\\n\\t\\t\\n\\t\\t//p1 and p2 are product number outside the brackets i.e our expresion is p1(sum)p2\\n        int p1,p2;\\n\\t\\t\\n\\t\\t//Find all possible conditions, iterate left bracket over num1 and right bracket over num2\\n        for(int b1=0;b1<num1.size();b1++)\\n        {\\n            for(int b2=0;b2<num2.size();b2++)\\n            {\\n                // s1 and s2 are strings which are outside the left parenthesis and right parenthesis respectively \\n                string s1=num1.substr(0,b1);\\n                string s2=num2.substr(b2+1,b2-num2.size()-1);\\n               \\n               //if any of the string is empty then its int value should be 1 else its same as string.\\n\\t\\t\\t   if(s1.empty())\\n                    p1=1;\\n                else\\n                    p1=stoi(num1.substr(0,b1));\\n                if(s2.empty())\\n                    p2=1;\\n                else\\n                    p2=stoi(num2.substr(b2+1,b2-num2.size()-1));\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t//sum stores the numerical value of the sum between the parenthesis\\t\\n                int sum=stoi(num1.substr(b1,num1.size())) + stoi(num2.substr(0,b2+1));\\n               //eval stores the numerical value of whole expression\\n\\t\\t\\t   int eval=p1*sum*p2;\\n\\t\\t\\t   \\n\\t\\t\\t   //if velue of expression is less then minimum, then make ans string = s1(sum) s1\\n                if(eval<min){\\n                    \\n                    min=eval;\\n                    ans=s1+\"(\"+num1.substr(b1,num1.size())+\"+\"+num2.substr(0,b2+1)+\")\"+s2;\\n                \\n                }\\n                \\n            }\\n        }\\n        return ans;\\n        //return final string\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string expr) {\\n        //First find the index of \\'+ in expresseion. let it be idx.\\n\\t\\tint idx;\\n        int n=expr.size();\\n        for(int i=0;i<n;i++)\\n            if(expr[i]==\\'+\\')\\n            {\\n                idx=i;\\n                break;\\n            }\\n\\t\\t\\t\\n\\t\\t//Now find two numbers which are on left and right side of \\'+\\' sign in expression\\t\\n        string num1 = expr.substr(0,idx);\\n        string num2 = expr.substr(idx+1,n-idx-1);\\n\\t\\t\\n\\t\\t//b1 and b2 are for brackets . b1=left bracket, b2=right bracket\\n        int b1=0,b2=0;\\n        int min =INT_MAX;\\n        string ans;\\n\\t\\t\\n\\t\\t//p1 and p2 are product number outside the brackets i.e our expresion is p1(sum)p2\\n        int p1,p2;\\n\\t\\t\\n\\t\\t//Find all possible conditions, iterate left bracket over num1 and right bracket over num2\\n        for(int b1=0;b1<num1.size();b1++)\\n        {\\n            for(int b2=0;b2<num2.size();b2++)\\n            {\\n                // s1 and s2 are strings which are outside the left parenthesis and right parenthesis respectively \\n                string s1=num1.substr(0,b1);\\n                string s2=num2.substr(b2+1,b2-num2.size()-1);\\n               \\n               //if any of the string is empty then its int value should be 1 else its same as string.\\n\\t\\t\\t   if(s1.empty())\\n                    p1=1;\\n                else\\n                    p1=stoi(num1.substr(0,b1));\\n                if(s2.empty())\\n                    p2=1;\\n                else\\n                    p2=stoi(num2.substr(b2+1,b2-num2.size()-1));\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t//sum stores the numerical value of the sum between the parenthesis\\t\\n                int sum=stoi(num1.substr(b1,num1.size())) + stoi(num2.substr(0,b2+1));\\n               //eval stores the numerical value of whole expression\\n\\t\\t\\t   int eval=p1*sum*p2;\\n\\t\\t\\t   \\n\\t\\t\\t   //if velue of expression is less then minimum, then make ans string = s1(sum) s1\\n                if(eval<min){\\n                    \\n                    min=eval;\\n                    ans=s1+\"(\"+num1.substr(b1,num1.size())+\"+\"+num2.substr(0,b2+1)+\")\"+s2;\\n                \\n                }\\n                \\n            }\\n        }\\n        return ans;\\n        //return final string\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931124,
                "title": "c-java-0-ms-easy-to-understand",
                "content": "Suppose we have expression  \"247+38\"\\nfor this we try to produce every possible string\\n\\nlike \\n1. (247+3)8\\n1. (247+38)\\n1. 2(47+3)8\\n1. 2(47+38)\\n1. 24(7+3)8\\n1. 24(7+38)\\n\\nafter generating every possible string ,\\nit get converted into 4 differnt numbers\\n\\n* a-> before the \\'(\\'\\n* b-> after \\'(\\' before \\'+\\'\\n* c-> after \\'+\\' before \\')\\'\\n* d-> after \\')\\'\\n\\nthen we know our ans will be a*(b+c)*d\\n\\nbut we know there is one **edge case **\\n(247+38)  in this a=d=0 , then we have to update a and d value to 1\\n\\n**Please Upvote the Post**\\n\\n**JAVA SOLUTION **\\n\\n```\\npublic String minimizeResult(String str) {\\n        int n=str.length();\\n        int idx=0;\\n        while(idx<n && str.charAt(idx)!=\\'+\\') idx++;\\n        idx++;\\n        int ans=1000000000;\\n        String res=\"\";\\n        for(int i=0;i<idx-1;i++){\\n            for(int j=idx;j<n;j++){\\n                StringBuilder sb=new StringBuilder(str);\\n                sb.insert(j+1,\\')\\');\\n                sb.insert(i,\\'(\\');\\n                \\n                int a=0,b=0,c=0,d=0,k=0;\\n                for(;sb.charAt(k)!=\\'(\\';k++){\\n                    a=a*10+(sb.charAt(k)-\\'0\\');\\n                }\\n                k++;\\n                for(;sb.charAt(k)!=\\'+\\';k++){\\n                    b=b*10+(sb.charAt(k)-\\'0\\');\\n                }\\n                k++;\\n                for(;sb.charAt(k)!=\\')\\';k++){\\n                    c=c*10+(sb.charAt(k)-\\'0\\');\\n                }\\n                k++;\\n                for(;k<sb.length();k++){\\n                    d=d*10+(sb.charAt(k)-\\'0\\');\\n                }\\n                b=b+c;\\n                if(a==0) a=1;\\n                if(d==0) d=1;\\n                \\n                int abc=a*b*d;\\n                if(abc<ans){\\n                    res=sb.toString();\\n                    ans=abc;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++ SOLUTION**\\n```\\n\\nstring minimizeResult(string str) {\\n        int n=str.length();\\n        int idx=0;\\n        while(idx<n && str[idx]!=\\'+\\') idx++;\\n        idx++;\\n        int ans=1000000000;\\n        string res=\"\";\\n        for(int i=0;i<idx-1;i++){\\n            for(int j=idx;j<n;j++){\\n                string sb=str.substr(0,i) + \"(\" + str.substr(i,j+1-i) + \")\" +str.substr(j+1,n);\\n                \\n                int a=0,b=0,c=0,d=0,k=0;\\n                for(;sb[k]!=\\'(\\';k++){\\n                    a=a*10+(sb[k]-\\'0\\');\\n                }\\n                k++;\\n                for(;sb[k]!=\\'+\\';k++){\\n                    b=b*10+(sb[k]-\\'0\\');\\n                }\\n                k++;\\n                for(;sb[k]!=\\')\\';k++){\\n                    c=c*10+(sb[k]-\\'0\\');\\n                }\\n                k++;\\n                for(;k<sb.length();k++){\\n                    d=d*10+(sb[k]-\\'0\\');\\n                }\\n                b=b+c;\\n                if(a==0) a=1;\\n                if(d==0) d=1;\\n                \\n                int abc=a*b*d;\\n                if(abc<ans){\\n                    res=sb;\\n                    ans=abc;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String minimizeResult(String str) {\\n        int n=str.length();\\n        int idx=0;\\n        while(idx<n && str.charAt(idx)!=\\'+\\') idx++;\\n        idx++;\\n        int ans=1000000000;\\n        String res=\"\";\\n        for(int i=0;i<idx-1;i++){\\n            for(int j=idx;j<n;j++){\\n                StringBuilder sb=new StringBuilder(str);\\n                sb.insert(j+1,\\')\\');\\n                sb.insert(i,\\'(\\');\\n                \\n                int a=0,b=0,c=0,d=0,k=0;\\n                for(;sb.charAt(k)!=\\'(\\';k++){\\n                    a=a*10+(sb.charAt(k)-\\'0\\');\\n                }\\n                k++;\\n                for(;sb.charAt(k)!=\\'+\\';k++){\\n                    b=b*10+(sb.charAt(k)-\\'0\\');\\n                }\\n                k++;\\n                for(;sb.charAt(k)!=\\')\\';k++){\\n                    c=c*10+(sb.charAt(k)-\\'0\\');\\n                }\\n                k++;\\n                for(;k<sb.length();k++){\\n                    d=d*10+(sb.charAt(k)-\\'0\\');\\n                }\\n                b=b+c;\\n                if(a==0) a=1;\\n                if(d==0) d=1;\\n                \\n                int abc=a*b*d;\\n                if(abc<ans){\\n                    res=sb.toString();\\n                    ans=abc;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1931496,
                "title": "generate-pairs",
                "content": "The code could be simpler, but here we try to limit string operations for efficiency.\\n\\nThe left side (before plus) and right side of the equation are independent. We can generate all possible pairs of `{mul, sum}` for each side. For example, for `\"247+38\"`, we will have:\\n- Left pairs (`lp`): \\n\\t- {0, 247} - we will use `1` as multiplier.\\n\\t- {2, 47}\\n\\t- {24, 7)\\n- Right pairs (`rp`):\\n\\t- {0, 38} - we will use `1` as multiplier.\\n\\t- {3, 8}\\n\\nThen, we will try all combination of those pairs to find the minimum result.\\n\\n**C++**\\n```cpp\\nstring minimizeResult(string exp) {\\n    int plus = exp.find(\\'+\\');\\n    vector<int> v;\\n    vector<pair<int, int>> lp, rp;\\n    for (int l = stoi(exp.substr(0, plus)), mul = 10; l * 10 >= mul; mul *= 10)\\n        lp.push_back({ l / mul, l % mul}); \\n    for (int r = stoi(exp.substr(plus + 1)), mul = 1; r / mul > 0; mul *= 10)\\n        rp.push_back({ r % mul, r / mul }); \\n    for (auto [m1, s1] : lp)\\n        for (auto [m2, s2]: rp)\\n            if (v.empty() || max(1, m1) * (s1 + s2) * max(1, m2) < max(1, v[0]) * (v[1] + v[2]) * max(1, v[3]))\\n                v = {m1, s1, s2, m2};\\n    return (v[0] ? to_string(v[0]) : \"\") + \"(\" + to_string(v[1]) \\n        + \"+\" + to_string(v[2]) + \")\" + (v[3] ? to_string(v[3]) : \"\");\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstring minimizeResult(string exp) {\\n    int plus = exp.find(\\'+\\');\\n    vector<int> v;\\n    vector<pair<int, int>> lp, rp;\\n    for (int l = stoi(exp.substr(0, plus)), mul = 10; l * 10 >= mul; mul *= 10)\\n        lp.push_back({ l / mul, l % mul}); \\n    for (int r = stoi(exp.substr(plus + 1)), mul = 1; r / mul > 0; mul *= 10)\\n        rp.push_back({ r % mul, r / mul }); \\n    for (auto [m1, s1] : lp)\\n        for (auto [m2, s2]: rp)\\n            if (v.empty() || max(1, m1) * (s1 + s2) * max(1, m2) < max(1, v[0]) * (v[1] + v[2]) * max(1, v[3]))\\n                v = {m1, s1, s2, m2};\\n    return (v[0] ? to_string(v[0]) : \"\") + \"(\" + to_string(v[1]) \\n        + \"+\" + to_string(v[2]) + \")\" + (v[3] ? to_string(v[3]) : \"\");\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1931441,
                "title": "o-1-space-inplace-with-explanation-100-faster-in-time-and-space",
                "content": "**Intuition**:\\nTry every possible combination and get the answer with minimum answer.\\n\\n**Explanation**:\\n# There will two parts majorly:\\n+ 0-index to index having \\'+\\'\\n+ index(\\'+\\')+1 to last\\n\\nThe **first part** can be atmost divided into two more subparts while partitioning.\\nThe **second part** can be atmost divided into two more subparts while partitioning.\\n\\nOur outer loop will be from **0** to **index having +**.\\nOur inner loop will be from **index having \\'+\\'** to **n-1**.\\n\\nSo in this way we will get **4 different set of integers by partitioning** and for **every 4 sets of integers we will find its result** and **we will keep updating two variables having the start index of \\'(\\' and index of \\')\\'**.\\n\\n**Apply Formula between every 4 integer and get one with minimum** : \\n>n1 * (n2+n3) * n4 \\n\\nAt last we will have **our minimum answer in variable** and **position in a and b**.\\nWe will just put the brackets at **a** and **b** position.\\n\\n# C++\\n\\n    string minimizeResult(string exp) {\\n        int mn= INT_MAX, a=-1,b=-1 ,n= exp.size(), plus=exp.find(\\'+\\');\\n        for(int i=0;i<plus;i++){\\n            for(int j=plus+1;j<n;j++){\\n                //extract 4 Integers\\n                int n1= stoi(exp.substr(0,i)==\"\"?\"1\":exp.substr(0,i));   //from 0 to i index we have one integer\\n                int n2= stoi(exp.substr(i,plus-i));                      //from i to plus-1 index -> we have one integer\\n                int n3= stoi(exp.substr(plus+1,j-plus));                 //from plus+1 index to j , we have one value\\n                int n4= stoi(exp.substr(j+1)==\"\"?\"1\":exp.substr(j+1));   //from j to last we have one value\\n                //update minimum by updating a and b variable\\n                if(n1*(n2+n3)*n4<mn) mn= n1*(n2+n3)*n4 ,a=i ,b=j+1;\\n            }\\n        }\\n        //insert \"(\" at a-position and \")\" at b-position we captured above\\n        exp.insert(a,\"(\");\\n        if(b==n) exp+=\")\";   else exp.insert(b+1,\")\");\\n        return exp;\\n    }\\n\\t\\n**Time** - O(n^3)\\n**Space** - O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "**Intuition**:\\nTry every possible combination and get the answer with minimum answer.\\n\\n**Explanation**:\\n# There will two parts majorly:\\n+ 0-index to index having \\'+\\'\\n+ index(\\'+\\')+1 to last\\n\\nThe **first part** can be atmost divided into two more subparts while partitioning.\\nThe **second part** can be atmost divided into two more subparts while partitioning.\\n\\nOur outer loop will be from **0** to **index having +**.\\nOur inner loop will be from **index having \\'+\\'** to **n-1**.\\n\\nSo in this way we will get **4 different set of integers by partitioning** and for **every 4 sets of integers we will find its result** and **we will keep updating two variables having the start index of \\'(\\' and index of \\')\\'**.\\n\\n**Apply Formula between every 4 integer and get one with minimum** : \\n>n1 * (n2+n3) * n4 \\n\\nAt last we will have **our minimum answer in variable** and **position in a and b**.\\nWe will just put the brackets at **a** and **b** position.\\n\\n# C++\\n\\n    string minimizeResult(string exp) {\\n        int mn= INT_MAX, a=-1,b=-1 ,n= exp.size(), plus=exp.find(\\'+\\');\\n        for(int i=0;i<plus;i++){\\n            for(int j=plus+1;j<n;j++){\\n                //extract 4 Integers\\n                int n1= stoi(exp.substr(0,i)==\"\"?\"1\":exp.substr(0,i));   //from 0 to i index we have one integer\\n                int n2= stoi(exp.substr(i,plus-i));                      //from i to plus-1 index -> we have one integer\\n                int n3= stoi(exp.substr(plus+1,j-plus));                 //from plus+1 index to j , we have one value\\n                int n4= stoi(exp.substr(j+1)==\"\"?\"1\":exp.substr(j+1));   //from j to last we have one value\\n                //update minimum by updating a and b variable\\n                if(n1*(n2+n3)*n4<mn) mn= n1*(n2+n3)*n4 ,a=i ,b=j+1;\\n            }\\n        }\\n        //insert \"(\" at a-position and \")\" at b-position we captured above\\n        exp.insert(a,\"(\");\\n        if(b==n) exp+=\")\";   else exp.insert(b+1,\")\");\\n        return exp;\\n    }\\n\\t\\n**Time** - O(n^3)\\n**Space** - O(1)",
                "codeTag": "Unknown"
            },
            {
                "id": 1931208,
                "title": "java-easy-to-understand",
                "content": "We have two numbers `left` and `right`.\\nAdd Open parenthesis at these poitions for `left`  : (0 , left.length()-1)\\nAdd Close parenthesis at these poitions for `right` :  (1 , right.length()).\\n\\nFor `left` , multiple will be on the left of the paranthesis and for `right` multiple will be on right.\\n\\nGet multiple and remaining number for both left and right, and create the final sum.\\n\\n```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        String[] sp = expression.split(\"\\\\\\\\+\");\\n        String left = sp[0];\\n        String right = sp[1];\\n        \\n        int min = Integer.MAX_VALUE;\\n        String result = \"(\" + expression + \")\";\\n\\t\\t\\n        for(int i=0; i<left.length(); i++) { //Index at which we add `(`  for left\\n            int leftMul = left.substring(0, i).equals(\"\") ? 1 : Integer.parseInt(left.substring(0,i));\\n            int leftNum = Integer.parseInt(left.substring(i));\\n            \\n            for(int j=1; j<=right.length(); j++) { //Index at which we add `)` for right\\n                int rightMul = right.substring(j).equals(\"\") ? 1 : Integer.parseInt(right.substring(j));\\n                int rightNum = Integer.parseInt(right.substring(0,j));\\n                \\n                int sum = leftMul * (leftNum + rightNum) * rightMul;\\n                if(sum < min) {\\n                    min = sum;\\n                    result = left.substring(0, i) + \"(\" + left.substring(i) + \"+\" + right.substring(0, j) + \")\" + right.substring(j);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        String[] sp = expression.split(\"\\\\\\\\+\");\\n        String left = sp[0];\\n        String right = sp[1];\\n        \\n        int min = Integer.MAX_VALUE;\\n        String result = \"(\" + expression + \")\";\\n\\t\\t\\n        for(int i=0; i<left.length(); i++) { //Index at which we add `(`  for left\\n            int leftMul = left.substring(0, i).equals(\"\") ? 1 : Integer.parseInt(left.substring(0,i));\\n            int leftNum = Integer.parseInt(left.substring(i));\\n            \\n            for(int j=1; j<=right.length(); j++) { //Index at which we add `)` for right\\n                int rightMul = right.substring(j).equals(\"\") ? 1 : Integer.parseInt(right.substring(j));\\n                int rightNum = Integer.parseInt(right.substring(0,j));\\n                \\n                int sum = leftMul * (leftNum + rightNum) * rightMul;\\n                if(sum < min) {\\n                    min = sum;\\n                    result = left.substring(0, i) + \"(\" + left.substring(i) + \"+\" + right.substring(0, j) + \")\" + right.substring(j);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931004,
                "title": "python-solution-using-2-pointers-brute-force",
                "content": "*Since the given maximum size is only 10, we can easily cover all possible options without TLE. Thus we use 2 pointers to cover all options.*\\n\\n**STEPS**\\n1. Traverse two pointers `l` & `r`. **L** pointer goes from 0 to **plus_index** and **R** pointer goes from **plus_index+1** to **N**. **plus_index** is the index of \\'+\\' in the expression. The **L** pointer is the position of \\'(\\' and **R** is for \\')\\'.\\n2. Use f string formatting to generate a expression. \\n3. Use evaulate function to get the result of the following expression.\\n4. If the new result is better than the old one, then update otherwise continue.\\n \\n**NOTE** \\n\\u27A1\\uFE0F**The `evaluate` function basically converts \"23(44+91)2\" into  \"23 X (44+91) X 2\" without ever having any * sign in the edges(used strip methods for that). `eval()` is a library function that evaluates a mathematical expression given in string form.**\\n\\u27A1\\uFE0F **`ans` is a list of 2 values, first is the smalles result of any expression and second is the expression itself.**\\n\\n**CODE**\\n```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        plus_index, n, ans = expression.find(\\'+\\'), len(expression), [float(inf),expression] \\n        def evaluate(exps: str):\\n            return eval(exps.replace(\\'(\\',\\'*(\\').replace(\\')\\', \\')*\\').lstrip(\\'*\\').rstrip(\\'*\\'))\\n        for l in range(plus_index):\\n            for r in range(plus_index+1, n):\\n                exps = f\\'{expression[:l]}({expression[l:plus_index]}+{expression[plus_index+1:r+1]}){expression[r+1:n]}\\'\\n                res = evaluate(exps)\\n                if ans[0] > res:\\n                    ans[0], ans[1] = res, exps\\n        return ans[1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        plus_index, n, ans = expression.find(\\'+\\'), len(expression), [float(inf),expression] \\n        def evaluate(exps: str):\\n            return eval(exps.replace(\\'(\\',\\'*(\\').replace(\\')\\', \\')*\\').lstrip(\\'*\\').rstrip(\\'*\\'))\\n        for l in range(plus_index):\\n            for r in range(plus_index+1, n):\\n                exps = f\\'{expression[:l]}({expression[l:plus_index]}+{expression[plus_index+1:r+1]}){expression[r+1:n]}\\'\\n                res = evaluate(exps)\\n                if ans[0] > res:\\n                    ans[0], ans[1] = res, exps\\n        return ans[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931007,
                "title": "c-o-1-space-brute-force-100-faster",
                "content": "**Approach**\\n```\\n1. Checking for positions\\n\"247+38\" --> \\n                     1st->   24(7+3)8 // one option\\n\\t\\t\\t\\t\\t 2nd-> 24(7+38) // 2nd option\\n\\t\\t\\t\\t\\t 3rd-> 2(47+3)8 //3rd option\\n\\t\\t\\t\\t\\t .... and many like these\\n\\t\\t\\t\\t\\t \\n2. calculate value for the left of opening bracket and between\\nbrackets and right of closing bracket\\n```\\n\\n\\n**CODE**\\n```\\nclass Solution {\\npublic:\\n    string minimizeResult(string expression) {\\n        bool plus = false;\\n        string a = \"\",b=\"\";\\n        for(char ch : expression){\\n            if(ch == \\'+\\'){\\n                plus = true;\\n            }\\n            if(!plus) a+=ch;\\n            else b+=ch;\\n        }\\n        \\n        int n = a.length();\\n        int m = b.length();\\n        string ans;\\n        int maxi = INT_MAX;\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 1 ; j < m ; j++){\\n                int left;\\n                if(i==0) left = 1;\\n                else left = stoi(a.substr(0,i));\\n                \\n                int middle = stoi(a.substr(i,n-i))+stoi(b.substr(0,j+1));\\n                \\n                int right;\\n                if(j==m-1)right = 1;\\n                else right = stoi(b.substr(j+1,m-j-1));\\n                \\n                if(left*middle*right < maxi){\\n                    maxi = left*middle*right;\\n                    ans = a.substr(0,i) + \"(\"+ a.substr(i,n-i) + b.substr(0,j+1) + \")\" + b.substr(j+1,m-j-1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n1. Checking for positions\\n\"247+38\" --> \\n                     1st->   24(7+3)8 // one option\\n\\t\\t\\t\\t\\t 2nd-> 24(7+38) // 2nd option\\n\\t\\t\\t\\t\\t 3rd-> 2(47+3)8 //3rd option\\n\\t\\t\\t\\t\\t .... and many like these\\n\\t\\t\\t\\t\\t \\n2. calculate value for the left of opening bracket and between\\nbrackets and right of closing bracket\\n```\n```\\nclass Solution {\\npublic:\\n    string minimizeResult(string expression) {\\n        bool plus = false;\\n        string a = \"\",b=\"\";\\n        for(char ch : expression){\\n            if(ch == \\'+\\'){\\n                plus = true;\\n            }\\n            if(!plus) a+=ch;\\n            else b+=ch;\\n        }\\n        \\n        int n = a.length();\\n        int m = b.length();\\n        string ans;\\n        int maxi = INT_MAX;\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 1 ; j < m ; j++){\\n                int left;\\n                if(i==0) left = 1;\\n                else left = stoi(a.substr(0,i));\\n                \\n                int middle = stoi(a.substr(i,n-i))+stoi(b.substr(0,j+1));\\n                \\n                int right;\\n                if(j==m-1)right = 1;\\n                else right = stoi(b.substr(j+1,m-j-1));\\n                \\n                if(left*middle*right < maxi){\\n                    maxi = left*middle*right;\\n                    ans = a.substr(0,i) + \"(\"+ a.substr(i,n-i) + b.substr(0,j+1) + \")\" + b.substr(j+1,m-j-1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932743,
                "title": "c-short-easy-to-write-code",
                "content": "Justr try all possibilites before and after \\'+\\' symbol.\\n\\neg: expression = \"247+38\"\\n```\\n(247+3)8 -> 2000\\n(247+38) -> 285\\n2(47+3)8 -> 800\\n2(47+38) -> 170\\n24(7+3)8 -> 1920\\n24(7+38) -> 1080\\n```\\n\\n##### C++ Code - 4ms\\n```cpp\\nstring minimizeResult(string s) {\\n    int plus = s.find(\\'+\\');\\n\\tint minres = INT_MAX, n = s.size();\\n    string res = \"\";\\n\\n    for (int i = 0; i < plus; i++) {\\n        for (int j = plus + 1; j < n; j++) {\\n            string a = s.substr(0, i);\\n            string b = s.substr(i, plus - i);\\n            string c = s.substr(plus + 1, j - plus);\\n            string d = s.substr(j + 1);\\n\\n            int p = a == \"\" ? 1 : stoi(a);\\n            int q = b == \"\" ? 1 : stoi(b);\\n            int r = c == \"\" ? 1 : stoi(c);\\n            int s = d == \"\" ? 1 : stoi(d);\\n\\n            int temp = p * (q + r) * s;\\n            if (temp < minres) {\\n                minres = temp;\\n                res = a + \"(\" + b + \"+\" + c + \")\" + d;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n(247+3)8 -> 2000\\n(247+38) -> 285\\n2(47+3)8 -> 800\\n2(47+38) -> 170\\n24(7+3)8 -> 1920\\n24(7+38) -> 1080\\n```\n```cpp\\nstring minimizeResult(string s) {\\n    int plus = s.find(\\'+\\');\\n\\tint minres = INT_MAX, n = s.size();\\n    string res = \"\";\\n\\n    for (int i = 0; i < plus; i++) {\\n        for (int j = plus + 1; j < n; j++) {\\n            string a = s.substr(0, i);\\n            string b = s.substr(i, plus - i);\\n            string c = s.substr(plus + 1, j - plus);\\n            string d = s.substr(j + 1);\\n\\n            int p = a == \"\" ? 1 : stoi(a);\\n            int q = b == \"\" ? 1 : stoi(b);\\n            int r = c == \"\" ? 1 : stoi(c);\\n            int s = d == \"\" ? 1 : stoi(d);\\n\\n            int temp = p * (q + r) * s;\\n            if (temp < minres) {\\n                minres = temp;\\n                res = a + \"(\" + b + \"+\" + c + \")\" + d;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1932601,
                "title": "intuitive-simple-python-code-with-explanation",
                "content": "Break the expresion into four numbers like **expresion = first + second**. Then break both left and right into two numbers: **first = num1, num2** and **second = num 3 and num 4**. Calculate the result with of these four numbers with the equation: **num1(num2 + num3)num4** , and keep track of the minimal result. Once a minimal found, update the result\\n\\n\\n```\\nclass Solution(object):\\n    def minimizeResult(self, expression):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: str\\n        \"\"\"\\n        first, second = expression.split(\\'+\\')\\n        score = float(\\'inf\\')\\n        res = \\'\\'\\n        for i in range(len(first)):\\n            num_1 = int(first[:i]) if i != 0 else 1\\n            num_2 = int(first[i:])\\n            for j in range(1, len(second) + 1):\\n                num_3 = int(second[:j])\\n                num_4 = int(second[j:]) if j != len(second) else 1\\n                cur_score = num_1*(num_2 + num_3)*num_4\\n                if cur_score < score:\\n                    res = first[:i] + \\'(\\' + first[i:] + \\'+\\' + second[:j] + \\')\\' + second[j:]\\n                    score = cur_score\\n\\n        return res\\n```",
                "solutionTags": [
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimizeResult(self, expression):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: str\\n        \"\"\"\\n        first, second = expression.split(\\'+\\')\\n        score = float(\\'inf\\')\\n        res = \\'\\'\\n        for i in range(len(first)):\\n            num_1 = int(first[:i]) if i != 0 else 1\\n            num_2 = int(first[i:])\\n            for j in range(1, len(second) + 1):\\n                num_3 = int(second[:j])\\n                num_4 = int(second[j:]) if j != len(second) else 1\\n                cur_score = num_1*(num_2 + num_3)*num_4\\n                if cur_score < score:\\n                    res = first[:i] + \\'(\\' + first[i:] + \\'+\\' + second[:j] + \\')\\' + second[j:]\\n                    score = cur_score\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931181,
                "title": "c-100-faster-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int func(string& e,int i,int j,int p){\\n        int a=1;\\n        if(i>0) a=stoi(e.substr(0,i));\\n        int b=stoi(e.substr(i,p-i));\\n        int c=stoi(e.substr(p+1,j-p));\\n        int d=1;\\n        if(j+1<e.size()) d=stoi(e.substr(j+1,e.size()-j));\\n        return a*(b+c)*d;\\n    }\\n    string minimizeResult(string e) {\\n        int p=0;                      //will store the index of \\'+\\'\\n        for(p=0;p<e.size();p++){\\n            if(e[p]==\\'+\\') break;\\n        }\\n        int ans=INT_MAX;              // will store the minimum possible value\\n        string res;\\n        for(int i=0;i<p;i++){                         // i-> where we will add \\'(\\'\\n            for(int j=p+1;j<e.size();j++){            // j-> where we will add \\')\\'\\n                int val=func(e,i,j,p);                // try every possible way \\n                if(val<ans){\\n                    ans=val;\\n                    res=e;\\n                    res.insert(j+1,1,\\')\\');\\n                    res.insert(i,1,\\'(\\');\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int func(string& e,int i,int j,int p){\\n        int a=1;\\n        if(i>0) a=stoi(e.substr(0,i));\\n        int b=stoi(e.substr(i,p-i));\\n        int c=stoi(e.substr(p+1,j-p));\\n        int d=1;\\n        if(j+1<e.size()) d=stoi(e.substr(j+1,e.size()-j));\\n        return a*(b+c)*d;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2840489,
                "title": "python-3-5-lines-w-example-t-m-82-99",
                "content": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:                   #   Example:  \"247+38\" \\n                                                                        #   left, right = \"247\",\"38\"\\n        left, right = expression.split(\\'+\\')                             \\n        value = lambda s:eval(s.replace(\\'(\\',\\'*(\\').replace(\\')\\',\\')*\\').strip(\\'*\\'))    \\n                                                                           \\n        lft = [ left[0:i]+\\'(\\'+ left[i:] for i in range(  len(left )  )] #   lft = [\\'(247\\', \\'2(47\\', \\'24(7\\']\\n        rgt = [right[0:i]+\\')\\'+right[i:] for i in range(1,len(right)+1)] #   rgt = [\\'3)8\\', \\'38)\\']\\n       \\n        return  min([l+\\'+\\'+r for l in lft for r in rgt], key = value)   #   = min[(247+3)8,(247+38),2(47+3)8,2(47+38),24(7+3)8,24(7+38)]\\n                                                                        #             |       |         |        |        |        |   \\n                                                                        #           2000     285       800      170     1920     1080   \\n                                                                        #                                        |\\n                                                                        #                                   return 2(47+38)\\n\\n```\\n[https://leetcode.com/submissions/detail/848284729/](http://)\\n\\nI could be wrong, but I think time complexity is *O*(*N*^2) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:                   #   Example:  \"247+38\" \\n                                                                        #   left, right = \"247\",\"38\"\\n        left, right = expression.split(\\'+\\')                             \\n        value = lambda s:eval(s.replace(\\'(\\',\\'*(\\').replace(\\')\\',\\')*\\').strip(\\'*\\'))    \\n                                                                           \\n        lft = [ left[0:i]+\\'(\\'+ left[i:] for i in range(  len(left )  )] #   lft = [\\'(247\\', \\'2(47\\', \\'24(7\\']\\n        rgt = [right[0:i]+\\')\\'+right[i:] for i in range(1,len(right)+1)] #   rgt = [\\'3)8\\', \\'38)\\']\\n       \\n        return  min([l+\\'+\\'+r for l in lft for r in rgt], key = value)   #   = min[(247+3)8,(247+38),2(47+3)8,2(47+38),24(7+3)8,24(7+38)]\\n                                                                        #             |       |         |        |        |        |   \\n                                                                        #           2000     285       800      170     1920     1080   \\n                                                                        #                                        |\\n                                                                        #                                   return 2(47+38)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937473,
                "title": "understandable-java-code-with-inline-comments",
                "content": "4 cases that are possible for every expression given in form (ab+cd) -\\n* a(b+c)d\\n* ab+cd\\n* a(b+cd)\\n* (ab+c)d\\n```\\npublic int multiplier(String s){\\n//if string is empty return 1\\n        if(s.equals(\"\"))\\n            return 1;\\n        return Integer.parseInt(s);\\n    }\\n    public int evaluate(String s){\\n\\t//evaluate the addition the string\\n        int plus=s.indexOf(\\'+\\');\\n        return Integer.parseInt(s.substring(0,plus))+Integer.parseInt(s.substring(plus+1,s.length()));\\n    }\\n    public String minimizeResult(String exp) {\\n\\t//get the index of \\'+\\' sign\\n        int plus=exp.indexOf(\\'+\\');\\n\\t\\t//initialize ans with max value of integer\\n        int ans=Integer.MAX_VALUE;\\n\\t\\t//intialized left bracket index, lb=-1 & right bracket index, rb=-1\\n        int lb=-1, rb=-1;\\n        for(int i=0;i<plus;i++){\\n\\t\\t//get the mul1 which is the number to be multiplied before plus sign\\n            int mul1=multiplier(exp.substring(0,i));\\n            for(int j=plus+1;j<exp.length();j++){\\n\\t\\t\\t// get the mul2 which is the number to be multiplied after plus sign expression evaluation\\n                int mul2=multiplier(exp.substring(j+1,exp.length()));\\n\\t\\t\\t\\t//evaluate currentAnswer {cans} for every pair of i and j\\n                int cans=mul1*evaluate(exp.substring(i,j+1))*mul2;\\n                if(cans<ans){\\n\\t\\t\\t\\t//if current answer is smaller than answer, then \\'i\\' is the index where we have to place left bracket and \\'j+1\\' is the index where we have to place right bracket\\n                    ans=cans;\\n                    lb=i;\\n                    rb=j+1;\\n                }\\n            }\\n        }\\n\\t\\t//add left and right bracket to the specific index in expression to get the answer\\n        String res=exp.substring(0,lb)+\"(\"+exp.substring(lb,rb)+\")\"+exp.substring(rb);\\n        return res;\\n```\\n\\n<strong>~~Upvote~~</strong>",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int multiplier(String s){\\n//if string is empty return 1\\n        if(s.equals(\"\"))\\n            return 1;\\n        return Integer.parseInt(s);\\n    }\\n    public int evaluate(String s){\\n\\t//evaluate the addition the string\\n        int plus=s.indexOf(\\'+\\');\\n        return Integer.parseInt(s.substring(0,plus))+Integer.parseInt(s.substring(plus+1,s.length()));\\n    }\\n    public String minimizeResult(String exp) {\\n\\t//get the index of \\'+\\' sign\\n        int plus=exp.indexOf(\\'+\\');\\n\\t\\t//initialize ans with max value of integer\\n        int ans=Integer.MAX_VALUE;\\n\\t\\t//intialized left bracket index, lb=-1 & right bracket index, rb=-1\\n        int lb=-1, rb=-1;\\n        for(int i=0;i<plus;i++){\\n\\t\\t//get the mul1 which is the number to be multiplied before plus sign\\n            int mul1=multiplier(exp.substring(0,i));\\n            for(int j=plus+1;j<exp.length();j++){\\n\\t\\t\\t// get the mul2 which is the number to be multiplied after plus sign expression evaluation\\n                int mul2=multiplier(exp.substring(j+1,exp.length()));\\n\\t\\t\\t\\t//evaluate currentAnswer {cans} for every pair of i and j\\n                int cans=mul1*evaluate(exp.substring(i,j+1))*mul2;\\n                if(cans<ans){\\n\\t\\t\\t\\t//if current answer is smaller than answer, then \\'i\\' is the index where we have to place left bracket and \\'j+1\\' is the index where we have to place right bracket\\n                    ans=cans;\\n                    lb=i;\\n                    rb=j+1;\\n                }\\n            }\\n        }\\n\\t\\t//add left and right bracket to the specific index in expression to get the answer\\n        String res=exp.substring(0,lb)+\"(\"+exp.substring(lb,rb)+\")\"+exp.substring(rb);\\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1961565,
                "title": "c-code-intuitive-approach",
                "content": "The intuition is to divide the string into 4 parts , you can refer to the picture below\\n![image](https://assets.leetcode.com/users/images/91e5ae93-6d51-4cc1-a9ac-283cc480d737_1650303402.9499226.jpeg)\\n \\nCode here:\\n\\n\\n    string minimizeResult(string s) {\\n        int n=s.size();\\n        int plus=-1;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'+\\'){\\n                plus=i;\\n                break;\\n            }\\n        }\\n        int mini=INT_MAX,posi=-1,posj=-1;\\n        string finals=\"\";\\n        \\n        for(int i=plus-1;i>=0;i--){\\n            for(int j=plus+1;j<n;j++){\\n\\t\\t\\t\\n\\t\\t\\t   //four parts of the string\\n\\t\\t\\t   \\n                string plus1=s.substr(i,plus-i);\\n                string plus2=s.substr(plus+1,j-plus);\\n                string muls1=s.substr(0,i);\\n                string muls2=s.substr(j+1,n-j+1);\\n                \\n                //cout<<muls1<<\"<->\"<<plus1<<\"<->\"<<plus2<<\"<->\"<<muls2<<\"\\\\n\";\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//Below is the computed value for bracketted string\\n                \\n                string val=muls1+\\'(\\'+ plus1 + \\'+\\'+plus2+\\')\\'+muls2;\\n                int ans=stoi(plus1)+stoi(plus2);\\n                if(muls1!=\"\") ans=ans*(stoi(muls1));\\n                if(muls2!=\"\") ans=ans*(stoi(muls2));\\n                \\n                if(ans<mini){\\n                    mini=ans;\\n                    finals=val;\\n                }\\n                \\n            }\\n        }\\n        \\n        return finals;\\n    }",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "The intuition is to divide the string into 4 parts , you can refer to the picture below\\n![image](https://assets.leetcode.com/users/images/91e5ae93-6d51-4cc1-a9ac-283cc480d737_1650303402.9499226.jpeg)\\n \\nCode here:\\n\\n\\n    string minimizeResult(string s) {\\n        int n=s.size();\\n        int plus=-1;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'+\\'){\\n                plus=i;\\n                break;\\n            }\\n        }\\n        int mini=INT_MAX,posi=-1,posj=-1;\\n        string finals=\"\";\\n        \\n        for(int i=plus-1;i>=0;i--){\\n            for(int j=plus+1;j<n;j++){\\n\\t\\t\\t\\n\\t\\t\\t   //four parts of the string\\n\\t\\t\\t   \\n                string plus1=s.substr(i,plus-i);\\n                string plus2=s.substr(plus+1,j-plus);\\n                string muls1=s.substr(0,i);\\n                string muls2=s.substr(j+1,n-j+1);\\n                \\n                //cout<<muls1<<\"<->\"<<plus1<<\"<->\"<<plus2<<\"<->\"<<muls2<<\"\\\\n\";\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//Below is the computed value for bracketted string\\n                \\n                string val=muls1+\\'(\\'+ plus1 + \\'+\\'+plus2+\\')\\'+muls2;\\n                int ans=stoi(plus1)+stoi(plus2);\\n                if(muls1!=\"\") ans=ans*(stoi(muls1));\\n                if(muls2!=\"\") ans=ans*(stoi(muls2));\\n                \\n                if(ans<mini){\\n                    mini=ans;\\n                    finals=val;\\n                }\\n                \\n            }\\n        }\\n        \\n        return finals;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1948200,
                "title": "solutions-are-for-kids-legends-take-hint-just-two-for-loop",
                "content": "# Idea:\\n**Note: Basic formula for calculation is` a*(b+c)*d`**\\n1. Split the num1 and num2 from \\'+\\'\\n2. Set minTillNow = inf\\n3. Set expression = \\'\\'\\n4. Can we iterate on num2 for each index of num1 ?  yes surely, That will pave us way to try all combination.\\n```\\nfor i in range(len(num1)):\\n\\t// find a and b\\n\\t    for j in range(len(num2)): \\n\\t\\t// find c and d\\n\\t\\t// Calculate current = a*(b+c)*d\\n\\t\\t// if current < minTillNow:\\n\\t\\t\\t//Set the minTillNow = current\\n\\t\\t\\t// store the expression = \"{}({}+{}){}\".format(a,b,c,d)\\n\\t\\t\\t\\n\\t\\t\\t// Then you will have to handle cases where a and d is to be removed from the expression. Can you think on it ??\\n```\\n5. *Don\\'t want to spoil your fun of understanding the code. Try to DIY and debug. You will probably awaken your Sharingan!! XD while reading the code. Still if you dont understand any section of the code. Do drop a comment coz im happy to help.*\\n\\n**I was kidding before when I said *solutions are for kids*. It takes immense amount of debugging skills to read someone\\'s code.**\\n\\n**Code:**\\n\\n```\\nclass Solution:\\n    def minimizeResult(self, exp: str) -> str:\\n        num1, num2 = exp.split(\\'+\\')\\n        minTillNow = inf\\n        expression = \\'\\'\\n        for i in range(len(num1)):\\n            a = int(num1[:i] or 1)\\n            b = int(num1[i:])\\n            for j in range(1, len(num2) + 1):\\n                c = int(num2[:j])\\n                d = int(num2[j:] or 1)\\n                current = a*(b+c)*d\\n                if current < result:\\n                    minTillNow = current\\n                    expression = \"{}({}+{}){}\".format(a,b,c,d)\\n                    if i == 0: #Removing a = 1 if i = 0\\n                        expression = expression[1:]\\n                    if j == len(num2): #Removing d = 1 if j = len(num2)\\n                        expression = expression[:-1]\\n                    \\n                          \\n        return expression\\n```\\n\\n# Help Yourself: Python string slicing\\nFor those people who didnt understand **a = int(num1[:i] or 1)**\\nLet\\'s understand using an example num1 = \\'2345\\'\\n```\\ni = 0 -->  num1[:0] --> a= \\'\\'\\ni = 1 -->  num1[:1] --> a=\\'2\\'\\ni = 2 -->  num1[:2] --> a=\\'23\\'\\ni = 3 -->  num1[:3] --> a=\\'234\\'\\ni = 4 -->  num1[:4] --> a=\\'2345\\'\\n\\n// But wait!! We dont want null values during calculation. Hence, for a = \\'\\', set a = 1\\ni = 0 --> int(num1[:0] or 1) --> a= 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfor i in range(len(num1)):\\n\\t// find a and b\\n\\t    for j in range(len(num2)): \\n\\t\\t// find c and d\\n\\t\\t// Calculate current = a*(b+c)*d\\n\\t\\t// if current < minTillNow:\\n\\t\\t\\t//Set the minTillNow = current\\n\\t\\t\\t// store the expression = \"{}({}+{}){}\".format(a,b,c,d)\\n\\t\\t\\t\\n\\t\\t\\t// Then you will have to handle cases where a and d is to be removed from the expression. Can you think on it ??\\n```\n```\\nclass Solution:\\n    def minimizeResult(self, exp: str) -> str:\\n        num1, num2 = exp.split(\\'+\\')\\n        minTillNow = inf\\n        expression = \\'\\'\\n        for i in range(len(num1)):\\n            a = int(num1[:i] or 1)\\n            b = int(num1[i:])\\n            for j in range(1, len(num2) + 1):\\n                c = int(num2[:j])\\n                d = int(num2[j:] or 1)\\n                current = a*(b+c)*d\\n                if current < result:\\n                    minTillNow = current\\n                    expression = \"{}({}+{}){}\".format(a,b,c,d)\\n                    if i == 0: #Removing a = 1 if i = 0\\n                        expression = expression[1:]\\n                    if j == len(num2): #Removing d = 1 if j = len(num2)\\n                        expression = expression[:-1]\\n                    \\n                          \\n        return expression\\n```\n```\\ni = 0 -->  num1[:0] --> a= \\'\\'\\ni = 1 -->  num1[:1] --> a=\\'2\\'\\ni = 2 -->  num1[:2] --> a=\\'23\\'\\ni = 3 -->  num1[:3] --> a=\\'234\\'\\ni = 4 -->  num1[:4] --> a=\\'2345\\'\\n\\n// But wait!! We dont want null values during calculation. Hence, for a = \\'\\', set a = 1\\ni = 0 --> int(num1[:0] or 1) --> a= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936790,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string s) \\n    {\\n        int n=s.size();\\n        int p=s.find(\\'+\\');\\n        int min_product=INT_MAX;\\n        string ans=\"\";\\n        for(int i=0;i<p;i++)\\n        {\\n            for(int j=p+1;j<n;j++)\\n            {\\n                string s1=s.substr(0,i);\\n                string s2=s.substr(i,p-i);\\n                string s3=s.substr(p+1,j-p);\\n                string s4=s.substr(j+1);\\n                int n1=s1==\"\"?1:stoi(s1);\\n                int n2=stoi(s2);\\n                int n3=stoi(s3);\\n                int n4=s4==\"\"?1:stoi(s4);\\n                if(n1*(n2+n3)*n4<min_product)\\n                {\\n                    min_product=n1*(n2+n3)*n4;\\n                    ans=s1+\"(\"+s2+\"+\"+s3+\")\"+s4;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string s) \\n    {\\n        int n=s.size();\\n        int p=s.find(\\'+\\');\\n        int min_product=INT_MAX;\\n        string ans=\"\";\\n        for(int i=0;i<p;i++)\\n        {\\n            for(int j=p+1;j<n;j++)\\n            {\\n                string s1=s.substr(0,i);\\n                string s2=s.substr(i,p-i);\\n                string s3=s.substr(p+1,j-p);\\n                string s4=s.substr(j+1);\\n                int n1=s1==\"\"?1:stoi(s1);\\n                int n2=stoi(s2);\\n                int n3=stoi(s3);\\n                int n4=s4==\"\"?1:stoi(s4);\\n                if(n1*(n2+n3)*n4<min_product)\\n                {\\n                    min_product=n1*(n2+n3)*n4;\\n                    ans=s1+\"(\"+s2+\"+\"+s3+\")\"+s4;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935323,
                "title": "javascript-simple-solution",
                "content": "```\\n/**\\n * @param {string} expression\\n * @return {string}\\n */\\nvar minimizeResult = function(expression) {\\n    const [left, right] = expression.split(\"+\");\\n    let res = [`(${expression})`, +left + +right];\\n    \\n    for(let i = 0; i < left.length; i++) {\\n        const i1 = left.slice(0, i) || 1;\\n        const i2 = left.slice(i);\\n        \\n        for(let j = 1; j <= right.length; j++) {\\n            const j1 = right.slice(0, j);\\n            const j2 = right.slice(j) || 1;\\n\\n            const tempTotal = i1*(+i2 + +j1)*j2;\\n                        \\n            if(res[1] > tempTotal ) {\\n                res[0] = `${left.slice(0, i)}(${i2}+${j1})${right.slice(j)}`;\\n                res[1] = tempTotal\\n            }\\n        }\\n    }\\n    return res[0]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} expression\\n * @return {string}\\n */\\nvar minimizeResult = function(expression) {\\n    const [left, right] = expression.split(\"+\");\\n    let res = [`(${expression})`, +left + +right];\\n    \\n    for(let i = 0; i < left.length; i++) {\\n        const i1 = left.slice(0, i) || 1;\\n        const i2 = left.slice(i);\\n        \\n        for(let j = 1; j <= right.length; j++) {\\n            const j1 = right.slice(0, j);\\n            const j2 = right.slice(j) || 1;\\n\\n            const tempTotal = i1*(+i2 + +j1)*j2;\\n                        \\n            if(res[1] > tempTotal ) {\\n                res[0] = `${left.slice(0, i)}(${i2}+${j1})${right.slice(j)}`;\\n                res[1] = tempTotal\\n            }\\n        }\\n    }\\n    return res[0]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1931470,
                "title": "c-conditional-bruteforce-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string minimizeResult(string exp) {\\n       int maxAns=INT_MAX;\\n        int left=0;\\n      pair<int,int> store={0,exp.size()-1};  \\n      for(int i=0;i<exp.size() and exp[i]!=\\'+\\';i++){\\n          int j=exp.size()-1;\\n          \\n          while(j>i and exp[j]!=\\'+\\'){\\n              \\n              // middle number\\n              int mid=0;\\n              int k=i;\\n              int midNumber=0;\\n              while(k<j and exp[k]!=\\'+\\'){\\n                  midNumber=midNumber*10+(exp[k]-\\'0\\');\\n                  k++;\\n              }\\n              k++;\\n              mid+=midNumber;\\n              midNumber=0;\\n              while(k<=j){\\n                  midNumber=midNumber*10+(exp[k]-\\'0\\');\\n                  k++;\\n              }\\n              mid+=midNumber;\\n              \\n              // right number\\n              int right=0;\\n             \\n              while(k<exp.size()){\\n                  right=right*10+(exp[k]-\\'0\\');\\n                  k++;\\n              }\\n              \\n              int val=(left==0?1:left)*(mid)*(right==0?1:right);\\n                  \\n              if(val<maxAns){\\n                  store={i,j};\\n                  maxAns=val;\\n              }\\n              j--;    \\n              \\n          }\\n          left=left*10+exp[i]-\\'0\\';\\n      } \\n       string ans=\"\";\\n       int i=0;\\n        while(i<store.first){\\n            ans+=exp[i++];\\n        }\\n        ans+=\\'(\\';\\n        while(i<=store.second){\\n            ans+=exp[i++];\\n        }\\n        ans+=\\')\\';\\n        while(i<exp.size()){\\n            ans+=exp[i++];\\n        }\\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string minimizeResult(string exp) {\\n       int maxAns=INT_MAX;\\n        int left=0;\\n      pair<int,int> store={0,exp.size()-1};  \\n      for(int i=0;i<exp.size() and exp[i]!=\\'+\\';i++){\\n          int j=exp.size()-1;\\n          \\n          while(j>i and exp[j]!=\\'+\\'){\\n              \\n              // middle number\\n              int mid=0;\\n              int k=i;\\n              int midNumber=0;\\n              while(k<j and exp[k]!=\\'+\\'){\\n                  midNumber=midNumber*10+(exp[k]-\\'0\\');\\n                  k++;\\n              }\\n              k++;\\n              mid+=midNumber;\\n              midNumber=0;\\n              while(k<=j){\\n                  midNumber=midNumber*10+(exp[k]-\\'0\\');\\n                  k++;\\n              }\\n              mid+=midNumber;\\n              \\n              // right number\\n              int right=0;\\n             \\n              while(k<exp.size()){\\n                  right=right*10+(exp[k]-\\'0\\');\\n                  k++;\\n              }\\n              \\n              int val=(left==0?1:left)*(mid)*(right==0?1:right);\\n                  \\n              if(val<maxAns){\\n                  store={i,j};\\n                  maxAns=val;\\n              }\\n              j--;    \\n              \\n          }\\n          left=left*10+exp[i]-\\'0\\';\\n      } \\n       string ans=\"\";\\n       int i=0;\\n        while(i<store.first){\\n            ans+=exp[i++];\\n        }\\n        ans+=\\'(\\';\\n        while(i<=store.second){\\n            ans+=exp[i++];\\n        }\\n        ans+=\\')\\';\\n        while(i<exp.size()){\\n            ans+=exp[i++];\\n        }\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971894,
                "title": "python3-brute-force-solution",
                "content": "```\\nclass Solution:\\n    def minimizeResult(self, exp: str) -> str:\\n        n = len(exp)\\n        mi = float(\\'inf\\')\\n        res = exp\\n        stop = -1\\n        for i in range(n):\\n            if exp[i] == \\'+\\':\\n                stop = i\\n                break\\n                \\n        def transform(start, end):\\n            if end < start or start > end:\\n                return 1\\n            return int(exp[start:end + 1])\\n        \\n        def evaluate(start, end):\\n            return int(exp[start:stop]) + int(exp[stop + 1:end + 1])\\n        \\n        for i in range(stop):\\n            for j in range(stop + 1, n):\\n                cur = transform(0, i - 1) * evaluate(i, j) * transform(j + 1, n - 1)\\n                if cur < mi:\\n                    mi = cur\\n                    res = exp[0:i] + \\'(\\' + exp[i:j+1] + \\')\\' + exp[j + 1:n]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, exp: str) -> str:\\n        n = len(exp)\\n        mi = float(\\'inf\\')\\n        res = exp\\n        stop = -1\\n        for i in range(n):\\n            if exp[i] == \\'+\\':\\n                stop = i\\n                break\\n                \\n        def transform(start, end):\\n            if end < start or start > end:\\n                return 1\\n            return int(exp[start:end + 1])\\n        \\n        def evaluate(start, end):\\n            return int(exp[start:stop]) + int(exp[stop + 1:end + 1])\\n        \\n        for i in range(stop):\\n            for j in range(stop + 1, n):\\n                cur = transform(0, i - 1) * evaluate(i, j) * transform(j + 1, n - 1)\\n                if cur < mi:\\n                    mi = cur\\n                    res = exp[0:i] + \\'(\\' + exp[i:j+1] + \\')\\' + exp[j + 1:n]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934271,
                "title": "implementation-java",
                "content": "```\\n// This is implementation based solution\\n// Here idea is brute force all possible brackets position in the strings and find the lowest value one\\nclass Solution {\\n    public String minimizeResult(String str) {\\n        int index = 0;\\n        for(int i=0;i<str.length();i++)\\n        {\\n            if(str.charAt(i)==\\'+\\')\\n            {\\n                index =i;\\n                break;\\n            }\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        int l =-1;\\n        int r = -1;\\n        for(int left = index-1;left>=0;left--)\\n        {\\n            for(int right = index+1;right<str.length();right++)\\n            {\\n               \\n                int a = Integer.parseInt(str.substring(left,index));\\n                int b = Integer.parseInt(str.substring(index+1,right+1));\\n                int left1 =1;\\n                int right1 = 1;\\n                if(right!= str.length()-1)\\n                {\\n                    right1 = Integer.parseInt(str.substring(right+1));\\n                }\\n                if(left != 0)\\n                {\\n                    left1 = Integer.parseInt(str.substring(0,left));\\n                }\\n                \\n                int lol = left1*(a+b)*right1;\\n                \\n                if(lol<ans)\\n                {\\n                   l = left;\\n                    r = right;\\n                    ans = lol;\\n                }\\n                \\n                \\n            }\\n        }\\nreturn str.substring(0,l)+\"(\"+str.substring(l,r+1)+\")\" +str.substring(r+1);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String minimizeResult(String str) {\\n        int index = 0;\\n        for(int i=0;i<str.length();i++)\\n        {\\n            if(str.charAt(i)==\\'+\\')\\n            {\\n                index =i;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1933453,
                "title": "solution-by-generating-pairs",
                "content": "We will try to generate all possible pairs to find out which pair gives min Value\\n\\nWe are generating value by the format: ```multiplier1 * (num1+ num2) * multiplier2```\\nmultiplier1 and multiplier2 can be empty strings as well\\ne.g: 2(1+2)\\nin this example multiplier1 is 2, and multiplier2 is 0 or empty string\\n\\n```\\npublic String minimizeResult(String expression) {\\n        String[] ar=expression.split(\"\\\\\\\\+\");\\n        String firstNum=ar[0];\\n        String secondNum=ar[1];\\n        \\n        int min=Integer.MAX_VALUE;\\n        String res=\"\";\\n        \\n        for(int i=0;i<=firstNum.length()-1;i++){\\n            String mul1=firstNum.substring(0,i);\\n            String num1=firstNum.substring(i);\\n            \\n            for(int j=0;j<=secondNum.length()-1;j++){\\n                String num2=secondNum.substring(0,j+1);\\n                String mul2=secondNum.substring(j+1);\\n               \\n                int cur=Integer.valueOf(num1)+Integer.valueOf(num2);\\n                if(!mul1.equals(\"\")){\\n                    cur*=Integer.valueOf(mul1);\\n                }\\n                if(!mul2.equals(\"\")){\\n                    cur*=Integer.valueOf(mul2);\\n                }\\n                \\n                if(cur<min){\\n                    min=cur;\\n                    res=mul1+\"(\"+num1+\"+\"+num2+\")\"+mul2;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```multiplier1 * (num1+ num2) * multiplier2```\n```\\npublic String minimizeResult(String expression) {\\n        String[] ar=expression.split(\"\\\\\\\\+\");\\n        String firstNum=ar[0];\\n        String secondNum=ar[1];\\n        \\n        int min=Integer.MAX_VALUE;\\n        String res=\"\";\\n        \\n        for(int i=0;i<=firstNum.length()-1;i++){\\n            String mul1=firstNum.substring(0,i);\\n            String num1=firstNum.substring(i);\\n            \\n            for(int j=0;j<=secondNum.length()-1;j++){\\n                String num2=secondNum.substring(0,j+1);\\n                String mul2=secondNum.substring(j+1);\\n               \\n                int cur=Integer.valueOf(num1)+Integer.valueOf(num2);\\n                if(!mul1.equals(\"\")){\\n                    cur*=Integer.valueOf(mul1);\\n                }\\n                if(!mul2.equals(\"\")){\\n                    cur*=Integer.valueOf(mul2);\\n                }\\n                \\n                if(cur<min){\\n                    min=cur;\\n                    res=mul1+\"(\"+num1+\"+\"+num2+\")\"+mul2;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1933235,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string s) {\\n        int plus=0;\\n        int mini=INT_MAX;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'+\\')plus=i;\\n        }\\n        string n1=s.substr(0,plus),n2=s.substr(plus+1);\\n        int t=(stoll(n1)+stoll(n2));\\n        mini=min(mini,t);\\n        ans+=\"(\"+n1+\"+\"+n2+\")\";\\n        for(int i=0;i<=n1.size();i++){\\n            for(int j=0;j<=n2.size();j++){\\n                // int t1=(stoi(n1.substr(0,i)))*(stoi(n1.substr(i))+stoi(n2.substr(0,j)))*(stoi(n1.substr(j)));\\n                string t2=n1.substr(0,i)==\"\"?\"1\":n1.substr(0,i);\\n                string t3=n1.substr(i)==\"\"?\"1\":n1.substr(i);\\n                string t5=n2.substr(0,j)==\"\"?\"a\":n2.substr(0,j);\\n                string t4=n2.substr(j)==\"\"?\"1\":n2.substr(j);\\n                string x=n2.substr(0,j),y=n2.substr(j);\\n                if(t5==\"a\"){\\n                    t5=t4;\\n                    t4=\"1\";\\n                    x=y;\\n                    y=\"\";\\n                }\\n                // cout<<t2 <<\" \"<<t3<<\" \"<<t5<<\" \"<<t4<<endl;\\n                int t1=((stoi(t2)*(stoi(t3)+stoi(t5))*stoi(t4)));\\n                // int t1=stoi(t2);\\n                if(t1<mini){\\n                    ans=n1.substr(0,i)+\"(\"+n1.substr(i)+\"+\"+x+\")\"+y;\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    mini=t1;\\n                }\\n            }\\n        }\\n        // cout<<mini;\\n        return ans;;\\n    }\\n};\\n```\\n**One of the worst question I solved on leetcode.**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string s) {\\n        int plus=0;\\n        int mini=INT_MAX;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'+\\')plus=i;\\n        }\\n        string n1=s.substr(0,plus),n2=s.substr(plus+1);\\n        int t=(stoll(n1)+stoll(n2));\\n        mini=min(mini,t);\\n        ans+=\"(\"+n1+\"+\"+n2+\")\";\\n        for(int i=0;i<=n1.size();i++){\\n            for(int j=0;j<=n2.size();j++){\\n                // int t1=(stoi(n1.substr(0,i)))*(stoi(n1.substr(i))+stoi(n2.substr(0,j)))*(stoi(n1.substr(j)));\\n                string t2=n1.substr(0,i)==\"\"?\"1\":n1.substr(0,i);\\n                string t3=n1.substr(i)==\"\"?\"1\":n1.substr(i);\\n                string t5=n2.substr(0,j)==\"\"?\"a\":n2.substr(0,j);\\n                string t4=n2.substr(j)==\"\"?\"1\":n2.substr(j);\\n                string x=n2.substr(0,j),y=n2.substr(j);\\n                if(t5==\"a\"){\\n                    t5=t4;\\n                    t4=\"1\";\\n                    x=y;\\n                    y=\"\";\\n                }\\n                // cout<<t2 <<\" \"<<t3<<\" \"<<t5<<\" \"<<t4<<endl;\\n                int t1=((stoi(t2)*(stoi(t3)+stoi(t5))*stoi(t4)));\\n                // int t1=stoi(t2);\\n                if(t1<mini){\\n                    ans=n1.substr(0,i)+\"(\"+n1.substr(i)+\"+\"+x+\")\"+y;\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    mini=t1;\\n                }\\n            }\\n        }\\n        // cout<<mini;\\n        return ans;;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1933209,
                "title": "java-solution-highly-commented-2-pointers-string-simulation",
                "content": "```\\nclass Solution {\\n    public String minimizeResult(String str) {\\n        \\n    /*Basically whole Expression boils down to : N1 * (N2+N3) * N4\\n    where N1 and N2 are part of num1 && N3 and N4 are part of num2\\n        \\n       Try to break this example \"247+38\"\\n        Left Part = 247\\n        Right Part = 38\\n        \\n        Now Pairs of Left Part i.e. (n1 and n2):\\n        {1,247}\\n        {2,47}\\n        {24,7}\\n        \\n        Now Pairs of right part i.e. (n3 and n4):\\n        {3,8}\\n        {38,1}\\n        \\n        Now the whole game left is of Pointer Management which\\n        you can understand by dry run\\n        */\\n        \\n        int small = Integer.MAX_VALUE;\\n        int left = -1;\\n        int right = -1;\\n        int plus = -1;\\n        \\n        char[] arr = str.toCharArray();\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==\\'+\\'){\\n                plus = i;  //Storing the index of Plus Operator\\n                break;\\n            }\\n        }\\n        \\n        for(int i=0;i<plus;i++){\\n            for(int j=plus+1;j<str.length();j++){\\n                \\n                int n1 = 1;\\n                String n1str = str.substring(0,i);\\n                if(n1str.length()>0){\\n                    n1 = Integer.parseInt(n1str);\\n                }\\n                \\n                String n2str = str.substring(i,plus);\\n                int n2 = Integer.parseInt(n2str);\\n                \\n                String n3str = str.substring(plus+1,j+1);\\n                int n3 = Integer.parseInt(n3str);\\n                \\n                int n4 = 1;\\n                String n4str = str.substring(j+1);\\n                if(n4str.length()>0){\\n                    n4 = Integer.parseInt(n4str);\\n                }\\n                \\n                int val = n1*(n2+n3)*n4;\\n                if(val<small){\\n                   small = val;\\n                    left = i;\\n                    right = j+1;\\n                }\\n            }\\n        }\\n        \\n        String ans = \"\";\\n        ans+=str.substring(0,left);\\n        ans+=\"(\";\\n        ans+=str.substring(left,right);\\n        ans+=\")\";\\n        ans+=str.substring(right);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String minimizeResult(String str) {\\n        \\n    /*Basically whole Expression boils down to : N1 * (N2+N3) * N4\\n    where N1 and N2 are part of num1 && N3 and N4 are part of num2\\n        \\n       Try to break this example \"247+38\"\\n        Left Part = 247\\n        Right Part = 38\\n        \\n        Now Pairs of Left Part i.e. (n1 and n2):\\n        {1,247}\\n        {2,47}\\n        {24,7}\\n        \\n        Now Pairs of right part i.e. (n3 and n4):\\n        {3,8}\\n        {38,1}\\n        \\n        Now the whole game left is of Pointer Management which\\n        you can understand by dry run\\n        */\\n        \\n        int small = Integer.MAX_VALUE;\\n        int left = -1;\\n        int right = -1;\\n        int plus = -1;\\n        \\n        char[] arr = str.toCharArray();\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==\\'+\\'){\\n                plus = i;  //Storing the index of Plus Operator\\n                break;\\n            }\\n        }\\n        \\n        for(int i=0;i<plus;i++){\\n            for(int j=plus+1;j<str.length();j++){\\n                \\n                int n1 = 1;\\n                String n1str = str.substring(0,i);\\n                if(n1str.length()>0){\\n                    n1 = Integer.parseInt(n1str);\\n                }\\n                \\n                String n2str = str.substring(i,plus);\\n                int n2 = Integer.parseInt(n2str);\\n                \\n                String n3str = str.substring(plus+1,j+1);\\n                int n3 = Integer.parseInt(n3str);\\n                \\n                int n4 = 1;\\n                String n4str = str.substring(j+1);\\n                if(n4str.length()>0){\\n                    n4 = Integer.parseInt(n4str);\\n                }\\n                \\n                int val = n1*(n2+n3)*n4;\\n                if(val<small){\\n                   small = val;\\n                    left = i;\\n                    right = j+1;\\n                }\\n            }\\n        }\\n        \\n        String ans = \"\";\\n        ans+=str.substring(0,left);\\n        ans+=\"(\";\\n        ans+=str.substring(left,right);\\n        ans+=\")\";\\n        ans+=str.substring(right);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931872,
                "title": "c-simple-brute-force-0ms-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n\\tstring minimizeResult(string s) {\\n\\t\\tint start = 0, end = 0; // start is the index for \\'(\\' and end for \\')\\'\\n\\t\\tint p = (int)(find(s.begin(), s.end(), \\'+\\') - s.begin()); // find the + operator postion\\n\\n\\t\\tvector<vector<int>> first(2), last(2);\\n\\t\\t// when the whole number is included in the parenthesis we have to multiply the sum by 1\\n\\t\\t// hence push 1 in the first[0]\\n\\t\\tfirst[0].push_back(1);\\n\\t\\tint i;\\n\\t\\tfor (i = 1; i < p; i++) {\\n\\t\\t\\t// integer value of substring from 0 to i - 1\\n\\t\\t\\t// the number which will remain outside of the parenthesis for the first number\\n\\t\\t\\tfirst[0].push_back(stoi(s.substr(0, i)));\\n\\t\\t\\t// the number which will remain between the parenthesis \\'(\\' and the + for the first number\\n\\t\\t\\tfirst[1].push_back(stoi(s.substr(i - 1)));\\n\\t\\t}\\n\\t\\tfirst[1].push_back(stoi(s.substr(i - 1)));\\n\\t\\tfor (i = 1; i < s.size() - p; i++) {\\n\\t\\t\\t// the number which will remain between the + operator and the parenthesis \\')\\' for the second number\\n\\t\\t\\tlast[0].push_back(stoi(s.substr(p + 1, i)));\\n\\t\\t\\t// the number which will remain outside of the parenthesis for the second number\\n\\t\\t\\tlast[1].push_back(stoi(s.substr(p + i)));\\n\\t\\t}\\n\\t\\t// the whole second number gets copied in the part outside the \\')\\' which is not possible, hence erase it\\n\\t\\tlast[1].erase(last[1].begin());\\n\\t\\t// push 1 to make sure that when nothing is outside \\')\\' we multiply by 1\\n\\t\\tlast[1].push_back(1);\\n\\n\\t\\tint ans = INT32_MAX;\\n\\n\\t\\tfor (int x = 0; x < first[0].size(); x++) { // iterate through all the possibilities for first number\\n\\t\\t\\tfor (int y = 0; y < last[0].size(); y++) { // iterate through all the possibilities for second number\\n\\t\\t\\t\\t// next two steps sums up the numbers between \\'(\\' and \\')\\'\\n\\t\\t\\t\\tint temp = first[1][x];\\n\\t\\t\\t\\ttemp += last[0][y];\\n\\t\\t\\t\\t// multiply temp with the number left after \\')\\' or 1 if none\\n\\t\\t\\t\\ttemp *= last[1][y];\\n\\t\\t\\t\\t// multiply temp with the number left before \\'(\\' or 1 if none\\n\\t\\t\\t\\ttemp *= first[0][x];\\n\\n\\t\\t\\t\\t// if we get temp smaller than the minimum of those computed previously\\n\\t\\t\\t\\tif (temp < ans) {\\n\\t\\t\\t\\t\\tans = temp; // change ans to temp\\n\\t\\t\\t\\t\\tstart = x; // set the index for \\'(\\' as x\\n\\t\\t\\t\\t\\tend = y; // set the index for \\')\\' as y\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\ts.insert(s.begin() + start, \\'(\\'); // insert \\'(\\' at the start position from the beginning\\n\\t\\t// after inserting \\')\\' the + operator shifts by 1 to the right hence (p + 1)\\n\\t\\t// end is indexed from 0 with respect to those digits after + operator hence the + 2\\n\\t\\ts.insert(s.begin() + (p + 1) + end + 2, \\')\\');\\n\\n\\t\\treturn s;\\n\\t}\\n};\\n```\\n\\nAny suggestions are appreciated.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tstring minimizeResult(string s) {\\n\\t\\tint start = 0, end = 0; // start is the index for \\'(\\' and end for \\')\\'\\n\\t\\tint p = (int)(find(s.begin(), s.end(), \\'+\\') - s.begin()); // find the + operator postion\\n\\n\\t\\tvector<vector<int>> first(2), last(2);\\n\\t\\t// when the whole number is included in the parenthesis we have to multiply the sum by 1\\n\\t\\t// hence push 1 in the first[0]\\n\\t\\tfirst[0].push_back(1);\\n\\t\\tint i;\\n\\t\\tfor (i = 1; i < p; i++) {\\n\\t\\t\\t// integer value of substring from 0 to i - 1\\n\\t\\t\\t// the number which will remain outside of the parenthesis for the first number\\n\\t\\t\\tfirst[0].push_back(stoi(s.substr(0, i)));\\n\\t\\t\\t// the number which will remain between the parenthesis \\'(\\' and the + for the first number\\n\\t\\t\\tfirst[1].push_back(stoi(s.substr(i - 1)));\\n\\t\\t}\\n\\t\\tfirst[1].push_back(stoi(s.substr(i - 1)));\\n\\t\\tfor (i = 1; i < s.size() - p; i++) {\\n\\t\\t\\t// the number which will remain between the + operator and the parenthesis \\')\\' for the second number\\n\\t\\t\\tlast[0].push_back(stoi(s.substr(p + 1, i)));\\n\\t\\t\\t// the number which will remain outside of the parenthesis for the second number\\n\\t\\t\\tlast[1].push_back(stoi(s.substr(p + i)));\\n\\t\\t}\\n\\t\\t// the whole second number gets copied in the part outside the \\')\\' which is not possible, hence erase it\\n\\t\\tlast[1].erase(last[1].begin());\\n\\t\\t// push 1 to make sure that when nothing is outside \\')\\' we multiply by 1\\n\\t\\tlast[1].push_back(1);\\n\\n\\t\\tint ans = INT32_MAX;\\n\\n\\t\\tfor (int x = 0; x < first[0].size(); x++) { // iterate through all the possibilities for first number\\n\\t\\t\\tfor (int y = 0; y < last[0].size(); y++) { // iterate through all the possibilities for second number\\n\\t\\t\\t\\t// next two steps sums up the numbers between \\'(\\' and \\')\\'\\n\\t\\t\\t\\tint temp = first[1][x];\\n\\t\\t\\t\\ttemp += last[0][y];\\n\\t\\t\\t\\t// multiply temp with the number left after \\')\\' or 1 if none\\n\\t\\t\\t\\ttemp *= last[1][y];\\n\\t\\t\\t\\t// multiply temp with the number left before \\'(\\' or 1 if none\\n\\t\\t\\t\\ttemp *= first[0][x];\\n\\n\\t\\t\\t\\t// if we get temp smaller than the minimum of those computed previously\\n\\t\\t\\t\\tif (temp < ans) {\\n\\t\\t\\t\\t\\tans = temp; // change ans to temp\\n\\t\\t\\t\\t\\tstart = x; // set the index for \\'(\\' as x\\n\\t\\t\\t\\t\\tend = y; // set the index for \\')\\' as y\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\ts.insert(s.begin() + start, \\'(\\'); // insert \\'(\\' at the start position from the beginning\\n\\t\\t// after inserting \\')\\' the + operator shifts by 1 to the right hence (p + 1)\\n\\t\\t// end is indexed from 0 with respect to those digits after + operator hence the + 2\\n\\t\\ts.insert(s.begin() + (p + 1) + end + 2, \\')\\');\\n\\n\\t\\treturn s;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931530,
                "title": "c-conditional-statements-only-brute-force-well-commenetd",
                "content": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string exp) \\n    {\\n        string left=\"\",right=\"\";\\n        bool plus=false;\\n        //247+38\\n        //left--247  right--  +38\\n        for(auto i:exp)\\n        {\\n            if(i==\\'+\\')\\n                plus=true;\\n            if(!plus)\\n                left+=i;\\n            else\\n                right+=i;\\n        }\\n        \\n        //n1==3  n2==3\\n        int n1 = left.length();\\n        int n2 = right.length();\\n        int mini=INT_MAX;\\n        string ans;\\n        \\n        \\n        //i loop for left string\\n        for(int i =0;i<n1;i++)\\n        {\\n            //j loop for string right\\n            for(int j=1;j<n2;j++)\\n            {\\n                //storing the string prior to opening parentheis\\n                int left_part;\\n                //if no char before bracket\\n                if(i==0)\\n                    left_part=1;\\n                else\\n                    left_part = stoi(left.substr(0,i));\\n                \\n                //storing the expression within the parenthesis\\n                //j+1,,,to include the \\'+\\' sign also\\n                int middle = stoi(left.substr(i,n1-i)) + stoi(right.substr(0,j+1));\\n                \\n                //to store the expression after the closing parenthesis\\n                int right_part;\\n                //if no char after parenthesis\\n                if(j==n2-1)\\n                    right_part=1;\\n                else\\n                    right_part = stoi(right.substr(j+1,n2-j-1));\\n                \\n                //checking if sum is minimum or not\\n                if(left_part*middle*right_part < mini)\\n                {\\n                    mini = left_part*middle*right_part;\\n                    //forming the string\\n                ans = left.substr(0,i)+\\'(\\' + left.substr(i,n1-i) +right.substr(0,j+1)+\\')\\' + right.substr(j+1,n2-j-1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string exp) \\n    {\\n        string left=\"\",right=\"\";\\n        bool plus=false;\\n        //247+38\\n        //left--247  right--  +38\\n        for(auto i:exp)\\n        {\\n            if(i==\\'+\\')\\n                plus=true;\\n            if(!plus)\\n                left+=i;\\n            else\\n                right+=i;\\n        }\\n        \\n        //n1==3  n2==3\\n        int n1 = left.length();\\n        int n2 = right.length();\\n        int mini=INT_MAX;\\n        string ans;\\n        \\n        \\n        //i loop for left string\\n        for(int i =0;i<n1;i++)\\n        {\\n            //j loop for string right\\n            for(int j=1;j<n2;j++)\\n            {\\n                //storing the string prior to opening parentheis\\n                int left_part;\\n                //if no char before bracket\\n                if(i==0)\\n                    left_part=1;\\n                else\\n                    left_part = stoi(left.substr(0,i));\\n                \\n                //storing the expression within the parenthesis\\n                //j+1,,,to include the \\'+\\' sign also\\n                int middle = stoi(left.substr(i,n1-i)) + stoi(right.substr(0,j+1));\\n                \\n                //to store the expression after the closing parenthesis\\n                int right_part;\\n                //if no char after parenthesis\\n                if(j==n2-1)\\n                    right_part=1;\\n                else\\n                    right_part = stoi(right.substr(j+1,n2-j-1));\\n                \\n                //checking if sum is minimum or not\\n                if(left_part*middle*right_part < mini)\\n                {\\n                    mini = left_part*middle*right_part;\\n                    //forming the string\\n                ans = left.substr(0,i)+\\'(\\' + left.substr(i,n1-i) +right.substr(0,j+1)+\\')\\' + right.substr(j+1,n2-j-1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931277,
                "title": "java-brute-force",
                "content": "```\\nclass Solution {\\n    public String minimizeResult(String s) {\\n        String[] a = s.split(\"\\\\\\\\+\");\\n        String res = \"\";\\n        int minsum = Integer.MAX_VALUE;\\n        int ls = -1;\\n        int rs = -1;\\n        String l = a[0];\\n        String r = a[1];\\n        for (int i = 0; i < l.length(); i++) {\\n            int left = Integer.parseInt(l.substring(i));\\n            for (int j = 0; j < r.length(); j++) {\\n                int right = Integer.parseInt(r.substring(0, j + 1));\\n                int leftmul = i == 0 ? 1 : Integer.parseInt(l.substring(0, i));\\n                int rightmul = j == r.length() - 1 ? 1 : Integer.parseInt(r.substring(j + 1));\\n                if (leftmul * (left + right) * rightmul < minsum) {\\n                    minsum = leftmul * (left + right) * rightmul;\\n                    ls = i;\\n                    rs = j;\\n                }\\n            }\\n        }\\n        res += l.substring(0, ls) + \"(\" + l.substring(ls) + \"+\" + r.substring(0, rs + 1) + \")\" + r.substring(rs + 1);\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String minimizeResult(String s) {\\n        String[] a = s.split(\"\\\\\\\\+\");\\n        String res = \"\";\\n        int minsum = Integer.MAX_VALUE;\\n        int ls = -1;\\n        int rs = -1;\\n        String l = a[0];\\n        String r = a[1];\\n        for (int i = 0; i < l.length(); i++) {\\n            int left = Integer.parseInt(l.substring(i));\\n            for (int j = 0; j < r.length(); j++) {\\n                int right = Integer.parseInt(r.substring(0, j + 1));\\n                int leftmul = i == 0 ? 1 : Integer.parseInt(l.substring(0, i));\\n                int rightmul = j == r.length() - 1 ? 1 : Integer.parseInt(r.substring(j + 1));\\n                if (leftmul * (left + right) * rightmul < minsum) {\\n                    minsum = leftmul * (left + right) * rightmul;\\n                    ls = i;\\n                    rs = j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1931209,
                "title": "what-is-written-in-the-question-just-implement-it",
                "content": "```\\nclass Solution {\\npublic:\\n    int calc(int i,string exp){\\n        \\n        int ans = 0;\\n        int pow = 1;\\n        for(int k=i-1;k>=0;k--){\\n            ans =  ans + pow*(exp[k] - \\'0\\') ;\\n            pow*=10;\\n        }\\n        return ans == 0 ? 1 : ans;\\n    }\\n    int func(int i,int j,string exp){\\n        int n = exp.size();\\n        int idx;\\n        for(int g=0;g<n;g++){\\n            if(exp[g] == \\'+\\'){\\n                idx = g;\\n                break;\\n            }\\n        }\\n        int p1 = 0;\\n        int pow =1;\\n        for(int x=idx-1;x>=i;x--){\\n            p1 = p1 + pow*(exp[x] - \\'0\\');\\n            pow*=10;\\n        }\\n        int p2 = 0;\\n        pow = 1;\\n        for(int x = j;x>idx;x--){\\n            p2 = p2 + pow*(exp[x] - \\'0\\');\\n            pow*=10;\\n        }\\n        \\n        return p1+p2 == 0 ? 1 : p1+p2;        \\n        \\n        \\n    }\\n    int calc_(int j,string exp){\\n        \\n        int ans = 0;\\n        int pow = 1;\\n        int n = exp.size();\\n        for(int k=n-1;k>=j+1;k--){\\n             ans =  ans + pow*(exp[k] - \\'0\\') ;\\n            pow*=10;\\n        }\\n        return ans == 0 ? 1 : ans;\\n    }\\n    string minimizeResult(string exp) {\\n        int n = exp.size();\\n        int idx;\\n        for(int i=0;i<n;i++){\\n            if(exp[i] == \\'+\\'){\\n                idx = i;\\n                break;\\n            }\\n        }\\n        int ans = INT_MAX;\\n        int l,r;\\n        for(int i=0;i<idx;i++){\\n            int pre = calc(i,exp);\\n            for(int j=idx+1;j<n;j++){\\n                int post = calc_(j,exp);\\n                int mid = func(i,j,exp);\\n                int ans_ = pre*mid*post;\\n                // cout<<pre<<\" \"<<mid<<\" \"<<post<<\" \"<<ans_<<endl;\\n                if(ans_ < ans){\\n                    ans = ans_;\\n                    l = i;\\n                    r = j;\\n                }\\n            }\\n        }\\n        string ex = exp;\\n        ex.insert(l,\"(\");\\n        ex.insert(r+2,\")\");\\n        return ex;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int calc(int i,string exp){\\n        \\n        int ans = 0;\\n        int pow = 1;\\n        for(int k=i-1;k>=0;k--){\\n            ans =  ans + pow*(exp[k] - \\'0\\') ;\\n            pow*=10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1931039,
                "title": "python-brute-force-minimize-result-by-adding-parentheses-to-expression",
                "content": "\\tclass Solution:\\n\\t\\tdef minimizeResult(self, expression: str) -> str:\\n\\t\\t\\ta = [i for i in expression] \\n\\t\\t\\tplus = a.index(\\'+\\')\\n\\t\\t\\tl,r = plus-1,plus+1 \\n\\t\\t\\tn = len(a)\\n\\t\\t\\tres = inf\\n\\t\\t\\tdef digit(s):\\n\\t\\t\\t\\tif not s: return 1 \\n\\t\\t\\t\\treturn int(\"\".join(s))\\n\\n\\t\\t\\tfor i in range(l,-1,-1):\\n\\t\\t\\t\\tfor j in range(r,n): \\n\\t\\t\\t\\t\\taddleft = digit(a[i:plus]) \\n\\t\\t\\t\\t\\taddright = digit(a[plus+1:j+1])\\n\\t\\t\\t\\t\\tmulleft = digit(a[:i]) \\n\\t\\t\\t\\t\\tmulright = digit(a[j+1:])\\n\\t\\t\\t\\t\\tans = mulleft * (addleft + addright) * mulright \\n\\t\\t\\t\\t\\tif ans<res: \\n\\t\\t\\t\\t\\t\\tres=ans\\n\\t\\t\\t\\t\\t\\tlres,rres = i,j \\n\\t\\t\\ta.insert(rres+1,\\')\\') \\n\\t\\t\\ta.insert(lres,\\'(\\') \\n\\t\\t\\treturn \"\".join(a)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minimizeResult(self, expression: str) -> str:\\n\\t\\t\\ta = [i for i in expression] \\n\\t\\t\\tplus = a.index(\\'+\\')\\n\\t\\t\\tl,r = plus-1,plus+1 \\n\\t\\t\\tn = len(a)\\n\\t\\t\\tres = inf\\n\\t\\t\\tdef digit(s):\\n\\t\\t\\t\\tif not s: return 1 \\n\\t\\t\\t\\treturn int(\"\".join(s))\\n\\n\\t\\t\\tfor i in range(l,-1,-1):\\n\\t\\t\\t\\tfor j in range(r,n): \\n\\t\\t\\t\\t\\taddleft = digit(a[i:plus]) \\n\\t\\t\\t\\t\\taddright = digit(a[plus+1:j+1])\\n\\t\\t\\t\\t\\tmulleft = digit(a[:i]) \\n\\t\\t\\t\\t\\tmulright = digit(a[j+1:])\\n\\t\\t\\t\\t\\tans = mulleft * (addleft + addright) * mulright \\n\\t\\t\\t\\t\\tif ans<res: \\n\\t\\t\\t\\t\\t\\tres=ans\\n\\t\\t\\t\\t\\t\\tlres,rres = i,j \\n\\t\\t\\ta.insert(rres+1,\\')\\') \\n\\t\\t\\ta.insert(lres,\\'(\\') \\n\\t\\t\\treturn \"\".join(a)",
                "codeTag": "Java"
            },
            {
                "id": 1931032,
                "title": "easy-python-solution-with-explanation",
                "content": "```\\n\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        \\n        # to store minimum answer\\n        minans = float(\\'inf\\')\\n        \\n        # result stores parenthesized string for the given expression\\n        result = \"\"\\n        \\n        # spliting both numbers\\n        num1, num2 = expression.split(\"+\")\\n        \\n        \\n        # traversing from behind of first number\\n        for i in range (len(num1)-1, -1, -1):\\n            \\n            # traversing from front of second number\\n            for j in range(1, len(num2)+1):\\n                \\n                \\n                # checking each and every combination \\n                \\n                # as we multiply extreme rightside and leftside if those values are null assigning them to 1 cz its multiplication\\n                # as we add middle rightParen and leftParen if those values are null assiging them to 0 cz its addition duh !\\n                \\n                rightside = int(num1[0:i]) if num1[0:i] else 1\\n                rightParen = int(num1[i:]) if num1[i:] else 0\\n                \\n                leftParen = int(num2[:j]) if num2[:j] else 0\\n                leftside = int(num2[j:]) if num2[j:] else 1\\n                \\n                \\n                current = rightside* (rightParen+ leftParen) * leftside\\n\\n                # if current is minimum then just update your result and don\\'t forget to update your minimum answer as well\\n                if current < minans :\\n                    \\n                    result = num1[0:i] +\"(\"+ num1[i:]+\"+\"+num2[:j]+\")\"+num2[j:]\\n                    minans = current\\n                    \\n        # return parenthesized string \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\n\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        \\n        # to store minimum answer\\n        minans = float(\\'inf\\')\\n        \\n        # result stores parenthesized string for the given expression\\n        result = \"\"\\n        \\n        # spliting both numbers\\n        num1, num2 = expression.split(\"+\")\\n        \\n        \\n        # traversing from behind of first number\\n        for i in range (len(num1)-1, -1, -1):\\n            \\n            # traversing from front of second number\\n            for j in range(1, len(num2)+1):\\n                \\n                \\n                # checking each and every combination \\n                \\n                # as we multiply extreme rightside and leftside if those values are null assigning them to 1 cz its multiplication\\n                # as we add middle rightParen and leftParen if those values are null assiging them to 0 cz its addition duh !\\n                \\n                rightside = int(num1[0:i]) if num1[0:i] else 1\\n                rightParen = int(num1[i:]) if num1[i:] else 0\\n                \\n                leftParen = int(num2[:j]) if num2[:j] else 0\\n                leftside = int(num2[j:]) if num2[j:] else 1\\n                \\n                \\n                current = rightside* (rightParen+ leftParen) * leftside\\n\\n                # if current is minimum then just update your result and don\\'t forget to update your minimum answer as well\\n                if current < minans :\\n                    \\n                    result = num1[0:i] +\"(\"+ num1[i:]+\"+\"+num2[:j]+\")\"+num2[j:]\\n                    minans = current\\n                    \\n        # return parenthesized string \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930985,
                "title": "c-easy-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n//     12345678 + 12345678\\n//     1234567(8+1)2345678\\n//     1234567(8+12)345678\\n    \\n    // find the index of plus sign \\n    int findPlus(string s,int n)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'+\\')\\n                return i;\\n        }\\n        return -1;\\n    }\\n    \\n    //a(b+c)d , it will return the answer for this string\\n    long long int compute(string s)\\n    {\\n        int n = s.size();\\n        int i=0;\\n        long long int prev = 0LL , prevPlus = 0LL , nextPlus = 0LL,next=0LL;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'(\\')\\n                break;\\n            prev = prev*10LL + s[i]-\\'0\\';\\n            i++;\\n        }\\n        \\n        i++;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'+\\')\\n                break;\\n            prevPlus = prevPlus*10LL + s[i]-\\'0\\';\\n            i++;\\n        }\\n        i++;\\n        \\n        while(i<n)\\n        {\\n            if(s[i]==\\')\\')\\n                break;\\n            nextPlus = nextPlus*10LL + s[i]-\\'0\\';\\n            i++;\\n        }\\n        i++;\\n        \\n        while(i<n)\\n        {\\n            next = next*10LL + s[i]-\\'0\\';\\n            i++;\\n        }\\n        \\n        // (1+3) , (1+3)4 , 4(1+3) for this type of cases\\n        if(prev ==0)\\n            prev = 1;\\n        if(next==0)\\n            next=1;\\n        \\n        return (prev*1LL*(prevPlus+nextPlus)*1LL*next*1LL);\\n    }\\n    \\n    string minimizeResult(string s) {\\n        int n = s.size();\\n        int plusSign = findPlus(s,n);  \\n        string ansString  = \"\";\\n        long long int ans = 999999999999999999;\\n        for(int i=0;i<plusSign;i++)\\n        {\\n            string leftBracket = s;\\n            leftBracket.insert(i,\"(\");\\n            int herePlus = findPlus(leftBracket,leftBracket.size());\\n            for(int j=herePlus+2;j<=leftBracket.size();j++)\\n            {\\n                string rightBracket = leftBracket;\\n                rightBracket.insert(j,\")\");\\n                long long int comp = compute(rightBracket);\\n                if(ans > comp)\\n                {\\n                    ans = comp;\\n                    ansString  = rightBracket;\\n                }\\n                // cout<<rightBracket<<\"->\"<<comp<<endl;\\n            }\\n        }\\n        return ansString;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//     12345678 + 12345678\\n//     1234567(8+1)2345678\\n//     1234567(8+12)345678\\n    \\n    // find the index of plus sign \\n    int findPlus(string s,int n)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'+\\')\\n                return i;\\n        }\\n        return -1;\\n    }\\n    \\n    //a(b+c)d , it will return the answer for this string\\n    long long int compute(string s)\\n    {\\n        int n = s.size();\\n        int i=0;\\n        long long int prev = 0LL , prevPlus = 0LL , nextPlus = 0LL,next=0LL;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'(\\')\\n                break;\\n            prev = prev*10LL + s[i]-\\'0\\';\\n            i++;\\n        }\\n        \\n        i++;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'+\\')\\n                break;\\n            prevPlus = prevPlus*10LL + s[i]-\\'0\\';\\n            i++;\\n        }\\n        i++;\\n        \\n        while(i<n)\\n        {\\n            if(s[i]==\\')\\')\\n                break;\\n            nextPlus = nextPlus*10LL + s[i]-\\'0\\';\\n            i++;\\n        }\\n        i++;\\n        \\n        while(i<n)\\n        {\\n            next = next*10LL + s[i]-\\'0\\';\\n            i++;\\n        }\\n        \\n        // (1+3) , (1+3)4 , 4(1+3) for this type of cases\\n        if(prev ==0)\\n            prev = 1;\\n        if(next==0)\\n            next=1;\\n        \\n        return (prev*1LL*(prevPlus+nextPlus)*1LL*next*1LL);\\n    }\\n    \\n    string minimizeResult(string s) {\\n        int n = s.size();\\n        int plusSign = findPlus(s,n);  \\n        string ansString  = \"\";\\n        long long int ans = 999999999999999999;\\n        for(int i=0;i<plusSign;i++)\\n        {\\n            string leftBracket = s;\\n            leftBracket.insert(i,\"(\");\\n            int herePlus = findPlus(leftBracket,leftBracket.size());\\n            for(int j=herePlus+2;j<=leftBracket.size();j++)\\n            {\\n                string rightBracket = leftBracket;\\n                rightBracket.insert(j,\")\");\\n                long long int comp = compute(rightBracket);\\n                if(ans > comp)\\n                {\\n                    ans = comp;\\n                    ansString  = rightBracket;\\n                }\\n                // cout<<rightBracket<<\"->\"<<comp<<endl;\\n            }\\n        }\\n        return ansString;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4024033,
                "title": "c-self-explanatory-simple-code",
                "content": "```\\n    string minimizeResult(string s) {\\n        // changing the string name from expression to s... \\n        // pls leetcode don\\'t give huge variable names\\n        \\n        int plusidx = -1;\\n        int n = s.length();\\n        for(int i = 0; i<n; i++){\\n            if(s[i]==\\'+\\'){\\n                plusidx = i;\\n                break;\\n            }\\n        }\\n        \\n        // Let the template of the string parenthesization be\\n        // a(b+c)d\\n        \\n        int ans = INT_MAX;\\n        string res = \"\";\\n        string a,b,c,d,mid;\\n        int anum,bnum,cnum,dnum;\\n        \\n        plusidx++;\\n        \\n        for(int i=0;i<plusidx-1;i++){\\n            for(int j=plusidx;j<n;j++){         \\n                a = s.substr(0,i);\\n                mid = s.substr(i,j+1-i);\\n                d = s.substr(j+1,n);\\n                \\n                // Printing all combinatoins\\n                // cout<<a + \"(\" + mid + \")\" + d<<\"\\\\n\";\\n                \\n                if(a.size()==0) anum = 1;\\n                else anum = stoi(a);\\n                \\n                if(d.size()==0) dnum = 1;\\n                else dnum = stoi(d);\\n                \\n                int k = 0;\\n                b.clear();\\n                c.clear();  \\n                while(mid[k]!=\\'+\\'){\\n                    b.push_back(mid[k++]); \\n                }\\n                k++;\\n                while(k<mid.length()){\\n                    c.push_back(mid[k++]);\\n                }\\n                \\n                bnum = stoi(b);\\n                cnum = stoi(c);\\n                \\n                int val = anum*(bnum+cnum)*dnum;\\n                if(val<ans){\\n                    ans = val;\\n                    res = a + \"(\" + mid + \")\" + d;\\n                }\\n                \\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\n    string minimizeResult(string s) {\\n        // changing the string name from expression to s... \\n        // pls leetcode don\\'t give huge variable names\\n        \\n        int plusidx = -1;\\n        int n = s.length();\\n        for(int i = 0; i<n; i++){\\n            if(s[i]==\\'+\\'){\\n                plusidx = i;\\n                break;\\n            }\\n        }\\n        \\n        // Let the template of the string parenthesization be\\n        // a(b+c)d\\n        \\n        int ans = INT_MAX;\\n        string res = \"\";\\n        string a,b,c,d,mid;\\n        int anum,bnum,cnum,dnum;\\n        \\n        plusidx++;\\n        \\n        for(int i=0;i<plusidx-1;i++){\\n            for(int j=plusidx;j<n;j++){         \\n                a = s.substr(0,i);\\n                mid = s.substr(i,j+1-i);\\n                d = s.substr(j+1,n);\\n                \\n                // Printing all combinatoins\\n                // cout<<a + \"(\" + mid + \")\" + d<<\"\\\\n\";\\n                \\n                if(a.size()==0) anum = 1;\\n                else anum = stoi(a);\\n                \\n                if(d.size()==0) dnum = 1;\\n                else dnum = stoi(d);\\n                \\n                int k = 0;\\n                b.clear();\\n                c.clear();  \\n                while(mid[k]!=\\'+\\'){\\n                    b.push_back(mid[k++]); \\n                }\\n                k++;\\n                while(k<mid.length()){\\n                    c.push_back(mid[k++]);\\n                }\\n                \\n                bnum = stoi(b);\\n                cnum = stoi(c);\\n                \\n                int val = anum*(bnum+cnum)*dnum;\\n                if(val<ans){\\n                    ans = val;\\n                    res = a + \"(\" + mid + \")\" + d;\\n                }\\n                \\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3872599,
                "title": "javascript-2232-minimize-result-by-adding-parentheses-to-expression",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar minimizeResult = function (ex) {\\n  let min = Infinity\\n  let an = []\\n\\n  let [l, r] = ex.split(\"+\");\\n  for (let i = 0; i < l.length; i++) {\\n    let a = l.slice(0, i)\\n    let b = l.slice(i)\\n\\n    for (let j = 1; j <= r.length; j++) {\\n      let c = r.slice(0, j)\\n      let d = r.slice(j)\\n\\n      let val = +b + +c\\n      if (a !== \\'\\') val = a * val\\n      if (d !== \\'\\') val = val * d\\n\\n      if (val < min) {\\n        min = Math.min(min, val)\\n        an = [a, b, c, d]\\n      }\\n    }\\n  }\\n\\n  let [a, b, c, d] = an\\n  return \\'\\' + a + \\'(\\' + b + \\'+\\' + c + \\')\\' + d\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimizeResult = function (ex) {\\n  let min = Infinity\\n  let an = []\\n\\n  let [l, r] = ex.split(\"+\");\\n  for (let i = 0; i < l.length; i++) {\\n    let a = l.slice(0, i)\\n    let b = l.slice(i)\\n\\n    for (let j = 1; j <= r.length; j++) {\\n      let c = r.slice(0, j)\\n      let d = r.slice(j)\\n\\n      let val = +b + +c\\n      if (a !== \\'\\') val = a * val\\n      if (d !== \\'\\') val = val * d\\n\\n      if (val < min) {\\n        min = Math.min(min, val)\\n        an = [a, b, c, d]\\n      }\\n    }\\n  }\\n\\n  let [a, b, c, d] = an\\n  return \\'\\' + a + \\'(\\' + b + \\'+\\' + c + \\')\\' + d\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2733604,
                "title": "python-brute-force-solution",
                "content": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        if not expression: return expression\\n        \\n        num1, num2 = expression.split(\\'+\\')\\n        min_result = float(\\'inf\\')\\n        min_expression = \\'\\'\\n        \\n        for i in range(len(num1)):\\n            for j in range(1, len(num2)+1):\\n                parenthesis_part1 = int(num1[i:])\\n                parenthesis_part2 = int(num2[0:j])\\n                \\n                outside_part1 = 1\\n                outside_part2 = 1\\n                is_outside_part1_empty = True\\n                is_outside_part2_empty = True\\n                if i != 0:\\n                    outside_part1 = int(num1[0:i])\\n                    is_outside_part1_empty = False\\n                if j != len(num2):\\n                    outside_part2 = int(num2[j:])\\n                    is_outside_part2_empty = False\\n                \\n                curr_result = outside_part1 * (parenthesis_part1 + parenthesis_part2) * outside_part2\\n                if curr_result < min_result:\\n                    min_result = curr_result\\n                    str_outside_part1 = \\'\\' if is_outside_part1_empty else str(outside_part1)\\n                    str_outside_part2 = \\'\\' if is_outside_part2_empty else str(outside_part2)\\n                    min_expression = (str_outside_part1 \\n                                      + \\'(\\' + str(parenthesis_part1) \\n                                      + \\'+\\' + str(parenthesis_part2) \\n                                      + \\')\\' + str_outside_part2)\\n        \\n        return min_expression\\n\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        if not expression: return expression\\n        \\n        num1, num2 = expression.split(\\'+\\')\\n        min_result = float(\\'inf\\')\\n        min_expression = \\'\\'\\n        \\n        for i in range(len(num1)):\\n            for j in range(1, len(num2)+1):\\n                parenthesis_part1 = int(num1[i:])\\n                parenthesis_part2 = int(num2[0:j])\\n                \\n                outside_part1 = 1\\n                outside_part2 = 1\\n                is_outside_part1_empty = True\\n                is_outside_part2_empty = True\\n                if i != 0:\\n                    outside_part1 = int(num1[0:i])\\n                    is_outside_part1_empty = False\\n                if j != len(num2):\\n                    outside_part2 = int(num2[j:])\\n                    is_outside_part2_empty = False\\n                \\n                curr_result = outside_part1 * (parenthesis_part1 + parenthesis_part2) * outside_part2\\n                if curr_result < min_result:\\n                    min_result = curr_result\\n                    str_outside_part1 = \\'\\' if is_outside_part1_empty else str(outside_part1)\\n                    str_outside_part2 = \\'\\' if is_outside_part2_empty else str(outside_part2)\\n                    min_expression = (str_outside_part1 \\n                                      + \\'(\\' + str(parenthesis_part1) \\n                                      + \\'+\\' + str(parenthesis_part2) \\n                                      + \\')\\' + str_outside_part2)\\n        \\n        return min_expression\\n\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2584817,
                "title": "69-faster-than-rest",
                "content": "\\tclass Solution:\\n\\t\\tdef minimizeResult(self, expression: str) -> str:\\n\\t\\t\\t#==========================\\n\\t\\t\\td = dict()\\n\\t\\t\\tself.mv = float(\\'inf\\')\\n\\t\\t\\t#===========================\\n\\n\\t\\t\\tdef computeExp(exp):\\n\\t\\t\\t\\tleft = exp.split(\")\")\\n\\t\\t\\t\\tright= left[0].split(\"(\")\\n\\n\\t\\t\\t\\tv = right[1]\\n\\n\\t\\t\\t\\tv = v.split(\"+\")\\n\\n\\t\\t\\t\\tbrac = int(v[0])+int(v[1])\\n\\n\\t\\t\\t\\tres = brac\\n\\t\\t\\t\\tif right[0]!=\\'\\':\\n\\t\\t\\t\\t\\tres*=int(right[0])\\n\\t\\t\\t\\tif left[1]!=\\'\\':\\n\\t\\t\\t\\t\\tres*=int(left[1])\\n\\t\\t\\t\\treturn res\\n\\t\\t\\t# print(computeExp(\"(3+2)\"))\\n\\n\\n\\t\\t\\tdef comb(p1,p2,n,s):\\n\\t\\t\\t\\tglobal minValue\\n\\t\\t\\t\\tif p1==-1 or p2==n+1:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tnw = [*s]\\n\\t\\t\\t\\tnw.insert(p1,\"(\")\\n\\t\\t\\t\\tnw.insert(p2+1,\")\")\\n\\t\\t\\t\\t#------------------\\n\\t\\t\\t\\tgenStr = \"\".join(nw)\\n\\t\\t\\t\\tvalue = computeExp(genStr)\\n\\t\\t\\t\\td[value] = genStr\\n\\t\\t\\t\\tself.mv = min(self.mv,value)\\n\\t\\t\\t\\t#-------------------\\n\\t\\t\\t\\t# comb(p1-1,p2+1,n,s)\\n\\t\\t\\t\\tcomb(p1,p2+1,n,s)\\n\\t\\t\\t\\tcomb(p1-1,p2,n,s)\\n\\n\\n\\t\\t\\ts =list(expression)\\n\\t\\t\\t# print(s)\\n\\t\\t\\tindex = s.index(\"+\")\\n\\n\\t\\t\\tcomb(index-1,index+2,len(s),s)\\n\\n\\t\\t\\treturn d[self.mv]\\n\\n\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minimizeResult(self, expression: str) -> str:\\n\\t\\t\\t#==========================\\n\\t\\t\\td = dict()\\n\\t\\t\\tself.mv = float(\\'inf\\')\\n\\t\\t\\t#===========================\\n\\n\\t\\t\\tdef computeExp(exp):\\n\\t\\t\\t\\tleft = exp.split(\")\")\\n\\t\\t\\t\\tright= left[0].split(\"(\")\\n\\n\\t\\t\\t\\tv = right[1]\\n\\n\\t\\t\\t\\tv = v.split(\"+\")\\n\\n\\t\\t\\t\\tbrac = int(v[0])+int(v[1])\\n\\n\\t\\t\\t\\tres = brac\\n\\t\\t\\t\\tif right[0]!=\\'\\':\\n\\t\\t\\t\\t\\tres*=int(right[0])\\n\\t\\t\\t\\tif left[1]!=\\'\\':\\n\\t\\t\\t\\t\\tres*=int(left[1])\\n\\t\\t\\t\\treturn res\\n\\t\\t\\t# print(computeExp(\"(3+2)\"))\\n\\n\\n\\t\\t\\tdef comb(p1,p2,n,s):\\n\\t\\t\\t\\tglobal minValue\\n\\t\\t\\t\\tif p1==-1 or p2==n+1:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tnw = [*s]\\n\\t\\t\\t\\tnw.insert(p1,\"(\")\\n\\t\\t\\t\\tnw.insert(p2+1,\")\")\\n\\t\\t\\t\\t#------------------\\n\\t\\t\\t\\tgenStr = \"\".join(nw)\\n\\t\\t\\t\\tvalue = computeExp(genStr)\\n\\t\\t\\t\\td[value] = genStr\\n\\t\\t\\t\\tself.mv = min(self.mv,value)\\n\\t\\t\\t\\t#-------------------\\n\\t\\t\\t\\t# comb(p1-1,p2+1,n,s)\\n\\t\\t\\t\\tcomb(p1,p2+1,n,s)\\n\\t\\t\\t\\tcomb(p1-1,p2,n,s)\\n\\n\\n\\t\\t\\ts =list(expression)\\n\\t\\t\\t# print(s)\\n\\t\\t\\tindex = s.index(\"+\")\\n\\n\\t\\t\\tcomb(index-1,index+2,len(s),s)\\n\\n\\t\\t\\treturn d[self.mv]\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2120447,
                "title": "javascript-solution-brute-force",
                "content": "We just generate all possible solutions\\n\\n```\\nvar minimizeResult = function(expression) {\\n    let MAX = Number.MAX_SAFE_INTEGER;    \\n\\n    const [firstNum, secondNum] = expression.split(\"+\");\\n    \\n    let minRes = MAX;\\n    let minStr = \"\";\\n    \\n    const num1Len = firstNum.length;\\n    const num2Len = secondNum.length;\\n    \\n    for (let i = 0; i < num1Len; ++i) {\\n        const leftNum1 = firstNum.substring(0, i);\\n        const rightNum1 = firstNum.substring(i);\\n        \\n        for (let j = 1; j <= num2Len; ++j) {\\n            const leftNum2 = secondNum.substring(0, j);\\n            const rightNum2 = secondNum.substring(j);\\n           \\n            const sum = parseInt(rightNum1)  + parseInt(leftNum2);\\n\\n            let prod = sum;\\n            \\n            if (leftNum1 != \"\") prod *= leftNum1;\\n            if (rightNum2 != \"\") prod *= rightNum2;\\n            \\n            if (prod < minRes) {\\n                minRes = prod;\\n                minStr = `${leftNum1}(${rightNum1}+${leftNum2})${rightNum2}`;\\n            }\\n        }\\n    }\\n    \\n    return minStr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimizeResult = function(expression) {\\n    let MAX = Number.MAX_SAFE_INTEGER;    \\n\\n    const [firstNum, secondNum] = expression.split(\"+\");\\n    \\n    let minRes = MAX;\\n    let minStr = \"\";\\n    \\n    const num1Len = firstNum.length;\\n    const num2Len = secondNum.length;\\n    \\n    for (let i = 0; i < num1Len; ++i) {\\n        const leftNum1 = firstNum.substring(0, i);\\n        const rightNum1 = firstNum.substring(i);\\n        \\n        for (let j = 1; j <= num2Len; ++j) {\\n            const leftNum2 = secondNum.substring(0, j);\\n            const rightNum2 = secondNum.substring(j);\\n           \\n            const sum = parseInt(rightNum1)  + parseInt(leftNum2);\\n\\n            let prod = sum;\\n            \\n            if (leftNum1 != \"\") prod *= leftNum1;\\n            if (rightNum2 != \"\") prod *= rightNum2;\\n            \\n            if (prod < minRes) {\\n                minRes = prod;\\n                minStr = `${leftNum1}(${rightNum1}+${leftNum2})${rightNum2}`;\\n            }\\n        }\\n    }\\n    \\n    return minStr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2013848,
                "title": "simple-implementation-self-intuitive",
                "content": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    string minimizeResult(string exp) {\\n        int n=exp.length();\\n        string s1,s2;\\n        for(int i=0;i<n;i++){\\n            if(exp[i]==\\'+\\'){\\n                s1=exp.substr(0,i);\\n                s2=exp.substr(i+1,n-i);\\n            }\\n        }\\n        string ans=\"(\"+s1+\"+\"+s2+\")\";\\n        int res=stoi(s1)+stoi(s2),n1=s1.length(),n2=s2.length();\\n        string a,b,c,d;\\n        int x1,x2,x3,x4,x;\\n        for(int i=-1;i<n1;i++){\\n            for(int j=-1;j<n2;j++){                \\n                a=s1.substr(0,i+1);\\n                b=s1.substr(i+1,n1-i-1);\\n                c=s2.substr(0,j+1);\\n                d=s2.substr(j+1,n2-j-1);\\n                x1=a.empty()?1:stoi(a);\\n                x2=b.empty()?0:stoi(b);\\n                x3=c.empty()?0:stoi(c);\\n                x4=d.empty()?1:stoi(d);\\n                if(x2==0||x3==0)\\n                    continue;\\n                x=(x1*(x2+x3)*x4);\\n                if(res>x){\\n                    res=x;\\n                    ans=a+\"(\"+b+\"+\"+c+\")\"+d;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    string minimizeResult(string exp) {\\n        int n=exp.length();\\n        string s1,s2;\\n        for(int i=0;i<n;i++){\\n            if(exp[i]==\\'+\\'){\\n                s1=exp.substr(0,i);\\n                s2=exp.substr(i+1,n-i);\\n            }\\n        }\\n        string ans=\"(\"+s1+\"+\"+s2+\")\";\\n        int res=stoi(s1)+stoi(s2),n1=s1.length(),n2=s2.length();\\n        string a,b,c,d;\\n        int x1,x2,x3,x4,x;\\n        for(int i=-1;i<n1;i++){\\n            for(int j=-1;j<n2;j++){                \\n                a=s1.substr(0,i+1);\\n                b=s1.substr(i+1,n1-i-1);\\n                c=s2.substr(0,j+1);\\n                d=s2.substr(j+1,n2-j-1);\\n                x1=a.empty()?1:stoi(a);\\n                x2=b.empty()?0:stoi(b);\\n                x3=c.empty()?0:stoi(c);\\n                x4=d.empty()?1:stoi(d);\\n                if(x2==0||x3==0)\\n                    continue;\\n                x=(x1*(x2+x3)*x4);\\n                if(res>x){\\n                    res=x;\\n                    ans=a+\"(\"+b+\"+\"+c+\")\"+d;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1964551,
                "title": "clean-python-solution",
                "content": "```\\nclass Solution:\\n    def minimizeResult(self, exp: str) -> str:\\n        a,b=exp.split(\\'+\\')\\n        mini = float(\\'inf\\')\\n        \\n        \\n        for i in range(len(a)):\\n            for j in range(1,len(b)+1):\\n                s1,s2,s3,s4 = a[:i],a[i:],b[:j],b[j:]\\n                res = int(s1 or 1)*(int(s2 or 0) +int(s3 or 0))*int(s4 or 1)\\n                \\n                if res<mini: \\n                    mini=res\\n                    x,y = i,j\\n                           \\n        return a[:x]+\\'(\\'+a[x:]+\\'+\\'+b[:y]+\\')\\'+b[y:]\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, exp: str) -> str:\\n        a,b=exp.split(\\'+\\')\\n        mini = float(\\'inf\\')\\n        \\n        \\n        for i in range(len(a)):\\n            for j in range(1,len(b)+1):\\n                s1,s2,s3,s4 = a[:i],a[i:],b[:j],b[j:]\\n                res = int(s1 or 1)*(int(s2 or 0) +int(s3 or 0))*int(s4 or 1)\\n                \\n                if res<mini: \\n                    mini=res\\n                    x,y = i,j\\n                           \\n        return a[:x]+\\'(\\'+a[x:]+\\'+\\'+b[:y]+\\')\\'+b[y:]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1952862,
                "title": "python-simple-solution",
                "content": "Please let me know if you did not understand the code or if there is any other way to optimize it.\\n\\n```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        \\n        expression1, expression2 = expression.split(\"+\")\\n        score = float(\\'INF\\')\\n        res = \\'\\'\\n        \\n        for i in range(len(expression1)):\\n            num1 = int(expression1[:i] if i > 0 else 1)\\n            num2 = int(expression1[i:])\\n            \\n            for j in range(1, len(expression2) + 1):\\n                num3 = int(expression2[:j])\\n                num4 = int(expression2[j:] if j != len(expression2) else 1)\\n                \\n                curr_score = num1 * (num2 + num3) * num4\\n                \\n                if curr_score < score:\\n\\t\\t\\t\\t\\t#efficient to use \\'join\\' for concatenation rather than \\'+\\'.\\n                    res = \"\".join([expression1[:i],\\'(\\', expression1[i:], \\'+\\', expression2[:j], \\')\\', expression2[j:]]) \\n                    score = curr_score\\n        return res\\n                \\n        \\n            \\n",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "Please let me know if you did not understand the code or if there is any other way to optimize it.\\n\\n```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        \\n        expression1, expression2 = expression.split(\"+\")\\n        score = float(\\'INF\\')\\n        res = \\'\\'\\n        \\n        for i in range(len(expression1)):\\n            num1 = int(expression1[:i] if i > 0 else 1)\\n            num2 = int(expression1[i:])\\n            \\n            for j in range(1, len(expression2) + 1):\\n                num3 = int(expression2[:j])\\n                num4 = int(expression2[j:] if j != len(expression2) else 1)\\n                \\n                curr_score = num1 * (num2 + num3) * num4\\n                \\n                if curr_score < score:\\n\\t\\t\\t\\t\\t#efficient to use \\'join\\' for concatenation rather than \\'+\\'.\\n                    res = \"\".join([expression1[:i],\\'(\\', expression1[i:], \\'+\\', expression2[:j], \\')\\', expression2[j:]]) \\n                    score = curr_score\\n        return res\\n                \\n        \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1951915,
                "title": "java-recursive-clean-comments-test-cases-100-faster-time-memory",
                "content": "```\\nclass Solution {\\n    \\n\\t// Variables for final solution, to avoid create combination Strings\\n    private int currentLeft = 0;\\n    private int currentRight = 0;\\n    private int currentMin = Integer.MAX_VALUE;\\n    \\n    public String minimizeResult(String expression) {\\n        \\n\\t\\t// Identify our starting point, to apply the expansion technique\\n        int plusIndex = expression.indexOf(\"+\");\\n        \\n\\t\\t// We start expanding from the first values to the left and right of the center (plus sign).\\n        expand(plusIndex - 1, plusIndex + 1, expression);\\n        \\n\\t\\t// Build the final String. We add the parentheses to our expression in the already calculated indices, defined as global variables.\\n        StringBuilder stringBuilder = new StringBuilder();\\n        \\n        for(int i = 0; i < expression.length(); i++)\\n        {\\n            if(i == currentLeft)\\n                stringBuilder.append(\\'(\\');\\n            \\n            stringBuilder.append(expression.charAt(i));\\n            \\n            if(i == currentRight)\\n                stringBuilder.append(\\')\\');\\n        }\\n        \\n\\t\\t// Edge case, if parentheses need to be inserted at the end of expression\\n        if(currentRight == expression.length())\\n            stringBuilder.append(\\')\\');\\n        \\n        return stringBuilder.toString();\\n        \\n    }\\n    \\n\\t// With this function, we calculate all possible combinations of parentheses from two pointers, left and right.\\n    private void expand(int left, int right, String expression){\\n    \\n        if(left < 0 || right >= expression.length())\\n            return;\\n        \\n\\t\\t// from zero to first parentheses\\n        int a = evaluate(0, left, expression);\\n\\t\\t\\n\\t\\t// from first parentheses to right parentheses (+1 means inclusive)\\n        int b = evaluate(left, right + 1, expression); \\n\\t\\t\\n\\t\\t// from right parentheses to the end of expression (+1 means inclusive)\\n        int c = evaluate(right + 1, expression.length(), expression);\\n        \\n\\t\\t// If the expression a * b * c is less than our current minimum\\n\\t\\t// this is our solution, we replace the variables with these new values.\\n        if((a * b * c) < currentMin)\\n        {\\n            currentMin = a * b * c;\\n            currentLeft = left;\\n            currentRight = right;\\n        }\\n        \\n        // Move parentheses left only\\n        expand(left - 1, right, expression);\\n\\t\\t\\n\\t\\t// Move parentheses right only\\n        expand(left, right + 1, expression);\\n\\t\\t\\n\\t\\t// Move parentheses left and right\\n        expand(left - 1, right + 1, expression);\\n        \\n    }\\n\\t\\n\\t/* This function is responsible for calculating the expressions of each variable.\\n\\n\\ta = (0, left) // from the start of the expression to the first parentheses\\n\\tb = (left, right) // between parentheses, include plus sign\\n\\tc = (right, end of expression) // from the last parentheses to the end\\n\\t*/\\n    private int evaluate(int left, int right, String expression){\\n        \\n\\t\\t// This means that the parentheses are at the beginning or end of the expression and are equal to the range of the expression to be evaluated. Return 1 to avoid zero factors in equation (a * b * c).\\n        if(left == right)\\n            return 1;\\n        \\n        int number = 0;\\n\\n        for(int i = left; i < right; i++)\\n        {\\n\\t\\t\\t// If we find a sign, we must add both parts, therefore, we convert the expression to (a + b). \\n\\t\\t\\t// We return the variable (a) wich is (number) and add to what follows after the sign (i + 1). \\n\\t\\t\\t// We call the same function to calculate the b value.\\n            if(expression.charAt(i) == \\'+\\')\\n                return number + evaluate(i + 1, right, expression);\\n            else\\n                number = (number * 10) + (expression.charAt(i) - \\'0\\');\\n        }\\n        \\n        return number;\\n            \\n    }\\n    \\n/** Test cases\\n\\n\"12+34\"\\n\"247+38\"\\n\"999+999\"\\n\"1+1\"\\n\"123+3445\"\\n\"155+11\"\\n\"11+1\"\\n\"9+29\"\\n\\n**/\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n\\t// Variables for final solution, to avoid create combination Strings\\n    private int currentLeft = 0;\\n    private int currentRight = 0;\\n    private int currentMin = Integer.MAX_VALUE;\\n    \\n    public String minimizeResult(String expression) {\\n        \\n\\t\\t// Identify our starting point, to apply the expansion technique\\n        int plusIndex = expression.indexOf(\"+\");\\n        \\n\\t\\t// We start expanding from the first values to the left and right of the center (plus sign).\\n        expand(plusIndex - 1, plusIndex + 1, expression);\\n        \\n\\t\\t// Build the final String. We add the parentheses to our expression in the already calculated indices, defined as global variables.\\n        StringBuilder stringBuilder = new StringBuilder();\\n        \\n        for(int i = 0; i < expression.length(); i++)\\n        {\\n            if(i == currentLeft)\\n                stringBuilder.append(\\'(\\');\\n            \\n            stringBuilder.append(expression.charAt(i));\\n            \\n            if(i == currentRight)\\n                stringBuilder.append(\\')\\');\\n        }\\n        \\n\\t\\t// Edge case, if parentheses need to be inserted at the end of expression\\n        if(currentRight == expression.length())\\n            stringBuilder.append(\\')\\');\\n        \\n        return stringBuilder.toString();\\n        \\n    }\\n    \\n\\t// With this function, we calculate all possible combinations of parentheses from two pointers, left and right.\\n    private void expand(int left, int right, String expression){\\n    \\n        if(left < 0 || right >= expression.length())\\n            return;\\n        \\n\\t\\t// from zero to first parentheses\\n        int a = evaluate(0, left, expression);\\n\\t\\t\\n\\t\\t// from first parentheses to right parentheses (+1 means inclusive)\\n        int b = evaluate(left, right + 1, expression); \\n\\t\\t\\n\\t\\t// from right parentheses to the end of expression (+1 means inclusive)\\n        int c = evaluate(right + 1, expression.length(), expression);\\n        \\n\\t\\t// If the expression a * b * c is less than our current minimum\\n\\t\\t// this is our solution, we replace the variables with these new values.\\n        if((a * b * c) < currentMin)\\n        {\\n            currentMin = a * b * c;\\n            currentLeft = left;\\n            currentRight = right;\\n        }\\n        \\n        // Move parentheses left only\\n        expand(left - 1, right, expression);\\n\\t\\t\\n\\t\\t// Move parentheses right only\\n        expand(left, right + 1, expression);\\n\\t\\t\\n\\t\\t// Move parentheses left and right\\n        expand(left - 1, right + 1, expression);\\n        \\n    }\\n\\t\\n\\t/* This function is responsible for calculating the expressions of each variable.\\n\\n\\ta = (0, left) // from the start of the expression to the first parentheses\\n\\tb = (left, right) // between parentheses, include plus sign\\n\\tc = (right, end of expression) // from the last parentheses to the end\\n\\t*/\\n    private int evaluate(int left, int right, String expression){\\n        \\n\\t\\t// This means that the parentheses are at the beginning or end of the expression and are equal to the range of the expression to be evaluated. Return 1 to avoid zero factors in equation (a * b * c).\\n        if(left == right)\\n            return 1;\\n        \\n        int number = 0;\\n\\n        for(int i = left; i < right; i++)\\n        {\\n\\t\\t\\t// If we find a sign, we must add both parts, therefore, we convert the expression to (a + b). \\n\\t\\t\\t// We return the variable (a) wich is (number) and add to what follows after the sign (i + 1). \\n\\t\\t\\t// We call the same function to calculate the b value.\\n            if(expression.charAt(i) == \\'+\\')\\n                return number + evaluate(i + 1, right, expression);\\n            else\\n                number = (number * 10) + (expression.charAt(i) - \\'0\\');\\n        }\\n        \\n        return number;\\n            \\n    }\\n    \\n/** Test cases\\n\\n\"12+34\"\\n\"247+38\"\\n\"999+999\"\\n\"1+1\"\\n\"123+3445\"\\n\"155+11\"\\n\"11+1\"\\n\"9+29\"\\n\\n**/\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944259,
                "title": "java-1ms",
                "content": "```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        // add 1 pair of parentheses to expression \"<Num1>+<Num2>\" to make \\n        // minimized aa(bb+cc)dd (where aa and/or dd could be implied \\'1\\')  \\n        \\n        final int plusAt = expression.indexOf(\\'+\\');\\n        final String term0 = expression.substring(0,plusAt);\\n        final String term1 = expression.substring(plusAt+1);\\n        int max = Integer.valueOf(term0)+Integer.valueOf(term1);\\n        int ijMax = term1.length(); //(i<<8) | j\\n        \\n        for (int i=0; i<term0.length(); ++i)\\n            for (int j=1; j<=term1.length(); ++j){\\n                final int midMx = Integer.valueOf(term0.substring(i)) + Integer.valueOf(term1.substring(0,j));\\n                final int lftMx = (i==0) ? 1 : Integer.valueOf(term0.substring(0,i));\\n                final int rtMx = (j==term1.length()) ? 1 : Integer.valueOf(term1.substring(j));\\n                final int chk = lftMx * midMx * rtMx;\\n                if(chk>=max)\\n                    continue;\\n                ijMax=(i<<8)|j;\\n                max = chk;\\n            }\\n        final StringBuilder maxExpr = new StringBuilder();\\n        final int i = ijMax>>8;\\n        final int j = ijMax&0xff;\\n        if (i>0)\\n            maxExpr.append(term0.substring(0,i));\\n        maxExpr.append(\\'(\\').append(term0.substring(i)).append(\\'+\\').append(term1.substring(0,j)).append(\\')\\');\\n        if (j<term1.length())\\n            maxExpr.append(term1.substring(j));\\n        return maxExpr.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String minimizeResult(String expression) {\\n        // add 1 pair of parentheses to expression \"<Num1>+<Num2>\" to make \\n        // minimized aa(bb+cc)dd (where aa and/or dd could be implied \\'1\\')  \\n        \\n        final int plusAt = expression.indexOf(\\'+\\');\\n        final String term0 = expression.substring(0,plusAt);\\n        final String term1 = expression.substring(plusAt+1);\\n        int max = Integer.valueOf(term0)+Integer.valueOf(term1);\\n        int ijMax = term1.length(); //(i<<8) | j\\n        \\n        for (int i=0; i<term0.length(); ++i)\\n            for (int j=1; j<=term1.length(); ++j){\\n                final int midMx = Integer.valueOf(term0.substring(i)) + Integer.valueOf(term1.substring(0,j));\\n                final int lftMx = (i==0) ? 1 : Integer.valueOf(term0.substring(0,i));\\n                final int rtMx = (j==term1.length()) ? 1 : Integer.valueOf(term1.substring(j));\\n                final int chk = lftMx * midMx * rtMx;\\n                if(chk>=max)\\n                    continue;\\n                ijMax=(i<<8)|j;\\n                max = chk;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1938155,
                "title": "java-clear-concise",
                "content": "```\\nclass Solution {\\n    \\n    String s1, s2, ans;\\n    int res;\\n    \\n    public String minimizeResult(String expression) {\\n        this.ans = \"\"; this.res = Integer.MAX_VALUE;\\n        String[] exp = expression.split(\"\\\\\\\\+\"); \\n        this.s1 = exp[0]; this.s2 = exp[1];\\n       \\n        help(0, s2.length());\\n        return ans;\\n    }\\n    \\n    private void help(int l, int r) {\\n        if (l >= s1.length() || r <= 0) return;\\n            \\n        int mul1 = 1, mul2 = 1, sum1 = 0, sum2 = 0;\\n        \\n        if (!s1.substring(0, l).equals(\"\")) mul1 = Integer.parseInt(s1.substring(0, l));\\n        if (!s1.substring(l, s1.length()).equals(\"\")) sum1 = Integer.parseInt(s1.substring(l, s1.length()));\\n        if (!s2.substring(0, r).equals(\"\")) sum2 = Integer.parseInt(s2.substring(0, r));\\n        if (!s2.substring(r, s2.length()).equals(\"\")) mul2 = Integer.parseInt(s2.substring(r, s2.length()));\\n        \\n        int cur = (sum1 + sum2) * mul1 * mul2;\\n        \\n        if (cur < res) {\\n            ans = s1.substring(0, l) + \"(\" + s1.substring(l, s1.length()) + \"+\" + s2.substring(0, r) + \")\" + s2.substring(r, s2.length());\\n            res = cur;\\n        }\\n        \\n        help(l + 1, r); help(l, r - 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    String s1, s2, ans;\\n    int res;\\n    \\n    public String minimizeResult(String expression) {\\n        this.ans = \"\"; this.res = Integer.MAX_VALUE;\\n        String[] exp = expression.split(\"\\\\\\\\+\"); \\n        this.s1 = exp[0]; this.s2 = exp[1];\\n       \\n        help(0, s2.length());\\n        return ans;\\n    }\\n    \\n    private void help(int l, int r) {\\n        if (l >= s1.length() || r <= 0) return;\\n            \\n        int mul1 = 1, mul2 = 1, sum1 = 0, sum2 = 0;\\n        \\n        if (!s1.substring(0, l).equals(\"\")) mul1 = Integer.parseInt(s1.substring(0, l));\\n        if (!s1.substring(l, s1.length()).equals(\"\")) sum1 = Integer.parseInt(s1.substring(l, s1.length()));\\n        if (!s2.substring(0, r).equals(\"\")) sum2 = Integer.parseInt(s2.substring(0, r));\\n        if (!s2.substring(r, s2.length()).equals(\"\")) mul2 = Integer.parseInt(s2.substring(r, s2.length()));\\n        \\n        int cur = (sum1 + sum2) * mul1 * mul2;\\n        \\n        if (cur < res) {\\n            ans = s1.substring(0, l) + \"(\" + s1.substring(l, s1.length()) + \"+\" + s2.substring(0, r) + \")\" + s2.substring(r, s2.length());\\n            res = cur;\\n        }\\n        \\n        help(l + 1, r); help(l, r - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935470,
                "title": "c-100-faster-in-time-and-space-with-explanation",
                "content": "Let\\'s look at the constraints of this problem. The length of the equation will be at most 10. \\nSo in how many ways can we put 2 brackets such that they are separated by the ```\\'+\\'```?\\nIf you do some simple maths you can understand that this problem can be done by a simple brute force.\\nHeres what we are gonna do.\\n1. Find the index of the ```+```, let\\'s call it ```idx```\\n2. Start from index 0 till ```idx-1```, since we can put bracket before the numbers.\\n3. Similarly iterate from ```idx+1``` till the end, keeping track of the final result.\\nLet\\'s see the code to make it more clear.\\n```\\nclass Solution {\\npublic:\\n    \\n\\t// st means we are adding opening bracket just after the index st\\n\\t// end means we are adding closing bracket just after the index end\\n\\t// br is the index of \\'+\\'\\n    int findVal(string s, int st, int end, int br)\\n    {\\n\\t\\t// valf is the value before the opening bracket\\n\\t\\t// valm is the value between the brackets consisting the \\'+\\'\\n\\t\\t// vale is the value after the closing bracket\\n        int valf = 0, valm = 0, vale = 0;\\n        if(st == 0)\\n            valf = 1;\\n        else\\n            valf = stoi(s.substr(0, st));\\n        \\n        if(end == s.size())\\n            vale = 1;\\n        else\\n            vale = stoi(s.substr(end));\\n        \\n        valm = stoi(s.substr(st, br - st)) + stoi(s.substr(br + 1, end - br - 1));\\n        return valf * valm * vale;\\n    }\\n    \\n    string minimizeResult(string s)\\n    {\\n        int id = s.find(\\'+\\');\\n        int n = s.size();\\n        \\n        int mn = INT_MAX;\\n\\t\\t\\n\\t\\t// to keep track of the place of brackets such that the result at that place is minimum\\n        int st = -1, end = -1;\\n        \\n        for(int i = 0; i < id; i++)\\n        {\\n            for(int j = id + 2; j <= n; j++)\\n            {\\n                int v = findVal(s, i, j, id);\\n                if(v < mn)\\n                    mn = v, st = i, end = j;\\n            }\\n        }\\n        string res;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i == st)\\n                res += \\'(\\';\\n            else if(i == end)\\n                res += \\')\\';\\n            res += s[i];\\n        }\\n        \\n        if(end == n)\\n            res += \\')\\';\\n        \\n        return res;\\n    }\\n};\\n```\\nTime complexity - ```O(n^3)```\\nSpace complexity - ```O(1)```\\n",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\'+\\'```\n```+```\n```idx```\n```idx-1```\n```idx+1```\n```\\nclass Solution {\\npublic:\\n    \\n\\t// st means we are adding opening bracket just after the index st\\n\\t// end means we are adding closing bracket just after the index end\\n\\t// br is the index of \\'+\\'\\n    int findVal(string s, int st, int end, int br)\\n    {\\n\\t\\t// valf is the value before the opening bracket\\n\\t\\t// valm is the value between the brackets consisting the \\'+\\'\\n\\t\\t// vale is the value after the closing bracket\\n        int valf = 0, valm = 0, vale = 0;\\n        if(st == 0)\\n            valf = 1;\\n        else\\n            valf = stoi(s.substr(0, st));\\n        \\n        if(end == s.size())\\n            vale = 1;\\n        else\\n            vale = stoi(s.substr(end));\\n        \\n        valm = stoi(s.substr(st, br - st)) + stoi(s.substr(br + 1, end - br - 1));\\n        return valf * valm * vale;\\n    }\\n    \\n    string minimizeResult(string s)\\n    {\\n        int id = s.find(\\'+\\');\\n        int n = s.size();\\n        \\n        int mn = INT_MAX;\\n\\t\\t\\n\\t\\t// to keep track of the place of brackets such that the result at that place is minimum\\n        int st = -1, end = -1;\\n        \\n        for(int i = 0; i < id; i++)\\n        {\\n            for(int j = id + 2; j <= n; j++)\\n            {\\n                int v = findVal(s, i, j, id);\\n                if(v < mn)\\n                    mn = v, st = i, end = j;\\n            }\\n        }\\n        string res;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i == st)\\n                res += \\'(\\';\\n            else if(i == end)\\n                res += \\')\\';\\n            res += s[i];\\n        }\\n        \\n        if(end == n)\\n            res += \\')\\';\\n        \\n        return res;\\n    }\\n};\\n```\n```O(n^3)```\n```O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1933797,
                "title": "easy-to-understand-c-generate-pairs-100-faster",
                "content": "As it is given in the question that ```3 <= expression.length <= 10```, we can try out brute-force approach.\\nLet\\'s place the brackets at each valid position and find the value of the resulting expression and maintain the one with minimum value.\\n\\n```\\nstring minimizeResult(string exp) {\\n        int index = exp.find(\\'+\\');\\n        int n = exp.size();\\n        int res = INT_MAX;\\n        int I = 0, J = 0;\\n        for(int i = 0; i < index; i++){\\n            for(int j =1; j < exp.size() - index; j++){\\n                // p1 * (s1 + s2) * p2\\n                int p1 = i > 0 ? stoi(exp.substr(0, i)) : 1;\\n                int s1 = stoi(exp.substr(i, index-i));\\n                cout<<s1<<endl;\\n                int s2 = stoi(exp.substr(index+1, j));\\n                cout<<s2<<endl;\\n                int p2 = j == exp.size() - index - 1 ? 1 : stoi(exp.substr(index+j+1, n-j));\\n                int calc = p1 * (s1+s2) * p2;\\n                cout<<p1<<\\'*\\'<<(s1+s2)<<\"*\"<<p2<<\"->\"<<calc<<endl;\\n                if(res > (calc)){\\n                    res = calc;\\n                    //Keep track of the parenthesis position of the minimum value expression\\n                    I=i,J=index+j+1;\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i = 0; i < exp.size(); i++){\\n            //Look for the position and append corresponding parenthesis\\n            if(i == I){\\n                ans.push_back(\\'(\\');\\n            }else if(i == J){\\n                ans.push_back(\\')\\');\\n            }\\n            ans.push_back(exp[i]);\\n        }\\n        if(J >= exp.size()) ans.push_back(\\')\\');\\n        return ans;\\n    }\\n```\\n\\nHappy Coding!\\nPeace\\n\\t\\n\\t",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```3 <= expression.length <= 10```\n```\\nstring minimizeResult(string exp) {\\n        int index = exp.find(\\'+\\');\\n        int n = exp.size();\\n        int res = INT_MAX;\\n        int I = 0, J = 0;\\n        for(int i = 0; i < index; i++){\\n            for(int j =1; j < exp.size() - index; j++){\\n                // p1 * (s1 + s2) * p2\\n                int p1 = i > 0 ? stoi(exp.substr(0, i)) : 1;\\n                int s1 = stoi(exp.substr(i, index-i));\\n                cout<<s1<<endl;\\n                int s2 = stoi(exp.substr(index+1, j));\\n                cout<<s2<<endl;\\n                int p2 = j == exp.size() - index - 1 ? 1 : stoi(exp.substr(index+j+1, n-j));\\n                int calc = p1 * (s1+s2) * p2;\\n                cout<<p1<<\\'*\\'<<(s1+s2)<<\"*\"<<p2<<\"->\"<<calc<<endl;\\n                if(res > (calc)){\\n                    res = calc;\\n                    //Keep track of the parenthesis position of the minimum value expression\\n                    I=i,J=index+j+1;\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i = 0; i < exp.size(); i++){\\n            //Look for the position and append corresponding parenthesis\\n            if(i == I){\\n                ans.push_back(\\'(\\');\\n            }else if(i == J){\\n                ans.push_back(\\')\\');\\n            }\\n            ans.push_back(exp[i]);\\n        }\\n        if(J >= exp.size()) ans.push_back(\\')\\');\\n        return ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1933428,
                "title": "c-easy-implementation",
                "content": "\\n    pair<int,pair<int,int>> fun(string&exp,int&i,int&j,int&op,int&n){\\n        int num1=1,num2=0,num3=0,num4=1;\\n        int p=0;\\n        if(p!=i){\\n            num1=0;\\n            while(p<i){\\n                num1=num1*10+(exp[p]-\\'0\\');\\n                p++;\\n            }\\n        }\\n        while(p<op){\\n            num2=num2*10+(exp[p]-\\'0\\');\\n            p++;\\n        }\\n        p++;\\n        while(p<=j){\\n            num3=num3*10+(exp[p]-\\'0\\');\\n            p++;\\n        }\\n        if(p!=n){\\n            num4=0;\\n            while(p<n){\\n                num4=num4*10+(exp[p]-\\'0\\');\\n                p++;\\n            }\\n        }\\n        return {num1*(num2+num3)*num4,{i,j}};\\n    }\\n    string minimizeResult(string exp){\\n        int n=exp.length(),op;\\n        for(int i=0;i<n;i++){\\n            if(exp[i]==\\'+\\'){\\n                op=i;\\n                break;\\n            }\\n        }\\n        pair<int,pair<int,int>>p(INT_MAX,{-1,-1});\\n        int i=0;\\n        while(i<op){\\n            int j=op+1;\\n            while(j<n){\\n                pair<int,pair<int,int>>curr=fun(exp,i,j,op,n);\\n                if(curr.first<p.first) p=curr;\\n                j++;\\n            }\\n            i++;\\n        }\\n        string st=\"\";\\n        i=0;\\n        while(i<p.second.first){\\n            st+=exp[i];\\n            i++;\\n        }\\n        st+=\\'(\\';\\n        while(i<=p.second.second){\\n            st+=exp[i];\\n            i++;\\n        }\\n        st+=\\')\\';\\n        while(i<n){\\n            st+=exp[i];\\n            i++;\\n        }\\n        return st;\\n    }",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "\\n    pair<int,pair<int,int>> fun(string&exp,int&i,int&j,int&op,int&n){\\n        int num1=1,num2=0,num3=0,num4=1;\\n        int p=0;\\n        if(p!=i){\\n            num1=0;\\n            while(p<i){\\n                num1=num1*10+(exp[p]-\\'0\\');\\n                p++;\\n            }\\n        }\\n        while(p<op){\\n            num2=num2*10+(exp[p]-\\'0\\');\\n            p++;\\n        }\\n        p++;\\n        while(p<=j){\\n            num3=num3*10+(exp[p]-\\'0\\');\\n            p++;\\n        }\\n        if(p!=n){\\n            num4=0;\\n            while(p<n){\\n                num4=num4*10+(exp[p]-\\'0\\');\\n                p++;\\n            }\\n        }\\n        return {num1*(num2+num3)*num4,{i,j}};\\n    }\\n    string minimizeResult(string exp){\\n        int n=exp.length(),op;\\n        for(int i=0;i<n;i++){\\n            if(exp[i]==\\'+\\'){\\n                op=i;\\n                break;\\n            }\\n        }\\n        pair<int,pair<int,int>>p(INT_MAX,{-1,-1});\\n        int i=0;\\n        while(i<op){\\n            int j=op+1;\\n            while(j<n){\\n                pair<int,pair<int,int>>curr=fun(exp,i,j,op,n);\\n                if(curr.first<p.first) p=curr;\\n                j++;\\n            }\\n            i++;\\n        }\\n        string st=\"\";\\n        i=0;\\n        while(i<p.second.first){\\n            st+=exp[i];\\n            i++;\\n        }\\n        st+=\\'(\\';\\n        while(i<=p.second.second){\\n            st+=exp[i];\\n            i++;\\n        }\\n        st+=\\')\\';\\n        while(i<n){\\n            st+=exp[i];\\n            i++;\\n        }\\n        return st;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1932681,
                "title": "python-easy-solution-two-pointers",
                "content": "```\\n# example : 241 + 97\\nclass Solution:\\n    def minimizeResult(self, exp: str) -> str:\\n        \\n        lo, n, mini, ans = 0, len(exp), float(\\'inf\\'), \\'\\'               # lo:  for placing opening paranthesis; hi : hi for placing closing paranthesis\\n        \\n        while exp[lo] != \\'+\\':                                          # move lo till we get \\'+\\', like invalid \\'241(+9\\'\\n            hi = n\\n            while exp[hi-1] != \\'+\\':                                    # for each left paranthesis we place the right paranthesis and evaluate\\n                left = exp[:lo] if lo else \\'1\\'                         # left: left part to opening paranthesis, why if else? case:  \\'(241 +\\', left is blank so we take 1\\n                right = exp[hi:] if hi != n else \\'1\\'                   # right: Similarly for closing, case: \\'+ 97)\\'\\n                val = eval(left + \\'*(\\' + exp[lo: hi] + \\')*\\' + right)   # evaluate the expression\\n                if val < mini:                                         # compare it with previous minimum \\n                    mini = val                                         # update mini\\n                    ans = exp[:lo] + \\'(\\' + exp[lo: hi] + \\')\\' + exp[hi:]# update ans\\n                hi -= 1                                                # decrement hi pointer\\n            lo += 1                                                    # increment lo pointer\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\n# example : 241 + 97\\nclass Solution:\\n    def minimizeResult(self, exp: str) -> str:\\n        \\n        lo, n, mini, ans = 0, len(exp), float(\\'inf\\'), \\'\\'               # lo:  for placing opening paranthesis; hi : hi for placing closing paranthesis\\n        \\n        while exp[lo] != \\'+\\':                                          # move lo till we get \\'+\\', like invalid \\'241(+9\\'\\n            hi = n\\n            while exp[hi-1] != \\'+\\':                                    # for each left paranthesis we place the right paranthesis and evaluate\\n                left = exp[:lo] if lo else \\'1\\'                         # left: left part to opening paranthesis, why if else? case:  \\'(241 +\\', left is blank so we take 1\\n                right = exp[hi:] if hi != n else \\'1\\'                   # right: Similarly for closing, case: \\'+ 97)\\'\\n                val = eval(left + \\'*(\\' + exp[lo: hi] + \\')*\\' + right)   # evaluate the expression\\n                if val < mini:                                         # compare it with previous minimum \\n                    mini = val                                         # update mini\\n                    ans = exp[:lo] + \\'(\\' + exp[lo: hi] + \\')\\' + exp[hi:]# update ans\\n                hi -= 1                                                # decrement hi pointer\\n            lo += 1                                                    # increment lo pointer\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932634,
                "title": "python-memory-usage-less-than-100-00",
                "content": "```\\nfrom copy import copy\\n\\n\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n\\n        result_expr = f\"({expression})\"\\n        min_result = eval(expression)\\n\\n        num1, num2 = expression.split(\\'+\\')\\n        num1_digits = [i for i in num1]\\n        num2_digits = [i for i in num2]\\n        for i in range(len(num1)):\\n            num1_digits_copy = copy(num1_digits)\\n            v1 = \\'*(\\' if i != 0 else \\'(\\'\\n            num1_digits_copy.insert(i, v1)\\n            first_part = \\'\\'.join(num1_digits_copy)\\n            for j in range(len(num2)):\\n                num2_digits_copy = copy(num2_digits)\\n\\n                v = \\')*\\' if j != 0 else \\')\\'\\n                num2_digits_copy.insert(len(num2) - j, v)\\n                second_part = \\'\\'.join(num2_digits_copy)\\n                current_expression = f\"{first_part}+{second_part}\"\\n\\n                current_eval = eval(current_expression)\\n                if current_eval < min_result:\\n                    min_result = current_eval\\n                    result_expr = current_expression\\n\\n        return result_expr.replace(\\'*\\', \\'\\')\\n\\n\\nif __name__ == \"__main__\":\\n    obj = Solution()\\n\\n    assert obj.minimizeResult(\"999+999\") == \"(999+999)\"\\n\\n    assert obj.minimizeResult(\"12+34\") == \"1(2+3)4\"\\n\\n    assert obj.minimizeResult(\"247+38\") == \"2(47+38)\"\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom copy import copy\\n\\n\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n\\n        result_expr = f\"({expression})\"\\n        min_result = eval(expression)\\n\\n        num1, num2 = expression.split(\\'+\\')\\n        num1_digits = [i for i in num1]\\n        num2_digits = [i for i in num2]\\n        for i in range(len(num1)):\\n            num1_digits_copy = copy(num1_digits)\\n            v1 = \\'*(\\' if i != 0 else \\'(\\'\\n            num1_digits_copy.insert(i, v1)\\n            first_part = \\'\\'.join(num1_digits_copy)\\n            for j in range(len(num2)):\\n                num2_digits_copy = copy(num2_digits)\\n\\n                v = \\')*\\' if j != 0 else \\')\\'\\n                num2_digits_copy.insert(len(num2) - j, v)\\n                second_part = \\'\\'.join(num2_digits_copy)\\n                current_expression = f\"{first_part}+{second_part}\"\\n\\n                current_eval = eval(current_expression)\\n                if current_eval < min_result:\\n                    min_result = current_eval\\n                    result_expr = current_expression\\n\\n        return result_expr.replace(\\'*\\', \\'\\')\\n\\n\\nif __name__ == \"__main__\":\\n    obj = Solution()\\n\\n    assert obj.minimizeResult(\"999+999\") == \"(999+999)\"\\n\\n    assert obj.minimizeResult(\"12+34\") == \"1(2+3)4\"\\n\\n    assert obj.minimizeResult(\"247+38\") == \"2(47+38)\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932275,
                "title": "easy-code-100-runtime-100-memory-c",
                "content": "![image](https://assets.leetcode.com/users/images/9a88e603-b1d6-48c7-ac6b-8b3656050976_1649577966.8470078.png)\\n\\n## **Solution**\\n\\n#### **Code**  \\n```cpp\\nclass Solution {\\npublic:\\n    string minimizeResult(string expression) {\\n        string a = \"\", b = \"\";\\n        int maxa, maxb, maxca, maxcb;\\n        bool plus = false;\\n        \\n        for (auto x : expression) {\\n            if (x == \\'+\\') plus = true;\\n            else if (plus) b += x;\\n            else a += x;\\n        }\\n        \\n        int soli = INT_MAX;\\n        for (int i = 0; i < a.size(); i++) {\\n            for (int j = b.size(); j > 0; j--) {\\n                int ai = i == 0 ? 1 : stoi(a.substr(0, i));\\n                int ca = stoi(a.substr(i));\\n                int cb = stoi(b.substr(0, j));\\n                int bi = j == b.size() ? 1 : stoi(b.substr(j));\\n                if (soli > (ai * (ca + cb) * bi)) {\\n                    maxa = i == 0 ? -1 : ai;\\n                    maxb = j == b.size() ? -1 : bi;\\n                    maxca = ca;\\n                    maxcb = cb;\\n                    soli = ai * (ca + cb) * bi;\\n                }\\n            }\\n        }\\n        \\n        if (maxa == -1 && maxb == -1) {\\n            return \\'(\\' + to_string(maxca) + \\'+\\' + to_string(maxcb) + \\')\\';\\n        }\\n        else if(maxa == -1) {\\n            return \\'(\\' + to_string(maxca) + \\'+\\' + to_string(maxcb) + \\')\\' + to_string(maxb);            \\n        }\\n        else if (maxb == -1) {\\n             return to_string(maxa) + \\'(\\' + to_string(maxca) + \\'+\\' + to_string(maxcb) + \\')\\';       \\n        }\\n        else {\\n            return to_string(maxa) + \\'(\\' + to_string(maxca) + \\'+\\' + to_string(maxcb) + \\')\\' + to_string(maxb);\\n        } \\n    }\\n};\\n```\\n\\n\\n __Check out all [my](https://leetcode.com/siddp6/) recent solutions [here](https://github.com/sidd6p/LeetCode)__\\n\\n \\n __Feel Free to Ask Doubts\\nAnd Please Share Some Suggestions\\nHAPPY CODING :)__\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string minimizeResult(string expression) {\\n        string a = \"\", b = \"\";\\n        int maxa, maxb, maxca, maxcb;\\n        bool plus = false;\\n        \\n        for (auto x : expression) {\\n            if (x == \\'+\\') plus = true;\\n            else if (plus) b += x;\\n            else a += x;\\n        }\\n        \\n        int soli = INT_MAX;\\n        for (int i = 0; i < a.size(); i++) {\\n            for (int j = b.size(); j > 0; j--) {\\n                int ai = i == 0 ? 1 : stoi(a.substr(0, i));\\n                int ca = stoi(a.substr(i));\\n                int cb = stoi(b.substr(0, j));\\n                int bi = j == b.size() ? 1 : stoi(b.substr(j));\\n                if (soli > (ai * (ca + cb) * bi)) {\\n                    maxa = i == 0 ? -1 : ai;\\n                    maxb = j == b.size() ? -1 : bi;\\n                    maxca = ca;\\n                    maxcb = cb;\\n                    soli = ai * (ca + cb) * bi;\\n                }\\n            }\\n        }\\n        \\n        if (maxa == -1 && maxb == -1) {\\n            return \\'(\\' + to_string(maxca) + \\'+\\' + to_string(maxcb) + \\')\\';\\n        }\\n        else if(maxa == -1) {\\n            return \\'(\\' + to_string(maxca) + \\'+\\' + to_string(maxcb) + \\')\\' + to_string(maxb);            \\n        }\\n        else if (maxb == -1) {\\n             return to_string(maxa) + \\'(\\' + to_string(maxca) + \\'+\\' + to_string(maxcb) + \\')\\';       \\n        }\\n        else {\\n            return to_string(maxa) + \\'(\\' + to_string(maxca) + \\'+\\' + to_string(maxcb) + \\')\\' + to_string(maxb);\\n        } \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931858,
                "title": "java-clean-code",
                "content": "```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        int plusPosition=findPlusPosition(expression);\\n        int minimumSum=Integer.MAX_VALUE;\\n        String minimumResult=\"\";\\n        for(int leftPosition=plusPosition-2;leftPosition>=-1;leftPosition--){\\n            for(int rightPosition=plusPosition+2;rightPosition<=expression.length();rightPosition++){\\n                int currentSum=evaluateSum(expression,leftPosition,plusPosition,rightPosition);\\n                if(currentSum<minimumSum){\\n                    minimumResult=getExpression(expression,leftPosition,plusPosition,rightPosition);\\n                    minimumSum=currentSum;\\n                }\\n            }\\n        }\\n        return minimumResult;\\n    }\\n    public int evaluateSum(String expression,int leftPosition,int plusPosition,int rightPosition){\\n        int num1,num2,num3,num4;\\n        num1=num2=num3=num4=0;\\n        num2=Integer.parseInt(expression.substring(leftPosition+1,plusPosition));\\n        num3=Integer.parseInt(expression.substring(plusPosition+1,rightPosition));\\n        int sum=num2+num3;\\n        if(leftPosition!=-1){\\n            num1=Integer.parseInt(expression.substring(0,leftPosition+1));\\n            sum*=num1;\\n        }\\n        if(rightPosition!=expression.length()){\\n            num4=Integer.parseInt(expression.substring(rightPosition,expression.length()));\\n            sum*=num4;\\n        }\\n        return sum;\\n    }\\n    public String getExpression(String expression,int leftPosition,int plusPosition,int rightPosition){\\n        StringBuilder sb=new StringBuilder();\\n        for(int index=0;index<=leftPosition;index++){\\n                sb.append(expression.charAt(index));\\n        }\\n        sb.append(\"(\");\\n        sb.append(expression.substring(leftPosition+1,plusPosition));\\n        sb.append(\"+\");\\n        sb.append(expression.substring(plusPosition+1,rightPosition));\\n        sb.append(\")\");\\n        for(int index=rightPosition;index<expression.length();index++){\\n            sb.append(expression.charAt(index));\\n        }\\n        return sb.toString();\\n    }\\n    public int findPlusPosition(String expression){\\n        int index=0;\\n        while(expression.charAt(index)!=\\'+\\'){\\n            index++;\\n        }\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        int plusPosition=findPlusPosition(expression);\\n        int minimumSum=Integer.MAX_VALUE;\\n        String minimumResult=\"\";\\n        for(int leftPosition=plusPosition-2;leftPosition>=-1;leftPosition--){\\n            for(int rightPosition=plusPosition+2;rightPosition<=expression.length();rightPosition++){\\n                int currentSum=evaluateSum(expression,leftPosition,plusPosition,rightPosition);\\n                if(currentSum<minimumSum){\\n                    minimumResult=getExpression(expression,leftPosition,plusPosition,rightPosition);\\n                    minimumSum=currentSum;\\n                }\\n            }\\n        }\\n        return minimumResult;\\n    }\\n    public int evaluateSum(String expression,int leftPosition,int plusPosition,int rightPosition){\\n        int num1,num2,num3,num4;\\n        num1=num2=num3=num4=0;\\n        num2=Integer.parseInt(expression.substring(leftPosition+1,plusPosition));\\n        num3=Integer.parseInt(expression.substring(plusPosition+1,rightPosition));\\n        int sum=num2+num3;\\n        if(leftPosition!=-1){\\n            num1=Integer.parseInt(expression.substring(0,leftPosition+1));\\n            sum*=num1;\\n        }\\n        if(rightPosition!=expression.length()){\\n            num4=Integer.parseInt(expression.substring(rightPosition,expression.length()));\\n            sum*=num4;\\n        }\\n        return sum;\\n    }\\n    public String getExpression(String expression,int leftPosition,int plusPosition,int rightPosition){\\n        StringBuilder sb=new StringBuilder();\\n        for(int index=0;index<=leftPosition;index++){\\n                sb.append(expression.charAt(index));\\n        }\\n        sb.append(\"(\");\\n        sb.append(expression.substring(leftPosition+1,plusPosition));\\n        sb.append(\"+\");\\n        sb.append(expression.substring(plusPosition+1,rightPosition));\\n        sb.append(\")\");\\n        for(int index=rightPosition;index<expression.length();index++){\\n            sb.append(expression.charAt(index));\\n        }\\n        return sb.toString();\\n    }\\n    public int findPlusPosition(String expression){\\n        int index=0;\\n        while(expression.charAt(index)!=\\'+\\'){\\n            index++;\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931680,
                "title": "cpp-solution-using-substr-function",
                "content": "```\\nclass Solution {\\npublic: \\n    string minimizeResult(string s) {\\n        int n1 = 0, n2 = 0;\\n        int i = 0;\\n        for(;i<s.size();i++) {\\n            if(s[i]==\\'+\\') break;\\n            else n1 = n1*10 + (s[i]-\\'0\\');\\n        }\\n        \\n        for(int j = i+1;j<s.size();j++) {\\n            n2 = n2*10 + (s[j]-\\'0\\');\\n        }\\n        // cout<<n1<<\" \"<<n2<<\"\\\\n\";\\n        int res = 1e8;\\n        string s1 = to_string(n1), s2 = to_string(n2);\\n        int br1 = 0, br2 = s2.size()-1;\\n        for(int i = 0;i<s1.size();i++) {\\n            for(int j = 0;j<s2.size();j++) {\\n                string temp1 = s1.substr(0, i), temp3 = s2.substr(j+1, s2.size()-j - 1), temp2 = s1.substr(i, s1.size()-i), temp4 = s2.substr(0, j+1); \\n                int x1 = temp1==\"\"?1:stoi(temp1);\\n                int x3 = temp3==\"\"?1:stoi(temp3);\\n                int x2 = stoi(temp2) + stoi(temp4);\\n                \\n                if(x1*x2*x3<res) {\\n                    br1 = i, br2 = j;\\n                    res = x1*x2*x3;\\n                }\\n            }\\n        }\\n        \\n        string ans = s1.substr(0, br1) + \\'(\\' + s1.substr(br1, s1.size() - br1) + \\'+\\' + s2.substr(0, br2+1) + \\')\\' + s2.substr(br2+1, s2.size()-br2 - 1);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    string minimizeResult(string s) {\\n        int n1 = 0, n2 = 0;\\n        int i = 0;\\n        for(;i<s.size();i++) {\\n            if(s[i]==\\'+\\') break;\\n            else n1 = n1*10 + (s[i]-\\'0\\');\\n        }\\n        \\n        for(int j = i+1;j<s.size();j++) {\\n            n2 = n2*10 + (s[j]-\\'0\\');\\n        }\\n        // cout<<n1<<\" \"<<n2<<\"\\\\n\";\\n        int res = 1e8;\\n        string s1 = to_string(n1), s2 = to_string(n2);\\n        int br1 = 0, br2 = s2.size()-1;\\n        for(int i = 0;i<s1.size();i++) {\\n            for(int j = 0;j<s2.size();j++) {\\n                string temp1 = s1.substr(0, i), temp3 = s2.substr(j+1, s2.size()-j - 1), temp2 = s1.substr(i, s1.size()-i), temp4 = s2.substr(0, j+1); \\n                int x1 = temp1==\"\"?1:stoi(temp1);\\n                int x3 = temp3==\"\"?1:stoi(temp3);\\n                int x2 = stoi(temp2) + stoi(temp4);\\n                \\n                if(x1*x2*x3<res) {\\n                    br1 = i, br2 = j;\\n                    res = x1*x2*x3;\\n                }\\n            }\\n        }\\n        \\n        string ans = s1.substr(0, br1) + \\'(\\' + s1.substr(br1, s1.size() - br1) + \\'+\\' + s2.substr(0, br2+1) + \\')\\' + s2.substr(br2+1, s2.size()-br2 - 1);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1931574,
                "title": "c-ez-solution-0ms-generate-all-possible-combination-of-brackets",
                "content": "Since the constraints are small we can generate all possible combinations of valid brackets, evaluate the expression and return that expression which is the minimum. I was suprised when my solution took 0ms to execute.\\n![image](https://assets.leetcode.com/users/images/17845916-2a9d-4bde-a942-446833ede55d_1649567233.3420317.png)\\nfunction eval()->Each valid generated expression is evaluated. Generating the four numbers seperately. \\n1. Before \\'(\\'  -> to be multiplied\\n2. After \\'(\\'  ->to be multiplied\\n3. Between ( ) -> the 2 nos to be added\\n\\nWe generate the brackets accordingly. After calculating the result of our generated expression we push that value and the expression into our priority queue (minHeap). At the end the top element is our required expression.\\nP.S = This is a bit difficult to be the 2nd question in weekly contest 288.\\n```\\nclass Solution {\\npublic:\\n    int eval(string s){\\n        int mul1=1,mul2=1,ind1=0,ind2=0,num1=0,num2=0;\\n        bool f=false;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\')            \\n                ind1=i;                \\n            \\n             if(s[i]==\\')\\')            \\n                ind2=i;\\n        }\\n        if(ind1!=0)\\n        mul1=stoi(s.substr(0,ind1));\\n        if(ind2!=s.length()-1)\\n        mul2=stoi(s.substr(ind2+1));\\n        for(int i=ind1+1;i<ind2;i++){\\n            if(!f&&s[i]!=\\'+\\')\\n                num1=num1*10+(s[i]-48);\\n            if(f)\\n                num2=num2*10+(s[i]-48);\\n            if(s[i]==\\'+\\')\\n                f=true;            \\n        }\\n       return((num1+num2)*mul1*mul2);\\n    }\\n    string minimizeResult(string expression) {\\n     if(expression.length()==3)\\n         return \"(\"+expression+\")\";\\n       priority_queue<pair<int,string>,vector<pair<int,string>>,greater<pair<int,string>>>pq;\\n        for(int i=0;i<expression.length();i++){\\n            if(expression[i]==\\'+\\')\\n                break;\\n            string tmp=expression;\\n            tmp.insert(i,\"(\");\\n            string tmp1=tmp;\\n            for(int j=0;j<expression.length();j++){\\n                if(expression[expression.length()-j-1]==\\'+\\')\\n                break;\\n                tmp.insert(expression.length()-j+1,\")\");\\n               //cout<<tmp<<\"\\\\n\";\\n                pq.push({eval(tmp),tmp});\\n                tmp=tmp1;\\n            }\\n        }       \\n        return pq.top().second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int eval(string s){\\n        int mul1=1,mul2=1,ind1=0,ind2=0,num1=0,num2=0;\\n        bool f=false;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\')            \\n                ind1=i;                \\n            \\n             if(s[i]==\\')\\')            \\n                ind2=i;\\n        }\\n        if(ind1!=0)\\n        mul1=stoi(s.substr(0,ind1));\\n        if(ind2!=s.length()-1)\\n        mul2=stoi(s.substr(ind2+1));\\n        for(int i=ind1+1;i<ind2;i++){\\n            if(!f&&s[i]!=\\'+\\')\\n                num1=num1*10+(s[i]-48);\\n            if(f)\\n                num2=num2*10+(s[i]-48);\\n            if(s[i]==\\'+\\')\\n                f=true;            \\n        }\\n       return((num1+num2)*mul1*mul2);\\n    }\\n    string minimizeResult(string expression) {\\n     if(expression.length()==3)\\n         return \"(\"+expression+\")\";\\n       priority_queue<pair<int,string>,vector<pair<int,string>>,greater<pair<int,string>>>pq;\\n        for(int i=0;i<expression.length();i++){\\n            if(expression[i]==\\'+\\')\\n                break;\\n            string tmp=expression;\\n            tmp.insert(i,\"(\");\\n            string tmp1=tmp;\\n            for(int j=0;j<expression.length();j++){\\n                if(expression[expression.length()-j-1]==\\'+\\')\\n                break;\\n                tmp.insert(expression.length()-j+1,\")\");\\n               //cout<<tmp<<\"\\\\n\";\\n                pq.push({eval(tmp),tmp});\\n                tmp=tmp1;\\n            }\\n        }       \\n        return pq.top().second;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1931540,
                "title": "easy-to-understand-intuition-solution-and-time-complexity-must-read-for-java-users",
                "content": "# This Solution would be helpful for beignners as it is easy to understand it. \\n**Would try to explain the better and faster way to solve it once I get the time, If I do then this text would be removed.**\\n\\nMany of us think the brute force approch won\\'t  work and we try to think of optimal solution, but it is neccesary to do the brute force first to understand if there is a pattern and if there is a pattern you can solve the mystry of the pattern and get a optimal solution.\\n\\nHere we can submit the brute for solution because the length of expression would be more 2 and less than 11 so the max length which we might have is N = 10 so here even N^2 solution would require 100 computation which can be easily done , why I said N^2 because we are going to check for each and every possible value obiously it would be N-1 because we don\\'t have to check for \"+\" but constant are ignored. \\n\\nWhen we are checking for all the possible values by making 2 loops and traversing from \"+\" to left and \"+\" to right for each value we will also require  to make substring to do the computation this will take O(N) time. For  Java there is String.substring() since you can\\'t see a loop many bignners think that it is a O(N) operation, but it isn\\'t . String.substring() is a O(N) because it traverse to the indexs which we mention and then provide us the value. Similarly Integer.parseInt() also takes O(N) operations, So the overall time complexity would be O(N^4).\\n\\nEnough Talking Let\\'s see the code , If there is anything which you didn\\'t undestand feel free to ask in the reply section.\\n\\n```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        int left = -1;\\n        int right = -1;\\n        int minVal = Integer.MAX_VALUE;\\n        char[] arr = expression.toCharArray();\\n        int len = arr.length;\\n        int idx = 0;\\n        for(int i=0;i<len;i++){\\n            char ch = arr[i];\\n            if(ch == \\'+\\'){\\n                idx = i;\\n                break;\\n            }\\n        }\\n        int l = idx - 1;\\n        int r = idx + 1;\\n        for(int i=l;i>=0;i--){\\n            for(int j=r;j<len;j++){\\n                int a = Integer.parseInt(expression.substring(i,idx));\\n                int b = Integer.parseInt(expression.substring(idx+1,j+1));\\n                int c = 1;\\n                int d = 1;\\n                if(i!=0) c = Integer.parseInt(expression.substring(0,i));\\n                if(j!=len-1) d = Integer.parseInt(expression.substring(j+1));\\n                int val = (a+b)*c*d;\\n                //System.out.println(val);\\n                if(val <= minVal){\\n                    minVal = val;\\n                    left = i;\\n                    right = j;\\n                }\\n            }\\n        }\\n        String strl = expression.substring(0,left);\\n        String strr = expression.substring(right+1);\\n        String strm = expression.substring(left,right+1);\\n        return ( strl + \\'(\\' + strm + \\')\\' + strr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        int left = -1;\\n        int right = -1;\\n        int minVal = Integer.MAX_VALUE;\\n        char[] arr = expression.toCharArray();\\n        int len = arr.length;\\n        int idx = 0;\\n        for(int i=0;i<len;i++){\\n            char ch = arr[i];\\n            if(ch == \\'+\\'){\\n                idx = i;\\n                break;\\n            }\\n        }\\n        int l = idx - 1;\\n        int r = idx + 1;\\n        for(int i=l;i>=0;i--){\\n            for(int j=r;j<len;j++){\\n                int a = Integer.parseInt(expression.substring(i,idx));\\n                int b = Integer.parseInt(expression.substring(idx+1,j+1));\\n                int c = 1;\\n                int d = 1;\\n                if(i!=0) c = Integer.parseInt(expression.substring(0,i));\\n                if(j!=len-1) d = Integer.parseInt(expression.substring(j+1));\\n                int val = (a+b)*c*d;\\n                //System.out.println(val);\\n                if(val <= minVal){\\n                    minVal = val;\\n                    left = i;\\n                    right = j;\\n                }\\n            }\\n        }\\n        String strl = expression.substring(0,left);\\n        String strr = expression.substring(right+1);\\n        String strm = expression.substring(left,right+1);\\n        return ( strl + \\'(\\' + strm + \\')\\' + strr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931370,
                "title": "c-brute-force-two-pointer",
                "content": "Main idea: \\n- Use two pointer to divide the equation into four numbers: num1,num2,num3,num4\\n- Compute all possible sum = num1 * (num2 + num3) * num4, and record location of the two pointers and update minSum if sum<minSum where minSum is minimun sum that we found.\\n\\t- In the case when num1 or num4 should be empty(eg.  `(999+999)`), we set them to 1 manualy `1*(999+999)*1`.\\n- Insert \\'(\\' and \\')\\' at correct position.\\n```\\nclass Solution {\\npublic:\\n    string minimizeResult(string expression) {\\n        int minSum=INT_MAX;\\n        int mid=expression.find(\\'+\\');//find position of \\'+\\'\\n        int toL=1,toR=1;//toL,toR represents distance from pointers to \\'+\\' at both side\\n        int maxL=0,maxR=0; //later:record the location of \\'(\\' and \\')\\'\\n        int num1,num2,num3,num4;\\n        while(mid-toL>=0){\\n            toR=1;\\n            while(mid+toR<expression.length()){\\n                if(mid-toL==0)num1=1; //if left pointer is at beginning of string =>(999+\\n                else  num1=stoi(expression.substr(0,mid-toL));\\n                if(mid+toR==expression.length()-1)num4=1;//if right pointer is at end of the string => +999)\\n                else num4=stoi(expression.substr(mid+toR+1));\\n                num2=stoi(expression.substr(mid-toL,toL));\\n                num3=stoi(expression.substr(mid+1,toR));\\n                if(num1*(num2+num3)*num4<minSum){\\n                    minSum=num1*(num2+num3)*num4;\\n                    maxL=toL;\\n                    maxR=toR;\\n                }\\n                toR++;\\n            }\\n            toL++;\\n        }\\n        expression.insert(mid+maxR+1,1,\\')\\');\\n        expression.insert(mid-maxL,1,\\'(\\');\\n        return expression;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string expression) {\\n        int minSum=INT_MAX;\\n        int mid=expression.find(\\'+\\');//find position of \\'+\\'\\n        int toL=1,toR=1;//toL,toR represents distance from pointers to \\'+\\' at both side\\n        int maxL=0,maxR=0; //later:record the location of \\'(\\' and \\')\\'\\n        int num1,num2,num3,num4;\\n        while(mid-toL>=0){\\n            toR=1;\\n            while(mid+toR<expression.length()){\\n                if(mid-toL==0)num1=1; //if left pointer is at beginning of string =>(999+\\n                else  num1=stoi(expression.substr(0,mid-toL));\\n                if(mid+toR==expression.length()-1)num4=1;//if right pointer is at end of the string => +999)\\n                else num4=stoi(expression.substr(mid+toR+1));\\n                num2=stoi(expression.substr(mid-toL,toL));\\n                num3=stoi(expression.substr(mid+1,toR));\\n                if(num1*(num2+num3)*num4<minSum){\\n                    minSum=num1*(num2+num3)*num4;\\n                    maxL=toL;\\n                    maxR=toR;\\n                }\\n                toR++;\\n            }\\n            toL++;\\n        }\\n        expression.insert(mid+maxR+1,1,\\')\\');\\n        expression.insert(mid-maxL,1,\\'(\\');\\n        return expression;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931360,
                "title": "simple-brute-force-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    long long toi(string s)\\n    {\\n        long long ans = 0;\\n        for(char c:s)\\n        {\\n            ans = ans * 10 + (c - \\'0\\');\\n        }\\n        return ans;\\n    }\\n    string minimizeResult(string expression) {\\n        int n = expression.length();\\n        int pivot = 0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(expression[i] == \\'+\\')\\n                pivot = i;\\n        }\\n\\n        long long mn = 1e10;\\n        int A;\\n        int B;\\n        for(int before = 0;before <= pivot - 1;before++)\\n        {\\n            for(int after = pivot + 1;after < n;after++)\\n            {\\n                long long a,b,c,d;\\n\\n                a = toi(expression.substr(0,before));\\n                b = toi(expression.substr(before,pivot - before));\\n\\n                c = toi(expression.substr(pivot + 1,after - pivot));\\n                d = toi(expression.substr(after + 1,n - after - 1));\\n                \\n                if(a == 0)a = 1;\\n                if(d == 0)d = 1;\\n                long long value = a * (b + c) * d;\\n                if(value < mn)\\n                {\\n                    mn = value;\\n                    A = after;\\n                    B = before;\\n                }\\n            }\\n        }\\n\\n        string ans;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i == B)\\n            {\\n                ans += \"(\";\\n            }\\n\\n            ans += expression[i];\\n\\n            if(i == A)\\n                ans += \")\";\\n        }\\n        return ans;\\n\\n\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long toi(string s)\\n    {\\n        long long ans = 0;\\n        for(char c:s)\\n        {\\n            ans = ans * 10 + (c - \\'0\\');\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1931302,
                "title": "python-clean-brute-force",
                "content": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        \\n        s = expression.split(\"+\")\\n        \\n        ans = []\\n        \\n        n1, n2 = len(s[0]), len(s[1])\\n        \\n        for i in range(0,n1+1):\\n            for j in range(0,n2+1):\\n                l, ml, mr, r = s[0][:i], s[0][i:], s[1][:j],  s[1][j:] \\n                \\n                lv = 1 if len(l)==0 else int(l)\\n                mlv = 1 if len(ml)==0 else int(ml)\\n                mrv = 1 if len(mr)==0 else int(mr)\\n                rv = 1 if len(r)==0 else int(r)\\n                \\n                v = lv*(mlv+mrv)*rv\\n                if ml and mr:\\n                    ans.append((v, l+\"(\"+ml +\"+\"+ mr+\")\"+r))\\n        \\n        ans.sort()\\n        \\n        return ans[0][1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        \\n        s = expression.split(\"+\")\\n        \\n        ans = []\\n        \\n        n1, n2 = len(s[0]), len(s[1])\\n        \\n        for i in range(0,n1+1):\\n            for j in range(0,n2+1):\\n                l, ml, mr, r = s[0][:i], s[0][i:], s[1][:j],  s[1][j:] \\n                \\n                lv = 1 if len(l)==0 else int(l)\\n                mlv = 1 if len(ml)==0 else int(ml)\\n                mrv = 1 if len(mr)==0 else int(mr)\\n                rv = 1 if len(r)==0 else int(r)\\n                \\n                v = lv*(mlv+mrv)*rv\\n                if ml and mr:\\n                    ans.append((v, l+\"(\"+ml +\"+\"+ mr+\")\"+r))\\n        \\n        ans.sort()\\n        \\n        return ans[0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931296,
                "title": "python-2-pointer-brute-force",
                "content": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        idx = expression.index(\\'+\\')\\n        pre = expression[:idx]\\n        post = expression[idx+1:]\\n\\t\\t\\n        tmp = [] \\n        ans = float(\\'inf\\') \\n        for i in range(0, len(pre)):\\n            for j in range(1, len(post)+1):\\n                tmp.append(pre[:i] + \\'*\\' + \\'(\\' + pre[i:] + \\'+\\' + post[:j] + \\')\\' + \\'*\\' +post[j:])\\n                \\n        res = \\'\\'\\n        for c in tmp:\\n            c = c.strip(\\'*\\')                        \\n            if eval(c) <= ans:\\n                res = c.replace(\\'*\\', \"\")\\n                ans = eval(c)\\n                            \\n        return res         \\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        idx = expression.index(\\'+\\')\\n        pre = expression[:idx]\\n        post = expression[idx+1:]\\n\\t\\t\\n        tmp = [] \\n        ans = float(\\'inf\\') \\n        for i in range(0, len(pre)):\\n            for j in range(1, len(post)+1):\\n                tmp.append(pre[:i] + \\'*\\' + \\'(\\' + pre[i:] + \\'+\\' + post[:j] + \\')\\' + \\'*\\' +post[j:])\\n                \\n        res = \\'\\'\\n        for c in tmp:\\n            c = c.strip(\\'*\\')                        \\n            if eval(c) <= ans:\\n                res = c.replace(\\'*\\', \"\")\\n                ans = eval(c)\\n                            \\n        return res         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931271,
                "title": "c-brute-force-o-n3",
                "content": "```\\nclass Solution \\npublic:\\n    string minimizeResult(string s) {\\n        \\n        vector<char> v1,v2;\\n        int i=0;\\n        while(s[i]!=\\'+\\')\\n            v1.push_back(s[i++]);\\n        \\n        // for(auto x:v1) cout<<x<<\" \";cout<<endl;\\n        \\n        i++;\\n         while(i<s.length())\\n            v2.push_back(s[i++]);\\n        \\n        \\n        // for(auto x:v2) cout<<x<<\" \";cout<<endl;\\n        \\n        int mn = INT_MAX;\\n        \\n        int p,q;\\n        \\n        for(int i=0;i<v1.size();i++){\\n            \\n            for(int j=0;j<v2.size();j++){\\n                \\n                int l1=0 , l2 =0;\\n                for(int p=0;p<i;p++){\\n                    l1=l1*10+(v1[p]-48);\\n                }\\n                \\n                for(int p=i;p<v1.size();p++){\\n                    l2=l2*10+(v1[p]-48);\\n                }\\n                \\n                // cout<<l1<<\" \"<<l2<<endl;\\n                \\n                \\n                int r1=0 , r2 =0;\\n                for(int p=0;p<=j;p++){\\n                    r1=r1*10+(v2[p]-\\'0\\');\\n                }\\n                \\n                for(int p=j+1;p<v2.size();p++){\\n                    r2=r2*10+(v2[p]-\\'0\\');\\n                }\\n                \\n                // cout<<r1<<\" \"<<r2<<endl;\\n                \\n                \\n                if(l1==0)l1=1;\\n                if(r2==0)r2=1;\\n                \\n                int ans = l1*(l2+r1)*r2;\\n                \\n                // cout<<ans<<endl;\\n                \\n                if(mn<ans){\\n                    mn=ans;\\n                    p=i,q=j;\\n                }\\n                \\n                mp[ans]={i,j};\\n                \\n                \\n            }\\n        }\\n        \\n        \\n      \\n        for(auto [x,y]:mp){\\n            if(x==mn){\\n                p=y.first;\\n                q=y.second;\\n            }\\n        }\\n        \\n        // cout<<p<<\" \"<<q<<endl;\\n        \\n        string ss=\"\";\\n        for(int i=0;i<v1.size();i++){\\n            if(p==i)\\n                ss+=\\'(\\';\\n            ss+=v1[i];\\n            \\n        }\\n        \\n        ss+=\\'+\\';\\n        \\n        for(int i=0;i<v2.size();i++){\\n           \\n            ss+=v2[i];\\n            \\n            if(q==i)ss+=\\')\\';\\n        }\\n        \\n        return ss;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\npublic:\\n    string minimizeResult(string s) {\\n        \\n        vector<char> v1,v2;\\n        int i=0;\\n        while(s[i]!=\\'+\\')\\n            v1.push_back(s[i++]);\\n        \\n        // for(auto x:v1) cout<<x<<\" \";cout<<endl;\\n        \\n        i++;\\n         while(i<s.length())\\n            v2.push_back(s[i++]);\\n        \\n        \\n        // for(auto x:v2) cout<<x<<\" \";cout<<endl;\\n        \\n        int mn = INT_MAX;\\n        \\n        int p,q;\\n        \\n        for(int i=0;i<v1.size();i++){\\n            \\n            for(int j=0;j<v2.size();j++){\\n                \\n                int l1=0 , l2 =0;\\n                for(int p=0;p<i;p++){\\n                    l1=l1*10+(v1[p]-48);\\n                }\\n                \\n                for(int p=i;p<v1.size();p++){\\n                    l2=l2*10+(v1[p]-48);\\n                }\\n                \\n                // cout<<l1<<\" \"<<l2<<endl;\\n                \\n                \\n                int r1=0 , r2 =0;\\n                for(int p=0;p<=j;p++){\\n                    r1=r1*10+(v2[p]-\\'0\\');\\n                }\\n                \\n                for(int p=j+1;p<v2.size();p++){\\n                    r2=r2*10+(v2[p]-\\'0\\');\\n                }\\n                \\n                // cout<<r1<<\" \"<<r2<<endl;\\n                \\n                \\n                if(l1==0)l1=1;\\n                if(r2==0)r2=1;\\n                \\n                int ans = l1*(l2+r1)*r2;\\n                \\n                // cout<<ans<<endl;\\n                \\n                if(mn<ans){\\n                    mn=ans;\\n                    p=i,q=j;\\n                }\\n                \\n                mp[ans]={i,j};\\n                \\n                \\n            }\\n        }\\n        \\n        \\n      \\n        for(auto [x,y]:mp){\\n            if(x==mn){\\n                p=y.first;\\n                q=y.second;\\n            }\\n        }\\n        \\n        // cout<<p<<\" \"<<q<<endl;\\n        \\n        string ss=\"\";\\n        for(int i=0;i<v1.size();i++){\\n            if(p==i)\\n                ss+=\\'(\\';\\n            ss+=v1[i];\\n            \\n        }\\n        \\n        ss+=\\'+\\';\\n        \\n        for(int i=0;i<v2.size();i++){\\n           \\n            ss+=v2[i];\\n            \\n            if(q==i)ss+=\\')\\';\\n        }\\n        \\n        return ss;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1931263,
                "title": "short-simply-python-o-n-solution-for-dummies-bruteforce-to-optimal",
                "content": "```\\n# [Optimized Bruteforce Approach - logic in Python] : Look closely, and you\\'ll realise it\\'s almost O(n\\xB2) solution :)\\n\\n# INSIGHT: we find the position where x is present, so that we can run for loops on either side of that \\'X\\'\\nclass Solution:\\n    def minimizeResult(self, x: str) -> str:\\n        ans = \"\"\\n        maxx = sys.maxsize\\n        for i in range(0, x.find(\\'+\\')):     # partial loop1\\n            for j in range(x.find(\\'+\\') + 2, len(x) + 1):    # partial loop2\\n                y = (x[:i] if x[:i] else \"1\") + \"*(\" + x[i:j] + \")*\" + (x[j:] if x[j:] else \"1\")\\n                if eval(y) < maxx:\\n                    maxx = eval(y)\\n                    ans = x[:i] + \"(\" + x[i:j] + \")\" + x[j:]\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# [Optimized Bruteforce Approach - logic in Python] : Look closely, and you\\'ll realise it\\'s almost O(n\\xB2) solution :)\\n\\n# INSIGHT: we find the position where x is present, so that we can run for loops on either side of that \\'X\\'\\nclass Solution:\\n    def minimizeResult(self, x: str) -> str:\\n        ans = \"\"\\n        maxx = sys.maxsize\\n        for i in range(0, x.find(\\'+\\')):     # partial loop1\\n            for j in range(x.find(\\'+\\') + 2, len(x) + 1):    # partial loop2\\n                y = (x[:i] if x[:i] else \"1\") + \"*(\" + x[i:j] + \")*\" + (x[j:] if x[j:] else \"1\")\\n                if eval(y) < maxx:\\n                    maxx = eval(y)\\n                    ans = x[:i] + \"(\" + x[i:j] + \")\" + x[j:]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931191,
                "title": "generate-all-ways",
                "content": "Logic: \\n1: split it into two parts assuming the center at index of(\"+\").\\n2. add \\'(\\' to the left substring at every index and store in a list.\\n3. add \\')\\' to the right substring at every index and store in a list.\\n4. concatinate and evaluate the expression.\\n\\nsince java does not have inbuilt evaluate function i had to implement it on my own.\\n\\n```\\nclass Solution {\\n    \\n    public String minimizeResult(String s) {\\n        long max=Long.MAX_VALUE;\\n        String res=\"\";\\n        int plus=s.indexOf(\"+\");\\n        List<String> list1=new ArrayList<>();\\n        String str1=s.substring(0,plus);\\n        for(int i=0;i<plus;i++){\\n            if(i==0){\\n                String gen=\\'(\\'+str1;\\n                list1.add(gen);\\n                continue;\\n            }\\n            String gen=str1.substring(0,i)+\\'(\\'+str1.substring(i);\\n            list1.add(gen);\\n        }\\n        \\n        List<String> list2=new ArrayList<>();\\n        String str2=s.substring(plus+1);\\n        for(int i=0;i<str2.length();i++){\\n            if(i==0){\\n                String gen=str2.charAt(i)+\")\"+str2.substring(i+1);\\n                list2.add(gen);\\n                continue;\\n            }\\n            String gen=str2.substring(0,i)+\\')\\'+str2.substring(i);\\n            list2.add(gen);\\n        }\\n        list2.add(str2+\")\");\\n        \\n        \\n        for(String s1: list1){\\n            for(String s2:list2){\\n                String gen=s1+\"+\"+s2;\\n                \\n                long cal=calculate(gen);\\n                //System.out.println(gen+\" \"+cal);\\n                if(cal<max){\\n                    max=cal;\\n                    res=gen;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public long calculate(String s) {\\n        int i=0;\\n        int j=s.length()-1;\\n        while(s.charAt(i)!=\\'(\\'){\\n            i++;\\n        }\\n        \\n        while(s.charAt(j)!=\\')\\'){\\n            j--;\\n        }\\n        String sub1=s.substring(0,i);\\n        String sub2=s.substring(j+1);\\n        if(sub1.equals(\"\"))sub1=\"1\";\\n        if(sub2.equals(\"\"))sub2=\"1\";\\n        long res=0;\\n        int plus=s.indexOf(\"+\");\\n        String left=s.substring(i+1,plus);\\n        String right=s.substring(plus+1,j);\\n        res=Long.parseLong(left)+Long.parseLong(right);\\n        \\n        res*=Integer.parseInt(sub1)*Integer.parseInt(sub2);\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String minimizeResult(String s) {\\n        long max=Long.MAX_VALUE;\\n        String res=\"\";\\n        int plus=s.indexOf(\"+\");\\n        List<String> list1=new ArrayList<>();\\n        String str1=s.substring(0,plus);\\n        for(int i=0;i<plus;i++){\\n            if(i==0){\\n                String gen=\\'(\\'+str1;\\n                list1.add(gen);\\n                continue;\\n            }\\n            String gen=str1.substring(0,i)+\\'(\\'+str1.substring(i);\\n            list1.add(gen);\\n        }\\n        \\n        List<String> list2=new ArrayList<>();\\n        String str2=s.substring(plus+1);\\n        for(int i=0;i<str2.length();i++){\\n            if(i==0){\\n                String gen=str2.charAt(i)+\")\"+str2.substring(i+1);\\n                list2.add(gen);\\n                continue;\\n            }\\n            String gen=str2.substring(0,i)+\\')\\'+str2.substring(i);\\n            list2.add(gen);\\n        }\\n        list2.add(str2+\")\");\\n        \\n        \\n        for(String s1: list1){\\n            for(String s2:list2){\\n                String gen=s1+\"+\"+s2;\\n                \\n                long cal=calculate(gen);\\n                //System.out.println(gen+\" \"+cal);\\n                if(cal<max){\\n                    max=cal;\\n                    res=gen;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public long calculate(String s) {\\n        int i=0;\\n        int j=s.length()-1;\\n        while(s.charAt(i)!=\\'(\\'){\\n            i++;\\n        }\\n        \\n        while(s.charAt(j)!=\\')\\'){\\n            j--;\\n        }\\n        String sub1=s.substring(0,i);\\n        String sub2=s.substring(j+1);\\n        if(sub1.equals(\"\"))sub1=\"1\";\\n        if(sub2.equals(\"\"))sub2=\"1\";\\n        long res=0;\\n        int plus=s.indexOf(\"+\");\\n        String left=s.substring(i+1,plus);\\n        String right=s.substring(plus+1,j);\\n        res=Long.parseLong(left)+Long.parseLong(right);\\n        \\n        res*=Integer.parseInt(sub1)*Integer.parseInt(sub2);\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931144,
                "title": "javascript-bf",
                "content": "```\\nvar minimizeResult = function(e) {\\n    [s1, s2] = e.split(\\'+\\');\\n    let ret = Infinity;\\n    let reta = [0, 0];\\n    const m = s1.length;\\n    const n = s2.length;\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            let u1 = i === 0 ? 1 : Number(s1.slice(0, i));\\n            let u2 = Number(s1.slice(i));\\n            let v1 = Number(s2.slice(0, j + 1));\\n            let v2 = j === n - 1 ? 1 : Number(s2.slice(j + 1));\\n            val = u1 * (u2 + v1) * v2;\\n            console.log([u1, u2, v1, v2]);\\n            if (val < ret) {\\n                ret = val;\\n                reta = [i, j];\\n            }\\n        }\\n    }\\n    console.log(reta);\\n    console.log(ret);\\n    return s1.slice(0, reta[0]) + \\'(\\' + s1.slice(reta[0]) + \\'+\\' + s2.slice(0, reta[1] + 1) + \\')\\' + s2.slice(reta[1] + 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimizeResult = function(e) {\\n    [s1, s2] = e.split(\\'+\\');\\n    let ret = Infinity;\\n    let reta = [0, 0];\\n    const m = s1.length;\\n    const n = s2.length;\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            let u1 = i === 0 ? 1 : Number(s1.slice(0, i));\\n            let u2 = Number(s1.slice(i));\\n            let v1 = Number(s2.slice(0, j + 1));\\n            let v2 = j === n - 1 ? 1 : Number(s2.slice(j + 1));\\n            val = u1 * (u2 + v1) * v2;\\n            console.log([u1, u2, v1, v2]);\\n            if (val < ret) {\\n                ret = val;\\n                reta = [i, j];\\n            }\\n        }\\n    }\\n    console.log(reta);\\n    console.log(ret);\\n    return s1.slice(0, reta[0]) + \\'(\\' + s1.slice(reta[0]) + \\'+\\' + s2.slice(0, reta[1] + 1) + \\')\\' + s2.slice(reta[1] + 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1931060,
                "title": "python-runtime-memory-very-concise-and-clear-solution",
                "content": "![image](https://assets.leetcode.com/users/images/445a7976-0a53-41c1-9d07-c8a33cd4691d_1649566736.2604487.png)\\n```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        num1, num2 = expression.split(\\'+\\')\\n        splits = lambda s: [[s[:i], s[i:]] for i in range(len(s))]\\n        minm = float(\\'inf\\')\\n        for l1, r1 in splits(num1): \\n            for l2, r2 in splits(num2):\\n                curr = int(l1 if l1 else 1) * (int(r1) + int(l2 if l2 else r2)) * int(r2 if l2 else 1)\\n                if curr < minm:\\n                    minm = curr\\n                    ans = (l1 if l1 else \\'\\') + \\'(\\' + r1 + \\'+\\' + (l2 if l2 else r2) + \\')\\' + (r2 if l2 else \\'\\')\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        num1, num2 = expression.split(\\'+\\')\\n        splits = lambda s: [[s[:i], s[i:]] for i in range(len(s))]\\n        minm = float(\\'inf\\')\\n        for l1, r1 in splits(num1): \\n            for l2, r2 in splits(num2):\\n                curr = int(l1 if l1 else 1) * (int(r1) + int(l2 if l2 else r2)) * int(r2 if l2 else 1)\\n                if curr < minm:\\n                    minm = curr\\n                    ans = (l1 if l1 else \\'\\') + \\'(\\' + r1 + \\'+\\' + (l2 if l2 else r2) + \\')\\' + (r2 if l2 else \\'\\')\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931038,
                "title": "python-straight-forward",
                "content": "```\\nclass Solution:\\n    def minimizeResult(self, E: str) -> str:\\n        n = len(E)\\n        \\n        plus = E.index(\\'+\\')\\n        \\n        # initial expression\\n        min_value = sum(list(map(int, E.split(\"+\"))))\\n        result = \"(\" + E + \")\"\\n        \\n        # search for all possible sub expressions\\n        for i in range(plus):\\n            for j in range(n, plus + 1, -1):\\n                e = E[i:j]   # sub expression\\n                e1 = E[0:i]  # before the expression\\n                e2 = E[j:]   # after the expression\\n                \\n                value = sum(list(map(int, e.split(\"+\")))) \\n                \\n                # multiply the values, if there are no\\'s before and after the sub-expression\\n                if e1 != \"\": value *= int(e1)  \\n                if e2 != \"\": value *= int(e2)\\n                \\n                # update the min_value\\n                if(min_value > value):\\n                    min_value = value\\n                    result = e1 + \"(\" + e + \")\" + e2                \\n                \\n        return result\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, E: str) -> str:\\n        n = len(E)\\n        \\n        plus = E.index(\\'+\\')\\n        \\n        # initial expression\\n        min_value = sum(list(map(int, E.split(\"+\"))))\\n        result = \"(\" + E + \")\"\\n        \\n        # search for all possible sub expressions\\n        for i in range(plus):\\n            for j in range(n, plus + 1, -1):\\n                e = E[i:j]   # sub expression\\n                e1 = E[0:i]  # before the expression\\n                e2 = E[j:]   # after the expression\\n                \\n                value = sum(list(map(int, e.split(\"+\")))) \\n                \\n                # multiply the values, if there are no\\'s before and after the sub-expression\\n                if e1 != \"\": value *= int(e1)  \\n                if e2 != \"\": value *= int(e2)\\n                \\n                # update the min_value\\n                if(min_value > value):\\n                    min_value = value\\n                    result = e1 + \"(\" + e + \")\" + e2                \\n                \\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931014,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string s) {\\n        string Snum1=\"\", Snum2=\"\";\\n        int i;\\n        for(i=0; i<s.length(); i++){\\n            if(s[i]==\\'+\\')   break;\\n            Snum1 += s[i];\\n        }\\n        i++;\\n        for(; i<s.length(); i++)    Snum2 += s[i];\\n        \\n        string res;\\n        int minV=INT_MAX;\\n        for(int i=0; i<Snum1.length(); i++){\\n            for(int j=0; j<Snum2.length(); j++){\\n                \\n                int num1, num2, mul1=1, mul2=1;\\n                if(i==0){\\n                    mul1=1;\\n                    num1=stoi(Snum1);\\n                }\\n                else{\\n                    mul1=stoi(Snum1.substr(0, i));\\n                    num1=stoi(Snum1.substr(i, Snum1.length()-i));\\n                }\\n                if(j==0){\\n                    mul2=1;\\n                    num2=stoi(Snum2);\\n                }\\n                else{\\n                    mul2=stoi(Snum2.substr(Snum2.length()-j, j));\\n                    num2=stoi(Snum2.substr(0, Snum2.length()-j));\\n                }\\n                if(mul1*(num1+num2)*mul2<minV){\\n                    minV = mul1*(num1+num2)*mul2;\\n                    res=\"\";\\n                    if(i!=0)    res+=to_string(mul1);\\n                    res+=\"(\";\\n                    res+= to_string(num1);\\n                    res+=\"+\";\\n                    res+= to_string(num2);\\n                    res+=\")\";\\n                    if(j!=0)    res+=to_string(mul2);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string s) {\\n        string Snum1=\"\", Snum2=\"\";\\n        int i;\\n        for(i=0; i<s.length(); i++){\\n            if(s[i]==\\'+\\')   break;\\n            Snum1 += s[i];\\n        }\\n        i++;\\n        for(; i<s.length(); i++)    Snum2 += s[i];\\n        \\n        string res;\\n        int minV=INT_MAX;\\n        for(int i=0; i<Snum1.length(); i++){\\n            for(int j=0; j<Snum2.length(); j++){\\n                \\n                int num1, num2, mul1=1, mul2=1;\\n                if(i==0){\\n                    mul1=1;\\n                    num1=stoi(Snum1);\\n                }\\n                else{\\n                    mul1=stoi(Snum1.substr(0, i));\\n                    num1=stoi(Snum1.substr(i, Snum1.length()-i));\\n                }\\n                if(j==0){\\n                    mul2=1;\\n                    num2=stoi(Snum2);\\n                }\\n                else{\\n                    mul2=stoi(Snum2.substr(Snum2.length()-j, j));\\n                    num2=stoi(Snum2.substr(0, Snum2.length()-j));\\n                }\\n                if(mul1*(num1+num2)*mul2<minV){\\n                    minV = mul1*(num1+num2)*mul2;\\n                    res=\"\";\\n                    if(i!=0)    res+=to_string(mul1);\\n                    res+=\"(\";\\n                    res+= to_string(num1);\\n                    res+=\"+\";\\n                    res+= to_string(num2);\\n                    res+=\")\";\\n                    if(j!=0)    res+=to_string(mul2);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931006,
                "title": "easy-implementation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long calc(string s){\\n        long a=1,b=0,c=0,d=1;\\n        int i=0;\\n        string t=\"\";\\n        s+=\\' \\';\\n        while(i<s.length()){\\n             if(s[i]==\\')\\'){\\n                if(t.length()!=0) c=stoi(t);\\n                t=\"\";\\n            }\\n            else if(s[i]==\\'(\\'){\\n                if(t.length()!=0) a=stoi(t);\\n                t=\"\";\\n            }\\n            else if(s[i]==\\'+\\'){\\n                if(t.length()!=0) b=stoi(t);\\n                t=\"\";\\n            }\\n             else if(s[i]==\\' \\'){\\n                if(t.length()!=0) d=stoi(t);\\n                t=\"\";\\n            }\\n            else t+=s[i];\\n            i++;\\n        }\\n        return a*(b+c)*d;\\n    }\\n    string minimizeResult(string exp) {\\n        int n=exp.length();\\n        int p=-1; //index of \\'+\\'\\n        for(int i=0;i<n;i++){\\n            if(exp[i]==\\'+\\'){\\n                p=i;\\n                break;\\n            }\\n        }\\n        string ans=\"\";\\n        long maxm=INT_MAX;\\n        for(int i=0;i<p;i++){\\n            for(int j=p+2;j<=n;j++){\\n                string t=exp.substr(0,i);\\n                t+=\\'(\\';\\n                t+=exp.substr(i,j-i);\\n                t+=\\')\\';\\n                t+=exp.substr(j);//expression string with parenthesis\\n                if(calc(t)<maxm){\\n                    ans=t;\\n                    maxm=calc(t);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long calc(string s){\\n        long a=1,b=0,c=0,d=1;\\n        int i=0;\\n        string t=\"\";\\n        s+=\\' \\';\\n        while(i<s.length()){\\n             if(s[i]==\\')\\'){\\n                if(t.length()!=0) c=stoi(t);\\n                t=\"\";\\n            }\\n            else if(s[i]==\\'(\\'){\\n                if(t.length()!=0) a=stoi(t);\\n                t=\"\";\\n            }\\n            else if(s[i]==\\'+\\'){\\n                if(t.length()!=0) b=stoi(t);\\n                t=\"\";\\n            }\\n             else if(s[i]==\\' \\'){\\n                if(t.length()!=0) d=stoi(t);\\n                t=\"\";\\n            }\\n            else t+=s[i];\\n            i++;\\n        }\\n        return a*(b+c)*d;\\n    }\\n    string minimizeResult(string exp) {\\n        int n=exp.length();\\n        int p=-1; //index of \\'+\\'\\n        for(int i=0;i<n;i++){\\n            if(exp[i]==\\'+\\'){\\n                p=i;\\n                break;\\n            }\\n        }\\n        string ans=\"\";\\n        long maxm=INT_MAX;\\n        for(int i=0;i<p;i++){\\n            for(int j=p+2;j<=n;j++){\\n                string t=exp.substr(0,i);\\n                t+=\\'(\\';\\n                t+=exp.substr(i,j-i);\\n                t+=\\')\\';\\n                t+=exp.substr(j);//expression string with parenthesis\\n                if(calc(t)<maxm){\\n                    ans=t;\\n                    maxm=calc(t);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034652,
                "title": "try-all-possibilites-and-evaluate",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    string ansstr=\"\";\\n    string minimizeResult(string str) \\n    {\\n        ans = INT_MAX;\\n        //as the constraints are small we can check every possibility\\n        int pos;\\n        for(int i=0;i<str.length();i++)\\n        {\\n            if(str[i] == \\'+\\')\\n            {\\n                pos = i;\\n                break;\\n            }\\n        }\\n        for(int i=0;i<pos;i++)\\n        {\\n            for(int j=pos+1;j<str.length();j++)\\n            {\\n                fun(str,i,j);\\n            }\\n        }\\n        return ansstr;\\n    }\\n    void fun(string &str,int &left,int &right)\\n    {\\n        string s=\"\";\\n        for(int i=0;i<str.length();i++)\\n        {\\n            if(i == left)\\n            {\\n               s.push_back(\\'(\\');\\n               s.push_back(str[i]);\\n            }\\n            else if(i == right)\\n            {\\n                s.push_back(str[i]);\\n                s.push_back(\\')\\');\\n            }\\n            else\\n            {\\n                s.push_back(str[i]);\\n            }\\n            \\n        }\\n       int val = eval(s,left,right);\\n       if(val < ans)\\n       {\\n           ans = val;\\n           ansstr = s;\\n       }\\n              \\n    }\\n    int eval(string &s,int &left,int &right)\\n    {\\n        int leftbrpos;\\n        int rightbrpos;\\n        int pluspos;\\n\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                leftbrpos = i;\\n            }\\n            else if(s[i] == \\')\\')\\n            {\\n                rightbrpos = i;        \\n            }\\n            else if(s[i] == \\'+\\')\\n            {\\n                pluspos = i;\\n            }\\n        }\\n\\n        int leftmul = 0;\\n        int rightmul = 0;\\n        int leftaddn = 0;\\n        int rightaddn = 0;\\n\\n        if(leftbrpos == 0)\\n        {\\n            leftmul = 1;\\n        }\\n        else \\n        {\\n            for(int i=0;i<leftbrpos;i++)\\n            {\\n                leftmul = (leftmul*10) + (s[i] - \\'0\\');\\n            }\\n        }\\n\\n        if(rightbrpos == s.length()-1)\\n        {\\n            rightmul = 1;\\n        }\\n        else\\n        {\\n            for(int i=rightbrpos+1;i<s.length();i++)\\n            {\\n                rightmul = (rightmul*10) + (s[i] - \\'0\\');\\n            }\\n        }\\n\\n        for(int i=leftbrpos+1;i<pluspos;i++)\\n        {\\n            leftaddn = (leftaddn*10) + (s[i] - \\'0\\');\\n        }\\n        for(int i=pluspos+1;i<rightbrpos;i++)\\n        {\\n            rightaddn = (rightaddn*10) + (s[i] - \\'0\\');\\n        }\\n        int val = leftmul * (leftaddn + rightaddn) * rightmul;\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    string ansstr=\"\";\\n    string minimizeResult(string str) \\n    {\\n        ans = INT_MAX;\\n        //as the constraints are small we can check every possibility\\n        int pos;\\n        for(int i=0;i<str.length();i++)\\n        {\\n            if(str[i] == \\'+\\')\\n            {\\n                pos = i;\\n                break;\\n            }\\n        }\\n        for(int i=0;i<pos;i++)\\n        {\\n            for(int j=pos+1;j<str.length();j++)\\n            {\\n                fun(str,i,j);\\n            }\\n        }\\n        return ansstr;\\n    }\\n    void fun(string &str,int &left,int &right)\\n    {\\n        string s=\"\";\\n        for(int i=0;i<str.length();i++)\\n        {\\n            if(i == left)\\n            {\\n               s.push_back(\\'(\\');\\n               s.push_back(str[i]);\\n            }\\n            else if(i == right)\\n            {\\n                s.push_back(str[i]);\\n                s.push_back(\\')\\');\\n            }\\n            else\\n            {\\n                s.push_back(str[i]);\\n            }\\n            \\n        }\\n       int val = eval(s,left,right);\\n       if(val < ans)\\n       {\\n           ans = val;\\n           ansstr = s;\\n       }\\n              \\n    }\\n    int eval(string &s,int &left,int &right)\\n    {\\n        int leftbrpos;\\n        int rightbrpos;\\n        int pluspos;\\n\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                leftbrpos = i;\\n            }\\n            else if(s[i] == \\')\\')\\n            {\\n                rightbrpos = i;        \\n            }\\n            else if(s[i] == \\'+\\')\\n            {\\n                pluspos = i;\\n            }\\n        }\\n\\n        int leftmul = 0;\\n        int rightmul = 0;\\n        int leftaddn = 0;\\n        int rightaddn = 0;\\n\\n        if(leftbrpos == 0)\\n        {\\n            leftmul = 1;\\n        }\\n        else \\n        {\\n            for(int i=0;i<leftbrpos;i++)\\n            {\\n                leftmul = (leftmul*10) + (s[i] - \\'0\\');\\n            }\\n        }\\n\\n        if(rightbrpos == s.length()-1)\\n        {\\n            rightmul = 1;\\n        }\\n        else\\n        {\\n            for(int i=rightbrpos+1;i<s.length();i++)\\n            {\\n                rightmul = (rightmul*10) + (s[i] - \\'0\\');\\n            }\\n        }\\n\\n        for(int i=leftbrpos+1;i<pluspos;i++)\\n        {\\n            leftaddn = (leftaddn*10) + (s[i] - \\'0\\');\\n        }\\n        for(int i=pluspos+1;i<rightbrpos;i++)\\n        {\\n            rightaddn = (rightaddn*10) + (s[i] - \\'0\\');\\n        }\\n        int val = leftmul * (leftaddn + rightaddn) * rightmul;\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997164,
                "title": "minimize-result-by-adding-parentheses-to-expression",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimizeResult(self, e: str) -> str:\\n        p = []\\n        b = e.split(\"+\")\\n        p.append([int(b[0]) + int(b[1]),\"(\" + e + \")\"])        \\n        for i in range(len(b[0])):\\n            a = b[0][:i]\\n            if len(a)>0:\\n                h = int(a)* (int(b[0][i:]) + int(b[1]))\\n                p.append([h,a + \"(\" + b[0][i:] +\"+\" +  b[1] +\")\"])\\n            else:\\n                h =  (int(b[0]) + int(b[1]))\\n                p.append([h,\"(\" + b[0] +\"+\" +  b[1] +\")\"])\\n            for j in range(1,len(b[1])):\\n                if len(a)>0:\\n                    h = int(a)* (int(b[0][i:]) + int(b[1][:j])) * int(b[1][j:])\\n                    print(h)\\n                    p.append([h,a + \"(\" + b[0][i:] +\"+\" +  b[1][:j] + \")\"+ b[1][j:]])\\n                else:\\n                    h = (int(b[0]) + (int(b[1][:j]))) * int(b[1][j:])\\n                    p.append([h,\"(\" + b[0] +\"+\" +  b[1][:j] + \")\"+ b[1][j:]])\\n        p.sort()\\n        return p[0][1]\\n                \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, e: str) -> str:\\n        p = []\\n        b = e.split(\"+\")\\n        p.append([int(b[0]) + int(b[1]),\"(\" + e + \")\"])        \\n        for i in range(len(b[0])):\\n            a = b[0][:i]\\n            if len(a)>0:\\n                h = int(a)* (int(b[0][i:]) + int(b[1]))\\n                p.append([h,a + \"(\" + b[0][i:] +\"+\" +  b[1] +\")\"])\\n            else:\\n                h =  (int(b[0]) + int(b[1]))\\n                p.append([h,\"(\" + b[0] +\"+\" +  b[1] +\")\"])\\n            for j in range(1,len(b[1])):\\n                if len(a)>0:\\n                    h = int(a)* (int(b[0][i:]) + int(b[1][:j])) * int(b[1][j:])\\n                    print(h)\\n                    p.append([h,a + \"(\" + b[0][i:] +\"+\" +  b[1][:j] + \")\"+ b[1][j:]])\\n                else:\\n                    h = (int(b[0]) + (int(b[1][:j]))) * int(b[1][j:])\\n                    p.append([h,\"(\" + b[0] +\"+\" +  b[1][:j] + \")\"+ b[1][j:]])\\n        p.sort()\\n        return p[0][1]\\n                \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945860,
                "title": "java-simple-solution",
                "content": "# Intuition\\n- split string and try putting parenthesis at all possible location\\n# Approach\\n- Split string by \\'+\\'\\n- Iterate for left half and right possible location of parenthesis (2 for loop)\\n- Expression for evalution is: a * (b+c) *d\\n- corner case: a and d can be empty. For that assign them 1 so that will not impact actual evaluated result\\na = arr[0].substring(0, i);\\nb = arr[0].substring(i);\\nc = arr[1].substring(0, j);\\nd = arr[1].substring(j);\\n- Compare minResultSoFar with current evaluated value, if min save expression\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        String[] arr = expression.split(\"\\\\\\\\+\");\\n        int res = Integer.MAX_VALUE;\\n        String exp = \"\";\\n        for(int i=0; i<arr[0].length(); i++) {\\n            for(int j=1; j<=arr[1].length(); j++) {\\n                String a = arr[0].substring(0, i);\\n                String b = arr[0].substring(i);\\n                String c = arr[1].substring(0, j);\\n                String d = arr[1].substring(j);\\n                int a1 = a == \"\" ? 1 : Integer.parseInt(a);\\n                int d1 = d== \"\" ? 1 : Integer.parseInt(d);\\n                int temp = a1 * (Integer.parseInt(b) + Integer.parseInt(c)) * d1;\\n                if (temp < res) {\\n                    res = temp;\\n                    exp = a + \"(\" + b + \"+\" + c + \")\" + d;\\n                }\\n            }\\n        }\\n        return exp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        String[] arr = expression.split(\"\\\\\\\\+\");\\n        int res = Integer.MAX_VALUE;\\n        String exp = \"\";\\n        for(int i=0; i<arr[0].length(); i++) {\\n            for(int j=1; j<=arr[1].length(); j++) {\\n                String a = arr[0].substring(0, i);\\n                String b = arr[0].substring(i);\\n                String c = arr[1].substring(0, j);\\n                String d = arr[1].substring(j);\\n                int a1 = a == \"\" ? 1 : Integer.parseInt(a);\\n                int d1 = d== \"\" ? 1 : Integer.parseInt(d);\\n                int temp = a1 * (Integer.parseInt(b) + Integer.parseInt(c)) * d1;\\n                if (temp < res) {\\n                    res = temp;\\n                    exp = a + \"(\" + b + \"+\" + c + \")\" + d;\\n                }\\n            }\\n        }\\n        return exp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945533,
                "title": "recursion-java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int minSum=Integer.MAX_VALUE;\\n    String minResult=\"\";\\n    public String minimizeResult(String expression) {\\n       eval(0,expression.length(),expression);\\n        return minResult;\\n    }\\n    public String getNumber(int l,int r,String str){\\n        try{\\n        StringBuilder sb=new StringBuilder();\\n          //  if(r==str.length()){\\n            //    r=r-1;\\n            //}\\n        for(int i=l;i<r;i++){\\n            sb.append(str.charAt(i));\\n        }\\n       \\n            return sb.toString();\\n        }catch(Exception e){\\n            \\n        }\\n        return \"\";\\n    }\\n    public int num(String s){\\n        if(s.equals(\"\"))return 1;\\n        return Integer.parseInt(s);\\n    }\\n    public int result(String ls,int l,int r){\\n        try{\\n            \\n        int leftStr=num(getNumber(0,l,ls));\\n        int rightStr=num(getNumber(r,ls.length(),ls));\\n        String middle=getNumber(l,r,ls);\\n          \\n        int sum=0;\\n \\n            String[] terms=middle.split(\"[+]\");\\n                 \\n            for(String term:terms){\\n            sum+=Integer.parseInt(term);\\n           // System.out.println(\"Term \"+term);\\n        }\\n        int leftNumber=leftStr;\\n        int rightNumber=rightStr;\\n      //  System.out.println(\"L R \"+leftNumber+\" \"+rightNumber+\" mid \"+sum);\\n            \\n            int r1=leftNumber*sum*rightNumber;\\n     //System.out.println(\"L \"+l+\" R \"+r+\" leftStr \"+leftStr+\" rightStr \"+rightStr+ \"middle \"+middle+\" terms size \"+terms.length+\" SUM \"+r1);\\n \\n            return r1;\\n      \\n        }catch(Exception e){\\n        //return -1;    \\n        }\\n        return -1;\\n        \\n        \\n        \\n    }\\n    public void eval(int left,int right,String expression){\\n        if(left>expression.length()||right<0)return;\\n        \\n        int term=expression.indexOf(\\'+\\');\\n         // System.out.println(\" L R \"+left+\" \"+right+\" term \"+term);\\n        if(left<term && right>term){\\n            \\n         //   System.out.println();\\n            int formedNumber=result(expression,left,right);\\n            if(minSum>formedNumber){\\n                minSum=formedNumber;\\n                String newStr=getNumber(0,left,expression)+\"(\"+ getNumber(left,right,expression)+\")\";\\n                if(right<expression.length()){\\n                    newStr+=getNumber(right,expression.length(),expression);\\n                }\\n                //System.out.println(\"NUmber  \"+formedNumber+\" >> \"+newStr);\\n                minResult=newStr;\\n            }\\n            minSum=Math.min(minSum,formedNumber);\\n            \\n        }else{\\n            return;\\n        }\\n        \\n       \\n        eval(left,right-1,expression);\\n        eval(left+1,right,expression);\\n        eval(left+1,right-1,expression);\\n            \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int minSum=Integer.MAX_VALUE;\\n    String minResult=\"\";\\n    public String minimizeResult(String expression) {\\n       eval(0,expression.length(),expression);\\n        return minResult;\\n    }\\n    public String getNumber(int l,int r,String str){\\n        try{\\n        StringBuilder sb=new StringBuilder();\\n          //  if(r==str.length()){\\n            //    r=r-1;\\n            //}\\n        for(int i=l;i<r;i++){\\n            sb.append(str.charAt(i));\\n        }\\n       \\n            return sb.toString();\\n        }catch(Exception e){\\n            \\n        }\\n        return \"\";\\n    }\\n    public int num(String s){\\n        if(s.equals(\"\"))return 1;\\n        return Integer.parseInt(s);\\n    }\\n    public int result(String ls,int l,int r){\\n        try{\\n            \\n        int leftStr=num(getNumber(0,l,ls));\\n        int rightStr=num(getNumber(r,ls.length(),ls));\\n        String middle=getNumber(l,r,ls);\\n          \\n        int sum=0;\\n \\n            String[] terms=middle.split(\"[+]\");\\n                 \\n            for(String term:terms){\\n            sum+=Integer.parseInt(term);\\n           // System.out.println(\"Term \"+term);\\n        }\\n        int leftNumber=leftStr;\\n        int rightNumber=rightStr;\\n      //  System.out.println(\"L R \"+leftNumber+\" \"+rightNumber+\" mid \"+sum);\\n            \\n            int r1=leftNumber*sum*rightNumber;\\n     //System.out.println(\"L \"+l+\" R \"+r+\" leftStr \"+leftStr+\" rightStr \"+rightStr+ \"middle \"+middle+\" terms size \"+terms.length+\" SUM \"+r1);\\n \\n            return r1;\\n      \\n        }catch(Exception e){\\n        //return -1;    \\n        }\\n        return -1;\\n        \\n        \\n        \\n    }\\n    public void eval(int left,int right,String expression){\\n        if(left>expression.length()||right<0)return;\\n        \\n        int term=expression.indexOf(\\'+\\');\\n         // System.out.println(\" L R \"+left+\" \"+right+\" term \"+term);\\n        if(left<term && right>term){\\n            \\n         //   System.out.println();\\n            int formedNumber=result(expression,left,right);\\n            if(minSum>formedNumber){\\n                minSum=formedNumber;\\n                String newStr=getNumber(0,left,expression)+\"(\"+ getNumber(left,right,expression)+\")\";\\n                if(right<expression.length()){\\n                    newStr+=getNumber(right,expression.length(),expression);\\n                }\\n                //System.out.println(\"NUmber  \"+formedNumber+\" >> \"+newStr);\\n                minResult=newStr;\\n            }\\n            minSum=Math.min(minSum,formedNumber);\\n            \\n        }else{\\n            return;\\n        }\\n        \\n       \\n        eval(left,right-1,expression);\\n        eval(left+1,right,expression);\\n        eval(left+1,right-1,expression);\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908682,
                "title": "easy-cpp-brute",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    string recent = \"\";\\n\\n    int eval(string s1,string s2,int ind1,int ind2,int plusind){\\n        string num1 = \"\";\\n        string bef=\"\";\\n        string aft=\"\";\\n        string num2 = \"\";\\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        if((s1[ind1]==\\'0\\' && ind1!=plusind-1) || (s2[ind2+1]==\\'0\\' && ind2+1!=n2-1)) return INT32_MAX;\\n        for(int i=0;i<n1;i++){\\n            if(i<ind1) bef+=s1[i];\\n            else num1+=s1[i];\\n        }\\n        for(int i=0;i<n2;i++){\\n            if(i<=ind2)num2+=s2[i];\\n            else aft+=s2[i];\\n        }\\n        recent = bef+\"(\"+num1+\"+\"+num2+\")\"+aft;\\n        if(bef==\"\") bef=\"1\";\\n        if(aft==\"\") aft=\"1\";\\n        return (stoi(bef)*(stoi(num1)+stoi(num2))*stoi(aft));\\n    }\\n\\n    string minimizeResult(string expression) {\\n        string expr1=\"\";\\n        string expr2=\"\";\\n        int plusind=-1;\\n        for(int i=0;i<((int)expression.size());i++){\\n            auto x = expression[i];\\n            if(x==\\'+\\')plusind=i;\\n            else if(plusind==-1) expr1+=x;\\n            else expr2+=x;\\n        }\\n        int ans = INT32_MAX;\\n        int n1 = expr1.size();\\n        int n2 = expr2.size();\\n        string fin=\"\";\\n        for(int i=0;i<n1;i++){\\n            for(int j=0;j<n2;j++){\\n                int temp = eval(expr1,expr2,i,j,plusind);\\n                if(temp<=ans){\\n                    ans= temp;\\n                    fin = recent;\\n                }\\n            }\\n        }\\n        return fin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    string recent = \"\";\\n\\n    int eval(string s1,string s2,int ind1,int ind2,int plusind){\\n        string num1 = \"\";\\n        string bef=\"\";\\n        string aft=\"\";\\n        string num2 = \"\";\\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        if((s1[ind1]==\\'0\\' && ind1!=plusind-1) || (s2[ind2+1]==\\'0\\' && ind2+1!=n2-1)) return INT32_MAX;\\n        for(int i=0;i<n1;i++){\\n            if(i<ind1) bef+=s1[i];\\n            else num1+=s1[i];\\n        }\\n        for(int i=0;i<n2;i++){\\n            if(i<=ind2)num2+=s2[i];\\n            else aft+=s2[i];\\n        }\\n        recent = bef+\"(\"+num1+\"+\"+num2+\")\"+aft;\\n        if(bef==\"\") bef=\"1\";\\n        if(aft==\"\") aft=\"1\";\\n        return (stoi(bef)*(stoi(num1)+stoi(num2))*stoi(aft));\\n    }\\n\\n    string minimizeResult(string expression) {\\n        string expr1=\"\";\\n        string expr2=\"\";\\n        int plusind=-1;\\n        for(int i=0;i<((int)expression.size());i++){\\n            auto x = expression[i];\\n            if(x==\\'+\\')plusind=i;\\n            else if(plusind==-1) expr1+=x;\\n            else expr2+=x;\\n        }\\n        int ans = INT32_MAX;\\n        int n1 = expr1.size();\\n        int n2 = expr2.size();\\n        string fin=\"\";\\n        for(int i=0;i<n1;i++){\\n            for(int j=0;j<n2;j++){\\n                int temp = eval(expr1,expr2,i,j,plusind);\\n                if(temp<=ans){\\n                    ans= temp;\\n                    fin = recent;\\n                }\\n            }\\n        }\\n        return fin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890990,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/735f98b8-e014-46ab-9b0b-0978759a2879_1691678836.6031058.png)\\n```\\nvoid solution(char* res, char* expression, int len, int pos) {\\n    int num = INT_MAX, l = 0, r = 0;\\n    for (int i = 0; i < pos; i++) {\\n        int lidx = i, a = 0, c = 0;\\n        for (int j = lidx; j < pos; j++) {\\n            a *= 10;\\n            a += (expression[j]-\\'0\\');\\n        }\\n        for (int j = 0; j < lidx; j++) {\\n            c *= 10;\\n            c += (expression[j]-\\'0\\');\\n        }\\n        if (c == 0) c++;\\n        for (int j = len-1; j > pos; j--) {\\n            int ridx = j, b = 0, d = 0;\\n            for (int k = ridx; k > pos; k--) {\\n                b += (expression[k]-\\'0\\') * pow(10, ridx-k);\\n            }\\n            for (int k = ridx+1; k < len; k++) {\\n                d *= 10;\\n                d += (expression[k]-\\'0\\');\\n            }\\n            if (d == 0) d++;\\n            int ans = c*(a+b)*d;\\n            if (ans < num) {\\n                num = ans;\\n                l = lidx;\\n                r = ridx;\\n            }\\n        }\\n    }\\n    int idx = 0;\\n    for (int i = 0; i < len+3; i++) {\\n        if (i == l) {\\n            res[i] = \\'(\\';\\n        } else if (i == r+2) {\\n            res[i] = \\')\\';\\n        } else {\\n            res[i] = expression[idx++];\\n        }\\n    }\\n}\\n\\nchar* minimizeResult(char* expression) {\\n    int len = strlen(expression), pos = 0;\\n    for (int i = 0; i < len; i++) {\\n        if (expression[i] == \\'+\\') {\\n            pos = i;\\n            break;\\n        }\\n    }\\n    char* res = (char*) calloc(len+3, sizeof(char));\\n    solution(res, expression, len, pos);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid solution(char* res, char* expression, int len, int pos) {\\n    int num = INT_MAX, l = 0, r = 0;\\n    for (int i = 0; i < pos; i++) {\\n        int lidx = i, a = 0, c = 0;\\n        for (int j = lidx; j < pos; j++) {\\n            a *= 10;\\n            a += (expression[j]-\\'0\\');\\n        }\\n        for (int j = 0; j < lidx; j++) {\\n            c *= 10;\\n            c += (expression[j]-\\'0\\');\\n        }\\n        if (c == 0) c++;\\n        for (int j = len-1; j > pos; j--) {\\n            int ridx = j, b = 0, d = 0;\\n            for (int k = ridx; k > pos; k--) {\\n                b += (expression[k]-\\'0\\') * pow(10, ridx-k);\\n            }\\n            for (int k = ridx+1; k < len; k++) {\\n                d *= 10;\\n                d += (expression[k]-\\'0\\');\\n            }\\n            if (d == 0) d++;\\n            int ans = c*(a+b)*d;\\n            if (ans < num) {\\n                num = ans;\\n                l = lidx;\\n                r = ridx;\\n            }\\n        }\\n    }\\n    int idx = 0;\\n    for (int i = 0; i < len+3; i++) {\\n        if (i == l) {\\n            res[i] = \\'(\\';\\n        } else if (i == r+2) {\\n            res[i] = \\')\\';\\n        } else {\\n            res[i] = expression[idx++];\\n        }\\n    }\\n}\\n\\nchar* minimizeResult(char* expression) {\\n    int len = strlen(expression), pos = 0;\\n    for (int i = 0; i < len; i++) {\\n        if (expression[i] == \\'+\\') {\\n            pos = i;\\n            break;\\n        }\\n    }\\n    char* res = (char*) calloc(len+3, sizeof(char));\\n    solution(res, expression, len, pos);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3851678,
                "title": "brute-force-python-solution-beats-100-runtime",
                "content": "# Intuition\\nBrute force\\n\\n# Approach\\nIterate through all possible left and right parenthesis positions and remember when the value is the smallest.\\n\\nWe could bring down the complexity to $$O(n^2)$$ by keeping track of the current values inside the parentheses and calculating the impact of moving the parenthesis left or right arithmetically. However, for small inputs like these, it wouldn\\'t make a difference.\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        plus_pos = expression.find(\\'+\\')\\n        min_val, min_lp, min_rp = None, 0, 0\\n\\n        for lp in range(0, plus_pos):\\n            for rp in range(plus_pos+2, len(expression)+1):\\n                val = int(expression[:lp] or 1) * \\\\\\n                    (int(expression[lp:plus_pos]) + int(expression[plus_pos+1:rp])) * \\\\\\n                    int(expression[rp:] or 1)\\n                if min_val is None or val < min_val:\\n                    min_val = val\\n                    min_lp = lp\\n                    min_rp = rp\\n        \\n        return expression[:min_lp] + \\'(\\' + expression[min_lp:min_rp] + \\')\\' + expression[min_rp:]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        plus_pos = expression.find(\\'+\\')\\n        min_val, min_lp, min_rp = None, 0, 0\\n\\n        for lp in range(0, plus_pos):\\n            for rp in range(plus_pos+2, len(expression)+1):\\n                val = int(expression[:lp] or 1) * \\\\\\n                    (int(expression[lp:plus_pos]) + int(expression[plus_pos+1:rp])) * \\\\\\n                    int(expression[rp:] or 1)\\n                if min_val is None or val < min_val:\\n                    min_val = val\\n                    min_lp = lp\\n                    min_rp = rp\\n        \\n        return expression[:min_lp] + \\'(\\' + expression[min_lp:min_rp] + \\')\\' + expression[min_rp:]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776942,
                "title": "python-bruteforce",
                "content": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        n,_,m = map(len, expression.partition(\\'+\\'))\\n        solved = \\'\\'\\n        res = inf\\n        for i in range(n):\\n            for j in range(1, m+1):\\n                if int(expression[:i] or \\'1\\')*eval(expression[i:n+j+1])*int(expression[n+j+1:] or \\'1\\') < res:\\n                    res = int(expression[:i] or \\'1\\')*eval(expression[i:n+j+1])*int(expression[n+j+1:] or \\'1\\')\\n                    solved = expression[:i]+\\'(\\'+expression[i:n+j+1]+\\')\\'+expression[n+j+1:]\\n\\n        return solved if eval(expression) > res else f\\'({expression})\\'\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        n,_,m = map(len, expression.partition(\\'+\\'))\\n        solved = \\'\\'\\n        res = inf\\n        for i in range(n):\\n            for j in range(1, m+1):\\n                if int(expression[:i] or \\'1\\')*eval(expression[i:n+j+1])*int(expression[n+j+1:] or \\'1\\') < res:\\n                    res = int(expression[:i] or \\'1\\')*eval(expression[i:n+j+1])*int(expression[n+j+1:] or \\'1\\')\\n                    solved = expression[:i]+\\'(\\'+expression[i:n+j+1]+\\')\\'+expression[n+j+1:]\\n\\n        return solved if eval(expression) > res else f\\'({expression})\\'\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775147,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minimizeResult(string expression) {\\n        int leftplus=-1, rightplus=-1;\\n        for (int i=0; i<expression.length(); i++){\\n            if (expression[i+1]==\\'+\\'){\\n                leftplus=i;\\n                rightplus=i+2;\\n                break;\\n            }\\n        }\\n        long long mini=LLONG_MAX, left=-1, right=-1;\\n        for (int i=0; i<=leftplus; i++){\\n            long long leftvaladd=stoll(expression.substr(i, leftplus-i+1));\\n            string leftvalmulstr=expression.substr(0, i);\\n            long long leftvalmul=1;\\n            if (!leftvalmulstr.empty()){\\n                leftvalmul=stoll(leftvalmulstr);\\n            }\\n            for (int j=rightplus; j<expression.size(); j++){\\n                long long rightvaladd=stoll(expression.substr(rightplus, j-rightplus+1));\\n                string rightvalmulstr=expression.substr(j+1);\\n                long long rightvalmul=1;\\n                if (!rightvalmulstr.empty()){\\n                    rightvalmul=stoll(rightvalmulstr);\\n                }\\n                long long z=leftvalmul*(leftvaladd+rightvaladd)*rightvalmul;\\n                if (z<mini){\\n                    mini=z;\\n                    left=i;\\n                    right=j;\\n                }\\n            }\\n        }\\n        // cout<<mini<<\" \"<<stoll(expression.substr(left, leftplus-left+1))<<\" \"<<stoll(expression.substr(right, right-rightplus+1));\\n        string s1=\"\";\\n        for (int i=0; i<expression.length(); i++){\\n            if (i==left){\\n                s1=s1+\\'(\\'+expression[i];\\n            }\\n            else if (i==right){\\n                s1=s1+expression[i]+\\')\\';\\n            }\\n            else{\\n                s1=s1+expression[i];\\n            }\\n        }\\n        return s1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string expression) {\\n        int leftplus=-1, rightplus=-1;\\n        for (int i=0; i<expression.length(); i++){\\n            if (expression[i+1]==\\'+\\'){\\n                leftplus=i;\\n                rightplus=i+2;\\n                break;\\n            }\\n        }\\n        long long mini=LLONG_MAX, left=-1, right=-1;\\n        for (int i=0; i<=leftplus; i++){\\n            long long leftvaladd=stoll(expression.substr(i, leftplus-i+1));\\n            string leftvalmulstr=expression.substr(0, i);\\n            long long leftvalmul=1;\\n            if (!leftvalmulstr.empty()){\\n                leftvalmul=stoll(leftvalmulstr);\\n            }\\n            for (int j=rightplus; j<expression.size(); j++){\\n                long long rightvaladd=stoll(expression.substr(rightplus, j-rightplus+1));\\n                string rightvalmulstr=expression.substr(j+1);\\n                long long rightvalmul=1;\\n                if (!rightvalmulstr.empty()){\\n                    rightvalmul=stoll(rightvalmulstr);\\n                }\\n                long long z=leftvalmul*(leftvaladd+rightvaladd)*rightvalmul;\\n                if (z<mini){\\n                    mini=z;\\n                    left=i;\\n                    right=j;\\n                }\\n            }\\n        }\\n        // cout<<mini<<\" \"<<stoll(expression.substr(left, leftplus-left+1))<<\" \"<<stoll(expression.substr(right, right-rightplus+1));\\n        string s1=\"\";\\n        for (int i=0; i<expression.length(); i++){\\n            if (i==left){\\n                s1=s1+\\'(\\'+expression[i];\\n            }\\n            else if (i==right){\\n                s1=s1+expression[i]+\\')\\';\\n            }\\n            else{\\n                s1=s1+expression[i];\\n            }\\n        }\\n        return s1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3734071,
                "title": "1ms-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMuch like longest palindromic substring we want to start our 2 pointers from the operator and expand outwards.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe want to exhaust every possible combination so start by finding the operator index. Mark two pointers, one left of the operator and one right of the operator. Start inwards and expand outwards, similar to Longest Palindromic Substring.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int min = Integer.MAX_VALUE;\\n    private int start = 0;\\n    private int end = 0;\\n    public String minimizeResult(String expression) {\\n        /*\\n            247+38 -> 2(47+38) = 170\\n            2(47+3)8 = 800\\n            24(7+3)8\\n            24(7+38)\\n            2(47+3)8\\n            (247+3)8\\n            (247+38)\\n        */\\n\\n        int operatorIdx = expression.indexOf(\\'+\\');\\n        int lo = operatorIdx-1;\\n        int hi = operatorIdx+1;\\n        while(lo >= 0) {\\n            minimizeResult(expression, lo, hi, operatorIdx);\\n            lo--;\\n        }\\n        StringBuffer sb = new StringBuffer(expression);\\n        sb.insert(start, \\'(\\');\\n        sb.insert(end+2, \\')\\'); // Shift two places to account for sb created after opening paranthesis and operator sign\\n        return sb.toString();\\n    }\\n    private void minimizeResult(String expression, int lo, int hi, int operatorIdx) {\\n        while (hi < expression.length()) {\\n            int leftInner = Integer.parseInt(expression.substring(lo,operatorIdx));\\n            int rightInner = Integer.parseInt(expression.substring(operatorIdx+1, hi+1));\\n            int leftOuter = 1;\\n            if (lo > 0) {\\n                leftOuter = Integer.parseInt(expression.substring(0, lo));\\n            }\\n            int rightOuter = 1;\\n            if (hi+1 < expression.length()) {\\n                rightOuter = Integer.parseInt(expression.substring(hi+1));\\n            }\\n            int result = (leftInner + rightInner) * leftOuter * rightOuter;\\n            if (result < min) {\\n                min = result;\\n                start = lo;\\n                end = hi;\\n            }\\n            hi++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int min = Integer.MAX_VALUE;\\n    private int start = 0;\\n    private int end = 0;\\n    public String minimizeResult(String expression) {\\n        /*\\n            247+38 -> 2(47+38) = 170\\n            2(47+3)8 = 800\\n            24(7+3)8\\n            24(7+38)\\n            2(47+3)8\\n            (247+3)8\\n            (247+38)\\n        */\\n\\n        int operatorIdx = expression.indexOf(\\'+\\');\\n        int lo = operatorIdx-1;\\n        int hi = operatorIdx+1;\\n        while(lo >= 0) {\\n            minimizeResult(expression, lo, hi, operatorIdx);\\n            lo--;\\n        }\\n        StringBuffer sb = new StringBuffer(expression);\\n        sb.insert(start, \\'(\\');\\n        sb.insert(end+2, \\')\\'); // Shift two places to account for sb created after opening paranthesis and operator sign\\n        return sb.toString();\\n    }\\n    private void minimizeResult(String expression, int lo, int hi, int operatorIdx) {\\n        while (hi < expression.length()) {\\n            int leftInner = Integer.parseInt(expression.substring(lo,operatorIdx));\\n            int rightInner = Integer.parseInt(expression.substring(operatorIdx+1, hi+1));\\n            int leftOuter = 1;\\n            if (lo > 0) {\\n                leftOuter = Integer.parseInt(expression.substring(0, lo));\\n            }\\n            int rightOuter = 1;\\n            if (hi+1 < expression.length()) {\\n                rightOuter = Integer.parseInt(expression.substring(hi+1));\\n            }\\n            int result = (leftInner + rightInner) * leftOuter * rightOuter;\\n            if (result < min) {\\n                min = result;\\n                start = lo;\\n                end = hi;\\n            }\\n            hi++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678987,
                "title": "beats-91-27-runtime",
                "content": "# Approach\\nSplit the expression by `+` to simplify indexing. Left bracket can be placed at `l_idx` from `0` to `l_num - 1`. Right bracket can be placed at `r_idx` from `1` to `r_num`. Edge cases at ends can have the default value as `1` using `or`. Intuitive and straightforward solution.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        min_val = float(\"inf\")\\n        l_num, r_num = expression.split(\"+\")\\n        l_idx, r_idx = None, None\\n        for i in range(len(l_num)):\\n            for j in range(len(r_num)):\\n                new_val = int(l_num[:i] or 1) * (int(l_num[i:]) + int(r_num[:j+1])) * int(r_num[j+1:] or 1)\\n                if new_val < min_val:\\n                    min_val, l_idx, r_idx = new_val, i, j + 1\\n        l_num = l_num[:l_idx] + \"(\" + l_num[l_idx:]\\n        r_num = r_num[:r_idx] + \")\" + r_num[r_idx:]\\n                    \\n        return l_num + \"+\" + r_num\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        min_val = float(\"inf\")\\n        l_num, r_num = expression.split(\"+\")\\n        l_idx, r_idx = None, None\\n        for i in range(len(l_num)):\\n            for j in range(len(r_num)):\\n                new_val = int(l_num[:i] or 1) * (int(l_num[i:]) + int(r_num[:j+1])) * int(r_num[j+1:] or 1)\\n                if new_val < min_val:\\n                    min_val, l_idx, r_idx = new_val, i, j + 1\\n        l_num = l_num[:l_idx] + \"(\" + l_num[l_idx:]\\n        r_num = r_num[:r_idx] + \")\" + r_num[r_idx:]\\n                    \\n        return l_num + \"+\" + r_num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668763,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        s=expression.split(\"+\")     #s=[\\'247\\',\\'38\\']\\n        left,right=list(s[0]),list(s[1])\\n        len_left,len_right=len(list(left)),len(list(right))\\n        res_left,res_right,res=[],[],float(\\'inf\\')\\n        for i in range(len_left):\\n            if i!=0:\\n                left.insert(i, \\'*(\\')\\n            else:\\n                left.insert(i, \\'(\\')\\n            res_left.append(\"\".join(left))\\n            left.pop(i)   \\n        for i in range(len_right):\\n            if i<len_right-1:\\n                right.insert(i+1,\")*\")\\n            else:\\n                right.insert(i+1,\")\")\\n            res_right.append(\"\".join(right))\\n            right.pop(i+1)\\n        for i in range(len_left):\\n            for j in range(len_right):\\n                val=eval(res_left[i]+\\'+\\'+res_right[j])\\n                if res>val:\\n                    res=val\\n                    x=res_left[i]+\\'+\\'+res_right[j]\\n        return x.replace(\"*\",\"\")\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        s=expression.split(\"+\")     #s=[\\'247\\',\\'38\\']\\n        left,right=list(s[0]),list(s[1])\\n        len_left,len_right=len(list(left)),len(list(right))\\n        res_left,res_right,res=[],[],float(\\'inf\\')\\n        for i in range(len_left):\\n            if i!=0:\\n                left.insert(i, \\'*(\\')\\n            else:\\n                left.insert(i, \\'(\\')\\n            res_left.append(\"\".join(left))\\n            left.pop(i)   \\n        for i in range(len_right):\\n            if i<len_right-1:\\n                right.insert(i+1,\")*\")\\n            else:\\n                right.insert(i+1,\")\")\\n            res_right.append(\"\".join(right))\\n            right.pop(i+1)\\n        for i in range(len_left):\\n            for j in range(len_right):\\n                val=eval(res_left[i]+\\'+\\'+res_right[j])\\n                if res>val:\\n                    res=val\\n                    x=res_left[i]+\\'+\\'+res_right[j]\\n        return x.replace(\"*\",\"\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655146,
                "title": "bruteforces-only",
                "content": "# Intuition\\nSimple and Bruteforce\\n\\n# Approach\\nitetate two loops and take all the possible cases amd find minimum for them....\\n\\n# Complexity\\n- Time complexity:\\nO(n*n);\\n\\n- Space complexity:\\nO(n);\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    string minimizeResult(string s)\\n    {\\n        int id = s.find(\\'+\\');\\n        int p = 0, q = s.length() - 1;\\n        int res = INT_MAX;\\n        string f = s;\\n        for (int i = 0; i < id; i++)\\n        {\\n            for (int j = id + 1; j < s.length(); j++)\\n            {\\n                int a = 1, b = 0, c = 0, d = 1;\\n                string temp = \"\";\\n                if (i > 0)\\n                {\\n                    a = stoi(s.substr(0, i));\\n                    temp += s.substr(0, i);\\n                }\\n                if (id - i > 0)\\n                {\\n                    b = stoi(s.substr(i, id - i));\\n                    temp += \"(\" + s.substr(i, id - i) + \"+\";\\n                }\\n                if (id + 1 < s.length() && j - id > 0)\\n                {\\n                    c = stoi(s.substr(id + 1, j - id));\\n                    temp += s.substr(id + 1, j - id) + \")\";\\n                }\\n                if (j + 1 < s.length())\\n                {\\n                    d = stoi(s.substr(j + 1));\\n                    temp += (s.substr(j + 1));\\n                }\\n                int ans = a * (b + c) * d;\\n                cout << a << \" \" << b << \" \" << c << \" \" << d << \"\\\\n\";\\n                if (res >= ans)\\n                {\\n                    f = temp;\\n                    p = i;\\n                    q = j;\\n                    res = min(res, ans);\\n                }\\n            }\\n        }\\n        cout << res;\\n        return f;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    string minimizeResult(string s)\\n    {\\n        int id = s.find(\\'+\\');\\n        int p = 0, q = s.length() - 1;\\n        int res = INT_MAX;\\n        string f = s;\\n        for (int i = 0; i < id; i++)\\n        {\\n            for (int j = id + 1; j < s.length(); j++)\\n            {\\n                int a = 1, b = 0, c = 0, d = 1;\\n                string temp = \"\";\\n                if (i > 0)\\n                {\\n                    a = stoi(s.substr(0, i));\\n                    temp += s.substr(0, i);\\n                }\\n                if (id - i > 0)\\n                {\\n                    b = stoi(s.substr(i, id - i));\\n                    temp += \"(\" + s.substr(i, id - i) + \"+\";\\n                }\\n                if (id + 1 < s.length() && j - id > 0)\\n                {\\n                    c = stoi(s.substr(id + 1, j - id));\\n                    temp += s.substr(id + 1, j - id) + \")\";\\n                }\\n                if (j + 1 < s.length())\\n                {\\n                    d = stoi(s.substr(j + 1));\\n                    temp += (s.substr(j + 1));\\n                }\\n                int ans = a * (b + c) * d;\\n                cout << a << \" \" << b << \" \" << c << \" \" << d << \"\\\\n\";\\n                if (res >= ans)\\n                {\\n                    f = temp;\\n                    p = i;\\n                    q = j;\\n                    res = min(res, ans);\\n                }\\n            }\\n        }\\n        cout << res;\\n        return f;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3629722,
                "title": "javascript-clean-solution-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N^2), N = expression.length\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {string} expression\\n * @return {string}\\n */\\nvar minimizeResult = function(expression) {\\n    let expressionArray = expression.split(\"+\");\\n    let left = expressionArray[0];\\n    let right = expressionArray[1];\\n    let res = expression;\\n    let min = left + right\\n    for (let i = 0; i < left.length; i++) {\\n        let i1 = left.slice(0, i);\\n        let i1Evaluation = Number(i1 || 1);\\n        let i2 = left.slice(i);\\n        let i2Evaluation = Number(i2);\\n        for (let j = 1; j <= right.length; j++) {\\n            let j1 = right.slice(0, j);\\n            let j1Evaluation = Number(j1);\\n            let j2 = right.slice(j);\\n            let j2Evaluation = Number(j2 || 1);\\n            let evaluation = i1Evaluation * (i2Evaluation + j1Evaluation) * j2Evaluation;\\n            if (evaluation < min) {\\n                res = `${i1}(${i2}+${j1})${j2}`;\\n                min = evaluation;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n/*\\nInput: expression = \"247+38\"\\nOutput: \"2(47+38)\"\\n\\nInput: expression = \"999+999\"\\nOutput: \"(999+999)\"\\n*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} expression\\n * @return {string}\\n */\\nvar minimizeResult = function(expression) {\\n    let expressionArray = expression.split(\"+\");\\n    let left = expressionArray[0];\\n    let right = expressionArray[1];\\n    let res = expression;\\n    let min = left + right\\n    for (let i = 0; i < left.length; i++) {\\n        let i1 = left.slice(0, i);\\n        let i1Evaluation = Number(i1 || 1);\\n        let i2 = left.slice(i);\\n        let i2Evaluation = Number(i2);\\n        for (let j = 1; j <= right.length; j++) {\\n            let j1 = right.slice(0, j);\\n            let j1Evaluation = Number(j1);\\n            let j2 = right.slice(j);\\n            let j2Evaluation = Number(j2 || 1);\\n            let evaluation = i1Evaluation * (i2Evaluation + j1Evaluation) * j2Evaluation;\\n            if (evaluation < min) {\\n                res = `${i1}(${i2}+${j1})${j2}`;\\n                min = evaluation;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n/*\\nInput: expression = \"247+38\"\\nOutput: \"2(47+38)\"\\n\\nInput: expression = \"999+999\"\\nOutput: \"(999+999)\"\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3629721,
                "title": "javascript-clean-solution-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N^2), N = expression.length\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {string} expression\\n * @return {string}\\n */\\nvar minimizeResult = function(expression) {\\n    let expressionArray = expression.split(\"+\");\\n    let left = expressionArray[0];\\n    let right = expressionArray[1];\\n    let res = expression;\\n    let min = left + right\\n    for (let i = 0; i < left.length; i++) {\\n        let i1 = left.slice(0, i);\\n        let i1Evaluation = Number(i1 || 1);\\n        let i2 = left.slice(i);\\n        let i2Evaluation = Number(i2);\\n        for (let j = 1; j <= right.length; j++) {\\n            let j1 = right.slice(0, j);\\n            let j1Evaluation = Number(j1);\\n            let j2 = right.slice(j);\\n            let j2Evaluation = Number(j2 || 1);\\n            let evaluation = i1Evaluation * (i2Evaluation + j1Evaluation) * j2Evaluation;\\n            if (evaluation < min) {\\n                res = `${i1}(${i2}+${j1})${j2}`;\\n                min = evaluation;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n/*\\nInput: expression = \"247+38\"\\nOutput: \"2(47+38)\"\\n\\nInput: expression = \"999+999\"\\nOutput: \"(999+999)\"\\n*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} expression\\n * @return {string}\\n */\\nvar minimizeResult = function(expression) {\\n    let expressionArray = expression.split(\"+\");\\n    let left = expressionArray[0];\\n    let right = expressionArray[1];\\n    let res = expression;\\n    let min = left + right\\n    for (let i = 0; i < left.length; i++) {\\n        let i1 = left.slice(0, i);\\n        let i1Evaluation = Number(i1 || 1);\\n        let i2 = left.slice(i);\\n        let i2Evaluation = Number(i2);\\n        for (let j = 1; j <= right.length; j++) {\\n            let j1 = right.slice(0, j);\\n            let j1Evaluation = Number(j1);\\n            let j2 = right.slice(j);\\n            let j2Evaluation = Number(j2 || 1);\\n            let evaluation = i1Evaluation * (i2Evaluation + j1Evaluation) * j2Evaluation;\\n            if (evaluation < min) {\\n                res = `${i1}(${i2}+${j1})${j2}`;\\n                min = evaluation;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n/*\\nInput: expression = \"247+38\"\\nOutput: \"2(47+38)\"\\n\\nInput: expression = \"999+999\"\\nOutput: \"(999+999)\"\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593864,
                "title": "java-1ms-100-and-clean-code",
                "content": "# Approach\\n1. As input is very small,9 digits, there are only max 20 possible combinations of left/right paranthesis\\n2. Split the expression into left and right number.\\n3. Looping with i from 0 to left.length, apply the left paranthesis at i index.\\nLooping with j from 0 ro right.length, apply the right paranthesis to j index.\\n4. Based on i and j paranthesis, determine the result.\\n5. If the result is smaller that the best result known, set the i and j paranthesis index\\n6. At the end, append the left and right paranthesis at i and j paranthesis index. \\n\\n# Complexity\\n- Time complexity:$$O(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        String[] chunks = expression.split(\"\\\\\\\\+\");\\n        int minResult = Integer.parseInt(chunks[0]) + Integer.parseInt(chunks[1]);\\n        int leftPos = 0, rightPos = expression.length();\\n        int leftSumToAdd, leftProductToAdd, currentResult;\\n        for (int i = 0; i < chunks[0].length(); i++) {\\n            leftSumToAdd = i == 0 ? 1 : Integer.parseInt(chunks[0].substring(0, i));\\n            leftProductToAdd = Integer.parseInt(chunks[0].substring(i, chunks[0].length())); \\n            for (int j = 0; j < chunks[1].length(); j++) {\\n                currentResult = getParanthesisResult(leftSumToAdd, leftProductToAdd, chunks[1], j);\\n                if (currentResult < minResult) {\\n                    minResult = currentResult;\\n                    leftPos = i;\\n                    rightPos = chunks[0].length() + j+2;\\n                }\\n            }\\n        }\\n        return addParanthesis(expression, leftPos, rightPos);\\n    }\\n\\n    private String addParanthesis(String expression, int leftP, int rightP) {\\n        StringBuilder stb = new StringBuilder(expression.length() + 2);\\n        for (int i = 0; i < expression.length(); i++) {\\n            if (i == leftP) {\\n                stb.append(\\'(\\');\\n            } else if (i == rightP) {\\n                stb.append(\\')\\');\\n            }\\n            stb.append(expression.charAt(i));\\n        }\\n        if (rightP == expression.length()) {\\n            stb.append(\\')\\');\\n        }\\n        return stb.toString();\\n    }\\n\\n    private int getParanthesisResult(int leftSumToAdd, int leftProductToAdd, String chunk, int j) {\\n        int rightProductToAdd = Integer.parseInt(chunk.substring(0, j+1));\\n        int rightSumToAdd = j == chunk.length() -1 ? 1 : Integer.parseInt(chunk.substring(j+1, chunk.length()));\\n        return leftSumToAdd * (leftProductToAdd + rightProductToAdd) * rightSumToAdd;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        String[] chunks = expression.split(\"\\\\\\\\+\");\\n        int minResult = Integer.parseInt(chunks[0]) + Integer.parseInt(chunks[1]);\\n        int leftPos = 0, rightPos = expression.length();\\n        int leftSumToAdd, leftProductToAdd, currentResult;\\n        for (int i = 0; i < chunks[0].length(); i++) {\\n            leftSumToAdd = i == 0 ? 1 : Integer.parseInt(chunks[0].substring(0, i));\\n            leftProductToAdd = Integer.parseInt(chunks[0].substring(i, chunks[0].length())); \\n            for (int j = 0; j < chunks[1].length(); j++) {\\n                currentResult = getParanthesisResult(leftSumToAdd, leftProductToAdd, chunks[1], j);\\n                if (currentResult < minResult) {\\n                    minResult = currentResult;\\n                    leftPos = i;\\n                    rightPos = chunks[0].length() + j+2;\\n                }\\n            }\\n        }\\n        return addParanthesis(expression, leftPos, rightPos);\\n    }\\n\\n    private String addParanthesis(String expression, int leftP, int rightP) {\\n        StringBuilder stb = new StringBuilder(expression.length() + 2);\\n        for (int i = 0; i < expression.length(); i++) {\\n            if (i == leftP) {\\n                stb.append(\\'(\\');\\n            } else if (i == rightP) {\\n                stb.append(\\')\\');\\n            }\\n            stb.append(expression.charAt(i));\\n        }\\n        if (rightP == expression.length()) {\\n            stb.append(\\')\\');\\n        }\\n        return stb.toString();\\n    }\\n\\n    private int getParanthesisResult(int leftSumToAdd, int leftProductToAdd, String chunk, int j) {\\n        int rightProductToAdd = Integer.parseInt(chunk.substring(0, j+1));\\n        int rightSumToAdd = j == chunk.length() -1 ? 1 : Integer.parseInt(chunk.substring(j+1, chunk.length()));\\n        return leftSumToAdd * (leftProductToAdd + rightProductToAdd) * rightSumToAdd;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587847,
                "title": "javascript-solution-brute-force-beats-100",
                "content": "Just follow the description.\\nDo it one by one and check every pair, nothing fancy but kind like easy to understand.\\n\\n\\n```\\n/**\\n * @param {string} expression\\n * @return {string}\\n */\\nvar minimizeResult = function(expression) {\\n    let idx = expression.indexOf(\\'+\\')\\n    let min = Infinity\\n    let record = []\\n    \\n    for(let i = idx+1, j = idx-1; i < expression.length && j >= 0; i++, j--) {\\n        let tempI = i\\n        \\n        while(tempI < expression.length) {\\n            let a = helper(expression, j, tempI, idx)\\n        \\n            if(min > a) {\\n                min = a\\n                record = [j,tempI]\\n            }\\n            tempI++\\n        }\\n        \\n        let tempJ = j\\n        \\n        while(tempJ >= 0) {\\n            let a = helper(expression, tempJ, i, idx)\\n            \\n            if(min > a) {\\n                min = a\\n                record = [tempJ,i]\\n            }\\n            tempJ--\\n        }\\n    }\\n    \\n    let res = expression.split(\\'\\')\\n    res.splice(record[0], 0, \"(\")\\n    res.splice(record[1]+2, 0, \")\")\\n    \\n    return res.join(\\'\\')\\n};\\n\\n\\n/**\\n* i     left side edge\\n* j     right side edge\\n* idx   \\'+\\' index\\n**/\\nconst helper = (s, i, j, idx) => {\\n    let front = s.slice(0, i) || 1\\n    let back = s.slice(j+1) || 1\\n    let a = s.slice(i, idx)\\n    let b = s.slice(idx+1, j+1)\\n    let res = parseInt(a)+parseInt(b)\\n    \\n    return res*front*back\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} expression\\n * @return {string}\\n */\\nvar minimizeResult = function(expression) {\\n    let idx = expression.indexOf(\\'+\\')\\n    let min = Infinity\\n    let record = []\\n    \\n    for(let i = idx+1, j = idx-1; i < expression.length && j >= 0; i++, j--) {\\n        let tempI = i\\n        \\n        while(tempI < expression.length) {\\n            let a = helper(expression, j, tempI, idx)\\n        \\n            if(min > a) {\\n                min = a\\n                record = [j,tempI]\\n            }\\n            tempI++\\n        }\\n        \\n        let tempJ = j\\n        \\n        while(tempJ >= 0) {\\n            let a = helper(expression, tempJ, i, idx)\\n            \\n            if(min > a) {\\n                min = a\\n                record = [tempJ,i]\\n            }\\n            tempJ--\\n        }\\n    }\\n    \\n    let res = expression.split(\\'\\')\\n    res.splice(record[0], 0, \"(\")\\n    res.splice(record[1]+2, 0, \")\")\\n    \\n    return res.join(\\'\\')\\n};\\n\\n\\n/**\\n* i     left side edge\\n* j     right side edge\\n* idx   \\'+\\' index\\n**/\\nconst helper = (s, i, j, idx) => {\\n    let front = s.slice(0, i) || 1\\n    let back = s.slice(j+1) || 1\\n    let a = s.slice(i, idx)\\n    let b = s.slice(idx+1, j+1)\\n    let res = parseInt(a)+parseInt(b)\\n    \\n    return res*front*back\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521473,
                "title": "clean-bf-approach",
                "content": "# Intuition\\nThis problem isn\\'t so bad once you realize it can only be minimized by adding the parentheses to either side of the +.  \\n\\n# Approach\\nBrute Force\\n\\n# Code\\n```\\n/**\\n * @param {string} expression\\n * @return {string}\\n */\\n/**\\n * @param {string} expression\\n * @return {string}\\n */\\nvar minimizeResult = function(expression) {\\n    const [left, right] = expression.split(\\'+\\');\\n    let min = Number.MAX_VALUE;\\n    let expressionFound;\\n    for(let i = 0; i < left.length; i++) {\\n        let l1 = left.slice(0, i);\\n        let l2 = left.slice(i)            \\n        for(let j = right.length; j >= 0; j--) {\\n            let r1 = right.slice(0, j)\\n            let r2 = right.slice(j);\\n            // l1 ( l2 + r1 ) r2\\n            const sum = parseInt(l1 !== \\'\\' ? l1 : 1) * \\n                        (parseInt(l2 !== \\'\\' ? l2 : 1) + \\n                        parseInt(r1 !== \\'\\' ? r1 : 1)) * \\n                        parseInt(r2 !== \\'\\' ? r2 : 1);\\n            if(sum < min) {\\n                min = sum                \\n                expressionFound = l1 + \\'(\\' + l2 + \\'+\\' + r1 + \\')\\' + r2;\\n            }\\n        }\\n    }\\n    // Nothing fancy...\\n    return expressionFound;  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} expression\\n * @return {string}\\n */\\n/**\\n * @param {string} expression\\n * @return {string}\\n */\\nvar minimizeResult = function(expression) {\\n    const [left, right] = expression.split(\\'+\\');\\n    let min = Number.MAX_VALUE;\\n    let expressionFound;\\n    for(let i = 0; i < left.length; i++) {\\n        let l1 = left.slice(0, i);\\n        let l2 = left.slice(i)            \\n        for(let j = right.length; j >= 0; j--) {\\n            let r1 = right.slice(0, j)\\n            let r2 = right.slice(j);\\n            // l1 ( l2 + r1 ) r2\\n            const sum = parseInt(l1 !== \\'\\' ? l1 : 1) * \\n                        (parseInt(l2 !== \\'\\' ? l2 : 1) + \\n                        parseInt(r1 !== \\'\\' ? r1 : 1)) * \\n                        parseInt(r2 !== \\'\\' ? r2 : 1);\\n            if(sum < min) {\\n                min = sum                \\n                expressionFound = l1 + \\'(\\' + l2 + \\'+\\' + r1 + \\')\\' + r2;\\n            }\\n        }\\n    }\\n    // Nothing fancy...\\n    return expressionFound;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3478375,
                "title": "kotlin-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun minimizeResult(expression: String): String {\\n        \\n        val split = expression.split(\"+\")\\n        val left = split[0]\\n        val right = split[1]\\n\\n        var num = Integer.MAX_VALUE\\n        var result = \"($left + $right)\"\\n\\n        for (i in 0 until left.length) {\\n            val leftMul = if (left.substring(0,i).isEmpty()) 1 else left.substring(0,i).toInt()\\n            val leftNum = left.substring(i).toInt()\\n\\n            for (j in 1..right.length) {\\n                val rightNum = right.substring(0,j).toInt() \\n                val rightMul = if (right.substring(j).isEmpty()) 1 else right.substring(j).toInt()               \\n                //println(\"$leftMul($leftNum+$rightNum)$rightMul\")\\n                val sum = leftMul * (leftNum + rightNum) * rightMul\\n\\n                if (sum < num) {\\n                    result = \"${left.substring(0,i)}($leftNum+$rightNum)${right.substring(j)}\"\\n                    num = sum\\n                }\\n            }\\n        }\\n\\n        return result\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minimizeResult(expression: String): String {\\n        \\n        val split = expression.split(\"+\")\\n        val left = split[0]\\n        val right = split[1]\\n\\n        var num = Integer.MAX_VALUE\\n        var result = \"($left + $right)\"\\n\\n        for (i in 0 until left.length) {\\n            val leftMul = if (left.substring(0,i).isEmpty()) 1 else left.substring(0,i).toInt()\\n            val leftNum = left.substring(i).toInt()\\n\\n            for (j in 1..right.length) {\\n                val rightNum = right.substring(0,j).toInt() \\n                val rightMul = if (right.substring(j).isEmpty()) 1 else right.substring(j).toInt()               \\n                //println(\"$leftMul($leftNum+$rightNum)$rightMul\")\\n                val sum = leftMul * (leftNum + rightNum) * rightMul\\n\\n                if (sum < num) {\\n                    result = \"${left.substring(0,i)}($leftNum+$rightNum)${right.substring(j)}\"\\n                    num = sum\\n                }\\n            }\\n        }\\n\\n        return result\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424832,
                "title": "python-recursive-solution",
                "content": "# Intuition\\nSliding window with evaluating the string at each move of the parenthesis\\n# Approach\\nRecursively move the parenthesis on either side once, evaluate, and compare to the next call. \\n# Complexity\\n- Time complexity:\\n    for expression of size n, \\n    O(n^2) since we compute the expression n times, and each time we parse through a string of size n.\\n- Space complexity:\\n-   O(n^2) in this case because I got lazy and create expression for each recursive call. Can simply generate expression once at the end and it would become O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        left, right = expression.split(\\'+\\')\\n\\n        _, expr = self.minimizeHelper(0, len(right)+1, left, right)\\n\\n        return expr\\n\\n    def minimizeHelper(self, leftp, rightp, left, right):\\n        if leftp >= len(left) or rightp <= 0:\\n            return sys.maxsize, \\'Invalid\\'\\n\\n        leftcoeff = 1 if leftp <= 0 else int(left[:leftp])\\n        leftsummand = 0 if leftp >= len(left) else int(left[leftp:])\\n        rightsummand = 0 if rightp <= 0 else int(right[:rightp])\\n        rightcoeff = 1 if rightp >= len(right) else int(right[rightp:])\\n\\n        currentsum = leftcoeff * (leftsummand + rightsummand) * rightcoeff\\n        expr = \\'\\'\\n\\n        v1, e1 = self.minimizeHelper(leftp+1, rightp, left, right)\\n        if v1 < currentsum:\\n            currentsum = v1\\n            expr = e1\\n        v2, e2 = self.minimizeHelper(leftp+1, rightp-1, left, right)\\n        if v2 < currentsum:\\n            currentsum = v2\\n            expr = e2\\n        v3, e3 = self.minimizeHelper(leftp, rightp-1, left, right)\\n        if v3 < currentsum:\\n            currentsum = v3\\n            expr = e3\\n    \\n        if len(expr) < 1:\\n            expr = left[:leftp] + \\'(\\' + str(left[leftp:]) + \\'+\\' + str(right[:rightp]) + \\')\\' + str(right[rightp:])\\n        # print(expr)\\n        # print(f\"value {currentsum}\")\\n\\n        return currentsum, expr\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        left, right = expression.split(\\'+\\')\\n\\n        _, expr = self.minimizeHelper(0, len(right)+1, left, right)\\n\\n        return expr\\n\\n    def minimizeHelper(self, leftp, rightp, left, right):\\n        if leftp >= len(left) or rightp <= 0:\\n            return sys.maxsize, \\'Invalid\\'\\n\\n        leftcoeff = 1 if leftp <= 0 else int(left[:leftp])\\n        leftsummand = 0 if leftp >= len(left) else int(left[leftp:])\\n        rightsummand = 0 if rightp <= 0 else int(right[:rightp])\\n        rightcoeff = 1 if rightp >= len(right) else int(right[rightp:])\\n\\n        currentsum = leftcoeff * (leftsummand + rightsummand) * rightcoeff\\n        expr = \\'\\'\\n\\n        v1, e1 = self.minimizeHelper(leftp+1, rightp, left, right)\\n        if v1 < currentsum:\\n            currentsum = v1\\n            expr = e1\\n        v2, e2 = self.minimizeHelper(leftp+1, rightp-1, left, right)\\n        if v2 < currentsum:\\n            currentsum = v2\\n            expr = e2\\n        v3, e3 = self.minimizeHelper(leftp, rightp-1, left, right)\\n        if v3 < currentsum:\\n            currentsum = v3\\n            expr = e3\\n    \\n        if len(expr) < 1:\\n            expr = left[:leftp] + \\'(\\' + str(left[leftp:]) + \\'+\\' + str(right[:rightp]) + \\')\\' + str(right[rightp:])\\n        # print(expr)\\n        # print(f\"value {currentsum}\")\\n\\n        return currentsum, expr\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400776,
                "title": "java-faster-than-100-tc-o-n-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n\\n        String result = \"\";\\n        int min = Integer.MAX_VALUE;\\n\\n        int plus = expression.indexOf(\\'+\\');\\n        StringBuilder str;\\n\\n        int openingMult = 0;\\n        int closingMult = 0;\\n        int sum = 0;\\n\\n        int leftN = Integer.parseInt(expression.substring(0, plus));\\n        int rightN = Integer.parseInt(expression.substring(plus+1, expression.length()));\\n\\n        for (int i = 0; i < plus; i++){\\n            for(int j = plus+2; j <= expression.length();j++) {\\n                str = new StringBuilder();\\n                str.append(expression.substring(0, i));\\n                str.append(\\'(\\');\\n                str.append(expression.substring(i, plus));\\n                str.append(\\'+\\');\\n                str.append(expression.substring(plus+1, j));\\n                str.append(\\')\\');\\n                str.append(expression.substring(j, expression.length()));\\n                String resultString = String.valueOf(str);\\n                int res = eval(resultString);\\n                if (res < min) {\\n                    min = res;\\n                    result = resultString;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n    private int eval(String s){\\n        int plus = s.indexOf(\\'+\\');\\n        int opening = s.indexOf(\\'(\\');\\n        int closing = s.indexOf(\\')\\');\\n        int openingMult = 0;\\n        int closingMult = 0;\\n        if (opening != 0 && opening != -1) openingMult = Integer.parseInt(s.substring(0, opening));\\n        if (closing != s.length()-1 && closing != -1) closingMult = Integer.parseInt(s.substring(closing+1, s.length()));\\n        int addition = Integer.parseInt(s.substring(opening+1, plus)) + Integer.parseInt(s.substring(plus+1, closing));\\n\\n        int result = addition * (openingMult != 0 ? openingMult : 1) * (closingMult != 0 ? closingMult : 1);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n\\n        String result = \"\";\\n        int min = Integer.MAX_VALUE;\\n\\n        int plus = expression.indexOf(\\'+\\');\\n        StringBuilder str;\\n\\n        int openingMult = 0;\\n        int closingMult = 0;\\n        int sum = 0;\\n\\n        int leftN = Integer.parseInt(expression.substring(0, plus));\\n        int rightN = Integer.parseInt(expression.substring(plus+1, expression.length()));\\n\\n        for (int i = 0; i < plus; i++){\\n            for(int j = plus+2; j <= expression.length();j++) {\\n                str = new StringBuilder();\\n                str.append(expression.substring(0, i));\\n                str.append(\\'(\\');\\n                str.append(expression.substring(i, plus));\\n                str.append(\\'+\\');\\n                str.append(expression.substring(plus+1, j));\\n                str.append(\\')\\');\\n                str.append(expression.substring(j, expression.length()));\\n                String resultString = String.valueOf(str);\\n                int res = eval(resultString);\\n                if (res < min) {\\n                    min = res;\\n                    result = resultString;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n    private int eval(String s){\\n        int plus = s.indexOf(\\'+\\');\\n        int opening = s.indexOf(\\'(\\');\\n        int closing = s.indexOf(\\')\\');\\n        int openingMult = 0;\\n        int closingMult = 0;\\n        if (opening != 0 && opening != -1) openingMult = Integer.parseInt(s.substring(0, opening));\\n        if (closing != s.length()-1 && closing != -1) closingMult = Integer.parseInt(s.substring(closing+1, s.length()));\\n        int addition = Integer.parseInt(s.substring(opening+1, plus)) + Integer.parseInt(s.substring(plus+1, closing));\\n\\n        int result = addition * (openingMult != 0 ? openingMult : 1) * (closingMult != 0 ? closingMult : 1);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390890,
                "title": "c-very-easy-solution-with-constant-space",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int toInt(string str , int i,int j){\\n        if(j==-1 or i==str.length()) return 1;\\n        int ans=0;\\n        for(int k=i;k<=j;k++){\\n           ans =  ans*10 + (str[k]-\\'0\\');\\n        }\\n        return ans;\\n    }\\n\\n\\n    string minimizeResult(string str) {\\n        int n=str.length();\\n        int ansLeft =0 , ansRight = 0 , plus=0;\\n\\n        for(int i=0;i<n;i++){\\n           if(str[i]==\\'+\\'){ \\n             plus=i;\\n             break;\\n           }\\n        }\\n        cout<<plus<<endl;\\n        int solve = INT_MAX;\\n        for(int i=-1;i<plus-1;i++){\\n            for(int j=plus+1;j<n;j++){\\n                int a = toInt(str , 0 , i);\\n                int b = toInt(str , i+1 , plus-1);\\n                int c = toInt(str , plus+1 , j);\\n                int d = toInt(str , j+1 , n-1);\\n                cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\\n                if(solve> a*(b+c)*d){\\n                    solve = a*(b+c)*d;\\n                    ansLeft = i, ansRight =j;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        if(ansLeft==-1) ans+=\\'(\\';\\n        for(int i=0;i<n;i++){\\n            ans+=str[i];\\n            if(i==ansLeft){\\n                ans+=\\'(\\';\\n            }\\n            if(i==ansRight){\\n                ans+=\\')\\';\\n            }\\n        }\\n        if(ansRight==n) ans+=\\')\\';\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int toInt(string str , int i,int j){\\n        if(j==-1 or i==str.length()) return 1;\\n        int ans=0;\\n        for(int k=i;k<=j;k++){\\n           ans =  ans*10 + (str[k]-\\'0\\');\\n        }\\n        return ans;\\n    }\\n\\n\\n    string minimizeResult(string str) {\\n        int n=str.length();\\n        int ansLeft =0 , ansRight = 0 , plus=0;\\n\\n        for(int i=0;i<n;i++){\\n           if(str[i]==\\'+\\'){ \\n             plus=i;\\n             break;\\n           }\\n        }\\n        cout<<plus<<endl;\\n        int solve = INT_MAX;\\n        for(int i=-1;i<plus-1;i++){\\n            for(int j=plus+1;j<n;j++){\\n                int a = toInt(str , 0 , i);\\n                int b = toInt(str , i+1 , plus-1);\\n                int c = toInt(str , plus+1 , j);\\n                int d = toInt(str , j+1 , n-1);\\n                cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\\n                if(solve> a*(b+c)*d){\\n                    solve = a*(b+c)*d;\\n                    ansLeft = i, ansRight =j;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        if(ansLeft==-1) ans+=\\'(\\';\\n        for(int i=0;i<n;i++){\\n            ans+=str[i];\\n            if(i==ansLeft){\\n                ans+=\\'(\\';\\n            }\\n            if(i==ansRight){\\n                ans+=\\')\\';\\n            }\\n        }\\n        if(ansRight==n) ans+=\\')\\';\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3350070,
                "title": "faster-than-100-percent",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minimizeResult(string ex) {\\n        int n= ex.size();\\n        int p = ex.find(\\'+\\');\\n        int val = INT_MAX;\\n        string ans = \"\";\\n        for(int i=0;i<p;i++){\\n            string s1 = ex.substr(0,i);\\n            string s2 = ex.substr(i,p-i);\\n            int a = s1 == \"\"?1:stoi(s1);\\n            int b = stoi(s2);\\n            for(int j=p+1;j<n;j++){\\n                string s3 = ex.substr(p+1,j-p);\\n                string s4 = ex.substr(j+1);\\n                int c = stoi(s3);\\n                int d = s4==\"\"?1:stoi(s4);\\n                if(a*(b+c)*d < val){\\n                    val = a*(b+c)*d;\\n                    ans = s1 + \\'(\\' + s2 + \\'+\\' + s3 + \\')\\' + s4;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string ex) {\\n        int n= ex.size();\\n        int p = ex.find(\\'+\\');\\n        int val = INT_MAX;\\n        string ans = \"\";\\n        for(int i=0;i<p;i++){\\n            string s1 = ex.substr(0,i);\\n            string s2 = ex.substr(i,p-i);\\n            int a = s1 == \"\"?1:stoi(s1);\\n            int b = stoi(s2);\\n            for(int j=p+1;j<n;j++){\\n                string s3 = ex.substr(p+1,j-p);\\n                string s4 = ex.substr(j+1);\\n                int c = stoi(s3);\\n                int d = s4==\"\"?1:stoi(s4);\\n                if(a*(b+c)*d < val){\\n                    val = a*(b+c)*d;\\n                    ans = s1 + \\'(\\' + s2 + \\'+\\' + s3 + \\')\\' + s4;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349448,
                "title": "c-brute-force",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string minimizeResult(string expression) {\\n        int k = expression.find(\\'+\\'), n = expression.length(), minVal = INT_MAX;\\n        string ans = \"\";\\n        for(int i = 0; i < k; i++) {\\n            for(int j = k + 1; j < n; j++) {\\n                string a = expression.substr(0, i);\\n                string b = expression.substr(i, k - i);\\n                string c = expression.substr(k + 1, j - k);\\n                string d = expression.substr(j + 1);\\n                int val = (a == \"\"? 1: stoi(a)) * (stoi(b) + stoi(c)) * (d == \"\"? 1: stoi(d));\\n                if(val < minVal) {\\n                    ans = a + \"(\" + b + \"+\" + c + \")\" + d;\\n                    minVal = val;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string expression) {\\n        int k = expression.find(\\'+\\'), n = expression.length(), minVal = INT_MAX;\\n        string ans = \"\";\\n        for(int i = 0; i < k; i++) {\\n            for(int j = k + 1; j < n; j++) {\\n                string a = expression.substr(0, i);\\n                string b = expression.substr(i, k - i);\\n                string c = expression.substr(k + 1, j - k);\\n                string d = expression.substr(j + 1);\\n                int val = (a == \"\"? 1: stoi(a)) * (stoi(b) + stoi(c)) * (d == \"\"? 1: stoi(d));\\n                if(val < minVal) {\\n                    ans = a + \"(\" + b + \"+\" + c + \")\" + d;\\n                    minVal = val;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326211,
                "title": "f-string-madness",
                "content": "just for fun i guess ... \\n\\n```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        expressions = []\\n        plus = expression.index(\\'+\\')\\n        \\n        for left in range(plus):\\n            l = f\"{expression[:left]}{\\'*\\' if left else \\'\\'}({expression[left:plus]}\"\\n            for right in range(plus+2, len(expression)+1):\\n                s = right != len(expression)\\n                r = f\"{expression[plus+1:right]}){\\'*\\' if s else \\'\\'}{expression[right:]}\"\\n                e = f\\'{l}+{r}\\'\\n                heappush(expressions, (eval(e), e))\\n    \\n        return expressions[0][-1].replace(\\'*\\', \\'\\')\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        expressions = []\\n        plus = expression.index(\\'+\\')\\n        \\n        for left in range(plus):\\n            l = f\"{expression[:left]}{\\'*\\' if left else \\'\\'}({expression[left:plus]}\"\\n            for right in range(plus+2, len(expression)+1):\\n                s = right != len(expression)\\n                r = f\"{expression[plus+1:right]}){\\'*\\' if s else \\'\\'}{expression[right:]}\"\\n                e = f\\'{l}+{r}\\'\\n                heappush(expressions, (eval(e), e))\\n    \\n        return expressions[0][-1].replace(\\'*\\', \\'\\')\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295211,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func minimizeResult(_ e: String) -> String {\\n        \\n        func n(_ s: String) -> [[Int]] {\\n            (0...s.count).map { [Int(s.prefix($0)) ?? 1, Int(s.dropFirst($0)) ?? 1] }\\n        }\\n\\n        let w = e.components(separatedBy: \"+\")\\n        \\n        let n1 = n(w[0])\\n        let n2 = n(w[1])\\n        \\n        var mi = Int.max\\n        var i1 = 0\\n        var i2 = 0\\n\\n        for i in n1.indices {\\n            for j in n2.indices {\\n\\n                let v = n1[i][0] * n2[j][1] * (n1[i][1] + n2[j][0])\\n                \\n                if v < mi {\\n                    mi = v\\n                    i1 = i\\n                    i2 = j\\n                }\\n            }\\n        }\\n\\n        var res = \"(\\\\(n1[i1][1])+\\\\(n2[i2][0]))\"\\n\\n        if n1.count > 2, i1 != 0 { res = \"\\\\(n1[i1][0])\" + res }\\n        if n2.count > 2, i2 != n2.count - 1 { res += \"\\\\(n2[i2][1])\" }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimizeResult(_ e: String) -> String {\\n        \\n        func n(_ s: String) -> [[Int]] {\\n            (0...s.count).map { [Int(s.prefix($0)) ?? 1, Int(s.dropFirst($0)) ?? 1] }\\n        }\\n\\n        let w = e.components(separatedBy: \"+\")\\n        \\n        let n1 = n(w[0])\\n        let n2 = n(w[1])\\n        \\n        var mi = Int.max\\n        var i1 = 0\\n        var i2 = 0\\n\\n        for i in n1.indices {\\n            for j in n2.indices {\\n\\n                let v = n1[i][0] * n2[j][1] * (n1[i][1] + n2[j][0])\\n                \\n                if v < mi {\\n                    mi = v\\n                    i1 = i\\n                    i2 = j\\n                }\\n            }\\n        }\\n\\n        var res = \"(\\\\(n1[i1][1])+\\\\(n2[i2][0]))\"\\n\\n        if n1.count > 2, i1 != 0 { res = \"\\\\(n1[i1][0])\" + res }\\n        if n2.count > 2, i2 != n2.count - 1 { res += \"\\\\(n2[i2][1])\" }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263060,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimize_result(expression: String) -> String {\\n        let mut plus = false;\\n        let mut a = String::new();\\n        let mut b = String::new();\\n        for ch in expression.chars() {\\n            if ch == \\'+\\' {\\n                plus = true;\\n            }\\n            if !plus {\\n                a.push(ch);\\n            } else {\\n                b.push(ch);\\n            }\\n        }\\n        let n = a.len();\\n        let m = b.len();\\n        let mut ans = String::new();\\n        let mut maxi = i32::MAX;\\n        for i in 0..n {\\n            for j in 1..m {\\n                let left;\\n                if i == 0 {\\n                    left = 1;\\n                } else {\\n                    left = a[0..i].parse::<i32>().unwrap();\\n                }\\n                let middle = a[i..n].parse::<i32>().unwrap() + b[0..j + 1].parse::<i32>().unwrap();\\n                let right;\\n                if j == m - 1 {\\n                    right = 1;\\n                } else {\\n                    right = b[j + 1..m].parse::<i32>().unwrap();\\n                }\\n                if left * middle * right < maxi {\\n                    maxi = left * middle * right;\\n                    ans = a[0..i].to_string()\\n                        + \"(\"\\n                        + &a[i..n].to_string()\\n                        + &b[0..j + 1].to_string()\\n                        + \")\"\\n                        + &b[j + 1..m].to_string();\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimize_result(expression: String) -> String {\\n        let mut plus = false;\\n        let mut a = String::new();\\n        let mut b = String::new();\\n        for ch in expression.chars() {\\n            if ch == \\'+\\' {\\n                plus = true;\\n            }\\n            if !plus {\\n                a.push(ch);\\n            } else {\\n                b.push(ch);\\n            }\\n        }\\n        let n = a.len();\\n        let m = b.len();\\n        let mut ans = String::new();\\n        let mut maxi = i32::MAX;\\n        for i in 0..n {\\n            for j in 1..m {\\n                let left;\\n                if i == 0 {\\n                    left = 1;\\n                } else {\\n                    left = a[0..i].parse::<i32>().unwrap();\\n                }\\n                let middle = a[i..n].parse::<i32>().unwrap() + b[0..j + 1].parse::<i32>().unwrap();\\n                let right;\\n                if j == m - 1 {\\n                    right = 1;\\n                } else {\\n                    right = b[j + 1..m].parse::<i32>().unwrap();\\n                }\\n                if left * middle * right < maxi {\\n                    maxi = left * middle * right;\\n                    ans = a[0..i].to_string()\\n                        + \"(\"\\n                        + &a[i..n].to_string()\\n                        + &b[0..j + 1].to_string()\\n                        + \")\"\\n                        + &b[j + 1..m].to_string();\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3255051,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string expression) {\\n        int plusIdx = expression.find(\\'+\\') ;\\n        string left = expression.substr(0, plusIdx) ;\\n        string right = expression.substr(plusIdx+1) ;\\n        string ret ;\\n        int minimum = INT_MAX ;\\n        for(int i = 0; i < left.size(); i++){\\n            for(int j = 0; j < right.size(); j++){\\n                int a = (i == 0) ? 1 : stoi(left.substr(0, i)) ;\\n                int b = stoi(left.substr(i)) ;\\n                int c = stoi(right.substr(0, j+1)) ;\\n                int d = (j == right.size()-1) ? 1 : stoi(right.substr(j+1)) ;\\n                \\n                int val = a*(b+c)*d ;\\n                \\n                if(val < minimum){\\n                    minimum = val ;\\n                    ret = (i== 0 ? \"\" : to_string(a) ) + \\'(\\' + to_string(b) + \\'+\\'\\\\\\n                        + to_string(c) + \\')\\' + (j == right.size()-1 ? \"\" : to_string(d))   ;\\n                }\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string expression) {\\n        int plusIdx = expression.find(\\'+\\') ;\\n        string left = expression.substr(0, plusIdx) ;\\n        string right = expression.substr(plusIdx+1) ;\\n        string ret ;\\n        int minimum = INT_MAX ;\\n        for(int i = 0; i < left.size(); i++){\\n            for(int j = 0; j < right.size(); j++){\\n                int a = (i == 0) ? 1 : stoi(left.substr(0, i)) ;\\n                int b = stoi(left.substr(i)) ;\\n                int c = stoi(right.substr(0, j+1)) ;\\n                int d = (j == right.size()-1) ? 1 : stoi(right.substr(j+1)) ;\\n                \\n                int val = a*(b+c)*d ;\\n                \\n                if(val < minimum){\\n                    minimum = val ;\\n                    ret = (i== 0 ? \"\" : to_string(a) ) + \\'(\\' + to_string(b) + \\'+\\'\\\\\\n                        + to_string(c) + \\')\\' + (j == right.size()-1 ? \"\" : to_string(d))   ;\\n                }\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234546,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string s) {\\n        auto pos_plus = s.find(\\'+\\');\\n        auto s1 = s.substr(0, pos_plus), s2 = s.substr(pos_plus+1);\\n        string res;\\n        long long minVal = 1e18;\\n        for(int i=0;i<s1.size();i++){\\n            auto a = 1LL;\\n            if(i>0) a = stoll(s1.substr(0, i));\\n            auto b = stoll(s.substr(i));\\n            for(int j=1;j<=s2.size();j++){\\n                auto c = stoll(s2.substr(0, j));\\n                auto d = 1LL;\\n                if(j < s2.size()) d = stoll(s2.substr(j));\\n                long long val = a*(b+c)*d;\\n                if(val <minVal){\\n                    minVal = val;\\n                    auto u = s1, v = s2;\\n                    u.insert(i, 1, \\'(\\');\\n                    v.insert(j, 1, \\')\\');\\n                    res = u+\\'+\\'+v;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string s) {\\n        auto pos_plus = s.find(\\'+\\');\\n        auto s1 = s.substr(0, pos_plus), s2 = s.substr(pos_plus+1);\\n        string res;\\n        long long minVal = 1e18;\\n        for(int i=0;i<s1.size();i++){\\n            auto a = 1LL;\\n            if(i>0) a = stoll(s1.substr(0, i));\\n            auto b = stoll(s.substr(i));\\n            for(int j=1;j<=s2.size();j++){\\n                auto c = stoll(s2.substr(0, j));\\n                auto d = 1LL;\\n                if(j < s2.size()) d = stoll(s2.substr(j));\\n                long long val = a*(b+c)*d;\\n                if(val <minVal){\\n                    minVal = val;\\n                    auto u = s1, v = s2;\\n                    u.insert(i, 1, \\'(\\');\\n                    v.insert(j, 1, \\')\\');\\n                    res = u+\\'+\\'+v;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223520,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minimizeResult(string expression) {\\n        vector<vector<int>>left,right;\\n        vector<int>v;\\n        int k=find(expression.begin(),expression.end(),\\'+\\')-expression.begin();\\n        string l=expression.substr(0,k);\\n        string r=expression.substr(k+1);\\n        //cout<<l<<\" \"<<r<<endl;\\n        int i=0;\\n        while(i<l.size()){\\n            if(i==0)left.push_back({-1,stoi(l)});\\n            else left.push_back({stoi(l.substr(0,i)),stoi(l.substr(i))});\\n            i++;\\n        }\\n        //cout<<\"h1\"<<endl;\\n        i=1;\\n        while(i<=r.size()){\\n            if(i==r.size())right.push_back({stoi(r),-1});\\n            else right.push_back({stoi(r.substr(0,i)),stoi(r.substr(i))});\\n            i++;\\n        }\\n        //cout<<\"h2\"<<endl;\\n        int p,q;\\n        int minm=INT_MAX;\\n        for(int i=0;i<left.size();i++){\\n            for(int j=0;j<right.size();j++){\\n                int w=left[i][0]<0?1:left[i][0];\\n                int x=right[j][1]<0?1:right[j][1];\\n                int ev=w*(left[i][1]+right[j][0])*x;\\n                if(minm>ev){\\n                    minm=ev;\\n                    p=i;\\n                    q=j;\\n                }\\n            }\\n        }\\n        //cout<<\"h3\"<<endl;\\n        string w=left[p][0]<0?\"\":to_string(left[p][0]);\\n        string x=right[q][1]<0?\"\":to_string(right[q][1]);\\n        string res=w+\"(\"+to_string(left[p][1])+\"+\"+to_string(right[q][0])+\")\"+x;\\n        return res;\\n\\n        //return \"\";\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string expression) {\\n        vector<vector<int>>left,right;\\n        vector<int>v;\\n        int k=find(expression.begin(),expression.end(),\\'+\\')-expression.begin();\\n        string l=expression.substr(0,k);\\n        string r=expression.substr(k+1);\\n        //cout<<l<<\" \"<<r<<endl;\\n        int i=0;\\n        while(i<l.size()){\\n            if(i==0)left.push_back({-1,stoi(l)});\\n            else left.push_back({stoi(l.substr(0,i)),stoi(l.substr(i))});\\n            i++;\\n        }\\n        //cout<<\"h1\"<<endl;\\n        i=1;\\n        while(i<=r.size()){\\n            if(i==r.size())right.push_back({stoi(r),-1});\\n            else right.push_back({stoi(r.substr(0,i)),stoi(r.substr(i))});\\n            i++;\\n        }\\n        //cout<<\"h2\"<<endl;\\n        int p,q;\\n        int minm=INT_MAX;\\n        for(int i=0;i<left.size();i++){\\n            for(int j=0;j<right.size();j++){\\n                int w=left[i][0]<0?1:left[i][0];\\n                int x=right[j][1]<0?1:right[j][1];\\n                int ev=w*(left[i][1]+right[j][0])*x;\\n                if(minm>ev){\\n                    minm=ev;\\n                    p=i;\\n                    q=j;\\n                }\\n            }\\n        }\\n        //cout<<\"h3\"<<endl;\\n        string w=left[p][0]<0?\"\":to_string(left[p][0]);\\n        string x=right[q][1]<0?\"\":to_string(right[q][1]);\\n        string res=w+\"(\"+to_string(left[p][1])+\"+\"+to_string(right[q][0])+\")\"+x;\\n        return res;\\n\\n        //return \"\";\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3191268,
                "title": "easy-to-understand-brute-force-python-solution-faster-than-97",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n\\n        def eval_expr(l,li,ri):\\n            ai=1\\n            if li!=0:\\n                l.insert(li,\\'*\\')\\n                ai+=1\\n            if ri!=len(l)-ai:\\n                l.insert(ri+ai,\\'*\\')\\n            return eval(\\'\\'.join(l))\\n\\n        pi=expression.index(\\'+\\')\\n        length=len(expression)\\n        res_sum,res_s=float(\\'inf\\'),None\\n        for i in range(pi):\\n            for j in range(pi+2,length+1):\\n                l=list(expression)\\n                l.insert(i,\\'(\\')\\n                l.insert(j+1,\\')\\')\\n                t=eval_expr(l,i,j+1)\\n                if t<res_sum:\\n                    res_sum=t\\n                    res_s=\\'\\'.join([c for c in l if c!=\\'*\\'])\\n        return res_s\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n\\n        def eval_expr(l,li,ri):\\n            ai=1\\n            if li!=0:\\n                l.insert(li,\\'*\\')\\n                ai+=1\\n            if ri!=len(l)-ai:\\n                l.insert(ri+ai,\\'*\\')\\n            return eval(\\'\\'.join(l))\\n\\n        pi=expression.index(\\'+\\')\\n        length=len(expression)\\n        res_sum,res_s=float(\\'inf\\'),None\\n        for i in range(pi):\\n            for j in range(pi+2,length+1):\\n                l=list(expression)\\n                l.insert(i,\\'(\\')\\n                l.insert(j+1,\\')\\')\\n                t=eval_expr(l,i,j+1)\\n                if t<res_sum:\\n                    res_sum=t\\n                    res_s=\\'\\'.join([c for c in l if c!=\\'*\\'])\\n        return res_s\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178831,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        int min=Integer.MAX_VALUE;\\n      String[] div=expression.split(\"\\\\\\\\+\");\\n      String left=div[0];\\n      String right=div[1];\\n      String ans=\"(\" + expression + \")\";\\n      for(int i=0;i<left.length();i++){\\n          int lm=left.substring(0,i)==\"\" ? 1:Integer.parseInt(left.substring(0,i));\\n          int leftnum=Integer.parseInt(left.substring(i));\\n          for(int j=1;j<=right.length();j++){\\n              int rm=right.substring(j)==\"\"?1:Integer.parseInt(right.substring(j));\\n          int rightnum=Integer.parseInt(right.substring(0,j));\\n          int sum=lm*(leftnum+rightnum)*rm;\\n          if(min>sum){\\n              min=sum;\\n              ans=left.substring(0,i)+\"(\"+leftnum+ \"+\"+rightnum + \")\"+right.substring(j);\\n          }\\n          }\\n      }\\n      return ans;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        int min=Integer.MAX_VALUE;\\n      String[] div=expression.split(\"\\\\\\\\+\");\\n      String left=div[0];\\n      String right=div[1];\\n      String ans=\"(\" + expression + \")\";\\n      for(int i=0;i<left.length();i++){\\n          int lm=left.substring(0,i)==\"\" ? 1:Integer.parseInt(left.substring(0,i));\\n          int leftnum=Integer.parseInt(left.substring(i));\\n          for(int j=1;j<=right.length();j++){\\n              int rm=right.substring(j)==\"\"?1:Integer.parseInt(right.substring(j));\\n          int rightnum=Integer.parseInt(right.substring(0,j));\\n          int sum=lm*(leftnum+rightnum)*rm;\\n          if(min>sum){\\n              min=sum;\\n              ans=left.substring(0,i)+\"(\"+leftnum+ \"+\"+rightnum + \")\"+right.substring(j);\\n          }\\n          }\\n      }\\n      return ans;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140028,
                "title": "c-using-nestd-loops",
                "content": "# Intuition\\nlength constraints are low we can try every possibal way of placing brackets\\n\\n# Approach\\napplied nested loops for every character\\n\\n# Complexity\\n- Time complexity:\\nO(N^3)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minimizeResult(string expression) {\\n        int mid;\\n        for(int i = 0; i < expression.size(); i++){\\n            if(expression[i] == \\'+\\'){\\n                mid = i;\\n                break;\\n            }\\n        }\\n        int mini = INT_MAX;\\n        string ans = \"\";\\n        for(int i = 1 ; mid+i < expression.size(); i++){\\n            for(int j = 1 ; mid-j >= 0; j++){\\n                string leftStr = expression.substr(mid-j,j);\\n                string rightStr = expression.substr(mid+1,i);\\n                \\n                int num = stoi(leftStr) + stoi(rightStr);\\n                string remainingLeft = expression.substr(0,mid-j);\\n                string remainingRight = expression.substr(mid+i+1);\\n                if(remainingRight.size()){\\n                    num *= stoi(remainingRight);\\n                }\\n                if(remainingLeft.size()){\\n                    num *= stoi(remainingLeft);\\n                }\\n\\n                if(num < mini){\\n                    string temp = expression;\\n                    temp.insert(mid-j,\"(\");\\n                    temp.insert(mid+i+2,\")\");\\n                    ans = temp;\\n                    mini = num;\\n                }\\n            }\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string expression) {\\n        int mid;\\n        for(int i = 0; i < expression.size(); i++){\\n            if(expression[i] == \\'+\\'){\\n                mid = i;\\n                break;\\n            }\\n        }\\n        int mini = INT_MAX;\\n        string ans = \"\";\\n        for(int i = 1 ; mid+i < expression.size(); i++){\\n            for(int j = 1 ; mid-j >= 0; j++){\\n                string leftStr = expression.substr(mid-j,j);\\n                string rightStr = expression.substr(mid+1,i);\\n                \\n                int num = stoi(leftStr) + stoi(rightStr);\\n                string remainingLeft = expression.substr(0,mid-j);\\n                string remainingRight = expression.substr(mid+i+1);\\n                if(remainingRight.size()){\\n                    num *= stoi(remainingRight);\\n                }\\n                if(remainingLeft.size()){\\n                    num *= stoi(remainingLeft);\\n                }\\n\\n                if(num < mini){\\n                    string temp = expression;\\n                    temp.insert(mid-j,\"(\");\\n                    temp.insert(mid+i+2,\")\");\\n                    ans = temp;\\n                    mini = num;\\n                }\\n            }\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014883,
                "title": "easy-to-understand-python-one-step-at-a-time",
                "content": "```\\n   def minimizeResult(self, expression):\\n   \\n       p = expression.index(\\'+\\')\\n       l = expression[0:p]\\n       r = expression[p+1:len(expression)]\\n        \\n        d = {}\\n        \\n        nl = len(l)\\n        nr = len(r)\\n        \\n       for i in range(nl):\\n           for j in range(1, nr+1):\\n                e = str(\"(\" + l[i:nl] + \"+\" + r[0:j] + \")\")\\n                f = l[0:i]\\n                b = r[j:nr]\\n                \\n                if f != \"\": e = f + \"*\" + e\\n                if b != \"\": e = e + \"*\" + b\\n                \\n                k = e.replace(\"*\", \"\")\\n                if k not in d: d[k] = eval(e)\\n        \\n        return d.keys()[d.values().index(min(d.values()))]\\n```\\n\\nRuntime: 41.30%\\nMemory: 82.61%",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n   def minimizeResult(self, expression):\\n   \\n       p = expression.index(\\'+\\')\\n       l = expression[0:p]\\n       r = expression[p+1:len(expression)]\\n        \\n        d = {}\\n        \\n        nl = len(l)\\n        nr = len(r)\\n        \\n       for i in range(nl):\\n           for j in range(1, nr+1):\\n                e = str(\"(\" + l[i:nl] + \"+\" + r[0:j] + \")\")\\n                f = l[0:i]\\n                b = r[j:nr]\\n                \\n                if f != \"\": e = f + \"*\" + e\\n                if b != \"\": e = e + \"*\" + b\\n                \\n                k = e.replace(\"*\", \"\")\\n                if k not in d: d[k] = eval(e)\\n        \\n        return d.keys()[d.values().index(min(d.values()))]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3005032,
                "title": "java-100-fast-easy-to-understand-parentheses-added-last",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        String[] nums = expression.split(\"\\\\\\\\+\");\\n        int num1 = Integer.parseInt(nums[0]);\\n        int num2 = Integer.parseInt(nums[1]);\\n        int length1 = nums[0].length();\\n        int length2 = nums[1].length();\\n        int[] splits1;\\n        int[] splits2;\\n        int min = Integer.MAX_VALUE;\\n        int result;\\n        int openParen = -1;\\n        int closeParen = -1;\\n        for (int i = length1 - 1; i >= 0; i--) {\\n            for (int j = length2; j >= 1; j--) {\\n                splits1 = parseNumber(num1, i, length1);\\n                splits2 = parseNumber(num2, j, length2);\\n                result = splits1[0] * (splits1[1] + splits2[0]) * splits2[1];\\n                if (result < min) {\\n                    min = result;\\n                    openParen = i;\\n                    closeParen = j;\\n                }\\n            }\\n        }\\n        StringBuilder exp = new StringBuilder(expression);\\n        exp.insert(openParen, \"(\");\\n        //1 for \"(\" just added and 1 for \"+\" so 2\\n        exp.insert(length1 + 2 + closeParen, \")\");\\n        return exp.toString();\\n    }\\n\\n    /*\\n        split given number with the provided number of digits\\n        ex. num = 123, firstLength = 1 -> 1, 23\\n            num = 123, firstLength = 0 -> 1, 123 (return 1 as the first number here instead of 0 so it doesn\\'t zero out\\n            the product of the expression\\n     */\\n    private int[] parseNumber(int num, int firstLength, int totalLength) {\\n        int[] answer = new int[2];\\n        int secondLength = totalLength - firstLength;\\n        int n = 1;\\n        int secondNum = 0;\\n        while (secondLength > 0) {\\n            secondNum = (num % 10) * n + secondNum;\\n            n *= 10;\\n            num = num / 10;\\n            secondLength--;\\n        }\\n        answer[0] = num == 0 ? 1 : num;\\n        answer[1] = secondNum == 0 ? 1 : secondNum;\\n        return answer;\\n    }        \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        String[] nums = expression.split(\"\\\\\\\\+\");\\n        int num1 = Integer.parseInt(nums[0]);\\n        int num2 = Integer.parseInt(nums[1]);\\n        int length1 = nums[0].length();\\n        int length2 = nums[1].length();\\n        int[] splits1;\\n        int[] splits2;\\n        int min = Integer.MAX_VALUE;\\n        int result;\\n        int openParen = -1;\\n        int closeParen = -1;\\n        for (int i = length1 - 1; i >= 0; i--) {\\n            for (int j = length2; j >= 1; j--) {\\n                splits1 = parseNumber(num1, i, length1);\\n                splits2 = parseNumber(num2, j, length2);\\n                result = splits1[0] * (splits1[1] + splits2[0]) * splits2[1];\\n                if (result < min) {\\n                    min = result;\\n                    openParen = i;\\n                    closeParen = j;\\n                }\\n            }\\n        }\\n        StringBuilder exp = new StringBuilder(expression);\\n        exp.insert(openParen, \"(\");\\n        //1 for \"(\" just added and 1 for \"+\" so 2\\n        exp.insert(length1 + 2 + closeParen, \")\");\\n        return exp.toString();\\n    }\\n\\n    /*\\n        split given number with the provided number of digits\\n        ex. num = 123, firstLength = 1 -> 1, 23\\n            num = 123, firstLength = 0 -> 1, 123 (return 1 as the first number here instead of 0 so it doesn\\'t zero out\\n            the product of the expression\\n     */\\n    private int[] parseNumber(int num, int firstLength, int totalLength) {\\n        int[] answer = new int[2];\\n        int secondLength = totalLength - firstLength;\\n        int n = 1;\\n        int secondNum = 0;\\n        while (secondLength > 0) {\\n            secondNum = (num % 10) * n + secondNum;\\n            n *= 10;\\n            num = num / 10;\\n            secondLength--;\\n        }\\n        answer[0] = num == 0 ? 1 : num;\\n        answer[1] = secondNum == 0 ? 1 : secondNum;\\n        return answer;\\n    }        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957168,
                "title": "easy-with-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n$$ Using \\\\ resursion \\\\ we \\\\ can \\\\ generate \\\\ all \\\\ possible \\\\ states.\\\\\\\\\\nfor \\\\ example $$ $$\\\\  12+34 :  \\\\\\\\ 1*(2+34), \\\\\\\\ (12+3)*4, \\\\  \\\\\\\\ 1*(2+3)*4, \\\\\\\\ 12+34$$\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStart with$$ \\\\ l = 0$$ as left pointer and $$r = n-1$$ as right pointer.\\nand call the recursion for $$(l + 1, r), (l, r - 1)$$\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nExponential ~ $$O(2^n)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    long minVal = Long.MAX_VALUE;\\n    String ans = \"\";\\n    public String minimizeResult(String expression) {\\n\\n        int n =  expression.length();\\n        generate(0, n-1, expression, n);\\n        return ans;\\n        \\n    }\\n    int getSum(String val){\\n        String [] nums = val.split(\"\\\\\\\\+\");\\n        if(nums.length < 2) return Integer.MAX_VALUE;\\n        return Integer.valueOf(nums[0]) + Integer.valueOf(nums[1]);\\n    }\\n\\n    void generate(int l, int r, String expression, int n){\\n        if(l > r) return;\\n        if(expression.charAt(l) == \\'+\\' || expression.charAt(r) == \\'+\\' ) return;\\n        String mid =  expression.substring(l,r+1);\\n        String left = expression.substring(0,l);\\n        String right = expression.substring(r+1,n);\\n        long aux = g(left) * getSum(mid) * g(right);\\n        if(minVal > aux){\\n            minVal = aux;\\n            ans = left +\"(\"+mid+\")\"+ right;\\n        }\\n        generate(l + 1, r,expression, n);\\n        generate(l, r - 1,expression, n);\\n    }\\n\\n    int g(String s){\\n        if(s == \"\") return 1;\\n        return Integer.valueOf(s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    long minVal = Long.MAX_VALUE;\\n    String ans = \"\";\\n    public String minimizeResult(String expression) {\\n\\n        int n =  expression.length();\\n        generate(0, n-1, expression, n);\\n        return ans;\\n        \\n    }\\n    int getSum(String val){\\n        String [] nums = val.split(\"\\\\\\\\+\");\\n        if(nums.length < 2) return Integer.MAX_VALUE;\\n        return Integer.valueOf(nums[0]) + Integer.valueOf(nums[1]);\\n    }\\n\\n    void generate(int l, int r, String expression, int n){\\n        if(l > r) return;\\n        if(expression.charAt(l) == \\'+\\' || expression.charAt(r) == \\'+\\' ) return;\\n        String mid =  expression.substring(l,r+1);\\n        String left = expression.substring(0,l);\\n        String right = expression.substring(r+1,n);\\n        long aux = g(left) * getSum(mid) * g(right);\\n        if(minVal > aux){\\n            minVal = aux;\\n            ans = left +\"(\"+mid+\")\"+ right;\\n        }\\n        generate(l + 1, r,expression, n);\\n        generate(l, r - 1,expression, n);\\n    }\\n\\n    int g(String s){\\n        if(s == \"\") return 1;\\n        return Integer.valueOf(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940248,
                "title": "python-just-a-solution",
                "content": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        nums = expression.split(\"+\")\\n        len_n1 = len(nums[0])\\n        len_n2 = len(nums[1])\\n\\n        # left parentheses can be added from 0 to len_n1 - 1\\n        # right parenthese can be added from 1 to len_n2\\n\\n        min_val = float(\\'inf\\')\\n        min_i, min_j = 0, 1\\n        for i in range(len_n1):\\n            if i == 0:\\n                n1_multi = 1\\n            else:\\n                n1_multi = int(nums[0][0:i])\\n            n1_plus = int(nums[0][i:len_n1])\\n            for j in range(1, len_n2 + 1):\\n                if j == len_n2:\\n                    n2_multi = 1\\n                else:\\n                    n2_multi = int(nums[1][j:len_n2])\\n                n2_plus = int(nums[1][0:j])\\n\\n                tval = n1_multi * (n1_plus + n2_plus) * n2_multi\\n                if tval < min_val:\\n                    min_val = tval\\n                    min_i = i\\n                    min_j = j\\n        return \"+\".join([nums[0][0:min_i] + \\'(\\' + nums[0][min_i:len_n1], nums[1][0:min_j] + \\')\\' + nums[1][min_j:len_n2]])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        nums = expression.split(\"+\")\\n        len_n1 = len(nums[0])\\n        len_n2 = len(nums[1])\\n\\n        # left parentheses can be added from 0 to len_n1 - 1\\n        # right parenthese can be added from 1 to len_n2\\n\\n        min_val = float(\\'inf\\')\\n        min_i, min_j = 0, 1\\n        for i in range(len_n1):\\n            if i == 0:\\n                n1_multi = 1\\n            else:\\n                n1_multi = int(nums[0][0:i])\\n            n1_plus = int(nums[0][i:len_n1])\\n            for j in range(1, len_n2 + 1):\\n                if j == len_n2:\\n                    n2_multi = 1\\n                else:\\n                    n2_multi = int(nums[1][j:len_n2])\\n                n2_plus = int(nums[1][0:j])\\n\\n                tval = n1_multi * (n1_plus + n2_plus) * n2_multi\\n                if tval < min_val:\\n                    min_val = tval\\n                    min_i = i\\n                    min_j = j\\n        return \"+\".join([nums[0][0:min_i] + \\'(\\' + nums[0][min_i:len_n1], nums[1][0:min_j] + \\')\\' + nums[1][min_j:len_n2]])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919254,
                "title": "easy-java-solution-beat-100-speed-97-40-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBruce force + dynamic programming\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public static String minimizeResult(String expression) {\\n        //247+38\\n        //\\n        int indexPlus=0;\\n        int n=expression.length();\\n\\n        for(int i=0;i<n;i++){\\n            if(expression.charAt(i)==\\'+\\'){\\n                indexPlus=i;\\n            }\\n        }\\n        int[] firstNumberLeft=new int[indexPlus];\\n        int[] firstNumberRight=new int[indexPlus];\\n        int[] secondNumberLeft=new int[n];\\n        int[] secondNumberRight=new int[n];\\n        int currentNumberLeft=0;\\n        int countLeft=1;\\n        int currentNumberRight=0;\\n\\n        for(int i=indexPlus-1;i>=0;i--){\\n            currentNumberLeft= (expression.charAt(i)-\\'0\\')*countLeft + currentNumberLeft;\\n            countLeft=countLeft*10;\\n            firstNumberLeft[i]=currentNumberLeft;\\n            currentNumberRight=expression.charAt(indexPlus-i-1) -\\'0\\'+currentNumberRight*10;\\n            firstNumberRight[indexPlus-i-1]=currentNumberRight;\\n        }\\n        currentNumberLeft=0;\\n        countLeft=1;\\n        currentNumberRight=0;\\n        for(int i=indexPlus+1;i<n;i++){\\n            currentNumberLeft=(expression.charAt(i)-\\'0\\') + currentNumberLeft*10;\\n            secondNumberLeft[i]=currentNumberLeft;\\n            currentNumberRight=(expression.charAt(n-(i-indexPlus-1)-1)-\\'0\\')*countLeft + currentNumberRight;\\n            countLeft=countLeft*10;\\n            secondNumberRight[n-(i-indexPlus-1)-1]=currentNumberRight;\\n        }\\n\\n        int rs=Integer.MAX_VALUE;\\n        int start=0;\\n        int end=0;\\n\\n        for(int i=indexPlus-1;i>=0;i--){\\n            int firstLeft=0;\\n            int firstRight=0;\\n\\n            if(i<indexPlus-1){\\n                //2 ,24 ,247\\n                firstLeft=firstNumberLeft[i+1];\\n            }\\n            //247 ,47 ,7\\n            firstRight=firstNumberRight[i];\\n            for(int j=indexPlus+1;j<n;j++){\\n                int secondLeft=0;\\n                int secondRight=0;\\n                int s = 0,t = 0;\\n\\n                //0 ,0 ,0 ,0 ,3 ,38\\n                secondLeft=secondNumberLeft[j];\\n                if(j<n-1){\\n                    //0 ,0 ,0 ,0 ,38 ,8\\n                    secondRight=secondNumberRight[j+1];\\n                }\\n                int value=0;\\n                //firstRight*(firstLeft + secondLeft)*secondRight\\n                if(firstLeft==0&&secondLeft==0){\\n                    value=firstLeft+secondRight;\\n                    s=i+1;\\n                    t=j+1;\\n                }else if(firstLeft==0&&secondLeft!=0){\\n                    if(secondRight!=0){\\n                        value=(firstRight + secondLeft)*secondRight;\\n                    }else{\\n                        value=firstRight + secondLeft;\\n                    }\\n                    s=i;\\n                    t=j;\\n                }else if(firstLeft!=0&&secondLeft==0){\\n                    if(firstRight!=0){\\n                        value=firstRight*(firstLeft + secondRight);\\n                    }else{\\n                        value=firstLeft + secondRight;\\n                    }\\n                    s=i+1;\\n                    t=j+1;\\n                }else if(firstLeft!=0&&secondLeft!=0){\\n                    if(secondRight!=0){\\n                        value=firstRight*(firstLeft + secondLeft)*secondRight;\\n                    }else {\\n                        value=firstRight*(firstLeft + secondLeft);\\n                    }\\n                    s=i+1;\\n                    t=j;\\n                }\\n                if(s==indexPlus-1&&i==indexPlus-1){\\n                    s=0;\\n                }\\n\\n                if(value<rs){\\n                    start=s;\\n                    end=t;\\n                    rs=value;\\n                }\\n            }\\n        }\\n\\n        StringBuilder rsS=new StringBuilder();\\n\\n        for(int i=0;i<n;i++){\\n            if(i==start){\\n                rsS.append(\"(\");\\n            }\\n            rsS.append(expression.charAt(i));\\n            if(i==end){\\n                rsS.append(\")\");\\n            }\\n        }\\n\\n        return rsS.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public static String minimizeResult(String expression) {\\n        //247+38\\n        //\\n        int indexPlus=0;\\n        int n=expression.length();\\n\\n        for(int i=0;i<n;i++){\\n            if(expression.charAt(i)==\\'+\\'){\\n                indexPlus=i;\\n            }\\n        }\\n        int[] firstNumberLeft=new int[indexPlus];\\n        int[] firstNumberRight=new int[indexPlus];\\n        int[] secondNumberLeft=new int[n];\\n        int[] secondNumberRight=new int[n];\\n        int currentNumberLeft=0;\\n        int countLeft=1;\\n        int currentNumberRight=0;\\n\\n        for(int i=indexPlus-1;i>=0;i--){\\n            currentNumberLeft= (expression.charAt(i)-\\'0\\')*countLeft + currentNumberLeft;\\n            countLeft=countLeft*10;\\n            firstNumberLeft[i]=currentNumberLeft;\\n            currentNumberRight=expression.charAt(indexPlus-i-1) -\\'0\\'+currentNumberRight*10;\\n            firstNumberRight[indexPlus-i-1]=currentNumberRight;\\n        }\\n        currentNumberLeft=0;\\n        countLeft=1;\\n        currentNumberRight=0;\\n        for(int i=indexPlus+1;i<n;i++){\\n            currentNumberLeft=(expression.charAt(i)-\\'0\\') + currentNumberLeft*10;\\n            secondNumberLeft[i]=currentNumberLeft;\\n            currentNumberRight=(expression.charAt(n-(i-indexPlus-1)-1)-\\'0\\')*countLeft + currentNumberRight;\\n            countLeft=countLeft*10;\\n            secondNumberRight[n-(i-indexPlus-1)-1]=currentNumberRight;\\n        }\\n\\n        int rs=Integer.MAX_VALUE;\\n        int start=0;\\n        int end=0;\\n\\n        for(int i=indexPlus-1;i>=0;i--){\\n            int firstLeft=0;\\n            int firstRight=0;\\n\\n            if(i<indexPlus-1){\\n                //2 ,24 ,247\\n                firstLeft=firstNumberLeft[i+1];\\n            }\\n            //247 ,47 ,7\\n            firstRight=firstNumberRight[i];\\n            for(int j=indexPlus+1;j<n;j++){\\n                int secondLeft=0;\\n                int secondRight=0;\\n                int s = 0,t = 0;\\n\\n                //0 ,0 ,0 ,0 ,3 ,38\\n                secondLeft=secondNumberLeft[j];\\n                if(j<n-1){\\n                    //0 ,0 ,0 ,0 ,38 ,8\\n                    secondRight=secondNumberRight[j+1];\\n                }\\n                int value=0;\\n                //firstRight*(firstLeft + secondLeft)*secondRight\\n                if(firstLeft==0&&secondLeft==0){\\n                    value=firstLeft+secondRight;\\n                    s=i+1;\\n                    t=j+1;\\n                }else if(firstLeft==0&&secondLeft!=0){\\n                    if(secondRight!=0){\\n                        value=(firstRight + secondLeft)*secondRight;\\n                    }else{\\n                        value=firstRight + secondLeft;\\n                    }\\n                    s=i;\\n                    t=j;\\n                }else if(firstLeft!=0&&secondLeft==0){\\n                    if(firstRight!=0){\\n                        value=firstRight*(firstLeft + secondRight);\\n                    }else{\\n                        value=firstLeft + secondRight;\\n                    }\\n                    s=i+1;\\n                    t=j+1;\\n                }else if(firstLeft!=0&&secondLeft!=0){\\n                    if(secondRight!=0){\\n                        value=firstRight*(firstLeft + secondLeft)*secondRight;\\n                    }else {\\n                        value=firstRight*(firstLeft + secondLeft);\\n                    }\\n                    s=i+1;\\n                    t=j;\\n                }\\n                if(s==indexPlus-1&&i==indexPlus-1){\\n                    s=0;\\n                }\\n\\n                if(value<rs){\\n                    start=s;\\n                    end=t;\\n                    rs=value;\\n                }\\n            }\\n        }\\n\\n        StringBuilder rsS=new StringBuilder();\\n\\n        for(int i=0;i<n;i++){\\n            if(i==start){\\n                rsS.append(\"(\");\\n            }\\n            rsS.append(expression.charAt(i));\\n            if(i==end){\\n                rsS.append(\")\");\\n            }\\n        }\\n\\n        return rsS.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868116,
                "title": "dfs-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string expression) {\\n        int p = expression.find(\\'+\\');\\n        string s1 = expression.substr(0, p);\\n        string s2 = expression.substr(p + 1);\\n        string ans = \"\";\\n        int largest = INT_MAX;\\n        unordered_set<string> visited;\\n        dfs(s1, s2, s1.size() - 1, 1, ans, largest, visited);\\n        return ans;\\n    }\\n    void dfs(string& s1, string& s2, int l, int r, string& ans, int& largest,\\n            unordered_set<string>& visited){\\n        string key = to_string(l) + \" \" + to_string(r);\\n        if (visited.find(key) != visited.end()) return;\\n        visited.insert(key);\\n        // make sure they are valid\\n        string lMultiplier = s1.substr(0, l);\\n        string mAddL = s1.substr(l);\\n        string mAddR = s2.substr(0, r);\\n        string rMultiplier = s2.substr(r);\\n        long lM = lMultiplier.empty() ? 1 : stol(lMultiplier);\\n        long mA = stol(mAddL) + stol(mAddR);\\n        long rM = rMultiplier.empty() ? 1 : stol(rMultiplier);\\n        long summation = lM * mA * rM;\\n        if (summation < largest){\\n            largest = summation;\\n            ans = lMultiplier + \\'(\\' + mAddL + \"+\" + mAddR + \\')\\' + rMultiplier;\\n        }\\n        if (!lMultiplier.empty()) dfs(s1, s2, l - 1, r, ans, largest, visited);\\n        if (!rMultiplier.empty()) dfs(s1, s2, l, r + 1, ans, largest, visited);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string expression) {\\n        int p = expression.find(\\'+\\');\\n        string s1 = expression.substr(0, p);\\n        string s2 = expression.substr(p + 1);\\n        string ans = \"\";\\n        int largest = INT_MAX;\\n        unordered_set<string> visited;\\n        dfs(s1, s2, s1.size() - 1, 1, ans, largest, visited);\\n        return ans;\\n    }\\n    void dfs(string& s1, string& s2, int l, int r, string& ans, int& largest,\\n            unordered_set<string>& visited){\\n        string key = to_string(l) + \" \" + to_string(r);\\n        if (visited.find(key) != visited.end()) return;\\n        visited.insert(key);\\n        // make sure they are valid\\n        string lMultiplier = s1.substr(0, l);\\n        string mAddL = s1.substr(l);\\n        string mAddR = s2.substr(0, r);\\n        string rMultiplier = s2.substr(r);\\n        long lM = lMultiplier.empty() ? 1 : stol(lMultiplier);\\n        long mA = stol(mAddL) + stol(mAddR);\\n        long rM = rMultiplier.empty() ? 1 : stol(rMultiplier);\\n        long summation = lM * mA * rM;\\n        if (summation < largest){\\n            largest = summation;\\n            ans = lMultiplier + \\'(\\' + mAddL + \"+\" + mAddR + \\')\\' + rMultiplier;\\n        }\\n        if (!lMultiplier.empty()) dfs(s1, s2, l - 1, r, ans, largest, visited);\\n        if (!rMultiplier.empty()) dfs(s1, s2, l, r + 1, ans, largest, visited);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859093,
                "title": "c-solution-runtime-0ms-beats-100",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    string minimizeResult(string expression) \\n    {\\n        int plus=expression.find(\"+\");\\n        int n=expression.size();\\n        string ansStr=\"\";\\n        int ans=INT_MAX;\\n        for(int b1=0; b1<=plus-1; b1++)\\n        {\\n            for(int b2=plus+2; b2<=n; b2++)  \\n            {\\n                int a=0, b=0;\\n                if(b1!=0) a=stoi(expression.substr(0,b1)); \\n                if(b2!=n) b=stoi(expression.substr(b2)); \\n                int c=stoi(expression.substr(b1,plus-b1)); \\n                int d=stoi(expression.substr(plus+1,b2-plus-1)); \\n                int eval=c+d;\\n                if(a!=0) eval*=a;\\n                if(b!=0) eval*=b;\\n                if(ans>eval)\\n                {\\n                    ans=eval;\\n                    ansStr=\"(\"+to_string(c)+\"+\"+to_string(d)+\")\";\\n                    if(a!=0) ansStr=to_string(a)+ansStr;\\n                    if(b!=0) ansStr+=to_string(b);\\n                }\\n            }\\n        }\\n        return ansStr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string minimizeResult(string expression) \\n    {\\n        int plus=expression.find(\"+\");\\n        int n=expression.size();\\n        string ansStr=\"\";\\n        int ans=INT_MAX;\\n        for(int b1=0; b1<=plus-1; b1++)\\n        {\\n            for(int b2=plus+2; b2<=n; b2++)  \\n            {\\n                int a=0, b=0;\\n                if(b1!=0) a=stoi(expression.substr(0,b1)); \\n                if(b2!=n) b=stoi(expression.substr(b2)); \\n                int c=stoi(expression.substr(b1,plus-b1)); \\n                int d=stoi(expression.substr(plus+1,b2-plus-1)); \\n                int eval=c+d;\\n                if(a!=0) eval*=a;\\n                if(b!=0) eval*=b;\\n                if(ans>eval)\\n                {\\n                    ans=eval;\\n                    ansStr=\"(\"+to_string(c)+\"+\"+to_string(d)+\")\";\\n                    if(a!=0) ansStr=to_string(a)+ansStr;\\n                    if(b!=0) ansStr+=to_string(b);\\n                }\\n            }\\n        }\\n        return ansStr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811100,
                "title": "java-o-mn-intuition-and-approach-provided",
                "content": "# Intuition and Approach\\nSplit the given expression into left number and right number. Further split the left number into left multiplier and left adder and right number into right adder and right multiplier. Add the left adder and the right adder and multiply the result with left multiplier and right multiplier.\\nSee if the resulting number is the smallest possible and if so, create the expression:\\nleftMultiplier + \"(\" + leftAdder + \"+\" + rightAdder + \")\" + rightMultiplier\\n\\n# Complexity\\n- Time complexity:\\nO(mn) where m is the length of left number and n is the length of right number\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public String minimizeResult(String expression) {\\n        String[] nums = expression.split(\"\\\\\\\\+\");\\n        String numOnLeft = nums[0];\\n        String numOnRight = nums[1];\\n        int n = numOnLeft.length();\\n        int m = numOnRight.length();\\n        int min = Integer.MAX_VALUE;\\n        String minExpression = \"\";\\n        for (int i = 0; i < n; i++) {\\n            String leftMultiplier = numOnLeft.substring(0, i);\\n            String leftAdder = numOnLeft.substring(i);\\n            int lm = leftMultiplier.length() == 0? 1 : Integer.parseInt(leftMultiplier);\\n            int la = Integer.parseInt(leftAdder);\\n            for (int j = 1; j <= m; j++) {\\n                String rightMultiplier = numOnRight.substring(j);\\n                String rightAdder = numOnRight.substring(0, j);\\n                int rm = rightMultiplier.length() == 0? 1 : Integer.parseInt(rightMultiplier);\\n                int ra = Integer.parseInt(rightAdder);\\n                int result = (la + ra) * lm * rm;\\n                if (result < min) {\\n                    min = result;\\n                    minExpression = leftMultiplier + \"(\" + leftAdder + \"+\" + rightAdder + \")\" + rightMultiplier;\\n                }\\n            }\\n        }\\n        return minExpression;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public String minimizeResult(String expression) {\\n        String[] nums = expression.split(\"\\\\\\\\+\");\\n        String numOnLeft = nums[0];\\n        String numOnRight = nums[1];\\n        int n = numOnLeft.length();\\n        int m = numOnRight.length();\\n        int min = Integer.MAX_VALUE;\\n        String minExpression = \"\";\\n        for (int i = 0; i < n; i++) {\\n            String leftMultiplier = numOnLeft.substring(0, i);\\n            String leftAdder = numOnLeft.substring(i);\\n            int lm = leftMultiplier.length() == 0? 1 : Integer.parseInt(leftMultiplier);\\n            int la = Integer.parseInt(leftAdder);\\n            for (int j = 1; j <= m; j++) {\\n                String rightMultiplier = numOnRight.substring(j);\\n                String rightAdder = numOnRight.substring(0, j);\\n                int rm = rightMultiplier.length() == 0? 1 : Integer.parseInt(rightMultiplier);\\n                int ra = Integer.parseInt(rightAdder);\\n                int result = (la + ra) * lm * rm;\\n                if (result < min) {\\n                    min = result;\\n                    minExpression = leftMultiplier + \"(\" + leftAdder + \"+\" + rightAdder + \")\" + rightMultiplier;\\n                }\\n            }\\n        }\\n        return minExpression;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808647,
                "title": "python-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        nums = expression.split(\\'+\\')\\n        m, n = len(nums[0]), len(nums[1])\\n        min_val = math.inf\\n        for i in range(m):\\n            for j in range(1, n+1):\\n                left = int(nums[0][:m-1-i]) if m-1-i > 0 else 1\\n                right = int(nums[1][j:]) if j < n else 1\\n                val = (int(nums[0][m-1-i:]) + int(nums[1][:j])) * left * right\\n                if val < min_val:\\n                    res = nums[0][:m-1-i] + \\'(\\' + nums[0][m-1-i:] + \\'+\\' + nums[1][:j] + \\')\\' + nums[1][j:]\\n                    min_val = val\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        nums = expression.split(\\'+\\')\\n        m, n = len(nums[0]), len(nums[1])\\n        min_val = math.inf\\n        for i in range(m):\\n            for j in range(1, n+1):\\n                left = int(nums[0][:m-1-i]) if m-1-i > 0 else 1\\n                right = int(nums[1][j:]) if j < n else 1\\n                val = (int(nums[0][m-1-i:]) + int(nums[1][:j])) * left * right\\n                if val < min_val:\\n                    res = nums[0][:m-1-i] + \\'(\\' + nums[0][m-1-i:] + \\'+\\' + nums[1][:j] + \\')\\' + nums[1][j:]\\n                    min_val = val\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805247,
                "title": "python-straightforward-beats-70",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force - two for loops\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTry all combinations in two for loops\\n# Complexity\\n- Time complexity: O(n^2) if n is the length of each number in the expression\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        [num1, num2] = expression.split(\\'+\\')\\n        min_exp, min_val = \\'\\', float(\\'inf\\')\\n        for i in range(len(num1)):\\n            for j in range(1,len(num2)+1):\\n                new_exp = num1[:i] + \\'(\\' + num1[i:] + \\'+\\' + num2[:j] + \\')\\' + num2[j:] \\n                new_val = 1\\n                if len(num1[:i])>0:\\n                    new_val = int(num1[:i])\\n                new_val = new_val * (int(num1[i:]) + int(num2[:j]))\\n                if len(num2[j:])>0:\\n                    new_val = new_val * int(num2[j:])\\n                if new_val < min_val:\\n                    min_val = new_val\\n                    min_exp = new_exp\\n        return min_exp\\n```\\n\\n# Question\\nIs there any huristic to prune some cases and optimize the time?",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        [num1, num2] = expression.split(\\'+\\')\\n        min_exp, min_val = \\'\\', float(\\'inf\\')\\n        for i in range(len(num1)):\\n            for j in range(1,len(num2)+1):\\n                new_exp = num1[:i] + \\'(\\' + num1[i:] + \\'+\\' + num2[:j] + \\')\\' + num2[j:] \\n                new_val = 1\\n                if len(num1[:i])>0:\\n                    new_val = int(num1[:i])\\n                new_val = new_val * (int(num1[i:]) + int(num2[:j]))\\n                if len(num2[j:])>0:\\n                    new_val = new_val * int(num2[j:])\\n                if new_val < min_val:\\n                    min_val = new_val\\n                    min_exp = new_exp\\n        return min_exp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791337,
                "title": "very-simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nA simple brute force and careful handling of the edge cases should do the trick.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nSince we know the brackets are on either side of the plus sign, we can have a nested forlopp with the first loop tracking all the first bracket indices, and the second bracket tracking all the second indices. \\n\\nKeep in mind that we need to make sure we have one number atleast on either side of the plus sign between the brackets.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n^2)$$ for a double for loop\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n)$$ to store the answer.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        plusIndex = expression.find(\"+\")\\n\\n        mn = int(expression[0:plusIndex]) + int(expression[plusIndex + 1:])\\n        ans  = \"(\" + expression + \")\"\\n\\n        for leftIndex in range(0, plusIndex):\\n            for rightIndex in range(plusIndex + 1, len(expression)):\\n                midVal = int(expression[leftIndex: plusIndex]) + int(expression[plusIndex + 1: rightIndex + 1])\\n                leftVal = int(expression[0: leftIndex]) if leftIndex > 0 else 1\\n                rightVal = int(expression[rightIndex+1:]) if rightIndex + 1 < len(expression) else 1\\n                if leftVal * midVal * rightVal < mn:\\n                    mn = leftVal * midVal * rightVal\\n                    ans = expression[0:leftIndex] + \"(\" + expression[leftIndex: rightIndex + 1] + \")\" + expression[rightIndex+1: ]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        plusIndex = expression.find(\"+\")\\n\\n        mn = int(expression[0:plusIndex]) + int(expression[plusIndex + 1:])\\n        ans  = \"(\" + expression + \")\"\\n\\n        for leftIndex in range(0, plusIndex):\\n            for rightIndex in range(plusIndex + 1, len(expression)):\\n                midVal = int(expression[leftIndex: plusIndex]) + int(expression[plusIndex + 1: rightIndex + 1])\\n                leftVal = int(expression[0: leftIndex]) if leftIndex > 0 else 1\\n                rightVal = int(expression[rightIndex+1:]) if rightIndex + 1 < len(expression) else 1\\n                if leftVal * midVal * rightVal < mn:\\n                    mn = leftVal * midVal * rightVal\\n                    ans = expression[0:leftIndex] + \"(\" + expression[leftIndex: rightIndex + 1] + \")\" + expression[rightIndex+1: ]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790962,
                "title": "c-solution-using-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int toInt(string s)\\n    {\\n        if (s == \"\")\\n            return 1;\\n        return stoi(s);\\n    }\\n    \\n    string minimizeResult(string expression) \\n    {\\n        int index = 0;\\n        int n = expression.size();\\n        while (index < n)\\n            if (expression[index] == \\'+\\')\\n                break;\\n            else\\n                index++;\\n\\t\\t// so far, we\\'ve found the position of the add sign in this string\\n        int val = INT_MAX;\\n        int lIndex;\\n        int rIndex;\\n\\t\\t// we split this string into four parts [0, lIndex), [lIndex, index), (index, rIndex], (rIndex, n)\\n        for (int i = 0; i < index; i++)\\n            for (int j = index + 1; j < n; j++)\\n            {\\n\\t\\t\\t   // multi1 and multi2 can be empty string so we can use self-defined\\n               // function * toInt* to transfer a string to an int(1 in the case of \"\")\\nint multi1 = toInt(expression.substr(0, i));\\n                int add1 = toInt(expression.substr(i, index - i));\\n                int add2 = toInt(expression.substr(index + 1, j - index));\\n                int multi2 = toInt(expression.substr(j + 1, n - j - 1));\\n                int v = multi1 * (add1 + add2) * multi2;\\n                if (v < val)\\n                {\\n                    val = v;\\n                    lIndex = i;\\n                    rIndex = j;\\n                }\\n            }\\n        // note the position to be inserted\\n\\t\\t// we first insert \\'(\\' so the position for \\')\\' should be added by 1\\n        expression.insert(lIndex, \"(\");\\n        expression.insert(rIndex + 2, \")\");\\n        return expression;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int toInt(string s)\\n    {\\n        if (s == \"\")\\n            return 1;\\n        return stoi(s);\\n    }\\n    \\n    string minimizeResult(string expression) \\n    {\\n        int index = 0;\\n        int n = expression.size();\\n        while (index < n)\\n            if (expression[index] == \\'+\\')\\n                break;\\n            else\\n                index++;\\n\\t\\t// so far, we\\'ve found the position of the add sign in this string\\n        int val = INT_MAX;\\n        int lIndex;\\n        int rIndex;\\n\\t\\t// we split this string into four parts [0, lIndex), [lIndex, index), (index, rIndex], (rIndex, n)\\n        for (int i = 0; i < index; i++)\\n            for (int j = index + 1; j < n; j++)\\n            {\\n\\t\\t\\t   // multi1 and multi2 can be empty string so we can use self-defined\\n               // function * toInt* to transfer a string to an int(1 in the case of \"\")\\nint multi1 = toInt(expression.substr(0, i));\\n                int add1 = toInt(expression.substr(i, index - i));\\n                int add2 = toInt(expression.substr(index + 1, j - index));\\n                int multi2 = toInt(expression.substr(j + 1, n - j - 1));\\n                int v = multi1 * (add1 + add2) * multi2;\\n                if (v < val)\\n                {\\n                    val = v;\\n                    lIndex = i;\\n                    rIndex = j;\\n                }\\n            }\\n        // note the position to be inserted\\n\\t\\t// we first insert \\'(\\' so the position for \\')\\' should be added by 1\\n        expression.insert(lIndex, \"(\");\\n        expression.insert(rIndex + 2, \")\");\\n        return expression;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756100,
                "title": "c-exhaustive-recursion-time-o-n-2-n-space-o-n",
                "content": "# Intuition\\nGiven `n` <= 10.\\nCan apply (brute force) Exhaustive Recursion.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTry out all the valid mathematical expression by moving parentheses on the left `l` and right `r` respectively.\\nDuring the recursion, we evaluates the value of the current expression. And to update the pair of `result = { l, r }` once we find any smaller value when parentheses are at `l` and `r`.\\n\\nHere is the starting point.\\n![\\u672A\\u547D\\u540D\\u7684\\u767D\\u677F.png](https://assets.leetcode.com/users/images/fdb66875-4551-4cc1-9f27-0fb864710db7_1667053339.3943624.png)\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n * 2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  string minimizeResult(string expression) {\\n    int n = expression.size(), plus_i = expression.find(\\'+\\');\\n    pair<int, int> result { 0, n };\\n    int curMin = INT_MAX;\\n    solve(expression, result, curMin, 0, n, plus_i, n);\\n    expression.insert(result.first, 1, \\'(\\');\\n    expression.insert(result.second + 1, 1, \\')\\');\\n    return expression;\\n  }\\n  \\nprivate:\\n   void solve(string& expr, pair<int, int>& result, int& curMin, int l, int r, int plus_i, int n) {\\n     if (l == plus_i or r == plus_i + 1)\\n       return;\\n     \\n     int curLeft = stoi(expr.substr(l, plus_i - l));\\n     int curRight = stoi(expr.substr(plus_i + 1, r - plus_i - 1));\\n     int multiLeft = l == 0 ? 1 : stoi(expr.substr(0, l));\\n     int multiRight = r == n ? 1 : stoi(expr.substr(r, n - r));\\n     int sum = multiLeft * (curLeft + curRight) * multiRight;\\n     if (sum < curMin) {\\n       curMin = sum;\\n       result = { l, r };\\n     }\\n     \\n     solve(expr, result, curMin, l+1, r, plus_i, n);\\n     solve(expr, result, curMin, l, r-1, plus_i, n);\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  string minimizeResult(string expression) {\\n    int n = expression.size(), plus_i = expression.find(\\'+\\');\\n    pair<int, int> result { 0, n };\\n    int curMin = INT_MAX;\\n    solve(expression, result, curMin, 0, n, plus_i, n);\\n    expression.insert(result.first, 1, \\'(\\');\\n    expression.insert(result.second + 1, 1, \\')\\');\\n    return expression;\\n  }\\n  \\nprivate:\\n   void solve(string& expr, pair<int, int>& result, int& curMin, int l, int r, int plus_i, int n) {\\n     if (l == plus_i or r == plus_i + 1)\\n       return;\\n     \\n     int curLeft = stoi(expr.substr(l, plus_i - l));\\n     int curRight = stoi(expr.substr(plus_i + 1, r - plus_i - 1));\\n     int multiLeft = l == 0 ? 1 : stoi(expr.substr(0, l));\\n     int multiRight = r == n ? 1 : stoi(expr.substr(r, n - r));\\n     int sum = multiLeft * (curLeft + curRight) * multiRight;\\n     if (sum < curMin) {\\n       curMin = sum;\\n       result = { l, r };\\n     }\\n     \\n     solve(expr, result, curMin, l+1, r, plus_i, n);\\n     solve(expr, result, curMin, l, r-1, plus_i, n);\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737194,
                "title": "java-center-expanding-algorithm-easy-solution",
                "content": "\\tpublic int evaluate(String exp){\\n        String l = exp.split(\"\\\\\\\\+\")[0];\\n        String r = exp.split(\"\\\\\\\\+\")[1];\\n        int left = Integer.parseInt(l);\\n        int right = Integer.parseInt(r);\\n        \\n        return left+right;\\n    }\\n    public String minimizeResult(String s) {\\n        int index = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == \\'+\\'){\\n                index = i;\\n                break;\\n            }\\n        }\\n        \\n        int i=index-1, j=index+1, min = Integer.MAX_VALUE;\\n        String result = \"\";\\n        while(i>=0){\\n            j = index+1;\\n            while(j<s.length()){\\n                String left = s.substring(0, i);\\n                String right = s.substring(j+1);\\n                \\n                int leftPart = left.length()>0? Integer.parseInt(s.substring(0, i)) : 1;\\n                int rightPart = right.length()>0? Integer.parseInt(right) : 1;\\n                \\n                String exp = s.substring(i,j+1);\\n                int midPart = evaluate(exp);\\n                int val = leftPart*midPart*rightPart;\\n                if(val < min){\\n                    result = left+\"(\"+exp+\")\"+right;\\n                    min = val;\\n                }\\n                j++;\\n            }\\n            i--;\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\tpublic int evaluate(String exp){\\n        String l = exp.split(\"\\\\\\\\+\")[0];\\n        String r = exp.split(\"\\\\\\\\+\")[1];\\n        int left = Integer.parseInt(l);\\n        int right = Integer.parseInt(r);\\n        \\n        return left+right;\\n    }\\n    public String minimizeResult(String s) {\\n        int index = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == \\'+\\'){\\n                index = i;\\n                break;\\n            }\\n        }\\n        \\n        int i=index-1, j=index+1, min = Integer.MAX_VALUE;\\n        String result = \"\";\\n        while(i>=0){\\n            j = index+1;\\n            while(j<s.length()){\\n                String left = s.substring(0, i);\\n                String right = s.substring(j+1);\\n                \\n                int leftPart = left.length()>0? Integer.parseInt(s.substring(0, i)) : 1;\\n                int rightPart = right.length()>0? Integer.parseInt(right) : 1;\\n                \\n                String exp = s.substring(i,j+1);\\n                int midPart = evaluate(exp);\\n                int val = leftPart*midPart*rightPart;\\n                if(val < min){\\n                    result = left+\"(\"+exp+\")\"+right;\\n                    min = val;\\n                }\\n                j++;\\n            }\\n            i--;\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2726811,
                "title": "easy-understanding-faster-solution",
                "content": "```\\nclass Solution {\\n     int utilfunc(int a,int b,int c,int d)\\n     {\\n        return a*(b+c)*d; \\n     }\\npublic:\\n    string minimizeResult(string expression) {\\n                \\n        string a = \"\";\\n        string b = \"\";\\n\\n       bool flag = true;\\n        for(auto it : expression)\\n        {\\n            if(it ==\\'+\\') \\n            {\\n                flag = false;\\n                continue;\\n            }\\n            if(flag) a += it;\\n            else b += it;\\n        }\\n        \\n        string ans = \"(\" + a + \"+\" + b + \")\";\\n        int val = stoi(a) + stoi(b);\\n        for(int i=0;i<a.length();i++)\\n        {\\n           for(int j=b.length();j>0;j--)\\n           {\\n               int a1 = i == 0 ? 1 :  stoi(a.substr(0,i));\\n               int b1 = stoi(a.substr(i));\\n               int c1 = stoi(b.substr(0,j));\\n               int d1 = j == b.length() ? 1 : stoi(b.substr(j));\\n    \\n               int cal = utilfunc(a1,b1,c1,d1);\\n               if(cal<val)\\n               {\\n                   val = cal;\\n                   ans = (i == 0 ? \"\" : to_string(a1)) + \"(\" + to_string(b1) + \"+\" + to_string(c1) + \")\" + (j == b.length() ? \"\" : to_string(d1));\\n                  \\n                   cout<<ans<<\" : \"<<val<<endl;\\n               }\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     int utilfunc(int a,int b,int c,int d)\\n     {\\n        return a*(b+c)*d; \\n     }\\npublic:\\n    string minimizeResult(string expression) {\\n                \\n        string a = \"\";\\n        string b = \"\";\\n\\n       bool flag = true;\\n        for(auto it : expression)\\n        {\\n            if(it ==\\'+\\') \\n            {\\n                flag = false;\\n                continue;\\n            }\\n            if(flag) a += it;\\n            else b += it;\\n        }\\n        \\n        string ans = \"(\" + a + \"+\" + b + \")\";\\n        int val = stoi(a) + stoi(b);\\n        for(int i=0;i<a.length();i++)\\n        {\\n           for(int j=b.length();j>0;j--)\\n           {\\n               int a1 = i == 0 ? 1 :  stoi(a.substr(0,i));\\n               int b1 = stoi(a.substr(i));\\n               int c1 = stoi(b.substr(0,j));\\n               int d1 = j == b.length() ? 1 : stoi(b.substr(j));\\n    \\n               int cal = utilfunc(a1,b1,c1,d1);\\n               if(cal<val)\\n               {\\n                   val = cal;\\n                   ans = (i == 0 ? \"\" : to_string(a1)) + \"(\" + to_string(b1) + \"+\" + to_string(c1) + \")\" + (j == b.length() ? \"\" : to_string(d1));\\n                  \\n                   cout<<ans<<\" : \"<<val<<endl;\\n               }\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2712586,
                "title": "java-100-faster-94-mem",
                "content": "```\\nclass Solution {\\n    String gExpression;\\n    int minValue;\\n    public String minimizeResult(String expression) {\\n        gExpression = expression;\\n        int midpointIdx = -1, idx1 = -1, idx2 = -1, pIdx1 = -1, pIdx2 = -1;\\n        minValue = Integer.MAX_VALUE;\\n        int left = 0, right = 0;\\n        for (int i = 0; i < expression.length(); i++) {\\n            char c = expression.charAt(i);\\n            if (c == \\'+\\') {\\n                midpointIdx = i;\\n                left = Integer.parseInt(expression.substring(0, i));\\n                right = Integer.parseInt(expression.substring(i + 1, expression.length()));\\n                minValue = left + right;\\n            }\\n        }\\n        int[] paren = {-1, -1};\\n        boolean[][] visited = new boolean[expression.length() + 1][expression.length() + 1];\\n        backtrack(midpointIdx, midpointIdx - 1, midpointIdx + 2, paren, visited);\\n        pIdx1 = paren[0];\\n        pIdx2 = paren[1];\\n        StringBuilder bldr = new StringBuilder();\\n        if (pIdx1 == -1) bldr.append(\\'(\\');\\n        for (int i = 0; i < expression.length(); i++) {\\n            char c = expression.charAt(i);\\n            if (i == pIdx1) bldr.append(\\'(\\');\\n            else if (i == pIdx2) bldr.append(\\')\\');\\n            bldr.append(c);\\n        }\\n        if (pIdx2 == expression.length()) bldr.append(\\')\\');\\n        else if (pIdx2 == -1) bldr.append(\\')\\');\\n        return bldr.toString();\\n    }\\n    \\n    public void backtrack(int i, int idx1, int idx2, int[] paren, boolean[][] visited) {\\n        if (visited[idx1][idx2]) return;\\n        visited[idx1][idx2] = true;\\n        int curr = Integer.parseInt(gExpression.substring(idx1, i)) + Integer.parseInt(gExpression.substring(i + 1, idx2));\\n        int left = idx1 == 0 ? 1 : Integer.parseInt(gExpression.substring(0, idx1));\\n        int right = idx2 == gExpression.length() ? 1 : Integer.parseInt(gExpression.substring(idx2, gExpression.length()));\\n        if (curr * left * right < minValue) {\\n            paren[0] = idx1;\\n            paren[1] = idx2;\\n            minValue = curr * left * right;\\n        }\\n        if (idx1 > 0) backtrack(i, idx1 - 1, idx2, paren, visited);\\n        if (idx2 < gExpression.length()) backtrack(i, idx1, idx2 + 1, paren, visited);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    String gExpression;\\n    int minValue;\\n    public String minimizeResult(String expression) {\\n        gExpression = expression;\\n        int midpointIdx = -1, idx1 = -1, idx2 = -1, pIdx1 = -1, pIdx2 = -1;\\n        minValue = Integer.MAX_VALUE;\\n        int left = 0, right = 0;\\n        for (int i = 0; i < expression.length(); i++) {\\n            char c = expression.charAt(i);\\n            if (c == \\'+\\') {\\n                midpointIdx = i;\\n                left = Integer.parseInt(expression.substring(0, i));\\n                right = Integer.parseInt(expression.substring(i + 1, expression.length()));\\n                minValue = left + right;\\n            }\\n        }\\n        int[] paren = {-1, -1};\\n        boolean[][] visited = new boolean[expression.length() + 1][expression.length() + 1];\\n        backtrack(midpointIdx, midpointIdx - 1, midpointIdx + 2, paren, visited);\\n        pIdx1 = paren[0];\\n        pIdx2 = paren[1];\\n        StringBuilder bldr = new StringBuilder();\\n        if (pIdx1 == -1) bldr.append(\\'(\\');\\n        for (int i = 0; i < expression.length(); i++) {\\n            char c = expression.charAt(i);\\n            if (i == pIdx1) bldr.append(\\'(\\');\\n            else if (i == pIdx2) bldr.append(\\')\\');\\n            bldr.append(c);\\n        }\\n        if (pIdx2 == expression.length()) bldr.append(\\')\\');\\n        else if (pIdx2 == -1) bldr.append(\\')\\');\\n        return bldr.toString();\\n    }\\n    \\n    public void backtrack(int i, int idx1, int idx2, int[] paren, boolean[][] visited) {\\n        if (visited[idx1][idx2]) return;\\n        visited[idx1][idx2] = true;\\n        int curr = Integer.parseInt(gExpression.substring(idx1, i)) + Integer.parseInt(gExpression.substring(i + 1, idx2));\\n        int left = idx1 == 0 ? 1 : Integer.parseInt(gExpression.substring(0, idx1));\\n        int right = idx2 == gExpression.length() ? 1 : Integer.parseInt(gExpression.substring(idx2, gExpression.length()));\\n        if (curr * left * right < minValue) {\\n            paren[0] = idx1;\\n            paren[1] = idx2;\\n            minValue = curr * left * right;\\n        }\\n        if (idx1 > 0) backtrack(i, idx1 - 1, idx2, paren, visited);\\n        if (idx2 < gExpression.length()) backtrack(i, idx1, idx2 + 1, paren, visited);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695588,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def minimizeResult(self, expression):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: str\\n        \"\"\"\\n        def add_from_string(test_str, left_index, right_index):\\n            add_exp = test_str[left_index+1:right_index+1]\\n            (exp1, exp2) = add_exp.split(\"+\")\\n            return (int(exp1) + int(exp2))\\n\\n        def mult_from_string(test_str, left_index, right_index, add_val):\\n            left_mult_val = test_str[:left_index]\\n            right_mult_val = test_str[right_index+2:]\\n            if len(left_mult_val) == 0:\\n                left_mult_val = 1\\n            if len(right_mult_val) == 0:\\n                right_mult_val = 1\\n            total = int(left_mult_val) * int(add_val) * int(right_mult_val)\\n            return total\\n\\n        plus_index = expression.index(\"+\") + 2\\n\\n        smallest_val = float(\\'inf\\')\\n        for left_index in range(plus_index-2):\\n            for right_index in range(plus_index,len(expression)+1):\\n                test_str = expression[:left_index] + \\'(\\' + expression[left_index:right_index] + \\')\\' + expression[right_index:]\\n                add_sum = add_from_string(test_str, left_index, right_index)        \\n                total = mult_from_string(test_str, left_index, right_index, add_sum)\\n                if total < smallest_val:\\n                    smallest_val = total\\n                    smallest_exp = test_str\\n        return(smallest_exp)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimizeResult(self, expression):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: str\\n        \"\"\"\\n        def add_from_string(test_str, left_index, right_index):\\n            add_exp = test_str[left_index+1:right_index+1]\\n            (exp1, exp2) = add_exp.split(\"+\")\\n            return (int(exp1) + int(exp2))\\n\\n        def mult_from_string(test_str, left_index, right_index, add_val):\\n            left_mult_val = test_str[:left_index]\\n            right_mult_val = test_str[right_index+2:]\\n            if len(left_mult_val) == 0:\\n                left_mult_val = 1\\n            if len(right_mult_val) == 0:\\n                right_mult_val = 1\\n            total = int(left_mult_val) * int(add_val) * int(right_mult_val)\\n            return total\\n\\n        plus_index = expression.index(\"+\") + 2\\n\\n        smallest_val = float(\\'inf\\')\\n        for left_index in range(plus_index-2):\\n            for right_index in range(plus_index,len(expression)+1):\\n                test_str = expression[:left_index] + \\'(\\' + expression[left_index:right_index] + \\')\\' + expression[right_index:]\\n                add_sum = add_from_string(test_str, left_index, right_index)        \\n                total = mult_from_string(test_str, left_index, right_index, add_sum)\\n                if total < smallest_val:\\n                    smallest_val = total\\n                    smallest_exp = test_str\\n        return(smallest_exp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692329,
                "title": "java-easy-to-understand",
                "content": "```\\npublic String minimizeResult(String expression) {\\n        int leftPos = -1;\\n        int rightPos = -1;\\n        int min = Integer.MAX_VALUE;\\n        \\n        int len = expression.length();\\n        int plusIndex = expression.indexOf(\"+\");\\n        // insert ( before i\\n        // insert ) after j\\n        for (int i = 0; i < plusIndex; i++) {\\n            for (int j = plusIndex + 1; j < len; j++) {\\n                int left = 1;\\n                int mid = 1;\\n                int right = 1;\\n                \\n                if (0 <= i - 1) {\\n                    left = Integer.valueOf(expression.substring(0, i)); // before i, exclude i\\n                }\\n                String s1 = expression.substring(i, plusIndex);\\n                String s2 = expression.substring(plusIndex + 1, j + 1); // after j, include j\\n                mid = evaluate(s1, s2);\\n                if (j + 1 <= len - 1) {\\n                    right = Integer.valueOf(expression.substring(j + 1, len));\\n                }\\n                \\n                int tmp = left * mid * right;\\n                if (tmp < min) {\\n                    min = tmp;\\n                    leftPos = i;\\n                    rightPos = j;\\n                }\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < len; i++) {\\n            char c = expression.charAt(i);\\n            if (i == leftPos) { // before\\n                sb.append(\"(\");\\n            } \\n            sb.append(c);\\n            if (i == rightPos) { // after\\n                sb.append(\")\");\\n            } \\n        }\\n        \\n        return sb.toString();\\n    }\\n    private int evaluate(String s1, String s2) {\\n        int value1 = Integer.valueOf(s1);\\n        int value2 = Integer.valueOf(s2);\\n        return value1 + value2;\\n    }\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String minimizeResult(String expression) {\\n        int leftPos = -1;\\n        int rightPos = -1;\\n        int min = Integer.MAX_VALUE;\\n        \\n        int len = expression.length();\\n        int plusIndex = expression.indexOf(\"+\");\\n        // insert ( before i\\n        // insert ) after j\\n        for (int i = 0; i < plusIndex; i++) {\\n            for (int j = plusIndex + 1; j < len; j++) {\\n                int left = 1;\\n                int mid = 1;\\n                int right = 1;\\n                \\n                if (0 <= i - 1) {\\n                    left = Integer.valueOf(expression.substring(0, i)); // before i, exclude i\\n                }\\n                String s1 = expression.substring(i, plusIndex);\\n                String s2 = expression.substring(plusIndex + 1, j + 1); // after j, include j\\n                mid = evaluate(s1, s2);\\n                if (j + 1 <= len - 1) {\\n                    right = Integer.valueOf(expression.substring(j + 1, len));\\n                }\\n                \\n                int tmp = left * mid * right;\\n                if (tmp < min) {\\n                    min = tmp;\\n                    leftPos = i;\\n                    rightPos = j;\\n                }\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < len; i++) {\\n            char c = expression.charAt(i);\\n            if (i == leftPos) { // before\\n                sb.append(\"(\");\\n            } \\n            sb.append(c);\\n            if (i == rightPos) { // after\\n                sb.append(\")\");\\n            } \\n        }\\n        \\n        return sb.toString();\\n    }\\n    private int evaluate(String s1, String s2) {\\n        int value1 = Integer.valueOf(s1);\\n        int value2 = Integer.valueOf(s2);\\n        return value1 + value2;\\n    }\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2670694,
                "title": "java-easy-understand-solution",
                "content": "# Intuition\\n```\\nexample:\\nxxx+yy \\nthere are 3 places to insert (, 2 places to insert ).\\nIt will convert to:\\n(xxx+y)y\\n(xxx+yy)\\nx(xx+y)y\\nx(xx+yy)\\nxx(x+y)y\\nxx(x+yy)\\nanother long example:\\n0123456789\\nxxxxx+yyyy\\nidx = indexOf(\\'+\\') = 5\\ninsert \\'(\\' at [0...4], insert \\')\\' at [7...10]\\ni from 0 to idx-1, j from idx + 2 to len\\nbuild the string, calculate the left, mid, right\\n```\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nO(n^3): two for loop, substring inside.\\n- Space complexity:\\nO(n): temp strings\\n\\n# Code\\n```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        int index = expression.indexOf(\\'+\\');\\n        long min = Long.MAX_VALUE;\\n        String res = null;\\n        for (int i = 0; i < index; i++) {\\n            for (int j = index + 2; j <= expression.length(); j++) {\\n                String left = expression.substring(0, i);\\n                String mid = expression.substring(i, j);\\n                String right = expression.substring(j);\\n                String cur = left + \"(\" + mid + \")\" + right;\\n\\n                String[] twoParts = mid.split(\"\\\\\\\\+\");\\n                long midNum = Long.parseLong(twoParts[0]) + Long.parseLong(twoParts[1]);\\n                long leftNum = left.equals(\"\") ? 1 : Long.parseLong(left);\\n                long rightNum = right.equals(\"\") ? 1 : Long.parseLong(right);\\n                long num = leftNum * midNum * rightNum;\\n                //System.out.println(cur + \":\" + num);\\n                if (num < min) {\\n                    min = num;\\n                    res = cur;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nexample:\\nxxx+yy \\nthere are 3 places to insert (, 2 places to insert ).\\nIt will convert to:\\n(xxx+y)y\\n(xxx+yy)\\nx(xx+y)y\\nx(xx+yy)\\nxx(x+y)y\\nxx(x+yy)\\nanother long example:\\n0123456789\\nxxxxx+yyyy\\nidx = indexOf(\\'+\\') = 5\\ninsert \\'(\\' at [0...4], insert \\')\\' at [7...10]\\ni from 0 to idx-1, j from idx + 2 to len\\nbuild the string, calculate the left, mid, right\\n```\n```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        int index = expression.indexOf(\\'+\\');\\n        long min = Long.MAX_VALUE;\\n        String res = null;\\n        for (int i = 0; i < index; i++) {\\n            for (int j = index + 2; j <= expression.length(); j++) {\\n                String left = expression.substring(0, i);\\n                String mid = expression.substring(i, j);\\n                String right = expression.substring(j);\\n                String cur = left + \"(\" + mid + \")\" + right;\\n\\n                String[] twoParts = mid.split(\"\\\\\\\\+\");\\n                long midNum = Long.parseLong(twoParts[0]) + Long.parseLong(twoParts[1]);\\n                long leftNum = left.equals(\"\") ? 1 : Long.parseLong(left);\\n                long rightNum = right.equals(\"\") ? 1 : Long.parseLong(right);\\n                long num = leftNum * midNum * rightNum;\\n                //System.out.println(cur + \":\" + num);\\n                if (num < min) {\\n                    min = num;\\n                    res = cur;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642476,
                "title": "simple-and-clean-solution-time-o-n-n-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string exp) {\\n        int p=0;\\n        for(int i=0;i<exp.size();i++){\\n            if(exp[i]==\\'+\\')\\n            {\\n                p=i;\\n                break;\\n            }\\n        }\\n        pair<int,int> ans={0,exp.size()-1};\\n        int mx=INT_MAX;\\n        for(int k=0;k<p;k++)\\n        {\\n            int j=p+1;\\n            while(j<exp.size())\\n            {\\n                int a=0;\\n                if(k!=0)\\n                {\\n                    a=stoi(exp.substr(0,k));\\n                }\\n                else a=1;\\n                int b=stoi(exp.substr(k,p-k));\\n                int c=stoi(exp.substr(p+1,j-p));\\n                \\n                int d=0;\\n                if(j==exp.size()-1)\\n                {\\n                    d=1;\\n                }\\n                else\\n                {\\n                    d=stoi(exp.substr(j+1,exp.size()-j-1));\\n                }\\n                int total=a*(b+c)*d;\\n                if(total<=mx)\\n                {\\n                    \\n                    ans.first=k;\\n                    ans.second=j;\\n                    mx=total;\\n                }\\n                j++;\\n            }\\n        }\\n        int k=0;\\n        string s;\\n        int i=0;\\n        for(i=0;i<=exp.size();i++)\\n        {\\n            if(i==ans.first)\\n            {\\n                s.push_back(\\'(\\');\\n            }\\n            if(i==ans.second+1)\\n            {\\n                s.push_back(\\')\\');\\n            }\\n            if(k!=exp.size())s.push_back(exp[k]);\\n            k++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string exp) {\\n        int p=0;\\n        for(int i=0;i<exp.size();i++){\\n            if(exp[i]==\\'+\\')\\n            {\\n                p=i;\\n                break;\\n            }\\n        }\\n        pair<int,int> ans={0,exp.size()-1};\\n        int mx=INT_MAX;\\n        for(int k=0;k<p;k++)\\n        {\\n            int j=p+1;\\n            while(j<exp.size())\\n            {\\n                int a=0;\\n                if(k!=0)\\n                {\\n                    a=stoi(exp.substr(0,k));\\n                }\\n                else a=1;\\n                int b=stoi(exp.substr(k,p-k));\\n                int c=stoi(exp.substr(p+1,j-p));\\n                \\n                int d=0;\\n                if(j==exp.size()-1)\\n                {\\n                    d=1;\\n                }\\n                else\\n                {\\n                    d=stoi(exp.substr(j+1,exp.size()-j-1));\\n                }\\n                int total=a*(b+c)*d;\\n                if(total<=mx)\\n                {\\n                    \\n                    ans.first=k;\\n                    ans.second=j;\\n                    mx=total;\\n                }\\n                j++;\\n            }\\n        }\\n        int k=0;\\n        string s;\\n        int i=0;\\n        for(i=0;i<=exp.size();i++)\\n        {\\n            if(i==ans.first)\\n            {\\n                s.push_back(\\'(\\');\\n            }\\n            if(i==ans.second+1)\\n            {\\n                s.push_back(\\')\\');\\n            }\\n            if(k!=exp.size())s.push_back(exp[k]);\\n            k++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597523,
                "title": "python-easy-to-understand-code",
                "content": "\\'\\'\\'\\n    def minimizeResult(self, expression: str) -> str:\\n\\n        expression = list(expression)\\n        \\n        # add brackets in various position\\n        pl = expression.index(\\'+\\')\\n        pl=pl+1 # left bracket\\n        \\n        m_val = math.inf\\n        m_ex = \\'\\'\\n        for lb in range(pl-1):\\n            for rb in range(pl+1,len(expression)+1):\\n                expression.insert(lb,\\'(\\')\\n                expression.insert(rb+1,\\')\\')\\n                \\n                outside = [expression[:lb],expression[rb+2:]]\\n                inside = [expression[lb+1:pl],expression[pl+1:rb+1]]\\n                #print(outside,inside)\\n                outnum = [int(\\'\\'.join(outside[i])) if len(outside[i])!=0 else 1 for i in range(0,2)]\\n                innum = [int(\\'\\'.join(inside[i])) if len(inside[i])!=0 else 0 for i in range(0,2)]\\n                #print(outnum,innum)\\n                val = sum(innum)*outnum[0]*outnum[1]\\n                if val<m_val:\\n                    m_val=val\\n                    m_ex = \\'\\'.join(expression)\\n                expression.remove(\\'(\\')\\n                expression.remove(\\')\\')\\n        return m_ex",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n    def minimizeResult(self, expression: str) -> str:\\n\\n        expression = list(expression)\\n        \\n        # add brackets in various position\\n        pl = expression.index(\\'+\\')\\n        pl=pl+1 # left bracket\\n        \\n        m_val = math.inf\\n        m_ex = \\'\\'\\n        for lb in range(pl-1):\\n            for rb in range(pl+1,len(expression)+1):\\n                expression.insert(lb,\\'(\\')\\n                expression.insert(rb+1,\\')\\')\\n                \\n                outside = [expression[:lb],expression[rb+2:]]\\n                inside = [expression[lb+1:pl],expression[pl+1:rb+1]]\\n                #print(outside,inside)\\n                outnum = [int(\\'\\'.join(outside[i])) if len(outside[i])!=0 else 1 for i in range(0,2)]\\n                innum = [int(\\'\\'.join(inside[i])) if len(inside[i])!=0 else 0 for i in range(0,2)]\\n                #print(outnum,innum)\\n                val = sum(innum)*outnum[0]*outnum[1]\\n                if val<m_val:\\n                    m_val=val\\n                    m_ex = \\'\\'.join(expression)\\n                expression.remove(\\'(\\')\\n                expression.remove(\\')\\')\\n        return m_ex",
                "codeTag": "Python3"
            },
            {
                "id": 2537418,
                "title": "python3-brute-force-faster-than-100",
                "content": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        num1, num2 = expression.split(\\'+\\');\\n        \\n        mini = int(num1) + int(num2);\\n        comb = [0,len(num2)-1];\\n        for l in range(len(num1)):\\n            left1 = 1 if l == 0 else int(num1[:l]);\\n            left2 = int(num1[l:]);\\n            for r in range(len(num2)):\\n                right1 = int(num2[:r+1]);\\n                right2 = 1 if r == len(num2)-1 else int(num2[r+1:]);\\n                cur = left1*(left2+right1)*right2\\n                if cur < mini:\\n                    mini = cur;\\n                    comb = [l,r];\\n        l,r = comb[0], comb[1]+1;\\n        return num1[:l]+\\'(\\'+num1[l:]+\\'+\\'+num2[:r]+\\')\\'+num2[r:] \\n                \\n\"\"\"\\n0   1   2           0   1\\n  2   4   7   +   3   8\\n\"\"\"",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        num1, num2 = expression.split(\\'+\\');\\n        \\n        mini = int(num1) + int(num2);\\n        comb = [0,len(num2)-1];\\n        for l in range(len(num1)):\\n            left1 = 1 if l == 0 else int(num1[:l]);\\n            left2 = int(num1[l:]);\\n            for r in range(len(num2)):\\n                right1 = int(num2[:r+1]);\\n                right2 = 1 if r == len(num2)-1 else int(num2[r+1:]);\\n                cur = left1*(left2+right1)*right2\\n                if cur < mini:\\n                    mini = cur;\\n                    comb = [l,r];\\n        l,r = comb[0], comb[1]+1;\\n        return num1[:l]+\\'(\\'+num1[l:]+\\'+\\'+num2[:r]+\\')\\'+num2[r:] \\n                \\n\"\"\"\\n0   1   2           0   1\\n  2   4   7   +   3   8\\n\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 2529808,
                "title": "bruteforce-approach",
                "content": "```\\nclass Solution {\\n    public String minimizeResult(String exp) {\\n         int add=exp.indexOf(\\'+\\');\\n        String left=exp.substring(0,add);\\n        String right=exp.substring(add+1,exp.length());\\n        int min=Integer.MAX_VALUE;\\n        String ans=\"\";\\n        for(int i=left.length()-1;i>=0;i--){\\n            int l1=1;\\n            int l2=Integer.parseInt(left.substring(i));\\n            if(i!=0)\\n             l1=Integer.parseInt(left.substring(0,i));\\n            for(int j=1;j<=right.length();j++){\\n                int r1=Integer.parseInt(right.substring(0,j));\\n                int r2=1;\\n                if(j!=right.length())\\n               r2=Integer.parseInt(right.substring(j));\\n                int eval=(l2+r1)*l1*r2;\\n                if(eval<=min){\\n                    min=eval;\\n                     if(i==0 && j==right.length()){\\n                         ans=\"(\"+exp+\")\";\\n                     }\\n                     else if(i==0){\\n                         ans=\"(\"+left+\"+\"+right.substring(0,j)+\")\"+right.substring(j);\\n                     }\\n                     else if(j==right.length()){\\n                         ans=left.substring(0,i)+\"(\"+left.substring(i)+\"+\"+right+\")\";\\n                     }\\n                     else{\\n                          ans=left.substring(0,i)+\"(\"+left.substring(i)+\"+\"+right.substring(0,j)+\")\"+right.substring(j);\\n                     }\\n                    min=eval;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String minimizeResult(String exp) {\\n         int add=exp.indexOf(\\'+\\');\\n        String left=exp.substring(0,add);\\n        String right=exp.substring(add+1,exp.length());\\n        int min=Integer.MAX_VALUE;\\n        String ans=\"\";\\n        for(int i=left.length()-1;i>=0;i--){\\n            int l1=1;\\n            int l2=Integer.parseInt(left.substring(i));\\n            if(i!=0)\\n             l1=Integer.parseInt(left.substring(0,i));\\n            for(int j=1;j<=right.length();j++){\\n                int r1=Integer.parseInt(right.substring(0,j));\\n                int r2=1;\\n                if(j!=right.length())\\n               r2=Integer.parseInt(right.substring(j));\\n                int eval=(l2+r1)*l1*r2;\\n                if(eval<=min){\\n                    min=eval;\\n                     if(i==0 && j==right.length()){\\n                         ans=\"(\"+exp+\")\";\\n                     }\\n                     else if(i==0){\\n                         ans=\"(\"+left+\"+\"+right.substring(0,j)+\")\"+right.substring(j);\\n                     }\\n                     else if(j==right.length()){\\n                         ans=left.substring(0,i)+\"(\"+left.substring(i)+\"+\"+right+\")\";\\n                     }\\n                     else{\\n                          ans=left.substring(0,i)+\"(\"+left.substring(i)+\"+\"+right.substring(0,j)+\")\"+right.substring(j);\\n                     }\\n                    min=eval;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2517124,
                "title": "c-simple-c-code",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int evaluation(string &m1, string &expression, string &m2)\\n    {\\n        int n = expression.size(), plus = -1;\\n        string val1 = \"\", val2 = \"\";\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(expression[i] == \\'+\\')\\n            {\\n                plus = i;\\n                continue;\\n            }\\n            if(plus == -1)\\n                val1 += expression[i];\\n            else\\n                val2 += expression[i];\\n        }\\n        // cout << m1 << \"-\" << m2 << endl;\\n        // cout << m1.size() << \" \" << m2.size() << endl;\\n        int val = stoi(val1) + stoi(val2);\\n        if(m1.size() > 0)\\n            val *= stoi(m1);\\n        if(m2.size() > 0)\\n            val *= stoi(m2);\\n        return val;\\n    }\\npublic:\\n    string minimizeResult(string expression) {\\n        string val1 = \"\", val2 =\"\";\\n        int plus = -1;\\n        for(int i = 0; i < expression.size(); i++)\\n        {\\n            if(expression[i] == \\'+\\')\\n            {\\n                plus = i;\\n                continue;\\n            }\\n            if(plus == -1)\\n                val1 += expression[i];\\n            else\\n                val2 += expression[i];\\n        }\\n        string ans = \\'(\\' + val1 + \\'+\\' + val2 + \\')\\';\\n        //cout << val1 << \" \" << val2;\\n        int val = stoi(val1) + stoi(val2);\\n        for(int i = 0; i < plus; i++)\\n        {\\n            for(int j = plus+1; j < expression.size(); j++)\\n            {\\n                string m1 = expression.substr(0,i);\\n                string v = expression.substr(i, (j-i+1));\\n                string m2 = expression.substr(j+1);\\n                string exp = m1 + \\'(\\' + v + \\')\\' + m2;\\n                // cout << expression.substr(0,i) << \" \" << expression.substr(i, (j-i+1)) << \" \" << expression.substr(j+1) << endl;\\n                \\n                int cal = evaluation(m1, v, m2);\\n                if(val > cal)\\n                {\\n                    val = cal;\\n                    ans = exp;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    int evaluation(string &m1, string &expression, string &m2)\\n    {\\n        int n = expression.size(), plus = -1;\\n        string val1 = \"\", val2 = \"\";\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(expression[i] == \\'+\\')\\n            {\\n                plus = i;\\n                continue;\\n            }\\n            if(plus == -1)\\n                val1 += expression[i];\\n            else\\n                val2 += expression[i];\\n        }\\n        // cout << m1 << \"-\" << m2 << endl;\\n        // cout << m1.size() << \" \" << m2.size() << endl;\\n        int val = stoi(val1) + stoi(val2);\\n        if(m1.size() > 0)\\n            val *= stoi(m1);\\n        if(m2.size() > 0)\\n            val *= stoi(m2);\\n        return val;\\n    }\\npublic:\\n    string minimizeResult(string expression) {\\n        string val1 = \"\", val2 =\"\";\\n        int plus = -1;\\n        for(int i = 0; i < expression.size(); i++)\\n        {\\n            if(expression[i] == \\'+\\')\\n            {\\n                plus = i;\\n                continue;\\n            }\\n            if(plus == -1)\\n                val1 += expression[i];\\n            else\\n                val2 += expression[i];\\n        }\\n        string ans = \\'(\\' + val1 + \\'+\\' + val2 + \\')\\';\\n        //cout << val1 << \" \" << val2;\\n        int val = stoi(val1) + stoi(val2);\\n        for(int i = 0; i < plus; i++)\\n        {\\n            for(int j = plus+1; j < expression.size(); j++)\\n            {\\n                string m1 = expression.substr(0,i);\\n                string v = expression.substr(i, (j-i+1));\\n                string m2 = expression.substr(j+1);\\n                string exp = m1 + \\'(\\' + v + \\')\\' + m2;\\n                // cout << expression.substr(0,i) << \" \" << expression.substr(i, (j-i+1)) << \" \" << expression.substr(j+1) << endl;\\n                \\n                int cal = evaluation(m1, v, m2);\\n                if(val > cal)\\n                {\\n                    val = cal;\\n                    ans = exp;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2485160,
                "title": "c-just-evaluate-all-possibilities",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int get_val(int &index, string &s) {\\n        int val = 0;\\n        \\n        while (index < s.size() && s[index] >= \\'0\\' && s[index] <= \\'9\\') {\\n            val = val * 10 + (s[index] - \\'0\\');\\n            index++;\\n        }\\n        \\n        index++;\\n        \\n        return val;\\n    }\\n    \\n    int evaluate(string s) {\\n        \\n        int index = 0;\\n        \\n        int a = get_val(index, s);\\n        \\n        int b = get_val(index, s);\\n        \\n        int c = get_val(index, s);\\n        \\n        int d = get_val(index, s);\\n        \\n        if (a == 0) {\\n            a = 1;\\n        }\\n        \\n        if (d == 0) {\\n            d = 1;\\n        }\\n        \\n        return a * (b + c) * d;\\n    }\\n    \\n    \\n    string minimizeResult(string s) {\\n        string ans = \"(\" + s + \")\";\\n        int min_val = evaluate(ans);\\n        \\n        int plus_index = s.find(\"+\");\\n        \\n        int size = s.size();\\n        \\n        for (int i = 0; i < plus_index; i++) {\\n            for (int j = plus_index + 1; j < size; j++) {\\n                string temp = s.substr(0, i) + \"(\" + s.substr(i, (j - i + 1)) + \")\" + s.substr(j + 1);\\n                int val = evaluate(temp);\\n\\n                if (val < min_val) {\\n                    min_val = val;\\n                    ans = temp;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int get_val(int &index, string &s) {\\n        int val = 0;\\n        \\n        while (index < s.size() && s[index] >= \\'0\\' && s[index] <= \\'9\\') {\\n            val = val * 10 + (s[index] - \\'0\\');\\n            index++;\\n        }\\n        \\n        index++;\\n        \\n        return val;\\n    }\\n    \\n    int evaluate(string s) {\\n        \\n        int index = 0;\\n        \\n        int a = get_val(index, s);\\n        \\n        int b = get_val(index, s);\\n        \\n        int c = get_val(index, s);\\n        \\n        int d = get_val(index, s);\\n        \\n        if (a == 0) {\\n            a = 1;\\n        }\\n        \\n        if (d == 0) {\\n            d = 1;\\n        }\\n        \\n        return a * (b + c) * d;\\n    }\\n    \\n    \\n    string minimizeResult(string s) {\\n        string ans = \"(\" + s + \")\";\\n        int min_val = evaluate(ans);\\n        \\n        int plus_index = s.find(\"+\");\\n        \\n        int size = s.size();\\n        \\n        for (int i = 0; i < plus_index; i++) {\\n            for (int j = plus_index + 1; j < size; j++) {\\n                string temp = s.substr(0, i) + \"(\" + s.substr(i, (j - i + 1)) + \")\" + s.substr(j + 1);\\n                int val = evaluate(temp);\\n\\n                if (val < min_val) {\\n                    min_val = val;\\n                    ans = temp;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472894,
                "title": "100-faster-java-solution",
                "content": "```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        int plusIndex = -1;\\n        int leftBracketIndex = -1;\\n        int rightBracketIndex = -1;\\n        int evaluation = Integer.MAX_VALUE;\\n        for(int i = 0;i<expression.length();i++){\\n            if(expression.charAt(i) == \\'+\\'){\\n                plusIndex = i;\\n                break;\\n            }\\n        }\\n        for(int i = 0;i<plusIndex;i++){\\n            for(int j = plusIndex+1;j<expression.length();j++){\\n                String n1Str = expression.substring(0, i);\\n                int n1 = 1;\\n                if(n1Str.length() > 0){\\n                    n1 = Integer.parseInt(n1Str);\\n                }\\n                \\n                String n2Str = expression.substring(i, plusIndex);\\n                int n2 = Integer.parseInt(n2Str);\\n                \\n                String n3Str = expression.substring(plusIndex+1, j+1);\\n                int n3 = Integer.parseInt(n3Str);\\n                \\n                String n4Str = expression.substring(j+1);\\n                int n4 = 1;\\n                if(n4Str.length() > 0){\\n                    n4 = Integer.parseInt(n4Str);\\n                }\\n                \\n                int currentValue = n1*(n2+n3)*n4;\\n                if(currentValue < evaluation){\\n                    evaluation = currentValue;\\n                    leftBracketIndex = i;\\n                    rightBracketIndex = j+1;\\n                }\\n            }          \\n        }\\n         StringBuilder sb = new StringBuilder();\\n            sb.append(expression.substring(0,leftBracketIndex));\\n            sb.append(\"(\");\\n            sb.append(expression.substring(leftBracketIndex, rightBracketIndex));\\n            sb.append(\")\");\\n            sb.append(expression.substring(rightBracketIndex));\\n            return sb.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        int plusIndex = -1;\\n        int leftBracketIndex = -1;\\n        int rightBracketIndex = -1;\\n        int evaluation = Integer.MAX_VALUE;\\n        for(int i = 0;i<expression.length();i++){\\n            if(expression.charAt(i) == \\'+\\'){\\n                plusIndex = i;\\n                break;\\n            }\\n        }\\n        for(int i = 0;i<plusIndex;i++){\\n            for(int j = plusIndex+1;j<expression.length();j++){\\n                String n1Str = expression.substring(0, i);\\n                int n1 = 1;\\n                if(n1Str.length() > 0){\\n                    n1 = Integer.parseInt(n1Str);\\n                }\\n                \\n                String n2Str = expression.substring(i, plusIndex);\\n                int n2 = Integer.parseInt(n2Str);\\n                \\n                String n3Str = expression.substring(plusIndex+1, j+1);\\n                int n3 = Integer.parseInt(n3Str);\\n                \\n                String n4Str = expression.substring(j+1);\\n                int n4 = 1;\\n                if(n4Str.length() > 0){\\n                    n4 = Integer.parseInt(n4Str);\\n                }\\n                \\n                int currentValue = n1*(n2+n3)*n4;\\n                if(currentValue < evaluation){\\n                    evaluation = currentValue;\\n                    leftBracketIndex = i;\\n                    rightBracketIndex = j+1;\\n                }\\n            }          \\n        }\\n         StringBuilder sb = new StringBuilder();\\n            sb.append(expression.substring(0,leftBracketIndex));\\n            sb.append(\"(\");\\n            sb.append(expression.substring(leftBracketIndex, rightBracketIndex));\\n            sb.append(\")\");\\n            sb.append(expression.substring(rightBracketIndex));\\n            return sb.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448596,
                "title": "100-faster-cpp",
                "content": "```\\n string minimizeResult(string expression) \\n    {\\n        int i=0;\\n        int n=expression.length();\\n        int j=n-1;\\n        \\n        vector<int> num1;\\n        while(expression[i]!=\\'+\\' && i<n)\\n        {\\n            num1.push_back(expression[i]-\\'0\\');\\n            i++;\\n        }\\n        i++;\\n        vector<int> num2;\\n       \\n        while(i<n)\\n        {\\n           num2.push_back(expression[i]-\\'0\\');\\n            i++;\\n        }\\n      //  num1=reverse(num1);\\n      //  num2=reverse(num2);\\n        \\n        \\n        \\n        n=num1.size();\\n        int m=num2.size();\\n        /*for(i=0; i<n; i++)\\n        {\\n             cout<<num1[i]<<\" \";\\n        } */\\n        \\n        i=0;\\n        int min_val=INT_MAX;\\n        int min_index=-1;\\n        int max_index=-1;\\n        while(i<n)\\n        {\\n            int x=0;\\n            int pre_x=0;\\n            int k;\\n            for(k=0; k<i; k++)\\n            {\\n                pre_x=pre_x*10+num1[k];\\n            }\\n            if(pre_x==0)\\n                pre_x=1;\\n            for(k=i; k<n; k++)\\n            {\\n                x=x*10+num1[k];\\n            }\\n            \\n           \\n             j=m;\\n            while(j>=0)\\n            {\\n                int y=0;\\n                int post_y=0;\\n                for(k=j; k<m; k++)\\n                {\\n                    post_y=post_y*10+num2[k];\\n                }\\n                if(post_y==0)\\n                    post_y=1;\\n                for(k=0; k<j; k++)\\n                {\\n                    y=y*10+num2[k];\\n                }\\n                \\n              \\n                int val=pre_x*(x+y)*post_y;\\n                if(min_val>val)\\n                {\\n                    min_val=val;\\n                    max_index=j;\\n                    min_index=i;\\n                }\\n                  j--;\\n            }\\n            \\n            i++;\\n        }\\n        \\n       // cout<<max_index<<\" \"<<min_index<<endl;\\n           // return to_string(min_val);\\n        \\n        string res=\"\";\\n        i=0;\\n        while(i<n)\\n        {\\n            if(res.length()==min_index)\\n                res.push_back(\\'(\\');\\n            \\n              res.push_back(num1[i]+\\'0\\');\\n            i++;\\n        }\\n        res.push_back(\\'+\\');\\n        string res1=\"\";\\n        i=0;\\n        while(i<m)\\n        {\\n            if(res1.length()==max_index && max_index!=0)\\n            {\\n                res1.push_back(\\')\\');\\n            }\\n            res1.push_back(num2[i]+\\'0\\');\\n            i++;\\n        }\\n        if(res1.length()==max_index || max_index==0)\\n            {\\n                res1.push_back(\\')\\');\\n            }\\n        return res+res1;\\n        \\n        \\n        \\n        \\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n string minimizeResult(string expression) \\n    {\\n        int i=0;\\n        int n=expression.length();\\n        int j=n-1;\\n        \\n        vector<int> num1;\\n        while(expression[i]!=\\'+\\' && i<n)\\n        {\\n            num1.push_back(expression[i]-\\'0\\');\\n            i++;\\n        }\\n        i++;\\n        vector<int> num2;\\n       \\n        while(i<n)\\n        {\\n           num2.push_back(expression[i]-\\'0\\');\\n            i++;\\n        }\\n      //  num1=reverse(num1);\\n      //  num2=reverse(num2);\\n        \\n        \\n        \\n        n=num1.size();\\n        int m=num2.size();\\n        /*for(i=0; i<n; i++)\\n        {\\n             cout<<num1[i]<<\" \";\\n        } */\\n        \\n        i=0;\\n        int min_val=INT_MAX;\\n        int min_index=-1;\\n        int max_index=-1;\\n        while(i<n)\\n        {\\n            int x=0;\\n            int pre_x=0;\\n            int k;\\n            for(k=0; k<i; k++)\\n            {\\n                pre_x=pre_x*10+num1[k];\\n            }\\n            if(pre_x==0)\\n                pre_x=1;\\n            for(k=i; k<n; k++)\\n            {\\n                x=x*10+num1[k];\\n            }\\n            \\n           \\n             j=m;\\n            while(j>=0)\\n            {\\n                int y=0;\\n                int post_y=0;\\n                for(k=j; k<m; k++)\\n                {\\n                    post_y=post_y*10+num2[k];\\n                }\\n                if(post_y==0)\\n                    post_y=1;\\n                for(k=0; k<j; k++)\\n                {\\n                    y=y*10+num2[k];\\n                }\\n                \\n              \\n                int val=pre_x*(x+y)*post_y;\\n                if(min_val>val)\\n                {\\n                    min_val=val;\\n                    max_index=j;\\n                    min_index=i;\\n                }\\n                  j--;\\n            }\\n            \\n            i++;\\n        }\\n        \\n       // cout<<max_index<<\" \"<<min_index<<endl;\\n           // return to_string(min_val);\\n        \\n        string res=\"\";\\n        i=0;\\n        while(i<n)\\n        {\\n            if(res.length()==min_index)\\n                res.push_back(\\'(\\');\\n            \\n              res.push_back(num1[i]+\\'0\\');\\n            i++;\\n        }\\n        res.push_back(\\'+\\');\\n        string res1=\"\";\\n        i=0;\\n        while(i<m)\\n        {\\n            if(res1.length()==max_index && max_index!=0)\\n            {\\n                res1.push_back(\\')\\');\\n            }\\n            res1.push_back(num2[i]+\\'0\\');\\n            i++;\\n        }\\n        if(res1.length()==max_index || max_index==0)\\n            {\\n                res1.push_back(\\')\\');\\n            }\\n        return res+res1;\\n        \\n        \\n        \\n        \\n        \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2431391,
                "title": "python-bfs-string-solution",
                "content": "```\\ndef minimizeResult(self, exp: str) -> str:\\n\\tidx = exp.index(\\'+\\')\\n\\tvisited = set([(idx-1, idx+1)])\\n\\tq = deque([(idx-1, idx+1)])\\n\\tans, ans_str = float(\\'inf\\'), None\\n\\twhile(q):\\n\\t\\ti, j = q.popleft()\\n\\t\\ts = (exp[:i] or \\'1\\')+\\'*(\\'+exp[i:j+1]+\\')*\\'+(exp[j+1:] or \\'1\\')\\n\\t\\tif eval(s)<ans:\\n\\t\\t\\tans = eval(s)\\n\\t\\t\\tans_str = exp[:i]+\\'(\\'+exp[i:j+1]+\\')\\'+exp[j+1:]\\n\\t\\tfor x, y in ((i-1, j), (i, j+1), (i-1, j+1)):\\n\\t\\t\\tif x>=0 and y<len(exp) and (x, y) not in visited:\\n\\t\\t\\t\\tq.append((x, y))\\n\\t\\t\\t\\tvisited.add((x, y))\\n\\treturn ans_str\\n```",
                "solutionTags": [],
                "code": "```\\ndef minimizeResult(self, exp: str) -> str:\\n\\tidx = exp.index(\\'+\\')\\n\\tvisited = set([(idx-1, idx+1)])\\n\\tq = deque([(idx-1, idx+1)])\\n\\tans, ans_str = float(\\'inf\\'), None\\n\\twhile(q):\\n\\t\\ti, j = q.popleft()\\n\\t\\ts = (exp[:i] or \\'1\\')+\\'*(\\'+exp[i:j+1]+\\')*\\'+(exp[j+1:] or \\'1\\')\\n\\t\\tif eval(s)<ans:\\n\\t\\t\\tans = eval(s)\\n\\t\\t\\tans_str = exp[:i]+\\'(\\'+exp[i:j+1]+\\')\\'+exp[j+1:]\\n\\t\\tfor x, y in ((i-1, j), (i, j+1), (i-1, j+1)):\\n\\t\\t\\tif x>=0 and y<len(exp) and (x, y) not in visited:\\n\\t\\t\\t\\tq.append((x, y))\\n\\t\\t\\t\\tvisited.add((x, y))\\n\\treturn ans_str\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2427062,
                "title": "python-using-string-only",
                "content": "```\\n    def minimizeResult(self, expression: str) -> str:\\n        num1, num2 = expression.split(\\'+\\')[0], expression.split(\\'+\\')[1]\\n        smallest = int(num1) + int(num2)\\n        small_l, small_r = 0, len(num2)\\n        for i in range(len(num1)):\\n            if i == 0:\\n                left_mult = 1\\n                left_sum = int(num1)\\n            else:\\n                left_mult = int(num1[:i])\\n                left_sum = int(num1[i:])\\n            for ii in range(1, len(num2) + 1):\\n                if ii == len(num2):\\n                    right_mult = 1\\n                    right_sum = int(num2)\\n                else:\\n                    right_mult = int(num2[ii:])\\n                    right_sum = int(num2[:ii])\\n                if left_mult * right_mult * (left_sum + right_sum) < smallest:\\n                    smallest = left_mult * right_mult * (left_sum + right_sum)\\n                    small_l, small_r = i, ii\\n        expression = num1[:small_l] + \\'(\\' + num1[small_l:] + \\'+\\' + num2[:small_r] + \\')\\' + num2[small_r:]\\n        return expression\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def minimizeResult(self, expression: str) -> str:\\n        num1, num2 = expression.split(\\'+\\')[0], expression.split(\\'+\\')[1]\\n        smallest = int(num1) + int(num2)\\n        small_l, small_r = 0, len(num2)\\n        for i in range(len(num1)):\\n            if i == 0:\\n                left_mult = 1\\n                left_sum = int(num1)\\n            else:\\n                left_mult = int(num1[:i])\\n                left_sum = int(num1[i:])\\n            for ii in range(1, len(num2) + 1):\\n                if ii == len(num2):\\n                    right_mult = 1\\n                    right_sum = int(num2)\\n                else:\\n                    right_mult = int(num2[ii:])\\n                    right_sum = int(num2[:ii])\\n                if left_mult * right_mult * (left_sum + right_sum) < smallest:\\n                    smallest = left_mult * right_mult * (left_sum + right_sum)\\n                    small_l, small_r = i, ii\\n        expression = num1[:small_l] + \\'(\\' + num1[small_l:] + \\'+\\' + num2[:small_r] + \\')\\' + num2[small_r:]\\n        return expression\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2404397,
                "title": "fast-and-easy-to-understand-python",
                "content": "```\\ndef minimizeResult(self, expression: str) -> str:\\n        def evaluate(exp):\\n            exp = exp.replace(\\')\\', \\'(\\')\\n            ll = exp.split(\\'(\\')\\n            if ll [0] == \\'\\':\\n                multiplier_1 = 1\\n            else:\\n                multiplier_1 = int(ll[0])\\n            \\n            if ll[2] == \\'\\':\\n                multiplier_2 = 1\\n            else:\\n                multiplier_2 = int(ll[2])\\n                \\n            ss = ll[1].split(\\'+\\')\\n            ssum = int(ss[0]) + int(ss[1])\\n            \\n            return multiplier_1*ssum*multiplier_2\\n        \\n        \\n        \\n        \\n        plus_index = expression.index(\\'+\\')\\n        minval = inf\\n        for i in range(plus_index):\\n            for j in range(plus_index+1, len(expression)):\\n                newexpression = expression[:i] + \\'(\\' + expression[i:j+1] + \\')\\' \\\\\\n                 + expression[j+1:]\\n                val = evaluate(newexpression)\\n                if val < minval:\\n                    minval = val\\n                    best = newexpression\\n                \\n        return best\\n",
                "solutionTags": [],
                "code": "```\\ndef minimizeResult(self, expression: str) -> str:\\n        def evaluate(exp):\\n            exp = exp.replace(\\')\\', \\'(\\')\\n            ll = exp.split(\\'(\\')\\n            if ll [0] == \\'\\':\\n                multiplier_1 = 1\\n            else:\\n                multiplier_1 = int(ll[0])\\n            \\n            if ll[2] == \\'\\':\\n                multiplier_2 = 1\\n            else:\\n                multiplier_2 = int(ll[2])\\n                \\n            ss = ll[1].split(\\'+\\')\\n            ssum = int(ss[0]) + int(ss[1])\\n            \\n            return multiplier_1*ssum*multiplier_2\\n        \\n        \\n        \\n        \\n        plus_index = expression.index(\\'+\\')\\n        minval = inf\\n        for i in range(plus_index):\\n            for j in range(plus_index+1, len(expression)):\\n                newexpression = expression[:i] + \\'(\\' + expression[i:j+1] + \\')\\' \\\\\\n                 + expression[j+1:]\\n                val = evaluate(newexpression)\\n                if val < minval:\\n                    minval = val\\n                    best = newexpression\\n                \\n        return best\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2393712,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int addition(string s){\\n        int leftpart=0,rightpart=0;\\n        int i=0;\\n        while(s[i]!=\\'(\\'){\\n            i++;\\n        }\\n        i++;\\n        while(s[i]!=\\'+\\'){\\n            leftpart=leftpart*10+(s[i]-\\'0\\');\\n            i++;\\n        }\\n        i++;\\n        while(s[i]!=\\')\\'){\\n            rightpart=rightpart*10+(s[i]-\\'0\\');\\n            i++;\\n        }\\n        \\n        return leftpart+rightpart;\\n    }\\n    int evaluate(string s){\\n        int before=0,after=0;\\n        int i=0;\\n        while(s[i]!=\\'(\\'){\\n            before=before*10+(s[i]-\\'0\\');\\n            i++;\\n        }\\n        i++;\\n        while(s[i]!=\\')\\'){\\n            i++;\\n        }\\n        i++;\\n        while(i!=s.length()){\\n            after=after*10+(s[i]-\\'0\\');\\n            i++;\\n        }\\n        if(before==0) before=1;\\n        if(after==0) after=1;\\n        // cout << addition(s);\\n        return before*(addition(s))*after;\\n        \\n    }\\n    \\n    string minimizeResult(string expression) {\\n        string ans,s,str,temp;\\n        int minimum=INT_MAX;\\n        int n=expression.find(\\'+\\');\\n        \\n        for(int i=0;i<n;i++){\\n            s=expression;\\n            s.insert(i,\"(\");\\n            for(int j=s.length();j>n+2;j--){  \\n                temp = s;\\n                str = temp;\\n                str=temp.insert(j,\")\");\\n                int k = evaluate(str);\\n                // cout << str << \" -> \" << k << endl;\\n                if(k<minimum){\\n                    ans=str;\\n                    minimum=k;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addition(string s){\\n        int leftpart=0,rightpart=0;\\n        int i=0;\\n        while(s[i]!=\\'(\\'){\\n            i++;\\n        }\\n        i++;\\n        while(s[i]!=\\'+\\'){\\n            leftpart=leftpart*10+(s[i]-\\'0\\');\\n            i++;\\n        }\\n        i++;\\n        while(s[i]!=\\')\\'){\\n            rightpart=rightpart*10+(s[i]-\\'0\\');\\n            i++;\\n        }\\n        \\n        return leftpart+rightpart;\\n    }\\n    int evaluate(string s){\\n        int before=0,after=0;\\n        int i=0;\\n        while(s[i]!=\\'(\\'){\\n            before=before*10+(s[i]-\\'0\\');\\n            i++;\\n        }\\n        i++;\\n        while(s[i]!=\\')\\'){\\n            i++;\\n        }\\n        i++;\\n        while(i!=s.length()){\\n            after=after*10+(s[i]-\\'0\\');\\n            i++;\\n        }\\n        if(before==0) before=1;\\n        if(after==0) after=1;\\n        // cout << addition(s);\\n        return before*(addition(s))*after;\\n        \\n    }\\n    \\n    string minimizeResult(string expression) {\\n        string ans,s,str,temp;\\n        int minimum=INT_MAX;\\n        int n=expression.find(\\'+\\');\\n        \\n        for(int i=0;i<n;i++){\\n            s=expression;\\n            s.insert(i,\"(\");\\n            for(int j=s.length();j>n+2;j--){  \\n                temp = s;\\n                str = temp;\\n                str=temp.insert(j,\")\");\\n                int k = evaluate(str);\\n                // cout << str << \" -> \" << k << endl;\\n                if(k<minimum){\\n                    ans=str;\\n                    minimum=k;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2369987,
                "title": "python-simple-brute-force-seems-to-be-working-notes",
                "content": "```\\n\"\"\"\\nwe can try solving this problem using brute force since maximum expression length\\ncan be of len 10\\n\"\"\"\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        num1, num2 = expression.split(\\'+\\')\\n        cand1, cand2 = [(\\'1\\', num1)], [(\\'1\\', num2)]\\n        for i in range(len(num1)-1):\\n            cand1.append((num1[:i+1], num1[i+1:]))\\n        for i in range(len(num2)-1, 0, -1):\\n            cand2.append((num2[i:], num2[:i]))\\n            \\n        open_idx = None\\n        close_idx = None\\n        min_val = float(\\'inf\\')\\n        \\n        for i, can1 in enumerate(cand1):\\n            for j, can2 in enumerate(cand2):\\n                if int(can1[0]) * int(can2[0]) * (int(can1[1]) + int(can2[1])) < min_val:\\n                    min_val = int(can1[0]) * int(can2[0]) * (int(can1[1]) + int(can2[1]))\\n                    open_idx = i\\n                    close_idx = j\\n                    \\n        result_str = num1[:open_idx] + \\'(\\' + num1[open_idx:] + \\'+\\' + num2[:len(num2)-close_idx] + \\')\\' + num2[len(num2) - close_idx:]\\n        return result_str\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nwe can try solving this problem using brute force since maximum expression length\\ncan be of len 10\\n\"\"\"\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        num1, num2 = expression.split(\\'+\\')\\n        cand1, cand2 = [(\\'1\\', num1)], [(\\'1\\', num2)]\\n        for i in range(len(num1)-1):\\n            cand1.append((num1[:i+1], num1[i+1:]))\\n        for i in range(len(num2)-1, 0, -1):\\n            cand2.append((num2[i:], num2[:i]))\\n            \\n        open_idx = None\\n        close_idx = None\\n        min_val = float(\\'inf\\')\\n        \\n        for i, can1 in enumerate(cand1):\\n            for j, can2 in enumerate(cand2):\\n                if int(can1[0]) * int(can2[0]) * (int(can1[1]) + int(can2[1])) < min_val:\\n                    min_val = int(can1[0]) * int(can2[0]) * (int(can1[1]) + int(can2[1]))\\n                    open_idx = i\\n                    close_idx = j\\n                    \\n        result_str = num1[:open_idx] + \\'(\\' + num1[open_idx:] + \\'+\\' + num2[:len(num2)-close_idx] + \\')\\' + num2[len(num2) - close_idx:]\\n        return result_str\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366405,
                "title": "brute-force-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(string a)\\n    {\\n        string p=\"\",q=\"\",r=\"\",s=\"\";\\n        int xo=0,y=0,z=0;\\n        for(auto x:a)\\n        {\\n            if(xo==0)\\n            {\\n                if(x==\\'(\\'){\\n                    xo=1;\\n                    continue;\\n                }\\n                else\\n                    p.push_back(x);\\n                continue;\\n            }\\n            if(y==0)\\n            {\\n                if(x==\\'+\\')\\n                {\\n                    y=1;\\n                    continue;\\n                }\\n                else\\n                    q.push_back(x);\\n                continue;\\n            }\\n            if(z==0)\\n            {\\n                if(x==\\')\\')\\n                {\\n                    z=1;\\n                    continue;\\n                }\\n                else\\n                    r.push_back(x);\\n                continue;\\n            }\\n            s.push_back(x);\\n        }\\n        int a1=0,a2=0,a3=0,a4=0;\\n        for(int i=0;i<p.size();i++)\\n        {\\n            a1+=(int)(p[i]-\\'0\\')*pow(10,p.size()-i-1);\\n        }\\n        for(int i=0;i<q.size();i++)\\n        {\\n            a2+=(int)(q[i]-\\'0\\')*pow(10,q.size()-i-1);\\n        }\\n        for(int i=0;i<r.size();i++)\\n        {\\n            a3+=(int)(r[i]-\\'0\\')*pow(10,r.size()-i-1);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            a4+=(int)(s[i]-\\'0\\')*pow(10,s.size()-i-1);\\n        }\\n        if(a1==0)\\n            a1=1;\\n        if(a4==0)\\n            a4=1;\\n        int ans=a1*(a2+a3)*a4;\\n        return ans;\\n    }\\n    string minimizeResult(string ex) {\\n        int idx=-1;\\n        for(int i=0;i<ex.size();i++)\\n        {\\n            if(ex[i]==\\'+\\'){\\n                idx=i;\\n                break;\\n            }\\n        }\\n        string k=\"\";\\n        int mn=INT_MAX;\\n        for(int i=0;i<idx;i++)\\n        {\\n            for(int j=ex.size()-1;j>idx;j--)\\n            {\\n                string a=ex.substr(0,i);\\n                string b=ex.substr(j+1,ex.size()-1-j);\\n                string c=ex.substr(i,j-i+1);\\n                string ans = a+\"(\"+c+\")\"+b;\\n                if(mn>fun(ans))\\n                {\\n                    mn=fun(ans);\\n                    k=ans;\\n                }\\n                cout<<ans<<\" \"<<fun(ans)<<\"\\\\n\";\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(string a)\\n    {\\n        string p=\"\",q=\"\",r=\"\",s=\"\";\\n        int xo=0,y=0,z=0;\\n        for(auto x:a)\\n        {\\n            if(xo==0)\\n            {\\n                if(x==\\'(\\'){\\n                    xo=1;\\n                    continue;\\n                }\\n                else\\n                    p.push_back(x);\\n                continue;\\n            }\\n            if(y==0)\\n            {\\n                if(x==\\'+\\')\\n                {\\n                    y=1;\\n                    continue;\\n                }\\n                else\\n                    q.push_back(x);\\n                continue;\\n            }\\n            if(z==0)\\n            {\\n                if(x==\\')\\')\\n                {\\n                    z=1;\\n                    continue;\\n                }\\n                else\\n                    r.push_back(x);\\n                continue;\\n            }\\n            s.push_back(x);\\n        }\\n        int a1=0,a2=0,a3=0,a4=0;\\n        for(int i=0;i<p.size();i++)\\n        {\\n            a1+=(int)(p[i]-\\'0\\')*pow(10,p.size()-i-1);\\n        }\\n        for(int i=0;i<q.size();i++)\\n        {\\n            a2+=(int)(q[i]-\\'0\\')*pow(10,q.size()-i-1);\\n        }\\n        for(int i=0;i<r.size();i++)\\n        {\\n            a3+=(int)(r[i]-\\'0\\')*pow(10,r.size()-i-1);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            a4+=(int)(s[i]-\\'0\\')*pow(10,s.size()-i-1);\\n        }\\n        if(a1==0)\\n            a1=1;\\n        if(a4==0)\\n            a4=1;\\n        int ans=a1*(a2+a3)*a4;\\n        return ans;\\n    }\\n    string minimizeResult(string ex) {\\n        int idx=-1;\\n        for(int i=0;i<ex.size();i++)\\n        {\\n            if(ex[i]==\\'+\\'){\\n                idx=i;\\n                break;\\n            }\\n        }\\n        string k=\"\";\\n        int mn=INT_MAX;\\n        for(int i=0;i<idx;i++)\\n        {\\n            for(int j=ex.size()-1;j>idx;j--)\\n            {\\n                string a=ex.substr(0,i);\\n                string b=ex.substr(j+1,ex.size()-1-j);\\n                string c=ex.substr(i,j-i+1);\\n                string ans = a+\"(\"+c+\")\"+b;\\n                if(mn>fun(ans))\\n                {\\n                    mn=fun(ans);\\n                    k=ans;\\n                }\\n                cout<<ans<<\" \"<<fun(ans)<<\"\\\\n\";\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2353007,
                "title": "python3-brute-force",
                "content": "This could be made more efficient by reducing the number of string slices, perhaps by using a `deque`. The basic idea should be the same.\\n\\n```python\\nclass Solution:\\n\\t# Splits expression into four numeric components (as strings)\\n    def splitExpr(self, expression, i, j, idx):\\n        return expression[:i], expression[i:idx], expression[idx+1:j+1], expression[j+1:]\\n\\t\\t\\n    # Given expression components as strings, return val of expression\\n    def getExprVal(self, a, b, c, d):\\n        a,b,c,d = map(lambda x: 1 if not x else int(x), [a,b,c,d])\\n        return a*(b+c)*d\\n    \\n    # Build result string given expression components\\n    def buildStr(self, a, b, c, d):\\n        return \\'\\'.join([a,\\'(\\',b,\\'+\\',c,\\')\\',d])\\n            \\n    # Enumerate all possible parantheses combinations and return min\\n    def minimizeResult(self, expression: str) -> str:\\n        idx, min_, res = expression.find(\\'+\\'), float(\\'inf\\'), \\'\\'\\n        for i in range(idx):\\n            for j in range(idx+1, len(expression)):\\n                a,b,c,d = self.splitExpr(expression, i, j, idx)\\n                cur = self.getExprVal(a,b,c,d)\\n                if cur < min_:\\n                    min_ = cur\\n                    res = self.buildStr(a,b,c,d)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```python\\nclass Solution:\\n\\t# Splits expression into four numeric components (as strings)\\n    def splitExpr(self, expression, i, j, idx):\\n        return expression[:i], expression[i:idx], expression[idx+1:j+1], expression[j+1:]\\n\\t\\t\\n    # Given expression components as strings, return val of expression\\n    def getExprVal(self, a, b, c, d):\\n        a,b,c,d = map(lambda x: 1 if not x else int(x), [a,b,c,d])\\n        return a*(b+c)*d\\n    \\n    # Build result string given expression components\\n    def buildStr(self, a, b, c, d):\\n        return \\'\\'.join([a,\\'(\\',b,\\'+\\',c,\\')\\',d])\\n            \\n    # Enumerate all possible parantheses combinations and return min\\n    def minimizeResult(self, expression: str) -> str:\\n        idx, min_, res = expression.find(\\'+\\'), float(\\'inf\\'), \\'\\'\\n        for i in range(idx):\\n            for j in range(idx+1, len(expression)):\\n                a,b,c,d = self.splitExpr(expression, i, j, idx)\\n                cur = self.getExprVal(a,b,c,d)\\n                if cur < min_:\\n                    min_ = cur\\n                    res = self.buildStr(a,b,c,d)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311193,
                "title": "python3-brute-force",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/af907302ab84ad94ecb97eeeb9b0bfa529041e30) for solutions of weekly 288. \\n\\n```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        k = expression.find(\\'+\\')\\n        ans = \"inf\"\\n        for i in range(k): \\n            for j in range(k+1, len(expression)): \\n                cand = f\\'{expression[:i]}({expression[i:k]}+{expression[k+1:j+1]}){expression[j+1:]}\\'\\n                ans = min(ans, cand, key=lambda x: eval(x.replace(\\'(\\', \\'*(\\').replace(\\')\\', \\')*\\').strip(\\'*\\')))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        k = expression.find(\\'+\\')\\n        ans = \"inf\"\\n        for i in range(k): \\n            for j in range(k+1, len(expression)): \\n                cand = f\\'{expression[:i]}({expression[i:k]}+{expression[k+1:j+1]}){expression[j+1:]}\\'\\n                ans = min(ans, cand, key=lambda x: eval(x.replace(\\'(\\', \\'*(\\').replace(\\')\\', \\')*\\').strip(\\'*\\')))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296469,
                "title": "c-using-recursion",
                "content": "```\\n// Approach :-> Recursively try all possible cases \\nclass Solution {\\npublic:\\n     pair<string,int> evaluate(string st,int i,int j){ // Here we are evaluating the sum \\n        st.insert(j,\")\");\\n        st.insert(i,\"(\");\\n         j++;\\n        int sumInd = st.find(\\'+\\');\\n        int num = stoi(st.substr(i+1,sumInd-i-1)) + stoi(st.substr(sumInd+1,j-sumInd-1));\\n        int first = 1;\\n        int second = 1;\\n        if(i!=0) first = stoi(st.substr(0,i));\\n        if(j!=st.size()-1){\\n            second = stoi(st.substr(j+1,st.size()-j-1));\\n        }\\n        return make_pair(st,num*first*second);\\n    }\\n    pair<string,int> solve(string &st,int i,int j){\\n        if(st[i]==\\'+\\' || st[j-1]==\\'+\\') return make_pair(\" \",INT32_MAX);\\n        \\n        pair<string,int> cur = evaluate(st,i,j); // evaluate for current parenthesis\\n        pair<string,int> p1 = solve(st,i+1,j); // call for first another possibilities\\n        pair<string,int> p2 = solve(st,i,j-1);//call for second possibilities\\n        \\n        return (cur.second<(p1.second<p2.second?p1:p2).second?cur:(p1.second<p2.second?p1:p2)); // return min of three min(cur,p1,p2)\\n    }\\n    string minimizeResult(string expression) {\\n        return solve(expression,0,expression.size()).first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n// Approach :-> Recursively try all possible cases \\nclass Solution {\\npublic:\\n     pair<string,int> evaluate(string st,int i,int j){ // Here we are evaluating the sum \\n        st.insert(j,\")\");\\n        st.insert(i,\"(\");\\n         j++;\\n        int sumInd = st.find(\\'+\\');\\n        int num = stoi(st.substr(i+1,sumInd-i-1)) + stoi(st.substr(sumInd+1,j-sumInd-1));\\n        int first = 1;\\n        int second = 1;\\n        if(i!=0) first = stoi(st.substr(0,i));\\n        if(j!=st.size()-1){\\n            second = stoi(st.substr(j+1,st.size()-j-1));\\n        }\\n        return make_pair(st,num*first*second);\\n    }\\n    pair<string,int> solve(string &st,int i,int j){\\n        if(st[i]==\\'+\\' || st[j-1]==\\'+\\') return make_pair(\" \",INT32_MAX);\\n        \\n        pair<string,int> cur = evaluate(st,i,j); // evaluate for current parenthesis\\n        pair<string,int> p1 = solve(st,i+1,j); // call for first another possibilities\\n        pair<string,int> p2 = solve(st,i,j-1);//call for second possibilities\\n        \\n        return (cur.second<(p1.second<p2.second?p1:p2).second?cur:(p1.second<p2.second?p1:p2)); // return min of three min(cur,p1,p2)\\n    }\\n    string minimizeResult(string expression) {\\n        return solve(expression,0,expression.size()).first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255528,
                "title": "intuitive-just-simulation",
                "content": "```\\nclass Solution {\\n    \\n    struct Num {\\n        int mul {1};\\n        int add {0};\\n        int paren_pos {0};\\n    };\\n    \\n    vector<Num> make_nums(const string& expr, bool left) {\\n        int len = expr.size();\\n        // vector<Num> res {Num{0, stoi(expr)}};\\n        vector<Num> res;\\n        if (left) {\\n            res.push_back(Num{1, stoi(expr), 0});\\n            for (int i = 1; i < len ; ++i) {\\n                int mul = stoi(expr.substr(0, i));\\n                int add = stoi(expr.substr(i));\\n                res.push_back(Num{mul, add, i});\\n                    \\n            }\\n        } else {\\n            res.push_back(Num{1, stoi(expr), (int)expr.size()});\\n            for (int i = 1; i < len; ++i) {\\n                int add = stoi(expr.substr(0, i));\\n                int mul = stoi(expr.substr(i));\\n                res.push_back(Num{mul, add, i});\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\npublic:\\n    string minimizeResult(string expression) {\\n        int plus_pos = expression.find(\\'+\\');\\n        auto left = expression.substr(0, plus_pos);\\n        auto right = expression.substr(plus_pos + 1);\\n        \\n        auto left_nums = make_nums(left, true);\\n        auto right_nums = make_nums(right, false);\\n\\n        int res = INT_MAX;\\n        int lp = 0, rp = right.size();\\n        for (auto l : left_nums) {\\n            for (auto r : right_nums) {\\n                auto tmp = l.mul * (l.add + r.add) * r.mul;\\n                if (tmp < res) {\\n                    res = tmp;\\n                    lp = l.paren_pos;\\n                    rp = r.paren_pos;\\n                }\\n            }\\n        }\\n        \\n        return left.insert(lp, 1, \\'(\\') + \"+\" + right.insert(rp, 1, \\')\\');\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    struct Num {\\n        int mul {1};\\n        int add {0};\\n        int paren_pos {0};\\n    };\\n    \\n    vector<Num> make_nums(const string& expr, bool left) {\\n        int len = expr.size();\\n        // vector<Num> res {Num{0, stoi(expr)}};\\n        vector<Num> res;\\n        if (left) {\\n            res.push_back(Num{1, stoi(expr), 0});\\n            for (int i = 1; i < len ; ++i) {\\n                int mul = stoi(expr.substr(0, i));\\n                int add = stoi(expr.substr(i));\\n                res.push_back(Num{mul, add, i});\\n                    \\n            }\\n        } else {\\n            res.push_back(Num{1, stoi(expr), (int)expr.size()});\\n            for (int i = 1; i < len; ++i) {\\n                int add = stoi(expr.substr(0, i));\\n                int mul = stoi(expr.substr(i));\\n                res.push_back(Num{mul, add, i});\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\npublic:\\n    string minimizeResult(string expression) {\\n        int plus_pos = expression.find(\\'+\\');\\n        auto left = expression.substr(0, plus_pos);\\n        auto right = expression.substr(plus_pos + 1);\\n        \\n        auto left_nums = make_nums(left, true);\\n        auto right_nums = make_nums(right, false);\\n\\n        int res = INT_MAX;\\n        int lp = 0, rp = right.size();\\n        for (auto l : left_nums) {\\n            for (auto r : right_nums) {\\n                auto tmp = l.mul * (l.add + r.add) * r.mul;\\n                if (tmp < res) {\\n                    res = tmp;\\n                    lp = l.paren_pos;\\n                    rp = r.paren_pos;\\n                }\\n            }\\n        }\\n        \\n        return left.insert(lp, 1, \\'(\\') + \"+\" + right.insert(rp, 1, \\')\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241998,
                "title": "python-simple-solution",
                "content": "```class Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        self.min_value = float(\\'INF\\')\\n        self.min_expr = \\'\\' \\n        def evaluate(i,j,left_index):\\n            new_expr= (expression[:i]+\"(\" + expression[i:left_index]+expression[left_index:j]+\")\"+expression[j:])\\n            lb = new_expr.index(\"(\")\\n            rb = new_expr.index(\")\")\\n            su = new_expr.index(\"+\")\\n            li = (new_expr[lb+1:su])\\n            ri = (new_expr[su+1:rb])\\n            rmul = new_expr[rb+1:]\\n            lmul = new_expr[:lb]\\n            evalt = int(li)+int(ri)\\n            if rmul:\\n                evalt *= int(rmul)\\n            if lmul:\\n                evalt *= int(lmul)\\n                \\n            if evalt< self.min_value:\\n                self.min_value = evalt\\n                self.min_expr = new_expr\\n                \\n           \\n        left_index = expression.index(\\'+\\')\\n        for i in range(left_index):\\n            for j in range(left_index+2,len(expression)+1):\\n                evaluate(i,j,left_index)\\n        return (self.min_expr)        \\n",
                "solutionTags": [],
                "code": "```class Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        self.min_value = float(\\'INF\\')\\n        self.min_expr = \\'\\' \\n        def evaluate(i,j,left_index):\\n            new_expr= (expression[:i]+\"(\" + expression[i:left_index]+expression[left_index:j]+\")\"+expression[j:])\\n            lb = new_expr.index(\"(\")\\n            rb = new_expr.index(\")\")\\n            su = new_expr.index(\"+\")\\n            li = (new_expr[lb+1:su])\\n            ri = (new_expr[su+1:rb])\\n            rmul = new_expr[rb+1:]\\n            lmul = new_expr[:lb]\\n            evalt = int(li)+int(ri)\\n            if rmul:\\n                evalt *= int(rmul)\\n            if lmul:\\n                evalt *= int(lmul)\\n                \\n            if evalt< self.min_value:\\n                self.min_value = evalt\\n                self.min_expr = new_expr\\n                \\n           \\n        left_index = expression.index(\\'+\\')\\n        for i in range(left_index):\\n            for j in range(left_index+2,len(expression)+1):\\n                evaluate(i,j,left_index)\\n        return (self.min_expr)        \\n",
                "codeTag": "Java"
            },
            {
                "id": 2197857,
                "title": "javascript-solution-using-regex",
                "content": "```\\nvar evalExpression = function(arr) {\\n\\n        let f = arr.match(/\\\\d+\\\\+\\\\d+/)[0].split(\\'+\\');\\n        let g = arr.match(/\\\\d+\\\\(/);\\n        let h = arr.match(/\\\\)\\\\d+/);\\n    \\n        let sum = Number.parseInt(f[0]) + Number.parseInt(f[1]);\\n    \\n        if (g) {\\n            sum = sum * Number.parseInt(g[0].split(\\'(\\')[0]);\\n        }\\n    \\n        if (h) {\\n            sum = sum * Number.parseInt(h[0].split(\\')\\')[1]);\\n        }\\n    \\n        return sum;\\n}\\n\\n\\nvar minimizeResult = function(exp) {\\n    \\n    let c = Infinity;\\n    \\n    let result = \"\";\\n    \\n        for(let i = 0; exp.charAt(i) !== \\'+\\'; i++) {\\n        \\n            for(let j = exp.length - 1; exp.charAt(j) !== \\'+\\'; j--) {\\n                \\n                let temp = exp.substring(0,i) + \"(\" +\\n                           exp.substring(i,j+1) + \")\" +\\n                           exp.substring(j+1, exp.length);\\n\\n                let d = evalExpression(temp);\\n                \\n                if (d < c) {\\n                    result = temp;\\n                    c = d;\\n                }\\n            }\\n        }\\n    \\n    return result;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar evalExpression = function(arr) {\\n\\n        let f = arr.match(/\\\\d+\\\\+\\\\d+/)[0].split(\\'+\\');\\n        let g = arr.match(/\\\\d+\\\\(/);\\n        let h = arr.match(/\\\\)\\\\d+/);\\n    \\n        let sum = Number.parseInt(f[0]) + Number.parseInt(f[1]);\\n    \\n        if (g) {\\n            sum = sum * Number.parseInt(g[0].split(\\'(\\')[0]);\\n        }\\n    \\n        if (h) {\\n            sum = sum * Number.parseInt(h[0].split(\\')\\')[1]);\\n        }\\n    \\n        return sum;\\n}\\n\\n\\nvar minimizeResult = function(exp) {\\n    \\n    let c = Infinity;\\n    \\n    let result = \"\";\\n    \\n        for(let i = 0; exp.charAt(i) !== \\'+\\'; i++) {\\n        \\n            for(let j = exp.length - 1; exp.charAt(j) !== \\'+\\'; j--) {\\n                \\n                let temp = exp.substring(0,i) + \"(\" +\\n                           exp.substring(i,j+1) + \")\" +\\n                           exp.substring(j+1, exp.length);\\n\\n                let d = evalExpression(temp);\\n                \\n                if (d < c) {\\n                    result = temp;\\n                    c = d;\\n                }\\n            }\\n        }\\n    \\n    return result;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2176393,
                "title": "c-o-m-n-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string e) {\\n        int pos = e.find(\\'+\\');\\n        string left = e.substr(0, pos);\\n        string right = e.substr(pos+1, e.size());\\n        \\n        int m = left.size(), n = right.size();\\n        \\n        int curr_max = INT_MAX;\\n        string res = \"\";\\n        for(int i=0; i<m; ++i)\\n        {\\n            string left1 = left.substr(0, i);\\n            int left1_int = (i == 0 ? 1 : stoi(left1));\\n            string left2 = left.substr(i, m-i);\\n            int left2_int = stoi(left2);\\n            for(int j=1; j<=n; ++j)\\n            {\\n                string right1 = right.substr(0, j);\\n                int right1_int = stoi(right1);\\n                string right2 = right.substr(j, n-j);\\n                int right2_int = (j==n? 1 : stoi(right2));\\n                \\n                int curr = left1_int * (left2_int + right1_int) * right2_int;\\n                if(curr < curr_max)\\n                {\\n                    curr_max = curr;\\n                    res = (i==0 ? \"\" : left1) + \"(\" + left2 + \"+\" + right1 + \")\" + (j==n ? \"\" : right2);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string e) {\\n        int pos = e.find(\\'+\\');\\n        string left = e.substr(0, pos);\\n        string right = e.substr(pos+1, e.size());\\n        \\n        int m = left.size(), n = right.size();\\n        \\n        int curr_max = INT_MAX;\\n        string res = \"\";\\n        for(int i=0; i<m; ++i)\\n        {\\n            string left1 = left.substr(0, i);\\n            int left1_int = (i == 0 ? 1 : stoi(left1));\\n            string left2 = left.substr(i, m-i);\\n            int left2_int = stoi(left2);\\n            for(int j=1; j<=n; ++j)\\n            {\\n                string right1 = right.substr(0, j);\\n                int right1_int = stoi(right1);\\n                string right2 = right.substr(j, n-j);\\n                int right2_int = (j==n? 1 : stoi(right2));\\n                \\n                int curr = left1_int * (left2_int + right1_int) * right2_int;\\n                if(curr < curr_max)\\n                {\\n                    curr_max = curr;\\n                    res = (i==0 ? \"\" : left1) + \"(\" + left2 + \"+\" + right1 + \")\" + (j==n ? \"\" : right2);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175158,
                "title": "python-brute-force",
                "content": "```\\nclass Solution:\\n    def minimizeResult(self, x: str) -> str:\\n        l=len(x)\\n        z=x.index(\\'+\\')\\n        a=[]\\n        b=[]\\n        r=\\'\\'\\n        for i in range(z):\\n            a.append((r,x[i:z]))\\n            r+=x[i]\\n        r=\\'\\'\\n        for i in range(z+1,l):\\n            r+=x[i]\\n            b.append((r,x[i+1:]))\\n        ans=inf,\\'\\'\\n        for q,r in a:\\n            for s,t in b:\\n                qq=1 if q==\\'\\' else int(q)\\n                tt=1 if t==\\'\\' else int(t)\\n                rr=int(r)\\n                ss=int(s)\\n                ans=min(ans,((rr+ss)*qq*tt, q+\"(\"+r+\\'+\\'+s+\\')\\'+t))\\n                \\n        return ans[1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, x: str) -> str:\\n        l=len(x)\\n        z=x.index(\\'+\\')\\n        a=[]\\n        b=[]\\n        r=\\'\\'\\n        for i in range(z):\\n            a.append((r,x[i:z]))\\n            r+=x[i]\\n        r=\\'\\'\\n        for i in range(z+1,l):\\n            r+=x[i]\\n            b.append((r,x[i+1:]))\\n        ans=inf,\\'\\'\\n        for q,r in a:\\n            for s,t in b:\\n                qq=1 if q==\\'\\' else int(q)\\n                tt=1 if t==\\'\\' else int(t)\\n                rr=int(r)\\n                ss=int(s)\\n                ans=min(ans,((rr+ss)*qq*tt, q+\"(\"+r+\\'+\\'+s+\\')\\'+t))\\n                \\n        return ans[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119171,
                "title": "python-proper-string-usage",
                "content": "I to have applied some hard core string manupulation and ik its difficult to understand but if u really wanna know how it is actually working plz remove comments(\"#\") from print statements and check what each step is actually doing , then u will realise that it is actually easy to understand. \\nIf any doubts feel free to ask.\\n```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        l=expression.split(\"+\")\\n        #print(x)\\n        x=str(l[0][::-1])\\n        y=str(l[1])\\n        dic={}\\n        dic[\"(\"+expression+\")\"]=int(x[::-1])+int(y)\\n        #print(int(x[::-1])+int(y))\\n        z=len(x)\\n        for i in range(len(x)):\\n            a=str(x[:z-i])+\"(\"+str(x[z-i:])\\n            #print(a)\\n            b=str(x[:z-i])\\n            if len(b)==0:\\n                b=int(x[z-i:])\\n                c=1\\n            \\n            else:\\n                b=int(x[:z-i][::-1])\\n                c=str(x[z-i:][::-1])\\n                if len(c)>0:\\n                    c=int(x[z-i:][::-1])\\n                else:\\n                    c=1\\n                \\n            p=len(y)\\n            for j in range(len(y)):\\n                d=str(y[:p-j])+\")\"+str(y[p-j:])\\n                e=int(y[:p-j])\\n                f=str(y[p-j:])\\n                if len(f)>0:\\n                    f=int(y[p-j:])\\n                else:\\n                    f=1\\n                    \\n                s=c*(b+e)*f\\n                dic[a[::-1]+\"+\"+d]=s\\n                #print(dic,b,c,e,f)\\n                \\n        sorted_d = sorted(dic.items(), key=operator.itemgetter(1))\\n        #print(sorted_d)\\n        return sorted_d[0][0]                \\n```\\nIf u really got the solution then plz...........UPVOTE...................Thnx in adv",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        l=expression.split(\"+\")\\n        #print(x)\\n        x=str(l[0][::-1])\\n        y=str(l[1])\\n        dic={}\\n        dic[\"(\"+expression+\")\"]=int(x[::-1])+int(y)\\n        #print(int(x[::-1])+int(y))\\n        z=len(x)\\n        for i in range(len(x)):\\n            a=str(x[:z-i])+\"(\"+str(x[z-i:])\\n            #print(a)\\n            b=str(x[:z-i])\\n            if len(b)==0:\\n                b=int(x[z-i:])\\n                c=1\\n            \\n            else:\\n                b=int(x[:z-i][::-1])\\n                c=str(x[z-i:][::-1])\\n                if len(c)>0:\\n                    c=int(x[z-i:][::-1])\\n                else:\\n                    c=1\\n                \\n            p=len(y)\\n            for j in range(len(y)):\\n                d=str(y[:p-j])+\")\"+str(y[p-j:])\\n                e=int(y[:p-j])\\n                f=str(y[p-j:])\\n                if len(f)>0:\\n                    f=int(y[p-j:])\\n                else:\\n                    f=1\\n                    \\n                s=c*(b+e)*f\\n                dic[a[::-1]+\"+\"+d]=s\\n                #print(dic,b,c,e,f)\\n                \\n        sorted_d = sorted(dic.items(), key=operator.itemgetter(1))\\n        #print(sorted_d)\\n        return sorted_d[0][0]                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2117644,
                "title": "c-solution",
                "content": "```\\nchar * minimizeResult(char * expression){  // one * (two + three) * four\\n    int len = strlen(expression);\\n    int two[9];\\n    int three[11];\\n    int one[9];\\n    int four[11];\\n    int add = 0;\\n    while (expression[add] != \\'+\\'){\\n        add++;\\n    }\\n    two[add-1] = expression[add-1]-48;\\n    int ten = 10;\\n    for (int i = add-2 ; i >= 0 ; i--){\\n        two[i] = two[i+1] + ten*(expression[i]-48);\\n        ten *= 10;\\n    }\\n    \\n    one[0] = 1;\\n    ten /= 10;\\n    for (int i = 1 ; i < add ; i++){\\n        one[i] = two[0]/ten;\\n        ten /= 10;\\n    }\\n    three[add+2] = expression[add+1]-48;\\n    for (int i = add+3 ; i <= len ; i++){\\n        three[i] = 10*three[i-1] + (expression[i-1]-48);\\n        ten *= 10;\\n    }\\n    four[add+2] = three[len]%ten;\\n    ten /= 10;\\n    for (int i = add+3 ; i < len ; i++){\\n        four[i] = three[len]%ten;\\n        ten /= 10;\\n    }\\n    four[len] = 1;\\n    int l, r;\\n    int max = INT_MAX;\\n    int now;\\n    for (int i = 0 ; i < add ; i++){\\n        for (int j = add+2 ; j <= len ; j++){\\n            now = one[i]*(two[i]+three[j])*four[j];\\n            if (now < max){\\n                l = i;\\n                r = j;\\n                max = now;\\n            }\\n        }\\n    }\\n    char* ans = malloc(sizeof(char)*(len+3));\\n    now = 0;\\n    r++;\\n    ans[len+2] = \\'\\\\0\\';\\n    len += 3;\\n    int i = 0;\\n    while (now < len){\\n        if (now == l){\\n            ans[now] = \\'(\\';\\n        } else if (now == r){\\n            ans[now] = \\')\\';\\n        } else {\\n            ans[now] = expression[i];;\\n            i++;\\n        }\\n        now++;\\n    }\\n    return ans;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * minimizeResult(char * expression){  // one * (two + three) * four\\n    int len = strlen(expression);\\n    int two[9];\\n    int three[11];\\n    int one[9];\\n    int four[11];\\n    int add = 0;\\n    while (expression[add] != \\'+\\'){\\n        add++;\\n    }\\n    two[add-1] = expression[add-1]-48;\\n    int ten = 10;\\n    for (int i = add-2 ; i >= 0 ; i--){\\n        two[i] = two[i+1] + ten*(expression[i]-48);\\n        ten *= 10;\\n    }\\n    \\n    one[0] = 1;\\n    ten /= 10;\\n    for (int i = 1 ; i < add ; i++){\\n        one[i] = two[0]/ten;\\n        ten /= 10;\\n    }\\n    three[add+2] = expression[add+1]-48;\\n    for (int i = add+3 ; i <= len ; i++){\\n        three[i] = 10*three[i-1] + (expression[i-1]-48);\\n        ten *= 10;\\n    }\\n    four[add+2] = three[len]%ten;\\n    ten /= 10;\\n    for (int i = add+3 ; i < len ; i++){\\n        four[i] = three[len]%ten;\\n        ten /= 10;\\n    }\\n    four[len] = 1;\\n    int l, r;\\n    int max = INT_MAX;\\n    int now;\\n    for (int i = 0 ; i < add ; i++){\\n        for (int j = add+2 ; j <= len ; j++){\\n            now = one[i]*(two[i]+three[j])*four[j];\\n            if (now < max){\\n                l = i;\\n                r = j;\\n                max = now;\\n            }\\n        }\\n    }\\n    char* ans = malloc(sizeof(char)*(len+3));\\n    now = 0;\\n    r++;\\n    ans[len+2] = \\'\\\\0\\';\\n    len += 3;\\n    int i = 0;\\n    while (now < len){\\n        if (now == l){\\n            ans[now] = \\'(\\';\\n        } else if (now == r){\\n            ans[now] = \\')\\';\\n        } else {\\n            ans[now] = expression[i];;\\n            i++;\\n        }\\n        now++;\\n    }\\n    return ans;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2081680,
                "title": "what-s-wrong-in-this-code",
                "content": "Below code failing for test case \"3985+6511\"\\n\\nExpected - (3985+651)1 sums up 4636\\nActual - \"398(5+6)1\" sums up 4378\\n\\n```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        String[] values = expression.split(\"\\\\\\\\+\");\\n        String a = values[0];\\n        String b = values[1];\\n        int numA = Integer.parseInt(a);\\n        int numB = Integer.parseInt(b);\\n        int actualSum = Integer.parseInt(a) + Integer.parseInt(b);\\n        String result = \"(\" + expression + \")\";\\n        int prevSum = Integer.MAX_VALUE;\\n        for(int i = b.length() - 1; i > 0; i--) {\\n            String left = b.substring(0, i);\\n            String right = b.substring(i, b.length());\\n            // System.out.println(\"l-\" + left + \";r-\" + right);\\n            int sum = (numA + Integer.parseInt(left)) * Integer.parseInt(right);\\n            if(sum >= actualSum) continue;\\n            if(prevSum > sum) {\\n                result = \"(\" + a + \"+\" + left + \")\" + right;\\n                prevSum = sum;\\n            }\\n        }\\n        for(int i = 1; i <= a.length() - 1; i++) {\\n            String left = a.substring(0, i);\\n            String right = a.substring(i, a.length());\\n            int sum = (numB + Integer.parseInt(right)) * Integer.parseInt(left);\\n            if(sum >= actualSum) continue;\\n            if(prevSum > sum) {\\n                result = left + \"(\" + right + \"+\" + b + \")\";\\n                prevSum = sum;\\n            }\\n        }\\n        int n = Math.min(a.length(), b.length());\\n        int l = 1;\\n        a = values[0];\\n        b = values[1];\\n        while(l < n) {\\n            String aLeft = a.substring(0, l);\\n            String aRight = a.substring(l, a.length());\\n            String bLeft = b.substring(0, b.length() - l);\\n            String bRight = b.substring(l, b.length());\\n            // System.out.println(aLeft + \"|\" + aRight + \"|\" + bLeft + \"|\" + bRight);\\n            int sum = Integer.parseInt(aLeft) * (Integer.parseInt(aRight) + Integer.parseInt(bLeft)) * Integer.parseInt(bRight);\\n            l++;\\n            if(sum >= actualSum) continue;\\n            if(prevSum > sum) {\\n                result = aLeft + \"(\" + aRight + \"+\" + bLeft + \")\" + bRight;\\n                prevSum = sum;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minimizeResult(String expression) {\\n        String[] values = expression.split(\"\\\\\\\\+\");\\n        String a = values[0];\\n        String b = values[1];\\n        int numA = Integer.parseInt(a);\\n        int numB = Integer.parseInt(b);\\n        int actualSum = Integer.parseInt(a) + Integer.parseInt(b);\\n        String result = \"(\" + expression + \")\";\\n        int prevSum = Integer.MAX_VALUE;\\n        for(int i = b.length() - 1; i > 0; i--) {\\n            String left = b.substring(0, i);\\n            String right = b.substring(i, b.length());\\n            // System.out.println(\"l-\" + left + \";r-\" + right);\\n            int sum = (numA + Integer.parseInt(left)) * Integer.parseInt(right);\\n            if(sum >= actualSum) continue;\\n            if(prevSum > sum) {\\n                result = \"(\" + a + \"+\" + left + \")\" + right;\\n                prevSum = sum;\\n            }\\n        }\\n        for(int i = 1; i <= a.length() - 1; i++) {\\n            String left = a.substring(0, i);\\n            String right = a.substring(i, a.length());\\n            int sum = (numB + Integer.parseInt(right)) * Integer.parseInt(left);\\n            if(sum >= actualSum) continue;\\n            if(prevSum > sum) {\\n                result = left + \"(\" + right + \"+\" + b + \")\";\\n                prevSum = sum;\\n            }\\n        }\\n        int n = Math.min(a.length(), b.length());\\n        int l = 1;\\n        a = values[0];\\n        b = values[1];\\n        while(l < n) {\\n            String aLeft = a.substring(0, l);\\n            String aRight = a.substring(l, a.length());\\n            String bLeft = b.substring(0, b.length() - l);\\n            String bRight = b.substring(l, b.length());\\n            // System.out.println(aLeft + \"|\" + aRight + \"|\" + bLeft + \"|\" + bRight);\\n            int sum = Integer.parseInt(aLeft) * (Integer.parseInt(aRight) + Integer.parseInt(bLeft)) * Integer.parseInt(bRight);\\n            l++;\\n            if(sum >= actualSum) continue;\\n            if(prevSum > sum) {\\n                result = aLeft + \"(\" + aRight + \"+\" + bLeft + \")\" + bRight;\\n                prevSum = sum;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078966,
                "title": "c",
                "content": "string minimizeResult(string s) {\\n        \\n        string ans;\\n        int n=s.size();\\n        int id=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'+\\'){\\n                id=i;                         // find index of \"+\"\\n                break;\\n            }\\n        }\\n        int sum=INT_MAX;\\n        for(int i=0;i<id;i++){\\n            for(int j=id+1;j<n;j++){\\n                int a= (i>0 ? stoi(s.substr(0,i)) : 1);\\n                int b= stoi(s.substr(i,id-i));\\n                int c= stoi(s.substr(id+1,j-id));\\n                int d= (n-1-j>0 ? stoi(s.substr(j+1,n-1-j)) : 1);\\n                if(a*(b+c)*d < sum){\\n                    sum = a*(b+c)*d;\\n                    ans=s.substr(0,i)+\\'(\\'+s.substr(i,id-i)+\\'+\\'+s.substr(id+1,j-id)+\\')\\'+s.substr(j+1,n-1-j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "string minimizeResult(string s) {\\n        \\n        string ans;\\n        int n=s.size();\\n        int id=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'+\\'){\\n                id=i;                         // find index of \"+\"\\n                break;\\n            }\\n        }\\n        int sum=INT_MAX;\\n        for(int i=0;i<id;i++){\\n            for(int j=id+1;j<n;j++){\\n                int a= (i>0 ? stoi(s.substr(0,i)) : 1);\\n                int b= stoi(s.substr(i,id-i));\\n                int c= stoi(s.substr(id+1,j-id));\\n                int d= (n-1-j>0 ? stoi(s.substr(j+1,n-1-j)) : 1);\\n                if(a*(b+c)*d < sum){\\n                    sum = a*(b+c)*d;\\n                    ans=s.substr(0,i)+\\'(\\'+s.substr(i,id-i)+\\'+\\'+s.substr(id+1,j-id)+\\')\\'+s.substr(j+1,n-1-j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2076193,
                "title": "python3-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef minimizeResult(self, exp: str) -> str:\\n\\t\\t\\tr=exp.index(\\'+\\')\\n\\t\\t\\tres=10e10\\n\\t\\t\\tresstr=\"\"\\n\\t\\t\\tfor i in range(r):\\n\\t\\t\\t\\tfor j in range(r+2,len(exp)+1):\\n\\t\\t\\t\\t\\ttm=exp[:i]+\\'*(\\'+exp[i:j]+\\')*\\'+exp[j:]\\n\\t\\t\\t\\t\\ttm1=exp[:i]+\\'(\\'+exp[i:j]+\\')\\'+exp[j:]\\n\\t\\t\\t\\t\\tif tm[-1]==\\'*\\': tm=tm[:-1]\\n\\t\\t\\t\\t\\tif tm[0]==\\'*\\': tm=tm[1:]\\n\\t\\t\\t\\t\\tif eval(tm)<res:\\n\\t\\t\\t\\t\\t\\tres=eval(tm)\\n\\t\\t\\t\\t\\t\\tresstr=tm1\\n\\t\\t\\treturn resstr",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minimizeResult(self, exp: str) -> str:\\n\\t\\t\\tr=exp.index(\\'+\\')\\n\\t\\t\\tres=10e10\\n\\t\\t\\tresstr=\"\"\\n\\t\\t\\tfor i in range(r):\\n\\t\\t\\t\\tfor j in range(r+2,len(exp)+1):\\n\\t\\t\\t\\t\\ttm=exp[:i]+\\'*(\\'+exp[i:j]+\\')*\\'+exp[j:]\\n\\t\\t\\t\\t\\ttm1=exp[:i]+\\'(\\'+exp[i:j]+\\')\\'+exp[j:]\\n\\t\\t\\t\\t\\tif tm[-1]==\\'*\\': tm=tm[:-1]\\n\\t\\t\\t\\t\\tif tm[0]==\\'*\\': tm=tm[1:]\\n\\t\\t\\t\\t\\tif eval(tm)<res:\\n\\t\\t\\t\\t\\t\\tres=eval(tm)\\n\\t\\t\\t\\t\\t\\tresstr=tm1\\n\\t\\t\\treturn resstr",
                "codeTag": "Java"
            },
            {
                "id": 2072536,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\n    int RESULT;\\n    string ANS;\\n    \\npublic:\\n    string minimizeResult(string expression) {\\n        int n = expression.size();\\n        RESULT = INT_MAX;\\n        int PLUS_INDEX = expression.find(\"+\");\\n        \\n        for(int i=0; i<PLUS_INDEX; i++){\\n            \\n            for(int j=PLUS_INDEX+1; j<n; j++){\\n                \\n                int a = i > 0 ? stoi(expression.substr(0, i)): 1;\\n                int b = stoi(expression.substr(i, PLUS_INDEX-i));\\n                int c = stoi(expression.substr(PLUS_INDEX+1, j-PLUS_INDEX));\\n                int d = n-1-j > 0 ? stoi(expression.substr(j+1, n-1-j)): 1;\\n                \\n                if(a*(b+c)*d < RESULT){\\n                    RESULT = a*(b+c)*d;\\n                    ANS = expression.substr(0, i)+\"(\"+expression.substr(i, PLUS_INDEX-i)+\"+\"+expression.substr(PLUS_INDEX+1, j-PLUS_INDEX)+\")\"+expression.substr(j+1, n-1-j);\\n                }\\n            }\\n        }\\n        \\n        return ANS;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "class Solution {\\n    int RESULT;\\n    string ANS;\\n    \\npublic:\\n    string minimizeResult(string expression) {\\n        int n = expression.size();\\n        RESULT = INT_MAX;\\n        int PLUS_INDEX = expression.find(\"+\");\\n        \\n        for(int i=0; i<PLUS_INDEX; i++){\\n            \\n            for(int j=PLUS_INDEX+1; j<n; j++){\\n                \\n                int a = i > 0 ? stoi(expression.substr(0, i)): 1;\\n                int b = stoi(expression.substr(i, PLUS_INDEX-i));\\n                int c = stoi(expression.substr(PLUS_INDEX+1, j-PLUS_INDEX));\\n                int d = n-1-j > 0 ? stoi(expression.substr(j+1, n-1-j)): 1;\\n                \\n                if(a*(b+c)*d < RESULT){\\n                    RESULT = a*(b+c)*d;\\n                    ANS = expression.substr(0, i)+\"(\"+expression.substr(i, PLUS_INDEX-i)+\"+\"+expression.substr(PLUS_INDEX+1, j-PLUS_INDEX)+\")\"+expression.substr(j+1, n-1-j);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2051316,
                "title": "javascript-product-of-3-parts-clean-codes-with-example",
                "content": "Let\\'s take `247+38` as example, whose `\"+\"` in index[3]:\\n\\n> `\"(\"` must be added **before** index[2]\\n> `\")\"` must be added **after** index[4]\\n\\n\\n| \\uD83D\\uDC51 | \"(\" at | \")\" at | expression | result | \\n| :---: | :---: | :---: | :---: | :---: |\\n| | 0 | 4 | (247+3) x 8 | 2000 |\\n| | 0 | 5 | (247+38) | 285 |\\n| | 1 | 4 | 2 x (47+3) x 8 | 800 |\\n| \\u2713 | 1 | 5 | 2 x (47+38) | 170 |\\n| | 2 | 4 | 24 x (7+3) x 8 | 1920 |\\n| | 2 | 5 | 24 x (7+38) | 1080 |\\n\\n\\n**Variables**\\n- `min` to collect the minimum result.\\n- `plus` for the index of \"+\".\\n- `left`, `right` for the minimum expression\\'s index of \"(\" and \")\".\\n\\n```\\nvar minimizeResult = function(expression) {\\n    let min=Infinity, left=right=-1;\\n    let plus=expression.indexOf(\"+\");\\n\\t\\n    for(let i=0; i<plus; i++){\\n        for(let j=plus+1; j<expression.length; j++){\\n\\t\\t\\t// split the expression into 3 parts, *=1 if not exists.\\n            let answer=(expression.substr(0,i)||1)\\n\\t\\t\\t\\t\\t  // digits between \"(\" and \")\" should add first.\\n\\t\\t\\t\\t\\t  *(expression.substr(i,plus-i)*1+expression.substr(plus+1,j-plus)*1)\\n\\t\\t\\t\\t\\t  *(expression.substr(j+1)||1);\\n            if(answer<min){\\n                min=answer; left=i; right=j+1;\\n            }\\n        }\\n    }\\n    return expression.substr(0,left)\\n\\t\\t  +\"(\"+expression.substr(left,right-left)\\n\\t\\t  +\")\"+expression.substr(right);\\n};\\n```\\n\\nThanks for your reading and **up-voting** :)\\n\\n**\\u2B50 Check [HERE](https://github.com/Lynn19950915/LeetCode_King) for my full Leetcode Notes ~**\\n",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar minimizeResult = function(expression) {\\n    let min=Infinity, left=right=-1;\\n    let plus=expression.indexOf(\"+\");\\n\\t\\n    for(let i=0; i<plus; i++){\\n        for(let j=plus+1; j<expression.length; j++){\\n\\t\\t\\t// split the expression into 3 parts, *=1 if not exists.\\n            let answer=(expression.substr(0,i)||1)\\n\\t\\t\\t\\t\\t  // digits between \"(\" and \")\" should add first.\\n\\t\\t\\t\\t\\t  *(expression.substr(i,plus-i)*1+expression.substr(plus+1,j-plus)*1)\\n\\t\\t\\t\\t\\t  *(expression.substr(j+1)||1);\\n            if(answer<min){\\n                min=answer; left=i; right=j+1;\\n            }\\n        }\\n    }\\n    return expression.substr(0,left)\\n\\t\\t  +\"(\"+expression.substr(left,right-left)\\n\\t\\t  +\")\"+expression.substr(right);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2035911,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    string minimizeResult(string exp)\\n    {\\n        // finding the index of + sign\\n        int plusInd = 0;\\n        int n = exp.size();\\n        for (int i = 0; i < n; i++)\\n            if (exp[i] == \\'+\\')\\n            {\\n                plusInd = i;\\n                break;\\n            }\\n\\n        int ans_left = -1, ans_right = -1, minRes = 1000000000;\\n        for (int i = 0; i < plusInd; i++)\\n        {\\n            int m1 = 1;\\n            if (i != 0)\\n                m1 = stoi(exp.substr(0, i));\\n            int n1 = stoi(exp.substr(i, plusInd - i));\\n            for (int j = plusInd + 1; j < n; j++)\\n            {\\n                int m2 = 1;\\n                if (j != n - 1)\\n                    m2 = stoi(exp.substr(j + 1, n - 1 - j));\\n                int n2 = stoi(exp.substr(plusInd + 1, j - plusInd));\\n                if (minRes > (m1 * (n1 + n2) * m2))\\n                    ans_left = i, ans_right = j, minRes = m1 * (n1 + n2) * m2;\\n            }\\n        }\\n\\n        \\n        string ans = exp.substr(0, ans_left) + \"(\" + exp.substr(ans_left, plusInd - ans_left) + \"+\";\\n        ans += exp.substr(plusInd + 1, ans_right - plusInd) + \")\" + exp.substr(ans_right + 1, n);\\n\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    string minimizeResult(string exp)\\n    {\\n        // finding the index of + sign\\n        int plusInd = 0;\\n        int n = exp.size();\\n        for (int i = 0; i < n; i++)\\n            if (exp[i] == \\'+\\')\\n            {\\n                plusInd = i;\\n                break;\\n            }\\n\\n        int ans_left = -1, ans_right = -1, minRes = 1000000000;\\n        for (int i = 0; i < plusInd; i++)\\n        {\\n            int m1 = 1;\\n            if (i != 0)\\n                m1 = stoi(exp.substr(0, i));\\n            int n1 = stoi(exp.substr(i, plusInd - i));\\n            for (int j = plusInd + 1; j < n; j++)\\n            {\\n                int m2 = 1;\\n                if (j != n - 1)\\n                    m2 = stoi(exp.substr(j + 1, n - 1 - j));\\n                int n2 = stoi(exp.substr(plusInd + 1, j - plusInd));\\n                if (minRes > (m1 * (n1 + n2) * m2))\\n                    ans_left = i, ans_right = j, minRes = m1 * (n1 + n2) * m2;\\n            }\\n        }\\n\\n        \\n        string ans = exp.substr(0, ans_left) + \"(\" + exp.substr(ans_left, plusInd - ans_left) + \"+\";\\n        ans += exp.substr(plusInd + 1, ans_right - plusInd) + \")\" + exp.substr(ans_right + 1, n);\\n\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030351,
                "title": "easy-understanding-python-recursion",
                "content": "```\\n    def minimizeResult(self, expression: str) -> str:\\n        \\n        res = math.inf\\n        res_str = None\\n        \\n        def dfs(left, right):\\n            nonlocal res, res_str\\n            \\n            for i in range(len(left)):\\n                a, b = left[:i], left[i:]\\n                \\n                for j in range(1, len(right)+1):\\n                    c, d = right[:j], right[j:]\\n                    \\n                    val = (int(a) if a else 1) * (int(b) + int(c)) * (int(d) if d else 1)\\n                    if val < res:\\n                        res = val\\n                        res_str = a + \\'(\\' + b + \\'+\\' + c + \\')\\' + d        \\n        \\n        dfs(*expression.split(\\'+\\'))\\n        return res_str\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n    def minimizeResult(self, expression: str) -> str:\\n        \\n        res = math.inf\\n        res_str = None\\n        \\n        def dfs(left, right):\\n            nonlocal res, res_str\\n            \\n            for i in range(len(left)):\\n                a, b = left[:i], left[i:]\\n                \\n                for j in range(1, len(right)+1):\\n                    c, d = right[:j], right[j:]\\n                    \\n                    val = (int(a) if a else 1) * (int(b) + int(c)) * (int(d) if d else 1)\\n                    if val < res:\\n                        res = val\\n                        res_str = a + \\'(\\' + b + \\'+\\' + c + \\')\\' + d        \\n        \\n        dfs(*expression.split(\\'+\\'))\\n        return res_str\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2027923,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        res = float(\\'inf\\')\\n        left, right = expression.split(\\'+\\')\\n        s = \\'\\'\\n\\n        for i in range(len(left)):\\n            for j in range(len(right)):\\n                part1_len = part4_len = -1\\n                part1 = left[: i]\\n                if len(part1) == 0:\\n                    part1 = \\'1\\'\\n                    part1_len = 0\\n                part2 = left[i : len(left)]\\n                part3 = right[: j + 1]\\n                part4 = right[j + 1 : ]\\n                if len(part4) == 0:\\n                    part4 = \\'1\\'\\n                    part4_len = 0\\n                cur = int(part1) * (int(part2) + int(part3)) * int(part4)\\n\\n                if cur < res:\\n                    res = cur\\n                    if part1_len == 0:\\n                        part1 = \\'\\'\\n                    if part4_len == 0:\\n                        part4 = \\'\\'\\n                    s = part1 + \\'(\\' + part2 + \\'+\\' + part3 +\\')\\' + part4\\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizeResult(self, expression: str) -> str:\\n        res = float(\\'inf\\')\\n        left, right = expression.split(\\'+\\')\\n        s = \\'\\'\\n\\n        for i in range(len(left)):\\n            for j in range(len(right)):\\n                part1_len = part4_len = -1\\n                part1 = left[: i]\\n                if len(part1) == 0:\\n                    part1 = \\'1\\'\\n                    part1_len = 0\\n                part2 = left[i : len(left)]\\n                part3 = right[: j + 1]\\n                part4 = right[j + 1 : ]\\n                if len(part4) == 0:\\n                    part4 = \\'1\\'\\n                    part4_len = 0\\n                cur = int(part1) * (int(part2) + int(part3)) * int(part4)\\n\\n                if cur < res:\\n                    res = cur\\n                    if part1_len == 0:\\n                        part1 = \\'\\'\\n                    if part4_len == 0:\\n                        part4 = \\'\\'\\n                    s = part1 + \\'(\\' + part2 + \\'+\\' + part3 +\\')\\' + part4\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005671,
                "title": "easy-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n    \\n    long evaluate(String A, String B, int i, int j)\\n    {\\n        int a = i > 0 ? Integer.parseInt(A.substring(0, i)) : 1;\\n        int b = Integer.parseInt(A.substring(i));\\n        int c = Integer.parseInt(B.substring(0, j + 1));\\n        int d = j + 1 < B.length() ? Integer.parseInt(B.substring(j + 1)) : 1;\\n        \\n        return a * (b + c) * d;\\n    }\\n    \\n    String construct(String A, String B, int i, int j)\\n    {\\n        return A.substring(0, i) + \"(\" + A.substring(i) + \"+\" + B.substring(0, j + 1) + \")\" + B.substring(j + 1);\\n    }\\n    \\n    public String minimizeResult(String expression) {\\n        \\n        String[] str = expression.split(\"\\\\\\\\+\");\\n        \\n        long minResult = Integer.parseInt(str[0]) + Integer.parseInt(str[1]);\\n        expression = \"(\" + expression + \")\";\\n        \\n        for(int i = str[0].length() - 1; i >= 0; i--)\\n        {\\n            for(int j = 0; j < str[1].length(); j++)\\n            {\\n                long currentResult = evaluate(str[0], str[1], i, j);\\n                if(minResult > currentResult)\\n                {\\n                    minResult = currentResult;\\n                    expression = construct(str[0], str[1], i, j); \\n                }\\n            }\\n        }\\n        \\n        return expression;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    long evaluate(String A, String B, int i, int j)\\n    {\\n        int a = i > 0 ? Integer.parseInt(A.substring(0, i)) : 1;\\n        int b = Integer.parseInt(A.substring(i));\\n        int c = Integer.parseInt(B.substring(0, j + 1));\\n        int d = j + 1 < B.length() ? Integer.parseInt(B.substring(j + 1)) : 1;\\n        \\n        return a * (b + c) * d;\\n    }\\n    \\n    String construct(String A, String B, int i, int j)\\n    {\\n        return A.substring(0, i) + \"(\" + A.substring(i) + \"+\" + B.substring(0, j + 1) + \")\" + B.substring(j + 1);\\n    }\\n    \\n    public String minimizeResult(String expression) {\\n        \\n        String[] str = expression.split(\"\\\\\\\\+\");\\n        \\n        long minResult = Integer.parseInt(str[0]) + Integer.parseInt(str[1]);\\n        expression = \"(\" + expression + \")\";\\n        \\n        for(int i = str[0].length() - 1; i >= 0; i--)\\n        {\\n            for(int j = 0; j < str[1].length(); j++)\\n            {\\n                long currentResult = evaluate(str[0], str[1], i, j);\\n                if(minResult > currentResult)\\n                {\\n                    minResult = currentResult;\\n                    expression = construct(str[0], str[1], i, j); \\n                }\\n            }\\n        }\\n        \\n        return expression;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984971,
                "title": "not-interesting-to-make-it-compiles",
                "content": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string expression) {\\n        int pos_plus = 0; \\n        for (; pos_plus < expression.size(); pos_plus++) {\\n            if (expression[pos_plus] == \\'+\\') break;\\n        }\\n        int left = 0, right = expression.size()-1; \\n        int ans = INT_MAX;\\n        string res; \\n        for (; left < pos_plus; left++) {\\n            for (; right > pos_plus; right--) {\\n                int a = stoi(expression.substr(left+1, pos_plus-left-1)); \\n                int b = stoi(expression.substr(pos_plus+1, right-pos_plus-1));\\n                int c = a+b;\\n                int multi1 = left == 0? 1 : stoi(expression.substr(0, left)); \\n                int multi2 = right == expression.size()-1? 1 : stoi(expression.substr(right+1)); \\n                if (multi1*c*multi2 < ans) {\\n                    res = left == 0? \"\" : expression.substr(0, left) + \"(\" + expression.substr(left, right-left+1) + \")\" + (right == expression.size()-1? \"\" : expression.substr(right+1));\\n                    ans = multi1*c * multi2;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minimizeResult(string expression) {\\n        int pos_plus = 0; \\n        for (; pos_plus < expression.size(); pos_plus++) {\\n            if (expression[pos_plus] == \\'+\\') break;\\n        }\\n        int left = 0, right = expression.size()-1; \\n        int ans = INT_MAX;\\n        string res; \\n        for (; left < pos_plus; left++) {\\n            for (; right > pos_plus; right--) {\\n                int a = stoi(expression.substr(left+1, pos_plus-left-1)); \\n                int b = stoi(expression.substr(pos_plus+1, right-pos_plus-1));\\n                int c = a+b;\\n                int multi1 = left == 0? 1 : stoi(expression.substr(0, left)); \\n                int multi2 = right == expression.size()-1? 1 : stoi(expression.substr(right+1)); \\n                if (multi1*c*multi2 < ans) {\\n                    res = left == 0? \"\" : expression.substr(0, left) + \"(\" + expression.substr(left, right-left+1) + \")\" + (right == expression.size()-1? \"\" : expression.substr(right+1));\\n                    ans = multi1*c * multi2;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984549,
                "title": "overkill-for-the-constraints-but-o-n-in-time-and-space",
                "content": "I didn\\'t replaced the stoi and substr by a function that could fully enable it to be really O(n) but it can be done by multiplying and dividng the values as we move the possible parenthesis possition. here is the idea:\\n\\nUsing the convex hull trick we can obtain a O(n) in time and space for this problem:\\nConsidering the problem as solving A(B+C)D we can consider it as (A\\\\*B+A\\\\*C)D.  So each possibility on the left side of the + sign can be represented as a line  Ax+A\\\\*B. So we can construct a lower hull starting from the largest A (which is the largest substring in the left of the +) and insert it in a vector. \\n\\nFor the right side we start from the smallest C number and test against de vector. Since our queries are in order there is no need to search for the best matching line, as we can discard the lines that are not optimal for values smallers than C.\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n  vector<pair<double, array<int, 3>>> lines;\\n\\n  double inline intersect(const array<int, 3> &a, const array<int, 3> &b) {\\n    double c = a[0] - b[0];\\n    double d = b[1] - a[1];\\n    return d / c;\\n  }\\n  string minimizeResult(string expression) {\\n    int plus_pos = 0;\\n    auto e = expression;\\n    for (; plus_pos < expression.size() && expression[plus_pos] != \\'+\\';\\n         plus_pos++)\\n      ;\\n    for (int i = plus_pos - 1; i >= 0; i--) {\\n      auto a_sum = stoi(e.substr(i, plus_pos - i));\\n      auto a_mul = 1;\\n      if (i != 0)\\n        a_mul = stoi(e.substr(0, i));\\n      array<int, 3> n = {a_mul, a_sum * a_mul, i};\\n      if (lines.empty()) {\\n        lines.push_back({numeric_limits<double>::max(), n});\\n        continue;\\n      }\\n      pair<double, array<int, 3>> prev;\\n      double ip_prev;\\n      bool zeros = false;\\n      while (!lines.empty()) {\\n        auto cur = lines.back();\\n        if (cur.second[0] == 0 && n[0] == 0) {\\n          zeros = true;\\n          break;\\n        }\\n        auto ip = intersect(cur.second, n);\\n        if (ip >= cur.first)\\n          break;\\n        prev = lines.back();\\n        ip_prev = ip;\\n        lines.resize(lines.size() - 1);\\n      }\\n      if (zeros)\\n        continue;\\n\\n      lines.push_back({{ip_prev}, prev.second});\\n      lines.push_back({numeric_limits<double>::max(), n});\\n    }\\n    auto min_mul = numeric_limits<int>::max();\\n    array<int, 2> i_mul;\\n    int best_line = 0;\\n    for (int i = plus_pos + 1; i < e.size(); i++) {\\n      auto b_sum = stoi(e.substr(plus_pos + 1, i - plus_pos));\\n      auto b_mul = 1;\\n      double prev_end = -1;\\n      if (i != e.size() - 1)\\n        b_mul = stoi(e.substr(i + 1, e.size() - 1 - i));\\n      for (; best_line < lines.size(); best_line++) {\\n        if (prev_end < b_sum && lines[best_line].first > b_sum) {\\n          break;\\n        }\\n      }\\n      auto lb = lines[best_line];\\n      // cout<<\"best line\"<<best_line<<endl;\\n      auto c_mul = b_mul * (b_sum * lb.second[0] + lb.second[1]);\\n\\n      if (c_mul < min_mul) {\\n        i_mul = {lb.second[2], i};\\n        min_mul = c_mul;\\n      }\\n    }\\n    string res;\\n    int i = 0;\\n    for (; i < i_mul[0]; i++)\\n      res += e[i];\\n    res += \"(\";\\n    for (; i < i_mul[1] + 1; i++)\\n      res += e[i];\\n\\n    res += \")\";\\n    for (; i < e.size(); i++)\\n      res += e[i];\\n\\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n  vector<pair<double, array<int, 3>>> lines;\\n\\n  double inline intersect(const array<int, 3> &a, const array<int, 3> &b) {\\n    double c = a[0] - b[0];\\n    double d = b[1] - a[1];\\n    return d / c;\\n  }\\n  string minimizeResult(string expression) {\\n    int plus_pos = 0;\\n    auto e = expression;\\n    for (; plus_pos < expression.size() && expression[plus_pos] != \\'+\\';\\n         plus_pos++)\\n      ;\\n    for (int i = plus_pos - 1; i >= 0; i--) {\\n      auto a_sum = stoi(e.substr(i, plus_pos - i));\\n      auto a_mul = 1;\\n      if (i != 0)\\n        a_mul = stoi(e.substr(0, i));\\n      array<int, 3> n = {a_mul, a_sum * a_mul, i};\\n      if (lines.empty()) {\\n        lines.push_back({numeric_limits<double>::max(), n});\\n        continue;\\n      }\\n      pair<double, array<int, 3>> prev;\\n      double ip_prev;\\n      bool zeros = false;\\n      while (!lines.empty()) {\\n        auto cur = lines.back();\\n        if (cur.second[0] == 0 && n[0] == 0) {\\n          zeros = true;\\n          break;\\n        }\\n        auto ip = intersect(cur.second, n);\\n        if (ip >= cur.first)\\n          break;\\n        prev = lines.back();\\n        ip_prev = ip;\\n        lines.resize(lines.size() - 1);\\n      }\\n      if (zeros)\\n        continue;\\n\\n      lines.push_back({{ip_prev}, prev.second});\\n      lines.push_back({numeric_limits<double>::max(), n});\\n    }\\n    auto min_mul = numeric_limits<int>::max();\\n    array<int, 2> i_mul;\\n    int best_line = 0;\\n    for (int i = plus_pos + 1; i < e.size(); i++) {\\n      auto b_sum = stoi(e.substr(plus_pos + 1, i - plus_pos));\\n      auto b_mul = 1;\\n      double prev_end = -1;\\n      if (i != e.size() - 1)\\n        b_mul = stoi(e.substr(i + 1, e.size() - 1 - i));\\n      for (; best_line < lines.size(); best_line++) {\\n        if (prev_end < b_sum && lines[best_line].first > b_sum) {\\n          break;\\n        }\\n      }\\n      auto lb = lines[best_line];\\n      // cout<<\"best line\"<<best_line<<endl;\\n      auto c_mul = b_mul * (b_sum * lb.second[0] + lb.second[1]);\\n\\n      if (c_mul < min_mul) {\\n        i_mul = {lb.second[2], i};\\n        min_mul = c_mul;\\n      }\\n    }\\n    string res;\\n    int i = 0;\\n    for (; i < i_mul[0]; i++)\\n      res += e[i];\\n    res += \"(\";\\n    for (; i < i_mul[1] + 1; i++)\\n      res += e[i];\\n\\n    res += \")\";\\n    for (; i < e.size(); i++)\\n      res += e[i];\\n\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1969298,
                "title": "0ms-c-beginner-friendly-approach-well-commented-code",
                "content": "**Time Complexity: O(mn)**\\nwhere, m = number of possible places for \\'(\\' on the LHS of \\'+ \\nand n = number of possible places for \\')\\' on the RHS of \\'+\\'.\\n\\nIf we take example input = \"247+38\"\\nm = 3 since (247, 2(47, 24(7 are the possible cases on LHS and\\nn = 2 since 3)8, 38) are the possible cases on RHS.\\nSo number of expressions that are possible with above cases are mxn = 3x2 = 6\\n(Apply Permutations and combinations logic).\\nThey are as follows:\\n(247+38)\\n(247+3)8\\n2(47+38)\\n2(47+3)8\\n24(7+38)\\n24(7+3)8\\nGenerate all these possible expressions and evaluate them and update \\'value\\' whenever smallest value of expression is found. Accordingly also update the \\'ans\\' string.\\n\\nBelow is the code with explanation of variables and each step -\\n```\\nclass Solution {\\npublic:\\n    \\n    int getIntFromStr(string s){\\n        int ans = 0;\\n        stringstream ss(s);\\n        ss >> ans;\\n        return ans;\\n    }\\n    \\n    string minimizeResult(string expression) {\\n        int i,j;\\n        int len = expression.length();\\n        \\n        // Get the index of \\'+\\'\\n        for(i=0;i<len;i++){\\n            if(expression[i]==\\'+\\')\\n                break;\\n        }\\n        \\n        // Declare the left_max to index just before that of \\'+\\' because this is the maximum possible index on the left side of \\'+\\'.\\n        int left_max = i-1;\\n        // Declare the right_min to index just after that of \\'+\\' because this is the minimum possible index on the right side of \\'+\\'.\\n        int right_min = i+1;\\n        // On the left of \\'+\\' minimum possible index is 0.\\n        int left_min = 0;\\n        // On the right of \\'+\\' maximum possible index is len.\\n        int right_max = len;\\n        // Store index of \\'+\\' as well.\\n        int plus_ind = i;\\n        // \\'value\\' stores the minimum possible value of all the expressions.\\n        int value = INT_MAX;\\n        string ans = \"\";\\n        \\n        // Consider all possible places for \\'(\\' on the left side, and for each possible place we consider possible places for \\')\\' on the right side of the \\'+\\' sign.\\n        for(i=left_min;i<=left_max;i++){\\n            // Get the substring of expression in given ranges as shown below to get num1, multiply_left, num2 & multiply_right and convert those strings to integers.\\n            int num1 = getIntFromStr(string(&expression[i], &expression[plus_ind]));\\n            int multiply_left = getIntFromStr(string(&expression[left_min], &expression[i]));\\n            // If multiply_left is 0 for example in case of expression like this - (247+38) where there is no number on the left side of \\'(\\'. So set multiply_left to 1 (because will multiply it with (num1+num2) to evaluate the expression)\\n            if(multiply_left==0){\\n                multiply_left = 1;\\n            }\\n            \\n            // Consider all possible places for \\')\\' on the right side of \\'+\\'.\\n            for(j=right_min;j<right_max;j++){\\n                \\n                int num2 = getIntFromStr(string(&expression[right_min], &expression[j+1]));\\n                int multiply_right = getIntFromStr(string(&expression[j+1], &expression[right_max]));\\n                if(multiply_right==0){\\n                    multiply_right = 1;\\n                }\\n                \\n                // Evaluate the expression and store the value if it is minimum.\\n                if(multiply_left*(num1+num2)*multiply_right < value){\\n                    value = multiply_left*(num1+num2)*multiply_right;\\n                    // Construct \\'ans\\' string i.e. the expression string that gives smallest possible value.\\n                    ans = string(&expression[left_min], &expression[i]) + \"(\" + string(&expression[i], &expression[plus_ind]) + \"+\" + string(&expression[right_min], &expression[j+1]) + \")\" + string(&expression[j+1], &expression[right_max]);\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n*Kindly upvote if this solution has helped you.\\nThanks for reading! :)*",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int getIntFromStr(string s){\\n        int ans = 0;\\n        stringstream ss(s);\\n        ss >> ans;\\n        return ans;\\n    }\\n    \\n    string minimizeResult(string expression) {\\n        int i,j;\\n        int len = expression.length();\\n        \\n        // Get the index of \\'+\\'\\n        for(i=0;i<len;i++){\\n            if(expression[i]==\\'+\\')\\n                break;\\n        }\\n        \\n        // Declare the left_max to index just before that of \\'+\\' because this is the maximum possible index on the left side of \\'+\\'.\\n        int left_max = i-1;\\n        // Declare the right_min to index just after that of \\'+\\' because this is the minimum possible index on the right side of \\'+\\'.\\n        int right_min = i+1;\\n        // On the left of \\'+\\' minimum possible index is 0.\\n        int left_min = 0;\\n        // On the right of \\'+\\' maximum possible index is len.\\n        int right_max = len;\\n        // Store index of \\'+\\' as well.\\n        int plus_ind = i;\\n        // \\'value\\' stores the minimum possible value of all the expressions.\\n        int value = INT_MAX;\\n        string ans = \"\";\\n        \\n        // Consider all possible places for \\'(\\' on the left side, and for each possible place we consider possible places for \\')\\' on the right side of the \\'+\\' sign.\\n        for(i=left_min;i<=left_max;i++){\\n            // Get the substring of expression in given ranges as shown below to get num1, multiply_left, num2 & multiply_right and convert those strings to integers.\\n            int num1 = getIntFromStr(string(&expression[i], &expression[plus_ind]));\\n            int multiply_left = getIntFromStr(string(&expression[left_min], &expression[i]));\\n            // If multiply_left is 0 for example in case of expression like this - (247+38) where there is no number on the left side of \\'(\\'. So set multiply_left to 1 (because will multiply it with (num1+num2) to evaluate the expression)\\n            if(multiply_left==0){\\n                multiply_left = 1;\\n            }\\n            \\n            // Consider all possible places for \\')\\' on the right side of \\'+\\'.\\n            for(j=right_min;j<right_max;j++){\\n                \\n                int num2 = getIntFromStr(string(&expression[right_min], &expression[j+1]));\\n                int multiply_right = getIntFromStr(string(&expression[j+1], &expression[right_max]));\\n                if(multiply_right==0){\\n                    multiply_right = 1;\\n                }\\n                \\n                // Evaluate the expression and store the value if it is minimum.\\n                if(multiply_left*(num1+num2)*multiply_right < value){\\n                    value = multiply_left*(num1+num2)*multiply_right;\\n                    // Construct \\'ans\\' string i.e. the expression string that gives smallest possible value.\\n                    ans = string(&expression[left_min], &expression[i]) + \"(\" + string(&expression[i], &expression[plus_ind]) + \"+\" + string(&expression[right_min], &expression[j+1]) + \")\" + string(&expression[j+1], &expression[right_max]);\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": []
    },
    {
        "title": "Maximum Score of a Node Sequence",
        "question_content": "<p>There is an <strong>undirected</strong> graph with <code>n</code> nodes, numbered from <code>0</code> to <code>n - 1</code>.</p>\n\n<p>You are given a <strong>0-indexed</strong> integer array <code>scores</code> of length <code>n</code> where <code>scores[i]</code> denotes the score of node <code>i</code>. You are also given a 2D integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists an <strong>undirected</strong> edge connecting nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>\n\n<p>A node sequence is <b>valid</b> if it meets the following conditions:</p>\n\n<ul>\n\t<li>There is an edge connecting every pair of <strong>adjacent</strong> nodes in the sequence.</li>\n\t<li>No node appears more than once in the sequence.</li>\n</ul>\n\n<p>The score of a node sequence is defined as the <strong>sum</strong> of the scores of the nodes in the sequence.</p>\n\n<p>Return <em>the <strong>maximum score</strong> of a valid node sequence with a length of </em><code>4</code><em>. </em>If no such sequence exists, return<em> </em><code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/15/ex1new3.png\" style=\"width: 290px; height: 215px;\" />\n<pre>\n<strong>Input:</strong> scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]\n<strong>Output:</strong> 24\n<strong>Explanation:</strong> The figure above shows the graph and the chosen node sequence [0,1,2,3].\nThe score of the node sequence is 5 + 2 + 9 + 8 = 24.\nIt can be shown that no other node sequence has a score of more than 24.\nNote that the sequences [3,1,2,0] and [1,0,2,3] are also valid and have a score of 24.\nThe sequence [0,3,2,4] is not valid since no edge connects nodes 0 and 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/17/ex2.png\" style=\"width: 333px; height: 151px;\" />\n<pre>\n<strong>Input:</strong> scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> The figure above shows the graph.\nThere are no valid node sequences of length 4, so we return -1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == scores.length</code></li>\n\t<li><code>4 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= scores[i] &lt;= 10<sup>8</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>There are no duplicate edges.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1953669,
                "title": "python-explanation-with-pictures-top-3-neighbors",
                "content": "Since it\\'s a chain of 4, we focus on the middle pair `(a, b)` of a chain `(X-a-b-Y)`.  Apparently, a-b must be in edges.\\n\\nThus the general idea is to traverse over all edges `(a, b)`. Among all the neighbors of `a`, we find the neighbor X with the largest score. Similarly, find the largest neighbor Y of node b , hence the maximum score centered on a-b is `X+a+b+Y`.\\n\\n![image](https://assets.leetcode.com/users/images/a5afa09d-a97e-42d5-834f-3caa63134d53_1650124916.8052251.png)\\n\\nNotice that we don\\'t need to store information of all the neighbors of a node because we only need the node with the largest score,  thus saving 3 neighboring nodes is enough. Please refer to the picture below.\\n\\n> Why we don\\'t save all the neighbors? \\n> Because it will bring O(n^2) time complexity and we don\\'t need that much information.\\n> \\n> Why we have to save up to 3 neighbors?\\n> Consider three nodes (a, b, c) are all connected as shown in the left part of the picture below, both `a` and `b` have two neighbors but we can\\'t find a chain of 4, cause they are both connected to `c`. \\n\\n![image](https://assets.leetcode.com/users/images/61568a8a-9cd7-4505-8b88-a7c4ae8c8f76_1650124920.2967174.png)\\n\\nTherefore, during the iteration, find out the largest neighbors (no duplicates) and get the maximum score for the current pair.\\n\\n![image](https://assets.leetcode.com/users/images/c899277f-d433-40c5-a9b4-9ca2fa1b09e3_1650124924.807308.png)\\n\\n\\n**complexity**\\nTime: O(n)\\nSpace: O(n)\\n\\n\\n**code**\\n```\\nclass Solution:\\n    def maximumScore(self, A: List[int], E: List[List[int]]) -> int:\\n        n = len(A)\\n        \\n        # Store the top 3 neighbors of a node.\\n        top3 = collections.defaultdict(list)\\n        \\n        def func(a, b, e):\\n            bisect.insort_left(top3[a], [e, b])\\n            if len(top3[a]) > 3:\\n                top3[a].pop(0)\\n        \\n        # Update the information of top 3 neighbors of each node\\n        for a, b in E:\\n            func(a, b, A[b])\\n            func(b, a, A[a])\\n        \\n        ans = -1\\n        for a, b in E:\\n            # If there is less than 2 neighbors of a node, skip this pair.\\n            if len(top3[a]) < 2 or len(top3[b]) < 2:\\n                continue\\n            for c in top3[a]:\\n                for d in top3[b]:\\n                    # Find the maximum score of two non-duplicated neighbors of a and b.\\n                    if c[1] not in [a, b] and d[1] not in [a, b] and c[1] != d[1]:\\n                        ans = max(ans, A[a] + A[b] + c[0] + d[0])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumScore(self, A: List[int], E: List[List[int]]) -> int:\\n        n = len(A)\\n        \\n        # Store the top 3 neighbors of a node.\\n        top3 = collections.defaultdict(list)\\n        \\n        def func(a, b, e):\\n            bisect.insort_left(top3[a], [e, b])\\n            if len(top3[a]) > 3:\\n                top3[a].pop(0)\\n        \\n        # Update the information of top 3 neighbors of each node\\n        for a, b in E:\\n            func(a, b, A[b])\\n            func(b, a, A[a])\\n        \\n        ans = -1\\n        for a, b in E:\\n            # If there is less than 2 neighbors of a node, skip this pair.\\n            if len(top3[a]) < 2 or len(top3[b]) < 2:\\n                continue\\n            for c in top3[a]:\\n                for d in top3[b]:\\n                    # Find the maximum score of two non-duplicated neighbors of a and b.\\n                    if c[1] not in [a, b] and d[1] not in [a, b] and c[1] != d[1]:\\n                        ans = max(ans, A[a] + A[b] + c[0] + d[0])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953706,
                "title": "java-python-keep-3-biggest-neighbours",
                "content": "# **Intuition**\\nWe don\\'t need to check all possible sequences,\\nbut only some big nodes.\\n<br>\\n\\n# **Explanation**\\nFor each edge `(i, j)` in `edges`,\\nwe find a neighbour `ii` of node `i`,\\nwe find a neighbour `jj` of node `i`,\\nIf `ii, i, j,jj` has no duplicate, then that\\'s a valid sequence.\\n\\nAd the intuition mentioned,\\nwe don\\'t have to enumearte all neignbours,\\nbut only some nodes with big value.\\n\\nBut how many is enough?\\nI\\'ll say 3.\\nFor example, we have `ii, i, j` now,\\nwe can enumerate 3 of node `j` biggest neighbour,\\nthere must be at least one node different node `ii` and node `i`.\\n\\nSo we need to iterate all edges `(i, j)`,\\nfor each node we keep at most 3 biggest neighbour, which this can be done in `O(3)` or `O(log3)`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n + m)`\\nSpace `O(n + m)`\\n<br>\\n\\n**Java**\\n```java\\n    public int maximumScore(int[] A, int[][] edges) {\\n        int n = A.length;\\n        PriorityQueue<Integer>[] q = new PriorityQueue[n];\\n        for (int i = 0; i < n; i++)\\n            q[i] = new PriorityQueue<>((a, b) -> A[a] - A[b]);\\n        for (int[] e : edges) {\\n            q[e[0]].offer(e[1]);\\n            q[e[1]].offer(e[0]);\\n            if (q[e[0]].size() > 3) q[e[0]].poll();\\n            if (q[e[1]].size() > 3) q[e[1]].poll();\\n        }\\n        int res = -1;\\n        for (int[] edge : edges)\\n            for (int i : q[edge[0]])\\n                for (int j : q[edge[1]])\\n                    if (i != j && i != edge[1] && j != edge[0])\\n                        res = Math.max(res, A[i] + A[j] + A[edge[0]] + A[edge[1]]);  \\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def maximumScore(self, A, edges):\\n        n = len(A)\\n        G = [[] for i in range(n)]\\n        for i,j in edges:\\n            G[i].append([A[j], j])\\n            G[j].append([A[i], i])\\n        for i in range(n):\\n            G[i] = nlargest(3, G[i])\\n            \\n        res = -1\\n        for i,j  in edges:\\n            for vii, ii in G[i]:\\n                for vjj, jj in G[j]:\\n                    if ii != jj and ii != j and j != ii:\\n                        res = max(res, vii + vjj + A[i] + A[j])\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java\\n    public int maximumScore(int[] A, int[][] edges) {\\n        int n = A.length;\\n        PriorityQueue<Integer>[] q = new PriorityQueue[n];\\n        for (int i = 0; i < n; i++)\\n            q[i] = new PriorityQueue<>((a, b) -> A[a] - A[b]);\\n        for (int[] e : edges) {\\n            q[e[0]].offer(e[1]);\\n            q[e[1]].offer(e[0]);\\n            if (q[e[0]].size() > 3) q[e[0]].poll();\\n            if (q[e[1]].size() > 3) q[e[1]].poll();\\n        }\\n        int res = -1;\\n        for (int[] edge : edges)\\n            for (int i : q[edge[0]])\\n                for (int j : q[edge[1]])\\n                    if (i != j && i != edge[1] && j != edge[0])\\n                        res = Math.max(res, A[i] + A[j] + A[edge[0]] + A[edge[1]]);  \\n        return res;\\n    }\\n```\n```py\\n    def maximumScore(self, A, edges):\\n        n = len(A)\\n        G = [[] for i in range(n)]\\n        for i,j in edges:\\n            G[i].append([A[j], j])\\n            G[j].append([A[i], i])\\n        for i in range(n):\\n            G[i] = nlargest(3, G[i])\\n            \\n        res = -1\\n        for i,j  in edges:\\n            for vii, ii in G[i]:\\n                for vjj, jj in G[j]:\\n                    if ii != jj and ii != j and j != ii:\\n                        res = max(res, vii + vjj + A[i] + A[j])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1953635,
                "title": "detailed-explanation-concise-python-solution-with-useful-libraries",
                "content": "This is a Google interview problem that has been [fairly common over the past few months.](https://leetcode.com/discuss/interview-question/1621880/Google-or-Onsite-or-Maximum-total/1176827) I think it\\'s pretty hard, so I\\'m going to give a detailed explanation and show you the very concise code that I wrote to solve it. If you\\'re a Python user, maybe you\\'ll learn some useful libraries with this, too.\\n\\nFirst, let\\'s make sure we understand what the problem\\'s asking. Given an undirected graph, let\\'s consider all sets of 4 verticies with this property: \\n- The vertices can be assigned names A,B,C,D such that the nodes in pairs (A, B), (B, C), and (C, D) are connected to one another. \\n\\nLet\\'s call any set of 4 verticies with this property a **quadruplet.** The task is to return the maximum sum of values of any quadruplet. So how do we do it?\\n\\nThe simplest solution that I can think of is to check every single quadruplet in the graph and return the maximum. That might work, but I\\'m concerned about the time complexity; if the graph has a lot of edges, then there will be a lot of quadruplets to check, and we might TLE. (I haven\\'t tested this myself though)\\n\\nLet\\'s try to find something a bit more optimal. Consider every edge in our graph. For each edge, let\\'s consider it the edge between (B, C), and try to make an optimal quadruplet (A, B, C, D) out of the neighbors of B and C. We get A from B\\'s neighbors, and D from C\\'s neighbors.\\n\\nWe can do this with a little preprocessing. For each node N, find up to 3 neighbors of N for which the values of these neighbors are maximum. These neighbors are the only ones that can possibly appear in a highest-value quadruplet. Why 3? Because for nodes (B, C), two things are possible:\\n1. One of the highest-value nodes from B is C.\\n2. One of the highest-value nodes from B is also connected to C.\\n\\nIn either case, we\\'ll have at least one redundant node, so we have to account for that by having three possible neighbors to pick from at each node.\\n\\nSo, for every (B, C) in our edge list, try every combination of possible A coming out of B and every possible D coming out of C. You can do this sort of haphazardly because we know we\\'ll always have at least 4 nodes in the input, and our node weights are always positive; if not, you\\'d have to detect when we use a redundant node. But I didn\\'t notice the n >= 4 and w >= 0 limit before solving it, so I check for redudant nodes in my solution.\\n\\nSolution and complexity analysis:\\n\\n```\\n# defaultdict is the same as Python\\'s usual dictionary, but if an\\n# element doesn\\'t exist, you can give it a default value to initialize with. \\nfrom collections import defaultdict\\n# nlargest(n, l) - returns the n largest values of collection l.\\nfrom heapq import nlargest\\n# \"product\" is a function that takes two collections and \\n# returns every pair between them.\\n# product(\"ab\", \"cd\") = [(a, c), (a, d), (b, c), (b, d)].\\nfrom itertools import product\\n\\nLet V be the number of nodes and E = len(edges).\\n# Time complexity: O(V + E) - we iterate through every vertex \\n#                  and every edge a constant number of times.\\n# Space complexity: O(V) - we save a constant \\n#                   number of neighbors (3) for every node.\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        # Turn the edge list into an adjacency graph.\\n        m = defaultdict(list)\\n        for u, v in edges:\\n            m[u].append((scores[v], v)) \\n            m[v].append((scores[u], u))\\n        \\n        # Cut down all neighbors of each node to the three\\n        # that have the highest value.\\n        for u in m:\\n            m[u] = nlargest(3, m[u])\\n\\n        ret = -1\\n        # Consider each edge to potentially be (B, C) for a quadruplet.\\n        for b, c in edges:\\n            # For every possible A and D in the neighbors of B and C...\\n            for (aWeight, a), (dWeight, d) in product(m[b], m[c]):\\n                # ... If we have no redundant nodes, it\\'s a quadruplet.\\n                # Since it\\'s the highest value quadruplet we could\\n                # possibly make with B and C, this solution is always accurate.\\n                if a not in [b, c] and d not in [b, c] and a != d:\\n                    ret = max(ret, scores[b] + scores[c] + aWeight + dWeight)\\n                    \\n        return ret\\n```\\n\\n**Please ask any questions below, and leave an upvote if this was helpful!**",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n# defaultdict is the same as Python\\'s usual dictionary, but if an\\n# element doesn\\'t exist, you can give it a default value to initialize with. \\nfrom collections import defaultdict\\n# nlargest(n, l) - returns the n largest values of collection l.\\nfrom heapq import nlargest\\n# \"product\" is a function that takes two collections and \\n# returns every pair between them.\\n# product(\"ab\", \"cd\") = [(a, c), (a, d), (b, c), (b, d)].\\nfrom itertools import product\\n\\nLet V be the number of nodes and E = len(edges).\\n# Time complexity: O(V + E) - we iterate through every vertex \\n#                  and every edge a constant number of times.\\n# Space complexity: O(V) - we save a constant \\n#                   number of neighbors (3) for every node.\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        # Turn the edge list into an adjacency graph.\\n        m = defaultdict(list)\\n        for u, v in edges:\\n            m[u].append((scores[v], v)) \\n            m[v].append((scores[u], u))\\n        \\n        # Cut down all neighbors of each node to the three\\n        # that have the highest value.\\n        for u in m:\\n            m[u] = nlargest(3, m[u])\\n\\n        ret = -1\\n        # Consider each edge to potentially be (B, C) for a quadruplet.\\n        for b, c in edges:\\n            # For every possible A and D in the neighbors of B and C...\\n            for (aWeight, a), (dWeight, d) in product(m[b], m[c]):\\n                # ... If we have no redundant nodes, it\\'s a quadruplet.\\n                # Since it\\'s the highest value quadruplet we could\\n                # possibly make with B and C, this solution is always accurate.\\n                if a not in [b, c] and d not in [b, c] and a != d:\\n                    ret = max(ret, scores[b] + scores[c] + aWeight + dWeight)\\n                    \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953681,
                "title": "c-o-e-try-every-edge-find-2-more-best-nodes-one-per-each-edge-side",
                "content": "The idea: try every edge, and select one more adjacent node per each of the edge ends.\\nThe selected additional nodes must not be intersected with each other and with the other edge nodes.\\nAlso there must be effective way to select additional nodes, so they provide max result. To achieve this - we can sort the adjacency list for each vertice (according to `scores`).\\nWe must try 3 best nodes for each of the edge side (because they are optimal, and if we try just 1 or 2 best nodes - there could be intersections - which is not allowed) - so try at most 9 combinations per each edge.\\n**Optimization**: as we need just 3 top scored neighbours per each edge side - instead of full adjacency list sorting we can utilize a PriorityQueue to find top 3 nodes - this will decrease our time complexity from `O(Elog(E))` to `O(E)`\\n![image](https://assets.leetcode.com/users/images/9f87370b-aaa6-43fa-891b-457d9a9158b0_1650123302.7105124.png)\\n1. Create adjacency list\\n2. Sort adjacency list, so best adjacent nodes are in the beginning\\n\\t2.1 Optimized: no need to sort the full list - we need just 3 top scored adjacent nodes - so use PriorityQueue, find top 3 adjacent nodes\\n3. Try each edge:\\n\\ttry <= 3 best adjacent nodes for each edge side. If no intersections - we have a sequence of 4 nodes (the current edge is in the middle), update result.\\n\\t\\nTime complexity:\\n`O(E log(E))` for adjacency list sorting\\n`O(E*9) = O(E)` for iterating over edges\\nTotal: `O(E log(E))`\\n`E` is edges count\\n\\n```cpp\\nint maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        const int n = scores.size();\\n        vector<vector<int>> adj(n);\\n        for (const vector<int>& edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        for (vector<int>& a : adj) {\\n            sort(a.begin(), a.end(), [&scores](const int l, const int r) { return scores[l] > scores[r]; });\\n        }\\n        \\n        int result = -1;\\n        for (const vector<int>& edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            int base = scores[u] + scores[v];\\n            for (int i = 0; i < min(3, (int)adj[u].size()); ++i) {\\n                int x = adj[u][i];\\n                \\n                if (x == v) continue; // intersection - not allowed, continue\\n                \\n                for (int j = 0; j < min(3, (int)adj[v].size()); ++j) {\\n                    int y = adj[v][j];\\n                    \\n                    if (y == u || x == y) continue; // intersection - not allowed, continue\\n                    \\n                    result = max(result, base + scores[x] + scores[y]);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```\\n\\n**Optimized with PriorityQueue, time complexity:**\\n`O(E)` for adjacency list top scored 3 finding\\n`O(E*9) = O(E)` for iterating over edges\\nTotal: `O(E)`\\n`E` is edges count\\n```cpp\\nint maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        const int n = scores.size();\\n        vector<vector<int>> adj(n);\\n        for (const vector<int>& edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        for (vector<int>& a : adj) {\\n            // priority queue for top scored 3 vertices:\\n            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\\n            for (int v : a) {\\n                int score = scores[v];\\n                if (pq.size() < 3 || pq.top().first < score) {\\n                    pq.push({score, v});\\n                    if (pq.size() > 3) {\\n                        pq.pop();\\n                    }\\n                }\\n            }\\n            a.resize(pq.size());\\n            for (int i = a.size() - 1; i >= 0; --i) {\\n                a[i] = pq.top().second;\\n                pq.pop();\\n            }\\n        }\\n        \\n        int result = -1;\\n        for (const vector<int>& edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            int base = scores[u] + scores[v];\\n            for (int x : adj[u]) {\\n                if (x == v) continue; // intersection - not allowed, continue\\n                \\n                for (int y : adj[v]) {\\n                    if (y == u || x == y) continue; // intersection - not allowed, continue\\n                    \\n                    result = max(result, base + scores[x] + scores[y]);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```\\n\\n\\nWhy 3 nodes (no more but no less) per each edge side are interesting?\\nE.g., if we handle the edge **[0-1]**, and highest score neighbours for the **0** node are: 1,2,3,4 (sorted from highest score to lowest):\\n![image](https://assets.leetcode.com/users/images/da9443a5-44ee-420b-aeca-630bf350bdc0_1650130719.196484.png)\\nIf we try just 1 or 2 top score neighbors for the node **0** - it can intersect with other edge side (node **1**), or with the node which is optimal for other edge side (node **2**) - in this case we will not be able to get optimal node for other edge side, or we couldn\\'t even find any node for other side. But if we try 3 nodes per each side - we guarantee to avoid intersection with (optimal) nodes from other side. At the picture it is required to try the node **3** (which is 3rd optimal for the node **0**) - so we\\'ll have a **3-0-1-2** quadriplet, which is optimal. If we try only nodes **1** and **2** - we will not be able to find any valid neighbout for the node **1**, which is on the other side of the edge - so there will be no quadriplet.",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\nint maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        const int n = scores.size();\\n        vector<vector<int>> adj(n);\\n        for (const vector<int>& edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        for (vector<int>& a : adj) {\\n            sort(a.begin(), a.end(), [&scores](const int l, const int r) { return scores[l] > scores[r]; });\\n        }\\n        \\n        int result = -1;\\n        for (const vector<int>& edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            int base = scores[u] + scores[v];\\n            for (int i = 0; i < min(3, (int)adj[u].size()); ++i) {\\n                int x = adj[u][i];\\n                \\n                if (x == v) continue; // intersection - not allowed, continue\\n                \\n                for (int j = 0; j < min(3, (int)adj[v].size()); ++j) {\\n                    int y = adj[v][j];\\n                    \\n                    if (y == u || x == y) continue; // intersection - not allowed, continue\\n                    \\n                    result = max(result, base + scores[x] + scores[y]);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```\n```cpp\\nint maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        const int n = scores.size();\\n        vector<vector<int>> adj(n);\\n        for (const vector<int>& edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        for (vector<int>& a : adj) {\\n            // priority queue for top scored 3 vertices:\\n            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\\n            for (int v : a) {\\n                int score = scores[v];\\n                if (pq.size() < 3 || pq.top().first < score) {\\n                    pq.push({score, v});\\n                    if (pq.size() > 3) {\\n                        pq.pop();\\n                    }\\n                }\\n            }\\n            a.resize(pq.size());\\n            for (int i = a.size() - 1; i >= 0; --i) {\\n                a[i] = pq.top().second;\\n                pq.pop();\\n            }\\n        }\\n        \\n        int result = -1;\\n        for (const vector<int>& edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            int base = scores[u] + scores[v];\\n            for (int x : adj[u]) {\\n                if (x == v) continue; // intersection - not allowed, continue\\n                \\n                for (int y : adj[v]) {\\n                    if (y == u || x == y) continue; // intersection - not allowed, continue\\n                    \\n                    result = max(result, base + scores[x] + scores[y]);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1954475,
                "title": "top-3",
                "content": "Such a deceptive problem. With the problem constraints, exploring paths - even with some sort of memoisation - would not cut it.\\n\\nThe idea is to consider each pair of nodes, connected by an edge, as the middle of the path. That way, we can just pick the highest-score neighbor for each node in the pair.\\n\\n> When picking neighbors, we make sure we do not pick another node in the pair, or a shared neighbor we already picked.\\n\\nSince a node could have a lot of neighbors, searching for the highest-score neighbor each time is slow, and results in TLE. Therefore, we can pre-sort the neighbors of each node, and check no more than top 3 neighbors. Why top 3? Because 2 out of these top 3 neighbors may not a valid pick for a given pair (another node in the pair, or a shared neighbor we already picked).\\n\\n![image](https://assets.leetcode.com/users/images/fcbf8b2a-4fb0-4129-91c8-5637430f5108_1650138032.7320812.png)\\n\\n**C++**\\nI tried using a heap, or a set, but partial sort resulted in the best runtime. We do not have to trim neighbors array; the code just looks a bit cleaner.\\n```cpp\\nint maximumScore(vector<int>& sc, vector<vector<int>>& edges) {\\n    int res = -1;\\n    vector<vector<int>> al(sc.size());\\n    for (auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    for(auto &l : al) {\\n        partial_sort(begin(l), begin(l) + min((int)l.size(), 3), end(l), [&](int i, int j){ return sc[i] > sc[j]; });\\n        l.resize(min((int)l.size(), 3));\\n    }\\n    for (auto &e : edges)\\n        for (int in : al[e[0]])\\n            for (int jn : al[e[1]])\\n                if (in != e[1] && jn != e[0] && in != jn)\\n                    res = max(res, sc[e[0]] + sc[e[1]] + sc[in] + sc[jn]);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint maximumScore(vector<int>& sc, vector<vector<int>>& edges) {\\n    int res = -1;\\n    vector<vector<int>> al(sc.size());\\n    for (auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    for(auto &l : al) {\\n        partial_sort(begin(l), begin(l) + min((int)l.size(), 3), end(l), [&](int i, int j){ return sc[i] > sc[j]; });\\n        l.resize(min((int)l.size(), 3));\\n    }\\n    for (auto &e : edges)\\n        for (int in : al[e[0]])\\n            for (int jn : al[e[1]])\\n                if (in != e[1] && jn != e[0] && in != jn)\\n                    res = max(res, sc[e[0]] + sc[e[1]] + sc[in] + sc[jn]);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1953627,
                "title": "python3-simple-solution-with-a-clear-explanation",
                "content": "It is a well-designed problem. The solution isn\\'t easy to find but is very simple indeed.\\nTrying every combination has a time complexity of `O(n^4)` and will undoubtedly break the time limit. However, the amount of total edges is small, which gives us a hint about how to solve this problem.\\nInstead of enumerating every node, we can try edges instead. The question becomes finding two more nodes connecting to each side of an edge.\\nTo maximize the result, we can use greedy approach. After the adjacency list is calculated, we sort every node\\'s linking table according to the scores of the nodes. Then we iterate through edges and try the first three nodes of every side. The reason is that the node is connecting to the other side, and they may be connecting to the same node as well. But the question requires the nodes in the sequence to be distinct. So we must try at least three nodes and rule out the wrong answer.\\nCode:\\n```\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        n = len(scores)\\n        edge = [[] for _ in range(n)]\\n        for u, v in edges:\\n            edge[u].append(v)\\n            edge[v].append(u)\\n        for l in edge:\\n            l.sort(key=lambda x:scores[x], reverse=True)\\n        ans = -1\\n        for u, v in edges:\\n            for x1 in range(min(3, len(edge[u]))):\\n                for y1 in range(min(3, len(edge[v]))):\\n                    x = edge[u][x1]\\n                    y = edge[v][y1]\\n                    if x != u and x != v and y != u and y != v and x != y:\\n                        ans = max(ans, scores[u] + scores[v] + scores[x] + scores[y])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        n = len(scores)\\n        edge = [[] for _ in range(n)]\\n        for u, v in edges:\\n            edge[u].append(v)\\n            edge[v].append(u)\\n        for l in edge:\\n            l.sort(key=lambda x:scores[x], reverse=True)\\n        ans = -1\\n        for u, v in edges:\\n            for x1 in range(min(3, len(edge[u]))):\\n                for y1 in range(min(3, len(edge[v]))):\\n                    x = edge[u][x1]\\n                    y = edge[v][y1]\\n                    if x != u and x != v and y != u and y != v and x != y:\\n                        ans = max(ans, scores[u] + scores[v] + scores[x] + scores[y])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953670,
                "title": "c-o-e-edge-traverse",
                "content": "Save 3 highest score neighbours for each node.\\nThen we traverse each `a-b`, and try to append `c`, `d` that `c-a-b-d` is a valid sequence.\\nComplexity: O(E)\\n\\n```\\nclass Solution {\\n    //sort and only save 3 of highest score neighbours\\n    void push_rank(const vector<int>& scores, vector<int> &rank, int node) {\\n        rank.push_back(node);\\n        for (int i = (int)rank.size() - 1; i - 1 >= 0; i--) {\\n            if (scores[rank[i]] > scores[rank[i - 1]]) {\\n                swap(rank[i], rank[i - 1]);\\n            }\\n        }\\n        if (rank.size() > 3) {\\n            rank.pop_back();\\n        }\\n    }\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n = scores.size();\\n        vector<vector<int>> ranks(n);    //node -> sorted [highest score neighbour node]\\n        for (const vector<int> &edge : edges) {\\n            int a = edge[0];\\n            int b = edge[1];\\n            push_rank(scores, ranks[a], b);\\n            push_rank(scores, ranks[b], a);\\n        }\\n        int result = -1;\\n        for (const vector<int> &edge : edges) {\\n            int a = edge[0];\\n            int b = edge[1];\\n            for (int c : ranks[a]) {\\n                for (int d : ranks[b]) {\\n                    if (c == b || c == d || d == a) {\\n                        continue;\\n                    }\\n                    // a, b, c, d are different\\n                    result = max(result, scores[a] + scores[b] + scores[c] + scores[d]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //sort and only save 3 of highest score neighbours\\n    void push_rank(const vector<int>& scores, vector<int> &rank, int node) {\\n        rank.push_back(node);\\n        for (int i = (int)rank.size() - 1; i - 1 >= 0; i--) {\\n            if (scores[rank[i]] > scores[rank[i - 1]]) {\\n                swap(rank[i], rank[i - 1]);\\n            }\\n        }\\n        if (rank.size() > 3) {\\n            rank.pop_back();\\n        }\\n    }\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n = scores.size();\\n        vector<vector<int>> ranks(n);    //node -> sorted [highest score neighbour node]\\n        for (const vector<int> &edge : edges) {\\n            int a = edge[0];\\n            int b = edge[1];\\n            push_rank(scores, ranks[a], b);\\n            push_rank(scores, ranks[b], a);\\n        }\\n        int result = -1;\\n        for (const vector<int> &edge : edges) {\\n            int a = edge[0];\\n            int b = edge[1];\\n            for (int c : ranks[a]) {\\n                for (int d : ranks[b]) {\\n                    if (c == b || c == d || d == a) {\\n                        continue;\\n                    }\\n                    // a, b, c, d are different\\n                    result = max(result, scores[a] + scores[b] + scores[c] + scores[d]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115209,
                "title": "java-o-n-easy-solution-with-comments",
                "content": "Please upvote if you like the solution.\\n\\n```\\nclass Solution {\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        \\n        Map<Integer, ArrayList<Integer>> map = new HashMap<Integer, ArrayList<Integer>>();\\n        \\n        // initialize nodes arraylists takes O(n)\\n        for(int i =0; i< scores.length;i++)\\n        {\\n           map.put(i,new ArrayList<Integer>()); \\n        }\\n        \\n        // add bidirectional edges to respective nodes to indicate a connection between them\\n        // again takes O(e) time\\n        for(int i =0; i< edges.length;i++)\\n        {\\n           map.get(edges[i][0]).add(edges[i][1]);\\n           map.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        \\n        // sort each arraylist indicating connection according to highest scores (i.e. in decreasing order)\\n        // again takes O(n) time\\n        for(int i =0; i< scores.length;i++)\\n        {\\n           Collections.sort(map.get(i), new Comparator<Integer>(){\\n               public int compare(Integer a, Integer b)\\n               {\\n                   return(scores[b] - scores[a]);\\n               }\\n           });\\n        }\\n        \\n        // now fix the middle edge and look for 1st and 4th vertices, make sure all the elements in the \\n        //result are unique elements, the elemnts at the end with which you are left is your answer.\\n\\t\\t// takes (3*3*n) time i.e. O(n)\\n        int ans = -1;\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            int least = scores[u] + scores[v];\\n            \\n            for(int j=0;j< Math.min(3, map.get(u).size());j++)\\n            {\\n                int x = map.get(u).get(j);\\n                if(x == v) \\n                  continue;\\n                \\n                for(int k=0;k< Math.min(3, map.get(v).size());k++)\\n                {\\n                    int y = map.get(v).get(k);\\n                    if(y == u || y == x)\\n                    continue;\\n                    \\n                    ans = Math.max(ans, least+scores[x]+scores[y]);\\n                }\\n                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        \\n        Map<Integer, ArrayList<Integer>> map = new HashMap<Integer, ArrayList<Integer>>();\\n        \\n        // initialize nodes arraylists takes O(n)\\n        for(int i =0; i< scores.length;i++)\\n        {\\n           map.put(i,new ArrayList<Integer>()); \\n        }\\n        \\n        // add bidirectional edges to respective nodes to indicate a connection between them\\n        // again takes O(e) time\\n        for(int i =0; i< edges.length;i++)\\n        {\\n           map.get(edges[i][0]).add(edges[i][1]);\\n           map.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        \\n        // sort each arraylist indicating connection according to highest scores (i.e. in decreasing order)\\n        // again takes O(n) time\\n        for(int i =0; i< scores.length;i++)\\n        {\\n           Collections.sort(map.get(i), new Comparator<Integer>(){\\n               public int compare(Integer a, Integer b)\\n               {\\n                   return(scores[b] - scores[a]);\\n               }\\n           });\\n        }\\n        \\n        // now fix the middle edge and look for 1st and 4th vertices, make sure all the elements in the \\n        //result are unique elements, the elemnts at the end with which you are left is your answer.\\n\\t\\t// takes (3*3*n) time i.e. O(n)\\n        int ans = -1;\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            int least = scores[u] + scores[v];\\n            \\n            for(int j=0;j< Math.min(3, map.get(u).size());j++)\\n            {\\n                int x = map.get(u).get(j);\\n                if(x == v) \\n                  continue;\\n                \\n                for(int k=0;k< Math.min(3, map.get(v).size());k++)\\n                {\\n                    int y = map.get(v).get(k);\\n                    if(y == u || y == x)\\n                    continue;\\n                    \\n                    ans = Math.max(ans, least+scores[x]+scores[y]);\\n                }\\n                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953664,
                "title": "cpp-an-optimization-problem-pretends-to-be-a-graph-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        // sort edges by sums of pairs of scores, descending\\n        sort(edges.begin(), edges.end(),\\n             [&](const vector<int>& e1, const vector<int>& e2) {\\n                 return scores[e1[0]] + scores[e1[1]] > scores[e2[0]] + scores[e2[1]];\\n             });\\n        \\n        int n = scores.size(), m = edges.size(), bound = m, ans = -1;\\n        vector<unordered_set<int>> g(n);\\n        \\n        for (const vector<int>& e: edges) {\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);\\n        }\\n        \\n        for (int i = 0; i < min(bound, m); ++i)\\n            for (int j = i + 1; j < m; ++j) {\\n                int a = edges[i][0], b = edges[i][1], c = edges[j][0], d = edges[j][1];\\n                \\n                // select pairs of (a, b) and (c, d)\\n                // optimization 1: check the sum, break if smaller (since we sorted the edges)\\n                if (ans >= scores[a] + scores[b] + scores[c] + scores[d]) break;\\n                \\n                // check if a, b, c, d are distinct, and any pair of (a, c), (a, d), (b, c), (b, d) can be found\\n                if (a == c || a == d || b == c || b == d ||\\n                    g[a].find(c) == g[a].end() && g[a].find(d) == g[a].end() &&\\n                    g[b].find(c) == g[b].end() && g[b].find(d) == g[b].end()) continue;\\n                \\n                ans = max(ans, scores[a] + scores[b] + scores[c] + scores[d]);\\n                \\n                // optimization 2: lower the outer bound\\n                bound = min(bound, j + 1);\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        // sort edges by sums of pairs of scores, descending\\n        sort(edges.begin(), edges.end(),\\n             [&](const vector<int>& e1, const vector<int>& e2) {\\n                 return scores[e1[0]] + scores[e1[1]] > scores[e2[0]] + scores[e2[1]];\\n             });\\n        \\n        int n = scores.size(), m = edges.size(), bound = m, ans = -1;\\n        vector<unordered_set<int>> g(n);\\n        \\n        for (const vector<int>& e: edges) {\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);\\n        }\\n        \\n        for (int i = 0; i < min(bound, m); ++i)\\n            for (int j = i + 1; j < m; ++j) {\\n                int a = edges[i][0], b = edges[i][1], c = edges[j][0], d = edges[j][1];\\n                \\n                // select pairs of (a, b) and (c, d)\\n                // optimization 1: check the sum, break if smaller (since we sorted the edges)\\n                if (ans >= scores[a] + scores[b] + scores[c] + scores[d]) break;\\n                \\n                // check if a, b, c, d are distinct, and any pair of (a, c), (a, d), (b, c), (b, d) can be found\\n                if (a == c || a == d || b == c || b == d ||\\n                    g[a].find(c) == g[a].end() && g[a].find(d) == g[a].end() &&\\n                    g[b].find(c) == g[b].end() && g[b].find(d) == g[b].end()) continue;\\n                \\n                ans = max(ans, scores[a] + scores[b] + scores[c] + scores[d]);\\n                \\n                // optimization 2: lower the outer bound\\n                bound = min(bound, j + 1);\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954064,
                "title": "python3-top-3-neighbors-in-adjacency-list-using-heap",
                "content": "The solution here converts the adjacency list into a heap. We just need the top 3 neighbors for any node to solve this problem. Since I am using heap, I can extract the top 3 neighbors in O(3*log(n)). \\n\\n**Main point**: For every edge, say a---b, we can search for the best neighbor of a (that is not b) and the best neighbor of b (that is not a). We also need to make sure the neighbors are not equal (i.e. we are not forming a triangle). Then, we have a valid sequence of length 4. Here a---b is the middle of the sequence.\\n\\nWe can iterate over all edges and perform the checks described above and find the best valid sequence. We are destined to find the best valid sequence in this algorithm.\\n\\nTime Complexity: O(e*log(n)), e is no. of edges, n is no. of nodes.\\n\\nPS: I\\'ve come realize we don\\'t need to use heaps. We can just save the top 3 neighbors while creating the adjacency list. We will only need the top 3 in our algorithm, so there is no point in saving the entire adjacency list for every node and heapifying it. This makes the time complexity O(e).\\n\\n```\\nimport heapq\\n\\nclass Pair:\\n    def __init__(self, node, score):\\n        self.node = node\\n        self.score = score\\n    def __lt__(self, other):\\n        return self.score < other.score\\n\\nclass Solution:    \\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        edgeList = [[] for i in range(len(scores))]\\n        for edge in edges:\\n            edgeList[edge[0]].append(Pair(edge[1], -1*scores[edge[1]]))\\n            edgeList[edge[1]].append(Pair(edge[0], -1*scores[edge[0]]))\\n            \\n        for nodeEdges in edgeList:\\n            heapq.heapify(nodeEdges)\\n            \\n        best = -1\\n        for e in edges:\\n            n0 = []\\n            n1 = []\\n            while(len(edgeList[e[0]])>0 and len(n0)<3):\\n                x = heapq.heappop(edgeList[e[0]])\\n                n0.append(x)\\n            while(len(edgeList[e[1]])>0 and len(n1)<3):\\n                x = heapq.heappop(edgeList[e[1]])\\n                n1.append(x)\\n            \\n            m0 = [x for x in n0 if x.node!=e[1]]\\n            m1 = [x for x in n1 if x.node!=e[0]]\\n            score = scores[e[0]] + scores[e[1]]\\n            \\n            if(len(m0)!=0 and len(m1)!=0):\\n                if(m0[0].node==m1[0].node):\\n                    if(len(m0)>1 and len(m1)==1):\\n                        score += scores[m0[1].node] + scores[m1[0].node]\\n                        best = max(best, score)\\n                    elif(len(m0)==1 and len(m1)>1):\\n                        score += scores[m0[0].node] + scores[m1[1].node]\\n                        best = max(best, score)\\n                    elif(len(m0)>1 and len(m1)>1):\\n                        score += scores[m0[0].node] + max(scores[m0[1].node], scores[m1[1].node])\\n                        best = max(best, score)\\n                else:\\n                    score += scores[m0[0].node] + scores[m1[0].node]\\n                    best = max(best, score)\\n            \\n            for n in n0:\\n                heapq.heappush(edgeList[e[0]], n)\\n            for n in n1:\\n                heapq.heappush(edgeList[e[1]], n)\\n\\n\\n        return best\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph"
                ],
                "code": "```\\nimport heapq\\n\\nclass Pair:\\n    def __init__(self, node, score):\\n        self.node = node\\n        self.score = score\\n    def __lt__(self, other):\\n        return self.score < other.score\\n\\nclass Solution:    \\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        edgeList = [[] for i in range(len(scores))]\\n        for edge in edges:\\n            edgeList[edge[0]].append(Pair(edge[1], -1*scores[edge[1]]))\\n            edgeList[edge[1]].append(Pair(edge[0], -1*scores[edge[0]]))\\n            \\n        for nodeEdges in edgeList:\\n            heapq.heapify(nodeEdges)\\n            \\n        best = -1\\n        for e in edges:\\n            n0 = []\\n            n1 = []\\n            while(len(edgeList[e[0]])>0 and len(n0)<3):\\n                x = heapq.heappop(edgeList[e[0]])\\n                n0.append(x)\\n            while(len(edgeList[e[1]])>0 and len(n1)<3):\\n                x = heapq.heappop(edgeList[e[1]])\\n                n1.append(x)\\n            \\n            m0 = [x for x in n0 if x.node!=e[1]]\\n            m1 = [x for x in n1 if x.node!=e[0]]\\n            score = scores[e[0]] + scores[e[1]]\\n            \\n            if(len(m0)!=0 and len(m1)!=0):\\n                if(m0[0].node==m1[0].node):\\n                    if(len(m0)>1 and len(m1)==1):\\n                        score += scores[m0[1].node] + scores[m1[0].node]\\n                        best = max(best, score)\\n                    elif(len(m0)==1 and len(m1)>1):\\n                        score += scores[m0[0].node] + scores[m1[1].node]\\n                        best = max(best, score)\\n                    elif(len(m0)>1 and len(m1)>1):\\n                        score += scores[m0[0].node] + max(scores[m0[1].node], scores[m1[1].node])\\n                        best = max(best, score)\\n                else:\\n                    score += scores[m0[0].node] + scores[m1[0].node]\\n                    best = max(best, score)\\n            \\n            for n in n0:\\n                heapq.heappush(edgeList[e[0]], n)\\n            for n in n1:\\n                heapq.heappush(edgeList[e[1]], n)\\n\\n\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953667,
                "title": "c-fix-the-middle-edge-o-edges-length",
                "content": "## Idea\\n- \"a valid node sequence with length of 4\" is equivalent to \"a valid edge sequence with length of 3\"\\n\\t- an edge sequence `e_0, e_1, ..., e_k` is valid if\\n\\t\\t1. `e_i[1] == e_{i+1}[0]` for all `i` in `[0, k)` and\\n\\t\\t2. each node in the sequence is visited only once (the restriction is the same as that w.r.t. the node sequence)\\n\\t- e.g. `[2, 3], [3, 1], [1, 4]` is valid; while `[2, 3], [3, 1], [1, 2]` is not.\\n- we can **fix the middle edge** and find for the endpoints other nodes (with an edge between them) with larger score.\\n## Algorithm\\n- let\\'s define `m` as the number of edges (`len(edges)` in python or `edges.size()` in C++), and also define `n` as the number of nodes.\\n### 1. The straight-forward version\\n1. for each node, keep track of the edges incident on it.\\n2. for each edge `[u, v]`, iterate through the edges incident on `u` and `v` respectively and find the largest total score of a **valid** edge sequence.\\n- consider a complete graph, the time complexity would be `O(m^2)`\\n\\t- that\\'s because `deg(i) == n-1` for each node, and the cost of examing one edge is `O(n^2) = O(m)`\\n### 2. Improved version\\n- for each node `i`, we would only use the edges that connect to a node `j` with larger score. so the idea here is to only keep such edges in each node. now the question become: **how many edges should we keep?**\\n\\t- only keeping the largest edge?\\n\\t\\t- fails on the graph\\n\\t\\t\\t- ![image](https://assets.leetcode.com/users/images/e05239f0-d8c5-45bf-9f63-b61b22e7b92e_1650122839.8170974.png)\\n\\t\\t\\t- it won\\'t consider the edge sequence `[2, 0], [0, 1], [1, 3]`\\n\\t- only keeping the largest two edges?\\n\\t\\t- fails on the graph\\n\\t\\t\\t- ![image](https://assets.leetcode.com/users/images/d5552880-ef92-4ffa-b3ab-53c7820c57f5_1650123038.2068918.png)\\n\\t\\t\\t- it won\\'t consider the edge sequence `[2, 0], [0, 1], [1, 3]` nor `[3, 0], [0, 1], [1, 2]`\\n\\t- only keeping the largest three edges?\\n\\t\\t- it works. we can explain it by the previous figure but i\\'ll skip it.\\n- so the improved algorithm is\\n\\t1. for each node, keep track of the **largest three** edges incident on it.\\n\\t\\t- the \"quantity\" of an edge here is determined by the score of the other node on the edge.\\n\\t2. for each edge `[u, v]`, iterate through the edges incident on `u` and `v` respectively and find the largest total score of a **valid** edge sequence.\\n\\t- the time complexity here is `O(m)`, since for each \"middle\" edge, we now have to consider **at most 9 (which is a constant)** possible combinations.\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n = scores.size();\\n        // keep track of the map: node id -> the largest 3 edges\\n        vector<vector<array<int, 2>>> another(n);\\n        for (auto& e : edges) {\\n            int u = e[0], v = e[1];\\n\\t\\t\\tanother[u].push_back({scores[v], v});\\n            another[v].push_back({scores[u], u});\\n        }\\n        for (int i = 0; i < n; i++) {\\n            sort(another[i].rbegin(), another[i].rend());\\n            if (another[i].size() > 3) {\\n\\t\\t\\t\\t// only keep the largest 3\\n                another[i].resize(3);\\n\\t\\t\\t}\\n        }\\n        // consider each edge as the middle edge\\n        int ans = -1e9;\\n        for (auto& e : edges) {\\n            int u = e[0], v = e[1];\\n            int cur_ans = -1e9;\\n            for (int i = 0; i < another[u].size(); i++) {\\n                int uu = another[u][i][1];\\n                if (uu == v) continue;  // skip the invaild sequence\\n                for (int j = 0; j < another[v].size(); j++) {\\n                    int vv = another[v][j][1];\\n                    if (vv == u || vv == uu) continue;  // skip the invaild sequences\\n                    cur_ans = max(cur_ans, scores[u] + scores[v] + scores[uu] + scores[vv]);\\n                }\\n            }\\n            ans = max(ans, cur_ans);\\n        }\\n        return max(ans, -1);\\n    }\\n};\\n```\\n- actually the time complexity of the code above is `O(n^2 lg n) = O(m lg n)` (since the `sort` part), we can make it `O(m)` by modifying the method of finding the largest three edges and it\\'s *left as an exercise for the readers*.\\n- the left as an exercise part is a joke. but it would still be a good exercise to think about how to achieve it without using the powerful `nth_element`.\\n\\t- hint: implement a helper function called `keepLargestThree` or something; think about how we could do it if we want to keep the largest two instead of three.\\n```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n = scores.size();\\n        // keep track of map: node id -> the largest 3 edges\\n        vector<vector<array<int, 2>>> another(n);\\n        for (auto& e : edges) {\\n            int u = e[0], v = e[1];\\n            another[u].push_back({scores[v], v});\\n            another[v].push_back({scores[u], u});\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (another[i].size() <= 3) continue;\\n            nth_element(another[i].begin(), another[i].begin() + 3, another[i].end(), [](const array<int, 2>& a, const array<int, 2>& b) {\\n                return a[0] > b[0];\\n            });\\n\\t\\t\\tanother[i].resize(3);\\n        }\\n        // consider each edge\\n        int ans = -1e9;\\n        for (auto& e : edges) {\\n            int u = e[0], v = e[1];\\n            int cur_ans = -1e9;\\n            for (int i = 0; i < another[u].size(); i++) {\\n                int uu = another[u][i][1];\\n                if (uu == v) continue;\\n                for (int j = 0; j < another[v].size(); j++) {\\n                    int vv = another[v][j][1];\\n                    if (vv == u || vv == uu) continue;\\n                    cur_ans = max(cur_ans, scores[u] + scores[v] + scores[uu] + scores[vv]);\\n                }\\n            }\\n            ans = max(ans, cur_ans);\\n        }\\n        return max(ans, -1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n = scores.size();\\n        // keep track of the map: node id -> the largest 3 edges\\n        vector<vector<array<int, 2>>> another(n);\\n        for (auto& e : edges) {\\n            int u = e[0], v = e[1];\\n\\t\\t\\tanother[u].push_back({scores[v], v});\\n            another[v].push_back({scores[u], u});\\n        }\\n        for (int i = 0; i < n; i++) {\\n            sort(another[i].rbegin(), another[i].rend());\\n            if (another[i].size() > 3) {\\n\\t\\t\\t\\t// only keep the largest 3\\n                another[i].resize(3);\\n\\t\\t\\t}\\n        }\\n        // consider each edge as the middle edge\\n        int ans = -1e9;\\n        for (auto& e : edges) {\\n            int u = e[0], v = e[1];\\n            int cur_ans = -1e9;\\n            for (int i = 0; i < another[u].size(); i++) {\\n                int uu = another[u][i][1];\\n                if (uu == v) continue;  // skip the invaild sequence\\n                for (int j = 0; j < another[v].size(); j++) {\\n                    int vv = another[v][j][1];\\n                    if (vv == u || vv == uu) continue;  // skip the invaild sequences\\n                    cur_ans = max(cur_ans, scores[u] + scores[v] + scores[uu] + scores[vv]);\\n                }\\n            }\\n            ans = max(ans, cur_ans);\\n        }\\n        return max(ans, -1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n = scores.size();\\n        // keep track of map: node id -> the largest 3 edges\\n        vector<vector<array<int, 2>>> another(n);\\n        for (auto& e : edges) {\\n            int u = e[0], v = e[1];\\n            another[u].push_back({scores[v], v});\\n            another[v].push_back({scores[u], u});\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (another[i].size() <= 3) continue;\\n            nth_element(another[i].begin(), another[i].begin() + 3, another[i].end(), [](const array<int, 2>& a, const array<int, 2>& b) {\\n                return a[0] > b[0];\\n            });\\n\\t\\t\\tanother[i].resize(3);\\n        }\\n        // consider each edge\\n        int ans = -1e9;\\n        for (auto& e : edges) {\\n            int u = e[0], v = e[1];\\n            int cur_ans = -1e9;\\n            for (int i = 0; i < another[u].size(); i++) {\\n                int uu = another[u][i][1];\\n                if (uu == v) continue;\\n                for (int j = 0; j < another[v].size(); j++) {\\n                    int vv = another[v][j][1];\\n                    if (vv == u || vv == uu) continue;\\n                    cur_ans = max(cur_ans, scores[u] + scores[v] + scores[uu] + scores[vv]);\\n                }\\n            }\\n            ans = max(ans, cur_ans);\\n        }\\n        return max(ans, -1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977607,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "```\\nclass Solution {\\n    public int maximumScore(int[] scores, int[][] edges) {\\n\\t\\tint n = scores.length;\\n\\t\\t\\n        int[][] count = new int[n][6];\\n\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\tint s = edge[0];\\n\\t\\t\\tint e = edge[1];\\n\\t\\t\\tif (count[s][0] == 0) {\\n\\t\\t\\t\\tcount[s][1] = e;\\n\\t\\t\\t\\tcount[s][0] = scores[e];\\n\\t\\t\\t} else if (count[s][2] == 0) {\\n\\t\\t\\t\\tif (scores[e] > count[s][0]) {\\n\\t\\t\\t\\t\\tcount[s][3] = count[s][1];\\n\\t\\t\\t\\t\\tcount[s][2] = count[s][0];\\n\\t\\t\\t\\t\\tcount[s][1] = e;\\n\\t\\t\\t\\t\\tcount[s][0] = scores[e];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcount[s][3] = e;\\n\\t\\t\\t\\t\\tcount[s][2] = scores[e];\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (scores[e] > count[s][4]) {\\n\\t\\t\\t\\tif (scores[e] > count[s][0]) {\\n\\t\\t\\t\\t\\tcount[s][5] = count[s][3];\\n\\t\\t\\t\\t\\tcount[s][4] = count[s][2];\\n\\t\\t\\t\\t\\tcount[s][3] = count[s][1];\\n\\t\\t\\t\\t\\tcount[s][2] = count[s][0];\\n\\t\\t\\t\\t\\tcount[s][1] = e;\\n\\t\\t\\t\\t\\tcount[s][0] = scores[e];\\n\\t\\t\\t\\t} else if (scores[e] > count[s][2]) {\\n\\t\\t\\t\\t\\tcount[s][5] = count[s][3];\\n\\t\\t\\t\\t\\tcount[s][4] = count[s][2];\\n\\t\\t\\t\\t\\tcount[s][3] = e;\\n\\t\\t\\t\\t\\tcount[s][2] = scores[e];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcount[s][5] = e;\\n\\t\\t\\t\\t\\tcount[s][4] = scores[e];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (count[e][0] == 0) {\\n\\t\\t\\t\\tcount[e][1] = s;\\n\\t\\t\\t\\tcount[e][0] = scores[s];\\n\\t\\t\\t} else if (count[e][2] == 0) {\\n\\t\\t\\t\\tif (scores[s] > count[e][0]) {\\n\\t\\t\\t\\t\\tcount[e][3] = count[e][1];\\n\\t\\t\\t\\t\\tcount[e][2] = count[e][0];\\n\\t\\t\\t\\t\\tcount[e][1] = s;\\n\\t\\t\\t\\t\\tcount[e][0] = scores[s];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcount[e][3] = s;\\n\\t\\t\\t\\t\\tcount[e][2] = scores[s];\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (scores[s] > count[e][4]) {\\n\\t\\t\\t\\tif (scores[s] > count[e][0]) {\\n\\t\\t\\t\\t\\tcount[e][5] = count[e][3];\\n\\t\\t\\t\\t\\tcount[e][4] = count[e][2];\\n\\t\\t\\t\\t\\tcount[e][3] = count[e][1];\\n\\t\\t\\t\\t\\tcount[e][2] = count[e][0];\\n\\t\\t\\t\\t\\tcount[e][1] = s;\\n\\t\\t\\t\\t\\tcount[e][0] = scores[s];\\n\\t\\t\\t\\t} else if (scores[s] > count[e][2]) {\\n\\t\\t\\t\\t\\tcount[e][5] = count[e][3];\\n\\t\\t\\t\\t\\tcount[e][4] = count[e][2];\\n\\t\\t\\t\\t\\tcount[e][3] = s;\\n\\t\\t\\t\\t\\tcount[e][2] = scores[s];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcount[e][5] = s;\\n\\t\\t\\t\\t\\tcount[e][4] = scores[s];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint max = -1;\\n\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\tint s = edge[0];\\n\\t\\t\\tint e = edge[1];\\n\\t\\t\\tint pos = scores[s] + scores[e];\\n\\t\\t\\tint p1 = -1;\\n\\t\\t\\tint p2 = -1;\\n\\t\\t\\tboolean fine = true;\\n\\t\\t\\tif (count[s][1] == e) {\\n\\t\\t\\t\\tif (count[s][2] == 0)\\n\\t\\t\\t\\t\\tfine = false;\\n\\t\\t\\t\\tp1 = count[s][3];\\n\\t\\t\\t\\tif (count[s][4] > 0)\\n\\t\\t\\t\\t\\tp2 = count[s][5];\\n\\t\\t\\t} else if (count[s][3] == e) {\\n\\t\\t\\t\\tif (count[s][0] == 0)\\n\\t\\t\\t\\t\\tfine = false;\\n\\t\\t\\t\\tp1 = count[s][1];\\n\\t\\t\\t\\tif (count[s][4] > 0)\\n\\t\\t\\t\\t\\tp2 = count[s][5];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tp1 = count[s][1];\\n\\t\\t\\t\\tif (count[s][0] == 0)\\n\\t\\t\\t\\t\\tfine = false;\\n\\t\\t\\t\\tif (count[s][2] > 0)\\n\\t\\t\\t\\t\\tp2 = count[s][3];\\n\\t\\t\\t} \\n\\t\\t\\tint p3 = -1;\\n\\t\\t\\tint p4 = -1;\\n\\t\\t\\tif (count[e][1] == s) {\\n\\t\\t\\t\\tif (count[e][2] == 0)\\n\\t\\t\\t\\t\\tfine = false;\\n\\t\\t\\t\\tp3 = count[e][3];\\n\\t\\t\\t\\tif (count[e][4] > 0)\\n\\t\\t\\t\\t\\tp4 = count[e][5];\\n\\t\\t\\t} else if (count[e][3] == s) {\\n\\t\\t\\t\\tif (count[e][0] == 0)\\n\\t\\t\\t\\t\\tfine = false;\\n\\t\\t\\t\\tp3 = count[e][1];\\n\\t\\t\\t\\tif (count[e][4] > 0)\\n\\t\\t\\t\\t\\tp4 = count[e][5];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tp3 = count[e][1];\\n\\t\\t\\t\\tif (count[e][0] == 0)\\n\\t\\t\\t\\t\\tfine = false;\\n\\t\\t\\t\\tif (count[e][2] > 0)\\n\\t\\t\\t\\t\\tp4 = count[e][3];\\n\\t\\t\\t} \\n\\t\\t\\tif (fine) {\\n\\t\\t\\t\\tif (p1 == p3) {\\n\\t\\t\\t\\t\\tif (p4 > -1)\\n\\t\\t\\t\\t\\t\\tmax = Math.max(max, pos + scores[p1] + scores[p4]);\\n\\t\\t\\t\\t\\tif (p2 > -1)\\n\\t\\t\\t\\t\\t\\tmax = Math.max(max, pos + scores[p1] + scores[p2]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tmax = Math.max(max, pos + scores[p1] + scores[p3]);\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn max;\\n    }\\n}\\n```\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumScore(int[] scores, int[][] edges) {\\n\\t\\tint n = scores.length;\\n\\t\\t\\n        int[][] count = new int[n][6];\\n\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\tint s = edge[0];\\n\\t\\t\\tint e = edge[1];\\n\\t\\t\\tif (count[s][0] == 0) {\\n\\t\\t\\t\\tcount[s][1] = e;\\n\\t\\t\\t\\tcount[s][0] = scores[e];\\n\\t\\t\\t} else if (count[s][2] == 0) {\\n\\t\\t\\t\\tif (scores[e] > count[s][0]) {\\n\\t\\t\\t\\t\\tcount[s][3] = count[s][1];\\n\\t\\t\\t\\t\\tcount[s][2] = count[s][0];\\n\\t\\t\\t\\t\\tcount[s][1] = e;\\n\\t\\t\\t\\t\\tcount[s][0] = scores[e];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcount[s][3] = e;\\n\\t\\t\\t\\t\\tcount[s][2] = scores[e];\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (scores[e] > count[s][4]) {\\n\\t\\t\\t\\tif (scores[e] > count[s][0]) {\\n\\t\\t\\t\\t\\tcount[s][5] = count[s][3];\\n\\t\\t\\t\\t\\tcount[s][4] = count[s][2];\\n\\t\\t\\t\\t\\tcount[s][3] = count[s][1];\\n\\t\\t\\t\\t\\tcount[s][2] = count[s][0];\\n\\t\\t\\t\\t\\tcount[s][1] = e;\\n\\t\\t\\t\\t\\tcount[s][0] = scores[e];\\n\\t\\t\\t\\t} else if (scores[e] > count[s][2]) {\\n\\t\\t\\t\\t\\tcount[s][5] = count[s][3];\\n\\t\\t\\t\\t\\tcount[s][4] = count[s][2];\\n\\t\\t\\t\\t\\tcount[s][3] = e;\\n\\t\\t\\t\\t\\tcount[s][2] = scores[e];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcount[s][5] = e;\\n\\t\\t\\t\\t\\tcount[s][4] = scores[e];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (count[e][0] == 0) {\\n\\t\\t\\t\\tcount[e][1] = s;\\n\\t\\t\\t\\tcount[e][0] = scores[s];\\n\\t\\t\\t} else if (count[e][2] == 0) {\\n\\t\\t\\t\\tif (scores[s] > count[e][0]) {\\n\\t\\t\\t\\t\\tcount[e][3] = count[e][1];\\n\\t\\t\\t\\t\\tcount[e][2] = count[e][0];\\n\\t\\t\\t\\t\\tcount[e][1] = s;\\n\\t\\t\\t\\t\\tcount[e][0] = scores[s];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcount[e][3] = s;\\n\\t\\t\\t\\t\\tcount[e][2] = scores[s];\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (scores[s] > count[e][4]) {\\n\\t\\t\\t\\tif (scores[s] > count[e][0]) {\\n\\t\\t\\t\\t\\tcount[e][5] = count[e][3];\\n\\t\\t\\t\\t\\tcount[e][4] = count[e][2];\\n\\t\\t\\t\\t\\tcount[e][3] = count[e][1];\\n\\t\\t\\t\\t\\tcount[e][2] = count[e][0];\\n\\t\\t\\t\\t\\tcount[e][1] = s;\\n\\t\\t\\t\\t\\tcount[e][0] = scores[s];\\n\\t\\t\\t\\t} else if (scores[s] > count[e][2]) {\\n\\t\\t\\t\\t\\tcount[e][5] = count[e][3];\\n\\t\\t\\t\\t\\tcount[e][4] = count[e][2];\\n\\t\\t\\t\\t\\tcount[e][3] = s;\\n\\t\\t\\t\\t\\tcount[e][2] = scores[s];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcount[e][5] = s;\\n\\t\\t\\t\\t\\tcount[e][4] = scores[s];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint max = -1;\\n\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\tint s = edge[0];\\n\\t\\t\\tint e = edge[1];\\n\\t\\t\\tint pos = scores[s] + scores[e];\\n\\t\\t\\tint p1 = -1;\\n\\t\\t\\tint p2 = -1;\\n\\t\\t\\tboolean fine = true;\\n\\t\\t\\tif (count[s][1] == e) {\\n\\t\\t\\t\\tif (count[s][2] == 0)\\n\\t\\t\\t\\t\\tfine = false;\\n\\t\\t\\t\\tp1 = count[s][3];\\n\\t\\t\\t\\tif (count[s][4] > 0)\\n\\t\\t\\t\\t\\tp2 = count[s][5];\\n\\t\\t\\t} else if (count[s][3] == e) {\\n\\t\\t\\t\\tif (count[s][0] == 0)\\n\\t\\t\\t\\t\\tfine = false;\\n\\t\\t\\t\\tp1 = count[s][1];\\n\\t\\t\\t\\tif (count[s][4] > 0)\\n\\t\\t\\t\\t\\tp2 = count[s][5];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tp1 = count[s][1];\\n\\t\\t\\t\\tif (count[s][0] == 0)\\n\\t\\t\\t\\t\\tfine = false;\\n\\t\\t\\t\\tif (count[s][2] > 0)\\n\\t\\t\\t\\t\\tp2 = count[s][3];\\n\\t\\t\\t} \\n\\t\\t\\tint p3 = -1;\\n\\t\\t\\tint p4 = -1;\\n\\t\\t\\tif (count[e][1] == s) {\\n\\t\\t\\t\\tif (count[e][2] == 0)\\n\\t\\t\\t\\t\\tfine = false;\\n\\t\\t\\t\\tp3 = count[e][3];\\n\\t\\t\\t\\tif (count[e][4] > 0)\\n\\t\\t\\t\\t\\tp4 = count[e][5];\\n\\t\\t\\t} else if (count[e][3] == s) {\\n\\t\\t\\t\\tif (count[e][0] == 0)\\n\\t\\t\\t\\t\\tfine = false;\\n\\t\\t\\t\\tp3 = count[e][1];\\n\\t\\t\\t\\tif (count[e][4] > 0)\\n\\t\\t\\t\\t\\tp4 = count[e][5];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tp3 = count[e][1];\\n\\t\\t\\t\\tif (count[e][0] == 0)\\n\\t\\t\\t\\t\\tfine = false;\\n\\t\\t\\t\\tif (count[e][2] > 0)\\n\\t\\t\\t\\t\\tp4 = count[e][3];\\n\\t\\t\\t} \\n\\t\\t\\tif (fine) {\\n\\t\\t\\t\\tif (p1 == p3) {\\n\\t\\t\\t\\t\\tif (p4 > -1)\\n\\t\\t\\t\\t\\t\\tmax = Math.max(max, pos + scores[p1] + scores[p4]);\\n\\t\\t\\t\\t\\tif (p2 > -1)\\n\\t\\t\\t\\t\\t\\tmax = Math.max(max, pos + scores[p1] + scores[p2]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tmax = Math.max(max, pos + scores[p1] + scores[p3]);\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959789,
                "title": "c-100-faster-100-less-memory",
                "content": "For each edge b-c , we will try to find neighbors of b and c such that all nodes are unique and give us maximum score (a-b-c-d). We only need to search 3 neighbors of b and c each which have the highest scores, to avoid duplication of nodes.\\nFor e.g. If we have a sequeunce b-c-d and we want to find the neighbor b\\nWe can have options c, d, and any other node. c and d will not be considered here as they will cause duplication in the sequence so we will choose the third node.\\nNote: As there are no self edges, therefore we need not to check if neighbor of b is b itself.\\n```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n = scores.size(), res=-1;\\n        vector<vector<pair<int, int>>> graph(n);\\n        for(vector<int> e: edges){\\n            graph[e[0]].push_back({scores[e[1]], e[1]});\\n            graph[e[1]].push_back({scores[e[0]], e[0]});\\n        }\\n        for(int i=0; i<n; i++){\\n            sort(graph[i].begin(), graph[i].end(), greater<pair<int, int>>());\\n        }\\n        for(auto e: edges){\\n            int b=e[0], c=e[1];\\n            for(int i=0; i<min(3, (int)graph[b].size()); i++){\\n                int a = graph[b][i].second;\\n                if(a==c) continue;\\n                for(int j=0; j<min(3, (int)graph[c].size()); j++){\\n                    int d = graph[c][j].second;\\n                    if(d==b || d==a) continue;\\n                    res = max(res, scores[a]+scores[b]+scores[c]+scores[d]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n = scores.size(), res=-1;\\n        vector<vector<pair<int, int>>> graph(n);\\n        for(vector<int> e: edges){\\n            graph[e[0]].push_back({scores[e[1]], e[1]});\\n            graph[e[1]].push_back({scores[e[0]], e[0]});\\n        }\\n        for(int i=0; i<n; i++){\\n            sort(graph[i].begin(), graph[i].end(), greater<pair<int, int>>());\\n        }\\n        for(auto e: edges){\\n            int b=e[0], c=e[1];\\n            for(int i=0; i<min(3, (int)graph[b].size()); i++){\\n                int a = graph[b][i].second;\\n                if(a==c) continue;\\n                for(int j=0; j<min(3, (int)graph[c].size()); j++){\\n                    int d = graph[c][j].second;\\n                    if(d==b || d==a) continue;\\n                    res = max(res, scores[a]+scores[b]+scores[c]+scores[d]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954315,
                "title": "c-beats-100-check-for-edges",
                "content": "Take every edge and find the top-scoring neighbors of both nodes of that edge. We need to find atmost 3 top scoring nodes because there may be overlap in neighbors. We can use the set to find top-scoring neighbors.\\n\\n```\\n/* \\n    Time: O(V+E)\\n    Space: O(V+E)\\n    Tags: Graph, Set, Sorting, Greedy\\n    Difficulty: H\\n*/\\n\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int> &scores, vector<vector<int>> &edges) {\\n        set<pair<int, int>> graph[scores.size()];\\n        for (auto edge : edges) {\\n            graph[edge[0]].insert({scores[edge[1]], edge[1]});\\n            graph[edge[1]].insert({scores[edge[0]], edge[0]});\\n            if (graph[edge[0]].size() > 3) graph[edge[0]].erase(graph[edge[0]].begin());\\n            if (graph[edge[1]].size() > 3) graph[edge[1]].erase(graph[edge[1]].begin());\\n        }\\n        int res = -1;\\n        for (auto edge : edges) {\\n            int ans = scores[edge[0]] + scores[edge[1]];\\n            for (auto node1 : graph[edge[0]]) {\\n                for (auto node2 : graph[edge[1]]) {\\n                    if (node1.second != edge[0] && node1.second != edge[1] && node2.second != edge[0] && node2.second != edge[1] && node2.second != node1.second)\\n                        res = max(res, ans + node1.first + node2.first);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Graph",
                    "Ordered Set"
                ],
                "code": "```\\n/* \\n    Time: O(V+E)\\n    Space: O(V+E)\\n    Tags: Graph, Set, Sorting, Greedy\\n    Difficulty: H\\n*/\\n\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int> &scores, vector<vector<int>> &edges) {\\n        set<pair<int, int>> graph[scores.size()];\\n        for (auto edge : edges) {\\n            graph[edge[0]].insert({scores[edge[1]], edge[1]});\\n            graph[edge[1]].insert({scores[edge[0]], edge[0]});\\n            if (graph[edge[0]].size() > 3) graph[edge[0]].erase(graph[edge[0]].begin());\\n            if (graph[edge[1]].size() > 3) graph[edge[1]].erase(graph[edge[1]].begin());\\n        }\\n        int res = -1;\\n        for (auto edge : edges) {\\n            int ans = scores[edge[0]] + scores[edge[1]];\\n            for (auto node1 : graph[edge[0]]) {\\n                for (auto node2 : graph[edge[1]]) {\\n                    if (node1.second != edge[0] && node1.second != edge[1] && node2.second != edge[0] && node2.second != edge[1] && node2.second != node1.second)\\n                        res = max(res, ans + node1.first + node2.first);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954005,
                "title": "python-3-hint-solution",
                "content": "```\\n# key is to store top 3 neighbors for each node\\n# for each pair of edges (two middle nodes): find the other two nodes with highest score\\n# we can\\'t store top 1 node (highest node is neighbor in the edge) or 2 nodes (two middle nodes share the same highest adjacent node)\\n\\n\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        \\n        g = defaultdict(list)\\n        for a, b in edges:\\n            heappush(g[a], (scores[b], b))\\n            if len(g[a]) > 3:\\n                heappop(g[a])\\n            heappush(g[b], (scores[a], a))\\n            if len(g[b]) > 3:\\n                heappop(g[b])\\n        \\n        ans = -1\\n        for a, b in edges:\\n            for s1, n1 in g[a]:\\n                if n1 == b: continue\\n                for s2, n2 in g[b]:\\n                    if n2 == n1 or n2 == a: continue\\n                    ans = max(ans, scores[a] + scores[b] + s1 + s2)\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n# key is to store top 3 neighbors for each node\\n# for each pair of edges (two middle nodes): find the other two nodes with highest score\\n# we can\\'t store top 1 node (highest node is neighbor in the edge) or 2 nodes (two middle nodes share the same highest adjacent node)\\n\\n\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        \\n        g = defaultdict(list)\\n        for a, b in edges:\\n            heappush(g[a], (scores[b], b))\\n            if len(g[a]) > 3:\\n                heappop(g[a])\\n            heappush(g[b], (scores[a], a))\\n            if len(g[b]) > 3:\\n                heappop(g[b])\\n        \\n        ans = -1\\n        for a, b in edges:\\n            for s1, n1 in g[a]:\\n                if n1 == b: continue\\n                for s2, n2 in g[b]:\\n                    if n2 == n1 or n2 == a: continue\\n                    ans = max(ans, scores[a] + scores[b] + s1 + s2)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1953821,
                "title": "similar-to-google-onsite-problem",
                "content": "Found in discussion for this contest.\\nGoogle ONSITE problem : https://leetcode.com/discuss/interview-question/1621880/Google-or-Onsite-or-Maximum-total/1176827\\n\\n```\\n#define sz(x) static_cast<int32_t>(x.size())\\ntemplate <class T> inline void chmax(T &x,T y){ x = max((x), (y));}\\n\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n = scores.size();\\n        vector <vector<int>> g(n);\\n        for (auto it : edges) {\\n            g[it[0]].push_back(it[1]);\\n            g[it[1]].push_back(it[0]);\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            sort(g[i].begin(), g[i].end(), [&](const auto a1, const auto a2) {\\n                return scores[a1] > scores[a2];\\n            });\\n        }\\n        int ans = -1;\\n        for (auto e : edges) {\\n            int u = e[0];\\n            int v = e[1];\\n            for (int i = 0; i < 3; ++i) {\\n                for (int j = 0; j < 3; ++j) {\\n                    if (i < sz(g[u]) and j < sz(g[v]) and g[u][i] != g[v][j] and u != g[v][j] and v != g[u][i]) {\\n                        chmax(ans, scores[u] + scores[v] + scores[g[u][i]] + scores[g[v][j]]);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease UPVOTE if u liked my soltion.",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\n#define sz(x) static_cast<int32_t>(x.size())\\ntemplate <class T> inline void chmax(T &x,T y){ x = max((x), (y));}\\n\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n = scores.size();\\n        vector <vector<int>> g(n);\\n        for (auto it : edges) {\\n            g[it[0]].push_back(it[1]);\\n            g[it[1]].push_back(it[0]);\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            sort(g[i].begin(), g[i].end(), [&](const auto a1, const auto a2) {\\n                return scores[a1] > scores[a2];\\n            });\\n        }\\n        int ans = -1;\\n        for (auto e : edges) {\\n            int u = e[0];\\n            int v = e[1];\\n            for (int i = 0; i < 3; ++i) {\\n                for (int j = 0; j < 3; ++j) {\\n                    if (i < sz(g[u]) and j < sz(g[v]) and g[u][i] != g[v][j] and u != g[v][j] and v != g[u][i]) {\\n                        chmax(ans, scores[u] + scores[v] + scores[g[u][i]] + scores[g[v][j]]);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310762,
                "title": "java-pq-easy-to-understand-with-explanation",
                "content": "scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]\\n1. Create an array of Priority Queues to store node (at index) and its all the neighboring nodes in a Priority Queue.\\n2. iterate over the scores/nodes len, at each index, create a new priority queue sorted by chronological order, at each index of the array.\\n3. iterate over the edges, for each edge, get the starting node and the ending node, create a bi directional edge btween starting node and the ending node. since we only want the longest path for the max of 4 nodes, if the size gets bigger than 3, poll the smaller value from the queue.\\n4. now iterate over the edges, look at all the neighbors, if none of the neighbors are equal, then get the max value between all the current max and the scores of all edges. scores[u] + scores[v] + scores[k] + scores[t]\\n5. return the max result.\\ntime: O(E+V), generating pq list takes O(E+V), nested for loops take O(E)\\nspace: O(V), pq list\\n\\n``` \\nclass Solution {\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        if (scores == null || scores.length == 0 || edges == null || edges.length == 0) {\\n            return -1;\\n        }\\n        int n = scores.length;\\n        \\n        PriorityQueue<Integer>[] neighbors = new PriorityQueue[n];\\n        \\n        // Create an array of Priority Queues to store node (at index) and its all the neighboring nodes in a Priority Queue.\\n        // O(V)\\n        for (int i = 0; i < n; i++) {\\n            neighbors[i] = new PriorityQueue<Integer>((a, b) -> scores[a] - scores[b]);\\n        }\\n        \\n        // O(E)\\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            neighbors[u].offer(v);\\n            neighbors[v].offer(u);\\n            if (neighbors[u].size() > 3) neighbors[u].poll();\\n            if (neighbors[v].size() > 3) neighbors[v].poll();\\n        }\\n        \\n        // in case there are no edges at all between all the nodes\\n        int res = -1;\\n        \\n        // O(E)\\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            for (int nei1 : neighbors[u]) {\\n                for (int nei2 : neighbors[v]) {\\n                    if (nei1 != v && nei2 != u && nei1 != nei2) {\\n                        res = Math.max(res, scores[u] + scores[v] + scores[nei1] + scores[nei2]);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        if (scores == null || scores.length == 0 || edges == null || edges.length == 0) {\\n            return -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1984916,
                "title": "python3-o-e-solution",
                "content": "```\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n      \\n      connection = {}\\n      \\n      for source, target in edges:\\n        if source not in connection: connection[source] = [target]\\n        else: connection[source].append(target)\\n          \\n        if target not in connection: connection[target] = [source]\\n        else: connection[target].append(source)\\n          \\n      res = -1\\n      \\n      max_dict = {}\\n      for key, value in connection.items():\\n        max1, max2, max3 = -sys.maxsize, -sys.maxsize, -sys.maxsize\\n        n1, n2, n3 = None, None, None\\n        for element in value:\\n          if scores[element] > max1:\\n            max1, max2, max3 = scores[element], max1, max2\\n            n1, n2, n3 = element, n1, n2\\n          elif scores[element] > max2:\\n            max2, max3 = scores[element], max2\\n            n2, n3 = element, n2\\n          elif scores[element] > max3:\\n            max3 = scores[element]\\n            n3 = element\\n        max_dict[key] = []\\n        if n1 != None: max_dict[key].append(n1)\\n        if n2 != None: max_dict[key].append(n2)\\n        if n3 != None: max_dict[key].append(n3)\\n             \\n      for source, target in edges:\\n        base = scores[source] + scores[target]\\n        \\n        n_s = max_dict[source]\\n        n_t = max_dict[target]\\n        if len(n_s) == 1 or len(n_t) == 1:\\n          pass\\n        else:\\n          new_n_s = [x for x in n_s if x != target]\\n          new_n_t = [x for x in n_t if x != source]\\n          if new_n_s[0] != new_n_t[0]:\\n            res = max(res, base + scores[new_n_s[0]] + scores[new_n_t[0]])\\n          else:\\n            if len(new_n_s) > 1:\\n              res = max(res, base + scores[new_n_s[1]] + scores[new_n_t[0]])\\n            if len(new_n_t) > 1:\\n              res = max(res, base + scores[new_n_s[0]] + scores[new_n_t[1]])      \\n    \\n      return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n      \\n      connection = {}\\n      \\n      for source, target in edges:\\n        if source not in connection: connection[source] = [target]\\n        else: connection[source].append(target)\\n          \\n        if target not in connection: connection[target] = [source]\\n        else: connection[target].append(source)\\n          \\n      res = -1\\n      \\n      max_dict = {}\\n      for key, value in connection.items():\\n        max1, max2, max3 = -sys.maxsize, -sys.maxsize, -sys.maxsize\\n        n1, n2, n3 = None, None, None\\n        for element in value:\\n          if scores[element] > max1:\\n            max1, max2, max3 = scores[element], max1, max2\\n            n1, n2, n3 = element, n1, n2\\n          elif scores[element] > max2:\\n            max2, max3 = scores[element], max2\\n            n2, n3 = element, n2\\n          elif scores[element] > max3:\\n            max3 = scores[element]\\n            n3 = element\\n        max_dict[key] = []\\n        if n1 != None: max_dict[key].append(n1)\\n        if n2 != None: max_dict[key].append(n2)\\n        if n3 != None: max_dict[key].append(n3)\\n             \\n      for source, target in edges:\\n        base = scores[source] + scores[target]\\n        \\n        n_s = max_dict[source]\\n        n_t = max_dict[target]\\n        if len(n_s) == 1 or len(n_t) == 1:\\n          pass\\n        else:\\n          new_n_s = [x for x in n_s if x != target]\\n          new_n_t = [x for x in n_t if x != source]\\n          if new_n_s[0] != new_n_t[0]:\\n            res = max(res, base + scores[new_n_s[0]] + scores[new_n_t[0]])\\n          else:\\n            if len(new_n_s) > 1:\\n              res = max(res, base + scores[new_n_s[1]] + scores[new_n_t[0]])\\n            if len(new_n_t) > 1:\\n              res = max(res, base + scores[new_n_s[0]] + scores[new_n_t[1]])      \\n    \\n      return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958964,
                "title": "python-easy-and-simple-solution-o-n",
                "content": "Based on https://leetcode.com/problems/maximum-score-of-a-node-sequence/discuss/1953669/Python3-Explanation-with-pictures-top-3-neighbors\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        G = defaultdict(list)\\n        for v,w in edges:\\n            G[v].append(w)\\n            G[w].append(v)\\n        res = float(\\'-inf\\')\\n        for v in G:\\n            G[v].sort(key = lambda w:-scores[w])\\n        for v in G:\\n            G[v] = set(G[v][:3])\\n        res = float(\\'-inf\\')\\n        for v, w in edges:\\n            tmp = scores[v]+scores[w]\\n            for x in G[v]-set([w]):\\n                for y in G[w]-set([v]):\\n                    if x!=y:\\n                        res = max(res, tmp + scores[x]+scores[y])\\n        return res if res != float(\\'-inf\\') else -1\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Based on https://leetcode.com/problems/maximum-score-of-a-node-sequence/discuss/1953669/Python3-Explanation-with-pictures-top-3-neighbors\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        G = defaultdict(list)\\n        for v,w in edges:\\n            G[v].append(w)\\n            G[w].append(v)\\n        res = float(\\'-inf\\')\\n        for v in G:\\n            G[v].sort(key = lambda w:-scores[w])\\n        for v in G:\\n            G[v] = set(G[v][:3])\\n        res = float(\\'-inf\\')\\n        for v, w in edges:\\n            tmp = scores[v]+scores[w]\\n            for x in G[v]-set([w]):\\n                for y in G[w]-set([v]):\\n                    if x!=y:\\n                        res = max(res, tmp + scores[x]+scores[y])\\n        return res if res != float(\\'-inf\\') else -1\\n",
                "codeTag": "Java"
            },
            {
                "id": 1954909,
                "title": "javascript-min-heap-solution-to-keep-3-biggest-neighbors",
                "content": "```\\nclass Heap {\\n  constructor(data = []) {\\n    this.data = data;\\n    this.comparator = (a, b) => a[1] - b[1];\\n    this.heapify();\\n  }\\n\\n  // O(nlog(n)). In fact, O(n)\\n  heapify() {\\n    if (this.size() < 2) return;\\n    for (let i = 1; i < this.size(); i++) {\\n      this.bubbleUp(i);\\n    }\\n  }\\n\\n  // O(1)\\n  peek() {\\n    if (this.size() === 0) return null;\\n    return this.data[0];\\n  }\\n\\n  // O(log(n))\\n  offer(value) {\\n    this.data.push(value);\\n    this.bubbleUp(this.size() - 1);\\n  }\\n\\n  // O(log(n))\\n  poll() {\\n    if (this.size() === 0) return null;\\n    const result = this.data[0];\\n    const last = this.data.pop();\\n    if (this.size() !== 0) {\\n      this.data[0] = last;\\n      this.bubbleDown(0);\\n    }\\n    return result;\\n  }\\n\\n  // O(log(n))\\n  bubbleUp(index) {\\n    while (index > 0) {\\n      const parentIndex = (index - 1) >> 1;\\n      if (this.comparator(this.data[index], this.data[parentIndex]) < 0) {\\n        this.swap(index, parentIndex);\\n        index = parentIndex;\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n\\n  // O(log(n))\\n  bubbleDown(index) {\\n    const lastIndex = this.size() - 1;\\n    while (true) {\\n      const leftIndex = index * 2 + 1;\\n      const rightIndex = index * 2 + 2;\\n      let findIndex = index;\\n      if (\\n        leftIndex <= lastIndex &&\\n        this.comparator(this.data[leftIndex], this.data[findIndex]) < 0\\n      ) {\\n        findIndex = leftIndex;\\n      }\\n      if (\\n        rightIndex <= lastIndex &&\\n        this.comparator(this.data[rightIndex], this.data[findIndex]) < 0\\n      ) {\\n        findIndex = rightIndex;\\n      }\\n      if (index !== findIndex) {\\n        this.swap(index, findIndex);\\n        index = findIndex;\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n\\n  // O(1)\\n  swap(index1, index2) {\\n    [this.data[index1], this.data[index2]] = [\\n      this.data[index2],\\n      this.data[index1]\\n    ];\\n  }\\n\\n  // O(1)\\n  size() {\\n    return this.data.length;\\n  }\\n    \\n    \\n  toArray() {\\n    return this.data.reverse().map(dt => dt.index)\\n  }\\n}\\n\\n/**\\n * @param {number[]} scores\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nconst maximumScore = (scores, edges) => {\\n    const n = scores.length\\n    \\n    let top3 = new Array(n).fill().map(() => new Heap())\\n    \\n    for (let [u, v] of edges) {\\n        top3[u].offer(([v, scores[v]]))\\n        if (top3[u].size() > 3)\\n            top3[u].poll()\\n        top3[v].offer(([u, scores[u]]))\\n        if (top3[v].size() > 3)\\n            top3[v].poll()\\n    }\\n    \\n    let top3Array = new Array(n)\\n    \\n    for (let i = 0; i < n; i++) {\\n       top3Array[i] = [...top3[i].data]\\n    }\\n    \\n    \\n    let ans = -1\\n    for (let [b, c] of edges) {\\n        if (top3[b].size() < 2 || top3[c].size() < 2) {\\n            continue\\n        }\\n        \\n        let score = scores[b] + scores[c]\\n        \\n        for (let [a, scoreA] of top3Array[b]) {\\n            for (let [d, scoreD] of top3Array[c]) {\\n                if (a !== b && a !== c && d !== b && d !== c && a !== d) {\\n                    ans = Math.max(ans, scoreA + score + scoreD)\\n                }\\n            }\\n        }\\n    }\\n  \\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Heap {\\n  constructor(data = []) {\\n    this.data = data;\\n    this.comparator = (a, b) => a[1] - b[1];\\n    this.heapify();\\n  }\\n\\n  // O(nlog(n)). In fact, O(n)\\n  heapify() {\\n    if (this.size() < 2) return;\\n    for (let i = 1; i < this.size(); i++) {\\n      this.bubbleUp(i);\\n    }\\n  }\\n\\n  // O(1)\\n  peek() {\\n    if (this.size() === 0) return null;\\n    return this.data[0];\\n  }\\n\\n  // O(log(n))\\n  offer(value) {\\n    this.data.push(value);\\n    this.bubbleUp(this.size() - 1);\\n  }\\n\\n  // O(log(n))\\n  poll() {\\n    if (this.size() === 0) return null;\\n    const result = this.data[0];\\n    const last = this.data.pop();\\n    if (this.size() !== 0) {\\n      this.data[0] = last;\\n      this.bubbleDown(0);\\n    }\\n    return result;\\n  }\\n\\n  // O(log(n))\\n  bubbleUp(index) {\\n    while (index > 0) {\\n      const parentIndex = (index - 1) >> 1;\\n      if (this.comparator(this.data[index], this.data[parentIndex]) < 0) {\\n        this.swap(index, parentIndex);\\n        index = parentIndex;\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n\\n  // O(log(n))\\n  bubbleDown(index) {\\n    const lastIndex = this.size() - 1;\\n    while (true) {\\n      const leftIndex = index * 2 + 1;\\n      const rightIndex = index * 2 + 2;\\n      let findIndex = index;\\n      if (\\n        leftIndex <= lastIndex &&\\n        this.comparator(this.data[leftIndex], this.data[findIndex]) < 0\\n      ) {\\n        findIndex = leftIndex;\\n      }\\n      if (\\n        rightIndex <= lastIndex &&\\n        this.comparator(this.data[rightIndex], this.data[findIndex]) < 0\\n      ) {\\n        findIndex = rightIndex;\\n      }\\n      if (index !== findIndex) {\\n        this.swap(index, findIndex);\\n        index = findIndex;\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n\\n  // O(1)\\n  swap(index1, index2) {\\n    [this.data[index1], this.data[index2]] = [\\n      this.data[index2],\\n      this.data[index1]\\n    ];\\n  }\\n\\n  // O(1)\\n  size() {\\n    return this.data.length;\\n  }\\n    \\n    \\n  toArray() {\\n    return this.data.reverse().map(dt => dt.index)\\n  }\\n}\\n\\n/**\\n * @param {number[]} scores\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nconst maximumScore = (scores, edges) => {\\n    const n = scores.length\\n    \\n    let top3 = new Array(n).fill().map(() => new Heap())\\n    \\n    for (let [u, v] of edges) {\\n        top3[u].offer(([v, scores[v]]))\\n        if (top3[u].size() > 3)\\n            top3[u].poll()\\n        top3[v].offer(([u, scores[u]]))\\n        if (top3[v].size() > 3)\\n            top3[v].poll()\\n    }\\n    \\n    let top3Array = new Array(n)\\n    \\n    for (let i = 0; i < n; i++) {\\n       top3Array[i] = [...top3[i].data]\\n    }\\n    \\n    \\n    let ans = -1\\n    for (let [b, c] of edges) {\\n        if (top3[b].size() < 2 || top3[c].size() < 2) {\\n            continue\\n        }\\n        \\n        let score = scores[b] + scores[c]\\n        \\n        for (let [a, scoreA] of top3Array[b]) {\\n            for (let [d, scoreD] of top3Array[c]) {\\n                if (a !== b && a !== c && d !== b && d !== c && a !== d) {\\n                    ans = Math.max(ans, scoreA + score + scoreD)\\n                }\\n            }\\n        }\\n    }\\n  \\n    return ans\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953676,
                "title": "c-sorting-bruteforce-greedy",
                "content": "\\n\\t// since path length = 4, we can greedily pick 4 nodes that make a simple path\\n    // sort the adjacency lists in decreasing order of node score\\n    // for every edge (x -> y) pick the next 2 nodes which are not in the current path, do the same for edge (y -> x) \\n```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& A, vector<vector<int>>& E) {\\n        int n = A.size();\\n        vector<vector<int>> adj(n);\\n        for (auto& x : E) {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            sort(adj[i].begin(), adj[i].end(), [&](int x, int y) {\\n                return A[x] > A[y];\\n            });\\n        }\\n\\t\\t\\n        int ans = -1;\\n        for (auto& t : E) {\\n            int x = t[0], y = t[1];\\n            int now = A[x] + A[y];\\n            for (int i = 0; i < 2; i++) {\\n                int count = 0;\\n                for (int v : adj[y]) {\\n                    if (v != x) {\\n                        for (int w : adj[v]) {\\n                            if (w != x && w != y) {\\n                                ans = max(ans, now + A[v] + A[w]);\\n                                ++count;\\n                                if (count >= 3) goto here;\\n                            }\\n                        }\\n                    }\\n                }\\n                here: swap(x, y);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumScore(vector<int>& A, vector<vector<int>>& E) {\\n        int n = A.size();\\n        vector<vector<int>> adj(n);\\n        for (auto& x : E) {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1953671,
                "title": "python3-simple-solution-by-sorting-edges",
                "content": "1. Since we need to search for sequences with a length of 4. This question can be converted into searching for two edges that connected with each other without sharing nodes.\\n2. Sort all edges by the sum of two nodes it connects in descending order.\\n3. Traverse edges and search for the largest connected edge in visited for each loop.\\n```\\ndef maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n    graph = collections.defaultdict(list)\\n    for i, j in edges:\\n        graph[i].append(j)\\n        graph[j].append(i)\\n\\n    edges = [[scores[i] + scores[j], i, j] for i, j in edges]\\n    edges.sort(reverse=True)\\n    visited = []\\n\\n    ret = -1\\n    for s, i, j in edges:\\n        if visited and s + visited[0][0] <= ret: break # prune\\n        for ss, ii, jj in visited:\\n            if s + ss <= ret: break # prune\\n            if len({i, j, ii, jj}) < 4: continue\\n            if ii in graph[i] or jj in graph[i] or ii in graph[j] or jj in graph[j]: ret = max(ret, s + ss)\\n        visited.append([s, i, j])\\n    return ret\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n    graph = collections.defaultdict(list)\\n    for i, j in edges:\\n        graph[i].append(j)\\n        graph[j].append(i)\\n\\n    edges = [[scores[i] + scores[j], i, j] for i, j in edges]\\n    edges.sort(reverse=True)\\n    visited = []\\n\\n    ret = -1\\n    for s, i, j in edges:\\n        if visited and s + visited[0][0] <= ret: break # prune\\n        for ss, ii, jj in visited:\\n            if s + ss <= ret: break # prune\\n            if len({i, j, ii, jj}) < 4: continue\\n            if ii in graph[i] or jj in graph[i] or ii in graph[j] or jj in graph[j]: ret = max(ret, s + ss)\\n        visited.append([s, i, j])\\n    return ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2310837,
                "title": "why-only-store-the-3-adjacent-nodes-in-hint-4",
                "content": "Hi,\\n\\nfor the hint 4\\nsorry I don\\'t get why only store the 3 adjacent nodes will prevent duplicate?\\ndid someone can explan it to me?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2304624,
                "title": "leetcode-the-hard-way-find-the-neighbours-explanation",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\nThe key idea is to find the best three neighbours for each node. We need to keep the order based on the scores. We can use priority queue but in C++ it is not convenient to iterate it at the end, instead we use set as it is sorted internally. After that, we just need to iterate them to find out all the combinations. However, we need to check if they are duplicate before updating the answer.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n = scores.size();\\n        // find the best neighbours (at most 3)\\n        vector<set<pair<int, int>>> m(n);\\n        for(auto x : edges) {\\n            int u = x[0], v = x[1];\\n            m[u].insert({scores[v], v});\\n            m[v].insert({scores[u], u});\\n            if (m[u].size() > 3) m[u].erase(m[u].begin());\\n            if (m[v].size() > 3) m[v].erase(m[v].begin());\\n        }\\n        // iterate each combination to find the answer\\n        int ans = -1;\\n        for (auto x : edges) {\\n            int u = x[0], v = x[1];\\n            for (auto x1 : m[u]) {\\n                for (auto x2 : m[v]) {\\n                    // skip some cases\\n                    if (x1.second != x2.second && x1.second != v && x2.second != u) {\\n                        ans = max(ans, scores[u] + scores[v] + x1.first + x2.first);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n = scores.size();\\n        // find the best neighbours (at most 3)\\n        vector<set<pair<int, int>>> m(n);\\n        for(auto x : edges) {\\n            int u = x[0], v = x[1];\\n            m[u].insert({scores[v], v});\\n            m[v].insert({scores[u], u});\\n            if (m[u].size() > 3) m[u].erase(m[u].begin());\\n            if (m[v].size() > 3) m[v].erase(m[v].begin());\\n        }\\n        // iterate each combination to find the answer\\n        int ans = -1;\\n        for (auto x : edges) {\\n            int u = x[0], v = x[1];\\n            for (auto x1 : m[u]) {\\n                for (auto x2 : m[v]) {\\n                    // skip some cases\\n                    if (x1.second != x2.second && x1.second != v && x2.second != u) {\\n                        ans = max(ans, scores[u] + scores[v] + x1.first + x2.first);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246009,
                "title": "c-top-3-runtime-beats-99-memory-beats-99",
                "content": "Not my idea, I found it from lee215 post.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {     \\n        const int N = scores.size();        \\n        vector<array<int,3>> nb(N, {-1,-1,-1});\\n        \\n        auto connect = [&](int a, int b) {\\n            auto &aa = nb[a];\\n            \\n            if (aa[0] == -1 || scores[b] > scores[aa[0]])\\n             aa[2] = aa[1], aa[1] = aa[0], aa[0] = b;\\n            else if (aa[1] == -1 || scores[b] > scores[aa[1]])\\n             aa[2] = aa[1], aa[1] = b;\\n            else if (aa[2] == -1 || scores[b] > scores[aa[2]])\\n             aa[2] = b;            \\n        };\\n                \\n        for (auto &e: edges) {\\n            connect(e[0], e[1]);\\n            connect(e[1], e[0]);\\n        }\\n\\n        int res = -1;\\n\\n        for (auto &e: edges) {\\n            const int a = e[0], b = e[1];\\n            const int ab = scores[a] + scores[b];\\n\\n            for (int aa=0; aa<3; aa++)\\n                for (int bb=0; bb<3; bb++)\\n                    if (nb[a][aa] != -1 && nb[b][bb] != -1 && nb[a][aa] != nb[b][bb] && nb[a][aa] != b && nb[b][bb] != a)\\n                        res = max(res, scores[nb[a][aa]] + scores[nb[b][bb]] + ab);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {     \\n        const int N = scores.size();        \\n        vector<array<int,3>> nb(N, {-1,-1,-1});\\n        \\n        auto connect = [&](int a, int b) {\\n            auto &aa = nb[a];\\n            \\n            if (aa[0] == -1 || scores[b] > scores[aa[0]])\\n             aa[2] = aa[1], aa[1] = aa[0], aa[0] = b;\\n            else if (aa[1] == -1 || scores[b] > scores[aa[1]])\\n             aa[2] = aa[1], aa[1] = b;\\n            else if (aa[2] == -1 || scores[b] > scores[aa[2]])\\n             aa[2] = b;            \\n        };\\n                \\n        for (auto &e: edges) {\\n            connect(e[0], e[1]);\\n            connect(e[1], e[0]);\\n        }\\n\\n        int res = -1;\\n\\n        for (auto &e: edges) {\\n            const int a = e[0], b = e[1];\\n            const int ab = scores[a] + scores[b];\\n\\n            for (int aa=0; aa<3; aa++)\\n                for (int bb=0; bb<3; bb++)\\n                    if (nb[a][aa] != -1 && nb[b][bb] != -1 && nb[a][aa] != nb[b][bb] && nb[a][aa] != b && nb[b][bb] != a)\\n                        res = max(res, scores[nb[a][aa]] + scores[nb[b][bb]] + ab);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193581,
                "title": "java-priorityqueue",
                "content": "If we look at it from edges point of view, the center 2 vertices are joined by the edges. \\nSo here is an idea - go through all the edges and make the vertices in the edge as the center 2 vertices, \\nthen we select the 1 next biggest node from each of the center vertex. we can preprocess this with a priorityqueue.\\n\\nI tried to think of an elegant way to select the best element from the heap, but I gave up. \\nJust iterate through them is good enough because we only have to keep the top 3.\\n```Java\\nclass Solution {\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        PriorityQueue<Integer>[] minheap = new PriorityQueue[scores.length];\\n        Comparator<Integer> cmp = Comparator.comparingInt(o -> scores[o]);\\n        Arrays.setAll(minheap, o -> new PriorityQueue<>(cmp));\\n        for (int[] e : edges){\\n            minheap[e[0]].offer(e[1]);\\n            minheap[e[1]].offer(e[0]);\\n            if (minheap[e[0]].size()>3){\\n                minheap[e[0]].poll();\\n            }\\n            if (minheap[e[1]].size()>3){\\n                minheap[e[1]].poll();\\n            }\\n        }\\n\\n        int ans = -1;\\n        for (int[] e : edges){\\n            for (int x : minheap[e[0]]){\\n                if (x != e[1]){\\n                    for (int y : minheap[e[1]]){\\n                        if (y != e[0] && y != x){\\n                            ans = Math.max(ans, scores[x] + scores[y] + scores[e[0]] + scores[e[1]]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        PriorityQueue<Integer>[] minheap = new PriorityQueue[scores.length];\\n        Comparator<Integer> cmp = Comparator.comparingInt(o -> scores[o]);\\n        Arrays.setAll(minheap, o -> new PriorityQueue<>(cmp));\\n        for (int[] e : edges){\\n            minheap[e[0]].offer(e[1]);\\n            minheap[e[1]].offer(e[0]);\\n            if (minheap[e[0]].size()>3){\\n                minheap[e[0]].poll();\\n            }\\n            if (minheap[e[1]].size()>3){\\n                minheap[e[1]].poll();\\n            }\\n        }\\n\\n        int ans = -1;\\n        for (int[] e : edges){\\n            for (int x : minheap[e[0]]){\\n                if (x != e[1]){\\n                    for (int y : minheap[e[1]]){\\n                        if (y != e[0] && y != x){\\n                            ans = Math.max(ans, scores[x] + scores[y] + scores[e[0]] + scores[e[1]]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163257,
                "title": "java-solution",
                "content": "class Solution {\\n    \\n    public int maximumScore(int[] scores, int[][] edges) {\\n        \\n        Graph g = new Graph(scores.length);\\n        \\n        for (int i=0; i<edges.length; i++) {\\n            g.addEdge(edges[i][0], edges[i][1]);\\n        }\\n        \\n        for (int i=0; i<scores.length; i++) {\\n            Collections.sort(g.arr.get(i), new Comparator<Integer>(){\\n               public int compare(Integer a, Integer b)\\n               {\\n                   return(scores[b] - scores[a]);\\n               }\\n           });\\n        }\\n        \\n        int ans = -1;\\n        \\n        for (int i=0; i<edges.length; i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            \\n            for (int j=0; j < Math.min(3, g.arr.get(u).size()); j++) {\\n                int x = g.arr.get(u).get(j);\\n                if (x == v) {\\n                    continue;\\n                }\\n                \\n                for (int k=0; k < Math.min(3, g.arr.get(v).size()); k++) {\\n                    int y = g.arr.get(v).get(k);\\n                    if (y == u || y == x) {\\n                        continue;\\n                    }\\n                    \\n                    ans = Math.max(ans, scores[u] + scores[v] + scores[x] + scores[y]);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\nclass Graph {\\n    int V;\\n    ArrayList<ArrayList<Integer>> arr;\\n    \\n    public Graph(int v) {\\n        V = v;\\n        arr = new ArrayList<>();\\n        for (int i=0; i<v; i++) {\\n            arr.add(new ArrayList<>());\\n        }\\n    }\\n    \\n    public void addEdge(int u, int v) {\\n        arr.get(u).add(v);\\n        arr.get(v).add(u);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public int maximumScore(int[] scores, int[][] edges) {\\n        \\n        Graph g = new Graph(scores.length);\\n        \\n        for (int i=0; i<edges.length; i++) {\\n            g.addEdge(edges[i][0], edges[i][1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2093745,
                "title": "c-straightforward",
                "content": "\\tIdea: Check every edge (nodeA - nodeB) satisfy nodeA have another adj node != nodeB and nodeB have another adj node != nodeA\\n\\t\\n\\tTime: O(n * log(3)) + O(n * 9) = O(n)\\n\\tSpace: O(n)\\n\\t\\n\\tclass Solution {\\n\\tpublic:    \\n\\t\\tint maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n\\t\\t\\tint nodes = scores.size();\\n\\n\\t\\t\\tauto compare = [&scores] (const int& nodeA, const int& nodeB) {\\n\\t\\t\\t\\treturn scores[nodeA] > scores[nodeB];\\n\\t\\t\\t};\\n\\t\\t\\tvector<vector<int>> graph;\\n\\t\\t\\tgraph.resize(nodes);\\n\\n\\t\\t\\tfor(auto& e : edges) { // O(n * log(3))\\n\\t\\t\\t\\tint nodeA = e[0], nodeB = e[1];\\n\\t\\t\\t\\tgraph[nodeA].push_back(nodeB);\\n\\t\\t\\t\\tgraph[nodeB].push_back(nodeA);\\n\\n\\t\\t\\t\\tsort(graph[nodeA].begin(), graph[nodeA].end(), compare);\\n\\t\\t\\t\\tsort(graph[nodeB].begin(), graph[nodeB].end(), compare);\\n\\n\\t\\t\\t\\tif(graph[nodeA].size() > 3) graph[nodeA].pop_back(); \\n\\t\\t\\t\\tif(graph[nodeB].size() > 3) graph[nodeB].pop_back();\\n\\t\\t\\t}\\n\\n\\t\\t\\tint ans = -1;\\n\\t\\t\\tfor(auto& e : edges) { // O(n * 9)\\n\\t\\t\\t\\tint nodeA = e[0], nodeB = e[1];\\n\\n\\t\\t\\t\\tfor(auto& a : graph[nodeA]) // O(9)\\n\\t\\t\\t\\t\\tfor(auto& b : graph[nodeB]) \\n\\t\\t\\t\\t\\t\\tif(a != nodeB && b != nodeA && a != b) \\n\\t\\t\\t\\t\\t\\t\\tans = max(ans, scores[nodeA] + scores[nodeB] + scores[a] + scores[b]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:    \\n\\t\\tint maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n\\t\\t\\tint nodes = scores.size();\\n\\n\\t\\t\\tauto compare = [&scores] (const int& nodeA, const int& nodeB) {\\n\\t\\t\\t\\treturn scores[nodeA] > scores[nodeB];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1958051,
                "title": "c-solution-without-priority-queue-100",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef vector<vector<int>> vvi;\\n    typedef vector<int> vi;\\n    typedef vector<vector<bool>> vvb;\\n    typedef vector<bool> vb;\\n    typedef vector<vector<string>> vvs;\\n    typedef vector<string> vs;\\n    typedef long long ll;\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int sz=scores.size();\\n        vvi graph(sz);\\n        for(auto x:edges){\\n            int u=x[0];\\n            int v=x[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        int ans=-1;\\n        auto comp=[&scores](const int p1,int p2){return scores[p1]>scores[p2];};\\n        for(int i=0;i<sz;i++){\\n            sort(graph[i].begin(),graph[i].end(),comp);\\n        }\\n        for(int k=0;k<edges.size();k++){\\n            int u=edges[k][0];\\n            int v=edges[k][1];\\n            int least=scores[u]+scores[v];\\n            for(int i=0;i<min(3,int(graph[u].size()));i++){\\n                int x=graph[u][i];\\n                if(x==v) continue;\\n                for(int j=0;j<min(3,int(graph[v].size()));j++){\\n                    int y=graph[v][j];\\n                    if(y==x || y==u) continue;\\n                    ans=max(ans,least+scores[x]+scores[y]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef vector<vector<int>> vvi;\\n    typedef vector<int> vi;\\n    typedef vector<vector<bool>> vvb;\\n    typedef vector<bool> vb;\\n    typedef vector<vector<string>> vvs;\\n    typedef vector<string> vs;\\n    typedef long long ll;\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int sz=scores.size();\\n        vvi graph(sz);\\n        for(auto x:edges){\\n            int u=x[0];\\n            int v=x[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        int ans=-1;\\n        auto comp=[&scores](const int p1,int p2){return scores[p1]>scores[p2];};\\n        for(int i=0;i<sz;i++){\\n            sort(graph[i].begin(),graph[i].end(),comp);\\n        }\\n        for(int k=0;k<edges.size();k++){\\n            int u=edges[k][0];\\n            int v=edges[k][1];\\n            int least=scores[u]+scores[v];\\n            for(int i=0;i<min(3,int(graph[u].size()));i++){\\n                int x=graph[u][i];\\n                if(x==v) continue;\\n                for(int j=0;j<min(3,int(graph[v].size()));j++){\\n                    int y=graph[v][j];\\n                    if(y==x || y==u) continue;\\n                    ans=max(ans,least+scores[x]+scores[y]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954360,
                "title": "c-100-in-time-100-in-space-clear-concise-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int find(int first, int second, unordered_map<int, vector<int>>& adjlist, vector<int>& scores){\\n\\t\\t// we have fixed first and second node, now to choose third and fourth node just have to pick the highest score neighbour (which would be either [0], [1], [2] in the adjlist)\\n\\t\\t\\n        int third, fourth;\\n\\t\\t\\n\\t\\t// third node will be the highest score element in adjacency list , considering it is not second\\n        if(adjlist[first][0]!=second){\\n            third= adjlist[first][0];\\n        }\\n        else if(adjlist[first].size()==1){\\n            return -1;\\n        }\\n        else{ // if highest score element is second then choose 2nd hightest score element to be third\\n            third= adjlist[first][1];\\n        }\\n\\n\\t\\t// similarly for fourth, but there are extra cases to see\\n\\t\\t// i.e. fourth node is the highest score element in adjacency list after first and third\\n\\t\\t\\n        if(adjlist[second][0]!=first && adjlist[second][0]!=third){\\n            fourth= adjlist[second][0];\\n        }\\n        else if(adjlist[second].size()==1){\\n            return -1;\\n        }\\n        else if(adjlist[second][1]!= first && adjlist[second][1]!=third){\\n            fourth= adjlist[second][1];\\n        }\\n        else if(adjlist[second].size()==2){\\n            return -1;\\n        }\\n        else{\\n            fourth= adjlist[second][2];\\n        }\\n\\n        return max(ans, scores[first]+scores[second]+scores[third]+scores[fourth]);\\n    }\\n    \\n    \\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n\\t\\n        unordered_map<int, vector<int>> adjlist;\\n\\t\\t// creating adjacency list\\n        for(vector<int> e: edges){\\n            adjlist[e[0]].push_back(e[1]);\\n            adjlist[e[1]].push_back(e[0]);\\n        }        \\n        \\n\\t\\t// sorting each adjacency list\\n        for(int i=0; i<scores.size(); i++){\\n            sort(adjlist[i].begin(), adjlist[i].end(), [&scores](int a, int b){return scores[a]>scores[b];});\\n        }\\n        \\n        \\n        int ans=-1;\\n        \\n\\t\\t// finding maximum score fixing a edge\\n\\t\\t// 2 calls to find fxn treating e[0] as first once and e[1] as first other time (it matters!)\\n        for(vector<int> e: edges){\\n            ans=max(ans, find(e[0], e[1], adjlist, scores));\\n            ans=max(ans, find(e[1], e[0], adjlist, scores));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int find(int first, int second, unordered_map<int, vector<int>>& adjlist, vector<int>& scores){\\n\\t\\t// we have fixed first and second node, now to choose third and fourth node just have to pick the highest score neighbour (which would be either [0], [1], [2] in the adjlist)\\n\\t\\t\\n        int third, fourth;\\n\\t\\t\\n\\t\\t// third node will be the highest score element in adjacency list , considering it is not second\\n        if(adjlist[first][0]!=second){\\n            third= adjlist[first][0];\\n        }\\n        else if(adjlist[first].size()==1){\\n            return -1;\\n        }\\n        else{ // if highest score element is second then choose 2nd hightest score element to be third\\n            third= adjlist[first][1];\\n        }\\n\\n\\t\\t// similarly for fourth, but there are extra cases to see\\n\\t\\t// i.e. fourth node is the highest score element in adjacency list after first and third\\n\\t\\t\\n        if(adjlist[second][0]!=first && adjlist[second][0]!=third){\\n            fourth= adjlist[second][0];\\n        }\\n        else if(adjlist[second].size()==1){\\n            return -1;\\n        }\\n        else if(adjlist[second][1]!= first && adjlist[second][1]!=third){\\n            fourth= adjlist[second][1];\\n        }\\n        else if(adjlist[second].size()==2){\\n            return -1;\\n        }\\n        else{\\n            fourth= adjlist[second][2];\\n        }\\n\\n        return max(ans, scores[first]+scores[second]+scores[third]+scores[fourth]);\\n    }\\n    \\n    \\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n\\t\\n        unordered_map<int, vector<int>> adjlist;\\n\\t\\t// creating adjacency list\\n        for(vector<int> e: edges){\\n            adjlist[e[0]].push_back(e[1]);\\n            adjlist[e[1]].push_back(e[0]);\\n        }        \\n        \\n\\t\\t// sorting each adjacency list\\n        for(int i=0; i<scores.size(); i++){\\n            sort(adjlist[i].begin(), adjlist[i].end(), [&scores](int a, int b){return scores[a]>scores[b];});\\n        }\\n        \\n        \\n        int ans=-1;\\n        \\n\\t\\t// finding maximum score fixing a edge\\n\\t\\t// 2 calls to find fxn treating e[0] as first once and e[1] as first other time (it matters!)\\n        for(vector<int> e: edges){\\n            ans=max(ans, find(e[0], e[1], adjlist, scores));\\n            ans=max(ans, find(e[1], e[0], adjlist, scores));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954297,
                "title": "c-soluton",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& sc, vector<vector<int>>&nums)\\n    {    \\n        int n=sc.size();\\n        vector<int>dp[n+1];\\n        for(auto it:nums)\\n        {\\n            dp[it[0]].push_back(it[1]);\\n            dp[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(dp[i].begin(),dp[i].end(),[&](auto &a,auto &b)\\n                 {\\n                     return sc[a]>sc[b];\\n                 });\\n        }\\n        int ans=-1;\\n        for(auto it:nums)\\n        {\\n            int a=it[0];\\n            int b=it[1];\\n            if(dp[a].size()<2||dp[b].size()<2)\\n            {\\n                continue;\\n            }\\n            for(int x=0;x<3&&x<dp[a].size();x++)\\n            {\\n                for(int y=0;y<3&&y<dp[b].size();y++)\\n                {\\n                    set<int>unique={a,b,dp[a][x],dp[b][y]};\\n                    if(unique.size()==4)\\n                    {\\n                        ans=max(ans,sc[a]+sc[b]+sc[dp[a][x]]+sc[dp[b][y]]);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& sc, vector<vector<int>>&nums)\\n    {    \\n        int n=sc.size();\\n        vector<int>dp[n+1];\\n        for(auto it:nums)\\n        {\\n            dp[it[0]].push_back(it[1]);\\n            dp[it[1]].push_back(it[0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(dp[i].begin(),dp[i].end(),[&](auto &a,auto &b)\\n                 {\\n                     return sc[a]>sc[b];\\n                 });\\n        }\\n        int ans=-1;\\n        for(auto it:nums)\\n        {\\n            int a=it[0];\\n            int b=it[1];\\n            if(dp[a].size()<2||dp[b].size()<2)\\n            {\\n                continue;\\n            }\\n            for(int x=0;x<3&&x<dp[a].size();x++)\\n            {\\n                for(int y=0;y<3&&y<dp[b].size();y++)\\n                {\\n                    set<int>unique={a,b,dp[a][x],dp[b][y]};\\n                    if(unique.size()==4)\\n                    {\\n                        ans=max(ans,sc[a]+sc[b]+sc[dp[a][x]]+sc[dp[b][y]]);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953905,
                "title": "c-simple-easy-to-understand-edge-traversal-o-elog3",
                "content": "/* iterate through each edge and check each node\\'s only heighest neighbor */\\n\\nclass Solution {\\npublic:\\n\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        vector<vector<int>> g(scores.size());\\n        \\n        for (auto &e : edges)\\n            g[e[0]].push_back(e[1]), g[e[1]].push_back(e[0]);\\n\\n        for (auto &i : g) \\n\\t\\tpartial_sort(begin(i),begin(i)+min<int>(3,i.size()),end(i),[&](auto &a, auto &b){return scores[a]>scores[b];});\\n        int ans = -1;\\n        for (auto &e : edges){\\n            auto u = e[0], v=e[1];\\n            auto sum = scores[u] +scores[v];\\n            for (auto u2 : g[u]){\\n                if (u2==v) continue;\\n                bool found=0;\\n                for (auto v2 : g[v]){\\n                    if (v2!=u2 && v2!=u  ){\\n                        ans =max(ans, scores[u2] +scores[v2] + sum);\\n                        found=1;\\n                        break;\\n                    } \\n                }\\n                if (found)\\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        vector<vector<int>> g(scores.size());\\n        \\n        for (auto &e : edges)\\n            g[e[0]].push_back(e[1]), g[e[1]].push_back(e[0]);\\n\\n        for (auto &i : g) \\n\\t\\tpartial_sort(begin(i),begin(i)+min<int>(3,i.size()),end(i),[&](auto &a, auto &b){return scores[a]>scores[b];}",
                "codeTag": "Java"
            },
            {
                "id": 1953881,
                "title": "java-beat-100",
                "content": "```\\nclass Solution {\\n    class Node {\\n        int value;\\n        Set<Node> next = new HashSet<>();\\n        public Node(int value) {\\n            this.value = value;\\n        }\\n        \\n        public void add(Node node) {\\n            next.add(node);\\n            node.next.add(this);\\n        }\\n    }\\n\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        Node[] list = new Node[scores.length];\\n        int maxValue = 0;\\n        for (int i = 0; i < list.length; i++) {\\n            list[i] = new Node(scores[i]);\\n            maxValue = Math.max(scores[i], maxValue);\\n        }\\n        for (int i = 0 ; i < edges.length; i++) {\\n            int[] p = edges[i];\\n            Node start = list[p[0]];\\n            Node end = list[p[1]];\\n            start.add(end);\\n        }\\n        \\n        int max = -1;\\n        for (int[] p : edges) {\\n            Node start = list[p[0]];\\n            Node end = list[p[1]];\\n            if (start.value + end.value + maxValue + maxValue <= max) {\\n                continue;\\n            }\\n            Queue<Node> q = new PriorityQueue<>(new Comparator<>() {\\n                public int compare(Node n1, Node n2) {\\n                    return n2.value - n1.value;\\n                }\\n            });\\n            for (Node n : start.next) {\\n                if (n != end) {\\n                    q.offer(n);\\n                }\\n            }\\n            if (q.size() == 0) {\\n                continue;\\n            }\\n            Node start1 = q.poll();\\n            Node start2 = q.poll();\\n            q.clear();\\n            for (Node n : end.next) {\\n                if (n != start)\\n                    q.offer(n);\\n            }\\n            if (q.size() == 0) {\\n                continue;\\n            }\\n            Node end1 = q.poll();\\n            Node end2 = q.poll();\\n            int sum = start.value + end.value + start1.value;\\n            if (start1 != end1) {\\n                sum += end1.value;\\n            } else if (start2 == null && end2 == null) {\\n                continue;\\n            } else if (start2 != null && end2 != null) {\\n                sum += Math.max(start2.value, end2.value);\\n            } else if (start2 == null) {\\n                sum += end2.value;\\n            } else {\\n                sum += start2.value;\\n            }\\n            max = Math.max(sum, max);\\n        }\\n        \\n        return max;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Node {\\n        int value;\\n        Set<Node> next = new HashSet<>();\\n        public Node(int value) {\\n            this.value = value;\\n        }\\n        \\n        public void add(Node node) {\\n            next.add(node);\\n            node.next.add(this);\\n        }\\n    }\\n\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        Node[] list = new Node[scores.length];\\n        int maxValue = 0;\\n        for (int i = 0; i < list.length; i++) {\\n            list[i] = new Node(scores[i]);\\n            maxValue = Math.max(scores[i], maxValue);\\n        }\\n        for (int i = 0 ; i < edges.length; i++) {\\n            int[] p = edges[i];\\n            Node start = list[p[0]];\\n            Node end = list[p[1]];\\n            start.add(end);\\n        }\\n        \\n        int max = -1;\\n        for (int[] p : edges) {\\n            Node start = list[p[0]];\\n            Node end = list[p[1]];\\n            if (start.value + end.value + maxValue + maxValue <= max) {\\n                continue;\\n            }\\n            Queue<Node> q = new PriorityQueue<>(new Comparator<>() {\\n                public int compare(Node n1, Node n2) {\\n                    return n2.value - n1.value;\\n                }\\n            });\\n            for (Node n : start.next) {\\n                if (n != end) {\\n                    q.offer(n);\\n                }\\n            }\\n            if (q.size() == 0) {\\n                continue;\\n            }\\n            Node start1 = q.poll();\\n            Node start2 = q.poll();\\n            q.clear();\\n            for (Node n : end.next) {\\n                if (n != start)\\n                    q.offer(n);\\n            }\\n            if (q.size() == 0) {\\n                continue;\\n            }\\n            Node end1 = q.poll();\\n            Node end2 = q.poll();\\n            int sum = start.value + end.value + start1.value;\\n            if (start1 != end1) {\\n                sum += end1.value;\\n            } else if (start2 == null && end2 == null) {\\n                continue;\\n            } else if (start2 != null && end2 != null) {\\n                sum += Math.max(start2.value, end2.value);\\n            } else if (start2 == null) {\\n                sum += end2.value;\\n            } else {\\n                sum += start2.value;\\n            }\\n            max = Math.max(sum, max);\\n        }\\n        \\n        return max;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967843,
                "title": "o-e-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    void insert(int i, vector<int>& list, vector<int>& scores) {\\n        list.push_back(i);\\n        int n = list.size() - 1;\\n        while (n > 0 && scores[list[n]] > scores[list[n - 1]]) {\\n            swap(list[n], list[n - 1]);\\n            --n;\\n        }\\n        if (list.size() > 3)\\n            list.pop_back();\\n    }\\n    \\n    int getMax(\\n        const int& i, const int& j,\\n        const vector<int>& il, const vector<int>& jl,\\n        const vector<int>& scores\\n    ) {\\n        int ii = 0, jj = 0;\\n        if (il[ii] == j) {\\n            if (il.size() == ++ii)\\n                return -1;\\n        }\\n\\n        if (jl[jj] == i || jl[jj] == il[ii]) {\\n            if (jl.size() == ++jj)\\n                return -1;\\n        }\\n        if (jl[jj] == i || jl[jj] == il[ii]) {\\n            if (jl.size() == ++jj)\\n                return -1;\\n        }        \\n\\n        return scores[il[ii]] + scores[jl[jj]];\\n    }\\n\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n\\n        unordered_map<int, vector<int>> mem;\\n\\n        for (auto& e: edges) {\\n            insert(e[1], mem[e[0]], scores);\\n            insert(e[0], mem[e[1]], scores);\\n        }\\n\\n        // Try and get Result\\n        int ret = -1;\\n        for (auto& e: edges) {\\n            auto l = e[0], r = e[1];\\n            auto retTmp = max(\\n                getMax(l, r, mem[l], mem[r], scores),\\n                getMax(r, l, mem[r], mem[l], scores)\\n            );\\n    \\n            if (retTmp == -1)\\n                continue;\\n            ret = max(ret, scores[l] + scores[r] + retTmp);\\n        }\\n\\n        return ret;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void insert(int i, vector<int>& list, vector<int>& scores) {\\n        list.push_back(i);\\n        int n = list.size() - 1;\\n        while (n > 0 && scores[list[n]] > scores[list[n - 1]]) {\\n            swap(list[n], list[n - 1]);\\n            --n;\\n        }\\n        if (list.size() > 3)\\n            list.pop_back();\\n    }\\n    \\n    int getMax(\\n        const int& i, const int& j,\\n        const vector<int>& il, const vector<int>& jl,\\n        const vector<int>& scores\\n    ) {\\n        int ii = 0, jj = 0;\\n        if (il[ii] == j) {\\n            if (il.size() == ++ii)\\n                return -1;\\n        }\\n\\n        if (jl[jj] == i || jl[jj] == il[ii]) {\\n            if (jl.size() == ++jj)\\n                return -1;\\n        }\\n        if (jl[jj] == i || jl[jj] == il[ii]) {\\n            if (jl.size() == ++jj)\\n                return -1;\\n        }        \\n\\n        return scores[il[ii]] + scores[jl[jj]];\\n    }\\n\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n\\n        unordered_map<int, vector<int>> mem;\\n\\n        for (auto& e: edges) {\\n            insert(e[1], mem[e[0]], scores);\\n            insert(e[0], mem[e[1]], scores);\\n        }\\n\\n        // Try and get Result\\n        int ret = -1;\\n        for (auto& e: edges) {\\n            auto l = e[0], r = e[1];\\n            auto retTmp = max(\\n                getMax(l, r, mem[l], mem[r], scores),\\n                getMax(r, l, mem[r], mem[l], scores)\\n            );\\n    \\n            if (retTmp == -1)\\n                continue;\\n            ret = max(ret, scores[l] + scores[r] + retTmp);\\n        }\\n\\n        return ret;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929277,
                "title": "rust-tracking-top-3-neighbours",
                "content": "# Intuition\\n\\nIterate through all edges, and try to extend each edge into 3-edge sequences using an adjacency list.\\n\\n# Code\\n```rust\\nuse std::collections::BinaryHeap;\\nuse std::cmp::Reverse;\\n\\npub fn to_graph(\\n    edges: &Vec<(usize, usize)>,\\n    scores: &Vec<u32>,\\n) -> Vec<Vec<usize>> {\\n    const HEAP_THRESHOLD: usize = 3;\\n\\n    let n = scores.len();\\n\\n    let mut ret = vec![BinaryHeap::new(); n];\\n\\n    for &(v0, v1) in edges {\\n        let e0 = scores[v0];\\n        let e1 = scores[v1];\\n\\n        ret[v0].push(Reverse((e1, v1)));\\n        ret[v1].push(Reverse((e0, v0)));\\n\\n        if ret[v0].len() > HEAP_THRESHOLD {\\n            ret[v0].pop();\\n        }\\n        if ret[v1].len() > HEAP_THRESHOLD {\\n            ret[v1].pop();\\n        }\\n    }\\n\\n    ret.into_iter()\\n        .map(|heap| {\\n            heap.into_iter()\\n                .map(|e| e.0.1)\\n                .collect::<Vec<_>>()\\n        })\\n        .collect::<Vec<_>>()\\n}\\n\\nimpl Solution {\\n    pub fn maximum_score(scores: Vec<i32>, edges: Vec<Vec<i32>>) -> i32 {\\n        let scores = scores.into_iter()\\n            .map(|e| e as u32)\\n            .collect::<Vec<_>>();\\n        let edges = edges.into_iter()\\n            .filter(|v| v.len() == 2)\\n            .map(|v| {\\n                v.into_iter()\\n                    .map(|e| e as usize)\\n                    .collect::<Vec<_>>()\\n            })\\n            .map(|v| (v[0], v[1]))\\n            .filter(|(v0, v1)| v0 != v1)\\n            .collect::<Vec<_>>();\\n        let graph = to_graph(&edges, &scores);\\n\\n        let mut ret = None;\\n        for (v0, v1) in edges {\\n            let mut _ret = None;\\n            for v0_next in graph[v0].clone() {\\n                if v0_next == v1 { continue; }\\n                let e0_next = scores[v0_next];\\n                for v1_next in graph[v1].clone() {\\n                    if v1_next == v0 { continue; }\\n                    if v0_next == v1_next { continue; }\\n                    let e1_next = scores[v1_next];\\n                    _ret = Some(_ret.unwrap_or(u32::MIN).max(e0_next + e1_next));\\n                }\\n            }\\n            let mut _ret = if let Some(inner) = _ret {\\n                inner\\n            } else { continue; };\\n            _ret += scores[v0];\\n            _ret += scores[v1];\\n\\n            ret = Some(ret.unwrap_or(u32::MIN).max(_ret));\\n        }\\n\\n        ret.map(|e| e as i32)\\n            .unwrap_or(-1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```rust\\nuse std::collections::BinaryHeap;\\nuse std::cmp::Reverse;\\n\\npub fn to_graph(\\n    edges: &Vec<(usize, usize)>,\\n    scores: &Vec<u32>,\\n) -> Vec<Vec<usize>> {\\n    const HEAP_THRESHOLD: usize = 3;\\n\\n    let n = scores.len();\\n\\n    let mut ret = vec![BinaryHeap::new(); n];\\n\\n    for &(v0, v1) in edges {\\n        let e0 = scores[v0];\\n        let e1 = scores[v1];\\n\\n        ret[v0].push(Reverse((e1, v1)));\\n        ret[v1].push(Reverse((e0, v0)));\\n\\n        if ret[v0].len() > HEAP_THRESHOLD {\\n            ret[v0].pop();\\n        }\\n        if ret[v1].len() > HEAP_THRESHOLD {\\n            ret[v1].pop();\\n        }\\n    }\\n\\n    ret.into_iter()\\n        .map(|heap| {\\n            heap.into_iter()\\n                .map(|e| e.0.1)\\n                .collect::<Vec<_>>()\\n        })\\n        .collect::<Vec<_>>()\\n}\\n\\nimpl Solution {\\n    pub fn maximum_score(scores: Vec<i32>, edges: Vec<Vec<i32>>) -> i32 {\\n        let scores = scores.into_iter()\\n            .map(|e| e as u32)\\n            .collect::<Vec<_>>();\\n        let edges = edges.into_iter()\\n            .filter(|v| v.len() == 2)\\n            .map(|v| {\\n                v.into_iter()\\n                    .map(|e| e as usize)\\n                    .collect::<Vec<_>>()\\n            })\\n            .map(|v| (v[0], v[1]))\\n            .filter(|(v0, v1)| v0 != v1)\\n            .collect::<Vec<_>>();\\n        let graph = to_graph(&edges, &scores);\\n\\n        let mut ret = None;\\n        for (v0, v1) in edges {\\n            let mut _ret = None;\\n            for v0_next in graph[v0].clone() {\\n                if v0_next == v1 { continue; }\\n                let e0_next = scores[v0_next];\\n                for v1_next in graph[v1].clone() {\\n                    if v1_next == v0 { continue; }\\n                    if v0_next == v1_next { continue; }\\n                    let e1_next = scores[v1_next];\\n                    _ret = Some(_ret.unwrap_or(u32::MIN).max(e0_next + e1_next));\\n                }\\n            }\\n            let mut _ret = if let Some(inner) = _ret {\\n                inner\\n            } else { continue; };\\n            _ret += scores[v0];\\n            _ret += scores[v1];\\n\\n            ret = Some(ret.unwrap_or(u32::MIN).max(_ret));\\n        }\\n\\n        ret.map(|e| e as i32)\\n            .unwrap_or(-1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830142,
                "title": "efficient-js-solution-beat-100-both-time-and-memory",
                "content": "![image.png](https://assets.leetcode.com/users/images/fe667437-e134-4125-8af3-82a192d198a6_1690564551.4545662.png)\\n\\n# Intuition\\n- Let\\'s denote a valid sequence to be a quadruplet `[a,b,c,d]`. We can first chose the **middle** edge, i.e. `[b, c]`. When approaching this way, one key observasion is that `a` must be the **optimal** neighbor of `b`. An optimal neighbor of `b` is one that\\'s directly connected to `b`, different from `c`, `d` and has the highest score. The same strategy should be applied for `d`.\\n- Let\\'s focus on finding `a`. We don\\'t naively iterate through every single neighbor of of `b`. Instead, it\\'s not hard to tell that there will be **at most 2 invalid neighbors**. Therefore, it helps if we can sufficiently have 3 neighbors with the highest score of `b` beforehand, when 2 of them are invalid, the rest is the **optimal neighbor**.\\n- The implementation should be intuitive and straightforward, you can refer to the code below.\\n\\n# Complexity\\n- Time complexity: $$O(edges.length)$$\\n- Space complexity: $$O(scores.length)$$\\n\\n# Code\\n```jsx\\n/**\\n * @param {number[]} scores\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar maximumScore = function (scores, edges) {\\n  const n = scores.length;\\n  scores.push(0);\\n\\n  /** @type {[number, number, number][]} */\\n  const bestNeighbors = [];\\n  for (let i = 0; i < n; i++) bestNeighbors.push([n, n, n]);\\n\\n  function addNeighbor(target, newNeighbor) {\\n    const tarNeis = bestNeighbors[target];\\n\\n    if (scores[newNeighbor] > scores[tarNeis[0]]) {\\n      tarNeis[2] = tarNeis[1];\\n      tarNeis[1] = tarNeis[0];\\n      tarNeis[0] = newNeighbor;\\n    } else if (scores[newNeighbor] > scores[tarNeis[1]]) {\\n      tarNeis[2] = tarNeis[1];\\n      tarNeis[1] = newNeighbor;\\n    } else if (scores[newNeighbor] > scores[tarNeis[2]]) {\\n      tarNeis[2] = newNeighbor;\\n    }\\n  }\\n  for (let [u, v] of edges) {\\n    addNeighbor(u, v);\\n    addNeighbor(v, u);\\n  }\\n\\n  let result = -1;\\n  for (let [b, c] of edges) {\\n    for (let a of bestNeighbors[b]) {\\n      if (a === c || a === n) continue;\\n\\n      for (let d of bestNeighbors[c]) {\\n        if (d === b || d === a || d === n) continue;\\n        result = Math.max(result, scores[a] + scores[b] + scores[c] + scores[d]);\\n      }\\n    }\\n  }\\n  \\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy",
                    "Graph"
                ],
                "code": "```jsx\\n/**\\n * @param {number[]} scores\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar maximumScore = function (scores, edges) {\\n  const n = scores.length;\\n  scores.push(0);\\n\\n  /** @type {[number, number, number][]} */\\n  const bestNeighbors = [];\\n  for (let i = 0; i < n; i++) bestNeighbors.push([n, n, n]);\\n\\n  function addNeighbor(target, newNeighbor) {\\n    const tarNeis = bestNeighbors[target];\\n\\n    if (scores[newNeighbor] > scores[tarNeis[0]]) {\\n      tarNeis[2] = tarNeis[1];\\n      tarNeis[1] = tarNeis[0];\\n      tarNeis[0] = newNeighbor;\\n    } else if (scores[newNeighbor] > scores[tarNeis[1]]) {\\n      tarNeis[2] = tarNeis[1];\\n      tarNeis[1] = newNeighbor;\\n    } else if (scores[newNeighbor] > scores[tarNeis[2]]) {\\n      tarNeis[2] = newNeighbor;\\n    }\\n  }\\n  for (let [u, v] of edges) {\\n    addNeighbor(u, v);\\n    addNeighbor(v, u);\\n  }\\n\\n  let result = -1;\\n  for (let [b, c] of edges) {\\n    for (let a of bestNeighbors[b]) {\\n      if (a === c || a === n) continue;\\n\\n      for (let d of bestNeighbors[c]) {\\n        if (d === b || d === a || d === n) continue;\\n        result = Math.max(result, scores[a] + scores[b] + scores[c] + scores[d]);\\n      }\\n    }\\n  }\\n  \\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3827674,
                "title": "short-linear-time-solution-in-python-faster-than-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution is three connected edges that cover four nodes where the sum of the four nodes are maximized. \\nFor each edge `(u, v)` we can find two best neighboring edges `(p, u)` and `(v, q)` so that `u, v, p, q` are four distinct nodes and their sum is maximized. \\nTo speed up, we precompute the best 3 edges of each node in the first scan of all edges in $$O(|E|)$$. As a result, the second scan of all edges can find the solution in $$O(|E|)$$.\\n\\n# Complexity\\n- Time complexity: $$O(|E|)$$ where $|E|$ is the number of edges. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(|V|)$$ where $|V|$ is the number of nodes. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        closest = defaultdict(set)\\n        for u, v in edges:\\n            for p, q in [(u, v), (v, u)]:\\n                if len(closest[p]) < 3:\\n                    closest[p].add(q)\\n                else:\\n                    r = min(closest[p], key=lambda x: scores[x])\\n                    if scores[r] < scores[q]:\\n                        closest[p].remove(r)\\n                        closest[p].add(q)\\n        return max((scores[u] + scores[v] + scores[p] + scores[q] \\n               for u, v in edges for p in closest[u] if p != v for q in closest[v] if q != p and q != u),\\n               default=-1)\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        closest = defaultdict(set)\\n        for u, v in edges:\\n            for p, q in [(u, v), (v, u)]:\\n                if len(closest[p]) < 3:\\n                    closest[p].add(q)\\n                else:\\n                    r = min(closest[p], key=lambda x: scores[x])\\n                    if scores[r] < scores[q]:\\n                        closest[p].remove(r)\\n                        closest[p].add(q)\\n        return max((scores[u] + scores[v] + scores[p] + scores[q] \\n               for u, v in edges for p in closest[u] if p != v for q in closest[v] if q != p and q != u),\\n               default=-1)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699684,
                "title": "considering-top-3-neighbours-graphs-python3",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n\\n        n = len(scores)\\n        graphs = defaultdict(list)\\n\\n        for a, b in edges:\\n            graphs[a].append([scores[b], b])\\n            graphs[b].append([scores[a], a])\\n\\n        for i in range(n):\\n            graphs[i] = nlargest(3, graphs[i])\\n\\n        res = -1\\n\\n        for i, j in edges:\\n            for vii, ii in graphs[i]:\\n                for vjj, jj in graphs[j]:\\n                    if ii != jj and ii != j and jj != i:\\n                        res = max(res, vii + vjj + scores[i] + scores[j])\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Graph"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n\\n        n = len(scores)\\n        graphs = defaultdict(list)\\n\\n        for a, b in edges:\\n            graphs[a].append([scores[b], b])\\n            graphs[b].append([scores[a], a])\\n\\n        for i in range(n):\\n            graphs[i] = nlargest(3, graphs[i])\\n\\n        res = -1\\n\\n        for i, j in edges:\\n            for vii, ii in graphs[i]:\\n                for vjj, jj in graphs[j]:\\n                    if ii != jj and ii != j and jj != i:\\n                        res = max(res, vii + vjj + scores[i] + scores[j])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680909,
                "title": "c-python-solution-with-explanation",
                "content": "Because the sequence only has 4 node, e.g., x1 - x2 - x3 - x4,\\nwe can enumerate each edge as center 2 nodes, namely x2 and x3,\\nand find x2 and x3 \\'s the non-repeated neighbor whose score is the biggest.\\nWe can use a max heap to find 3 biggest nodes for each node, tc is O(n).\\n\\n### python\\n```python\\nfrom heapq import nlargest\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n\\t\\t# build a graph with score\\n        g = [[] for _ in range(len(scores))]\\n        for n1, n2 in edges:\\n            g[n1].append((scores[n2], n2))\\n            g[n2].append((scores[n1], n1))\\n\\t\\t# build max heap for each node\\n        for i, nodes in enumerate(g):\\n            if len(nodes) > 3:\\n\\t\\t\\t\\t# tc of nlargest is O(len(nodes) + 3 * log(len(nodes))) = O(len(nodes))\\n\\t\\t\\t\\t# total tc is O(sum(len(nodes))) = O(len(edges))\\n                g[i] = nlargest(3, nodes)\\n\\t\\t# x1 - x2 - x3 - x4\\n\\t\\t# enumerate each edge as center 2 nodes, namely x2 and x3\\n        ans = -1\\n        for n1, n2 in edges:\\n            for sc1, nei1 in g[n1]:\\n                for sc2, nei2 in g[n2]:\\n                    if nei1 != n2 and nei2 != n1 and nei1 != nei2:\\n                        ans = max(ans, scores[n1] + scores[n2] + sc1 + sc2)\\n        return ans\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        vector<vector<pair<int, int>>> g (scores.size());\\n        for (auto& e: edges) {\\n            int n1 = e[0], n2 = e[1];\\n            g[n1].emplace_back(scores[n2], n2);\\n            g[n2].emplace_back(scores[n1], n1);\\n        }\\n        for (auto& nodes: g) {\\n            if (nodes.size() > 3) {\\n                nth_element(nodes.begin(), nodes.begin() + 2, nodes.end(), \\n                            [] (pair<int, int>& x, pair<int, int>& y) {return x.first > y.first;}); // quick select\\n                nodes.resize(3);\\n            }\\n        }\\n        int ans = -1;\\n        for (auto& e: edges) {\\n            int n1 = e[0], n2 = e[1];\\n            for (auto& [sc1, nei1]: g[n1]) {\\n                for (auto& [sc2, nei2]: g[n2]) {\\n                    if (nei2 != n1 && nei1 != n2 && nei1 != nei2)\\n                        ans = max(ans, sc1 + sc2 + scores[n1] + scores[n2]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Graph"
                ],
                "code": "```python\\nfrom heapq import nlargest\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n\\t\\t# build a graph with score\\n        g = [[] for _ in range(len(scores))]\\n        for n1, n2 in edges:\\n            g[n1].append((scores[n2], n2))\\n            g[n2].append((scores[n1], n1))\\n\\t\\t# build max heap for each node\\n        for i, nodes in enumerate(g):\\n            if len(nodes) > 3:\\n\\t\\t\\t\\t# tc of nlargest is O(len(nodes) + 3 * log(len(nodes))) = O(len(nodes))\\n\\t\\t\\t\\t# total tc is O(sum(len(nodes))) = O(len(edges))\\n                g[i] = nlargest(3, nodes)\\n\\t\\t# x1 - x2 - x3 - x4\\n\\t\\t# enumerate each edge as center 2 nodes, namely x2 and x3\\n        ans = -1\\n        for n1, n2 in edges:\\n            for sc1, nei1 in g[n1]:\\n                for sc2, nei2 in g[n2]:\\n                    if nei1 != n2 and nei2 != n1 and nei1 != nei2:\\n                        ans = max(ans, scores[n1] + scores[n2] + sc1 + sc2)\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        vector<vector<pair<int, int>>> g (scores.size());\\n        for (auto& e: edges) {\\n            int n1 = e[0], n2 = e[1];\\n            g[n1].emplace_back(scores[n2], n2);\\n            g[n2].emplace_back(scores[n1], n1);\\n        }\\n        for (auto& nodes: g) {\\n            if (nodes.size() > 3) {\\n                nth_element(nodes.begin(), nodes.begin() + 2, nodes.end(), \\n                            [] (pair<int, int>& x, pair<int, int>& y) {return x.first > y.first;}); // quick select\\n                nodes.resize(3);\\n            }\\n        }\\n        int ans = -1;\\n        for (auto& e: edges) {\\n            int n1 = e[0], n2 = e[1];\\n            for (auto& [sc1, nei1]: g[n1]) {\\n                for (auto& [sc2, nei2]: g[n2]) {\\n                    if (nei2 != n1 && nei1 != n2 && nei1 != nei2)\\n                        ans = max(ans, sc1 + sc2 + scores[n1] + scores[n2]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434902,
                "title": "elog-something-solution-for-u-shit",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        ans,g=-1,defaultdict(SortedList)\\n        for x,y in edges:\\n            print(x,y)\\n            g[x].add((scores[y],y))\\n            g[y].add((scores[x],x))\\n        ans=-1\\n        for x,y in edges:\\n            res=scores[x]+scores[y]\\n            g[x].remove((scores[y],y))\\n            g[y].remove((scores[x],x))\\n            i=len(g[x])-1\\n            j=len(g[y])-1\\n            if i>=0 and j>=0 and g[x][i]==g[y][j]:\\n                if j-1>=0 and i-1>=0:\\n                    if g[x][i-1][0]>=g[y][j-1][0]:\\n                        i-=1\\n                    else:\\n                        j-=1\\n                elif j-1>=0:\\n                    j-=1\\n                elif i-1>=0:\\n                    i-=1\\n                else:\\n                    j-=1\\n            if i>=0 and j>=0:\\n                ans=max(ans,res+g[x][i][0]+g[y][j][0])\\n            g[x].add((scores[y],y))\\n            g[y].add((scores[x],x))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        ans,g=-1,defaultdict(SortedList)\\n        for x,y in edges:\\n            print(x,y)\\n            g[x].add((scores[y],y))\\n            g[y].add((scores[x],x))\\n        ans=-1\\n        for x,y in edges:\\n            res=scores[x]+scores[y]\\n            g[x].remove((scores[y],y))\\n            g[y].remove((scores[x],x))\\n            i=len(g[x])-1\\n            j=len(g[y])-1\\n            if i>=0 and j>=0 and g[x][i]==g[y][j]:\\n                if j-1>=0 and i-1>=0:\\n                    if g[x][i-1][0]>=g[y][j-1][0]:\\n                        i-=1\\n                    else:\\n                        j-=1\\n                elif j-1>=0:\\n                    j-=1\\n                elif i-1>=0:\\n                    i-=1\\n                else:\\n                    j-=1\\n            if i>=0 and j>=0:\\n                ans=max(ans,res+g[x][i][0]+g[y][j][0])\\n            g[x].add((scores[y],y))\\n            g[y].add((scores[x],x))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428707,
                "title": "my-solution",
                "content": "```\\n/**\\n * the solution is as following,\\n * 1. iterate every edge and get at most three adjacent nodes for every node,\\n *    the scores of which are maximum ones\\n * 1.1 two adjacent nodes are not enough, think about there exist three nodes,\\n *     every two of which are connected\\n * 1.2 more than three adjacent nodes are unnecessary\\n * 2. iterate every edge,\\n *    regard its two nodes as the middle two nodes of a valid node sequence,\\n *    try to find a valid node sequence from their adjacent nodes retrieved by the step 1\\n *\\n * Time Complexity: O(n_edges)\\n * Space Complexity: O(n)\\n * where `n_edges` is the length of the vector `edges`\\n *       `n` is the length of the vector `scores`\\n */\\nclass Solution {\\n public:\\n  int maximumScore(const vector<int> &scores, const vector<vector<int>> &edges) {\\n    const int n = static_cast<int>(scores.size());\\n    vector<int> candidates[n];\\n    for (const vector<int> &edge : edges) {\\n      insert_candidates(scores, candidates[edge.front()], edge.back());\\n      insert_candidates(scores, candidates[edge.back()], edge.front());\\n    }\\n    \\n    int ret = numeric_limits<int>::min();\\n    for (const vector<int> &edge : edges) {\\n      const int node2 = edge.front();\\n      const int node3 = edge.back();\\n      for (const int node1 : candidates[node2]) {\\n        for (const int node4 : candidates[node3]) {\\n          if (node1 != node3 && node2 != node4 && node1 != node4) {\\n            ret = max(ret, scores[node1] + scores[node2] + scores[node3] + scores[node4]);\\n          }\\n        }\\n      }\\n    }\\n    return ret == numeric_limits<int>::min() ? -1 : ret;\\n  }\\n  \\n private:\\n  void insert_candidates(const vector<int> &scores, vector<int> &nodes, const int node) {\\n    constexpr int max_candidates = 3;\\n    auto compare = [&scores](const int lhs, const int rhs) -> bool {\\n      return scores[lhs] < scores[rhs];\\n    };\\n    nodes.emplace_back(node);\\n    if (nodes.size() > max_candidates) {\\n      nodes.erase(min_element(nodes.begin(), nodes.end(), compare));\\n    }\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * the solution is as following,\\n * 1. iterate every edge and get at most three adjacent nodes for every node,\\n *    the scores of which are maximum ones\\n * 1.1 two adjacent nodes are not enough, think about there exist three nodes,\\n *     every two of which are connected\\n * 1.2 more than three adjacent nodes are unnecessary\\n * 2. iterate every edge,\\n *    regard its two nodes as the middle two nodes of a valid node sequence,\\n *    try to find a valid node sequence from their adjacent nodes retrieved by the step 1\\n *\\n * Time Complexity: O(n_edges)\\n * Space Complexity: O(n)\\n * where `n_edges` is the length of the vector `edges`\\n *       `n` is the length of the vector `scores`\\n */\\nclass Solution {\\n public:\\n  int maximumScore(const vector<int> &scores, const vector<vector<int>> &edges) {\\n    const int n = static_cast<int>(scores.size());\\n    vector<int> candidates[n];\\n    for (const vector<int> &edge : edges) {\\n      insert_candidates(scores, candidates[edge.front()], edge.back());\\n      insert_candidates(scores, candidates[edge.back()], edge.front());\\n    }\\n    \\n    int ret = numeric_limits<int>::min();\\n    for (const vector<int> &edge : edges) {\\n      const int node2 = edge.front();\\n      const int node3 = edge.back();\\n      for (const int node1 : candidates[node2]) {\\n        for (const int node4 : candidates[node3]) {\\n          if (node1 != node3 && node2 != node4 && node1 != node4) {\\n            ret = max(ret, scores[node1] + scores[node2] + scores[node3] + scores[node4]);\\n          }\\n        }\\n      }\\n    }\\n    return ret == numeric_limits<int>::min() ? -1 : ret;\\n  }\\n  \\n private:\\n  void insert_candidates(const vector<int> &scores, vector<int> &nodes, const int node) {\\n    constexpr int max_candidates = 3;\\n    auto compare = [&scores](const int lhs, const int rhs) -> bool {\\n      return scores[lhs] < scores[rhs];\\n    };\\n    nodes.emplace_back(node);\\n    if (nodes.size() > max_candidates) {\\n      nodes.erase(min_element(nodes.begin(), nodes.end(), compare));\\n    }\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393195,
                "title": "c",
                "content": "```\\nusing PII = pair<int, int> ; //{score, idx}\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n = scores.size() ;\\n        auto graph = vector<vector<PII>>(n) ;\\n        for(auto& e : edges){\\n            int u = e[0] ;\\n            int v = e[1] ;\\n            graph[u].push_back({scores[v], v}) ;\\n            graph[v].push_back({scores[u], u}) ;\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            sort(graph[i].rbegin(), graph[i].rend()) ;\\n            if(graph[i].size() > 3)\\n                graph[i].resize(3) ;\\n        }\\n            \\n        int ret = -1 ;\\n        for(auto& e : edges){\\n            int u = e[0] ;\\n            int v = e[1] ;\\n            for(auto [score1, i] : graph[u]){\\n                for(auto [socre2, j] : graph[v]){\\n                    if(i != j && i != v && j != u )\\n                        ret = max(ret, scores[i] + scores[j] + scores[u] + scores[v]) ;\\n                }\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nusing PII = pair<int, int> ; //{score, idx}\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n = scores.size() ;\\n        auto graph = vector<vector<PII>>(n) ;\\n        for(auto& e : edges){\\n            int u = e[0] ;\\n            int v = e[1] ;\\n            graph[u].push_back({scores[v], v}) ;\\n            graph[v].push_back({scores[u], u}) ;\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            sort(graph[i].rbegin(), graph[i].rend()) ;\\n            if(graph[i].size() > 3)\\n                graph[i].resize(3) ;\\n        }\\n            \\n        int ret = -1 ;\\n        for(auto& e : edges){\\n            int u = e[0] ;\\n            int v = e[1] ;\\n            for(auto [score1, i] : graph[u]){\\n                for(auto [socre2, j] : graph[v]){\\n                    if(i != j && i != v && j != u )\\n                        ret = max(ret, scores[i] + scores[j] + scores[u] + scores[v]) ;\\n                }\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263476,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn maximum_score(scores: Vec<i32>, edges: Vec<Vec<i32>>) -> i32 {\\n        use std::cmp::Reverse;\\n        let n = scores.len();\\n        let mut graph = vec![vec![]; n];\\n        for e in edges.iter() {\\n            graph[e[0] as usize].push((scores[e[1] as usize], e[1] as usize));\\n            graph[e[1] as usize].push((scores[e[0] as usize], e[0] as usize));\\n        }\\n        for i in 0..n {\\n            graph[i].sort_by_key(|x| Reverse(x.0));\\n        }\\n        let mut res = -1;\\n        for e in edges.iter() {\\n            let b = e[0] as usize;\\n            let c = e[1] as usize;\\n            for i in 0..graph[b].len().min(3) {\\n                let a = graph[b][i].1;\\n                if a == c {\\n                    continue;\\n                }\\n                for j in 0..graph[c].len().min(3) {\\n                    let d = graph[c][j].1;\\n                    if d == b || d == a {\\n                        continue;\\n                    }\\n                    res = res.max(scores[a] + scores[b] + scores[c] + scores[d]);\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_score(scores: Vec<i32>, edges: Vec<Vec<i32>>) -> i32 {\\n        use std::cmp::Reverse;\\n        let n = scores.len();\\n        let mut graph = vec![vec![]; n];\\n        for e in edges.iter() {\\n            graph[e[0] as usize].push((scores[e[1] as usize], e[1] as usize));\\n            graph[e[1] as usize].push((scores[e[0] as usize], e[0] as usize));\\n        }\\n        for i in 0..n {\\n            graph[i].sort_by_key(|x| Reverse(x.0));\\n        }\\n        let mut res = -1;\\n        for e in edges.iter() {\\n            let b = e[0] as usize;\\n            let c = e[1] as usize;\\n            for i in 0..graph[b].len().min(3) {\\n                let a = graph[b][i].1;\\n                if a == c {\\n                    continue;\\n                }\\n                for j in 0..graph[c].len().min(3) {\\n                    let d = graph[c][j].1;\\n                    if d == b || d == a {\\n                        continue;\\n                    }\\n                    res = res.max(scores[a] + scores[b] + scores[c] + scores[d]);\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3216448,
                "title": "python-solution-with-comments-dfs-and-top-3-neighbors-with-min-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst solution is intuitive approach using DFS+backtracking, but this approach gets TLE. \\n\\nSecond solution uses top 3 neighbors, I just implemented this appoach https://leetcode.com/problems/maximum-score-of-a-node-sequence/solutions/1953669/python-explanation-with-pictures-top-3-neighbors/ using heap. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nDFS+Backtracking\\nV: number of vertices\\n\\n- Time complexity: O(V^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\nTop 3 neighbor\\n- Time complexity: O(V) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V)\\n\\n# Code\\n```\\n# DFS Approach with backtracking\\n\\'\\'\\'\\nDesc:\\n* undirected graph\\n* n nodes [0, n-1]\\n* scores: integer array, length is n, index [0, ...n-1]\\n    scores[i] denotes the score of the node i\\n* edges: [a,b] = node a connected to node b (bi-directional connection)\\n* node sequence is VALID if:\\n    there is an edge connecting every pair of adjacent nodes in the sequence\\n    no node repetition in the sequence\\n\\n* score of the sequence = sum of node scores inside the sequence\\n* RETURN = maximum score of a VALID node sequence with a length of 4, if not return -1\\n\\n\\nApproach 1: DFS + Backtracking\\n1 - build a graph from edges array\\n2 - find each unique path with length of 4 which is VALID path\\n3 - get the maximum valued path\\n\\n\\nTime Complexity: O(V^2)\\nSpace Complexity: O(V)\\n\\nDry on for the this input: \\nscores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]\\n\\n             getMax(0, 0, ()) 24\\n                /            \\n           getMax(1, 1, (0)) 19  \\n           /\\n        getMax(2, 2, (0, 1)) 17 \\n        /                     \\\\\\n    getMax(3, 3, (0, 1,2)) get(4,3,(0,1,2))\\n    /                         \\\\\\n   8                           4\\n\\'\\'\\'\\n\\n\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        # 1 - build a graph\\n        graph = defaultdict(set)\\n\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n\\n        def getMaxPathScore(vertex, level, visited):\\n            if level == 3:\\n                return scores[vertex]\\n\\n            visited.add(vertex)\\n            score = -1\\n\\n            for neighbor in graph[vertex]:\\n                if neighbor in visited:\\n                    continue\\n\\n                visited.add(neighbor)\\n                score = max(score, getMaxPathScore(neighbor, level+1, visited))\\n                visited.remove(neighbor)\\n\\n            return -1 if score == -1 else score + scores[vertex]    \\n        \\n        # 2 - iterate each vertex for path with 4 nodes\\n        ans, n = -1, len(scores)\\n\\n        for vertex in range(n):\\n            ans = max(ans, getMaxPathScore(vertex, 0, set()))\\n\\n        return ans\\n```\\n\\n\\n```\\nfrom collections import defaultdict\\nfrom heapq import heappop, heappush\\n\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n\\n        # uses min heap to keep the maximum scored neighbors\\n        def keepTop3(a, b):\\n            if len(graph[a]) >= 3:\\n                if graph[a][0][0] < scores[b]:\\n                    heappop(graph[a])\\n                    heappush(graph[a], (scores[b], b))\\n            else:\\n                heappush(graph[a], (scores[b], b))\\n        \\n        # build a graph by keeping maximum scored 3 neighbors using min heap\\n        for a, b in edges:\\n            keepTop3(a, b)\\n            keepTop3(b, a)\\n\\n        ans = -1\\n\\n        # iterate each edge one by one, and find the node with 3 edges   c-a-b-d\\n        for a, b in edges:\\n            # because both a and b vertices are the middle two vertices. \\n            # their neighbor counts has to be bigger than 1, since a is connected to c and d (need at least 2 edges), b is connected to a and d (needs at least 2 edges)\\n            if len(graph[a]) <= 1 or len(graph[b]) <= 1:  \\n                continue\\n\\n            for score_c, c in graph[a]:\\n                for score_d, d in graph[b]:\\n                    if c not in [a,b] and d not in [a,b] and c != d:\\n                        ans = max(ans, scores[a] + scores[b] + score_c + score_d)\\n\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n# DFS Approach with backtracking\\n\\'\\'\\'\\nDesc:\\n* undirected graph\\n* n nodes [0, n-1]\\n* scores: integer array, length is n, index [0, ...n-1]\\n    scores[i] denotes the score of the node i\\n* edges: [a,b] = node a connected to node b (bi-directional connection)\\n* node sequence is VALID if:\\n    there is an edge connecting every pair of adjacent nodes in the sequence\\n    no node repetition in the sequence\\n\\n* score of the sequence = sum of node scores inside the sequence\\n* RETURN = maximum score of a VALID node sequence with a length of 4, if not return -1\\n\\n\\nApproach 1: DFS + Backtracking\\n1 - build a graph from edges array\\n2 - find each unique path with length of 4 which is VALID path\\n3 - get the maximum valued path\\n\\n\\nTime Complexity: O(V^2)\\nSpace Complexity: O(V)\\n\\nDry on for the this input: \\nscores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]\\n\\n             getMax(0, 0, ()) 24\\n                /            \\n           getMax(1, 1, (0)) 19  \\n           /\\n        getMax(2, 2, (0, 1)) 17 \\n        /                     \\\\\\n    getMax(3, 3, (0, 1,2)) get(4,3,(0,1,2))\\n    /                         \\\\\\n   8                           4\\n\\'\\'\\'\\n\\n\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        # 1 - build a graph\\n        graph = defaultdict(set)\\n\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n\\n        def getMaxPathScore(vertex, level, visited):\\n            if level == 3:\\n                return scores[vertex]\\n\\n            visited.add(vertex)\\n            score = -1\\n\\n            for neighbor in graph[vertex]:\\n                if neighbor in visited:\\n                    continue\\n\\n                visited.add(neighbor)\\n                score = max(score, getMaxPathScore(neighbor, level+1, visited))\\n                visited.remove(neighbor)\\n\\n            return -1 if score == -1 else score + scores[vertex]    \\n        \\n        # 2 - iterate each vertex for path with 4 nodes\\n        ans, n = -1, len(scores)\\n\\n        for vertex in range(n):\\n            ans = max(ans, getMaxPathScore(vertex, 0, set()))\\n\\n        return ans\\n```\n```\\nfrom collections import defaultdict\\nfrom heapq import heappop, heappush\\n\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n\\n        # uses min heap to keep the maximum scored neighbors\\n        def keepTop3(a, b):\\n            if len(graph[a]) >= 3:\\n                if graph[a][0][0] < scores[b]:\\n                    heappop(graph[a])\\n                    heappush(graph[a], (scores[b], b))\\n            else:\\n                heappush(graph[a], (scores[b], b))\\n        \\n        # build a graph by keeping maximum scored 3 neighbors using min heap\\n        for a, b in edges:\\n            keepTop3(a, b)\\n            keepTop3(b, a)\\n\\n        ans = -1\\n\\n        # iterate each edge one by one, and find the node with 3 edges   c-a-b-d\\n        for a, b in edges:\\n            # because both a and b vertices are the middle two vertices. \\n            # their neighbor counts has to be bigger than 1, since a is connected to c and d (need at least 2 edges), b is connected to a and d (needs at least 2 edges)\\n            if len(graph[a]) <= 1 or len(graph[b]) <= 1:  \\n                continue\\n\\n            for score_c, c in graph[a]:\\n                for score_d, d in graph[b]:\\n                    if c not in [a,b] and d not in [a,b] and c != d:\\n                        ans = max(ans, scores[a] + scores[b] + score_c + score_d)\\n\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908518,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\ntypedef pair<ll, ll> pi;\\npublic:\\n    int maximumScore(vector<int>&vals, vector<vector<int>>&e) {\\n        ll n=vals.size(), ans=-1;\\n        vector<set<pi>>g(n);\\n        for(const auto&edge:e){\\n            ll u=edge[0], v=edge[1];\\n            g[u].insert({vals[v], v}), g[v].insert({vals[u], u});\\n            if(g[u].size()>3){\\n                g[u].erase(begin(g[u]));\\n            }\\n            if(g[v].size()>3){\\n                g[v].erase(begin(g[v]));\\n            }\\n        }\\n        for(const auto&edge:e){\\n            ll u=edge[0], v=edge[1];\\n            for(const auto&[xVal, x]:g[u]){\\n                for(const auto&[yVal, y]:g[v]){\\n                    if(x!=v && x!=y && u!=y){\\n                        ans=max(ans, vals[u]+vals[v]+xVal+yVal);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\ntypedef pair<ll, ll> pi;\\npublic:\\n    int maximumScore(vector<int>&vals, vector<vector<int>>&e) {\\n        ll n=vals.size(), ans=-1;\\n        vector<set<pi>>g(n);\\n        for(const auto&edge:e){\\n            ll u=edge[0], v=edge[1];\\n            g[u].insert({vals[v], v}), g[v].insert({vals[u], u});\\n            if(g[u].size()>3){\\n                g[u].erase(begin(g[u]));\\n            }\\n            if(g[v].size()>3){\\n                g[v].erase(begin(g[v]));\\n            }\\n        }\\n        for(const auto&edge:e){\\n            ll u=edge[0], v=edge[1];\\n            for(const auto&[xVal, x]:g[u]){\\n                for(const auto&[yVal, y]:g[v]){\\n                    if(x!=v && x!=y && u!=y){\\n                        ans=max(ans, vals[u]+vals[v]+xVal+yVal);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796806,
                "title": "python-try-for-every-edge-and-check-the-3-biggest-neighbor-nodes-concise-and-clear",
                "content": "We make a little optimization on the Brute-Force by considering only the 3 biggest neighbors for each node. The reason for choosing 3 biggest neighbors is : -\\n\\nLet\\'s say we are currently considering edge` u---v` and `i and j are the neighbor nodes of u and v ` respectively\\nNow there can be 2 possibilities which we dont want to cosider wrt to a particular node:\\n* i is same as v\\n* i and j are equal. We are asked to look for a sequence of 4 nodes, this would make the sequence of 3 different nodes\\n\\nHence we would be able to get an answer in atmost 3 neighboring nodes.\\n\\n\\n```\\nclass Solution:\\n    def maximumScore(self, values: List[int], edges: List[List[int]]) -> int:\\n        G = defaultdict(list)\\n        for u,v in edges:\\n            G[u].append([values[v],v])\\n            G[v].append([values[u],u])\\n            \\n        for i in range(len(values)):\\n            G[i].sort(reverse = True)\\n            G[i] = G[i][:3]\\n        \\n        ans = -1\\n        for u,v in edges:\\n            for neiU, i in G[u]:\\n                for neiV, j in G[v]:\\n                    if i != v and j != u and i != j:\\n                        ans = max(ans, values[u] + values[v] + neiU + neiV)\\n                        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maximumScore(self, values: List[int], edges: List[List[int]]) -> int:\\n        G = defaultdict(list)\\n        for u,v in edges:\\n            G[u].append([values[v],v])\\n            G[v].append([values[u],u])\\n            \\n        for i in range(len(values)):\\n            G[i].sort(reverse = True)\\n            G[i] = G[i][:3]\\n        \\n        ans = -1\\n        for u,v in edges:\\n            for neiU, i in G[u]:\\n                for neiV, j in G[v]:\\n                    if i != v and j != u and i != j:\\n                        ans = max(ans, values[u] + values[v] + neiU + neiV)\\n                        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774442,
                "title": "video-walkthrough-easy",
                "content": "[Video Walkthrough](https://youtu.be/ktY8OQ-Z6ZE)\\n```\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        \\n        #O(len(scores))SPACE\\n        #O(len(edges)) RUNTIME\\n        G = [[] for _ in range(len(scores))]\\n        #O(E)\\n        for u,v in edges:\\n            if len(G[u]) < 3: heapq.heappush(G[u],(scores[v], v))\\n            else: heapq.heappushpop(G[u],(scores[v], v))\\n            if len(G[v]) < 3: heapq.heappush(G[v],(scores[u], u))\\n            else: heapq.heappushpop(G[v],(scores[u], u))\\n        \\n        \\n        maxScore = -1\\n        \\n        #O(E)\\n        for u,v in edges:\\n            #3\\n            for score_w, w in G[u]:\\n                #3\\n                for score_x, x in G[v]:\\n                    if w != v and x != u and x != w: maxScore = max(maxScore, scores[u] + scores[v] + score_w + score_x)\\n        return maxScore\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        \\n        #O(len(scores))SPACE\\n        #O(len(edges)) RUNTIME\\n        G = [[] for _ in range(len(scores))]\\n        #O(E)\\n        for u,v in edges:\\n            if len(G[u]) < 3: heapq.heappush(G[u],(scores[v], v))\\n            else: heapq.heappushpop(G[u],(scores[v], v))\\n            if len(G[v]) < 3: heapq.heappush(G[v],(scores[u], u))\\n            else: heapq.heappushpop(G[v],(scores[u], u))\\n        \\n        \\n        maxScore = -1\\n        \\n        #O(E)\\n        for u,v in edges:\\n            #3\\n            for score_w, w in G[u]:\\n                #3\\n                for score_x, x in G[v]:\\n                    if w != v and x != u and x != w: maxScore = max(maxScore, scores[u] + scores[v] + score_w + score_x)\\n        return maxScore\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724812,
                "title": "python-keep-track-with-3-biggest-neighbors",
                "content": "```\\nfrom heapq import nlargest\\nfrom itertools import product\\n\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        n = len(scores)\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        for u in range(n): graph[u] = nlargest(3, graph[u], key=lambda x:scores[x])\\n        ans = -1\\n        for u, v in edges:\\n            if len(graph[u]) <= 1 or len(graph[v]) <= 1: continue\\n            for x, y in product(graph[u], graph[v]):\\n                if x == y or x == v or y == u: continue\\n                ans = max(ans, scores[u] + scores[v] + scores[x] + scores[y])\\n        return ans  \\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import nlargest\\nfrom itertools import product\\n\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        n = len(scores)\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        for u in range(n): graph[u] = nlargest(3, graph[u], key=lambda x:scores[x])\\n        ans = -1\\n        for u, v in edges:\\n            if len(graph[u]) <= 1 or len(graph[v]) <= 1: continue\\n            for x, y in product(graph[u], graph[v]):\\n                if x == y or x == v or y == u: continue\\n                ans = max(ans, scores[u] + scores[v] + scores[x] + scores[y])\\n        return ans  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717327,
                "title": "c-priority-queue-and-2d-list",
                "content": "# Intuition\\nInspired by [https://leetcode.com/problems/maximum-score-of-a-node-sequence/solutions/2310762/java-pq-easy-to-understand-with-explanation/]()\\n\\n# Approach\\n1-Use an array of priorty queues to store the 3 most valuable neighbors of each node by visiting both nodes of each edge of the array of edges. The priority queue is useful to get rid of the weaker neighbors as you end up with more than 3 neighbors. The higher the score the higher the priority.\\n\\n2-Copy the array of priority queues into a 2D list. Since the priority queue cannot be used in a \"foreach\", we\\'ll need to copy this data into a data structure that is traversable.\\n\\n3-Visit every edge in edges. In each visit, get the highest sum of scores of the edge nodes and their neighbors. The answer will be your most up to date highest some of scores.\\n\\n# Complexity\\n- Time complexity: O(E+V), where V is number of scores, and E is the number of edges.\\n\\n- Space complexity: O(V)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumScore(int[] scores, int[][] edges) {\\n        if (scores == null || scores.Length == 0 || edges == null || edges.Length == 0) \\n        {\\n            return -1;\\n        }\\n        int n = scores.Length;\\n        \\n        var neighbors = new PriorityQueue<int,int>[n];\\n        var neighbors2 = new List<List<int>>();\\n\\n        // Create an array of Priority Queues to store node (at index) and its all the neighboring nodes in a Priority Queue.\\n        // O(V)\\n        for (int i = 0; i < n; i++) \\n        {\\n            neighbors[i] = new PriorityQueue<int,int>(Comparer<int>.Create((a, b) => a - b));\\n        }\\n        \\n        // O(E)\\n        foreach (var edge in edges) \\n        {\\n            int u = edge[0];\\n            int v = edge[1];\\n            neighbors[u].Enqueue(v, scores[v]);\\n            neighbors[v].Enqueue(u, scores[u]);\\n            if (neighbors[u].Count > 3) \\n                neighbors[u].Dequeue();\\n            if (neighbors[v].Count > 3) \\n                neighbors[v].Dequeue();\\n        }\\n        \\n        // in case there are no edges at all between all the nodes\\n        int res = -1;\\n        for (int i = 0; i < neighbors.Length; i++)\\n        {\\n            var q1 = neighbors[i];\\n            neighbors2.Add(new List<int>());\\n            while (q1.Count > 0) \\n            {\\n                var nei1 = q1.Dequeue();\\n                neighbors2[i].Add(nei1);\\n            }\\n        }\\n        \\n        // O(E)\\n        foreach (int[] edge in edges) \\n        {\\n            int u = edge[0];\\n            int v = edge[1];\\n           foreach(var nei1 in neighbors2[u])\\n            {\\n                foreach(var nei2 in neighbors2[v])\\n                {\\n                    if (nei1 != v && nei2 != u && nei1 != nei2) {\\n                        res = Math.Max(res, scores[u] + scores[v] + scores[nei1] + scores[nei2]);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumScore(int[] scores, int[][] edges) {\\n        if (scores == null || scores.Length == 0 || edges == null || edges.Length == 0) \\n        {\\n            return -1;\\n        }\\n        int n = scores.Length;\\n        \\n        var neighbors = new PriorityQueue<int,int>[n];\\n        var neighbors2 = new List<List<int>>();\\n\\n        // Create an array of Priority Queues to store node (at index) and its all the neighboring nodes in a Priority Queue.\\n        // O(V)\\n        for (int i = 0; i < n; i++) \\n        {\\n            neighbors[i] = new PriorityQueue<int,int>(Comparer<int>.Create((a, b) => a - b));\\n        }\\n        \\n        // O(E)\\n        foreach (var edge in edges) \\n        {\\n            int u = edge[0];\\n            int v = edge[1];\\n            neighbors[u].Enqueue(v, scores[v]);\\n            neighbors[v].Enqueue(u, scores[u]);\\n            if (neighbors[u].Count > 3) \\n                neighbors[u].Dequeue();\\n            if (neighbors[v].Count > 3) \\n                neighbors[v].Dequeue();\\n        }\\n        \\n        // in case there are no edges at all between all the nodes\\n        int res = -1;\\n        for (int i = 0; i < neighbors.Length; i++)\\n        {\\n            var q1 = neighbors[i];\\n            neighbors2.Add(new List<int>());\\n            while (q1.Count > 0) \\n            {\\n                var nei1 = q1.Dequeue();\\n                neighbors2[i].Add(nei1);\\n            }\\n        }\\n        \\n        // O(E)\\n        foreach (int[] edge in edges) \\n        {\\n            int u = edge[0];\\n            int v = edge[1];\\n           foreach(var nei1 in neighbors2[u])\\n            {\\n                foreach(var nei2 in neighbors2[v])\\n                {\\n                    if (nei1 != v && nei2 != u && nei1 != nei2) {\\n                        res = Math.Max(res, scores[u] + scores[v] + scores[nei1] + scores[nei2]);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685475,
                "title": "python-simple-maths",
                "content": "\\n    def maximumScore(self, scores, edges):\\n        dict1 = defaultdict(list)\\n        \\n        for i,j in edges:\\n            dict1[i].append([scores[j],j])\\n            dict1[j].append([scores[i],i])\\n            \\n        for i in dict1:\\n            dict1[i] = sorted(dict1[i], reverse = True)\\n            \\n        max_val = -1\\n        \\n        for i,j in edges:\\n            for s1,p1 in dict1[i][:3]:\\n                for s2,p2 in dict1[j][:3]:\\n                    if len(set([i,j,p1,p2])) != 4:\\n                        continue\\n                    max_val = max(max_val, s1 + s2 + scores[i] + scores[j])\\n                    \\n        return max_val\\n",
                "solutionTags": [],
                "code": "\\n    def maximumScore(self, scores, edges):\\n        dict1 = defaultdict(list)\\n        \\n        for i,j in edges:\\n            dict1[i].append([scores[j],j])\\n            dict1[j].append([scores[i],i])\\n            \\n        for i in dict1:\\n            dict1[i] = sorted(dict1[i], reverse = True)\\n            \\n        max_val = -1\\n        \\n        for i,j in edges:\\n            for s1,p1 in dict1[i][:3]:\\n                for s2,p2 in dict1[j][:3]:\\n                    if len(set([i,j,p1,p2])) != 4:\\n                        continue\\n                    max_val = max(max_val, s1 + s2 + scores[i] + scores[j])\\n                    \\n        return max_val\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2674293,
                "title": "c-3-biggest-neighbours",
                "content": "```\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        const int n = scores.size();\\n        vector<vector<int>> g(n);\\n        for(auto& e:edges){\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        for(auto& v:g){\\n            const int n = min<int>(3, v.size());\\n            partial_sort(v.begin(), v.begin()+n, v.end(), [&](int i, int j){return scores[i] > scores[j];});\\n            v = vector(v.begin(), v.begin()+n);\\n        }\\n        \\n        int res = -1;\\n        for(auto& e:edges){\\n            int i = e[0], j = e[1];\\n            int score = 0;\\n            for(auto k1 : g[i]) for (auto k2 : g[j]){\\n                if(k1 == j || k2 == i || k1 == k2) continue;\\n                score = max(score, scores[k1] + scores[k2]);\\n            }\\n            if(score > 0 ) res = max(res, score + scores[i] + scores[j]);\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        const int n = scores.size();\\n        vector<vector<int>> g(n);\\n        for(auto& e:edges){\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        for(auto& v:g){\\n            const int n = min<int>(3, v.size());\\n            partial_sort(v.begin(), v.begin()+n, v.end(), [&](int i, int j){return scores[i] > scores[j];});\\n            v = vector(v.begin(), v.begin()+n);\\n        }\\n        \\n        int res = -1;\\n        for(auto& e:edges){\\n            int i = e[0], j = e[1];\\n            int score = 0;\\n            for(auto k1 : g[i]) for (auto k2 : g[j]){\\n                if(k1 == j || k2 == i || k1 == k2) continue;\\n                score = max(score, scores[k1] + scores[k2]);\\n            }\\n            if(score > 0 ) res = max(res, score + scores[i] + scores[j]);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2636059,
                "title": "java-sorting-preprocessing",
                "content": "```\\n/**\\n    *   brute force would be to create a graph and run a dfs starting from each node adding their score and calculating the maximum but it would be exponential\\n    \\n    *   another intuition can be selecting any edge to be middle edge in the sequence, now we have 2 remaining nodes we can select from the neighbours of this middle edges\\n    *   we only need to see top 3 nodes (coz we don\\'t want to see duplicate nodes that\\'s why 3) from both of these two middle nodes, to select 2 nodes, one from each middle node that gives maximum score\\n    *\\n    *   algorithm\\n    *   - create graph adjacency list.\\n    *   - sort neightbours of each nodes by their scores in descending order.\\n    *   - now iterate over edges.\\n    *   - select each edge to be middle nodes.\\n    *   - from one of the middle nodes, select one node it should not be one of already selected.\\n    *   - nowin inner loop select one node from the other edge and calculate max score.\\n    */\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        int n = scores.length;\\n        List<List<Integer>> graph = createGraph(n, edges, scores);\\n\\n        int maxScore = -1;\\n        for (int[] edge : edges) {\\n            int a = edge[0];\\n            int b = edge[1];\\n\\n            for (int i = 0; i < Math.min(3, graph.get(a).size()); i++) {\\n                int c = graph.get(a).get(i);\\n\\n                if (c == b) continue;\\n\\n                for (int j = 0; j < Math.min(3, graph.get(b).size()); j++) {\\n                    int d = graph.get(b).get(j);\\n                    if (d == a || d == c) continue;\\n\\n                    maxScore = Math.max(maxScore, scores[a] + scores[b] + scores[c] + scores[d]);\\n                }\\n            }\\n        }\\n\\n        return maxScore;\\n    }\\n    \\n    \\n    private List<List<Integer>> createGraph(int n, int[][] edges, int[] scores) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());\\n\\n        for (int[] edge : edges) {\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n\\n        for (List<Integer> adj : graph) Collections.sort(adj, (a, b) -> scores[b] - scores[a]);\\n        return graph;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\n/**\\n    *   brute force would be to create a graph and run a dfs starting from each node adding their score and calculating the maximum but it would be exponential\\n    \\n    *   another intuition can be selecting any edge to be middle edge in the sequence, now we have 2 remaining nodes we can select from the neighbours of this middle edges\\n    *   we only need to see top 3 nodes (coz we don\\'t want to see duplicate nodes that\\'s why 3) from both of these two middle nodes, to select 2 nodes, one from each middle node that gives maximum score\\n    *\\n    *   algorithm\\n    *   - create graph adjacency list.\\n    *   - sort neightbours of each nodes by their scores in descending order.\\n    *   - now iterate over edges.\\n    *   - select each edge to be middle nodes.\\n    *   - from one of the middle nodes, select one node it should not be one of already selected.\\n    *   - nowin inner loop select one node from the other edge and calculate max score.\\n    */\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        int n = scores.length;\\n        List<List<Integer>> graph = createGraph(n, edges, scores);\\n\\n        int maxScore = -1;\\n        for (int[] edge : edges) {\\n            int a = edge[0];\\n            int b = edge[1];\\n\\n            for (int i = 0; i < Math.min(3, graph.get(a).size()); i++) {\\n                int c = graph.get(a).get(i);\\n\\n                if (c == b) continue;\\n\\n                for (int j = 0; j < Math.min(3, graph.get(b).size()); j++) {\\n                    int d = graph.get(b).get(j);\\n                    if (d == a || d == c) continue;\\n\\n                    maxScore = Math.max(maxScore, scores[a] + scores[b] + scores[c] + scores[d]);\\n                }\\n            }\\n        }\\n\\n        return maxScore;\\n    }\\n    \\n    \\n    private List<List<Integer>> createGraph(int n, int[][] edges, int[] scores) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());\\n\\n        for (int[] edge : edges) {\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n\\n        for (List<Integer> adj : graph) Collections.sort(adj, (a, b) -> scores[b] - scores[a]);\\n        return graph;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2622400,
                "title": "lol-here-i-am-trying-to-write-production-level-code-on-an-lc-hard-xd-faster-than-90",
                "content": "```\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        # Declaration of adjacency list, maximum score and path score variables\\n        graph, bestScores, maxScore = defaultdict(list), defaultdict(list), -1\\n        \\n        # Turning the edge list into an adjacency graph.\\n        for vertex1, vertex2 in edges:\\n            graph[vertex1].append(vertex2)\\n            graph[vertex2].append(vertex1)\\n        \\n        # We will iterate through all the nodes, starting from those nodes\\n        # and update the nodes with largest, 2nd largest and 3rd largest scores\\n        # for each node\\n        for startingVertex in graph:\\n            # initialise the best scores for the starting node\\n            # to score the largest, 2nd largest and 3rd largest scores\\n            # and their corresponding nodes\\n            bestScores[startingVertex] = [[-1, -1], [-1, -1], [-1, -1]]\\n            \\n            for neighbor in graph[startingVertex]:\\n                # Fetching the score for the current node\\n                current = [scores[neighbor], neighbor]\\n                \\n                # If the score of current node is bigger than all of the current scores\\n                # shift the 1st and 2nd maximum to 2nd and 3rd maximum and store current\\n                # as the maximum\\n                if current > bestScores[startingVertex][0]:\\n                    bestScores[startingVertex][2] = bestScores[startingVertex][1]\\n                    bestScores[startingVertex][1] = bestScores[startingVertex][0]\\n                    bestScores[startingVertex][0] = current\\n                \\n                # If the score of current node is bigger than 2nd maximum score\\n                # shift the 2nd maximum to 3rd maximum and store current\\n                # as the 2nd maximum\\n                elif current > bestScores[startingVertex][1]:\\n                    bestScores[startingVertex][2] = bestScores[startingVertex][1]\\n                    bestScores[startingVertex][1] = current\\n                \\n                # If the score of current node is bigger than 3nd maximum score\\n                # store current as the 3rd maximum\\n                elif current > bestScores[startingVertex][2]:\\n                    bestScores[startingVertex][2] = current\\n                \\n        \\n        # Iterate over all the edges and find maximum scores of nodes connected\\n        # with all these nodes. The maximum score will be computed by finding the maximum\\n        # scores of the vertices of the edge themselves and the scores of the vertices\\n        # connected to vertex1 and vertex2 which have maximum scores \\n        for vertex1, vertex2 in edges:\\n            \\n            # Getting maximum scores for 1st vertex\\n            for scoreOfVertex3, vertex3 in bestScores[vertex1]:\\n                \\n                # Getting maximum scores for 2nd vertex \\n                for scoreOfVertex4, vertex4 in bestScores[vertex2]:\\n                    \\n                    # If all the vertices are distinct, we can update the maximum score\\n                    # Provided the maximum score nodes of the two vertices exist\\n                    if vertex3 != vertex4 and vertex3 != vertex1 and vertex3 != vertex2 and vertex4 != vertex1 and vertex4 != vertex2:\\n                        if scoreOfVertex3 != -1 and scoreOfVertex4 != -1:\\n                            maxScore = max(maxScore, scores[vertex1] + scores[vertex2] + scoreOfVertex3 + scoreOfVertex4)\\n        return maxScore\\n```",
                "solutionTags": [
                    "Python",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        # Declaration of adjacency list, maximum score and path score variables\\n        graph, bestScores, maxScore = defaultdict(list), defaultdict(list), -1\\n        \\n        # Turning the edge list into an adjacency graph.\\n        for vertex1, vertex2 in edges:\\n            graph[vertex1].append(vertex2)\\n            graph[vertex2].append(vertex1)\\n        \\n        # We will iterate through all the nodes, starting from those nodes\\n        # and update the nodes with largest, 2nd largest and 3rd largest scores\\n        # for each node\\n        for startingVertex in graph:\\n            # initialise the best scores for the starting node\\n            # to score the largest, 2nd largest and 3rd largest scores\\n            # and their corresponding nodes\\n            bestScores[startingVertex] = [[-1, -1], [-1, -1], [-1, -1]]\\n            \\n            for neighbor in graph[startingVertex]:\\n                # Fetching the score for the current node\\n                current = [scores[neighbor], neighbor]\\n                \\n                # If the score of current node is bigger than all of the current scores\\n                # shift the 1st and 2nd maximum to 2nd and 3rd maximum and store current\\n                # as the maximum\\n                if current > bestScores[startingVertex][0]:\\n                    bestScores[startingVertex][2] = bestScores[startingVertex][1]\\n                    bestScores[startingVertex][1] = bestScores[startingVertex][0]\\n                    bestScores[startingVertex][0] = current\\n                \\n                # If the score of current node is bigger than 2nd maximum score\\n                # shift the 2nd maximum to 3rd maximum and store current\\n                # as the 2nd maximum\\n                elif current > bestScores[startingVertex][1]:\\n                    bestScores[startingVertex][2] = bestScores[startingVertex][1]\\n                    bestScores[startingVertex][1] = current\\n                \\n                # If the score of current node is bigger than 3nd maximum score\\n                # store current as the 3rd maximum\\n                elif current > bestScores[startingVertex][2]:\\n                    bestScores[startingVertex][2] = current\\n                \\n        \\n        # Iterate over all the edges and find maximum scores of nodes connected\\n        # with all these nodes. The maximum score will be computed by finding the maximum\\n        # scores of the vertices of the edge themselves and the scores of the vertices\\n        # connected to vertex1 and vertex2 which have maximum scores \\n        for vertex1, vertex2 in edges:\\n            \\n            # Getting maximum scores for 1st vertex\\n            for scoreOfVertex3, vertex3 in bestScores[vertex1]:\\n                \\n                # Getting maximum scores for 2nd vertex \\n                for scoreOfVertex4, vertex4 in bestScores[vertex2]:\\n                    \\n                    # If all the vertices are distinct, we can update the maximum score\\n                    # Provided the maximum score nodes of the two vertices exist\\n                    if vertex3 != vertex4 and vertex3 != vertex1 and vertex3 != vertex2 and vertex4 != vertex1 and vertex4 != vertex2:\\n                        if scoreOfVertex3 != -1 and scoreOfVertex4 != -1:\\n                            maxScore = max(maxScore, scores[vertex1] + scores[vertex2] + scoreOfVertex3 + scoreOfVertex4)\\n        return maxScore\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587788,
                "title": "i-m-getting-tle-on-this-can-anyone-tell-why",
                "content": "For each edge, I have finding 2 other optimal vertices so that path length is maximised for length = 4. \\n```\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        n = len(scores)\\n        adj = [[] for v in range(n)]\\n        for v1, v2 in edges:\\n            adj[v1].append(v2)\\n            adj[v2].append(v1)\\n            \\n        edges2 = [edge[::-1] for edge in edges]\\n        edges.extend(edges2)\\n        ans = -1\\n        scores.append(-1)\\n        for e in edges:\\n            v1, v2 = e\\n            m1 = n\\n            for v3 in adj[v1]:\\n                if v3 != v2 and scores[v3] > scores[m1]:\\n                    m1 = v3\\n            m2 = n\\n            for v4 in adj[v2]:\\n                if v4 != v1 and v4 != m1 and scores[v4] > scores[m2]:\\n                    m2 = v4\\n            if m1 != n  and m2 != n: ans = max(ans, scores[v1] + scores[v2] + scores[m1] + scores[m2])\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        n = len(scores)\\n        adj = [[] for v in range(n)]\\n        for v1, v2 in edges:\\n            adj[v1].append(v2)\\n            adj[v2].append(v1)\\n            \\n        edges2 = [edge[::-1] for edge in edges]\\n        edges.extend(edges2)\\n        ans = -1\\n        scores.append(-1)\\n        for e in edges:\\n            v1, v2 = e\\n            m1 = n\\n            for v3 in adj[v1]:\\n                if v3 != v2 and scores[v3] > scores[m1]:\\n                    m1 = v3\\n            m2 = n\\n            for v4 in adj[v2]:\\n                if v4 != v1 and v4 != m1 and scores[v4] > scores[m2]:\\n                    m2 = v4\\n            if m1 != n  and m2 != n: ans = max(ans, scores[v1] + scores[v2] + scores[m1] + scores[m2])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494952,
                "title": "python-checking-for-existence-of-valid-paths-for-each-pair-edge",
                "content": "```\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        \\n        edge_dict = defaultdict(list)\\n        for x,y in edges:\\n            edge_dict[x].append(y)\\n            edge_dict[y].append(x)\\n        \\n        best = defaultdict(list)\\n        for edge in edge_dict: # for each vertex in graph\\n            best[edge] = [ [-1,-1], [-1,-1], [-1,-1] ]\\n            \\n            for v in edge_dict[edge]: # look at adjacent vertices to identify the 3 highest score adjacent \\n                current = [scores[v],v]\\n                if current>best[edge][0]:\\n                    best[edge][2] = best[edge][1]\\n                    best[edge][1] = best[edge][0]\\n                    best[edge][0] = current\\n                elif current>best[edge][1]:\\n                    best[edge][2] = best[edge][1]\\n                    best[edge][1] = current\\n                elif current>best[edge][2]:\\n                    best[edge][2] = current\\n        \\n        max_score = -1\\n        for a,b in edges:\\n            for score_c, c in best[a]:\\n                for score_d, d in best[b]:\\n                    if c!=d and c!=a and c!=b and d!=a and d!=b:\\n                        if score_c != -1 and score_d != -1:\\n                            max_score = max(max_score,scores[a]+scores[b]+score_c+score_d) # valid path found, track the maximum\\n                            \\n        return max_score    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        \\n        edge_dict = defaultdict(list)\\n        for x,y in edges:\\n            edge_dict[x].append(y)\\n            edge_dict[y].append(x)\\n        \\n        best = defaultdict(list)\\n        for edge in edge_dict: # for each vertex in graph\\n            best[edge] = [ [-1,-1], [-1,-1], [-1,-1] ]\\n            \\n            for v in edge_dict[edge]: # look at adjacent vertices to identify the 3 highest score adjacent \\n                current = [scores[v],v]\\n                if current>best[edge][0]:\\n                    best[edge][2] = best[edge][1]\\n                    best[edge][1] = best[edge][0]\\n                    best[edge][0] = current\\n                elif current>best[edge][1]:\\n                    best[edge][2] = best[edge][1]\\n                    best[edge][1] = current\\n                elif current>best[edge][2]:\\n                    best[edge][2] = current\\n        \\n        max_score = -1\\n        for a,b in edges:\\n            for score_c, c in best[a]:\\n                for score_d, d in best[b]:\\n                    if c!=d and c!=a and c!=b and d!=a and d!=b:\\n                        if score_c != -1 and score_d != -1:\\n                            max_score = max(max_score,scores[a]+scores[b]+score_c+score_d) # valid path found, track the maximum\\n                            \\n        return max_score    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469201,
                "title": "c-bucketing-top-3-neighbors-for-each-node",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int N = scores.size();\\n        \\n        vector<vector<pair<int,int>>> MaxScores(N,vector<pair<int,int>>(3,{-1,-1}));\\n        for(int i=0;i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            \\n            if(scores[v] > MaxScores[u][0].first){\\n                MaxScores[u][2] = MaxScores[u][1];\\n                MaxScores[u][1] = MaxScores[u][0];\\n                MaxScores[u][0] = {scores[v],v};\\n            }else if(scores[v] > MaxScores[u][1].first){\\n                MaxScores[u][2] = MaxScores[u][1];\\n                MaxScores[u][1] = {scores[v],v};\\n            }else if(scores[v] > MaxScores[u][2].first){\\n                MaxScores[u][2] = {scores[v],v};\\n            }\\n            \\n            if(scores[u] > MaxScores[v][0].first){\\n                MaxScores[v][2] = MaxScores[v][1];\\n                MaxScores[v][1] = MaxScores[v][0];\\n                MaxScores[v][0] = {scores[u],u};\\n            }else if(scores[u] > MaxScores[v][1].first){\\n                MaxScores[v][2] = MaxScores[v][1];\\n                MaxScores[v][1] = {scores[u],u};\\n            }else if(scores[u] > MaxScores[v][2].first){\\n                MaxScores[v][2] = {scores[u],u};\\n            }\\n        }\\n        \\n        int Ans = -1;\\n        for(int i=0;i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n           \\n            for(int i=0;i<3;i++){\\n                for(int j=0;j<3;j++){\\n                    int x = MaxScores[u][i].second;\\n                    int y = MaxScores[v][j].second;\\n                    \\n                    if(x!=-1 && y!=-1 && u!=x && v!=x && u!=y && v!=y && x!=y){\\n                        int TotalScore = scores[u] + scores[v] + scores[x] + scores[y];\\n                        Ans = max(Ans,TotalScore);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return Ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int N = scores.size();\\n        \\n        vector<vector<pair<int,int>>> MaxScores(N,vector<pair<int,int>>(3,{-1,-1}));\\n        for(int i=0;i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            \\n            if(scores[v] > MaxScores[u][0].first){\\n                MaxScores[u][2] = MaxScores[u][1];\\n                MaxScores[u][1] = MaxScores[u][0];\\n                MaxScores[u][0] = {scores[v],v};\\n            }else if(scores[v] > MaxScores[u][1].first){\\n                MaxScores[u][2] = MaxScores[u][1];\\n                MaxScores[u][1] = {scores[v],v};\\n            }else if(scores[v] > MaxScores[u][2].first){\\n                MaxScores[u][2] = {scores[v],v};\\n            }\\n            \\n            if(scores[u] > MaxScores[v][0].first){\\n                MaxScores[v][2] = MaxScores[v][1];\\n                MaxScores[v][1] = MaxScores[v][0];\\n                MaxScores[v][0] = {scores[u],u};\\n            }else if(scores[u] > MaxScores[v][1].first){\\n                MaxScores[v][2] = MaxScores[v][1];\\n                MaxScores[v][1] = {scores[u],u};\\n            }else if(scores[u] > MaxScores[v][2].first){\\n                MaxScores[v][2] = {scores[u],u};\\n            }\\n        }\\n        \\n        int Ans = -1;\\n        for(int i=0;i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n           \\n            for(int i=0;i<3;i++){\\n                for(int j=0;j<3;j++){\\n                    int x = MaxScores[u][i].second;\\n                    int y = MaxScores[v][j].second;\\n                    \\n                    if(x!=-1 && y!=-1 && u!=x && v!=x && u!=y && v!=y && x!=y){\\n                        int TotalScore = scores[u] + scores[v] + scores[x] + scores[y];\\n                        Ans = max(Ans,TotalScore);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return Ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467192,
                "title": "python-clean-code-with-proof",
                "content": "Consider all possiblities `a, b` for a middle edge of a 4-len path. Then for `a` node pick highest score neighbor `ta`, similarly for `b` pick `tb`. Thus we get largest possible sum 4-len path `ta - a - b - tb` with middle nodes being `a and b`.\\n\\nBut, there is a caviat that (1) `ta == b` or `tb == a` or `ta == tb` might hold, resulting in a non-valid path. That\\'s why for each node `a` we precompute three largest score vertices `ta1, ta2, ta3` and choose best pair `ta_i` `tb_j` so that equalities (1) won\\'t hold.\\n\\nTime complexity is O(n + m). Where n, m - number of nodes and edges respectively.\\n\\n```\\nclass Solution:\\n    def maximumScore(self, scores, edges):\\n        n = len(scores)\\n        t3 = [[] for _ in range(n)]\\n        gr = [[] for _ in range(n)]\\n\\n        for a, b in edges:\\n            gr[a].append(b)\\n            gr[b].append(a)\\n\\n        for v in range(n):\\n            for to in gr[v]:\\n                t3[v].append((scores[to], to))\\n            t3[v] = sorted(t3[v], reverse=True)[:3]\\n\\n        mx = -1\\n        for a, b in edges:\\n            for sa, ta in t3[a]:\\n                if ta == b: continue\\n                for sb, tb, in t3[b]:\\n                    if tb == a or tb == ta: continue\\n                    mx = max(mx, sa + sb + scores[a] + scores[b])\\n\\n        return mx\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumScore(self, scores, edges):\\n        n = len(scores)\\n        t3 = [[] for _ in range(n)]\\n        gr = [[] for _ in range(n)]\\n\\n        for a, b in edges:\\n            gr[a].append(b)\\n            gr[b].append(a)\\n\\n        for v in range(n):\\n            for to in gr[v]:\\n                t3[v].append((scores[to], to))\\n            t3[v] = sorted(t3[v], reverse=True)[:3]\\n\\n        mx = -1\\n        for a, b in edges:\\n            for sa, ta in t3[a]:\\n                if ta == b: continue\\n                for sb, tb, in t3[b]:\\n                    if tb == a or tb == ta: continue\\n                    mx = max(mx, sa + sb + scores[a] + scores[b])\\n\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372151,
                "title": "rust-top-3-neighbors",
                "content": "Translated from @Bakerston and @lee215 \\'s solution \\n```rust\\nimpl Solution {\\n    pub fn maximum_score(scores: Vec<i32>, edges: Vec<Vec<i32>>) -> i32 {\\n        let len = scores.len();\\n\\n        // we store the neighbor with tuples (Reverse(Score), NODE)\\n        // since rust\\'s tuple are ordered lexicographically,\\n        // the score will be compared first\\n        // we also need to keep the binary heap as a min-heap to pop\\n        // the smallest element out of the binary heap\\n        let mut neighbors: Vec<BinaryHeap<(Reverse<i32>, usize)>> = vec![BinaryHeap::new(); len];\\n\\n        for edge in edges.iter() {\\n            let u = edge[0] as usize;\\n            let v = edge[1] as usize;\\n\\n            neighbors[u].push((Reverse(scores[v]), v));\\n            neighbors[v].push((Reverse(scores[u]), u));\\n\\n            if neighbors[u].len() > 3 {\\n                neighbors[u].pop();\\n            }\\n            if neighbors[v].len() > 3 {\\n                neighbors[v].pop();\\n            }\\n        }\\n\\n        let mut res = -1;\\n\\n        for edge in edges.into_iter() {\\n            let u = edge[0] as usize;\\n            let v = edge[1] as usize;\\n            for (Reverse(u_neighbor_score), u_neighbor) in neighbors[u].iter() {\\n                for (Reverse(v_neighbor_score), v_neighbor) in neighbors[v].iter() {\\n                    if *u_neighbor != v && *v_neighbor != u && *u_neighbor != *v_neighbor {\\n                        res = std::cmp::max(\\n                            res,\\n                            scores[u] + scores[v] + *u_neighbor_score + *v_neighbor_score,\\n                        );\\n                    }\\n                }\\n            }\\n        }\\n\\n        res\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn maximum_score(scores: Vec<i32>, edges: Vec<Vec<i32>>) -> i32 {\\n        let len = scores.len();\\n\\n        // we store the neighbor with tuples (Reverse(Score), NODE)\\n        // since rust\\'s tuple are ordered lexicographically,\\n        // the score will be compared first\\n        // we also need to keep the binary heap as a min-heap to pop\\n        // the smallest element out of the binary heap\\n        let mut neighbors: Vec<BinaryHeap<(Reverse<i32>, usize)>> = vec![BinaryHeap::new(); len];\\n\\n        for edge in edges.iter() {\\n            let u = edge[0] as usize;\\n            let v = edge[1] as usize;\\n\\n            neighbors[u].push((Reverse(scores[v]), v));\\n            neighbors[v].push((Reverse(scores[u]), u));\\n\\n            if neighbors[u].len() > 3 {\\n                neighbors[u].pop();\\n            }\\n            if neighbors[v].len() > 3 {\\n                neighbors[v].pop();\\n            }\\n        }\\n\\n        let mut res = -1;\\n\\n        for edge in edges.into_iter() {\\n            let u = edge[0] as usize;\\n            let v = edge[1] as usize;\\n            for (Reverse(u_neighbor_score), u_neighbor) in neighbors[u].iter() {\\n                for (Reverse(v_neighbor_score), v_neighbor) in neighbors[v].iter() {\\n                    if *u_neighbor != v && *v_neighbor != u && *u_neighbor != *v_neighbor {\\n                        res = std::cmp::max(\\n                            res,\\n                            scores[u] + scores[v] + *u_neighbor_score + *v_neighbor_score,\\n                        );\\n                    }\\n                }\\n            }\\n        }\\n\\n        res\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2367819,
                "title": "c-solution-preprocessing-sorting",
                "content": "As mentined in the hint, for a four node path, there are three edges. Fix the middle edge and find the the other two edges. To do that, we create an adjacency list and sort it in descending order of the node value of its neighbours. Then we iterate over all the edges one by one and try to find the other two edges. We just need to consider top `3` neighbours of the node for the worst case scenario: Imagine the edge between `a` and `b`. Assume that `a` is the first highest neighbor of `b`,  `c` is the second highest neighbor. Now for `a`, `b` is the first highest and `c` is the second highest valued neighbor. In this case, we need `d`, the third highest valued neighbor of `a`.\\n\\nComplexity:\\nTime => `O(ElogV)`\\nSpace => `O(E + V)`\\n\\n```\\n#define Node pair<int, int>\\n#define makeNode(i, s) make_pair(s, i)\\n#define getNode() second\\n#define getScore() first\\n\\nclass Solution {\\nprivate:\\n    int INVALID = -1;\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int k = 4;\\n        int n = scores.size();\\n        vector<vector<Node>> adjList(n);\\n        for(auto& edge: edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            adjList[u].push_back(makeNode(v, scores[v]));\\n            adjList[v].push_back(makeNode(u, scores[u]));\\n        }\\n        for(int i = 0; i < n; i++){\\n            sort(adjList[i].begin(), adjList[i].end(), greater<Node>());\\n        }\\n        vector<bool> vis(n, false);\\n        int ans = INVALID;\\n        for(auto& edge: edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            vis[u] = vis[v] = true;\\n            int score = scores[u] + scores[v];\\n            for(int i = 0; i < k-1 && i < adjList[u].size(); i++){\\n                if(vis[adjList[u][i].getNode()]){\\n                    continue;\\n                }\\n                vis[adjList[u][i].getNode()] = true;\\n                score += scores[adjList[u][i].getNode()];\\n                for(int j = 0; j < k-1 && j < adjList[v].size(); j++){\\n                    if(vis[adjList[v][j].getNode()]){\\n                        continue;\\n                    }\\n                    vis[adjList[v][j].getNode()] = true;\\n                    score += scores[adjList[v][j].getNode()];\\n                    ans = max(ans, score);\\n                    score -= scores[adjList[v][j].getNode()];\\n                    vis[adjList[v][j].getNode()] = false;\\n                }\\n                score -= scores[adjList[u][i].getNode()];\\n                vis[adjList[u][i].getNode()] = false;\\n            }\\n            vis[u] = vis[v] = false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n#define Node pair<int, int>\\n#define makeNode(i, s) make_pair(s, i)\\n#define getNode() second\\n#define getScore() first\\n\\nclass Solution {\\nprivate:\\n    int INVALID = -1;\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int k = 4;\\n        int n = scores.size();\\n        vector<vector<Node>> adjList(n);\\n        for(auto& edge: edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            adjList[u].push_back(makeNode(v, scores[v]));\\n            adjList[v].push_back(makeNode(u, scores[u]));\\n        }\\n        for(int i = 0; i < n; i++){\\n            sort(adjList[i].begin(), adjList[i].end(), greater<Node>());\\n        }\\n        vector<bool> vis(n, false);\\n        int ans = INVALID;\\n        for(auto& edge: edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            vis[u] = vis[v] = true;\\n            int score = scores[u] + scores[v];\\n            for(int i = 0; i < k-1 && i < adjList[u].size(); i++){\\n                if(vis[adjList[u][i].getNode()]){\\n                    continue;\\n                }\\n                vis[adjList[u][i].getNode()] = true;\\n                score += scores[adjList[u][i].getNode()];\\n                for(int j = 0; j < k-1 && j < adjList[v].size(); j++){\\n                    if(vis[adjList[v][j].getNode()]){\\n                        continue;\\n                    }\\n                    vis[adjList[v][j].getNode()] = true;\\n                    score += scores[adjList[v][j].getNode()];\\n                    ans = max(ans, score);\\n                    score -= scores[adjList[v][j].getNode()];\\n                    vis[adjList[v][j].getNode()] = false;\\n                }\\n                score -= scores[adjList[u][i].getNode()];\\n                vis[adjList[u][i].getNode()] = false;\\n            }\\n            vis[u] = vis[v] = false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349351,
                "title": "java-priority-queue-top-3",
                "content": "```\\n/* for every node, we need 3 other nodes in the path, so keep top 3 neighbors of each node and calculate sum of path.\\n*/\\n\\nclass Solution {\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        if(scores == null || edges == null) {\\n            return 0;\\n        }\\n        \\n        int n = scores.length;    \\n        PriorityQueue<Integer>[] topNeighbrs = new PriorityQueue[n];\\n        for(int idx = 0; idx<n; idx++) {\\n            topNeighbrs[idx] = new PriorityQueue<>((a,b) -> Integer.compare(scores[a], scores[b]));\\n        }\\n        \\n        for(int[] edge : edges) {    \\n            int firstNode = edge[0], secondNode = edge[1];\\n            topNeighbrs[firstNode].add(secondNode);\\n            topNeighbrs[secondNode].add(firstNode);\\n            \\n            if(topNeighbrs[firstNode].size() > 3) {\\n                topNeighbrs[firstNode].poll();\\n            }if(topNeighbrs[secondNode].size() > 3) {\\n                topNeighbrs[secondNode].poll();\\n            }\\n        }\\n        \\n        int maxScore = -1;\\n        for(int[] edge : edges) {\\n            int n1 = edge[0];\\n            int n2 = edge[1];\\n            for(int n11 : topNeighbrs[n1]) {\\n                for(int n22 : topNeighbrs[n2]) {\\n                    \\n                    if(n11 != n22 && n11 != n2 && n22 != n1) {\\n                        maxScore = Math.max(maxScore, scores[n11] + scores[n1] + scores[n2] + scores[n22]);\\n                    }   \\n                }\\n            }\\n            \\n        }\\n        \\n        return maxScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/* for every node, we need 3 other nodes in the path, so keep top 3 neighbors of each node and calculate sum of path.\\n*/\\n\\nclass Solution {\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        if(scores == null || edges == null) {\\n            return 0;\\n        }\\n        \\n        int n = scores.length;    \\n        PriorityQueue<Integer>[] topNeighbrs = new PriorityQueue[n];\\n        for(int idx = 0; idx<n; idx++) {\\n            topNeighbrs[idx] = new PriorityQueue<>((a,b) -> Integer.compare(scores[a], scores[b]));\\n        }\\n        \\n        for(int[] edge : edges) {    \\n            int firstNode = edge[0], secondNode = edge[1];\\n            topNeighbrs[firstNode].add(secondNode);\\n            topNeighbrs[secondNode].add(firstNode);\\n            \\n            if(topNeighbrs[firstNode].size() > 3) {\\n                topNeighbrs[firstNode].poll();\\n            }if(topNeighbrs[secondNode].size() > 3) {\\n                topNeighbrs[secondNode].poll();\\n            }\\n        }\\n        \\n        int maxScore = -1;\\n        for(int[] edge : edges) {\\n            int n1 = edge[0];\\n            int n2 = edge[1];\\n            for(int n11 : topNeighbrs[n1]) {\\n                for(int n22 : topNeighbrs[n2]) {\\n                    \\n                    if(n11 != n22 && n11 != n2 && n22 != n1) {\\n                        maxScore = Math.max(maxScore, scores[n11] + scores[n1] + scores[n2] + scores[n22]);\\n                    }   \\n                }\\n            }\\n            \\n        }\\n        \\n        return maxScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286872,
                "title": "python-go-top-3-neighbors-o-v-e",
                "content": "*Python* solution\\n\\n```python\\ndef maximumScore(self, scores, edges):\\n    adj = [[] for _ in range(len(scores))]\\n    for i, j in edges:\\n        adj[i].append(j)\\n        adj[j].append(i)\\n    top = [heapq.nlargest(3, adj[i], scores.__getitem__) for i in range(len(scores))]\\n    return max(\\n        [\\n            scores[a] + scores[b] + scores[c] + scores[d]\\n            for a, b in edges\\n            for c, d in itertools.product(top[a], top[b])\\n            if len({a, b, c, d}) == 4\\n        ],\\n        default=-1,\\n    )\\n```\\n\\n*Go* solution in 267ms\\n\\n```go\\nfunc maximumScore(scores []int, edges [][]int) int {\\n\\tvar (\\n\\t\\tres = -1\\n\\t\\tn   = len(scores)\\n\\t\\tadj = make([][]int, n)\\n\\t\\ttop = make([][]int, n)\\n\\t)\\n\\tfor _, x := range edges {\\n\\t\\ti, j := x[0], x[1]\\n\\t\\tadj[i] = append(adj[i], j)\\n\\t\\tadj[j] = append(adj[j], i)\\n\\t}\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < 3; j++ {\\n\\t\\t\\tx, val := -1, 0\\n\\t\\t\\tfor y, z := range adj[i] {\\n\\t\\t\\t\\tif z >= 0 && scores[z] > val {\\n\\t\\t\\t\\t\\tx, val = y, scores[z]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif x >= 0 {\\n\\t\\t\\t\\tadj[i][x], top[i] = -1, append(top[i], adj[i][x])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor _, x := range edges {\\n\\t\\ta, b := x[0], x[1]\\n\\t\\tfor _, c := range top[a] {\\n\\t\\t\\tfor _, d := range top[b] {\\n\\t\\t\\t\\tif a != d && b != c && c != d {\\n\\t\\t\\t\\t\\tif cur := scores[a] + scores[b] + scores[c] + scores[d]; cur > res {\\n\\t\\t\\t\\t\\t\\tres = cur\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef maximumScore(self, scores, edges):\\n    adj = [[] for _ in range(len(scores))]\\n    for i, j in edges:\\n        adj[i].append(j)\\n        adj[j].append(i)\\n    top = [heapq.nlargest(3, adj[i], scores.__getitem__) for i in range(len(scores))]\\n    return max(\\n        [\\n            scores[a] + scores[b] + scores[c] + scores[d]\\n            for a, b in edges\\n            for c, d in itertools.product(top[a], top[b])\\n            if len({a, b, c, d}) == 4\\n        ],\\n        default=-1,\\n    )\\n```\n```go\\nfunc maximumScore(scores []int, edges [][]int) int {\\n\\tvar (\\n\\t\\tres = -1\\n\\t\\tn   = len(scores)\\n\\t\\tadj = make([][]int, n)\\n\\t\\ttop = make([][]int, n)\\n\\t)\\n\\tfor _, x := range edges {\\n\\t\\ti, j := x[0], x[1]\\n\\t\\tadj[i] = append(adj[i], j)\\n\\t\\tadj[j] = append(adj[j], i)\\n\\t}\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < 3; j++ {\\n\\t\\t\\tx, val := -1, 0\\n\\t\\t\\tfor y, z := range adj[i] {\\n\\t\\t\\t\\tif z >= 0 && scores[z] > val {\\n\\t\\t\\t\\t\\tx, val = y, scores[z]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif x >= 0 {\\n\\t\\t\\t\\tadj[i][x], top[i] = -1, append(top[i], adj[i][x])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor _, x := range edges {\\n\\t\\ta, b := x[0], x[1]\\n\\t\\tfor _, c := range top[a] {\\n\\t\\t\\tfor _, d := range top[b] {\\n\\t\\t\\t\\tif a != d && b != c && c != d {\\n\\t\\t\\t\\t\\tif cur := scores[a] + scores[b] + scores[c] + scores[d]; cur > res {\\n\\t\\t\\t\\t\\t\\tres = cur\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2189683,
                "title": "go-easy-commented-solution",
                "content": "```\\nfunc maximumScore(scores []int, edges [][]int) int {\\n    neighbors := map[int][]int{}\\n    \\n    // construct bidirectional adjacency map\\n    for _, e := range edges {\\n        neighbors[e[0]] = append(neighbors[e[0]], e[1])\\n        neighbors[e[1]] = append(neighbors[e[1]], e[0])\\n    }\\n    \\n    // sort all neighbors by decreasing score and limit to top 3\\n    for k := range neighbors {\\n        sort.Slice(neighbors[k], func(i, j int) bool {\\n            return scores[neighbors[k][i]] > scores[neighbors[k][j]]\\n        })\\n        l := min(3, len(neighbors[k]))\\n        neighbors[k] = neighbors[k][:l]\\n    }\\n    \\n    out := -1\\n    // iterate through all sequences that look like [leftNeighbor, l, r, rightNeighbor]\\n    for _, e := range edges {\\n        l := e[0]\\n        r := e[1]\\n        currScore := scores[l] + scores[r]\\n        // iterate through all leftNeighbors of l which aren\\'t r\\n        for _, leftNeighbor := range neighbors[l] {\\n            if leftNeighbor == r {\\n                continue\\n            }\\n            \\n            // iterate through all rightNeighbors of r which aren\\'t l or leftNeighbor\\n            for _, rightNeighbor := range neighbors[r] {\\n                if rightNeighbor == l || rightNeighbor == leftNeighbor {\\n                    continue\\n                }\\n                \\n                // add scores of all 4 nodes and compare to current max\\n                out = max(out, currScore + scores[leftNeighbor] + scores[rightNeighbor])\\n            }\\n        }\\n    }\\n    return out\\n}\\n\\nfunc max(i, j int) int {\\n    if i > j {\\n        return i\\n    }\\n    return j\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}",
                "solutionTags": [],
                "code": "```\\nfunc maximumScore(scores []int, edges [][]int) int {\\n    neighbors := map[int][]int{}\\n    \\n    // construct bidirectional adjacency map\\n    for _, e := range edges {\\n        neighbors[e[0]] = append(neighbors[e[0]], e[1])\\n        neighbors[e[1]] = append(neighbors[e[1]], e[0])\\n    }\\n    \\n    // sort all neighbors by decreasing score and limit to top 3\\n    for k := range neighbors {\\n        sort.Slice(neighbors[k], func(i, j int) bool {\\n            return scores[neighbors[k][i]] > scores[neighbors[k][j]]\\n        })\\n        l := min(3, len(neighbors[k]))\\n        neighbors[k] = neighbors[k][:l]\\n    }\\n    \\n    out := -1\\n    // iterate through all sequences that look like [leftNeighbor, l, r, rightNeighbor]\\n    for _, e := range edges {\\n        l := e[0]\\n        r := e[1]\\n        currScore := scores[l] + scores[r]\\n        // iterate through all leftNeighbors of l which aren\\'t r\\n        for _, leftNeighbor := range neighbors[l] {\\n            if leftNeighbor == r {\\n                continue\\n            }\\n            \\n            // iterate through all rightNeighbors of r which aren\\'t l or leftNeighbor\\n            for _, rightNeighbor := range neighbors[r] {\\n                if rightNeighbor == l || rightNeighbor == leftNeighbor {\\n                    continue\\n                }\\n                \\n                // add scores of all 4 nodes and compare to current max\\n                out = max(out, currScore + scores[leftNeighbor] + scores[rightNeighbor])\\n            }\\n        }\\n    }\\n    return out\\n}\\n\\nfunc max(i, j int) int {\\n    if i > j {\\n        return i\\n    }\\n    return j\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2173655,
                "title": "python3",
                "content": "```class Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        store = defaultdict(list)\\n        for a, b in edges:\\n            bisect.insort_left(store[a],[scores[b], b])\\n            bisect.insort_left(store[b],[scores[a], a])\\n            if len(store[a]) > 3:\\n                store[a].pop(0)\\n            if len(store[b]) > 3:\\n                store[b].pop(0)\\n        ans = -1\\n        for a, b in edges:\\n            if len(store[a]) < 2 or len(store[b]) < 2 :\\n                continue\\n            for c in store[a]:\\n                for d in store[b]:\\n                    if c[1] != d[1] and c[1] not in [a, b] and d[1] not in [a, b]:\\n                        ans = max(ans, scores[a] + scores[b] + c[0] + d[0])\\n        return ans",
                "solutionTags": [],
                "code": "```class Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        store = defaultdict(list)\\n        for a, b in edges:\\n            bisect.insort_left(store[a],[scores[b], b])\\n            bisect.insort_left(store[b],[scores[a], a])\\n            if len(store[a]) > 3:\\n                store[a].pop(0)\\n            if len(store[b]) > 3:\\n                store[b].pop(0)\\n        ans = -1\\n        for a, b in edges:\\n            if len(store[a]) < 2 or len(store[b]) < 2 :\\n                continue\\n            for c in store[a]:\\n                for d in store[b]:\\n                    if c[1] != d[1] and c[1] not in [a, b] and d[1] not in [a, b]:\\n                        ans = max(ans, scores[a] + scores[b] + c[0] + d[0])\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2167202,
                "title": "python-sort-edges",
                "content": "ideas:\\n(0) total 3 edges, loop through the middle edge and check the left and right possibilities;\\n(1) first sort nodes\\'s neighbors and only need keep top 3 highly scored neighbors;\\n(2) for each end node of the middle edge, say [a,b], one may encounter a neighbor node c shared by both a and b;\\n(3) so consider c1, c2 the two possibles; and get the corresponding d1,d2 for node b\\'s neibors.\\n\\n```\\ndef maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        g=defaultdict(list)\\n        for a,b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n        ## each node keeps only the top 2 highest scored nb\\n        for i in g:\\n            g[i].sort(reverse=True, key=lambda x:scores[x])\\n            g[i]=g[i][0:3]\\n        res=-1\\n        for a,b in edges:\\n            s1=s2=-1\\n            c2=-1\\n            c1=-1\\n            getc2=False\\n            for i in g[a]:\\n                if i in [a,b]:\\n                    continue\\n                c1=i\\n                if i in g[b]:\\n                    getc2=True\\n                break\\n            if getc2:\\n                for k in g[a]:\\n                    if k in [a,b,c1]:\\n                        continue\\n                    else:\\n                        c2=k\\n                        break\\n            d2=-1\\n            d1=-1\\n            for j in g[b]:\\n                if j in [a,b,c1]:\\n                    continue\\n                d1=j\\n                break\\n            if c1>=0 and d1>=0:\\n                s1=scores[a]+scores[b]+scores[c1]+scores[d1]\\n            if c2>=0 and len(g[b])>=2:\\n                for j in g[b]:\\n                    if j in [a,b,c2]:continue\\n                    d2=j\\n                    break\\n                if d2>=0:\\n                    s2=scores[a]+scores[b]+scores[c2]+scores[d2]\\n            s=max(s1,s2)    \\n            if s>res and ((c1>=0 and d1>=0) or (c2>=0 and d2>=0)):\\n                res=s\\n                \\n        return res",
                "solutionTags": [],
                "code": "ideas:\\n(0) total 3 edges, loop through the middle edge and check the left and right possibilities;\\n(1) first sort nodes\\'s neighbors and only need keep top 3 highly scored neighbors;\\n(2) for each end node of the middle edge, say [a,b], one may encounter a neighbor node c shared by both a and b;\\n(3) so consider c1, c2 the two possibles; and get the corresponding d1,d2 for node b\\'s neibors.\\n\\n```\\ndef maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        g=defaultdict(list)\\n        for a,b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n        ## each node keeps only the top 2 highest scored nb\\n        for i in g:\\n            g[i].sort(reverse=True, key=lambda x:scores[x])\\n            g[i]=g[i][0:3]\\n        res=-1\\n        for a,b in edges:\\n            s1=s2=-1\\n            c2=-1\\n            c1=-1\\n            getc2=False\\n            for i in g[a]:\\n                if i in [a,b]:\\n                    continue\\n                c1=i\\n                if i in g[b]:\\n                    getc2=True\\n                break\\n            if getc2:\\n                for k in g[a]:\\n                    if k in [a,b,c1]:\\n                        continue\\n                    else:\\n                        c2=k\\n                        break\\n            d2=-1\\n            d1=-1\\n            for j in g[b]:\\n                if j in [a,b,c1]:\\n                    continue\\n                d1=j\\n                break\\n            if c1>=0 and d1>=0:\\n                s1=scores[a]+scores[b]+scores[c1]+scores[d1]\\n            if c2>=0 and len(g[b])>=2:\\n                for j in g[b]:\\n                    if j in [a,b,c2]:continue\\n                    d2=j\\n                    break\\n                if d2>=0:\\n                    s2=scores[a]+scores[b]+scores[c2]+scores[d2]\\n            s=max(s1,s2)    \\n            if s>res and ((c1>=0 and d1>=0) or (c2>=0 and d2>=0)):\\n                res=s\\n                \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2123644,
                "title": "c",
                "content": "```\\n    public int MaximumScore(int[] scores, int[][] edges) {\\n        int n = scores.Length;\\n        var graph = new List<(int, int)>[n];     // <score, id>\\n        \\n        // get insertion sort pos\\n        int index(List<(int, int)> list, int val) {\\n            int j = 0;\\n            while(j < list.Count && list[j].Item1 > val) j++;\\n            return j;\\n        }\\n        \\n        // for each node save the most largest 3 neighbors\\n        foreach(var e in edges) {\\n            if(graph[e[0]] == null) graph[e[0]] = new List<(int, int)>();\\n            if(graph[e[1]] == null) graph[e[1]] = new List<(int, int)>();\\n            if(graph[e[0]].Count == 0) \\n                graph[e[0]].Add((scores[e[1]], e[1]));\\n            else {\\n                var idx1 = index(graph[e[0]], scores[e[1]]);\\n                graph[e[0]].Insert(idx1, (scores[e[1]], e[1]));\\n            }\\n            if(graph[e[1]].Count == 0) \\n                graph[e[1]].Add((scores[e[0]], e[0]));\\n            else {\\n                var idx2 = index(graph[e[1]], scores[e[0]]);\\n                graph[e[1]].Insert(idx2, (scores[e[0]], e[0]));\\n            }\\n            if(graph[e[0]].Count > 3) graph[e[0]].RemoveAt(3);\\n            if(graph[e[1]].Count > 3) graph[e[1]].RemoveAt(3);\\n        }\\n        \\n\\n        int result = -1;\\n        foreach(var e in edges) {\\n            int a = e[0], b = e[1], sa = scores[e[0]], sb = scores[e[1]];\\n            foreach(var (sc, c) in graph[a])\\n                foreach(var (sd, d) in graph[b]) \\n                    if(sa + sb + sc + sd > result && c != b && c != d && d != a)\\n                        result = sa + sb + sc + sd;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int MaximumScore(int[] scores, int[][] edges) {\\n        int n = scores.Length;\\n        var graph = new List<(int, int)>[n];     // <score, id>\\n        \\n        // get insertion sort pos\\n        int index(List<(int, int)> list, int val) {\\n            int j = 0;\\n            while(j < list.Count && list[j].Item1 > val) j++;\\n            return j;\\n        }\\n        \\n        // for each node save the most largest 3 neighbors\\n        foreach(var e in edges) {\\n            if(graph[e[0]] == null) graph[e[0]] = new List<(int, int)>();\\n            if(graph[e[1]] == null) graph[e[1]] = new List<(int, int)>();\\n            if(graph[e[0]].Count == 0) \\n                graph[e[0]].Add((scores[e[1]], e[1]));\\n            else {\\n                var idx1 = index(graph[e[0]], scores[e[1]]);\\n                graph[e[0]].Insert(idx1, (scores[e[1]], e[1]));\\n            }\\n            if(graph[e[1]].Count == 0) \\n                graph[e[1]].Add((scores[e[0]], e[0]));\\n            else {\\n                var idx2 = index(graph[e[1]], scores[e[0]]);\\n                graph[e[1]].Insert(idx2, (scores[e[0]], e[0]));\\n            }\\n            if(graph[e[0]].Count > 3) graph[e[0]].RemoveAt(3);\\n            if(graph[e[1]].Count > 3) graph[e[1]].RemoveAt(3);\\n        }\\n        \\n\\n        int result = -1;\\n        foreach(var e in edges) {\\n            int a = e[0], b = e[1], sa = scores[e[0]], sb = scores[e[1]];\\n            foreach(var (sc, c) in graph[a])\\n                foreach(var (sd, d) in graph[b]) \\n                    if(sa + sb + sc + sd > result && c != b && c != d && d != a)\\n                        result = sa + sb + sc + sd;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2067925,
                "title": "kotlin-solution",
                "content": "```kotlin\\nclass Solution {\\n    \\n    // Kotlin 1.4 function\\n    private fun <T : Comparable<T>> Iterable<T>.maxOrNull(): T? {\\n        val iterator = iterator()\\n        if (!iterator.hasNext()) return null\\n        var max = iterator.next()\\n        while (iterator.hasNext()) {\\n            val e = iterator.next()\\n            if (max < e) max = e\\n        }\\n        return max\\n    }\\n\\n    // Kotlin 1.4 function\\n    private inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int {\\n        var sum: Int = 0.toInt()\\n        for (element in this) {\\n            sum += selector(element)\\n        }\\n        return sum\\n    }\\n\\n    fun maximumScore(scores: IntArray, edges: Array<IntArray>): Int {\\n        val adjacentMap = edges.flatMap {\\n                listOf(\\n                    it[0] to it[1],\\n                    it[1] to it[0]\\n                )\\n            }.groupBy { it.first }\\n            .mapValues { entry -> entry.value.map { it.second } }\\n            .mapValues { entry ->\\n                entry.value.sortedByDescending { scores[it] }.take(3)\\n            }\\n        return edges.flatMap { e ->\\n            val leftNeighbor = adjacentMap[e[0]] ?: listOf()\\n            val rightNeighbor = adjacentMap[e[1]] ?: listOf()\\n            leftNeighbor.flatMap { left ->\\n                rightNeighbor.mapNotNull { right ->\\n                    val nodeSet = setOf(left, e[0], e[1], right)\\n                    if (nodeSet.size == 4) {\\n                        nodeSet.sumOf { scores[it] }\\n                    } else null\\n                }\\n            }\\n        }.maxOrNull() ?: -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nclass Solution {\\n    \\n    // Kotlin 1.4 function\\n    private fun <T : Comparable<T>> Iterable<T>.maxOrNull(): T? {\\n        val iterator = iterator()\\n        if (!iterator.hasNext()) return null\\n        var max = iterator.next()\\n        while (iterator.hasNext()) {\\n            val e = iterator.next()\\n            if (max < e) max = e\\n        }\\n        return max\\n    }\\n\\n    // Kotlin 1.4 function\\n    private inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int {\\n        var sum: Int = 0.toInt()\\n        for (element in this) {\\n            sum += selector(element)\\n        }\\n        return sum\\n    }\\n\\n    fun maximumScore(scores: IntArray, edges: Array<IntArray>): Int {\\n        val adjacentMap = edges.flatMap {\\n                listOf(\\n                    it[0] to it[1],\\n                    it[1] to it[0]\\n                )\\n            }.groupBy { it.first }\\n            .mapValues { entry -> entry.value.map { it.second } }\\n            .mapValues { entry ->\\n                entry.value.sortedByDescending { scores[it] }.take(3)\\n            }\\n        return edges.flatMap { e ->\\n            val leftNeighbor = adjacentMap[e[0]] ?: listOf()\\n            val rightNeighbor = adjacentMap[e[1]] ?: listOf()\\n            leftNeighbor.flatMap { left ->\\n                rightNeighbor.mapNotNull { right ->\\n                    val nodeSet = setOf(left, e[0], e[1], right)\\n                    if (nodeSet.size == 4) {\\n                        nodeSet.sumOf { scores[it] }\\n                    } else null\\n                }\\n            }\\n        }.maxOrNull() ?: -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002431,
                "title": "java-straightforward-easy-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int maximumScore(int[] scores, int[][] edges) {\\n\\t\\n\\t    // store only top 3 nodes (having highest scores)\\n        int[][] graph = new int[scores.length][3];\\n        for(int[] a: graph) Arrays.fill(a, -1);\\n        \\n        for(int[] edge: edges) {\\n            insert(edge[0], graph[edge[1]], scores);\\n            insert(edge[1], graph[edge[0]], scores);\\n        }\\n\\n        int maxScore = -1;\\n        for(int[] edge: edges) {\\n            int u = edge[0], v = edge[1];\\n            int score = scores[u] + scores[v];\\n            \\n            for(int i=0; i<3; i++) {\\n\\t\\t\\t    // if neighbour is current node, skip\\n                if(graph[u][i] == -1 || graph[u][i] == v) continue;\\n                \\n                for(int j=0; j<3; j++) {\\n\\t\\t\\t\\t    // if neighbour is current node or already choosen node, skip\\n                    if(graph[v][j] == -1 || graph[v][j] == u) continue;\\n                    if(graph[v][j] == graph[u][i]) continue;\\n                    \\n                    maxScore = Math.max(maxScore, score + scores[graph[u][i]] + scores[graph[v][j]]);\\n                }\\n            }\\n        }\\n        \\n        return maxScore;\\n    }\\n    \\n    private void insert(int n, int[] arr, int[] scores) {\\n        if(arr[0] == -1) {\\n            arr[0] = n;\\n        }\\n        else if(arr[1] == -1) {\\n            if(scores[arr[0]] < scores[n]) {\\n                arr[1] = arr[0];\\n                arr[0] = n;\\n            }\\n            else {\\n                arr[1] = n;\\n            }\\n        }\\n        else if(arr[2] == -1) {\\n            if(scores[arr[0]] < scores[n]) {\\n                arr[2] = arr[1];\\n                arr[1] = arr[0];\\n                arr[0] = n;\\n            }\\n            else if(scores[arr[1]] < scores[n]) {\\n                arr[2] = arr[1];\\n                arr[1] = n;\\n            }\\n            else {\\n                arr[2] = n;\\n            }\\n        }\\n        else {\\n            if(scores[arr[0]] < scores[n]) {\\n                arr[2] = arr[1];\\n                arr[1] = arr[0];\\n                arr[0] = n;\\n            }\\n            else if(scores[arr[1]] < scores[n]) {\\n                arr[2] = arr[1];\\n                arr[1] = n;\\n            }\\n            else if(scores[arr[2]] < scores[n]) {\\n                arr[2] = n;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumScore(int[] scores, int[][] edges) {\\n\\t\\n\\t    // store only top 3 nodes (having highest scores)\\n        int[][] graph = new int[scores.length][3];\\n        for(int[] a: graph) Arrays.fill(a, -1);\\n        \\n        for(int[] edge: edges) {\\n            insert(edge[0], graph[edge[1]], scores);\\n            insert(edge[1], graph[edge[0]], scores);\\n        }\\n\\n        int maxScore = -1;\\n        for(int[] edge: edges) {\\n            int u = edge[0], v = edge[1];\\n            int score = scores[u] + scores[v];\\n            \\n            for(int i=0; i<3; i++) {\\n\\t\\t\\t    // if neighbour is current node, skip\\n                if(graph[u][i] == -1 || graph[u][i] == v) continue;\\n                \\n                for(int j=0; j<3; j++) {\\n\\t\\t\\t\\t    // if neighbour is current node or already choosen node, skip\\n                    if(graph[v][j] == -1 || graph[v][j] == u) continue;\\n                    if(graph[v][j] == graph[u][i]) continue;\\n                    \\n                    maxScore = Math.max(maxScore, score + scores[graph[u][i]] + scores[graph[v][j]]);\\n                }\\n            }\\n        }\\n        \\n        return maxScore;\\n    }\\n    \\n    private void insert(int n, int[] arr, int[] scores) {\\n        if(arr[0] == -1) {\\n            arr[0] = n;\\n        }\\n        else if(arr[1] == -1) {\\n            if(scores[arr[0]] < scores[n]) {\\n                arr[1] = arr[0];\\n                arr[0] = n;\\n            }\\n            else {\\n                arr[1] = n;\\n            }\\n        }\\n        else if(arr[2] == -1) {\\n            if(scores[arr[0]] < scores[n]) {\\n                arr[2] = arr[1];\\n                arr[1] = arr[0];\\n                arr[0] = n;\\n            }\\n            else if(scores[arr[1]] < scores[n]) {\\n                arr[2] = arr[1];\\n                arr[1] = n;\\n            }\\n            else {\\n                arr[2] = n;\\n            }\\n        }\\n        else {\\n            if(scores[arr[0]] < scores[n]) {\\n                arr[2] = arr[1];\\n                arr[1] = arr[0];\\n                arr[0] = n;\\n            }\\n            else if(scores[arr[1]] < scores[n]) {\\n                arr[2] = arr[1];\\n                arr[1] = n;\\n            }\\n            else if(scores[arr[2]] < scores[n]) {\\n                arr[2] = n;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979283,
                "title": "c-expand-each-pair-by-storing-3-neighbor",
                "content": "// Time complexity O(E)\\n```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        unordered_map<int, set<pair<int, int>>> graph; // insert time is still O(1) because edge size is bounded to 3\\n        \\n        for (vector<int> &eachE : edges) {\\n            graph[eachE[0]].emplace(scores[eachE[1]], eachE[1]);\\n            if (graph[eachE[0]].size() == 4) {\\n                graph[eachE[0]].erase(graph[eachE[0]].begin());\\n            }\\n            graph[eachE[1]].emplace(scores[eachE[0]], eachE[0]);\\n            if (graph[eachE[1]].size() == 4) {\\n                graph[eachE[1]].erase(graph[eachE[1]].begin());\\n            }\\n        }\\n        \\n        int res = -1;\\n        for (vector<int> &eachE : edges) {\\n            auto it0 = graph[eachE[0]].rbegin();\\n            auto it1 = graph[eachE[1]].rbegin();\\n            auto end0 = graph[eachE[0]].rend();\\n            auto end1 = graph[eachE[1]].rend();\\n            \\n            if (it0->second == eachE[1]) it0++;\\n            if (it1->second == eachE[0]) it1++;\\n            \\n            while (it0->second == it1->second) {\\n                auto nextIt0 = next(it0);\\n                auto nextIt1 = next(it1);\\n\\n                while (nextIt0 != end0 && nextIt0->second == eachE[1]) {\\n                    nextIt0++;\\n                }\\n\\n                while (nextIt1 != end1 && nextIt1->second == eachE[0]) {\\n                    nextIt1++;\\n                }\\n\\n                if (nextIt0 == end0 && nextIt1 == end1) {\\n                    it0 = end0;\\n                    it1 = end1;\\n                    break;\\n                }\\n                \\n                if (nextIt0 == end0) {\\n                    it1 = nextIt1;\\n                } else if (nextIt1 == end1) {\\n                    it0 = nextIt0;\\n                } else {\\n                    if (nextIt0->first > nextIt1->first) {\\n                        it0 = nextIt0;\\n                    } else {\\n                        it1 = nextIt1;\\n                    }\\n                }\\n            }\\n            if (it0 != end0 && it1 != end1) {\\n                res = max(res, scores[eachE[0]] + scores[eachE[1]] + it0->first + it1->first);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        unordered_map<int, set<pair<int, int>>> graph; // insert time is still O(1) because edge size is bounded to 3\\n        \\n        for (vector<int> &eachE : edges) {\\n            graph[eachE[0]].emplace(scores[eachE[1]], eachE[1]);\\n            if (graph[eachE[0]].size() == 4) {\\n                graph[eachE[0]].erase(graph[eachE[0]].begin());\\n            }\\n            graph[eachE[1]].emplace(scores[eachE[0]], eachE[0]);\\n            if (graph[eachE[1]].size() == 4) {\\n                graph[eachE[1]].erase(graph[eachE[1]].begin());\\n            }\\n        }\\n        \\n        int res = -1;\\n        for (vector<int> &eachE : edges) {\\n            auto it0 = graph[eachE[0]].rbegin();\\n            auto it1 = graph[eachE[1]].rbegin();\\n            auto end0 = graph[eachE[0]].rend();\\n            auto end1 = graph[eachE[1]].rend();\\n            \\n            if (it0->second == eachE[1]) it0++;\\n            if (it1->second == eachE[0]) it1++;\\n            \\n            while (it0->second == it1->second) {\\n                auto nextIt0 = next(it0);\\n                auto nextIt1 = next(it1);\\n\\n                while (nextIt0 != end0 && nextIt0->second == eachE[1]) {\\n                    nextIt0++;\\n                }\\n\\n                while (nextIt1 != end1 && nextIt1->second == eachE[0]) {\\n                    nextIt1++;\\n                }\\n\\n                if (nextIt0 == end0 && nextIt1 == end1) {\\n                    it0 = end0;\\n                    it1 = end1;\\n                    break;\\n                }\\n                \\n                if (nextIt0 == end0) {\\n                    it1 = nextIt1;\\n                } else if (nextIt1 == end1) {\\n                    it0 = nextIt0;\\n                } else {\\n                    if (nextIt0->first > nextIt1->first) {\\n                        it0 = nextIt0;\\n                    } else {\\n                        it1 = nextIt1;\\n                    }\\n                }\\n            }\\n            if (it0 != end0 && it1 != end1) {\\n                res = max(res, scores[eachE[0]] + scores[eachE[1]] + it0->first + it1->first);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967776,
                "title": "compute-top-3-neighbors-using-multimap-then-combine",
                "content": "### Compute top-3 neighbors using multimap, then combine\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        const int n = scores.size();\\n        vector<vector<int>> adj(n); // adjacency list\\n        // creating the adjacency list\\n        for (const auto& e : edges) {\\n            adj[e[0]].emplace_back(e[1]);\\n            adj[e[1]].emplace_back(e[0]);\\n        }\\n        // a multimap from score to node-id, i.e. map<Score-->NodeID>\\n        using TopScoreMap = multimap<int, int, greater<>>;\\n        // Get the top-3 high-score neighbors for each node u\\n        vector<TopScoreMap> scoreMaps(n);\\n        for (int u = 0; u < n; ++u) {\\n            scoreMaps[u] = findTopKNeighbors(3, adj, scores, u);\\n        }\\n\\n        int currMax = -1;\\n        // for each edge e(u->v) in the edges,\\n        // combine the top3 neighbors of u with those of v, to get the max score\\n        // centered at edge e(u-->v).\\n        // even in the worst case, there will be a valid triplet of edges (quadruplet of nodes)\\n        for (const auto& e : edges) {\\n            const auto u = e[0], v = e[1];\\n            const int coreScore = scores[u] + scores[v];\\n            // since the two top3 multimaps each contain at most 3 elements, this nested loop has at\\n            // most 9 iterations.\\n            for (auto [xScore, xNode] : scoreMaps[u]) {\\n                for (auto [yScore, yNode] : scoreMaps[v]) {\\n                    if (xNode == yNode || xNode == v || yNode == u) {\\n                        continue;\\n                    }\\n                    currMax = max(currMax, coreScore + xScore + yScore);\\n                }\\n            }\\n        }\\n\\n        return currMax;\\n    }\\n\\nprivate:\\n    static inline multimap<int, int, greater<>> findTopKNeighbors(\\n            const int k, // k as in top-k\\n            const vector<vector<int>>& adj,\\n            const vector<int>& scores,\\n            const int centralNode) {\\n        multimap<int, int, greater<>> topUNeighbors; // map from score to node-id\\n        for (auto x : adj[centralNode]) { // x is centralNode\\'s neighbor\\n            if (topUNeighbors.size() < k) {\\n                topUNeighbors.emplace(scores[x], x);\\n            } else {\\n                if (topUNeighbors.rbegin()->first < scores[x]) {\\n                    topUNeighbors.emplace(scores[x], x);\\n                    // remove the candidate with the lowest score,\\n                    // so that the map\\'s size remains being k.\\n                    topUNeighbors.erase(prev(topUNeighbors.end()));\\n                }\\n            }\\n        }\\n        return topUNeighbors;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        const int n = scores.size();\\n        vector<vector<int>> adj(n); // adjacency list\\n        // creating the adjacency list\\n        for (const auto& e : edges) {\\n            adj[e[0]].emplace_back(e[1]);\\n            adj[e[1]].emplace_back(e[0]);\\n        }\\n        // a multimap from score to node-id, i.e. map<Score-->NodeID>\\n        using TopScoreMap = multimap<int, int, greater<>>;\\n        // Get the top-3 high-score neighbors for each node u\\n        vector<TopScoreMap> scoreMaps(n);\\n        for (int u = 0; u < n; ++u) {\\n            scoreMaps[u] = findTopKNeighbors(3, adj, scores, u);\\n        }\\n\\n        int currMax = -1;\\n        // for each edge e(u->v) in the edges,\\n        // combine the top3 neighbors of u with those of v, to get the max score\\n        // centered at edge e(u-->v).\\n        // even in the worst case, there will be a valid triplet of edges (quadruplet of nodes)\\n        for (const auto& e : edges) {\\n            const auto u = e[0], v = e[1];\\n            const int coreScore = scores[u] + scores[v];\\n            // since the two top3 multimaps each contain at most 3 elements, this nested loop has at\\n            // most 9 iterations.\\n            for (auto [xScore, xNode] : scoreMaps[u]) {\\n                for (auto [yScore, yNode] : scoreMaps[v]) {\\n                    if (xNode == yNode || xNode == v || yNode == u) {\\n                        continue;\\n                    }\\n                    currMax = max(currMax, coreScore + xScore + yScore);\\n                }\\n            }\\n        }\\n\\n        return currMax;\\n    }\\n\\nprivate:\\n    static inline multimap<int, int, greater<>> findTopKNeighbors(\\n            const int k, // k as in top-k\\n            const vector<vector<int>>& adj,\\n            const vector<int>& scores,\\n            const int centralNode) {\\n        multimap<int, int, greater<>> topUNeighbors; // map from score to node-id\\n        for (auto x : adj[centralNode]) { // x is centralNode\\'s neighbor\\n            if (topUNeighbors.size() < k) {\\n                topUNeighbors.emplace(scores[x], x);\\n            } else {\\n                if (topUNeighbors.rbegin()->first < scores[x]) {\\n                    topUNeighbors.emplace(scores[x], x);\\n                    // remove the candidate with the lowest score,\\n                    // so that the map\\'s size remains being k.\\n                    topUNeighbors.erase(prev(topUNeighbors.end()));\\n                }\\n            }\\n        }\\n        return topUNeighbors;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963971,
                "title": "can-anyone-please-tell-me-where-am-i-going-wrong",
                "content": "I am iteratively going to each node and travering to a length of 4 from each node to each possible path of length 4. The method is good and it runs perfectly except it gives TLE, so I applied dp into it. there is something wrong with how I am applying dp.\\n\\n```\\nclass Solution {\\n    \\n    int dfs(vector<int> &scr, vector<vector<int>> &adj, int ver, int d, set<int> st, int &ans, int cs, vector<vector<int>> &dp){\\n        if(d==0){\\n            ans=max(ans,cs);\\n            dp[ver][d]=cs;\\n            return cs;\\n        }\\n        \\n        if(dp[ver][d]!=-1) return dp[ver][d];\\n        \\n        int score=-1;\\n        \\n        for(auto v:adj[ver]){\\n            if(!st.count(v)){\\n                st.insert(v);\\n                score = max(dfs(scr, adj, v, d-1, st, ans, cs+scr[v], dp),score);\\n                st.erase(v);\\n            }\\n        }\\n        \\n        dp[ver][d]=score;\\n        \\n        return dp[ver][d];\\n    }\\n    \\npublic:\\n    int maximumScore(vector<int>& scr, vector<vector<int>>& edg){\\n        int ans=-1;\\n        vector<vector<int>> adj(scr.size());\\n        for(int i=0; i<edg.size(); i++){\\n            adj[edg[i][0]].push_back(edg[i][1]);\\n            adj[edg[i][1]].push_back(edg[i][0]);\\n        }\\n        vector<vector<int>> dp(scr.size(), vector<int> (4,-1));\\n        for(int i=0; i<scr.size(); i++){\\n            set<int> st;\\n            st.insert(i);\\n            dp[i][3]=max(dfs(scr,adj,i,3,st,ans,scr[i],dp),dp[i][3]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int dfs(vector<int> &scr, vector<vector<int>> &adj, int ver, int d, set<int> st, int &ans, int cs, vector<vector<int>> &dp){\\n        if(d==0){\\n            ans=max(ans,cs);\\n            dp[ver][d]=cs;\\n            return cs;\\n        }\\n        \\n        if(dp[ver][d]!=-1) return dp[ver][d];\\n        \\n        int score=-1;\\n        \\n        for(auto v:adj[ver]){\\n            if(!st.count(v)){\\n                st.insert(v);\\n                score = max(dfs(scr, adj, v, d-1, st, ans, cs+scr[v], dp),score);\\n                st.erase(v);\\n            }\\n        }\\n        \\n        dp[ver][d]=score;\\n        \\n        return dp[ver][d];\\n    }\\n    \\npublic:\\n    int maximumScore(vector<int>& scr, vector<vector<int>>& edg){\\n        int ans=-1;\\n        vector<vector<int>> adj(scr.size());\\n        for(int i=0; i<edg.size(); i++){\\n            adj[edg[i][0]].push_back(edg[i][1]);\\n            adj[edg[i][1]].push_back(edg[i][0]);\\n        }\\n        vector<vector<int>> dp(scr.size(), vector<int> (4,-1));\\n        for(int i=0; i<scr.size(); i++){\\n            set<int> st;\\n            st.insert(i);\\n            dp[i][3]=max(dfs(scr,adj,i,3,st,ans,scr[i],dp),dp[i][3]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963379,
                "title": "can-someone-tell-me-what-s-wrong-with-my-code",
                "content": "```\\nclass Solution {\\n    public static int dfs(List<List<Integer>> li,int curr,int[] len,int[] scores,Set<Integer> set,boolean[] b){\\n        len[0]++;\\n        set.add(curr);\\n        int point=scores[curr];\\n         if(len[0]==4){\\n            return point;\\n        }\\n        int temp=0;\\n        \\n        for(int i=0;i<li.get(curr).size();i++){\\n            if(!set.contains(li.get(curr).get(i))){\\n                int t=point+dfs(li,li.get(curr).get(i),len,scores,set,b);\\n                temp=Math.max(temp,t);\\n                if(len[0]==4){\\n            temp=Math.max(temp,t);                \\n                    b[0]=true;                   \\n                }     \\n               len[0]--;    \\n        }\\n\\n        }\\n       return b[0]==true?temp:0;\\n    }\\n    public int maximumScore(int[] scores, int[][] edges) {\\n      \\n        List<List<Integer>> li =new ArrayList<>();\\n        for(int i=0;i<scores.length;i++){\\n            li.add(new ArrayList<>());\\n\\t\\t}                                                                          /*Creating Adjacency List*/           \\n        for(int[] i:edges){\\n            li.get(i[0]).add(i[1]);\\n            li.get(i[1]).add(i[0]);\\n        }\\n        int max=-1;\\n        for(int i=0;i<li.size();i++){\\n            max=Math.max(max,dfs(li,i,new int[]{0},scores,new HashSet<Integer>(),new boolean[]{false}));              /*Dfs on every node*/\\n        }\\n        System.out.print(li);\\n        return max==0?-1:max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static int dfs(List<List<Integer>> li,int curr,int[] len,int[] scores,Set<Integer> set,boolean[] b){\\n        len[0]++;\\n        set.add(curr);\\n        int point=scores[curr];\\n         if(len[0]==4){\\n            return point;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1962315,
                "title": "java-solution-straightforward",
                "content": "```\\nclass Solution {\\n    class Node {\\n        int i;\\n        int val;\\n        List<Node> next = new ArrayList<>();\\n\\n        Node(int i, int val) {\\n            this.i = i;\\n            this.val = val;\\n        }\\n\\t\\t// sort the adjacent nodes score\\n        void sortNext() {\\n            Collections.sort(next, (a, b) -> a.val - b.val);\\n        }\\n\\t\\t// get the max score between 2 nodes, the 4 nodes should be a, b, anext, bnext without duplication\\n        static int max(Node a, Node b) {\\n            int max = -1;\\n            for (int i = a.next.size() - 1; i >= 0; i--) {\\n                Node anext = a.next.get(i);\\n                if (anext.i == b.i) continue;\\n                for (int j = b.next.size() - 1; j >= 0; j--) {\\n                    Node bnext = b.next.get(j);\\n                    if (bnext.i == a.i || anext.i == bnext.i) continue;\\n                    int max0 = anext.val + bnext.val + a.val + b.val;\\n                    if (max0 > max) max = max0;\\n                    else break; // the next score will be smaller, so break\\n                }\\n            }\\n            return max;\\n        }\\n    }\\n\\n\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        Map<Integer, Node> map = new HashMap<>();\\n        for (int i = 0; i < scores.length; i++) map.put(i, new Node(i, scores[i]));\\n        for (int[] e : edges) {\\n            map.get(e[0]).next.add(map.get(e[1]));\\n            map.get(e[1]).next.add(map.get(e[0]));\\n        }\\n        for (Node node : map.values()) node.sortNext();\\n        int max = -1;\\n        for (int[] e : edges)\\n            max = Math.max(max, Node.max(map.get(e[0]), map.get(e[1])));\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Node {\\n        int i;\\n        int val;\\n        List<Node> next = new ArrayList<>();\\n\\n        Node(int i, int val) {\\n            this.i = i;\\n            this.val = val;\\n        }\\n\\t\\t// sort the adjacent nodes score\\n        void sortNext() {\\n            Collections.sort(next, (a, b) -> a.val - b.val);\\n        }\\n\\t\\t// get the max score between 2 nodes, the 4 nodes should be a, b, anext, bnext without duplication\\n        static int max(Node a, Node b) {\\n            int max = -1;\\n            for (int i = a.next.size() - 1; i >= 0; i--) {\\n                Node anext = a.next.get(i);\\n                if (anext.i == b.i) continue;\\n                for (int j = b.next.size() - 1; j >= 0; j--) {\\n                    Node bnext = b.next.get(j);\\n                    if (bnext.i == a.i || anext.i == bnext.i) continue;\\n                    int max0 = anext.val + bnext.val + a.val + b.val;\\n                    if (max0 > max) max = max0;\\n                    else break; // the next score will be smaller, so break\\n                }\\n            }\\n            return max;\\n        }\\n    }\\n\\n\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        Map<Integer, Node> map = new HashMap<>();\\n        for (int i = 0; i < scores.length; i++) map.put(i, new Node(i, scores[i]));\\n        for (int[] e : edges) {\\n            map.get(e[0]).next.add(map.get(e[1]));\\n            map.get(e[1]).next.add(map.get(e[0]));\\n        }\\n        for (Node node : map.values()) node.sortNext();\\n        int max = -1;\\n        for (int[] e : edges)\\n            max = Math.max(max, Node.max(map.get(e[0]), map.get(e[1])));\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960947,
                "title": "c-three-biggest-neighbors",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) \\n    {\\n        int n=scores.size();\\n        vector<vector<pair<int,int>>>G(n);\\n        for(auto &x:edges)\\n        {\\n            G[x[0]].push_back({scores[x[1]],x[1]});\\n            G[x[1]].push_back({scores[x[0]],x[0]});\\n        }\\n        for(int i=0;i<n;i++)\\n            sort(G[i].begin(),G[i].end(),greater<pair<int,int>>());\\n        int ans=-1;\\n        for(auto &x:edges)\\n        {\\n            int left=x[0],right=x[1];\\n            int cur=scores[left]+scores[right];\\n            int sz1=G[left].size(),sz2=G[right].size();\\n            for(int i=0;i<min(3,sz1);i++)\\n                for(int j=0;j<min(3,sz2);j++)\\n                {\\n                    if(G[left][i].second==left||G[left][i].second==right||G[left][i].second==G[right][j].second)\\n                        continue;\\n                    if(G[right][j].second==left||G[right][j].second==right||G[right][j].second==G[left][i].second)\\n                        continue;\\n                    ans=max(ans,cur+G[left][i].first+G[right][j].first);\\n                }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) \\n    {\\n        int n=scores.size();\\n        vector<vector<pair<int,int>>>G(n);\\n        for(auto &x:edges)\\n        {\\n            G[x[0]].push_back({scores[x[1]],x[1]});\\n            G[x[1]].push_back({scores[x[0]],x[0]});\\n        }\\n        for(int i=0;i<n;i++)\\n            sort(G[i].begin(),G[i].end(),greater<pair<int,int>>());\\n        int ans=-1;\\n        for(auto &x:edges)\\n        {\\n            int left=x[0],right=x[1];\\n            int cur=scores[left]+scores[right];\\n            int sz1=G[left].size(),sz2=G[right].size();\\n            for(int i=0;i<min(3,sz1);i++)\\n                for(int j=0;j<min(3,sz2);j++)\\n                {\\n                    if(G[left][i].second==left||G[left][i].second==right||G[left][i].second==G[right][j].second)\\n                        continue;\\n                    if(G[right][j].second==left||G[right][j].second==right||G[right][j].second==G[left][i].second)\\n                        continue;\\n                    ans=max(ans,cur+G[left][i].first+G[right][j].first);\\n                }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960317,
                "title": "cpp-simple-easy-understandable-solution-with-hint",
                "content": "Hint:- you want to find a 4 length nodes whose sum is largest\\n\\nsomething like (node1 <----> node2 <----> node3 <----> node4)\\nif you carefully observe there are three edges between those 4 nodes. Then just fixed the middle edge.\\n\\nlogic:- create the adjacency vector\\nsort the vector according to their scores\\nnow traverse the edges assuming that will be a middle edge of the solution \\n\\n```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        unordered_map<int, vector<pair<int, int>>> graph;\\n        \\n        for(auto&it: edges){\\n            graph[it[0]].push_back({scores[it[1]], it[1]});\\n            graph[it[1]].push_back({scores[it[0]], it[0]});\\n        }\\n        \\n        for(auto&it: graph){\\n            sort(it.second.begin(), it.second.end());\\n        }\\n        \\n        int ans = -1;\\n        \\n        for(auto&it: edges){\\n            \\n            int tans = scores[it[0]] + scores[it[1]];\\n            int a = graph[it[0]].size();\\n            auto&it0 = graph[it[0]];\\n            auto&it1 = graph[it[1]];\\n            int b = graph[it[1]].size();\\n            \\n            if(it0[a-1].second == it[1]) a--;\\n            if(it1[b-1].second == it[0]) b--;\\n            if(a == 0 || b == 0) continue;\\n            \\n            else if(it0[a-1].second != it1[b-1].second){\\n                tans += it0[a-1].first + it1[b-1].first;\\n                ans = max(ans, tans);\\n            }\\n            else{\\n                if(a-2 >= 0 && it0[a-2].second != it[1]){\\n                    ans = max(ans, tans + it0[a-2].first + it1[b-1].first);\\n                }\\n                if(b-2 >= 0 && it1[b-2].second != it[0]){\\n                    ans = max(ans, tans + it0[a-1].first + it1[b-2].first);\\n                }\\n                if(a-3 >= 0 && it0[a-3].second != it[1]){\\n                    ans = max(ans, tans + it0[a-3].first + it1[b-1].first);\\n                }\\n                if(b-3 >= 0 && it1[b-3].second != it[0]){\\n                    ans = max(ans, tans + it0[a-1].first + it1[b-3].first);\\n                }\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        unordered_map<int, vector<pair<int, int>>> graph;\\n        \\n        for(auto&it: edges){\\n            graph[it[0]].push_back({scores[it[1]], it[1]});\\n            graph[it[1]].push_back({scores[it[0]], it[0]});\\n        }\\n        \\n        for(auto&it: graph){\\n            sort(it.second.begin(), it.second.end());\\n        }\\n        \\n        int ans = -1;\\n        \\n        for(auto&it: edges){\\n            \\n            int tans = scores[it[0]] + scores[it[1]];\\n            int a = graph[it[0]].size();\\n            auto&it0 = graph[it[0]];\\n            auto&it1 = graph[it[1]];\\n            int b = graph[it[1]].size();\\n            \\n            if(it0[a-1].second == it[1]) a--;\\n            if(it1[b-1].second == it[0]) b--;\\n            if(a == 0 || b == 0) continue;\\n            \\n            else if(it0[a-1].second != it1[b-1].second){\\n                tans += it0[a-1].first + it1[b-1].first;\\n                ans = max(ans, tans);\\n            }\\n            else{\\n                if(a-2 >= 0 && it0[a-2].second != it[1]){\\n                    ans = max(ans, tans + it0[a-2].first + it1[b-1].first);\\n                }\\n                if(b-2 >= 0 && it1[b-2].second != it[0]){\\n                    ans = max(ans, tans + it0[a-1].first + it1[b-2].first);\\n                }\\n                if(a-3 >= 0 && it0[a-3].second != it[1]){\\n                    ans = max(ans, tans + it0[a-3].first + it1[b-1].first);\\n                }\\n                if(b-3 >= 0 && it1[b-3].second != it[0]){\\n                    ans = max(ans, tans + it0[a-1].first + it1[b-3].first);\\n                }\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958473,
                "title": "c-top-3-highest-nodes-with-set-beats-100",
                "content": "**Why top 3 neighbours?**\\nWe will get 2 nodes by traversing the edges, say **n1** & **n2**. \\n\\nTwo edges remain. Let\\'s choose the 3rd edge from **n1** which has the highest score. But, it could be the same edge of **n1** & **n2**. According to the ques, we have to skip this, and the 2nd highest would require. Let\\'s assume we have chosen the 2nd highest edge **n1** & **c1**. \\n\\nOne edge remains. Let\\'s choose the 4th edge from **n2** which has the highest score. But, it could be either of **n1** & **n2** or **n2** & **c1**  or both. If both of the two edges are the top 2 highest from **n2**, we have to skip this two and the 3rd highest would require. Let\\'s assume we have chosen the 3rd highest edge **n2** & **c2**. \\n\\nWe have chosen all the 4 edges. Hence, maximum of 3rd highest would be required and we would never require the 4th highest.\\n\\nResult = scores[n1] + scores[n2] + scores[c1] + scores[c2]\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n=scores.size();\\n        set<pair<int, int>> pq[n]; //first = weight, second = nodeId\\n        for(auto&v: edges) { //O(E * 2 * log4)\\n            int n1=v[0];\\n            int n2=v[1];\\n            pq[n1].insert({scores[n2], n2}); //O(log 4)\\n            pq[n2].insert({scores[n1], n1}); //O(log 4)\\n            if(pq[n1].size()==4) {\\n\\t\\t\\t\\t//ignoring lowest node from front\\n\\t\\t\\t\\t//so that time complexity would be O(log 4)\\n               pq[n1].erase(pq[n1].begin());\\n            }\\n            if(pq[n2].size()==4) {\\n\\t\\t\\t\\t//ignoring lowest node from front\\n\\t\\t\\t\\t//so that time complexity would be O(log 4)\\n                pq[n2].erase(pq[n2].begin());\\n            }\\n        }\\n\\n        int maxRes=-1;\\n        for(auto& v: edges) { //O(9 E)\\n            int n1=v[0];\\n            int n2=v[1];\\n            int dscore=scores[n1]+scores[n2];\\n            for(auto& c1: pq[n1]) { //O(9)\\n                if(c1.second==n2) {\\n                    continue;\\n                }\\n                for(auto& c2: pq[n2]) { //O(3)\\n                    if(c2.second==c1.second || c2.second==n1) {\\n                        continue;\\n                    }\\n                    maxRes=max(maxRes, dscore+c1.first+c2.first);\\n                }\\n            }\\n        }\\n        return maxRes;\\n    }\\n};\\n```\\n\\n\\n**Time Complexity:** O(E * 2 * log4 + 9 * E) \\u2248 O(E), where E is the number of Edges\\n**Space Complexity:** O(4 * E) \\u2248 O(E),  where E is the number of Edges",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n=scores.size();\\n        set<pair<int, int>> pq[n]; //first = weight, second = nodeId\\n        for(auto&v: edges) { //O(E * 2 * log4)\\n            int n1=v[0];\\n            int n2=v[1];\\n            pq[n1].insert({scores[n2], n2}); //O(log 4)\\n            pq[n2].insert({scores[n1], n1}); //O(log 4)\\n            if(pq[n1].size()==4) {\\n\\t\\t\\t\\t//ignoring lowest node from front\\n\\t\\t\\t\\t//so that time complexity would be O(log 4)\\n               pq[n1].erase(pq[n1].begin());\\n            }\\n            if(pq[n2].size()==4) {\\n\\t\\t\\t\\t//ignoring lowest node from front\\n\\t\\t\\t\\t//so that time complexity would be O(log 4)\\n                pq[n2].erase(pq[n2].begin());\\n            }\\n        }\\n\\n        int maxRes=-1;\\n        for(auto& v: edges) { //O(9 E)\\n            int n1=v[0];\\n            int n2=v[1];\\n            int dscore=scores[n1]+scores[n2];\\n            for(auto& c1: pq[n1]) { //O(9)\\n                if(c1.second==n2) {\\n                    continue;\\n                }\\n                for(auto& c2: pq[n2]) { //O(3)\\n                    if(c2.second==c1.second || c2.second==n1) {\\n                        continue;\\n                    }\\n                    maxRes=max(maxRes, dscore+c1.first+c2.first);\\n                }\\n            }\\n        }\\n        return maxRes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957706,
                "title": "c-2242-maximum-score-of-a-node-sequence",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n = scores.size(); \\n        vector<vector<int>> graph(n); \\n        for (auto& edge : edges) {\\n            graph[edge[0]].push_back(edge[1]); \\n            graph[edge[1]].push_back(edge[0]); \\n        }\\n        for (auto& node : graph) sort(node.begin(), node.end(), [&](auto& lhs, auto& rhs) {return scores[lhs] > scores[rhs];}); \\n        int ans = -1; \\n        for (auto& edge : edges) {\\n            int u = edge[0], v = edge[1]; \\n            for (int i = 0; i < min(3, (int)graph[u].size()); ++i) \\n                for (int j = 0; j < min(3, (int)graph[v].size()); ++j) \\n                    if (graph[u][i] != v && graph[v][j] != u && graph[u][i] != graph[v][j]) \\n                        ans = max(ans, scores[u] + scores[v] + scores[graph[u][i]] + scores[graph[v][j]]); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n = scores.size(); \\n        vector<vector<int>> graph(n); \\n        for (auto& edge : edges) {\\n            graph[edge[0]].push_back(edge[1]); \\n            graph[edge[1]].push_back(edge[0]); \\n        }\\n        for (auto& node : graph) sort(node.begin(), node.end(), [&](auto& lhs, auto& rhs) {return scores[lhs] > scores[rhs];}); \\n        int ans = -1; \\n        for (auto& edge : edges) {\\n            int u = edge[0], v = edge[1]; \\n            for (int i = 0; i < min(3, (int)graph[u].size()); ++i) \\n                for (int j = 0; j < min(3, (int)graph[v].size()); ++j) \\n                    if (graph[u][i] != v && graph[v][j] != u && graph[u][i] != graph[v][j]) \\n                        ans = max(ans, scores[u] + scores[v] + scores[graph[u][i]] + scores[graph[v][j]]); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957262,
                "title": "o-n-m-iterate-over-edges-faster-than-100-store-top-3-for-all-nodes",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int u, int v, int U, int V){\\n        if(u==v || u==U || u==V || v==U || v==V || U == V) return false;\\n        if(u==-1 || v==-1) return false;        \\n        return true;\\n    }\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n = scores.size();\\n        vector<vector<int>> adj(n);\\n        \\n        for(vector<int> edge:edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        vector<vector<int>> maxForAll(n, vector<int>(3, -1));\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            vector<int> &maxU = maxForAll[i]; // maxU[0] - firstMax, maxU[1] - secondMax, maxV[2] - thirdMax\\n            \\n            for(int neighU:adj[i]){                \\n                \\n                if(maxU[0] == -1) {\\n                    maxU[0] = neighU;\\n                } else if(scores[maxU[0]] <= scores[neighU]) {\\n                    maxU[2] = maxU[1];\\n                    maxU[1] = maxU[0];\\n                    maxU[0] = neighU;\\n                } else if(maxU[1] == -1){\\n                    maxU[1] = neighU;\\n                } else if(scores[maxU[1]] <= scores[neighU]){\\n                    maxU[2] = maxU[1];\\n                    maxU[1] = neighU;\\n                } else if(maxU[2] == -1 || scores[maxU[2]] <= scores[neighU]){\\n                    maxU[2] = neighU;\\n                }                 \\n            }\\n                      \\n        }\\n        \\n        int answer = -1;\\n        \\n        for(vector<int> edge:edges){\\n            int u = edge[0];\\n            int v = edge[1];                        \\n            \\n            for(int i=0;i<3;i++){\\n                for(int j=0;j<3;j++){\\n                    if(isPossible(maxForAll[u][i], maxForAll[v][j], u, v)) {\\n                        answer = max(scores[maxForAll[u][i]] + scores[maxForAll[v][j]] + scores[u] + scores[v], answer);\\n                    }        \\n                }\\n            }\\n                        \\n            \\n        }\\n        \\n        return answer;\\n    }\\n};\\n\\n\\n// A----\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int u, int v, int U, int V){\\n        if(u==v || u==U || u==V || v==U || v==V || U == V) return false;\\n        if(u==-1 || v==-1) return false;        \\n        return true;\\n    }\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n = scores.size();\\n        vector<vector<int>> adj(n);\\n        \\n        for(vector<int> edge:edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        vector<vector<int>> maxForAll(n, vector<int>(3, -1));\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            vector<int> &maxU = maxForAll[i]; // maxU[0] - firstMax, maxU[1] - secondMax, maxV[2] - thirdMax\\n            \\n            for(int neighU:adj[i]){                \\n                \\n                if(maxU[0] == -1) {\\n                    maxU[0] = neighU;\\n                } else if(scores[maxU[0]] <= scores[neighU]) {\\n                    maxU[2] = maxU[1];\\n                    maxU[1] = maxU[0];\\n                    maxU[0] = neighU;\\n                } else if(maxU[1] == -1){\\n                    maxU[1] = neighU;\\n                } else if(scores[maxU[1]] <= scores[neighU]){\\n                    maxU[2] = maxU[1];\\n                    maxU[1] = neighU;\\n                } else if(maxU[2] == -1 || scores[maxU[2]] <= scores[neighU]){\\n                    maxU[2] = neighU;\\n                }                 \\n            }\\n                      \\n        }\\n        \\n        int answer = -1;\\n        \\n        for(vector<int> edge:edges){\\n            int u = edge[0];\\n            int v = edge[1];                        \\n            \\n            for(int i=0;i<3;i++){\\n                for(int j=0;j<3;j++){\\n                    if(isPossible(maxForAll[u][i], maxForAll[v][j], u, v)) {\\n                        answer = max(scores[maxForAll[u][i]] + scores[maxForAll[v][j]] + scores[u] + scores[v], answer);\\n                    }        \\n                }\\n            }\\n                        \\n            \\n        }\\n        \\n        return answer;\\n    }\\n};\\n\\n\\n// A----\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956834,
                "title": "python-3-1833-ms-100-faster-clear-explanation-top-neighbours-approach",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        \\n        # the idea is to take every edge in edges\\n        # this adge has 2 Nodes (left, right), \\n        # the sequence should have 4 Nodes, so, we need 2 Nodes more\\n        # if we add one Node to left Node and one Node to right Node \\n        # then we will have sequence of 4 Nodes\\n        # Every Node (linked to edges left and right ) we will get from pre_prepared neighbours set \\n        \\n        size = len(scores)\\n        \\n        # create neighbours list for every Node\\n        # node_idx: [list of neighbours: (neighbour_score, neighbour_idx)]\\n        nbrs = [[] for idx in range(size)]\\n\\n        # populate neighbours list\\n        for node_a, node_b in edges:\\n            nbrs[node_a].append((scores[node_b], node_b))\\n            nbrs[node_b].append((scores[node_a], node_a))\\n        \\n        # for every node we need just 3 greatest neighbours \\n        # as by the rules we make sequence of just 4 Nodes\\n        for node_i in range(size):\\n            nbrs[node_i].sort(reverse=True)\\n            nbrs[node_i] = nbrs[node_i][:3]\\n            # nbrs[node_i] = sorted(nbrs[node_i], reverse=True)[:3]\\n        \\n        # nbrs = [sorted(nbrs[node_i], reverse=True)[:3] for node_i in range(size)]\\n        \\n        # print(nbrs)\\n        #  0: [(9, 2), (2, 1)],          node 0 linked with 1 and 2 with scores: 2, 9\\n        #  1: [(9, 2), (8, 3), (5, 0)], \\n        #  2: [(8, 3), (5, 0), (4, 4)] ...  \\n        \\n        # for every edge in edges\\n        # we add to this edge at left and at right one node from neighbours list\\n        # and check max sum of scores\\n        \\n        max_score = -1  # -math.inf\\n        \\n        for node_a, node_b in edges:\\n            sum_a_b = scores[node_a] + scores[node_b]\\n            \\n            for score_a_l, node_a_l in nbrs[node_a]:\\n                \\n                if node_a_l != node_b:\\n                    for score_b_r, node_b_r in nbrs[node_b]:\\n                        \\n                        if node_a_l != node_b_r != node_a:\\n                            # sum_score = score_a_l + sum_a_b + score_b_r\\n                            # max_score = max(max_score, sum_score)\\n                            max_score = max(max_score, score_a_l + sum_a_b + score_b_r)\\n                            break\\n                            \\n        return max_score\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        \\n        # the idea is to take every edge in edges\\n        # this adge has 2 Nodes (left, right), \\n        # the sequence should have 4 Nodes, so, we need 2 Nodes more\\n        # if we add one Node to left Node and one Node to right Node \\n        # then we will have sequence of 4 Nodes\\n        # Every Node (linked to edges left and right ) we will get from pre_prepared neighbours set \\n        \\n        size = len(scores)\\n        \\n        # create neighbours list for every Node\\n        # node_idx: [list of neighbours: (neighbour_score, neighbour_idx)]\\n        nbrs = [[] for idx in range(size)]\\n\\n        # populate neighbours list\\n        for node_a, node_b in edges:\\n            nbrs[node_a].append((scores[node_b], node_b))\\n            nbrs[node_b].append((scores[node_a], node_a))\\n        \\n        # for every node we need just 3 greatest neighbours \\n        # as by the rules we make sequence of just 4 Nodes\\n        for node_i in range(size):\\n            nbrs[node_i].sort(reverse=True)\\n            nbrs[node_i] = nbrs[node_i][:3]\\n            # nbrs[node_i] = sorted(nbrs[node_i], reverse=True)[:3]\\n        \\n        # nbrs = [sorted(nbrs[node_i], reverse=True)[:3] for node_i in range(size)]\\n        \\n        # print(nbrs)\\n        #  0: [(9, 2), (2, 1)],          node 0 linked with 1 and 2 with scores: 2, 9\\n        #  1: [(9, 2), (8, 3), (5, 0)], \\n        #  2: [(8, 3), (5, 0), (4, 4)] ...  \\n        \\n        # for every edge in edges\\n        # we add to this edge at left and at right one node from neighbours list\\n        # and check max sum of scores\\n        \\n        max_score = -1  # -math.inf\\n        \\n        for node_a, node_b in edges:\\n            sum_a_b = scores[node_a] + scores[node_b]\\n            \\n            for score_a_l, node_a_l in nbrs[node_a]:\\n                \\n                if node_a_l != node_b:\\n                    for score_b_r, node_b_r in nbrs[node_b]:\\n                        \\n                        if node_a_l != node_b_r != node_a:\\n                            # sum_score = score_a_l + sum_a_b + score_b_r\\n                            # max_score = max(max_score, sum_score)\\n                            max_score = max(max_score, score_a_l + sum_a_b + score_b_r)\\n                            break\\n                            \\n        return max_score\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1956803,
                "title": "swift-simple-solution-by-sorting-and-keeping-top-3-neighbours",
                "content": "```\\nclass Solution {\\n    func maximumScore(_ scores: [Int], _ edges: [[Int]]) -> Int {\\n        let n = scores.count\\n        var map = Array(repeating: [Int](), count: n)\\n        \\n        for e in edges {\\n            map[e[0]].append(e[1])  \\n            map[e[1]].append(e[0])            \\n        }\\n        \\n        for i in 0..<n { \\n            var arr = map[i].sorted(by: {\\n                scores[$0] > scores[$1]\\n            })\\n            if arr.count > 3 {\\n                arr = Array(arr[0..<3])\\n            }\\n            map[i] = arr\\n        }\\n        \\n        var ans = -1\\n        for e in edges {\\n            let a = e[0]\\n            let b = e[1]\\n            for x in map[a] {\\n                for y in map[b] {\\n                    if x != y, x != b, y != a, ans < scores[a] + scores[b] + scores[x] + scores[y] {\\n                        ans = scores[a] + scores[b] + scores[x] + scores[y]\\n                    }\\n                }\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    func maximumScore(_ scores: [Int], _ edges: [[Int]]) -> Int {\\n        let n = scores.count\\n        var map = Array(repeating: [Int](), count: n)\\n        \\n        for e in edges {\\n            map[e[0]].append(e[1])  \\n            map[e[1]].append(e[0])            \\n        }\\n        \\n        for i in 0..<n { \\n            var arr = map[i].sorted(by: {\\n                scores[$0] > scores[$1]\\n            })\\n            if arr.count > 3 {\\n                arr = Array(arr[0..<3])\\n            }\\n            map[i] = arr\\n        }\\n        \\n        var ans = -1\\n        for e in edges {\\n            let a = e[0]\\n            let b = e[1]\\n            for x in map[a] {\\n                for y in map[b] {\\n                    if x != y, x != b, y != a, ans < scores[a] + scores[b] + scores[x] + scores[y] {\\n                        ans = scores[a] + scores[b] + scores[x] + scores[y]\\n                    }\\n                }\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956798,
                "title": "python-solution-with-explaination",
                "content": "## Approach\\nThe approach goes like this for every edge`[a,b]` in `edges` we update the `neighbour`  dictionary with the score of the adjacent node and its value. Now we travel thru the\\ndictionary to get the score of a sequence and update max score if len of seq is 4.\\n\\nIn the iteration we don\\'t need all the neighbours just the top 3 with the highest score. That is why we sort the `neighbour` dictionary in reverse order of scores.\\n\\n```\\ndef maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        neighbour = collections.defaultdict(list)\\n        for a, b in edges :\\n            neighbour[a].append([scores[b], b])\\n            neighbour[b].append([scores[a], a])\\n        for k in neighbour :\\n            neighbour[k] = sorted(neighbour[k], reverse=True)\\n        \\n        to_ret = -1\\n        for a, b in edges :\\n            for s1, p1 in neighbour[a][:3] :\\n                for s2, p2 in neighbour[b][:3] :\\n                    if not len(set([a, b, p1, p2])) == 4 :\\n                        continue\\n                    to_ret = max(to_ret, s1+s2+scores[a]+scores[b])\\n        return to_ret\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\ndef maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\\n        neighbour = collections.defaultdict(list)\\n        for a, b in edges :\\n            neighbour[a].append([scores[b], b])\\n            neighbour[b].append([scores[a], a])\\n        for k in neighbour :\\n            neighbour[k] = sorted(neighbour[k], reverse=True)\\n        \\n        to_ret = -1\\n        for a, b in edges :\\n            for s1, p1 in neighbour[a][:3] :\\n                for s2, p2 in neighbour[b][:3] :\\n                    if not len(set([a, b, p1, p2])) == 4 :\\n                        continue\\n                    to_ret = max(to_ret, s1+s2+scores[a]+scores[b])\\n        return to_ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1956676,
                "title": "c-solution",
                "content": "DFS is the intuitive idea if we want to find the 4 nodes that are connected in sequence, and we can iterate each node and get the max value. But DFS will give TLE for sure. \\n\\nAlternatively, to make it easier, we can get the 2 nodes first, and expand the 2 nodes to 4 nodes. The edge of 2 nodes are already provided, so for the rest 2 nodes, we just look at these 2 nodes\\' neighbours. It could be both nodes\\' neighbours, if they both have 2 distinctive neighbouring nodes. If not, we can look at either one node, and see if it has 2 consecutive nodes. \\n\\n* First we build the graph (2D vector) based on the edges \\n* Then we need to sort each node\\'s connected neighbours in descending order since we want the biggest value \\n* Next we iterate each edge from edges, and examine whether we can form a 4-nodes sequence from the 2 nodes on each edge. \\n* We keep track of the max total res in the iteration. \\n\\n```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        \\n        const int n = scores.size();\\n        \\n        vector<vector<int>> graph(n);\\n        for (auto &edge : edges)\\n        {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        for (auto &vec : graph)\\n        {\\n            std::sort(vec.begin(), vec.end(), [&](int a, int b) {\\n                return scores[a] > scores[b];\\n            });\\n        }\\n        \\n        int res = -1;\\n        \\n        for (auto &edge : edges)\\n        {\\n            int x = edge[0], y = edge[1];\\n            vector<int> c1, c2;\\n            \\n            vector<int> &v1 = graph[x];\\n            vector<int> &v2 = graph[y];\\n            \\n            for (int i = 0; i < v1.size() && c1.size() < 2; ++i)\\n            {\\n                if (v1[i] != y)\\n                    c1.push_back(v1[i]);\\n            }\\n            \\n            for (int i = 0; i < v2.size() && c2.size() < 2; ++i)\\n            {\\n                if (v2[i] != x)\\n                    c2.push_back(v2[i]);\\n            }\\n            \\n            if (c1.empty() || c2.empty())   continue;\\n            \\n            int s = scores[x] + scores[y];\\n            \\n            if (c1[0] != c2[0])\\n                res = std::max(res, s + scores[c1[0]] + scores[c2[0]]);\\n            else\\n            {\\n                if (c1.size() > 1)\\n                    res = std::max(res, s + scores[c1[0]] + scores[c1[1]]);\\n                \\n                if (c2.size() > 1)\\n                    res = std::max(res, s + scores[c2[0]] + scores[c2[1]]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        \\n        const int n = scores.size();\\n        \\n        vector<vector<int>> graph(n);\\n        for (auto &edge : edges)\\n        {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        for (auto &vec : graph)\\n        {\\n            std::sort(vec.begin(), vec.end(), [&](int a, int b) {\\n                return scores[a] > scores[b];\\n            });\\n        }\\n        \\n        int res = -1;\\n        \\n        for (auto &edge : edges)\\n        {\\n            int x = edge[0], y = edge[1];\\n            vector<int> c1, c2;\\n            \\n            vector<int> &v1 = graph[x];\\n            vector<int> &v2 = graph[y];\\n            \\n            for (int i = 0; i < v1.size() && c1.size() < 2; ++i)\\n            {\\n                if (v1[i] != y)\\n                    c1.push_back(v1[i]);\\n            }\\n            \\n            for (int i = 0; i < v2.size() && c2.size() < 2; ++i)\\n            {\\n                if (v2[i] != x)\\n                    c2.push_back(v2[i]);\\n            }\\n            \\n            if (c1.empty() || c2.empty())   continue;\\n            \\n            int s = scores[x] + scores[y];\\n            \\n            if (c1[0] != c2[0])\\n                res = std::max(res, s + scores[c1[0]] + scores[c2[0]]);\\n            else\\n            {\\n                if (c1.size() > 1)\\n                    res = std::max(res, s + scores[c1[0]] + scores[c1[1]]);\\n                \\n                if (c2.size() > 1)\\n                    res = std::max(res, s + scores[c2[0]] + scores[c2[1]]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955470,
                "title": "traverse-edges-instead-of-nodes",
                "content": "Traverse all the edges, and remeber three biggest neghbors of each node,\\n\\n\\n```\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        Map<Integer,PriorityQueue<int[]>> map = new HashMap<>();\\n        long ans = -1;\\n        for(int[] e: edges){\\n            map.computeIfAbsent(e[0], q->new PriorityQueue<>((x,y)->x[0]-y[0])).add(new int[]{scores[e[1]], e[1]});\\n            map.computeIfAbsent(e[1], q->new PriorityQueue<>((x,y)->x[0]-y[0])).add(new int[]{scores[e[0]], e[0]});\\n            if(map.get(e[0]).size() > 3) map.get(e[0]).poll();\\n            if(map.get(e[1]).size() > 3) map.get(e[1]).poll();\\n        }\\n        for(int[] e: edges){\\n            long current = scores[e[0]] + scores[e[1]];\\n            long next = getNext(map, e[0], e[1]);\\n            if(next == -1) continue;\\n            if(current + next > Integer.MAX_VALUE) continue;\\n            ans = Math.max(ans, current + next);\\n        }\\n        return (int)ans;\\n    }\\n    public long getNext(Map<Integer,PriorityQueue<int[]>> map, int i, int j){\\n        PriorityQueue<int[]> iNext = new PriorityQueue<>(map.getOrDefault(i, new PriorityQueue<>()));\\n        PriorityQueue<int[]> jNext = new PriorityQueue<>(map.getOrDefault(j, new PriorityQueue<>()));\\n       // remove the connection of i, j\\n       List<int[]> list1 = new ArrayList<>();\\n        while(iNext.size() > 0){\\n            int[] cur = iNext.poll();\\n            if(cur[1]==j) continue;\\n            list1.add(0,cur);\\n        }\\n\\n        List<int[]> list2 = new ArrayList<>();\\n        while(jNext.size()>0){\\n            int[] cur = jNext.poll();\\n            if(cur[1]==i) continue;\\n            list2.add(0,cur);\\n        }\\n        if(list1.size()==0 || list2.size()==0) return -1;\\n        // 1 1 / 1 2/ 2 1/ 2 2\\n\\t\\t// i j may connect to same node \\n        if(list1.get(0)[1] != list2.get(0)[1]) return list1.get(0)[0] + list2.get(0)[0];\\n        if(list1.size()==1 && list2.size()==1) return -1;\\n        if(list1.size()==2 && list2.size()==2){\\n            return Math.max((long)list1.get(0)[0] + list2.get(1)[0], (long)list1.get(1)[0] + list2.get(0)[0]);\\n        }\\n        if(list2.size()==2) return (long)list1.get(0)[0] + list2.get(1)[0];\\n        return (long)list1.get(1)[0] + list2.get(0)[0];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        Map<Integer,PriorityQueue<int[]>> map = new HashMap<>();\\n        long ans = -1;\\n        for(int[] e: edges){\\n            map.computeIfAbsent(e[0], q->new PriorityQueue<>((x,y)->x[0]-y[0])).add(new int[]{scores[e[1]], e[1]});\\n            map.computeIfAbsent(e[1], q->new PriorityQueue<>((x,y)->x[0]-y[0])).add(new int[]{scores[e[0]], e[0]});\\n            if(map.get(e[0]).size() > 3) map.get(e[0]).poll();\\n            if(map.get(e[1]).size() > 3) map.get(e[1]).poll();\\n        }\\n        for(int[] e: edges){\\n            long current = scores[e[0]] + scores[e[1]];\\n            long next = getNext(map, e[0], e[1]);\\n            if(next == -1) continue;\\n            if(current + next > Integer.MAX_VALUE) continue;\\n            ans = Math.max(ans, current + next);\\n        }\\n        return (int)ans;\\n    }\\n    public long getNext(Map<Integer,PriorityQueue<int[]>> map, int i, int j){\\n        PriorityQueue<int[]> iNext = new PriorityQueue<>(map.getOrDefault(i, new PriorityQueue<>()));\\n        PriorityQueue<int[]> jNext = new PriorityQueue<>(map.getOrDefault(j, new PriorityQueue<>()));\\n       // remove the connection of i, j\\n       List<int[]> list1 = new ArrayList<>();\\n        while(iNext.size() > 0){\\n            int[] cur = iNext.poll();\\n            if(cur[1]==j) continue;\\n            list1.add(0,cur);\\n        }\\n\\n        List<int[]> list2 = new ArrayList<>();\\n        while(jNext.size()>0){\\n            int[] cur = jNext.poll();\\n            if(cur[1]==i) continue;\\n            list2.add(0,cur);\\n        }\\n        if(list1.size()==0 || list2.size()==0) return -1;\\n        // 1 1 / 1 2/ 2 1/ 2 2\\n\\t\\t// i j may connect to same node \\n        if(list1.get(0)[1] != list2.get(0)[1]) return list1.get(0)[0] + list2.get(0)[0];\\n        if(list1.size()==1 && list2.size()==1) return -1;\\n        if(list1.size()==2 && list2.size()==2){\\n            return Math.max((long)list1.get(0)[0] + list2.get(1)[0], (long)list1.get(1)[0] + list2.get(0)[0]);\\n        }\\n        if(list2.size()==2) return (long)list1.get(0)[0] + list2.get(1)[0];\\n        return (long)list1.get(1)[0] + list2.get(0)[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955116,
                "title": "4-possible-ideas-detailed-analysis",
                "content": "(1) First possible solution is brute force using Depth first search approach to find \\n    maximum  sum  of 4 adjacent nodes.\\n\\tThis approach gives TLE .\\n\\n``` \\nclass Solution {\\n    vector<bool>visited;\\n    int ans=-1;\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n=scores.size();\\n        vector<int>g[n];\\n        for(auto i:edges){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        for(int i=0;i<n;i++)visited.push_back(0);\\n        for(int i=0;i<n;i++)dfs(g,0,i,0,scores);\\n        return ans;\\n    }\\n    void dfs(vector<int>g[],int c,int n,int sum,vector<int>&scores){\\n        if(c==4){\\n            ans=max(ans,sum);\\n                return;\\n        }\\n        if(visited[n])return;\\n        visited[n]=1;\\n        for(int i:g[n]){\\n            dfs(g,c+1,i,sum+scores[n],scores);\\n        }\\n        visited[n]=0;\\n    }\\n}; \\n\\n ```\\n \\n(2) 4 adjacent nodes of a graph are  required of maximum score, here we are provided with the edge list having two nodes each. Consider these two nodes as the middle two nodes of the 4 adjacent nodes that are required. Now we require two nodes, to get maximum Score . Hence for each node, make an adjaceny list (GRAPH) ,containing a node of maximum score. \\n\\tA <--> **B** <--> **C**<--> D\\nnow A node can be equivalent to C node   and B node can be equivalent to  D node.\\nSo to overcome from the situation that nodes should not be repeated in 4 adjacent nodes that are required , we insert 2 more  nodes of maximum score.\\nnow we traverse the edge list, and consider scores of two nodes of edges list and the maximum score of nodes linked to these two  nodes of edge list. It must be ensured that no overlapping of nodes occurs.\\n```\\n\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int ans=-1;\\n        vector<int>g[scores.size()];\\n        for(auto &i:edges){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        for(auto &i: g) \\n            sort(i.begin(),i.end(),[&](int a,int b){return scores[a]>scores[b];});\\n        for(auto &i:edges){\\n            for(int m=0;m<3&&m<g[i[0]].size();m++){\\n                \\n                if(i[1]==g[i[0]][m])continue;\\n                \\n                for(int n=0;n<3&&n<g[i[1]].size();n++){\\n                    \\n                    if(i[0]==g[i[1]][n])continue;\\n                    \\n                    if(g[i[0]][m]==g[i[1]][n])continue;\\n                    \\n                    ans=max(ans,scores[i[0]]+scores[i[1]]+scores[g[i[1]][n]]+scores[g[i[0]][m]]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n(3) How approach 2 can be optimized? \\n we can use priority queue, to get three nodes of maximum score and store them in \\n adjacency list, This will reduce the space complexity by inserting only three nodes for each\\n in the adjacency list, irrespective of inserting all the connected nodes.\\n \\n (4) Approach 2 can be further optimized by  replacing sorting with linear time complexity.\\n      make an adjaceny list of size of number of nodes in graph as column and the row of 3 size.\\n\\t  example :\\n\\t  int g[scores.size()][3];\\nThe idea is to Find the nodes of maximum score and store them in graph in linear time.\\nIt is similar to finding maximum 1 element in the array or maximum 2 elements in the array\\n, we can even find maximum 3 elements in the array.\\nExample algorithm\\n\\n1) Initialize the largest three elements as minus infinite.\\n    first = second = third = -\\u221E\\n\\n2) Iterate through all elements of array.\\n   a) Let current array element be x.\\n   b) If (x > first)\\n      {\\n          // This order of assignment is important\\n          third = second\\n          second = first\\n          first = x   \\n       }\\n   c)  Else if (x > second)\\n      {\\n          third = second\\n          second = x \\n      }\\n   d)  Else if (x > third)\\n      {\\n          third = x  \\n      }\\n\\n3) Print first, second and third.",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "``` \\nclass Solution {\\n    vector<bool>visited;\\n    int ans=-1;\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n=scores.size();\\n        vector<int>g[n];\\n        for(auto i:edges){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        for(int i=0;i<n;i++)visited.push_back(0);\\n        for(int i=0;i<n;i++)dfs(g,0,i,0,scores);\\n        return ans;\\n    }\\n    void dfs(vector<int>g[],int c,int n,int sum,vector<int>&scores){\\n        if(c==4){\\n            ans=max(ans,sum);\\n                return;\\n        }\\n        if(visited[n])return;\\n        visited[n]=1;\\n        for(int i:g[n]){\\n            dfs(g,c+1,i,sum+scores[n],scores);\\n        }\\n        visited[n]=0;\\n    }\\n}; \\n\\n ```\n```\\n\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int ans=-1;\\n        vector<int>g[scores.size()];\\n        for(auto &i:edges){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        for(auto &i: g) \\n            sort(i.begin(),i.end(),[&](int a,int b){return scores[a]>scores[b];});\\n        for(auto &i:edges){\\n            for(int m=0;m<3&&m<g[i[0]].size();m++){\\n                \\n                if(i[1]==g[i[0]][m])continue;\\n                \\n                for(int n=0;n<3&&n<g[i[1]].size();n++){\\n                    \\n                    if(i[0]==g[i[1]][n])continue;\\n                    \\n                    if(g[i[0]][m]==g[i[1]][n])continue;\\n                    \\n                    ans=max(ans,scores[i[0]]+scores[i[1]]+scores[g[i[1]][n]]+scores[g[i[0]][m]]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954989,
                "title": "c-100-efficiency-100-space-complexity-as-simple-as-i-can-make-it",
                "content": "\\nI did cheat a little with the hints. In my opinion the means to optimize it is quite clever before I looked it up my answer would time out.\\n\\nThe premise is that you traverse along the edge set of your undirected graph.\\n\\nAt each edge (which consists of two connected points) you run a for loop through all points connected to them and take the max sum of the scores of these four points that you get.\\n\\nThe Oprimization (which I didnt figure out on my own) is that you need only search the top three scores connecected to the adjacent nodes of the edge on each side..\\n\\nSo three timess three is at most nine cases to look up for each edge. Not tknowing this my algorithm did terribly and I did not get past test case 51.\\n\\nWith this modification however runtime become constant in terms of the size of the edge space. That is if the edge space is of complexity n the runtime will be of complexity 9n,\\n\\nSo the set up is as follows:\\n\\nYou make a double vector that holds you edge set, Call it G.\\n\\nFor each node i  G[i] stores ALL the nodes connected to node i.\\n\\nThne what you wish to do is sort each G[i] in terms of the scores. That is sort the nodes of G[i] in decreasing order in relation to the values of their original scores.  There is a very clever method to do this efficiently with the built in sort function. \\n\\nAfter you have G[i] sorted appropriately you can make your search for each edge e with say edges a and b\\n\\n\\nYou run a double for loop through the top three verticies of G[a] and G[b] which makes at most nine cases and take the maximum result.\\n\\nSo this is it. I didnt get it on my onw however ^_^.    Thank You !!! =]\\n\\n```\\nvector<int> S;\\n\\nclass Solution {\\npublic:\\n  \\n    vector<vector<int>> G;\\n    \\n    //vector<bool> B;\\n        \\n    \\n    static bool Compare(int &P1, int &P2)\\n    {\\n        return(S[P1]>S[P2]);\\n    }\\n    \\n    void EdgeS(vector<int> E, int &ret, vector<bool> &H)\\n    {\\n        \\n        int cret=S[E[0]]+S[E[1]];\\n        H[E[0]]=true;\\n        H[E[1]]=true;\\n        int add=-1, lv=-1;\\n        int v;\\n        for(int i=0;i<G[E[0]].size()&&i<3;i++)\\n        {\\n            v=G[E[0]][i];\\n            if(S[v]>add && !H[v])\\n            {\\n                lv=v;\\n                add=S[v];\\n            }\\n        }\\n        \\n        if(add==-1) return;\\n        cret+=add;\\n        H[lv]=true;\\n        \\n        add=-1;\\n        lv=-1;\\n        \\n        for(int i=0;i<G[E[1]].size()&&i<3;i++)\\n        {\\n            v=G[E[1]][i];\\n            if(S[v]>add && !H[v])\\n            {\\n                lv=v;\\n                add=S[v];\\n            }\\n        }\\n        \\n        if(add==-1) return;\\n        cret+=add;\\n        H[lv]=true;\\n        \\n        ret=max(ret,cret);\\n        \\n        \\n        \\n    }\\n\\t\\n    \\n    \\n    int maximumScore(vector<int>& S1, vector<vector<int>>& E) {\\n        \\n        S=S1;\\n        int n=S.size();\\n        vector<vector<int>> G1(n);\\n        \\n        for(auto v:E)\\n        {\\n            G1[v[0]].push_back(v[1]);\\n            G1[v[1]].push_back(v[0]);\\n        }\\n        G=G1;\\n        \\n        for(int i=0;i<n;i++) sort(G[i].begin(),G[i].end(),Compare);\\n        int ret=-1;\\n        \\n        vector<bool> H1(n,false),H;\\n        \\n        \\n            \\n        H=H1;\\n        \\n        vector<int> e={0,0};\\n        \\n        for(auto e1:E)\\n        {\\n            H=H1;\\n            e[0]=e1[0];\\n            e[1]=e1[1];\\n            EdgeS(e, ret, H);\\n            H=H1;\\n            e[1]=e1[0];\\n            e[0]=e1[1];\\n            EdgeS(e, ret, H);\\n            //DFS(i,1,H,ret,0);\\n           // B[i]=true;\\n        }\\n        \\n        ///for(int i=0;i<n;i++) ret=max(ret,FindAt(i,n));\\n        //cout<<FindAt(1,n);\\n        \\n        return(ret);\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Array",
                    "Graph"
                ],
                "code": "```\\nvector<int> S;\\n\\nclass Solution {\\npublic:\\n  \\n    vector<vector<int>> G;\\n    \\n    //vector<bool> B;\\n        \\n    \\n    static bool Compare(int &P1, int &P2)\\n    {\\n        return(S[P1]>S[P2]);\\n    }\\n    \\n    void EdgeS(vector<int> E, int &ret, vector<bool> &H)\\n    {\\n        \\n        int cret=S[E[0]]+S[E[1]];\\n        H[E[0]]=true;\\n        H[E[1]]=true;\\n        int add=-1, lv=-1;\\n        int v;\\n        for(int i=0;i<G[E[0]].size()&&i<3;i++)\\n        {\\n            v=G[E[0]][i];\\n            if(S[v]>add && !H[v])\\n            {\\n                lv=v;\\n                add=S[v];\\n            }\\n        }\\n        \\n        if(add==-1) return;\\n        cret+=add;\\n        H[lv]=true;\\n        \\n        add=-1;\\n        lv=-1;\\n        \\n        for(int i=0;i<G[E[1]].size()&&i<3;i++)\\n        {\\n            v=G[E[1]][i];\\n            if(S[v]>add && !H[v])\\n            {\\n                lv=v;\\n                add=S[v];\\n            }\\n        }\\n        \\n        if(add==-1) return;\\n        cret+=add;\\n        H[lv]=true;\\n        \\n        ret=max(ret,cret);\\n        \\n        \\n        \\n    }\\n\\t\\n    \\n    \\n    int maximumScore(vector<int>& S1, vector<vector<int>>& E) {\\n        \\n        S=S1;\\n        int n=S.size();\\n        vector<vector<int>> G1(n);\\n        \\n        for(auto v:E)\\n        {\\n            G1[v[0]].push_back(v[1]);\\n            G1[v[1]].push_back(v[0]);\\n        }\\n        G=G1;\\n        \\n        for(int i=0;i<n;i++) sort(G[i].begin(),G[i].end(),Compare);\\n        int ret=-1;\\n        \\n        vector<bool> H1(n,false),H;\\n        \\n        \\n            \\n        H=H1;\\n        \\n        vector<int> e={0,0};\\n        \\n        for(auto e1:E)\\n        {\\n            H=H1;\\n            e[0]=e1[0];\\n            e[1]=e1[1];\\n            EdgeS(e, ret, H);\\n            H=H1;\\n            e[1]=e1[0];\\n            e[0]=e1[1];\\n            EdgeS(e, ret, H);\\n            //DFS(i,1,H,ret,0);\\n           // B[i]=true;\\n        }\\n        \\n        ///for(int i=0;i<n;i++) ret=max(ret,FindAt(i,n));\\n        //cout<<FindAt(1,n);\\n        \\n        return(ret);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1954851,
                "title": "java-top-3-neighbours",
                "content": "The idea is to iterate through all edges v---w and add the best possible pair of neighbours nv and nw to obtain the most valuable path of 4 nodes ( nv --- v --- w --- nw ). \\nIn order to add nv and nw we only need to keep 3 top valued neighbours for each node e.g. for \\'w\\' we would like to choose the highest valued node \\'nw\\', but we need to make sure that \\'nw\\' is neither \\'v\\' nor \\'nv\\', so in the worst case we need to pick the 3-rd highest valued node.\\nAs the list of neighbours we need to track is short, we use a version of insertion sort below to keep track of up to top 3 sorted neighbours only for each node (and represent the adjacency list as array, for fast performance).\\n```\\n\\tpublic int maximumScore(int[] scores, int[][] edges) {\\n        int n= scores.length;\\n        int[][] al= new int[n][3]; // edges to top 3 value nodes\\n        for(int[] top3:al) Arrays.fill(top3, -1);\\n        for(int[] e:edges){\\n            int v= e[0], w= e[1];\\n            insert(al[v], scores, w);\\n            insert(al[w], scores, v);\\n        }\\n        int ans= -1;\\n        for(int[] e:edges){\\n            int v= e[0], w= e[1], scoreVW= scores[v]+scores[w];\\n            for(int nv:al[v]){\\n                if(nv==-1) break;\\n                if(nv==w) continue;\\n                for(int nw:al[w]){\\n                    if(nw==-1) break;\\n                    if(nw==v || nw==nv) continue;\\n                    ans= Math.max(ans, scores[nv]+scoreVW+scores[nw]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n    void insert(int[] top3, int[] s, int v){\\n        if(top3[0]==-1 || s[v]>s[top3[0]]){\\n            top3[2]= top3[1]; top3[1]= top3[0]; top3[0]= v;\\n        }else if(top3[1]==-1 || s[v]>s[top3[1]]){\\n            top3[2]= top3[1]; top3[1]= v; \\n        }else if(top3[2]==-1 ||  s[v]>s[top3[2]]){\\n            top3[2]= v;\\n        }\\n    }\\t",
                "solutionTags": [],
                "code": "The idea is to iterate through all edges v---w and add the best possible pair of neighbours nv and nw to obtain the most valuable path of 4 nodes ( nv --- v --- w --- nw ). \\nIn order to add nv and nw we only need to keep 3 top valued neighbours for each node e.g. for \\'w\\' we would like to choose the highest valued node \\'nw\\', but we need to make sure that \\'nw\\' is neither \\'v\\' nor \\'nv\\', so in the worst case we need to pick the 3-rd highest valued node.\\nAs the list of neighbours we need to track is short, we use a version of insertion sort below to keep track of up to top 3 sorted neighbours only for each node (and represent the adjacency list as array, for fast performance).\\n```\\n\\tpublic int maximumScore(int[] scores, int[][] edges) {\\n        int n= scores.length;\\n        int[][] al= new int[n][3]; // edges to top 3 value nodes\\n        for(int[] top3:al) Arrays.fill(top3, -1);\\n        for(int[] e:edges){\\n            int v= e[0], w= e[1];\\n            insert(al[v], scores, w);\\n            insert(al[w], scores, v);\\n        }\\n        int ans= -1;\\n        for(int[] e:edges){\\n            int v= e[0], w= e[1], scoreVW= scores[v]+scores[w];\\n            for(int nv:al[v]){\\n                if(nv==-1) break;\\n                if(nv==w) continue;\\n                for(int nw:al[w]){\\n                    if(nw==-1) break;\\n                    if(nw==v || nw==nv) continue;\\n                    ans= Math.max(ans, scores[nv]+scoreVW+scores[nw]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n    void insert(int[] top3, int[] s, int v){\\n        if(top3[0]==-1 || s[v]>s[top3[0]]){\\n            top3[2]= top3[1]; top3[1]= top3[0]; top3[0]= v;\\n        }else if(top3[1]==-1 || s[v]>s[top3[1]]){\\n            top3[2]= top3[1]; top3[1]= v; \\n        }else if(top3[2]==-1 ||  s[v]>s[top3[2]]){\\n            top3[2]= v;\\n        }\\n    }\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1954770,
                "title": "need-help-python3",
                "content": "# Can anyone explain me, why?\\n**scores = [16,21,22,2,24,21,12,17,2,24]\\nedges = [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,0]]**\\n\\nwhy this is giving ***83*** , it should be ***61***\\n![image](https://assets.leetcode.com/users/images/894f06c9-f5b7-43c9-9b89-a2de2c61ddf6_1650143878.90271.png)\\n\\n\\nand \\n**scores = [18,6,4,9,8,2]**\\n**edges = [[0,1],[0,2],[0,3],[0,4],[0,5],[1,2],[1,3],[1,4],[1,5],[2,3],[2,4],[2,5],[3,4],[3,5],[4,5]]**\\n\\nis giving ***41***? it should be ***47***\\n![image](https://assets.leetcode.com/users/images/77c44ad0-2fd1-4318-905b-ee5f162ce1b0_1650143850.9942899.png)\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# Can anyone explain me, why?\\n**scores = [16,21,22,2,24,21,12,17,2,24]\\nedges = [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,0]]**\\n\\nwhy this is giving ***83*** , it should be ***61***\\n![image](https://assets.leetcode.com/users/images/894f06c9-f5b7-43c9-9b89-a2de2c61ddf6_1650143878.90271.png)\\n\\n\\nand \\n**scores = [18,6,4,9,8,2]**\\n**edges = [[0,1],[0,2],[0,3],[0,4],[0,5],[1,2],[1,3],[1,4],[1,5],[2,3],[2,4],[2,5],[3,4],[3,5],[4,5]]**\\n\\nis giving ***41***? it should be ***47***\\n![image](https://assets.leetcode.com/users/images/77c44ad0-2fd1-4318-905b-ee5f162ce1b0_1650143850.9942899.png)\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1954636,
                "title": "java-priorityqueue-greedy",
                "content": "Time Complexity: O(E * 9) == O(E) for iterating over edges\\nSpace Complexity: O(E)\\n\\t\\n\\tclass Solution {\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        if (scores == null || scores.length == 0) return -1;\\n        \\n        // use a table to store the 3 biggest neighbors of each node\\n        Map<Integer, PriorityQueue<Integer>> hashmap = new HashMap<>();\\n        for (int[] edge : edges) {\\n            int l = edge[0];\\n            int r = edge[1];\\n            hashmap.putIfAbsent(l, new PriorityQueue<>((a, b) -> scores[a] - scores[b]));\\n            hashmap.putIfAbsent(r, new PriorityQueue<>((a, b) -> scores[a] - scores[b]));\\n            hashmap.get(l).add(r);\\n            hashmap.get(r).add(l);\\n            while (hashmap.get(l).size() > 3) {\\n                hashmap.get(l).poll();\\n            }\\n            while (hashmap.get(r).size() > 3) {\\n                hashmap.get(r).poll();\\n            }\\n        }\\n        \\n        int res = -1;\\n        for (int[] edge : edges) {\\n            int a = edge[0];\\n            int b = edge[1];\\n            // find the 3 biggest neighbor nodes of a\\n            for (int i : hashmap.get(a)) {\\n                // find the 3 biggest neighbor nodes of b\\n                for (int j : hashmap.get(b)) {\\n\\t\\t\\t\\t\\t// here is the reason why we need to store 3 neighbor nodes, rather than 2 nodes\\n                    if (i != b && j != a && i != j) {\\n                        res = Math.max(res, scores[a] + scores[b] + scores[i] + scores[j]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\t}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maximumScore(int[] scores, int[][] edges) {\\n        if (scores == null || scores.length == 0) return -1;\\n        \\n        // use a table to store the 3 biggest neighbors of each node\\n        Map<Integer, PriorityQueue<Integer>> hashmap = new HashMap<>();\\n        for (int[] edge : edges) {\\n            int l = edge[0];\\n            int r = edge[1];\\n            hashmap.putIfAbsent(l, new PriorityQueue<>((a, b) -> scores[a] - scores[b]));\\n            hashmap.putIfAbsent(r, new PriorityQueue<>((a, b) -> scores[a] - scores[b]));\\n            hashmap.get(l).add(r);\\n            hashmap.get(r).add(l);\\n            while (hashmap.get(l).size() > 3) {\\n                hashmap.get(l).poll();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1954482,
                "title": "c-keep-top-3-neighbors-with-highest-value",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        const int num_nodes = scores.size();\\n        std::vector<TopK> node_to_top;\\n        node_to_top.reserve(num_nodes);\\n        for (int node = 0; node < num_nodes; ++node) {\\n            node_to_top.push_back(TopK(node));\\n        }\\n        for (const auto &edge : edges) {\\n            const int u = edge[0], v = edge[1];\\n            node_to_top[u].add(scores[v], v);\\n            node_to_top[v].add(scores[u], u);\\n        }\\n        int max_score = -1;\\n        for (const auto &edge : edges) {\\n            const int u = edge[0], v = edge[1];\\n            int score = scores[u] + scores[v];\\n            if (auto ref = node_to_top[u].max_match(node_to_top[v])) {\\n                max_score = std::max(score + *ref, max_score);\\n            }\\n        }\\n        return max_score;\\n    }\\nprivate:\\n    class TopK {\\n    public:\\n        TopK(const int source): size_(0), source_(source) {            \\n            vals_.fill(0);\\n            inds_.fill(-1);\\n        }\\n        \\n        void add(int val, int idx) {\\n            int i = 0;\\n            for (; i < vals_.size(); ++i) {\\n                if (vals_[i] < val) {\\n                    break;\\n                }\\n            }\\n            for (; i < vals_.size(); ++i) {\\n                std::swap(val, vals_[i]);\\n                std::swap(idx, inds_[i]);\\n            }\\n            size_ = std::min(size_ + 1, vals_.size());\\n        }                   \\n        \\n        std::optional<int> max_match(const TopK &other) const {\\n            std::optional<int> maybe_max_val;\\n            for (int i = 0; i < size_; ++i) {\\n                const int u = inds_[i];\\n                if (u == other.source_) {\\n                    continue;\\n                }\\n                for (int j = 0; j < other.size_; ++j) {\\n                    const int v = other.inds_[j];\\n                    if ((v == source_) || (v == u)) {\\n                        continue;\\n                    }\\n                    maybe_max_val = std::max(vals_[i] + other.vals_[j], maybe_max_val.value_or(0));\\n                }\\n            }\\n            return maybe_max_val;\\n        }\\n        \\n    private:\\n        size_t size_;\\n        int source_;\\n        std::array<int, 4> vals_;\\n        std::array<int, 4> inds_;\\n    };\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        const int num_nodes = scores.size();\\n        std::vector<TopK> node_to_top;\\n        node_to_top.reserve(num_nodes);\\n        for (int node = 0; node < num_nodes; ++node) {\\n            node_to_top.push_back(TopK(node));\\n        }\\n        for (const auto &edge : edges) {\\n            const int u = edge[0], v = edge[1];\\n            node_to_top[u].add(scores[v], v);\\n            node_to_top[v].add(scores[u], u);\\n        }\\n        int max_score = -1;\\n        for (const auto &edge : edges) {\\n            const int u = edge[0], v = edge[1];\\n            int score = scores[u] + scores[v];\\n            if (auto ref = node_to_top[u].max_match(node_to_top[v])) {\\n                max_score = std::max(score + *ref, max_score);\\n            }\\n        }\\n        return max_score;\\n    }\\nprivate:\\n    class TopK {\\n    public:\\n        TopK(const int source): size_(0), source_(source) {            \\n            vals_.fill(0);\\n            inds_.fill(-1);\\n        }\\n        \\n        void add(int val, int idx) {\\n            int i = 0;\\n            for (; i < vals_.size(); ++i) {\\n                if (vals_[i] < val) {\\n                    break;\\n                }\\n            }\\n            for (; i < vals_.size(); ++i) {\\n                std::swap(val, vals_[i]);\\n                std::swap(idx, inds_[i]);\\n            }\\n            size_ = std::min(size_ + 1, vals_.size());\\n        }                   \\n        \\n        std::optional<int> max_match(const TopK &other) const {\\n            std::optional<int> maybe_max_val;\\n            for (int i = 0; i < size_; ++i) {\\n                const int u = inds_[i];\\n                if (u == other.source_) {\\n                    continue;\\n                }\\n                for (int j = 0; j < other.size_; ++j) {\\n                    const int v = other.inds_[j];\\n                    if ((v == source_) || (v == u)) {\\n                        continue;\\n                    }\\n                    maybe_max_val = std::max(vals_[i] + other.vals_[j], maybe_max_val.value_or(0));\\n                }\\n            }\\n            return maybe_max_val;\\n        }\\n        \\n    private:\\n        size_t size_;\\n        int source_;\\n        std::array<int, 4> vals_;\\n        std::array<int, 4> inds_;\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954468,
                "title": "c-solution-using-multimap",
                "content": "```\\nclass Solution {\\n    vector<multimap<int, int>> nei;\\npublic:\\n    \\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        nei.assign(scores.size(), multimap<int, int>());\\n        for(auto& e : edges) {\\n            nei[e[0]].insert(make_pair(scores[e[1]], e[1]));\\n            if(nei[e[0]].size() > 3) nei[e[0]].erase(nei[e[0]].begin());\\n            nei[e[1]].insert(make_pair(scores[e[0]], e[0]));\\n            if(nei[e[1]].size() > 3) nei[e[1]].erase(nei[e[1]].begin());\\n        }\\n        \\n        int res = -1;\\n        for(auto& e : edges) {\\n            int cur = -1;\\n            for(auto& t : nei[e[0]]) {\\n                for(auto& s : nei[e[1]]) {\\n                    if(t.second == e[1] || s.second == e[0] || t.second == s.second) continue;\\n                    cur = max(cur, t.first + s.first);\\n                }\\n            }\\n            if(cur >= 0) res = max(res, cur + scores[e[0]] + scores[e[1]]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<multimap<int, int>> nei;\\npublic:\\n    \\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        nei.assign(scores.size(), multimap<int, int>());\\n        for(auto& e : edges) {\\n            nei[e[0]].insert(make_pair(scores[e[1]], e[1]));\\n            if(nei[e[0]].size() > 3) nei[e[0]].erase(nei[e[0]].begin());\\n            nei[e[1]].insert(make_pair(scores[e[0]], e[0]));\\n            if(nei[e[1]].size() > 3) nei[e[1]].erase(nei[e[1]].begin());\\n        }\\n        \\n        int res = -1;\\n        for(auto& e : edges) {\\n            int cur = -1;\\n            for(auto& t : nei[e[0]]) {\\n                for(auto& s : nei[e[1]]) {\\n                    if(t.second == e[1] || s.second == e[0] || t.second == s.second) continue;\\n                    cur = max(cur, t.first + s.first);\\n                }\\n            }\\n            if(cur >= 0) res = max(res, cur + scores[e[0]] + scores[e[1]]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954447,
                "title": "c-greedy-fix-middle-edge-partial-sort-simple-code",
                "content": "Intuition is same : Fix middle edge and find max score neighbours.\\n**Use partial sort keep the top 3 neighbours.**\\n\\n```\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n = scores.size();\\n        vector<vector<int>> adj(n);\\n        for(auto& e:edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        int result=-1;\\n        \\n        for(auto& v:adj)\\n        {\\n            if(v.size()==0) continue;\\n            int k = min(3,(int)v.size());\\n            nth_element(v.begin(), v.begin() + k - 1, v.end(), [&](int l,int r){ return scores[l]>scores[r];});\\n            v.resize(k);\\n        }\\n        \\n        for(auto& e:edges)\\n        {\\n            int base = scores[e[0]] + scores[e[1]];\\n            for(auto& x: adj[e[0]])\\n            {\\n                if(x== e[1]) continue;\\n                for(auto& y:adj[e[1]])\\n                {\\n                    if(y == e[0] || y == x) continue;\\n                    result = max(result, base + scores[x] + scores[y]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic:\\n    int maximumScore(vector<int>& scores, vector<vector<int>>& edges) {\\n        int n = scores.size();\\n        vector<vector<int>> adj(n);\\n        for(auto& e:edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        int result=-1;\\n        \\n        for(auto& v:adj)\\n        {\\n            if(v.size()==0) continue;\\n            int k = min(3,(int)v.size());\\n            nth_element(v.begin(), v.begin() + k - 1, v.end(), [&](int l,int r){ return scores[l]>scores[r];});\\n            v.resize(k);\\n        }\\n        \\n        for(auto& e:edges)\\n        {\\n            int base = scores[e[0]] + scores[e[1]];\\n            for(auto& x: adj[e[0]])\\n            {\\n                if(x== e[1]) continue;\\n                for(auto& y:adj[e[1]])\\n                {\\n                    if(y == e[0] || y == x) continue;\\n                    result = max(result, base + scores[x] + scores[y]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": []
    },
    {
        "title": "Dynamic Pivoting of a Table",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Total Appeal of A String",
        "question_content": "<p>The <b>appeal</b> of a string is the number of <strong>distinct</strong> characters found in the string.</p>\n\n<ul>\n\t<li>For example, the appeal of <code>&quot;abbca&quot;</code> is <code>3</code> because it has <code>3</code> distinct characters: <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, and <code>&#39;c&#39;</code>.</li>\n</ul>\n\n<p>Given a string <code>s</code>, return <em>the <strong>total appeal of all of its <strong>substrings</strong>.</strong></em></p>\n\n<p>A <strong>substring</strong> is a contiguous sequence of characters within a string.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abbca&quot;\n<strong>Output:</strong> 28\n<strong>Explanation:</strong> The following are the substrings of &quot;abbca&quot;:\n- Substrings of length 1: &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot; have an appeal of 1, 1, 1, 1, and 1 respectively. The sum is 5.\n- Substrings of length 2: &quot;ab&quot;, &quot;bb&quot;, &quot;bc&quot;, &quot;ca&quot; have an appeal of 2, 1, 2, and 2 respectively. The sum is 7.\n- Substrings of length 3: &quot;abb&quot;, &quot;bbc&quot;, &quot;bca&quot; have an appeal of 2, 2, and 3 respectively. The sum is 7.\n- Substrings of length 4: &quot;abbc&quot;, &quot;bbca&quot; have an appeal of 3 and 3 respectively. The sum is 6.\n- Substrings of length 5: &quot;abbca&quot; has an appeal of 3. The sum is 3.\nThe total sum is 5 + 7 + 7 + 6 + 3 = 28.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;code&quot;\n<strong>Output:</strong> 20\n<strong>Explanation:</strong> The following are the substrings of &quot;code&quot;:\n- Substrings of length 1: &quot;c&quot;, &quot;o&quot;, &quot;d&quot;, &quot;e&quot; have an appeal of 1, 1, 1, and 1 respectively. The sum is 4.\n- Substrings of length 2: &quot;co&quot;, &quot;od&quot;, &quot;de&quot; have an appeal of 2, 2, and 2 respectively. The sum is 6.\n- Substrings of length 3: &quot;cod&quot;, &quot;ode&quot; have an appeal of 3 and 3 respectively. The sum is 6.\n- Substrings of length 4: &quot;code&quot; has an appeal of 4. The sum is 4.\nThe total sum is 4 + 6 + 6 + 4 = 20.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1996203,
                "title": "dp",
                "content": "> Note: there is even a simpler [combinatorics solution](https://leetcode.com/problems/total-appeal-of-a-string/discuss/1999226/Combinatorics), proposed by [geekykant](https://leetcode.com/geekykant/).\\n\\nWhat is the appeal of all substrings that end at `i`-th position?\\n- It is the same as the appeal of all substrings that end at `i - 1` position, plus: \\n- number of substrings (ending at `i`-th position) that do not contain `s[i]` character.\\n\\t- to count those substrings, we just track the previous (`prev`) position of `s[i]` character.\\n\\n![image](https://assets.leetcode.com/users/images/96c9f2ad-4378-461a-bcf0-3dd9596765be_1651377614.4588175.png)\\n\\n**C++**\\nSince we initialize `last` with zero, we need to do `+ 1` \\n```cpp\\nlong long appealSum(string s) {\\n    long long res = 0, cur = 0, prev[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        cur += i + 1 - prev[s[i] - \\'a\\'];\\n        prev[s[i] - \\'a\\'] = i + 1;\\n        res += cur;\\n    }\\n    return res;\\n}\\n```\\n**Python 3**\\n```python\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        res, cur, prev = 0, 0, defaultdict(lambda: -1)\\n        for i, ch in enumerate(s):\\n            cur += i - prev[ch]\\n            prev[ch] = i\\n            res += cur\\n        return res  \\n```\\n**Java**\\n```java\\npublic long appealSum(String s) {\\n    long res = 0, cur = 0, prev[] = new long[26];\\n    for (int i = 0; i < s.length(); ++i) {\\n        cur += i + 1 - prev[s.charAt(i) - \\'a\\'];\\n        prev[s.charAt(i) - \\'a\\'] = i + 1;\\n        res += cur;\\n    }    \\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```cpp\\nlong long appealSum(string s) {\\n    long long res = 0, cur = 0, prev[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        cur += i + 1 - prev[s[i] - \\'a\\'];\\n        prev[s[i] - \\'a\\'] = i + 1;\\n        res += cur;\\n    }\\n    return res;\\n}\\n```\n```python\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        res, cur, prev = 0, 0, defaultdict(lambda: -1)\\n        for i, ch in enumerate(s):\\n            cur += i - prev[ch]\\n            prev[ch] = i\\n            res += cur\\n        return res  \\n```\n```java\\npublic long appealSum(String s) {\\n    long res = 0, cur = 0, prev[] = new long[26];\\n    for (int i = 0; i < s.length(); ++i) {\\n        cur += i + 1 - prev[s.charAt(i) - \\'a\\'];\\n        prev[s.charAt(i) - \\'a\\'] = i + 1;\\n        res += cur;\\n    }    \\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996390,
                "title": "java-c-python-easy-and-concise-with-explanation",
                "content": "# **Intuition**\\nQuite similar to [828. Count Unique Characters of All Substrings of a Given String](https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/discuss/128952/).\\nYou can take 828 as an another chanllendge to practice more.\\n<br>\\n\\n# **Explanation**\\nassume we have string xxxaxxxxb..., with s[i] = a and s[j] = b.\\n`s[i]` is th last character `a` before that `b`.\\n\\nWe want to count, how many substring ending at `s[j]` contains character `a`.\\nThey are xxxaxxxxb, xxaxxxxb, xaxxxxb, axxxxb ...., \\n`i + 1` substring ending with character `a` at `s[i]`,\\nso we do `res += i + 1`.\\n\\nWe repeatly do this for every `s[i]` and every one of 26 characters.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(26)`\\n<br>\\n\\n**Java**\\n```java\\n    public long appealSum(String s) {\\n        int last[] = new int[26];\\n        long res = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            last[s.charAt(i) - \\'a\\'] = i + 1;\\n            for (int j: last)\\n                res += j;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long appealSum(string s) {\\n        vector<int> last(26);\\n        long res = 0, n = s.size();\\n        for (int i = 0; i < n; ++i) {\\n            last[s[i] - \\'a\\'] = i + 1;\\n            for (int j: last)\\n                res += j;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def appealSum(self, s):\\n        last = {}\\n        res = 0\\n        for i,c in enumerate(s):\\n            last[c] = i + 1\\n            res += sum(last.values())\\n        return res\\n```\\n<br>\\n<br>\\n\\n\\n# **Solution 2: Improved from `O(26n)` to `O(n)`**\\nDon\\'t do a O(26) for loop to accumulate the `last`,\\ninsteadly ccount the total value of `last` and update it in `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public long appealSum(String s) {\\n        int last[] = new int[26];\\n        long res = 0, total = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            total += i + 1 - last[s.charAt(i) - \\'a\\'];\\n            last[s.charAt(i) - \\'a\\'] = i + 1;\\n            res += total;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long appealSum(string s) {\\n        vector<int> last(26);\\n        long res = 0, n = s.size(), total = 0;\\n        for (int i = 0; i < n; ++i) {\\n            total += i + 1 - last[s[i] - \\'a\\'];\\n            last[s[i] - \\'a\\'] = i + 1;\\n            res += total;\\n        }\\n        return res;\\n    }\\n```\\n<br>\\n<br>\\n\\n# **Solution3: Count contirbution for each character**\\n\\nThis solution is more like what we do for [828. Count Unique Characters of All Substrings of a Given String](https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/discuss/128952/).\\nYou can take 828 as an another chanllendge to practice more.\\n\\nIn a substring, multiple same character only get one point.\\nWe can consider that the first occurrence get the point.\\nNow for each character, we count its countribution for all substring.\\n\\nFor each character `s[i]`, \\nthe substring must start before `s[i]` to contain `s[i]`\\nand need to end after the `last` occurrence of `s[i]`,\\notherwise the last occurrence of character `s[i]` will get the socre.\\n\\nIn total, there are `i - last[s[i]]` possible start position,\\nand `n - i` possible end position,\\nso `s[i]` can contribute `(i - last[s[i]]) * (n - i)` points.\\n\\nFrom this formula, we can also the difference between problem 2262 and 828.\\n\\nComplexity: Time `O(n)`, Space `O(26)`\\n<br>\\n\\n**Java**\\n```java\\n    public long appealSum(String s) {\\n        int last[] = new int[26];\\n        Arrays.fill(last, -1);\\n        long res = 0, n = s.length();\\n        for (int i = 0; i < s.length(); ++i) {\\n            res += (i - last[s.charAt(i) - \\'a\\']) * (n - i);\\n            last[s.charAt(i) - \\'a\\'] = i;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long appealSum(string s) {\\n        vector<int> last(26, -1);\\n        long res = 0, n = s.size();\\n        for (int i = 0; i < n; ++i) {\\n            res += (i - last[s[i] - \\'a\\']) * (n - i);\\n            last[s[i] - \\'a\\'] = i;\\n        }\\n        return res;        \\n    }\\n```\\n\\n**Python**\\n```py\\n    def appealSum(self, s: str) -> int:\\n        last = defaultdict(lambda: -1)\\n        res, n = 0, len(s)\\n        for i, c in enumerate(s):\\n            res += (i - last[c]) * (n - i)\\n            last[c] = i\\n        return res\\n```\\n<br>\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long appealSum(String s) {\\n        int last[] = new int[26];\\n        long res = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            last[s.charAt(i) - \\'a\\'] = i + 1;\\n            for (int j: last)\\n                res += j;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    long long appealSum(string s) {\\n        vector<int> last(26);\\n        long res = 0, n = s.size();\\n        for (int i = 0; i < n; ++i) {\\n            last[s[i] - \\'a\\'] = i + 1;\\n            for (int j: last)\\n                res += j;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def appealSum(self, s):\\n        last = {}\\n        res = 0\\n        for i,c in enumerate(s):\\n            last[c] = i + 1\\n            res += sum(last.values())\\n        return res\\n```\n```java\\n    public long appealSum(String s) {\\n        int last[] = new int[26];\\n        long res = 0, total = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            total += i + 1 - last[s.charAt(i) - \\'a\\'];\\n            last[s.charAt(i) - \\'a\\'] = i + 1;\\n            res += total;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    long long appealSum(string s) {\\n        vector<int> last(26);\\n        long res = 0, n = s.size(), total = 0;\\n        for (int i = 0; i < n; ++i) {\\n            total += i + 1 - last[s[i] - \\'a\\'];\\n            last[s[i] - \\'a\\'] = i + 1;\\n            res += total;\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public long appealSum(String s) {\\n        int last[] = new int[26];\\n        Arrays.fill(last, -1);\\n        long res = 0, n = s.length();\\n        for (int i = 0; i < s.length(); ++i) {\\n            res += (i - last[s.charAt(i) - \\'a\\']) * (n - i);\\n            last[s.charAt(i) - \\'a\\'] = i;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    long long appealSum(string s) {\\n        vector<int> last(26, -1);\\n        long res = 0, n = s.size();\\n        for (int i = 0; i < n; ++i) {\\n            res += (i - last[s[i] - \\'a\\']) * (n - i);\\n            last[s[i] - \\'a\\'] = i;\\n        }\\n        return res;        \\n    }\\n```\n```py\\n    def appealSum(self, s: str) -> int:\\n        last = defaultdict(lambda: -1)\\n        res, n = 0, len(s)\\n        for i, c in enumerate(s):\\n            res += (i - last[c]) * (n - i)\\n            last[c] = i\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1996300,
                "title": "python3-o-n-o-1-detail-for-beginners",
                "content": "**Thought Process**\\n\\nThe constraints of length of input is 10^5, then we would like to do it linear time.\\nSo started filling this table to observe pattern. (to visually see what are my possible subarrays are as iterating only once)\\n\\nAssume our example input is **S = \\'ababba\\'**\\n\\n\\n![image](https://assets.leetcode.com/users/images/dfb64561-ecc6-40ff-bc17-0f6611b7fc3e_1651378572.6720748.png)\\n\\n\\n\\nSo to store the previously seen characters\\u2019s index, we can use hashmap.\\n**It makes sense because we know that we just need to increment the number of current candidates that does not have duplicate characters that we are looking at i.**\\nSo we are basically doing => previous points **+ (** number of candidates for current index **\\u2013** index where this character was shown before **)**.\\n\\nHope this makes sense, then implement gets simple.\\n\\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        lastSeenMap = {s[0]: 0}\\n        prev, curr, res = 1, 0, 1\\n        \\n        for i in range(1, len(s)):\\n            if s[i] in lastSeenMap:\\n                curr = prev + (i - lastSeenMap[s[i]])\\n            else:\\n                curr = prev + (i + 1)\\n            res += curr\\n            prev = curr\\n            lastSeenMap[s[i]] = i\\n        return res\\n```\\n\\n**Complexity:**\\nTime \\u2013 O(N) because we are only iterating over the input once\\nSpace \\u2013 O(26) -> O(1) as input consist of lowercase English letters only\\n\\n**Please correct me if I am wrong !\\nPlease UPVOTE if you find this solution helpful !\\nHappy algo!**\\n\\n**UPDATES** - I found that the way how I started is useful when you are looking for all possible subarrays.\\nWorking on the two problems greatly helped me to understand such a problem like this, so please take a look\\nhttps://leetcode.com/problems/sum-of-subarray-ranges/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        lastSeenMap = {s[0]: 0}\\n        prev, curr, res = 1, 0, 1\\n        \\n        for i in range(1, len(s)):\\n            if s[i] in lastSeenMap:\\n                curr = prev + (i - lastSeenMap[s[i]])\\n            else:\\n                curr = prev + (i + 1)\\n            res += curr\\n            prev = curr\\n            lastSeenMap[s[i]] = i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999226,
                "title": "combinatorics",
                "content": "This is similar to [2063. Vowels of All Substrings](https://leetcode.com/problems/vowels-of-all-substrings/discuss/1563701/(i-%2B-1)-*-(sz-i)). \\n\\nFrom that problem, we use the fact that each character appears in `(i + 1) * (n - i)` substrings. However, it does not contribute to the appeal of substrings on the left that already include that character. For example, for string \"abc**a**b\", the second \\'a\\' character contributes to the appeal of 6 substrings: \\n- ~~\"abca\"~~ and ~~\"abcab\"~~ (first \\'a\\' character is already counted)\\n- \"bca\" and \"bcab\"\\n- \"ca\" and \"cab\"\\n- \"a\" and \"ab\"\\n\\nTo exclude previously counted substrings, we just track the previous (prev) position of s[i] character. So, the final formula is `(i - prev[ch]) * (n - i)`.\\n\\n> For a different way to solve it, check out this [DP solution](https://leetcode.com/problems/total-appeal-of-a-string/discuss/1996203/DP).\\n\\n![image](https://assets.leetcode.com/users/images/b8208d0c-fac0-44b9-933e-7e7c905b5224_1651437042.982223.png)\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        res, n, prev = 0, len(s), defaultdict(lambda: -1)\\n        for i, ch in enumerate(s):\\n            res += (i - prev[ch]) * (n - i)\\n            prev[ch] = i\\n        return res\\n```\\n\\n**C++**\\n```cpp\\nlong long appealSum(string s) {\\n    long long res = 0, n = s.size(), prev[26] = {};\\n    for (int i = 0; i < n; ++i) {\\n        res += (i + 1 - prev[s[i] - \\'a\\']) * (n - i);\\n        prev[s[i] - \\'a\\'] = i + 1;\\n    }\\n    return res;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        res, n, prev = 0, len(s), defaultdict(lambda: -1)\\n        for i, ch in enumerate(s):\\n            res += (i - prev[ch]) * (n - i)\\n            prev[ch] = i\\n        return res\\n```\n```cpp\\nlong long appealSum(string s) {\\n    long long res = 0, n = s.size(), prev[26] = {};\\n    for (int i = 0; i < n; ++i) {\\n        res += (i + 1 - prev[s[i] - \\'a\\']) * (n - i);\\n        prev[s[i] - \\'a\\'] = i + 1;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997337,
                "title": "pictorial-explanation-linear-solution-question-with-similar-approach",
                "content": "**Pattern -->** Find each index\\'s contribution \\nQuestions with same intituion \\nhttps://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/sum-of-subarray-ranges/\\n\\n # ** Intution **\\n\\n\\u2022\\tEvery index contributes to answer as many substrings as it is part of --EXCEPT when the current character is already counted in the same substring. \\n\\u2022\\tWe iterate from left and count substrings where index i is making fresh contribution.\\n\\u2022\\tIf we see same char again, we don\\u2019t count substrings which are alrady accounted for. \\n\\n![image](https://assets.leetcode.com/users/images/3fda90a1-7413-4aeb-bce0-524ab1ac0cf5_1651391104.74763.png)\\n\\n\\n```\\n public long appealSum(String s) {\\n        \\n        int n = s.length();\\n        \\n        int[] lastOccur = new int[26];\\n        \\n        Arrays.fill(lastOccur , -1);\\n        \\n        long ans = 0 ;\\n        \\n        \\n        for(int i = 0 ; i < n ; i++){\\n            \\n            char curr = s.charAt(i) ;\\n            long sum = (long)(n -i ) *  (long) ( i - lastOccur[curr - \\'a\\']);\\n            ans += sum ;\\n            \\n            lastOccur[curr - \\'a\\'] = i ;\\n\\n            \\n        }\\n        \\n        return ans ;\\n        \\n    }\\n\\t```\\n\\n",
                "solutionTags": [],
                "code": "```\\n public long appealSum(String s) {\\n        \\n        int n = s.length();\\n        \\n        int[] lastOccur = new int[26];\\n        \\n        Arrays.fill(lastOccur , -1);\\n        \\n        long ans = 0 ;\\n        \\n        \\n        for(int i = 0 ; i < n ; i++){\\n            \\n            char curr = s.charAt(i) ;\\n            long sum = (long)(n -i ) *  (long) ( i - lastOccur[curr - \\'a\\']);\\n            ans += sum ;\\n            \\n            lastOccur[curr - \\'a\\'] = i ;\\n\\n            \\n        }\\n        \\n        return ans ;\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1998915,
                "title": "from-2d-dp-to-single-variable-c",
                "content": "**2D DP Solution(TLE)** \\nSo to perform 2D dp think of a matrix with rows as start letter of substring and columns as end letter of substring.\\nFoe example for string ```abbca```\\nConsider a 2d array ```dp``` where ```dp[i][j]``` denotes appeal(distinct character) of substring starting at ```s[i]``` and ending at ```s[j]```. \\nFor ```j<i```,  ```dp[i][j] = 0``` since you can\\'t end before you start. \\n\\nHere is an image for reference\\n\\n![image](https://assets.leetcode.com/users/images/d8b6e2d5-5cab-4e34-9f16-d931056e7e25_1651415284.8973978.png)\\n\\nThis will give TLE for given constraints. Since its ```O(n^2)```.\\nCode: \\n```\\nlong long appealSum(string s) {\\n\\tint n = s.size();\\n        long long dp[n][n], sum = 0;\\n        for (int i = 0; i < n; ++i) {\\n            set<char> set; //to store distinct elements\\n            for (int j = 0; j < n; ++j) {\\n                if (j < i)\\n                    dp[i][j] = 0;\\n                else {\\n                    set.insert(s[j]);\\n                    dp[i][j] = set.size(); //to get distinct elements in substring s(i, j)\\n                }   \\n\\t\\t\\t\\tsum+=dp[i][j];\\n            }\\n        }\\n        return sum;\\n    }\\n```\\n\\n\\n**1D DP Solution**\\nConsider a 1D array ```dp``` of size `n+1` where ```dp[i]``` denotes appeal of substring ending at ```i-1``` index + number of substrings ending at ```i``` that do not contain ```s[i]``` character.\\nA ```prev``` array to store the prev position of character.\\ni.e. `dp[i] = dp[i-1] + (i + prev[s[i]-\\'a\\'])`\\n\\nFor example: For given string `abbca`  \\nappeal of substring (0, 0) = 1\\nappeal of substring (0, 1) = appeal of substring (0, 0) + pos(s[1]) - prev_pos(s[1])\\nand so on.\\n`pos(s[i]) - prev_pos(s[i])` gives number of substrings in which s[i] does not appear\\nAppeal of substring `a` = 1\\nAppeal of substring `ab` = appeal of substring `a` + appeal of substring `ab` = 1 + 2 = 3\\nAppeal of substring `abb` = appeal of substring `ab` + appeal of substring `abb` = 3 + (3-2) = 4\\nAppeal of substring `abbc` = appeal of substring `abb` + appeal of substring `abbc` = 4 + (4-0) = 8\\nAppeal of substring `abbca` = appeal of substring `abbc` + appeal of substring `abbca` = 8 + (5-1) = 12\\nAppeal of **string** `abbca` = 1+ 3 + 4 + 8 + 12 = 28\\n\\n![image](https://assets.leetcode.com/users/images/19caa0f9-7342-4a0c-9d91-c6b7af412e16_1651426670.5744307.png)\\n\\n\\nCode: \\n```\\nlong long appealSum(string s) {\\n\\tint n = s.size();\\n\\tlong long ans = 0, prev_pos[26] = {0};\\n\\tlong long dp[n+1];\\n\\tdp[0] = 0;\\n\\n\\tfor (int i = 1; i <= n; ++i) {\\n\\t\\tdp[i] = dp[i-1] + (i) - prev_pos[s[i-1]-\\'a\\'];\\n\\t\\tprev_pos[s[i-1]-\\'a\\'] = i;\\n\\t\\tans+=dp[i];\\n\\t\\tcout<<dp[i]<<\" \";\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n\\n**Constant Space**\\n\\nSince we only require value of Prev State i.e. For Appeal of substring (i, j) we require Appeal of substring(i, j-1)\\nHence 1d DP can be reduced to a single variable dp\\n\\nCode: \\n```\\nlong long appealSum(string s) {\\n\\tint n = s.size();\\n\\tlong long ans = 0, prev_pos[26] = {0};\\n\\tlong long dp=0;\\n\\n\\tfor (int i = 1; i <= n; ++i) {\\n\\t\\tdp += (i) - prev_pos[s[i-1]-\\'a\\'];\\n\\t\\tprev_pos[s[i-1]-\\'a\\'] = i;\\n\\t\\tans+=dp;\\n\\t\\tcout<<dp<<\" \";\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\nDo upvote if you liked it!!!\\n**THANKS FOR READING!**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```abbca```\n```dp```\n```dp[i][j]```\n```s[i]```\n```s[j]```\n```j<i```\n```dp[i][j] = 0```\n```O(n^2)```\n```\\nlong long appealSum(string s) {\\n\\tint n = s.size();\\n        long long dp[n][n], sum = 0;\\n        for (int i = 0; i < n; ++i) {\\n            set<char> set; //to store distinct elements\\n            for (int j = 0; j < n; ++j) {\\n                if (j < i)\\n                    dp[i][j] = 0;\\n                else {\\n                    set.insert(s[j]);\\n                    dp[i][j] = set.size(); //to get distinct elements in substring s(i, j)\\n                }   \\n\\t\\t\\t\\tsum+=dp[i][j];\\n            }\\n        }\\n        return sum;\\n    }\\n```\n```dp```\n```dp[i]```\n```i-1```\n```i```\n```s[i]```\n```prev```\n```\\nlong long appealSum(string s) {\\n\\tint n = s.size();\\n\\tlong long ans = 0, prev_pos[26] = {0};\\n\\tlong long dp[n+1];\\n\\tdp[0] = 0;\\n\\n\\tfor (int i = 1; i <= n; ++i) {\\n\\t\\tdp[i] = dp[i-1] + (i) - prev_pos[s[i-1]-\\'a\\'];\\n\\t\\tprev_pos[s[i-1]-\\'a\\'] = i;\\n\\t\\tans+=dp[i];\\n\\t\\tcout<<dp[i]<<\" \";\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\nlong long appealSum(string s) {\\n\\tint n = s.size();\\n\\tlong long ans = 0, prev_pos[26] = {0};\\n\\tlong long dp=0;\\n\\n\\tfor (int i = 1; i <= n; ++i) {\\n\\t\\tdp += (i) - prev_pos[s[i-1]-\\'a\\'];\\n\\t\\tprev_pos[s[i-1]-\\'a\\'] = i;\\n\\t\\tans+=dp;\\n\\t\\tcout<<dp<<\" \";\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2217777,
                "title": "java-fastest-o-n-time-building-the-logic",
                "content": "# \\uD83D\\uDCCC Building the Logic \\uD83E\\uDD14\\nThese type questions follow a similar pattern.\\nIn questions where you are asked to **count** something in **every substring / subarray** of a \\'N\\' size array / string having N = 10^5 . Then dont even try to generate all possible substrings/subarrays as it would definitely lead to TLE.\\nWhat we can do ::: Just See **How much contribution every element can provide to the answer** in just one For Loop \\uD83D\\uDC49\\uD83C\\uDFFB O(N)\\n\\n# \\uD83D\\uDCCC Explanation \\u270D\\uD83C\\uDFFB\\nConsider string **\"bcde\"**\\n\\n\\uD83C\\uDFAF lets talk about character \\'c\\' that in how many substrings this \\'c\\' will be counted as unique string\\n::: left no of characters on L.H.S of \\'c\\'   = **left** \\n::: left no of characters on R.H.S of \\'c\\'   = **right** \\nThen total possible substrings containing this \\'c\\' = (left+1) x (right+1)\\n\\nThus contributions for c = 2 * 3  = 6 \\nand those 6 substrings are ( bc, bcd, bcde, c, cd, cde )\\n\\nSo we can say that every character will have contribution of (left+1)x(right+1) to the ans.\\n\\n\\uD83C\\uDFAF But there is one small catch here !\\n**What if characters are same ??** then only one of those characters will have contribution in any substring containing them. \\n\"acca\"\\nHere first \\'c\\' will for sure have a contribution  = (left+1)x(right+1) = 2 x 3 = 6\\nbut for second \\'c\\' Left region will be reduced till the rightmost \\'c\\' on leftside. So the  value of  **left** for second \\'c\\' will be = 0 !!\\nRight will have no change. \\nSo contribution for second \\'c\\' = 1 x 2  = 2;\\n\\nThis way we can calculate the contribution for each and every character in just one for loop.\\n\\n\\u2705 Time Complexity = O(N) \\n\\u2705 Space Complexity = O(26) = O(1)\\n</br>\\n```\\nclass Solution {\\n    public long appealSum(String s) {\\n        \\n        int l = s.length();\\n        int[] lo = new int[26];  //store the last ocuurence index of every character\\n        Arrays.fill(lo,-1);\\n        \\n        long ans = 0;\\n        for(int i=0;i<l;i++)\\n        {\\n            int cc = s.charAt(i)-\\'a\\';\\n            int right = l-i-1;\\n            int left;\\n            \\n            int last = lo[cc];\\n            if(last==-1) left = i;\\n            else left = (i-last)-1;        \\n            ans += (left+1)*(right+1);     \\n            lo[cc] = i;  \\n        }\\n        return ans;    \\n    }\\n}\\n```\\n\\n```\\uD83C\\uDFAF BONUS : Now you have got the logic behind these type of questions. I have a similar question for you \\uD83D\\uDE42 Give it a try  \\uD83D\\uDC4D\\uD83C\\uDFFB```\\nhttps://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/ \\n\\n</br>\\n\\uD83D\\uDCCC Upvote if you liked the approach \\uD83D\\uDE04\\uD83D\\uDE0A",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long appealSum(String s) {\\n        \\n        int l = s.length();\\n        int[] lo = new int[26];  //store the last ocuurence index of every character\\n        Arrays.fill(lo,-1);\\n        \\n        long ans = 0;\\n        for(int i=0;i<l;i++)\\n        {\\n            int cc = s.charAt(i)-\\'a\\';\\n            int right = l-i-1;\\n            int left;\\n            \\n            int last = lo[cc];\\n            if(last==-1) left = i;\\n            else left = (i-last)-1;        \\n            ans += (left+1)*(right+1);     \\n            lo[cc] = i;  \\n        }\\n        return ans;    \\n    }\\n}\\n```\n```\\uD83C\\uDFAF BONUS : Now you have got the logic behind these type of questions. I have a similar question for you \\uD83D\\uDE42 Give it a try  \\uD83D\\uDC4D\\uD83C\\uDFFB```",
                "codeTag": "Java"
            },
            {
                "id": 2310576,
                "title": "c-99-simple-observation-pictorially-explained",
                "content": "**Hello. Please upvote the answer if you found this post helpful.**\\n\\nEverytime a new character is added to the substring it will introduce \"i+1\" (i.e. the length) MORE appeal to that of the previous substring. This is valid when all the characters are unique that is there is no repitition in the string. Let\\'s look at an example : \\n![image](https://assets.leetcode.com/users/images/a5bbc76d-9b2c-4011-8693-d5d1c9d0fa2f_1658356360.749971.png)\\n\\nNow when we introduce repititions, the contribution of the new character being added to the string IF ALREADY PRESENT in the previous substring will be different. So what will be the contribution of this new repeated character being added?\\nFor this we will need to find the index where this character was repeated in the substring earlier. We will only consider the elements after that index as before that the contribution of this new character will just be \"0\".\\nExample : Notice when we had substring \"ab\" and when we were trying to add \"b\" ( index 2) to this substring, we find that b already exists in the substring at index 1. So adding the new \"b\" to substring from [0..x], x being 1 here, will not produce any new \"APPEAL\". (We can see that substring \"bb\" and \"abb\" do not provide any new appeal)\\nPlease watch the example for more clarity :\\n![image](https://assets.leetcode.com/users/images/3de29bbc-f6af-4aea-8e84-ed79d0d08940_1658356729.4092557.png)\\n\\nCode : \\n\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long sum=0, prev=0;\\n        int freq[128];\\n        for(int i=0;i<128;i++)freq[i]=-1;\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(freq[s[i]]==-1)\\n                prev+=i+1;\\n            else\\n                prev+=i-freq[s[i]];\\n                \\n            freq[s[i]]=i;\\n            sum+=prev;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long sum=0, prev=0;\\n        int freq[128];\\n        for(int i=0;i<128;i++)freq[i]=-1;\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(freq[s[i]]==-1)\\n                prev+=i+1;\\n            else\\n                prev+=i-freq[s[i]];\\n                \\n            freq[s[i]]=i;\\n            sum+=prev;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470799,
                "title": "o-n-step-by-step-guide",
                "content": "**Intro**\\nIn order to calculate number of unique characters in all substrings, let\\'s think how we could iterate these substrings.\\n\\nLet\\'s do it iteratively, by starting from 1st character, then adding next character every iteration, untill we end up with complete string.\\nEach iteration we enumerate all substrings that ends with just added character.\\n\\n```\\nfor (int i = 0; i < s.Length; i++)\\nfor (int j = 0; j <= i; j++)\\n{\\n    substring = take characters from j to i\\n}\\n```\\n\\n**Solution**\\n\\nNow when we know how to enumerate all substrings, lets think on the solution.\\n\\nLet\\'s start with simplified version.\\n\\n**All characters are unique**\\n\\nLets think how occurence count is changed when we add 1 more character to the string\\n\\n|String| Occurence of \\'a\\' | Occurence of \\'b\\'     | Occurence of \\'\\u0441\\'                | Occurence Sum| Total|\\n|------|-------------------|----------------------|------------------------------|------------------|------|\\n|a       | **a** =     1       |                                 |                                           | 1                        | 1      |\\n|ab     | **a**b =   1       | a**b** + **b** = 2 |                                           | 3                        | 1 + 3 = 4|\\n|abc    | **a**bc = 1      | a**b**c+**b**c =2 | ab**c**+b**c**+**c** = 3| 6                        | 4 + 6 =10|\\n\\n1st thing to notice, the position where character appears first is equal to number of occurences.\\n\\n2nd thign to notice, every time we add a new character to the string, we care only about new substrings that ends with new character, all other substrings already been counted during previous iterations.\\n\\n```\\npublic long AppealSum(string s)\\n{\\n    var total = 0;\\n    var occurenceSum = 0;\\n\\n    for (int i = 0; i < s.Length; i++)\\n    {\\n\\t    // Character at pos i will appear i+1 times\\n        occurenceSum += i+1;\\n        total += occurenceSum;\\n    }\\n\\n    return total;\\n}\\n```\\n\\nNow lets see what happens if we add not unique character.\\n\\n**Next character is not unique**\\n\\nLets add \\'a\\' to \\'abc\\', so the string will be \\'abca\\'\\n\\n|String| Occurence of \\'a\\'                                             | Occurence of \\'b\\'            | Occurence of \\'\\u0441\\'                      | Occurence Sum| Total|\\n|------|------------------------------------------------- |-------------------------- |---------------------------------|-------------|------|\\n|abc   | **a**bc = 1                                                     | a**b**c+**b**c = 2     | ab**c**+b**c**+**c** = 3      | 6  | 4 + 6 = 10 |\\n|abca | **a**bc**a** +bc**a** + c**a** + **a** = 4 | a**b**ca+**b**ca = 2 | ab**c**a+b**c**a+**c**a = 3| 9  |10 + 9 = 19 |\\n\\nLet\\'s look at \\'abca\\' string, \\'a\\' appeard 4 times: **a**bc**a**, bc**a**, c**a**, **a**.\\nWe dont care about 1st \\'a\\' anymore, because all new substrings with 4th \\'a\\' already include all substrings with 1st \\'a\\'. So we need to update occurence count for \\'a\\' from 1 to 4.\\n\\nLets use an array that will have occurence of every character:\\n```\\npublic long AppealSum(string s)\\n{\\n    var total = 0;\\n    var occurence = new int[26];\\n        \\n    for (int i = 0; i < s.Length; i++)\\n    {\\n\\t    // Character at pos i will appear i+1 times\\n        occurence[s[i]-\\'a\\'] = i+1;\\n        // Sum up occurence count of all characters and update total count\\n        total += occurence.Sum();\\n    }\\n        \\n    return total;\\n}\\n```\\n\\t\\t\\n**Optimization**\\nInstead of caclucalting sum of character occurence every iteration, we could optmize this operation:\\n\\t\\t\\n```\\npublic long AppealSum(string s)\\n{\\n    var total = 0;\\n    var occurence = new int[26];\\n    var occurenceSum = 0;\\t\\t\\t\\t\\n        \\n    for (int i = 0; i < s.Length; i++)\\n    {\\n        occurenceSum += i+1 - occurence[s[i]-\\'a\\'];\\n        occurence[s[i]-\\'a\\'] = i+1;\\n        total += occurenceSum;\\n    }\\n        \\n    return total;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfor (int i = 0; i < s.Length; i++)\\nfor (int j = 0; j <= i; j++)\\n{\\n    substring = take characters from j to i\\n}\\n```\n```\\npublic long AppealSum(string s)\\n{\\n    var total = 0;\\n    var occurenceSum = 0;\\n\\n    for (int i = 0; i < s.Length; i++)\\n    {\\n\\t    // Character at pos i will appear i+1 times\\n        occurenceSum += i+1;\\n        total += occurenceSum;\\n    }\\n\\n    return total;\\n}\\n```\n```\\npublic long AppealSum(string s)\\n{\\n    var total = 0;\\n    var occurence = new int[26];\\n        \\n    for (int i = 0; i < s.Length; i++)\\n    {\\n\\t    // Character at pos i will appear i+1 times\\n        occurence[s[i]-\\'a\\'] = i+1;\\n        // Sum up occurence count of all characters and update total count\\n        total += occurence.Sum();\\n    }\\n        \\n    return total;\\n}\\n```\n```\\npublic long AppealSum(string s)\\n{\\n    var total = 0;\\n    var occurence = new int[26];\\n    var occurenceSum = 0;\\t\\t\\t\\t\\n        \\n    for (int i = 0; i < s.Length; i++)\\n    {\\n        occurenceSum += i+1 - occurence[s[i]-\\'a\\'];\\n        occurence[s[i]-\\'a\\'] = i+1;\\n        total += occurenceSum;\\n    }\\n        \\n    return total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997366,
                "title": "c-beats-100-logic-explained-simple-and-easy",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long appealSum(string s) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tlong long ans = 0;\\n\\t\\t\\tfor(char ch=\\'a\\';ch<=\\'z\\';ch++)       // we are finding the number of substrings containing at least 1 occurence of ch\\n\\t\\t\\t{\\n\\t\\t\\t\\tint prev = 0;                   // prev will store the previous index of the charcter ch\\n\\t\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(s[i] == ch) prev = i+1;  // if the current character is equal to ch , then the no. of substring\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// ending at i and having at least one occurence of ch will be i+1 .\\n\\n\\t\\t\\t\\t\\tans+=prev;                  // else the no. of substrings ending at i and having at least\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// one occurence of ch will be the equal to, the previous index of ch.\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;                        // TC - O(n*26) , SC - O(1)\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long appealSum(string s) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tlong long ans = 0;\\n\\t\\t\\tfor(char ch=\\'a\\';ch<=\\'z\\';ch++)       // we are finding the number of substrings containing at least 1 occurence of ch\\n\\t\\t\\t{\\n\\t\\t\\t\\tint prev = 0;                   // prev will store the previous index of the charcter ch\\n\\t\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(s[i] == ch) prev = i+1;  // if the current character is equal to ch , then the no. of substring\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// ending at i and having at least one occurence of ch will be i+1 .\\n\\n\\t\\t\\t\\t\\tans+=prev;                  // else the no. of substrings ending at i and having at least\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// one occurence of ch will be the equal to, the previous index of ch.\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1996625,
                "title": "java-o-n-concise-solution-with-explanation-7ms",
                "content": "**Thingking process**\\n* From the constrains, it must be solved by O(NlogN) or O(N) solution.\\n* If it\\'s solvable by O(NlogN), it might be related to sorting. However, I can\\'t imagine that sort can help me.\\n* So I should focus on designing an O(N) solution.\\n* If I can count the number of appearance among the possible substrings for each letter, I can scan the string and get the answer in linear time.\\n* Take the `\"code\"` (the second sample) and letter `c` as an example, the number of substring containing it can be calculated by 1 x 4 (number of possible start point on the left side x number of possible end point on the right side).\\n* Continue with the above, I calculate the value for each letter and the sum matches the expectation.\\n* The method seems work but how can I deal with the string contains duplicate letters such as `\"abbca\"`?\\n* Let\\'s look at this sample `\"....a......a......\"`. For the first letter `a`, I can calculate its contribution with the above method and there\\'s no problem.\\n* For the second letter `a`, the possible starting point on the left side should be the position next to the first `a` because the position before it is already covered by the previous letter `a`. Thus, I think I figure out the formula.\\n\\n**Implementation**\\n\\n```\\nclass Solution {\\n    public long appealSum(String s) {\\n        long res = 0;\\n        char[] cs = s.toCharArray();\\n        int n = cs.length;\\n        int[] pos = new int[26];\\n        Arrays.fill(pos, -1);\\n        for (int i = 0; i < n; ++i) {\\n            int j = cs[i] - \\'a\\', prev = pos[j]; \\n            res += (i - prev) * (long) (n - i);\\n            pos[j] = i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long appealSum(String s) {\\n        long res = 0;\\n        char[] cs = s.toCharArray();\\n        int n = cs.length;\\n        int[] pos = new int[26];\\n        Arrays.fill(pos, -1);\\n        for (int i = 0; i < n; ++i) {\\n            int j = cs[i] - \\'a\\', prev = pos[j]; \\n            res += (i - prev) * (long) (n - i);\\n            pos[j] = i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996308,
                "title": "easy-c-solution-in-o-n-time",
                "content": "Feel free to comment and do upvote if you like this solution.\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        \\n        int n = s.size();\\n        \\n        long long ans =1;\\n        \\n        vector<int> v(26,-1);  // stores the index of character\\n        vector<long long> p(n,0); // which stores the count of ans up to present index\\n        p[0] = 1;\\n        v[s[0]-\\'a\\'] = 0;\\n        \\n        for(int i=1;i<n;i++){\\n            if(v[s[i]-\\'a\\']==-1){\\n                p[i] = p[i-1]+(i)+1; // At present idx count will increase by the no of elements before + prev ans\\n                ans+=p[i];\\n            }else{\\n                int j = v[s[i]-\\'a\\'];\\n                if(j==i-1){\\n                    p[i] = p[j]+1;\\n                }\\n                else p[i] = p[i-1]-(j+1)+i+1; \\n                ans+=p[i];\\n            }\\n            v[s[i]-\\'a\\'] = i;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        \\n        int n = s.size();\\n        \\n        long long ans =1;\\n        \\n        vector<int> v(26,-1);  // stores the index of character\\n        vector<long long> p(n,0); // which stores the count of ans up to present index\\n        p[0] = 1;\\n        v[s[0]-\\'a\\'] = 0;\\n        \\n        for(int i=1;i<n;i++){\\n            if(v[s[i]-\\'a\\']==-1){\\n                p[i] = p[i-1]+(i)+1; // At present idx count will increase by the no of elements before + prev ans\\n                ans+=p[i];\\n            }else{\\n                int j = v[s[i]-\\'a\\'];\\n                if(j==i-1){\\n                    p[i] = p[j]+1;\\n                }\\n                else p[i] = p[i-1]-(j+1)+i+1; \\n                ans+=p[i];\\n            }\\n            v[s[i]-\\'a\\'] = i;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207026,
                "title": "python3-7-lines-dp-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe idea is to iterate over all characters and for every one of them calculate the amount of substrings where this character contribute to the score. The formula is as follows:\\n`X + Y - Z`, where\\n* X - the amount of substrings where current characters appears if the string started from this characters `n - i`\\n* Y - the amount of substrings that the previous character can form with the current one ` dp[i-1] - i`\\n* Z - correction for the previously seen same characters (just substruct amount of substrings where those two appears together) `last_seen[ch] + 1`\\n\\nTo know when the same characters appeared before. we use a hash map `last_seen`\\n\\nSo resulting formula is `(n - i) + (dp[i - 1] - i) - (last_seen[ch] + 1)`. Result is equal to sum of the dp table.\\n\\n\\n```\\ndef appealSum(self, s: str) -> int:\\n\\tn = len(s) \\n\\tdp = [0]*(n + 1)\\n\\tlast_seen = defaultdict(lambda: -1)\\n\\tfor i, ch in enumerate(s):\\n\\t\\tdp[i] = (n - i) + (dp[i - 1] - i) - (last_seen[ch] + 1)\\n\\t\\tlast_seen[ch] = i\\n\\n\\treturn sum(dp)\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef appealSum(self, s: str) -> int:\\n\\tn = len(s) \\n\\tdp = [0]*(n + 1)\\n\\tlast_seen = defaultdict(lambda: -1)\\n\\tfor i, ch in enumerate(s):\\n\\t\\tdp[i] = (n - i) + (dp[i - 1] - i) - (last_seen[ch] + 1)\\n\\t\\tlast_seen[ch] = i\\n\\n\\treturn sum(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3708693,
                "title": "cpp-dynamic-programming-explained-thought-process-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs latin alphabets contains only 26 character, its always possible that question asked about the unique characters or property based on it. first thought was storing the frequency in prefix vector and processing it.\\nThis comment helped me a lot to come up with current approach\\n[Comment by cursydd ](https://leetcode.com/problems/total-appeal-of-a-string/description/comments/1802971)\\n  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince we are asked to find the appeal for all substring we can\\'t traverse trough all the substring and sum up their appeals.\\nAs it would have O(n^2) or higher time complexity.\\nwhich will definitely give TLE for n = 1e5;\\n\\nSo i tried to calculate the way we count the number of substring endings at index i. that would be i+1;\\nand we can calculate all of them in single pass.\\n\\nI tried above concept with appeal, i.e. total appeal of all the substrings ending at ith index.\\nlets look at dry run of following two strings.\\nit will help you understand the dp transition states;\\n\\n```\\nexample 1:\\ns = \"abcd\"\\n\\nIndex:       0   1   2    3\\nSubstrings:  a  ab  abc  abcd\\n             1   b   bc   bcd\\n                 3    c    cd\\n                      6     d\\n                           10 \\n```\\n\\n   appeal at i = 1  -> 3= 1(pre index appeal) + (1+1)\\n   appeal at i = 2  -> 6= 3(pre index appeal) + (2+1)\\n   appeal at i = 3  -> 10= 6(pre index appeal) + (3+1)\\n\\n\\n``` \\n    if(ith character has no previous occurance)\\n     cur appeal (at ith index) = appeal of previous index + ( index +1) \\n```\\ntotal appeal = 1+3+6+10;\\n\\nexample 2:\\ns = \"abcdb\"\\n```\\nIndex:       0   1   2     3    4\\nSubstrings:  a  ab  abc  abcd  abcdb (string has extra b)\\n             1   b   bc   bcd   bcdb (string has extra b)\\n                 3    c    cd    cdb\\n                      6     d     db\\n                           10      b\\n                                  13 \\n\\n``` \\n   appeal at i = 4 -> 10 + (4+1) - ( extra repeating characters).\\n    **This extra characters  will be number of the substrings that are ending at the last occurance index ( i.e. last occurance +1 ),\\nas they already contains current character**\\n\\n\\n  ``` \\nif(ith character has previous occurance)\\n cur appeal (at ith index) = appeal of previous index + ( index +1) - (last occurance index +1)\\n```\\n# Summary\\n```\\ndp[i]  = dp[i-1] +(i +1) - ( last_occ[s[i]] +1)\\n```\\nand As our current Dp state only depends on previous State,\\nwe can use two variables, Pre_appeal and Cur_appeal to obtain\\nthe answer with constant space complexity.\\nwe have initialized last_occ with -1,\\nWhen there are no previous occurance ( last_occ[s[i]] +1 ) turns to zero.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(1)** As we use constat space of 26 integers.\\n\\n# Code\\n\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string &s) {\\n        int n = s.size();\\n        vector<int> last_occ(26 ,-1 );\\n    long ans = 0;\\n    int pre_appeal = 0 ; \\n        for(int i = 0; i < n; i++)\\n        {\\n            int cur_appeal = 0;\\n            cur_appeal = pre_appeal + (i +1)  - ( last[s[i] - \\'a\\'] +1);\\n            ans += cur_appeal;\\n            last_occ[s[i] - \\'a\\'] = i;\\n            pre_appeal = cur_appeal;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please Upvote if you found this helpful**\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nexample 1:\\ns = \"abcd\"\\n\\nIndex:       0   1   2    3\\nSubstrings:  a  ab  abc  abcd\\n             1   b   bc   bcd\\n                 3    c    cd\\n                      6     d\\n                           10 \\n```\n``` \\n    if(ith character has no previous occurance)\\n     cur appeal (at ith index) = appeal of previous index + ( index +1) \\n```\n```\\nIndex:       0   1   2     3    4\\nSubstrings:  a  ab  abc  abcd  abcdb (string has extra b)\\n             1   b   bc   bcd   bcdb (string has extra b)\\n                 3    c    cd    cdb\\n                      6     d     db\\n                           10      b\\n                                  13 \\n\\n```\n``` \\nif(ith character has previous occurance)\\n cur appeal (at ith index) = appeal of previous index + ( index +1) - (last occurance index +1)\\n```\n```\\ndp[i]  = dp[i-1] +(i +1) - ( last_occ[s[i]] +1)\\n```\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string &s) {\\n        int n = s.size();\\n        vector<int> last_occ(26 ,-1 );\\n    long ans = 0;\\n    int pre_appeal = 0 ; \\n        for(int i = 0; i < n; i++)\\n        {\\n            int cur_appeal = 0;\\n            cur_appeal = pre_appeal + (i +1)  - ( last[s[i] - \\'a\\'] +1);\\n            ans += cur_appeal;\\n            last_occ[s[i] - \\'a\\'] = i;\\n            pre_appeal = cur_appeal;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996801,
                "title": "c-go-java-find-substring-with-k-distinct-characters",
                "content": "Idea : \\n*  At most 26 distinct characters\\n*  Do 1 <= i <= 26, find how many substrings with **i** distinct characters\\n*  Same question as **LC992 Subarrays with K Different Integers**\\n\\nC++\\n```\\nusing namespace std;\\nusing ll = long long;\\n\\nint cnt[26];\\nll most(string& s, int k) {\\n    for(int i = 0; i < 26; i++) cnt[i] = 0;\\n\\tll res = 0;\\n    int size = 0;\\n    for(int i = 0, j = 0; i < s.size(); i++) {\\n        cnt[s[i] - \\'a\\']++;\\n        if(cnt[s[i] - \\'a\\'] == 1) size++;\\n        while(size > k) {\\n            cnt[s[j] - \\'a\\']--;\\n            if(cnt[s[j] - \\'a\\'] == 0) size--;\\n            j++;\\n        }\\n        res += (i - j) + 1;\\n    }\\n    return res;\\n}\\n\\nll cal(string& s, int k) {\\n    return most(s, k) - most(s, k - 1);\\n}\\n\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        ll res = 0;\\n        for(int i = 1; i <= 26; i++) {\\n            ll x = cal(s, i);\\n            res += (x * i);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n\\nGo\\n```\\nfunc atmost(s string, k int) int64 {\\n    cnt := make([]int, 26)\\n    var SIZE, j int = 0, 0\\n    res := int64(0)\\n    for i := 0; i < len(s); i++ {\\n        cnt[s[i] - \\'a\\']++\\n        if cnt[s[i] - \\'a\\'] == 1 {\\n            SIZE++\\n        }\\n        for SIZE > k {\\n            cnt[s[j] - \\'a\\']--\\n            if cnt[s[j] - \\'a\\'] == 0 {\\n                SIZE--\\n            }\\n            j++\\n        }\\n        res += int64(i - j + 1)\\n    }\\n    return res\\n}\\n\\nfunc appealSum(s string) int64 {\\n    res := int64(0)\\n    for i := 1; i <= 26; i++ {\\n        x := atmost(s, i) - atmost(s, i - 1)\\n        res += (x) * int64(i)\\n    } \\n    return res\\n}\\n```\\n\\nJava\\n```\\nclass Solution {\\n    public long appealSum(String s) {\\n        long res = 0;\\n        for(int i = 1; i <= 26; i++) {\\n            long x = most(s, i) - most(s, i - 1);\\n            res += x * i;\\n        }\\n        return res;\\n    }\\n    public long most(String s, int k) {\\n        int cnt[] = new int[26];\\n        int size = 0;\\n        long res = 0;\\n        for(int i = 0, j = 0; i < s.length(); i++) {\\n            cnt[s.charAt(i) - \\'a\\']++;\\n            if(cnt[s.charAt(i) - \\'a\\'] == 1) size++;\\n            while(size > k) {\\n                cnt[s.charAt(j) - \\'a\\']--;\\n                if(cnt[s.charAt(j) - \\'a\\'] == 0) size--;\\n                j++;\\n            }\\n            res += (i - j + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing namespace std;\\nusing ll = long long;\\n\\nint cnt[26];\\nll most(string& s, int k) {\\n    for(int i = 0; i < 26; i++) cnt[i] = 0;\\n\\tll res = 0;\\n    int size = 0;\\n    for(int i = 0, j = 0; i < s.size(); i++) {\\n        cnt[s[i] - \\'a\\']++;\\n        if(cnt[s[i] - \\'a\\'] == 1) size++;\\n        while(size > k) {\\n            cnt[s[j] - \\'a\\']--;\\n            if(cnt[s[j] - \\'a\\'] == 0) size--;\\n            j++;\\n        }\\n        res += (i - j) + 1;\\n    }\\n    return res;\\n}\\n\\nll cal(string& s, int k) {\\n    return most(s, k) - most(s, k - 1);\\n}\\n\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        ll res = 0;\\n        for(int i = 1; i <= 26; i++) {\\n            ll x = cal(s, i);\\n            res += (x * i);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nfunc atmost(s string, k int) int64 {\\n    cnt := make([]int, 26)\\n    var SIZE, j int = 0, 0\\n    res := int64(0)\\n    for i := 0; i < len(s); i++ {\\n        cnt[s[i] - \\'a\\']++\\n        if cnt[s[i] - \\'a\\'] == 1 {\\n            SIZE++\\n        }\\n        for SIZE > k {\\n            cnt[s[j] - \\'a\\']--\\n            if cnt[s[j] - \\'a\\'] == 0 {\\n                SIZE--\\n            }\\n            j++\\n        }\\n        res += int64(i - j + 1)\\n    }\\n    return res\\n}\\n\\nfunc appealSum(s string) int64 {\\n    res := int64(0)\\n    for i := 1; i <= 26; i++ {\\n        x := atmost(s, i) - atmost(s, i - 1)\\n        res += (x) * int64(i)\\n    } \\n    return res\\n}\\n```\n```\\nclass Solution {\\n    public long appealSum(String s) {\\n        long res = 0;\\n        for(int i = 1; i <= 26; i++) {\\n            long x = most(s, i) - most(s, i - 1);\\n            res += x * i;\\n        }\\n        return res;\\n    }\\n    public long most(String s, int k) {\\n        int cnt[] = new int[26];\\n        int size = 0;\\n        long res = 0;\\n        for(int i = 0, j = 0; i < s.length(); i++) {\\n            cnt[s.charAt(i) - \\'a\\']++;\\n            if(cnt[s.charAt(i) - \\'a\\'] == 1) size++;\\n            while(size > k) {\\n                cnt[s.charAt(j) - \\'a\\']--;\\n                if(cnt[s.charAt(j) - \\'a\\'] == 0) size--;\\n                j++;\\n            }\\n            res += (i - j + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996493,
                "title": "c-explanation-added-next-occurrence-dynamic-programming-beats-100",
                "content": "**Approach**\\n1. Store next occurrence of the character at `i` position.\\n2. Hence, the dp state would be: `dp[i]` denotes appeal of all substrings starting at index `i`.\\n3. `dp[i] = dp[i + 1] + (nextOccurrence[i] - i)` will be the formulation of the dp solution.\\n4. The final answer would be the sum of all the dp states `(0 <= i < n)`\\n\\n**Note:** We can further optimise the solution by using two variables because for the state `i`, `i` only require next state, i.e, `i + 1`\\n\\n**Optimized Solution:**\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int n = s.size();\\n        int nextOccurence[n];\\n        \\n        for(int i = 0; i < 26; i++) {\\n            int last = n;\\n            for(int j = n - 1; j >= 0; j--) {\\n                if(s[j] == \\'a\\' + i) {\\n                    nextOccurence[j] = last;\\n                    last = j;\\n                }\\n            }\\n        }\\n        int small = 0;\\n        long long ans = 0;\\n        for(int i = n - 1; i >= 0; i--) {\\n            int diff = nextOccurence[i] - i;\\n            ans += small + diff;\\n            small = small + diff;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Time Complexity:** `O(n)`\\n**Space Complexity:** `O(n)`",
                "solutionTags": [
                    "C",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int n = s.size();\\n        int nextOccurence[n];\\n        \\n        for(int i = 0; i < 26; i++) {\\n            int last = n;\\n            for(int j = n - 1; j >= 0; j--) {\\n                if(s[j] == \\'a\\' + i) {\\n                    nextOccurence[j] = last;\\n                    last = j;\\n                }\\n            }\\n        }\\n        int small = 0;\\n        long long ans = 0;\\n        for(int i = n - 1; i >= 0; i--) {\\n            int diff = nextOccurence[i] - i;\\n            ans += small + diff;\\n            small = small + diff;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996270,
                "title": "python-hashmap-o-n-solution-with-detailed-explanations-clean-concise",
                "content": "**Intuition**\\nThe given constraint has `1 <= s.length <= 10^5`, indicating `O(N^2)` solutions would get TLE. A natural idea is to use 1-D DP.\\n\\n**Explanation**\\nWe use an array `dp` of length `N`, where `dp[i]` represents the total appeal of all of substrings ending at index `i` of the original string `s`. We also use a hashmap to record the most recent index with the current letter. Now, two conditions needs to be considered:\\n(1) If the current letter does not exist in the hashmap, meaning that it is a *new* appearance. Hence, the current letter can contribute to the appeals of all substrings ending at it, which implies `dp[i] = dp[i - 1] + (i + 1)`;\\n(2) If the current letter does exist in the hashmap, meaning that it is not a new appearance. Hence, the current letter can contribute to the appeals of all substrings starting after the previous appearance and ending at it, which implies `dp[i] = dp[i - 1] + (i - hashmap[s[i]])`.\\nThe final answer is `sum(dp)`.\\n\\n**Complexity**\\nTime: `O(N)`, where `N = s.length` since we perform a linear scan\\nSpace `O(N)`, for the use of `dp` array (and the hashmap)\\n\\nBelow is my in-contest solution. Please upvote if you find this solution helpful. Thanks!\\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0] * n\\n        dp[0] = 1\\n        hashmap = {s[0]: 0}\\n        for i in range(1, n):\\n            if s[i] not in hashmap:\\n                dp[i] = dp[i - 1] + (i + 1)\\n                hashmap[s[i]] = i\\n            else:\\n                dp[i] = dp[i - 1] + (i - hashmap[s[i]])\\n                hashmap[s[i]] = i\\n        return sum(dp)\\n```\\n\\n**Follow up**: The above solution can be further optimized to save the use of `dp` array given as follows, which makes the code even more clean and concise.\\n\\n**Complexity**\\nTime: `O(N)`, where `N = s.length` since we perform a linear scan\\nSpace `O(26) = O(1)`, for the use of hashmap only\\n\\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        n = len(s)\\n        curSum, cumSum = 1, 1\\n        hashmap = {s[0]: 0}\\n        for i in range(1, n):\\n            if s[i] not in hashmap:\\n                curSum += i + 1\\n            else:\\n                curSum += i - hashmap[s[i]]\\n            cumSum += curSum\\n            hashmap[s[i]] = i\\n        return cumSum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0] * n\\n        dp[0] = 1\\n        hashmap = {s[0]: 0}\\n        for i in range(1, n):\\n            if s[i] not in hashmap:\\n                dp[i] = dp[i - 1] + (i + 1)\\n                hashmap[s[i]] = i\\n            else:\\n                dp[i] = dp[i - 1] + (i - hashmap[s[i]])\\n                hashmap[s[i]] = i\\n        return sum(dp)\\n```\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        n = len(s)\\n        curSum, cumSum = 1, 1\\n        hashmap = {s[0]: 0}\\n        for i in range(1, n):\\n            if s[i] not in hashmap:\\n                curSum += i + 1\\n            else:\\n                curSum += i - hashmap[s[i]]\\n            cumSum += curSum\\n            hashmap[s[i]] = i\\n        return cumSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996201,
                "title": "python3-easy-understand-solution",
                "content": "\\n\\n* For each `s[i]`, count number of substring such that `s[i]` is unique\\n* Formula:\\n\\t* `s[i] = (i + 1) * (j - i)`\\n\\t* Where `j` is the nearest index after `i`, where `s[i] = s[j]`, if `j` does not exist, `j = len(s)`\\n\\n\\n<iframe src=\"https://leetcode.com/playground/LJZfKYdK/shared\" frameBorder=\"0\" width=\"800\" height=\"350\"></iframe>\\n\\n**Complexity**\\n* Time: `O(N)`\\n* Space : `O(N)`",
                "solutionTags": [],
                "code": "\\n\\n* For each `s[i]`, count number of substring such that `s[i]` is unique\\n* Formula:\\n\\t* `s[i] = (i + 1) * (j - i)`\\n\\t* Where `j` is the nearest index after `i`, where `s[i] = s[j]`, if `j` does not exist, `j = len(s)`\\n\\n\\n<iframe src=\"https://leetcode.com/playground/LJZfKYdK/shared\" frameBorder=\"0\" width=\"800\" height=\"350\"></iframe>\\n\\n**Complexity**\\n* Time: `O(N)`\\n* Space : `O(N)`",
                "codeTag": "Unknown"
            },
            {
                "id": 1999319,
                "title": "understand-algorithm-o-n-c-snippet-explained",
                "content": "Can we solve **using DP**?\\nAns: Yes\\n\\n**Basic Conept to Understand**\\nappeal(\"abc\") = 3 (since 3 unique characters)\\nSuppose we know appeal(str) = N\\nappeal(str + \"x\") = 1 + N, if x **does not exist in str**\\n                             = 0 + N, if x **exists in str**\\n\\nThe following code uses more space (but is **easier to understand**)\\n```\\nlong long appealSum(string s) {\\n        long long res = 0;\\n        int N = s.length();\\n        vector<int> totAppealOfAllSubStrEndingAtCurIndex(N, 0);\\n        vector<int> dp(N, 0);\\n        vector<int> lastOccurenceSeenSoFarOfChar(26, 0);\\n        for(int i = 0; i < N; i++)  {\\n            if(i == 0)  {\\n                totAppealOfAllSubStrEndingAtCurIndex[i] = (i+1 - lastOccurenceSeenSoFarOfChar[s[i]-\\'a\\']);\\n                dp[i] = totAppealOfAllSubStrEndingAtCurIndex[i];\\n            }\\n            else    {\\n                totAppealOfAllSubStrEndingAtCurIndex[i] = totAppealOfAllSubStrEndingAtCurIndex[i-1] + (i+1 - lastOccurenceSeenSoFarOfChar[s[i]-\\'a\\']);\\n                dp[i] = dp[i-1] + totAppealOfAllSubStrEndingAtCurIndex[i];\\n            }\\n            lastOccurenceSeenSoFarOfChar[s[i]-\\'a\\'] = i+1;\\n        }\\n        res = dp[N-1];\\n        return res;\\n    }\\n```\\n**Explanation**\\n**dp[i]** = total appeal for the string ending at position i\\n**totAppealOfAllSubStrEndingAtCurIndex[i]** = Sum of appeal of all substrings ending at i\\n\\nSuppose we know the value of dp[i-1]\\ndp[i] = dp[i-1] + totAppealOfAllSubStrEndingAtCurIndex[i]\\n\\nCan we **use totAppealOfAllSubStrEndingAtCurIndex[i-1] to compute totAppealOfAllSubStrEndingAtCurIndex[i]**?\\n**Answer is YES**. How?\\n\\ntotAppealOfAllSubStrEndingAtCurIndex[i] = totAppealOfAllSubStrEndingAtCurIndex[i-1] **+ Number of substrings ending at position i that do not contain chracter s[i]**\\n\\n**Understand with an example**\\nFor example \"abcb\"\\ntotAppealOfAllSubStrEndingAtCurIndex[2] =                         appeal(\"c \")   + appeal(\"bc \") + appeal(\"abc \")\\ntotAppealOfAllSubStrEndingAtCurIndex[3] = appeal(\"b\") + appeal(\"cb\") + appeal(\"bcb\") + appeal(\"abcb\")\\n\\nNotice: Equation 2 has character \"b\" appended to all the strings in equation 1 \\nif character \"b\" does not exist in corresponding string in Eq 1 but exists in Eq 2, then it would lead to an additional appeal of 1, ie **appeal(\"cb\") = 1 + appeal(\"c\")**\\nIf character \"b\" exists in corresponding string in Eq 1 as well, then the new character would not lead to an additional appeal of 1, ie **appeal(\"bcb\") = 0 + appeal(\"bc\")**\\n\\nTherefore, totAppealOfAllSubStrEndingAtCurIndex[i] = totAppealOfAllSubStrEndingAtCurIndex[i-1] + (Number of substrings ending at position i that do not contain chracter s[i])\\n\\n**Number of substrings ending at position i that do not contain chracter s[i]** can be simply computed by **keeping track of last occurences of each character among the lower case 26 characters.**\\n\\n\\nThe following code is simplified to use lesser space (but is **difficult to understand**)\\n```\\nlong long appealSum(string s) {\\n        long long res = 0;\\n        int N = s.length();\\n        int totAppealOfAllSubStrEndingAtCurIndex = 0;\\n        vector< int > lastOccurenceSeenSoFarOfChar(26, 0);\\n        for(int i = 0; i < N; i++)  {\\n            totAppealOfAllSubStrEndingAtCurIndex += (i+1 - lastOccurenceSeenSoFarOfChar[s[i]-\\'a\\']);\\n            res += totAppealOfAllSubStrEndingAtCurIndex;\\n            lastOccurenceSeenSoFarOfChar[s[i]-\\'a\\'] = i+1;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nlong long appealSum(string s) {\\n        long long res = 0;\\n        int N = s.length();\\n        vector<int> totAppealOfAllSubStrEndingAtCurIndex(N, 0);\\n        vector<int> dp(N, 0);\\n        vector<int> lastOccurenceSeenSoFarOfChar(26, 0);\\n        for(int i = 0; i < N; i++)  {\\n            if(i == 0)  {\\n                totAppealOfAllSubStrEndingAtCurIndex[i] = (i+1 - lastOccurenceSeenSoFarOfChar[s[i]-\\'a\\']);\\n                dp[i] = totAppealOfAllSubStrEndingAtCurIndex[i];\\n            }\\n            else    {\\n                totAppealOfAllSubStrEndingAtCurIndex[i] = totAppealOfAllSubStrEndingAtCurIndex[i-1] + (i+1 - lastOccurenceSeenSoFarOfChar[s[i]-\\'a\\']);\\n                dp[i] = dp[i-1] + totAppealOfAllSubStrEndingAtCurIndex[i];\\n            }\\n            lastOccurenceSeenSoFarOfChar[s[i]-\\'a\\'] = i+1;\\n        }\\n        res = dp[N-1];\\n        return res;\\n    }\\n```\n```\\nlong long appealSum(string s) {\\n        long long res = 0;\\n        int N = s.length();\\n        int totAppealOfAllSubStrEndingAtCurIndex = 0;\\n        vector< int > lastOccurenceSeenSoFarOfChar(26, 0);\\n        for(int i = 0; i < N; i++)  {\\n            totAppealOfAllSubStrEndingAtCurIndex += (i+1 - lastOccurenceSeenSoFarOfChar[s[i]-\\'a\\']);\\n            res += totAppealOfAllSubStrEndingAtCurIndex;\\n            lastOccurenceSeenSoFarOfChar[s[i]-\\'a\\'] = i+1;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1996269,
                "title": "java-o-n-track-previous-index-of-each-character",
                "content": "Defining f(i): total appeal of all substrings ending at index i\\n**Example**:\\n```\\ns: abcdb\\ni: 01234\\n```\\nassuming f(3) is calculated as:\\n```\\nd -> 1\\ncd -> 2\\nbcd -> 3\\nabcd -> 4\\nf(3) = 10\\n```\\nLet\\'s calculate for i = 4, append b to all f(3) strings and one empty string\\n```\\nf(4) = ?\\nb -> 1(new substring with only 1 character: \"b\")\\ndb -> 1+1\\ncdb -> 2+1\\nbcdb -> 3+0(\\'b\\' already exists don\\'t count again)\\nabcdb -> 4+0\\n```\\n\\'b\\' needs to be counted only after the last occurence\\n```\\nf(4) = f(3)+1+(number of chars between last index of b and cur index)\\n     = 10 + 1+(4-1-1)\\n     = 13\\nf(4) = f(3) + 1 + (4-lastIndex[\\'b\\']-1)\\n     = f(3) + 4 - lastIndex[s[4]]\\n```\\n\\ntherefore formula for f(i) is as following:\\n```\\nf(i): total appeal of all substrings ending at index i\\nf(i) = f(i-1)+(i)-(lastIndex[s[i]])\\nbase case:\\nf(0) = 1\\nans = sum(f(i)) where i = 0 to s.length\\n```\\n**Code:**\\n```\\n/*\\nf(i): total appeal of all substrings ending at index i\\nf(i) = f(i-1)+(i)-(lastIndex[s[i]])\\nbase case:\\nf(0) = 1\\nans = sum(f(i)) where i = 0 to s.length\\n*/\\nclass Solution {\\n    public long appealSum(String s) {\\n        int n = s.length();\\n        // keeps track of the last index of cur character in for loop\\n        int[] lInd = new int[26];\\n        Arrays.fill(lInd, -1);\\n        // dp[i]: total appeal of all substrings ending at index i-1\\n        // here dp is running one step ahead of f defined above\\n        // i.e. dp[i+1] = f(i), dp[0] = 0\\n        long[] dp = new long[n+1];\\n        long res = 0l;\\n        for(int i = 0; i < n; i ++) {\\n            int c = s.charAt(i)-\\'a\\';\\n            dp[i+1] = dp[i]+i-lInd[c];\\n            res += dp[i+1];\\n            // set last index so that it can be used if character \\'c\\' occurs again after ith index \\n            lInd[c] = i;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nSpace complexity can be reduced to O(1) as `f(i)` only depends on `f(i-1)`\\n```\\nclass Solution {\\n    public long appealSum(String s) {\\n        int n = s.length();\\n        int[] lInd = new int[26];\\n        Arrays.fill(lInd, -1);\\n        long dp = 0;\\n        long res = 0l;\\n        for(int i = 0; i < n; i ++) {\\n            int c = s.charAt(i)-\\'a\\';\\n            dp = dp+i-lInd[c];\\n            res += dp;\\n            lInd[c] = i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\ns: abcdb\\ni: 01234\\n```\n```\\nd -> 1\\ncd -> 2\\nbcd -> 3\\nabcd -> 4\\nf(3) = 10\\n```\n```\\nf(4) = ?\\nb -> 1(new substring with only 1 character: \"b\")\\ndb -> 1+1\\ncdb -> 2+1\\nbcdb -> 3+0(\\'b\\' already exists don\\'t count again)\\nabcdb -> 4+0\\n```\n```\\nf(4) = f(3)+1+(number of chars between last index of b and cur index)\\n     = 10 + 1+(4-1-1)\\n     = 13\\nf(4) = f(3) + 1 + (4-lastIndex[\\'b\\']-1)\\n     = f(3) + 4 - lastIndex[s[4]]\\n```\n```\\nf(i): total appeal of all substrings ending at index i\\nf(i) = f(i-1)+(i)-(lastIndex[s[i]])\\nbase case:\\nf(0) = 1\\nans = sum(f(i)) where i = 0 to s.length\\n```\n```\\n/*\\nf(i): total appeal of all substrings ending at index i\\nf(i) = f(i-1)+(i)-(lastIndex[s[i]])\\nbase case:\\nf(0) = 1\\nans = sum(f(i)) where i = 0 to s.length\\n*/\\nclass Solution {\\n    public long appealSum(String s) {\\n        int n = s.length();\\n        // keeps track of the last index of cur character in for loop\\n        int[] lInd = new int[26];\\n        Arrays.fill(lInd, -1);\\n        // dp[i]: total appeal of all substrings ending at index i-1\\n        // here dp is running one step ahead of f defined above\\n        // i.e. dp[i+1] = f(i), dp[0] = 0\\n        long[] dp = new long[n+1];\\n        long res = 0l;\\n        for(int i = 0; i < n; i ++) {\\n            int c = s.charAt(i)-\\'a\\';\\n            dp[i+1] = dp[i]+i-lInd[c];\\n            res += dp[i+1];\\n            // set last index so that it can be used if character \\'c\\' occurs again after ith index \\n            lInd[c] = i;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long appealSum(String s) {\\n        int n = s.length();\\n        int[] lInd = new int[26];\\n        Arrays.fill(lInd, -1);\\n        long dp = 0;\\n        long res = 0l;\\n        for(int i = 0; i < n; i ++) {\\n            int c = s.charAt(i)-\\'a\\';\\n            dp = dp+i-lInd[c];\\n            res += dp;\\n            lInd[c] = i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996219,
                "title": "java-simple-quick-sliding-window-solution-with-detailed-explanation",
                "content": "```    \\n\\t// When there are multiple occurances of the same character in a substring, \\n    // only one occurance of the character contributes to the final result.\\n    // Let\\'s say only the last occurance of a character contributes to the result.\\n    // This algorithm goes through each character of the string, \\n    // and calculates the number of substrings in which this character contributes to the result,\\n    // which equals to the number of substrings containing this character, and not containing the next occurance of the same character. \\n    \\n    public long appealSum(String s) {\\n        // use an array of list to keep track of the indexes of each characters.\\n        ArrayList<Integer>[] indexes = new ArrayList[26];\\n        for(int i = 0; i < 26; i++){\\n            indexes[i] = new ArrayList<>();\\n        }\\n        for(int i = 0; i < s.length(); i++){\\n            indexes[s.charAt(i) - \\'a\\'].add(i);\\n        }\\n        \\n        long total = 0L;\\n        for(List<Integer> index : indexes){\\n            for(int i = 0; i < index.size(); i++){\\n                // the current index.\\n                int curr = index.get(i);\\n                // the index of next occurance of the same character.\\n                int next = i+1 < index.size() ? index.get(i+1) : s.length();\\n                long first = Long.valueOf(curr + 1);\\n                long second = Long.valueOf(next - curr);\\n                // Build substrings using the concept of sliding window. \\n                // There are (curr + 1) options for the left end of the window, and (next - curr) options for the right end of the window.\\n                total += first * second;\\n            }\\n        }\\n        return total;\\n    }",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```    \\n\\t// When there are multiple occurances of the same character in a substring, \\n    // only one occurance of the character contributes to the final result.\\n    // Let\\'s say only the last occurance of a character contributes to the result.\\n    // This algorithm goes through each character of the string, \\n    // and calculates the number of substrings in which this character contributes to the result,\\n    // which equals to the number of substrings containing this character, and not containing the next occurance of the same character. \\n    \\n    public long appealSum(String s) {\\n        // use an array of list to keep track of the indexes of each characters.\\n        ArrayList<Integer>[] indexes = new ArrayList[26];\\n        for(int i = 0; i < 26; i++){\\n            indexes[i] = new ArrayList<>();\\n        }\\n        for(int i = 0; i < s.length(); i++){\\n            indexes[s.charAt(i) - \\'a\\'].add(i);\\n        }\\n        \\n        long total = 0L;\\n        for(List<Integer> index : indexes){\\n            for(int i = 0; i < index.size(); i++){\\n                // the current index.\\n                int curr = index.get(i);\\n                // the index of next occurance of the same character.\\n                int next = i+1 < index.size() ? index.get(i+1) : s.length();\\n                long first = Long.valueOf(curr + 1);\\n                long second = Long.valueOf(next - curr);\\n                // Build substrings using the concept of sliding window. \\n                // There are (curr + 1) options for the left end of the window, and (next - curr) options for the right end of the window.\\n                total += first * second;\\n            }\\n        }\\n        return total;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3561077,
                "title": "c-dp-eas-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long int x = 1, y = 1, k = 0;\\n        vector<int> v(26,-1);//make an array store index of chars\\n\\n        v[s[0]-\\'a\\'] = 1; \\n        // cout<<1<<\" \";\\n        for(int i = 1; i < s.length(); i++){\\n            x += i+1;//x is strore ans till ith index.\\n            if(v[s[i]-\\'a\\'] > 0){//if char previously came than increment and by curr index - pre index\\n                x -= v[s[i]-\\'a\\'];\\n            }\\n            // cout<<x<<\" \";\\n            y += x;\\n            v[s[i]-\\'a\\'] = i+1;//storing index\\n        }\\n        return y;//y is ans variable\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long int x = 1, y = 1, k = 0;\\n        vector<int> v(26,-1);//make an array store index of chars\\n\\n        v[s[0]-\\'a\\'] = 1; \\n        // cout<<1<<\" \";\\n        for(int i = 1; i < s.length(); i++){\\n            x += i+1;//x is strore ans till ith index.\\n            if(v[s[i]-\\'a\\'] > 0){//if char previously came than increment and by curr index - pre index\\n                x -= v[s[i]-\\'a\\'];\\n            }\\n            // cout<<x<<\" \";\\n            y += x;\\n            v[s[i]-\\'a\\'] = i+1;//storing index\\n        }\\n        return y;//y is ans variable\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2379420,
                "title": "c-easy-intuitive-approach-using-hashing-dp",
                "content": "This question was fun. \\n**What this question asks?**\\nWell, this question wants us to find the *appeal* of *all substrings*, where appeal is the count of distinct characters in that particular substring. We have to do this for all substrings of the string. \\nNow, if we start simulating this problem, it will cost us two loops of string length, taking the time complexity to O(n<sup>2</sup>) which is NA here. Now, we need to think better. Think if we could somehow use already calculated answers. DP, we call that. \\n\\n**Why DP?** Well, when you observe some of the test cases carefully, you will see a pattern, where we can actually resuse the already calculated answers. \\nIf we start from the last character of a string, and move towards its beginning, we can make our observations.\\n\\n```\\n\\ts = \"fluqu\"\\n\\texpected ans = 32\\n\\nIn this case, if we start from the end,\\n\\tsubstring         appeal                        Substrings\\n\\t    \"u\"              1                            [\"u\"] \\n\\t\\t\"qu\"             1 + 2                        [\"q\", \"qu\"]\\n\\t\\t\"uqu\"            1 + 2 + 2                    [\"u\", \"uq\", \"uqu\"]\\n\\t\\t\"luqu\"           1 + 2 + 3 + 3                [\"l\", \"lu\", \"luq\", \"luqu\"]\\n\\t\\t\"fluqu\"          1 + 2 + 3 + 4 + 4            [\"f\", \"fl\", \"flu\", \"fluq\", \"fluqu\"]\\n\\nTotal appeal  = 32\\n```\\nNow, if we closely observe this, we can see the pattern, that is, `\"qu\"` is nothing but `q` added in `\"u\"`. \\nSo, if we add `q` in every substring of `\"u\"`, we will have only \"`qu`\" and one substring of alone `q`. If we check their appeal, it\\'d be 2 and 1, ie `unique characters till now + previous answer`. \\nNext iteration, we have `uqu`, so we add `u` to all the previous substrings and 1 \\'u\\' itself. But, `u` has occured before, therefore, unique characters will remain the same when next `u` will be included. But, untill the next nearest `u` comes, we will have unique characters. So, we just need to check where the next nearest `u` occurs and simply add that difference to previous answer, ie `next nearest u + previous answer` \\nIt was just an observation that doing so would include all the substrings of the string and also their appeals. \\n\\n**Time :** Since we are just iterating the string only once and accumulate has a complexity of O(N), therefore, the overall Time complexity of this code would be O(N)\\n**Space :** We have two vectors, one of size 26, and another of size equal to string size, therefore, our space complexity would be O(26+N) ~ O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int n = s.size();\\n\\t\\t// Occur stores the recent occurance of any character and dp stores the answer starting from an index\\n        vector <long long> occur(26,-1),dp(n,0);\\n        \\n        dp[n-1] = 1;\\n        occur[s[n-1]-\\'a\\'] = n-1;\\n\\t\\t\\n        for(int i = n-2; i>=0; i--){\\n           // If this character has not yet occurred\\n\\t\\t   if(occur[s[i]-\\'a\\']!=-1){\\n                dp[i] = dp[i+1] + abs(occur[s[i]-\\'a\\']-i);\\n                occur[s[i]-\\'a\\'] = i;\\n            }\\n            else{\\n\\t\\t\\t\\t// If it has occurred before\\n                occur[s[i]-\\'a\\'] = i;\\n                dp[i] = dp[i+1] + n-i;\\n            }\\n        }\\n        long long ans = accumulate(dp.begin(),dp.end(),0LL);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\ts = \"fluqu\"\\n\\texpected ans = 32\\n\\nIn this case, if we start from the end,\\n\\tsubstring         appeal                        Substrings\\n\\t    \"u\"              1                            [\"u\"] \\n\\t\\t\"qu\"             1 + 2                        [\"q\", \"qu\"]\\n\\t\\t\"uqu\"            1 + 2 + 2                    [\"u\", \"uq\", \"uqu\"]\\n\\t\\t\"luqu\"           1 + 2 + 3 + 3                [\"l\", \"lu\", \"luq\", \"luqu\"]\\n\\t\\t\"fluqu\"          1 + 2 + 3 + 4 + 4            [\"f\", \"fl\", \"flu\", \"fluq\", \"fluqu\"]\\n\\nTotal appeal  = 32\\n```\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int n = s.size();\\n\\t\\t// Occur stores the recent occurance of any character and dp stores the answer starting from an index\\n        vector <long long> occur(26,-1),dp(n,0);\\n        \\n        dp[n-1] = 1;\\n        occur[s[n-1]-\\'a\\'] = n-1;\\n\\t\\t\\n        for(int i = n-2; i>=0; i--){\\n           // If this character has not yet occurred\\n\\t\\t   if(occur[s[i]-\\'a\\']!=-1){\\n                dp[i] = dp[i+1] + abs(occur[s[i]-\\'a\\']-i);\\n                occur[s[i]-\\'a\\'] = i;\\n            }\\n            else{\\n\\t\\t\\t\\t// If it has occurred before\\n                occur[s[i]-\\'a\\'] = i;\\n                dp[i] = dp[i+1] + n-i;\\n            }\\n        }\\n        long long ans = accumulate(dp.begin(),dp.end(),0LL);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072159,
                "title": "c-o-26-n-a-better-approach",
                "content": "basically this question is asking the sum of contributions of each letter in every sub string.\\nfor example let string s be \"abcd\"\\n\\nsubstrings - a, ab, abc, abcd,b,bc,bcd,c,cd,d\\ncontributions of atleast 1 a in the substrings = 4\\nb = 6\\nc = 6\\nd = 4\\n\\ntotal appeal = 4+6+6+4 = 20 which is the answer\\n\\nto find the contribution of a particular character, I\\'ve used this formula:\\ntotal substrings - substrings which does not have that character.\\n\\nHere is the code\\n\\n```\\nclass Solution {\\npublic:\\n   \\n    long long appealSum(string s) {\\n       long long int ans = 0;\\n       long long int cnt = 0;\\n        long long int cts = 0;\\n        string abc = \"abcdefghijklmnopqrstuvwxyz\";\\n      long long int n = s.length();\\n      long long int ts = n*(n+1)/2;\\n        for(int i = 0;i<26;i++){\\n            for(int j = 0;j<n;j++){\\n                if(s[j] == abc[i]){\\n                    cts += cnt*(cnt+1)/2;\\n                    cnt=0;\\n                }\\n                else cnt++;\\n            }\\n            cts+=cnt*(cnt+1)/2;\\n            cnt=0;\\n            ans = ans + ts-cts;\\n            cts=0;\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    long long appealSum(string s) {\\n       long long int ans = 0;\\n       long long int cnt = 0;\\n        long long int cts = 0;\\n        string abc = \"abcdefghijklmnopqrstuvwxyz\";\\n      long long int n = s.length();\\n      long long int ts = n*(n+1)/2;\\n        for(int i = 0;i<26;i++){\\n            for(int j = 0;j<n;j++){\\n                if(s[j] == abc[i]){\\n                    cts += cnt*(cnt+1)/2;\\n                    cnt=0;\\n                }\\n                else cnt++;\\n            }\\n            cts+=cnt*(cnt+1)/2;\\n            cnt=0;\\n            ans = ans + ts-cts;\\n            cts=0;\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996584,
                "title": "javascript-last-tracking-144ms",
                "content": "```\\nconst ord = (c) => c.charCodeAt();\\n\\nconst appealSum = (s) => {\\n    let last = Array(26).fill(0), res = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        last[ord(s[i]) - 97] = i + 1;\\n        for (let j = 0; j < 26; j++) res += last[j];\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst ord = (c) => c.charCodeAt();\\n\\nconst appealSum = (s) => {\\n    let last = Array(26).fill(0), res = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        last[ord(s[i]) - 97] = i + 1;\\n        for (let j = 0; j < 26; j++) res += last[j];\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422481,
                "title": "dp-strore-element-index-easy-to-understand",
                "content": "/*increment ans by char at index i - previous index of char\\nif element first time occur than increment ans by (i+1)*/\\n````\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long int ans = 0;\\n        long long int  tmp = 0;\\n        vector<int> dp(26,-1);\\n        for(int i = 0; i < s.length(); i++){\\n            if(dp[s[i]-\\'a\\']==-1){\\n                ans += (i+1);\\n            }else{\\n                ans += (i-dp[s[i]-\\'a\\']);\\n            }\\n            // cout<<ans<<\" \";\\n            tmp += ans;\\n            dp[s[i]-\\'a\\'] = i;\\n        }\\n        // cout<<endl;\\n        return tmp;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long int ans = 0;\\n        long long int  tmp = 0;\\n        vector<int> dp(26,-1);\\n        for(int i = 0; i < s.length(); i++){\\n            if(dp[s[i]-\\'a\\']==-1){\\n                ans += (i+1);\\n            }else{\\n                ans += (i-dp[s[i]-\\'a\\']);\\n            }\\n            // cout<<ans<<\" \";\\n            tmp += ans;\\n            dp[s[i]-\\'a\\'] = i;\\n        }\\n        // cout<<endl;\\n        return tmp;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2678490,
                "title": "concise-python-o-n-solution-with-explanations",
                "content": "We can calculate the occurence of each letter separately. For example, let\\'s only focus on letter `a` and assume the layout of letter `a` is like this:\\n```\\nIndex: -1 ... i ... j ... k ... L\\ns: ... a ... a ... a...\\n```\\nAssume there are three `a` in `s`, and their indexes are `i, j, k` respectively. I also put `-1` and `L = len(s)` in the graph as the left boundary and right boundary for better understanding.\\nTherefore, to calculate how many times that `a` contributes to the final answer, which is the `Appeal`, we can think like this:\\n1). If only consider the sub-string that `a` occurs once, the total number of sub-string should be `(i - (-1)) * (j - i)` + `(j - i) * (k - j) + (k - j ) * (L - k)`. \\n2). If only consider the sub-string that `a` occurs twice, the total number is `(i - (-1)) * (k - j) + (j - i) * (L - k)`.\\n3). If consider the sub-string that `a` occurs tripple times, the total number is `(i - (-1)) * (L - k)`.\\nNow let\\'s accumulate the above three formulas and merge the same items, we will get the final formula `(i - (-1)) * (L - i) + (j - i) * (L - j) + (k - j) * (L - k)`. So the answer is pretty straightforward now, for each character, we simply accumulate the product of `\"current index\" - \"prev index\"` and `\"length of s\" - \"current index\"`.\\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        prev, res, l = [-1] * 26, 0, len(s)\\n        for i, c in enumerate(s):\\n            index = ord(c) - 97\\n            res += (i - prev[index]) * (l - i)\\n            prev[index] = i\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nIndex: -1 ... i ... j ... k ... L\\ns: ... a ... a ... a...\\n```\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        prev, res, l = [-1] * 26, 0, len(s)\\n        for i, c in enumerate(s):\\n            index = ord(c) - 97\\n            res += (i - prev[index]) * (l - i)\\n            prev[index] = i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092411,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        vector<int>lookUp(26, -1);\\n        long long result = 0;\\n        int n = s.length();\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            result += (i - lookUp[s[i] - \\'a\\'])*(n - i);\\n            lookUp[s[i] - \\'a\\'] = i;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        vector<int>lookUp(26, -1);\\n        long long result = 0;\\n        int n = s.length();\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            result += (i - lookUp[s[i] - \\'a\\'])*(n - i);\\n            lookUp[s[i] - \\'a\\'] = i;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066787,
                "title": "linear-dp",
                "content": "![image](https://assets.leetcode.com/users/images/b9b81117-c3f2-475f-9890-1f9b11e826ba_1653310825.8118174.jpeg)\\n![image](https://assets.leetcode.com/users/images/e2989444-ac3c-4b44-85eb-ba602e485b54_1653310837.286044.jpeg)\\nsry for a mistake in images dp[0]=1;\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long appealSum(string s) {\\n        \\n        int n=s.length();\\n        int dp[n];\\n        dp[0]=1;\\n        int last[26];\\n        memset(last,-1,sizeof(last));\\n        last[s[0]-\\'a\\']=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=dp[i-1]+1+i;\\n            if(last[s[i]-\\'a\\']!=-1)\\n            {\\n                dp[i]-=(last[s[i]-\\'a\\']+1);\\n            }\\n            last[s[i]-\\'a\\']=i;\\n        }\\n      \\n        ll sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n            sum+=dp[i];\\n        \\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long appealSum(string s) {\\n        \\n        int n=s.length();\\n        int dp[n];\\n        dp[0]=1;\\n        int last[26];\\n        memset(last,-1,sizeof(last));\\n        last[s[0]-\\'a\\']=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=dp[i-1]+1+i;\\n            if(last[s[i]-\\'a\\']!=-1)\\n            {\\n                dp[i]-=(last[s[i]-\\'a\\']+1);\\n            }\\n            last[s[i]-\\'a\\']=i;\\n        }\\n      \\n        ll sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n            sum+=dp[i];\\n        \\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039548,
                "title": "java-o-n-time-o-1-space-with-explaination",
                "content": "the key to resolve this problem is that to undertsand how to calculate  subarrays of one character. It is easy if we know every one character\\'s subarrays. Then the result is the sum of all subarrays of every unique character.\\n\\nthere is an equation, (curentIdx-leftedge)(rightedge-curentIdx) = total subarrays of the char. \\n\\nMoverover, the second issue is how to remove the repeat chars. There is common approach it to only count the char from left side. so we need to record the last left side position of the char.* \\n\\'\\'\\'\\npublic long appealSum(String s) {\\n        if(s==null || s.length() ==0){\\n            return 0;\\n        }\\n        \\n        int len = s.length();\\n        int[] lastPos = new int[26];\\n        Arrays.fill(lastPos,-1);\\n        long res = 0;\\n        for(int i = 0; i < len; i++){\\n            int idx = s.charAt(i)-\\'a\\';\\n            res += (i-lastPos[idx]) * (len-i);    \\n            lastPos[idx] = i;\\n        }\\n        \\n        return res;\\n    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "the key to resolve this problem is that to undertsand how to calculate  subarrays of one character. It is easy if we know every one character\\'s subarrays. Then the result is the sum of all subarrays of every unique character.\\n\\nthere is an equation, (curentIdx-leftedge)(rightedge-curentIdx) = total subarrays of the char. \\n\\nMoverover, the second issue is how to remove the repeat chars. There is common approach it to only count the char from left side. so we need to record the last left side position of the char.* \\n\\'\\'\\'\\npublic long appealSum(String s) {\\n        if(s==null || s.length() ==0){\\n            return 0;\\n        }\\n        \\n        int len = s.length();\\n        int[] lastPos = new int[26];\\n        Arrays.fill(lastPos,-1);\\n        long res = 0;\\n        for(int i = 0; i < len; i++){\\n            int idx = s.charAt(i)-\\'a\\';\\n            res += (i-lastPos[idx]) * (len-i);    \\n            lastPos[idx] = i;\\n        }\\n        \\n        return res;\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2014150,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) similar to Kadane\\'s algorithm, we return the accumulated sum of \"best solutions ending here\" for each `j`<sup>th</sup> index of the input string `s`.\\n\\nPerform a linear scan of the input string `s` and consider the \"best solutions ending here\" for all substrings ending at each `j`<sup>th</sup> index, ie. there are `j + 1` substrings ending at each index `j`, and we want to count the amount of those substrings which do *not* contain the character `s[j]` because those are the substrings which each contribute +1 onto the total `appeal`.  Thus we use a map `m` to store each previously seen index `i` of each character `s[j]` (default to `-1` if `s[j]` has *not* been seen).  Then the amount of substrings ending at `j` which do *not* contain the character `s[j]` is `j - i` and we add this `appeal` onto the `appeal` of the previous solution ending at `j - 1`.\\n\\n**Iteratively Improved Solutions:**\\n\\n1. brute-force O(N<sup>2</sup>) solution: TLE\\n\\t* starting at each `i`<sup>th</sup> start index from `0..N - 1` inclusive for each `k`<sup>th</sup> length from `1..N` inclusive\\n2. dp solution O(N) memory: AC\\n\\t* use the past to formulate the future: `dp[j] = dp[j - 1] + additional appeal with s[j]`\\n3. dp solution O(1) memory: AC\\n\\t* use the past to formulate the future: `total += current = previous + additional appeal with s[j]`\\n\\n**How do we \"see\" the recurrence relation? (write down examples and figure it out)**\\n\\n![image](https://assets.leetcode.com/users/images/f20acfc1-90fd-4e93-9e12-e78d435e8d76_1651850290.5758176.png)\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n*1. brute-force O(N<sup>2</sup>) solution: TLE*\\n```\\nclass Solution {\\n    fun appealSum(s: String): Long {\\n        var t = 0L\\n        var N = s.length\\n        for (i in 0 until N) {\\n            for (k in 1..N) {\\n                if (i + k <= N) {\\n                    var seen = s.substring(i, i + k).toSet()\\n                    t += seen.size\\n                }\\n            }\\n        }\\n        return t\\n    }\\n}\\n```\\n\\n*2. dp solution O(N) memory: AC*\\n```\\nclass Solution {\\n    fun appealSum(s: String): Long {\\n        var N = s.length\\n        var dp = LongArray(N) { 0L }\\n        dp[0] = 1\\n        var m = mutableMapOf<Char, Int>(Pair(s[0], 0))\\n        for (j in 1 until N) {\\n            var i = m[s[j]] ?: -1; m[s[j]] = j\\n            var appeal = j - i\\n            dp[j] = dp[j - 1] + appeal\\n        }\\n        return dp.sum()\\n    }\\n}\\n```\\n\\n*3. dp solution O(1) memory: AC*\\n```\\nclass Solution {\\n    fun appealSum(s: String): Long {\\n        var N = s.length\\n        var t = 1L\\n        var (pre, cur) = Pair(1L, 0L)\\n        var m = mutableMapOf<Char, Int>(Pair(s[0], 0))\\n        for (j in 1 until N) {\\n            var i = m[s[j]] ?: -1; m[s[j]] = j\\n            var appeal = j - i\\n            cur = pre + appeal; pre = cur\\n            t += cur\\n        }\\n        return t\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n*1. brute-force O(N<sup>2</sup>) solution: TLE*\\n```\\nlet appealSum = (s, t = 0) => {\\n    let N = s.length;\\n    for (let i = 0; i < N; ++i) {\\n        for (let k = 1; i + k <= N; ++k) {\\n            let seen = new Set(s.substr(i, k).split(\\'\\'));\\n            t += seen.size;\\n        }\\n    }\\n    return t;\\n};\\n```\\n\\n*2. dp solution O(N) memory: AC*\\n```\\nlet appealSum = (s, m = new Map([[s[0], 0]])) => {\\n    let N = s.length;\\n    let dp = Array(N).fill(0);\\n    dp[0] = 1;\\n    for (let j = 1; j < N; ++j) {\\n        let i = m.has(s[j]) ? m.get(s[j]) : -1; m.set(s[j], j);\\n        let appeal = j - i;\\n        dp[j] = dp[j - 1] + appeal;\\n    }\\n    return _.sum(dp);\\n};\\n```\\n\\n*3. dp solution O(1) memory: AC*\\n```\\nlet appealSum = (s, m = new Map([[s[0], 0]]), t = 1) => {\\n    let N = s.length;\\n    let [pre, cur] = [1, 0];\\n    for (let j = 1; j < N; ++j) {\\n        let i = m.has(s[j]) ? m.get(s[j]) : -1; m.set(s[j], j);\\n        let appeal = j - i;\\n        t += cur = pre + appeal, pre = cur;\\n    }\\n    return t;\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n*1. brute-force O(N<sup>2</sup>) solution: TLE*\\n```\\nclass Solution:\\n    def appealSum(self, s: str, t = 0) -> int:\\n        N = len(s)\\n        for i in range(N):\\n            for k in range(1, N + 1):\\n                if i + k <= N:\\n                    seen = set(list(s[i:i + k]))\\n                    t += len(seen)\\n        return t\\n```\\n\\n*2. dp solution O(N) memory: AC*\\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        m = { s[0]: 0 }\\n        N = len(s)\\n        dp = [0] * N\\n        dp[0] = 1\\n        for j in range(1, N):\\n            i = m[s[j]] if s[j] in m else -1; m[s[j]] = j\\n            appeal = j - i\\n            dp[j] = dp[j - 1] + appeal\\n        return sum(dp)\\n```\\n\\n*3. dp solution O(1) memory: AC*\\n```\\nclass Solution:\\n    def appealSum(self, s: str, t = 1) -> int:\\n        m = { s[0]: 0 }\\n        N = len(s)\\n        pre, cur = 1, 0\\n        for j in range(1, N):\\n            i = m[s[j]] if s[j] in m else -1; m[s[j]] = j\\n            appeal = j - i\\n            cur = pre + appeal; pre = cur\\n            t += cur\\n        return t\\n```\\n\\n---\\n\\n**Rust Solutions:**\\n\\n*1. brute-force O(N<sup>2</sup>) solution: TLE*\\n```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn appeal_sum(s: String) -> i64 {\\n        let mut t: i64 = 0;\\n        let s: Vec<char> = s.chars().collect();\\n        let N = s.len();\\n        for i in 0..N {\\n            for k in 1..=N {\\n                if i + k <= N {\\n                    let mut seen = HashSet::new();\\n                    for j in 0..k {\\n                        seen.insert(s[i + j]);\\n                    }\\n                    t += seen.len() as i64;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n}\\n```\\n\\n*2. dp solution O(N) memory: AC*\\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn appeal_sum(s: String) -> i64 {\\n        let s: Vec<char> = s.chars().collect();\\n        let N = s.len();\\n        let mut m = HashMap::<char, i64>::new();\\n        m.insert(s[0], 0);\\n        let mut dp = vec![0 as i64; N];\\n        dp[0] = 1;\\n        for j in 1..N {\\n            let i: i64 = *m.entry(s[j]).or_insert(-1); m.insert(s[j], j as i64);\\n            let appeal = j as i64 - i;\\n            dp[j] = dp[j - 1] + appeal;\\n        }\\n        return dp.iter().sum();\\n    }\\n}\\n```\\n\\n*3. dp solution O(1) memory: AC*\\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn appeal_sum(s: String) -> i64 {\\n        let mut t: i64 = 1;\\n        let s: Vec<char> = s.chars().collect();\\n        let N = s.len();\\n        let mut m = HashMap::<char, i64>::new();\\n        m.insert(s[0], 0);\\n        let (mut pre, mut cur) = (1 as i64, 0 as i64);\\n        for j in 1..N {\\n            let i: i64 = *m.entry(s[j]).or_insert(-1); m.insert(s[j], j as i64);\\n            let appeal = j as i64 - i;\\n            cur = pre + appeal; pre = cur;\\n            t += cur;\\n        }\\n        return t;\\n    }\\n}\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n*1. brute-force O(N<sup>2</sup>) solution: TLE*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using Set = unordered_set<char>;\\n    LL appealSum(string s, LL t = 0) {\\n        int N = s.size();\\n        for (auto i{ 0 }; i < N; ++i) {\\n            for (auto k{ 1 }; i + k <= N; ++k) {\\n                Set seen; copy(s.begin() + i, s.begin() + i + k, inserter(seen, seen.end()));\\n                t += seen.size();\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```\\n\\n*2. dp solution O(N) memory: AC*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using Map = unordered_map<char, int>;\\n    LL appealSum(string s) {\\n        Map m{{ s[0], 0 }};\\n        int N = s.size();\\n        VL dp(N);\\n        dp[0] = 1;\\n        for (auto j{ 1 }; j < N; ++j) {\\n            auto i = m.find(s[j]) != m.end() ? m[s[j]] : -1; m[s[j]] = j;\\n            auto appeal = j - i;\\n            dp[j] = dp[j - 1] + appeal;\\n        }\\n        return accumulate(dp.begin(), dp.end(), 0LL);\\n    }\\n};\\n```\\n\\n*3. dp solution O(1) memory: AC*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using Map = unordered_map<char, int>;\\n    LL appealSum(string s, LL t = 1) {\\n        Map m{{ s[0], 0 }};\\n        int N = s.size();\\n        auto [pre, cur] = make_pair(1, 0);\\n        for (auto j{ 1 }; j < N; ++j) {\\n            auto i = m.find(s[j]) != m.end() ? m[s[j]] : -1; m[s[j]] = j;\\n            auto appeal = j - i;\\n            t += cur = pre + appeal, pre = cur;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun appealSum(s: String): Long {\\n        var t = 0L\\n        var N = s.length\\n        for (i in 0 until N) {\\n            for (k in 1..N) {\\n                if (i + k <= N) {\\n                    var seen = s.substring(i, i + k).toSet()\\n                    t += seen.size\\n                }\\n            }\\n        }\\n        return t\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun appealSum(s: String): Long {\\n        var N = s.length\\n        var dp = LongArray(N) { 0L }\\n        dp[0] = 1\\n        var m = mutableMapOf<Char, Int>(Pair(s[0], 0))\\n        for (j in 1 until N) {\\n            var i = m[s[j]] ?: -1; m[s[j]] = j\\n            var appeal = j - i\\n            dp[j] = dp[j - 1] + appeal\\n        }\\n        return dp.sum()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun appealSum(s: String): Long {\\n        var N = s.length\\n        var t = 1L\\n        var (pre, cur) = Pair(1L, 0L)\\n        var m = mutableMapOf<Char, Int>(Pair(s[0], 0))\\n        for (j in 1 until N) {\\n            var i = m[s[j]] ?: -1; m[s[j]] = j\\n            var appeal = j - i\\n            cur = pre + appeal; pre = cur\\n            t += cur\\n        }\\n        return t\\n    }\\n}\\n```\n```\\nlet appealSum = (s, t = 0) => {\\n    let N = s.length;\\n    for (let i = 0; i < N; ++i) {\\n        for (let k = 1; i + k <= N; ++k) {\\n            let seen = new Set(s.substr(i, k).split(\\'\\'));\\n            t += seen.size;\\n        }\\n    }\\n    return t;\\n};\\n```\n```\\nlet appealSum = (s, m = new Map([[s[0], 0]])) => {\\n    let N = s.length;\\n    let dp = Array(N).fill(0);\\n    dp[0] = 1;\\n    for (let j = 1; j < N; ++j) {\\n        let i = m.has(s[j]) ? m.get(s[j]) : -1; m.set(s[j], j);\\n        let appeal = j - i;\\n        dp[j] = dp[j - 1] + appeal;\\n    }\\n    return _.sum(dp);\\n};\\n```\n```\\nlet appealSum = (s, m = new Map([[s[0], 0]]), t = 1) => {\\n    let N = s.length;\\n    let [pre, cur] = [1, 0];\\n    for (let j = 1; j < N; ++j) {\\n        let i = m.has(s[j]) ? m.get(s[j]) : -1; m.set(s[j], j);\\n        let appeal = j - i;\\n        t += cur = pre + appeal, pre = cur;\\n    }\\n    return t;\\n};\\n```\n```\\nclass Solution:\\n    def appealSum(self, s: str, t = 0) -> int:\\n        N = len(s)\\n        for i in range(N):\\n            for k in range(1, N + 1):\\n                if i + k <= N:\\n                    seen = set(list(s[i:i + k]))\\n                    t += len(seen)\\n        return t\\n```\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        m = { s[0]: 0 }\\n        N = len(s)\\n        dp = [0] * N\\n        dp[0] = 1\\n        for j in range(1, N):\\n            i = m[s[j]] if s[j] in m else -1; m[s[j]] = j\\n            appeal = j - i\\n            dp[j] = dp[j - 1] + appeal\\n        return sum(dp)\\n```\n```\\nclass Solution:\\n    def appealSum(self, s: str, t = 1) -> int:\\n        m = { s[0]: 0 }\\n        N = len(s)\\n        pre, cur = 1, 0\\n        for j in range(1, N):\\n            i = m[s[j]] if s[j] in m else -1; m[s[j]] = j\\n            appeal = j - i\\n            cur = pre + appeal; pre = cur\\n            t += cur\\n        return t\\n```\n```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn appeal_sum(s: String) -> i64 {\\n        let mut t: i64 = 0;\\n        let s: Vec<char> = s.chars().collect();\\n        let N = s.len();\\n        for i in 0..N {\\n            for k in 1..=N {\\n                if i + k <= N {\\n                    let mut seen = HashSet::new();\\n                    for j in 0..k {\\n                        seen.insert(s[i + j]);\\n                    }\\n                    t += seen.len() as i64;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n}\\n```\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn appeal_sum(s: String) -> i64 {\\n        let s: Vec<char> = s.chars().collect();\\n        let N = s.len();\\n        let mut m = HashMap::<char, i64>::new();\\n        m.insert(s[0], 0);\\n        let mut dp = vec![0 as i64; N];\\n        dp[0] = 1;\\n        for j in 1..N {\\n            let i: i64 = *m.entry(s[j]).or_insert(-1); m.insert(s[j], j as i64);\\n            let appeal = j as i64 - i;\\n            dp[j] = dp[j - 1] + appeal;\\n        }\\n        return dp.iter().sum();\\n    }\\n}\\n```\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn appeal_sum(s: String) -> i64 {\\n        let mut t: i64 = 1;\\n        let s: Vec<char> = s.chars().collect();\\n        let N = s.len();\\n        let mut m = HashMap::<char, i64>::new();\\n        m.insert(s[0], 0);\\n        let (mut pre, mut cur) = (1 as i64, 0 as i64);\\n        for j in 1..N {\\n            let i: i64 = *m.entry(s[j]).or_insert(-1); m.insert(s[j], j as i64);\\n            let appeal = j as i64 - i;\\n            cur = pre + appeal; pre = cur;\\n            t += cur;\\n        }\\n        return t;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using Set = unordered_set<char>;\\n    LL appealSum(string s, LL t = 0) {\\n        int N = s.size();\\n        for (auto i{ 0 }; i < N; ++i) {\\n            for (auto k{ 1 }; i + k <= N; ++k) {\\n                Set seen; copy(s.begin() + i, s.begin() + i + k, inserter(seen, seen.end()));\\n                t += seen.size();\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using Map = unordered_map<char, int>;\\n    LL appealSum(string s) {\\n        Map m{{ s[0], 0 }};\\n        int N = s.size();\\n        VL dp(N);\\n        dp[0] = 1;\\n        for (auto j{ 1 }; j < N; ++j) {\\n            auto i = m.find(s[j]) != m.end() ? m[s[j]] : -1; m[s[j]] = j;\\n            auto appeal = j - i;\\n            dp[j] = dp[j - 1] + appeal;\\n        }\\n        return accumulate(dp.begin(), dp.end(), 0LL);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using Map = unordered_map<char, int>;\\n    LL appealSum(string s, LL t = 1) {\\n        Map m{{ s[0], 0 }};\\n        int N = s.size();\\n        auto [pre, cur] = make_pair(1, 0);\\n        for (auto j{ 1 }; j < N; ++j) {\\n            auto i = m.find(s[j]) != m.end() ? m[s[j]] : -1; m[s[j]] = j;\\n            auto appeal = j - i;\\n            t += cur = pre + appeal, pre = cur;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996969,
                "title": "java-count-characters",
                "content": "```\\nclass Solution {\\n    public static long appealSum(String s) {\\n   \\t\\tlong sum = 0;\\n        \\n\\t\\tlong total = (long)s.length() * (s.length() + 1) / 2;\\n        total =total *26;\\n\\n\\t\\tfor (char i = \\'a\\'; i <= \\'z\\'; i++) {\\n\\t\\t\\tsum += helper(i, s);\\n\\t\\t}\\n\\t\\treturn total - sum;\\n\\t}\\n\\n\\tpublic static long helper(char ch, String s) {\\n\\t\\tlong count = 0;\\n\\t\\tlong res = 0;\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tif (s.charAt(i) == ch) {\\n\\t\\t\\t\\tres += (count) * (count + 1) / 2;\\n\\t\\t\\t\\tcount = 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres += (count) * (count + 1) / 2;\\n\\t\\treturn res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static long appealSum(String s) {\\n   \\t\\tlong sum = 0;\\n        \\n\\t\\tlong total = (long)s.length() * (s.length() + 1) / 2;\\n        total =total *26;\\n\\n\\t\\tfor (char i = \\'a\\'; i <= \\'z\\'; i++) {\\n\\t\\t\\tsum += helper(i, s);\\n\\t\\t}\\n\\t\\treturn total - sum;\\n\\t}\\n\\n\\tpublic static long helper(char ch, String s) {\\n\\t\\tlong count = 0;\\n\\t\\tlong res = 0;\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tif (s.charAt(i) == ch) {\\n\\t\\t\\t\\tres += (count) * (count + 1) / 2;\\n\\t\\t\\t\\tcount = 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres += (count) * (count + 1) / 2;\\n\\t\\treturn res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996330,
                "title": "python-hashtable-one-pass-o-n-with-illustration",
                "content": "![image](https://assets.leetcode.com/users/images/e4d3d6b7-e6ba-466c-8861-0fde02d88ac6_1651377776.9508905.png)\\n\\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        prev = {}\\n        total, curr = 0, 0\\n        for i, c in enumerate(s):\\n            if c in prev:\\n                curr += i + 1 - (prev[c])\\n                prev[c] = (i + 1)\\n            else:\\n                prev[c] = (i+1)\\n                curr += i + 1\\n            total += curr\\n        return total\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        prev = {}\\n        total, curr = 0, 0\\n        for i, c in enumerate(s):\\n            if c in prev:\\n                curr += i + 1 - (prev[c])\\n                prev[c] = (i + 1)\\n            else:\\n                prev[c] = (i+1)\\n                curr += i + 1\\n            total += curr\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136900,
                "title": "store-previous-index-95-faster-simple-easy-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long int ans = 1,k=1;\\n        vector<int> v(26,0);\\n        // cout<<ans<<\"#\"<<k<<\" \";\\n        v[s[0]-\\'a\\'] = 1;\\n        for(int i = 1; i < s.length(); i++){\\n            if(s[i] == s[i-1]){\\n                k++;\\n                ans += k;\\n            }else{\\n                k += i+1;\\n                k -= v[s[i]-\\'a\\'];\\n                ans += k;\\n            }\\n            v[s[i]-\\'a\\'] = i+1;\\n            // cout<<ans<<\"#\"<<k<<\" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long int ans = 1,k=1;\\n        vector<int> v(26,0);\\n        // cout<<ans<<\"#\"<<k<<\" \";\\n        v[s[0]-\\'a\\'] = 1;\\n        for(int i = 1; i < s.length(); i++){\\n            if(s[i] == s[i-1]){\\n                k++;\\n                ans += k;\\n            }else{\\n                k += i+1;\\n                k -= v[s[i]-\\'a\\'];\\n                ans += k;\\n            }\\n            v[s[i]-\\'a\\'] = i+1;\\n            // cout<<ans<<\"#\"<<k<<\" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2963728,
                "title": "python3-solution-dp-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def appealSum(self, s):\\n        dp = [-1] * 26\\n        ans = cur = 0\\n        for e, i in enumerate(s):\\n            j = ord(i) - 97\\n            cur += e - dp[j]\\n            ans += cur\\n            dp[j] = e\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def appealSum(self, s):\\n        dp = [-1] * 26\\n        ans = cur = 0\\n        for e, i in enumerate(s):\\n            j = ord(i) - 97\\n            cur += e - dp[j]\\n            ans += cur\\n            dp[j] = e\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600657,
                "title": "javascript-single-pass-detailed-comments-faster-than-90-hashmap",
                "content": "We know that the first letter can\\'t be seen before, so the first letter has it\\'s contribution \\nof (n-i), where n is the size of the string.\\nE.g: \\n\\t\"abbaba\" -> starting from the \"a\", this letter is unique at least 6 times (n-i);\\n     \" bbaba\" -> starting from the \"b\", this letter is unique at least 5 times (n-i);\\n     \"  baba\" -> starting from the second \"b\", this letter is unique at least 4 times (n-i);\\n     \"   aba\" -> starting from the second \"a\", this letter is unique at least 3 times (n-i);\\n     \"    ba\" -> starting from the third \"b\", this letter is unique at least 2 times (n-i);\\n     \"     a\" -> starting from the third \"a\", this letter is unique at least 1 time (n-i);\\n\\nThe catch is \"bb\" count as 1 appeal.\\n\\nSo we need to know, how many strings started before the current letter that DIDN\\'T have that letter\\nthat\\'s why we neeed the previous array to know the previous idx of the current letter:\\n \"abbaba\" => prev = [-1, -1, 1, 0, 2 ,3]\\nE.g: \"abbaba\" -> starting from the \"a\", this letter is unique at least 6 times (n-i), but for strings betwen (previous + 1) and current idx (i - (prev + 1)) =>  6 * (0 - (-1+1) ) = 0;\\n     \" bbaba\" -> starting from the \"b\", this letter is unique at least 5 times (n-i) but for strings betwen (previous + 1) and current idx (i - (prev + 1)) =>  5 * (1 - (-1+1) ) = 5;\\n     \"  baba\" -> starting from the second \"b\", this letter is unique at least 4 times (n-i) but for strings betwen (previous + 1) and current idx (i - (prev + 1)) =>  4* (2 - (1+1) ) = 0;\\n     \"   aba\" -> starting from the second \"a\", this letter is unique at least 3 times (n-i) but for strings betwen (previous + 1) and current idx (i - (prev + 1)) =>  3 * (3 - (0+1) ) = 6;\\n     \"    ba\" -> starting from the third \"b\", this letter is unique at least 2 times (n-i) but for strings betwen (previous + 1) and current idx (i - (prev + 1)) =>  2 * (4 - (2+1) ) = 4;\\n     \"     a\" -> starting from the third \"a\", this letter is unique at least 1 time (n-i) but for strings betwen (previous + 1) and current idx (i - (prev + 1)) =>  1 * (5 - (3+1) ) = 1;\\n\\t \\nThis way we calculated the contribution of every letter, the sum of every contribution is the result.\\n\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar appealSum = function (s) {\\n    //First lets find out the range where every letter is unique,\\n    //using a hashmap to do it in O(N)\\n    let previousRepeated = getRepeated(s); //We can do this in a single pass, but is less readable\\n    //Now for every letter, lets calculate it\\'s unique contribution as unique.\\n    let result = 0;\\n    const n = s.length;\\n    for (let i = 0; i < s.length; i++) {\\n        //We know that the first letter can\\'t be seen before, so the first letter has it\\'s contribution \\n        //of (n-i).\\n        //E.g: \"abbaba\" -> starting from the \"a\", this letter is unique at least 6 times (n-i);\\n        //     \" bbaba\" -> starting from the \"b\", this letter is unique at least 5 times (n-i);\\n        //     \"  baba\" -> starting from the second \"b\", this letter is unique at least 4 times (n-i);\\n        //     \"   aba\" -> starting from the second \"a\", this letter is unique at least 3 times (n-i);\\n        //     \"    ba\" -> starting from the third \"b\", this letter is unique at least 2 times (n-i);\\n        //     \"     a\" -> starting from the third \"a\", this letter is unique at least 1 time (n-i);\\n        const numberOfStringsStartingFromHere = (n - i);\\n        //Now we need to know, how many string started before the current letter that DIDN\\'T have that letter\\n        //that\\'s why we neeed the previous array to know the previous idx of the current letter:\\n        // \"abbaba\" => prev = [-1, -1, 1, 0, 2 ,3]\\n        //E.g: \"abbaba\" -> starting from the \"a\", this letter is unique at least 6 times (n-i), but for strings betwen (previous + 1) and current idx (i - (prev + 1)) =>  6 * (0 - (-1+1) ) = 0;\\n        //     \" bbaba\" -> starting from the \"b\", this letter is unique at least 5 times (n-i) but for strings betwen (previous + 1) and current idx (i - (prev + 1)) =>  5 * (1 - (-1+1) ) = 5;\\n        //     \"  baba\" -> starting from the second \"b\", this letter is unique at least 4 times (n-i) but for strings betwen (previous + 1) and current idx (i - (prev + 1)) =>  4* (2 - (1+1) ) = 0;\\n        //     \"   aba\" -> starting from the second \"a\", this letter is unique at least 3 times (n-i) but for strings betwen (previous + 1) and current idx (i - (prev + 1)) =>  3 * (3 - (0+1) ) = 6;\\n        //     \"    ba\" -> starting from the third \"b\", this letter is unique at least 2 times (n-i) but for strings betwen (previous + 1) and current idx (i - (prev + 1)) =>  2 * (4 - (2+1) ) = 4;\\n        //     \"     a\" -> starting from the third \"a\", this letter is unique at least 1 time (n-i) but for strings betwen (previous + 1) and current idx (i - (prev + 1)) =>  1 * (5 - (3+1) ) = 1;\\n\\n        //This allow us to count \"bb\" as 1 contribution for the first b, \"bbab\" as 1 contribution for the first be\\n        // and \"bab\" as 1 contribution\\n        const numberOfStringsStartedWithoutPrevious = (n - i) * (i - ( previousRepeated[i] + 1) );\\n\\n        const totalContribution = numberOfStringsStartingFromHere + numberOfStringsStartedWithoutPrevious;\\n        result += totalContribution;\\n    }\\n\\n    return result;\\n};\\nfunction getRepeated(s) {\\n    let previousRepeated = Array(s.length).fill(-1);\\n    let seen = new Map();\\n    for (let i = 0; i < s.length; i++) {\\n        const letter = s[i];\\n        if (seen.has(letter)) {\\n            const previousIdx = seen.get(letter);\\n            previousRepeated[i] = previousIdx;\\n        }\\n        seen.set(letter, i);\\n    }\\n    return previousRepeated;\\n}\\n\\n//appealSum(\"abbaba\")\\n```\\n\\n\\nIf you like to do it in one pass, and save some memory:\\n\\n\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar appealSum = function (s) {\\n    let result = 0;\\n    const n = s.length;\\n\\n    let seen = new Map();\\n\\n    for (let i = 0; i < s.length; i++) {\\n        const letter = s[i];\\n        let previousRepeated = -1;\\n        if (seen.has(letter)) {\\n            previousRepeated = seen.get(letter);\\n        }\\n        seen.set(letter, i);\\n\\n        const numberOfStringsStartingFromHere = (n - i);\\n        const numberOfStringsStartedWithoutPrevious = (n - i) * (i - ( previousRepeated + 1) );\\n        const totalContribution = numberOfStringsStartingFromHere + numberOfStringsStartedWithoutPrevious;\\n        result += totalContribution;\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar appealSum = function (s) {\\n    //First lets find out the range where every letter is unique,\\n    //using a hashmap to do it in O(N)\\n    let previousRepeated = getRepeated(s); //We can do this in a single pass, but is less readable\\n    //Now for every letter, lets calculate it\\'s unique contribution as unique.\\n    let result = 0;\\n    const n = s.length;\\n    for (let i = 0; i < s.length; i++) {\\n        //We know that the first letter can\\'t be seen before, so the first letter has it\\'s contribution \\n        //of (n-i).\\n        //E.g: \"abbaba\" -> starting from the \"a\", this letter is unique at least 6 times (n-i);\\n        //     \" bbaba\" -> starting from the \"b\", this letter is unique at least 5 times (n-i);\\n        //     \"  baba\" -> starting from the second \"b\", this letter is unique at least 4 times (n-i);\\n        //     \"   aba\" -> starting from the second \"a\", this letter is unique at least 3 times (n-i);\\n        //     \"    ba\" -> starting from the third \"b\", this letter is unique at least 2 times (n-i);\\n        //     \"     a\" -> starting from the third \"a\", this letter is unique at least 1 time (n-i);\\n        const numberOfStringsStartingFromHere = (n - i);\\n        //Now we need to know, how many string started before the current letter that DIDN\\'T have that letter\\n        //that\\'s why we neeed the previous array to know the previous idx of the current letter:\\n        // \"abbaba\" => prev = [-1, -1, 1, 0, 2 ,3]\\n        //E.g: \"abbaba\" -> starting from the \"a\", this letter is unique at least 6 times (n-i), but for strings betwen (previous + 1) and current idx (i - (prev + 1)) =>  6 * (0 - (-1+1) ) = 0;\\n        //     \" bbaba\" -> starting from the \"b\", this letter is unique at least 5 times (n-i) but for strings betwen (previous + 1) and current idx (i - (prev + 1)) =>  5 * (1 - (-1+1) ) = 5;\\n        //     \"  baba\" -> starting from the second \"b\", this letter is unique at least 4 times (n-i) but for strings betwen (previous + 1) and current idx (i - (prev + 1)) =>  4* (2 - (1+1) ) = 0;\\n        //     \"   aba\" -> starting from the second \"a\", this letter is unique at least 3 times (n-i) but for strings betwen (previous + 1) and current idx (i - (prev + 1)) =>  3 * (3 - (0+1) ) = 6;\\n        //     \"    ba\" -> starting from the third \"b\", this letter is unique at least 2 times (n-i) but for strings betwen (previous + 1) and current idx (i - (prev + 1)) =>  2 * (4 - (2+1) ) = 4;\\n        //     \"     a\" -> starting from the third \"a\", this letter is unique at least 1 time (n-i) but for strings betwen (previous + 1) and current idx (i - (prev + 1)) =>  1 * (5 - (3+1) ) = 1;\\n\\n        //This allow us to count \"bb\" as 1 contribution for the first b, \"bbab\" as 1 contribution for the first be\\n        // and \"bab\" as 1 contribution\\n        const numberOfStringsStartedWithoutPrevious = (n - i) * (i - ( previousRepeated[i] + 1) );\\n\\n        const totalContribution = numberOfStringsStartingFromHere + numberOfStringsStartedWithoutPrevious;\\n        result += totalContribution;\\n    }\\n\\n    return result;\\n};\\nfunction getRepeated(s) {\\n    let previousRepeated = Array(s.length).fill(-1);\\n    let seen = new Map();\\n    for (let i = 0; i < s.length; i++) {\\n        const letter = s[i];\\n        if (seen.has(letter)) {\\n            const previousIdx = seen.get(letter);\\n            previousRepeated[i] = previousIdx;\\n        }\\n        seen.set(letter, i);\\n    }\\n    return previousRepeated;\\n}\\n\\n//appealSum(\"abbaba\")\\n```\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar appealSum = function (s) {\\n    let result = 0;\\n    const n = s.length;\\n\\n    let seen = new Map();\\n\\n    for (let i = 0; i < s.length; i++) {\\n        const letter = s[i];\\n        let previousRepeated = -1;\\n        if (seen.has(letter)) {\\n            previousRepeated = seen.get(letter);\\n        }\\n        seen.set(letter, i);\\n\\n        const numberOfStringsStartingFromHere = (n - i);\\n        const numberOfStringsStartedWithoutPrevious = (n - i) * (i - ( previousRepeated + 1) );\\n        const totalContribution = numberOfStringsStartingFromHere + numberOfStringsStartedWithoutPrevious;\\n        result += totalContribution;\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2497481,
                "title": "n-time-complexity-and-no-dp-and-0-1-space",
                "content": "Basically adding the contributions of all the letters individually , running the loop 26 times for every character.\\nfor ever letter , lets say \\'a\\' \\nwe will take in acoount variable prev which will store the index of the last occurence of character \\'a\\' and now whenever we get to an inde j where s[j]=\\'a\\' then the number of strings in which this character is contributing can start from any index between prev and j and it should atleast end on index j so that it has one \\'a\\' in it for example if the string is \"bcacdeagh\" then at index 6 ,\\'a\\' is there and it contibutes to substrings like eagh,deagh,dea,deag,sdeag etc and it can be find out using the formula\\n(j-prev)*(n-j) and just keep changing the previos value as we move forward (doing this for every character)\\n\\n\\n```\\nlong long appealSum(string s) {\\n        \\n         int i;\\n        int n=s.size();\\n    long long int ans=0;\\n        int j;\\n        int prev;\\n        for(i=0;i<26;i++){\\n            char c=\\'a\\'+i;\\n            prev=-1;\\n            for(j=0;j<n;j++){\\n                \\n                if(s[j]==c){    \\n                  ans=ans+(j-prev)*(n-j);\\n                    prev=j;\\n                    \\n                }\\n                    \\n            }\\n            \\n        }\\n        return ans;    \\n    }\\n```\\nsimilar que:: \\nhttps://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/discuss/2502003/o(n)-solution-without-dp-(explanation)\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nlong long appealSum(string s) {\\n        \\n         int i;\\n        int n=s.size();\\n    long long int ans=0;\\n        int j;\\n        int prev;\\n        for(i=0;i<26;i++){\\n            char c=\\'a\\'+i;\\n            prev=-1;\\n            for(j=0;j<n;j++){\\n                \\n                if(s[j]==c){    \\n                  ans=ans+(j-prev)*(n-j);\\n                    prev=j;\\n                    \\n                }\\n                    \\n            }\\n            \\n        }\\n        return ans;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2477208,
                "title": "c-solution-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        vector<int> v(26, 0);\\n        long long ans = 0, curr = 0;\\n        for(int i=0; i<s.size(); ++i) {\\n            int prev = v[s[i]-\\'a\\'];\\n            v[s[i]-\\'a\\'] = i+1;\\n            curr += v[s[i]-\\'a\\'] - prev;\\n            ans += curr;\\n        }\\n     return ans;\\n    }\\n};\\n/**\\nif(find helpful) {\\ndo upvote();\\n}\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        vector<int> v(26, 0);\\n        long long ans = 0, curr = 0;\\n        for(int i=0; i<s.size(); ++i) {\\n            int prev = v[s[i]-\\'a\\'];\\n            v[s[i]-\\'a\\'] = i+1;\\n            curr += v[s[i]-\\'a\\'] - prev;\\n            ans += curr;\\n        }\\n     return ans;\\n    }\\n};\\n/**\\nif(find helpful) {\\ndo upvote();\\n}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477013,
                "title": "python3-i-was-unable-to-solve-this-problem-o-n",
                "content": "I was unable to solve this problem, then I checked and solved these two following similar questions:\\nhttps://leetcode.com/problems/count-vowel-substrings-of-a-string/ (Easy but not easy)\\nhttps://leetcode.com/problems/vowels-of-all-substrings/ (Medium)\\nThe pattern seems easier to recognize that we just need to clarify if the character is seen or not.\\nLet\\'s check the steps 4 and 5 in the following example.\\n\\nGiven a string \"abbca\", let\\'s loop from left to right.\\n1. a: 1\\n2. ab, b: 2+1=3\\n3. abb, bb, b: **2+1+1**=**4**\\n\\nAfter three steps, we will have a dictionary **seen** containing latest indices of characters: **seen = {a:0, b:2}**, **count = 4**\\n\\nIn the next step, since **\"c\" is not in seen**, the **unique number of chars of 3 previous substrings** will be **increased by 1** when we add \"c\" and the \"c\" itself is 1;\\nhence, the count = **2+1+1** in step 3 will be count = **3+2+2**+1=8, so we have the step 4 as below:\\n\\n4. abbc, bbc, bc, c: 3+2+2+1=8\\n\\nRegarding the next step that **\"a\" is already in seen**, that says **only the unique number of chars of substrings after the latest index of \"a\"** can be increased by 1 when we add \"a\", and the \"a\" itself is 1; \\nhence, count = 3+**2+2+1** in step 4 will be count = 3+**3+3+2**+1=12, so we have the step 5 as below:\\n\\n5.  abbca, bbca, bca, ca, a: 3+3+3+2+1=12\\n\\nCode: \\n\\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        ans = count = 0\\n        seen = {}\\n        for i, c in enumerate(s):\\n            count += i+(-seen[c] if c in seen else 1)\\n            seen[c] = i\\n            ans += count\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        ans = count = 0\\n        seen = {}\\n        for i, c in enumerate(s):\\n            count += i+(-seen[c] if c in seen else 1)\\n            seen[c] = i\\n            ans += count\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193013,
                "title": "my-attempt-at-trying-to-explain-one-of-several-o-n-solutions",
                "content": "Good day all,\\n\\nhere\\'s my code with an attempt to explain how the solution gets constructed in linear time, constant aux space. Please do not hesitate to ask if you need more clarification; it took me a while to wrap my head around it.\\n\\n```\\nclass Solution {\\n    /**\\n     * Key takeaways:\\n     * Iteratively, it\\'s clear that solutions can be constructed from previous ones:\\n     * adding a char means adding a certain subset of substrings.\\n     * It helps to think of the result as the sum of the appeals of these substrings.\\n     * The appeals of these substrings can be computed using the appeal of the previously\\n     * added substrings.\\n     * It suffices to add the new appeal introduced by the new char to the substrings\\n     * that don\\'t contain it. For this, maintain the last occurrence of each char.\\n     */\\n    \\n    public long appealSum(String s) {\\n        long res = 0;\\n        \\n        int[] lastOccurrence = new int[\\'z\\' + 1];\\n        Arrays.fill(lastOccurrence, -1);\\n        \\n        /**\\n         * The new addition to res consists of the previous addition to it\\n         *   PLUS the contribution of the new char to the substrings that don\\'t contain it\\n         *     WHICH HAPPENS TO BE the distance between now and the last occurrence of the char\\n         *\\n         * Eg: abxc, append b == Adding {b, cb, xcb, bxcb, abxcb} =\\n         *\\n         *                                             b   (+1) \\\\\\n         * a    b    x    c  -->  a     b    x    cb       (+1) |\\n         * ab   bx   xc           ab    bx   xcb           (+1) | This is == i - lastOccurrence[\\'b\\']\\n         * abx  bxc               abx   bxcb               (+0) | <- 0 because \\'b\\' appears already\\n         * abxc                   abxcb                    (+0) /\\n         *                                                  ^^    + Addition\\n         *                                                          for {c, xc, bxc, abxc}\\n         */\\n        int previousAddition = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            // Recompute this addition to res using the previous one (see reasoning above)\\n            previousAddition = i - lastOccurrence[s.charAt(i)] + previousAddition;\\n            \\n            // Record this char\\'s occurrence\\n            lastOccurrence[s.charAt(i)] = i;\\n            \\n            // Tally this addition\\n            res += previousAddition;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /**\\n     * Key takeaways:\\n     * Iteratively, it\\'s clear that solutions can be constructed from previous ones:\\n     * adding a char means adding a certain subset of substrings.\\n     * It helps to think of the result as the sum of the appeals of these substrings.\\n     * The appeals of these substrings can be computed using the appeal of the previously\\n     * added substrings.\\n     * It suffices to add the new appeal introduced by the new char to the substrings\\n     * that don\\'t contain it. For this, maintain the last occurrence of each char.\\n     */\\n    \\n    public long appealSum(String s) {\\n        long res = 0;\\n        \\n        int[] lastOccurrence = new int[\\'z\\' + 1];\\n        Arrays.fill(lastOccurrence, -1);\\n        \\n        /**\\n         * The new addition to res consists of the previous addition to it\\n         *   PLUS the contribution of the new char to the substrings that don\\'t contain it\\n         *     WHICH HAPPENS TO BE the distance between now and the last occurrence of the char\\n         *\\n         * Eg: abxc, append b == Adding {b, cb, xcb, bxcb, abxcb} =\\n         *\\n         *                                             b   (+1) \\\\\\n         * a    b    x    c  -->  a     b    x    cb       (+1) |\\n         * ab   bx   xc           ab    bx   xcb           (+1) | This is == i - lastOccurrence[\\'b\\']\\n         * abx  bxc               abx   bxcb               (+0) | <- 0 because \\'b\\' appears already\\n         * abxc                   abxcb                    (+0) /\\n         *                                                  ^^    + Addition\\n         *                                                          for {c, xc, bxc, abxc}\\n         */\\n        int previousAddition = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            // Recompute this addition to res using the previous one (see reasoning above)\\n            previousAddition = i - lastOccurrence[s.charAt(i)] + previousAddition;\\n            \\n            // Record this char\\'s occurrence\\n            lastOccurrence[s.charAt(i)] = i;\\n            \\n            // Tally this addition\\n            res += previousAddition;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2160001,
                "title": "c-keep-track-of-last-occurence-of-each-character-o-n-time-and-o-1-space",
                "content": "```\\n/* \\n    Time: O(n)\\n    Space: O(1)\\n    Tag: DP (Keep track of index of last occurence of each character)\\n    Difficulty: H to think | E to Implement\\n*/\\n\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        vector<int> lastPos(26, 0);\\n        long long repeated = 0, res = 0;\\n\\n        for (long long i = 0; i < s.length(); i++) {\\n            repeated += lastPos[s[i] - \\'a\\'];\\n            lastPos[s[i] - \\'a\\'] = i + 1;\\n            res += ((i + 1) * (i + 2)) / 2 - repeated; // find maximum possible character sum and then subtract the repeated ones\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n/* \\n    Time: O(n)\\n    Space: O(1)\\n    Tag: DP (Keep track of index of last occurence of each character)\\n    Difficulty: H to think | E to Implement\\n*/\\n\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        vector<int> lastPos(26, 0);\\n        long long repeated = 0, res = 0;\\n\\n        for (long long i = 0; i < s.length(); i++) {\\n            repeated += lastPos[s[i] - \\'a\\'];\\n            lastPos[s[i] - \\'a\\'] = i + 1;\\n            res += ((i + 1) * (i + 2)) / 2 - repeated; // find maximum possible character sum and then subtract the repeated ones\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124646,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N * constant)***\\n\\n* ***Space Complexity : O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // find total substring with atleast one character\\n    \\n    long long find_substring(string str, char ch)\\n    {\\n        long long n = str.size();\\n        \\n        // store total substring without char\\n        \\n        long long res = 0;\\n        \\n        long long curr_count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(str[i] == ch)\\n            {\\n                res += (curr_count) * (curr_count + 1) / 2;\\n                \\n                curr_count = 0;\\n            }\\n            else\\n            {\\n                curr_count++;\\n            }\\n        }\\n        \\n        res += (curr_count) * (curr_count + 1) / 2;\\n        \\n        long long total_substring = (n * (n + 1)) / 2;\\n        \\n        return total_substring - res;\\n    }\\n    \\n    long long appealSum(string str) {\\n        \\n        long long n = str.size();\\n        \\n        long long ans = 0;\\n        \\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++)\\n        {\\n            int idx = ch - \\'a\\';\\n            \\n            long long count = find_substring(str, ch);\\n            \\n            ans += count;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // find total substring with atleast one character\\n    \\n    long long find_substring(string str, char ch)\\n    {\\n        long long n = str.size();\\n        \\n        // store total substring without char\\n        \\n        long long res = 0;\\n        \\n        long long curr_count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(str[i] == ch)\\n            {\\n                res += (curr_count) * (curr_count + 1) / 2;\\n                \\n                curr_count = 0;\\n            }\\n            else\\n            {\\n                curr_count++;\\n            }\\n        }\\n        \\n        res += (curr_count) * (curr_count + 1) / 2;\\n        \\n        long long total_substring = (n * (n + 1)) / 2;\\n        \\n        return total_substring - res;\\n    }\\n    \\n    long long appealSum(string str) {\\n        \\n        long long n = str.size();\\n        \\n        long long ans = 0;\\n        \\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++)\\n        {\\n            int idx = ch - \\'a\\';\\n            \\n            long long count = find_substring(str, ch);\\n            \\n            ans += count;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085372,
                "title": "python-dp-simple-to-understand",
                "content": "idea:\\n(1) dp[i]: for substring ending at i;\\n(2) if char is new to the hashmap, the conttribution is i+1, together with dp[i-1];\\n(3) if char showed up before, the contribution is from the last position+1 to i.\\n\\n```\\ndef appealSum(self, s: str) -> int:\\n        n=len(s)\\n        dp=[0]*n\\n        dp[0]=1\\n        m=defaultdict(list)\\n        for i,c in enumerate(s):\\n            if c not in m:\\n                m[c].append(i)\\n                if i>=1:\\n                    dp[i]=dp[i-1]+i+1\\n            else:\\n                prev=m[c][-1]\\n                m[c].append(i)\\n                dp[i]=dp[i-1]+i-prev\\n        res=sum(dp)\\n        return res\\n",
                "solutionTags": [],
                "code": "idea:\\n(1) dp[i]: for substring ending at i;\\n(2) if char is new to the hashmap, the conttribution is i+1, together with dp[i-1];\\n(3) if char showed up before, the contribution is from the last position+1 to i.\\n\\n```\\ndef appealSum(self, s: str) -> int:\\n        n=len(s)\\n        dp=[0]*n\\n        dp[0]=1\\n        m=defaultdict(list)\\n        for i,c in enumerate(s):\\n            if c not in m:\\n                m[c].append(i)\\n                if i>=1:\\n                    dp[i]=dp[i-1]+i+1\\n            else:\\n                prev=m[c][-1]\\n                m[c].append(i)\\n                dp[i]=dp[i-1]+i-prev\\n        res=sum(dp)\\n        return res\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2017419,
                "title": "o-n-dynamic-programming",
                "content": "For a string `s` of length `n`, we are interested in computing the sum of the appeal of each substring of `s`, where the appeal is the unique number of characters in that substring.\\n\\n**LOCAL PROBLEM**\\nFor each index `i`, we consider the sum of the appeal of all substrings ending at index `i`, denote it `sum(i)`.\\n\\nWhat do we know about this quantity?\\n- Certainly the sum of appeal of all substrings ending at the prior index `i-1` is less than it, since each substring ending at index `i-1` extends to a substring ending at index `i`, and we don\\'t lose appeal by tacking on characters; also, we gain an additional substring `s[i]` to consider at index `i`, which necessarily has appeal value 1\\n- The character `s[i]` will only contribute to the appeal of the substrings ending at index `i-1` (that we extend to end at index `i`)  which do not have `s[i]` already contained\\n\\nThus, it seems we need to keep track of the last occurrence of any character we encounter, so that we can easily figure out just how many substrings ending at index `i` have gained a new character `s[i]`. Namely, if we always keep up to date for any character `x`, \\n```\\nprev(x) := previous index we encountered character x\\n```\\nand use `prev(x) = -1` if we have not encountered it yet, then we arrive at the simple recurrence:\\n```\\nsum(i) = sum(i-1) + (i - prev(s[i])) \\n```\\n\\n**PUTTING IT ALL TOGETHER**\\nOnce we know the answer for each local index `i`, then to get the sum of appeals over all substrings, just sum up `sum(i)` over all possible substring end indexes `i`:\\n```\\nsum of appeal = sum(0) + ... + sum(n-1)\\n```\\n\\n\\n**CODE**\\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        n = len(s)\\n        prev_occurrence = {}\\n        sum_ending_at = [0] * n\\n        \\n        for i in range(n):\\n            sum_ending_at[i] = sum_ending_at[i-1]\\n            if s[i] not in prev_occurrence:\\n                sum_ending_at[i] += i + 1\\n            else:\\n                sum_ending_at[i] += i - prev_occurrence[s[i]]\\n            prev_occurrence[s[i]] = i\\n        \\n        return sum(sum_ending_at)\\n```",
                "solutionTags": [],
                "code": "```\\nprev(x) := previous index we encountered character x\\n```\n```\\nsum(i) = sum(i-1) + (i - prev(s[i])) \\n```\n```\\nsum of appeal = sum(0) + ... + sum(n-1)\\n```\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        n = len(s)\\n        prev_occurrence = {}\\n        sum_ending_at = [0] * n\\n        \\n        for i in range(n):\\n            sum_ending_at[i] = sum_ending_at[i-1]\\n            if s[i] not in prev_occurrence:\\n                sum_ending_at[i] += i + 1\\n            else:\\n                sum_ending_at[i] += i - prev_occurrence[s[i]]\\n            prev_occurrence[s[i]] = i\\n        \\n        return sum(sum_ending_at)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2000708,
                "title": "javascript",
                "content": "JS implementation of https://leetcode.com/problems/total-appeal-of-a-string/discuss/1996390/JavaC%2B%2BPython-Easy-and-Concise-with-Explanation\\n\\n```\\nconst appealSum = function(s) {\\n    let count = 0\\n    let hashMap = new Map()\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        hashMap.set(s[i], i + 1)\\n        for (let el of hashMap.values()) {\\n            count += el\\n        }\\n    }\\n\\t\\n    return count\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst appealSum = function(s) {\\n    let count = 0\\n    let hashMap = new Map()\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        hashMap.set(s[i], i + 1)\\n        for (let el of hashMap.values()) {\\n            count += el\\n        }\\n    }\\n\\t\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2000161,
                "title": "python",
                "content": "Genius solution from user \"votrubac\"\\n```\\nclass Solution(object):\\n    def appealSum(self, s):\\n        last = {}\\n        cur = 0\\n        res = 0\\n        for i, ch in enumerate(s):\\n            cur += i - (last[ch] if ch in last else -1)\\n            last[ch] = i\\n            res += cur\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def appealSum(self, s):\\n        last = {}\\n        cur = 0\\n        res = 0\\n        for i, ch in enumerate(s):\\n            cur += i - (last[ch] if ch in last else -1)\\n            last[ch] = i\\n            res += cur\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998398,
                "title": "java-dp-vs-sliding-window-with-explanation",
                "content": "### DP\\nInspired by [DP](https://leetcode.com/problems/total-appeal-of-a-string/discuss/1996203/DP) (author: votrubac)\\n##### Steps\\nThe appeal of all substrings end at `i`th is:\\n- the appreal of substrings end at `i-1`th, plus\\n- the distance to the last index of the same character \\n\\nTherefore, we can get the formula:\\n```java\\nf[i] = f[i-1] + i - lastIndexOf(s[i]) + 1\\n```\\n\\n##### Solution\\n```java\\npublic long appealSum(String s) {\\n    int n = s.length();\\n    int[] last = new int[26];\\n    for (int i = 0; i < 26; i++) last[i] = -1;\\n\\n    long cur = 0, res = 0;\\n    for (int i = 0; i < n; i++) {\\n        int idx = s.charAt(i) - \\'a\\';\\n        cur += i - last[idx];\\n        last[idx] = i;\\n        res += cur;\\n    }\\n    return res;\\n}\\n```\\n------\\n\\n### Sliding Window\\nInspired by [JAVA | Sliding window](https://leetcode.com/problems/total-appeal-of-a-string/discuss/1998266/JAVA-or-Sliding-window)  (author: tiwarianand940)\\n\\n##### Idea\\nThe appeal of all substrings is acutally the sum of the **count of substrings containing a specific character**.\\n\\nExample 1: `abbca`\\n```\\nsubstrings contains `a`: [a, ab, abb, abbc, abbca] and [bbca, bca, ca, a]          -> count is 9\\nsubstrings contains `b`: [b, bb, bbc, bbca, ab, abb, abbc, abbca] and [b, bc, bca] -> count is 10\\nsubstrings contains `c`: [abbc, bbc, bc, c, abbca, bbca, bca, ca]                  -> count is 8\\n```\\n\\n##### Formula\\nFor a specific character, the count of substrings containing `ith` character is `left * right`, where\\n- left is `(index of ith char) + 1`\\n- right is `n - (index of ith char)`\\n\\nBut this will cause duplicate count.\\n\\n\\nInstead, we should get the count of substrings containing `ith` character **WITHOUT** containing `i-1th` character. Therefore, \\n- left is `(index of ith char) - (index of i-1th char)`\\n- right is `n - (index of ith char)`\\n\\n\\nExample 2: `abbca`\\n```\\nthe count containing `1th a` is 1 * 5 = 5\\nthe count containing `2th a` is 4 * 1 = 4\\nthe count containing `1th b` is 2 * 4 = 8\\nthe count containing `2th b` is 1 * 3 = 3\\nthe count containing `1th c` is 4 * 2 = 8\\n```\\n\\n##### Steps\\n1. store the indexes for all characters\\n2. for a specific character, iterate over all the occurences\\n3. sum up the count: `(current index - previous index) * (n - current index)`\\n4. repeat 2-3 for all characters\\n\\n\\n##### Solution\\n```java\\npublic long appealSum(String s) {\\n    int n = s.length();\\n    List<Integer>[] indexes = new ArrayList[26];\\n    for (int i = 0; i < 26; i++) indexes[i] = new ArrayList<>();\\n    for (int i = 0; i < n; i++) {\\n        int idx = s.charAt(i) - \\'a\\';\\n        indexes[idx].add(i);\\n    }\\n\\n    long res = 0;\\n    for (List<Integer> index : indexes) {\\n        int m = index.size();\\n        for (int i = 0; i < m; i++) {\\n            int cur = index.get(i);\\n            int pre = i == 0 ? -1 : index.get(i - 1);\\n            res += (long) (cur - pre) * (n - cur);\\n        }\\n    }\\n    return res;\\n}\\n```\\n\\nPlease let me know if it\\'s helpful for you, thanks :)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```java\\nf[i] = f[i-1] + i - lastIndexOf(s[i]) + 1\\n```\n```java\\npublic long appealSum(String s) {\\n    int n = s.length();\\n    int[] last = new int[26];\\n    for (int i = 0; i < 26; i++) last[i] = -1;\\n\\n    long cur = 0, res = 0;\\n    for (int i = 0; i < n; i++) {\\n        int idx = s.charAt(i) - \\'a\\';\\n        cur += i - last[idx];\\n        last[idx] = i;\\n        res += cur;\\n    }\\n    return res;\\n}\\n```\n```\\nsubstrings contains `a`: [a, ab, abb, abbc, abbca] and [bbca, bca, ca, a]          -> count is 9\\nsubstrings contains `b`: [b, bb, bbc, bbca, ab, abb, abbc, abbca] and [b, bc, bca] -> count is 10\\nsubstrings contains `c`: [abbc, bbc, bc, c, abbca, bbca, bca, ca]                  -> count is 8\\n```\n```\\nthe count containing `1th a` is 1 * 5 = 5\\nthe count containing `2th a` is 4 * 1 = 4\\nthe count containing `1th b` is 2 * 4 = 8\\nthe count containing `2th b` is 1 * 3 = 3\\nthe count containing `1th c` is 4 * 2 = 8\\n```\n```java\\npublic long appealSum(String s) {\\n    int n = s.length();\\n    List<Integer>[] indexes = new ArrayList[26];\\n    for (int i = 0; i < 26; i++) indexes[i] = new ArrayList<>();\\n    for (int i = 0; i < n; i++) {\\n        int idx = s.charAt(i) - \\'a\\';\\n        indexes[idx].add(i);\\n    }\\n\\n    long res = 0;\\n    for (List<Integer> index : indexes) {\\n        int m = index.size();\\n        for (int i = 0; i < m; i++) {\\n            int cur = index.get(i);\\n            int pre = i == 0 ? -1 : index.get(i - 1);\\n            res += (long) (cur - pre) * (n - cur);\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997618,
                "title": "javascript-last-index",
                "content": "**Solution: Last Index**\\n\\nKeep track of the last index of each character in `s`, on the fly.\\nTo get the number of subarrays each character appears in, the formula is `(n - i) * (i + 1)`\\n  `(i + 1)` -> number of starting subarrays ending with `arr[i]`\\n  `(n - i)` -> number of different ending subarrays after `arr[i]`\\n  e.g: arr = `[1,2,3,4]`\\n  Let\\'s look for the number of times `arr[1]` appears in a subarray:\\n  `(i + 1) = [[1,2],[2]]`\\n  `(n - i) = [[2],[2,3],[2,3,4]]`\\n`  (n - i) * (i + 1)` = all the combinations (6) ->` [[1,2],[1,2,3],[1,2,3,4],[2],[2,3],[2,3,4]]`\\n\\nHowever, we are only counting the distinct characters.\\nTo solve this, keep track of the last index of each character, then exclude counting the subarrays which overlap with the last occurance.\\nThe formula turns into: `(n - i) * (i - lastIdx)`\\n\\ne.g: arr = `[1,2,3,2,4]`\\nLet\\'s calculate the \\'appeal\\' of `arr[3]`.\\nWe only want to count these subarrays (don\\'t include the earlier 2) -> `[[3,2],[3,2,4],[2],[2,4]]`\\nThe last occurance of 2 was at index 1.\\n`(n - i) * (i - lastIdx) = (5 - 3) * (3 - 1) = 2 * 2 = 4`\\n\\nTime Complexity: `O(n)` 74ms\\nSpace Complexity:  `O(1)` 44.5MB\\n```\\nvar appealSum = function(s) {\\n  let ans = 0, n = s.length;\\n  let lastIndex = Array(26).fill(-1);\\n  for (let i = 0; i < n; i++) {\\n    let charcode = s.charCodeAt(i) - 97;\\n    let lastIdx = lastIndex[charcode];\\n    ans += (n - i) * (i - lastIdx);\\n    lastIndex[charcode] = i;\\n  }  \\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar appealSum = function(s) {\\n  let ans = 0, n = s.length;\\n  let lastIndex = Array(26).fill(-1);\\n  for (let i = 0; i < n; i++) {\\n    let charcode = s.charCodeAt(i) - 97;\\n    let lastIdx = lastIndex[charcode];\\n    ans += (n - i) * (i - lastIdx);\\n    lastIndex[charcode] = i;\\n  }  \\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1996844,
                "title": "java-simple-greedy-accumulation-sum-o-26-n",
                "content": "Key concept: Keep accumulated sum of total appeal sum up to curr while iterating string and improve accum sum each time then add to ans each time. Every time new character is added to back, all suffixes are new strings. We improve suffixes that improve appeal in constant time using last idx alphabet array.\\n\\n**Iterate each characters in string while keeping last character idx for each alphabets.** When we add new character for example \\'c\\' like below we will check the last idx that has character \\'c\\'. **From last idx, every idx to the right will treat new \\'c\\' inserted as new therefore each of them will increase by 1 which can be easily calculated through distance of curr idx and last character idx.** We add it to **accum sum since this will need to be added again in next iteration as next suffix\\'s appeal sum will be based on previous suffix\\'s appeal sum**. Then we add accum sum to answer. We do not add more in the left of last character idx (including last character idx) since those do not improve in appeal. Lastly,  just update last character idx to be used in next iterations.\\n\\nBelow is example in iteration at index 8:\\n![image](https://assets.leetcode.com/users/images/cbc0e413-5e63-47c3-8415-8fc22169cb37_1651383036.8008597.png)\\n\\nTime complexity: O(26*N) => O(N)\\n\\n\\n```\\nclass Solution {\\n    public long appealSum(String s) {\\n\\n        int[] lastAlphIdxArr = new int[26];\\n        for(int i=0;i<26;i++) {\\n            lastAlphIdxArr[i] = -1;\\n        }\\n\\n        long accum = 0;\\n        long ans = 0;\\n        for(int i=0;i<s.length();i++) {\\n            char c = s.charAt(i);\\n\\n            int lastCharIdx = lastAlphIdxArr[c-\\'a\\'];\\n            accum += i - lastCharIdx; // update accum sum\\n            ans += accum;\\n            // Update last character idx\\n            lastAlphIdxArr[c-\\'a\\'] = i;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public long appealSum(String s) {\\n\\n        int[] lastAlphIdxArr = new int[26];\\n        for(int i=0;i<26;i++) {\\n            lastAlphIdxArr[i] = -1;\\n        }\\n\\n        long accum = 0;\\n        long ans = 0;\\n        for(int i=0;i<s.length();i++) {\\n            char c = s.charAt(i);\\n\\n            int lastCharIdx = lastAlphIdxArr[c-\\'a\\'];\\n            accum += i - lastCharIdx; // update accum sum\\n            ans += accum;\\n            // Update last character idx\\n            lastAlphIdxArr[c-\\'a\\'] = i;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996353,
                "title": "python-clean-simple",
                "content": "```py\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        result = 0\\n        a = ord(\\'a\\')\\n        count = [0] * 26\\n        for i, char in enumerate(s):\\n            count[ord(char)-a] = i + 1\\n            for j in range(26):\\n                result += count[j]\\n        return result \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        result = 0\\n        a = ord(\\'a\\')\\n        count = [0] * 26\\n        for i, char in enumerate(s):\\n            count[ord(char)-a] = i + 1\\n            for j in range(26):\\n                result += count[j]\\n        return result \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996303,
                "title": "c-o-n-combinatoric-approach",
                "content": "The appeal of a string is the number of distinct characters found in the string.\\n\\nFor each character c = \\'a\\', \\'b\\', ... ,\\'z\\', if we define appeal_c for string s to be \\nappeal_c(s) = 1 if c in s else 0, then\\nappeal of s is equal to the sum of appeal_c(s) for all c = \\'a\\', \\'b\\', ... ,\\'z\\'.\\n\\nTherefore, when finding the total appeal of all of substrings of a given string s, we can calculate sum(appeal_c(t)) for all substring t of s for each character c separately and then add them over all letters c.\\n\\nGiven a string s of length n, there are n*(n+1)/2 number of substrings.\\ngiven c, how many substrings t is s.t. appeal_c(t) = 0?\\nIf a string s has no c in it, then any substring t of s satisfies appeal_c(t) = 0\\nSo for each character c we need to find the maximal substring that does not contain c.\\nFor each such substring of length l we can substract l*(l+1) / 2 from n*(n+1)/2.\\n\\n```\\nclass Solution {\\npublic:\\n  long long appealSum(string s) {\\n    \\n    using ll = long long;  \\n    int n = s.size();\\n\\n    vector<vector<int>> a(26);\\n    for (int i=0; i<n; i++) {\\n      int x = s[i] - \\'a\\';\\n      a[x].push_back(i);\\n    }\\n    ll ans = 0;\\n    \\n    for (int i=0; i<26; i++) {\\n      if (a[i].empty()) continue;\\n      a[i].push_back(n);\\n      ans += n*(n+1) / 2;\\n      for (int j=0; j<a[i].size(); j++) {\\n        ll cnt;\\n        if (j==0) cnt = a[i][j];\\n        else cnt = a[i][j] - a[i][j-1] - 1;\\n        ans -= cnt*(cnt+1)/2;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long appealSum(string s) {\\n    \\n    using ll = long long;  \\n    int n = s.size();\\n\\n    vector<vector<int>> a(26);\\n    for (int i=0; i<n; i++) {\\n      int x = s[i] - \\'a\\';\\n      a[x].push_back(i);\\n    }\\n    ll ans = 0;\\n    \\n    for (int i=0; i<26; i++) {\\n      if (a[i].empty()) continue;\\n      a[i].push_back(n);\\n      ans += n*(n+1) / 2;\\n      for (int j=0; j<a[i].size(); j++) {\\n        ll cnt;\\n        if (j==0) cnt = a[i][j];\\n        else cnt = a[i][j] - a[i][j-1] - 1;\\n        ans -= cnt*(cnt+1)/2;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996230,
                "title": "o-n-time-and-o-1-space-solution-with-explanation",
                "content": "The key thing here is to understand that in each interval only the first occurrence of a unique character will have contribution to the final result. \\nSo to get to the answer we just need to find all the interval in which the current character is occured for the first time. To do this we just need to maintain the previous occurence of all possible characters(i.e. lowercase alphabets in this case). All interval starting after the prev occurrence and before and at the current index will have contribution from current character\\n\\n<b> Java </b>\\n```\\nclass Solution {\\n    public long appealSum(String s) {\\n      int[] pos = new int[26];\\n      long res = 0;\\n      int n = s.length();\\n      for (int i = 0;i<n;i++) {\\n        int c = (int)(s.charAt(i) -\\'a\\');\\n        res += ((i+1)-pos[c])*(n-i);\\n        pos[c] = i+1;\\n      }\\n      return res;\\n    }\\n}\\n```\\n\\n<b> Go</b>\\n```\\nfunc appealSum(s string) int64 {\\n  pos := make([]int, 26)\\n  res := 0\\n  n:= len(s)\\n  for i:= 0;i<n;i++{\\n    c := s[i]-\\'a\\'\\n    res += ((i+1)-pos[c])*(n-i)\\n    pos[c] = i+1\\n  }\\n  return int64(res)\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Go"
                ],
                "code": "```\\nclass Solution {\\n    public long appealSum(String s) {\\n      int[] pos = new int[26];\\n      long res = 0;\\n      int n = s.length();\\n      for (int i = 0;i<n;i++) {\\n        int c = (int)(s.charAt(i) -\\'a\\');\\n        res += ((i+1)-pos[c])*(n-i);\\n        pos[c] = i+1;\\n      }\\n      return res;\\n    }\\n}\\n```\n```\\nfunc appealSum(s string) int64 {\\n  pos := make([]int, 26)\\n  res := 0\\n  n:= len(s)\\n  for i:= 0;i<n;i++{\\n    c := s[i]-\\'a\\'\\n    res += ((i+1)-pos[c])*(n-i)\\n    pos[c] = i+1\\n  }\\n  return int64(res)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564324,
                "title": "easy-explanation-with-example",
                "content": "```\\n// 0 1 2 3 4\\n// a b c d b\\n// Appeal for all substring ending at d --F(3)\\n// d    -> 1\\n// cd   -> 2\\n// bcd  -> 3\\n// abcd -> 4\\n\\n// Appeal for all substring ending at b --F(4)\\n// b     -> 1\\n// db    -> 1 + 1\\n// cdb   -> 2 + 1\\n// bcdb  -> 3 + 0\\n// abcdb -> 4 + 0\\n// we can find this with the help of dp \\n// first find the recurrence relation \\n// F(4) = F(3) + 1 + (4 - 1) - 1\\n// adding 1 for b but what is (4 - 1) - 1 ?\\n//         i\\n// 0 1 2 3 4\\n// a b c d b  we can see we are checking here the last occ of b\\n// we have added 1 , 1, 0 , 0 in the right side above \\n// total is 2 if b occ before , than we have added 0 so we want those \\n// substring in which b doesn\\'t occur before becz than only we will get 1 \\n// so (4 - 1) - 1 = 2 with d or cd if we add b {db, cdb} we will get 1 \\n// so finally F(i) = F(i - 1) + i - lastOcc(b)\\nclass Solution {\\n    public long appealSum(String s) {\\n        int n = s.length();\\n       \\n        long[] dp = new long[n + 1];\\n        \\n        int[] lastIndex = new int[26];\\n        Arrays.fill(lastIndex, -1);\\n        \\n        long ans = 0l;\\n        \\n        for(int i = 0; i < n; i++){\\n            int c = s.charAt(i) - \\'a\\';\\n            // calculate the new substrings count with the help of prev \\n            dp[i + 1] = dp[i] + i - lastIndex[c];\\n            ans += dp[i + 1]; // add the new substrings count into ans\\n            lastIndex[c] = i; // update the last occ of char\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n// 0 1 2 3 4\\n// a b c d b\\n// Appeal for all substring ending at d --F(3)\\n// d    -> 1\\n// cd   -> 2\\n// bcd  -> 3\\n// abcd -> 4\\n\\n// Appeal for all substring ending at b --F(4)\\n// b     -> 1\\n// db    -> 1 + 1\\n// cdb   -> 2 + 1\\n// bcdb  -> 3 + 0\\n// abcdb -> 4 + 0\\n// we can find this with the help of dp \\n// first find the recurrence relation \\n// F(4) = F(3) + 1 + (4 - 1) - 1\\n// adding 1 for b but what is (4 - 1) - 1 ?\\n//         i\\n// 0 1 2 3 4\\n// a b c d b  we can see we are checking here the last occ of b\\n// we have added 1 , 1, 0 , 0 in the right side above \\n// total is 2 if b occ before , than we have added 0 so we want those \\n// substring in which b doesn\\'t occur before becz than only we will get 1 \\n// so (4 - 1) - 1 = 2 with d or cd if we add b {db, cdb} we will get 1 \\n// so finally F(i) = F(i - 1) + i - lastOcc(b)\\nclass Solution {\\n    public long appealSum(String s) {\\n        int n = s.length();\\n       \\n        long[] dp = new long[n + 1];\\n        \\n        int[] lastIndex = new int[26];\\n        Arrays.fill(lastIndex, -1);\\n        \\n        long ans = 0l;\\n        \\n        for(int i = 0; i < n; i++){\\n            int c = s.charAt(i) - \\'a\\';\\n            // calculate the new substrings count with the help of prev \\n            dp[i + 1] = dp[i] + i - lastIndex[c];\\n            ans += dp[i + 1]; // add the new substrings count into ans\\n            lastIndex[c] = i; // update the last occ of char\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453209,
                "title": "java-o-n-time",
                "content": "``` java []\\n// O(n) time\\n// O(26) space\\nclass Solution {\\n    public long appealSum(String s) {\\n        int[] a = new int[26];\\n        long c=0;\\n        long ans=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            c-=a[s.charAt(i)-\\'a\\'];\\n            ans+=c+=a[s.charAt(i)-\\'a\\']=i+1;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n``` java []\\n// O(n*26) time\\n// O(26) space\\nclass Solution {\\n    public long appealSum(String s) {\\n        int[] a = new int[26];\\n        long ans=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a[s.charAt(i)-\\'a\\']=i+1;\\n            ans+=sum(a);\\n        }\\n        return ans;\\n    }\\n    \\n    private long sum(int[] a)\\n    {\\n        long sum=0;\\n        for(int x:a)\\n            sum+=x;\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "``` java []\\n// O(n) time\\n// O(26) space\\nclass Solution {\\n    public long appealSum(String s) {\\n        int[] a = new int[26];\\n        long c=0;\\n        long ans=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            c-=a[s.charAt(i)-\\'a\\'];\\n            ans+=c+=a[s.charAt(i)-\\'a\\']=i+1;\\n        }\\n        return ans;\\n    }\\n}\\n```\n``` java []\\n// O(n*26) time\\n// O(26) space\\nclass Solution {\\n    public long appealSum(String s) {\\n        int[] a = new int[26];\\n        long ans=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a[s.charAt(i)-\\'a\\']=i+1;\\n            ans+=sum(a);\\n        }\\n        return ans;\\n    }\\n    \\n    private long sum(int[] a)\\n    {\\n        long sum=0;\\n        for(int x:a)\\n            sum+=x;\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752156,
                "title": "python-dp-solution",
                "content": "\\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        \\n        #brute force\\n        #def cnt_appeal(s):\\n            #l=\\'\\'.join(s)\\n            #return len(set(s))\\n    \\n        #cnt=0\\n        #i=1\\n        #while i<=len(s):\\n            #for j in range(len(s)):\\n                #tmp=s[j:j+i]\\n                \\n                #if len(tmp)>=i:\\n                    #cnt+=cnt_appeal(tmp)\\n            #i+=1\\n        #return cnt\\n\\t\\t\\n        n=len(s)    \\n        dp=[0]*(n+1)\\n        last_ind=[-1]*26\\n        ans=0\\n        l=list(s)\\n        for i in range(n):\\n            c=ord(l[i])-ord(\\'a\\')\\n            dp[i+1]=dp[i]+i-last_ind[c]\\n            ans+=dp[i+1]\\n            last_ind[c]=i\\n        return ans\\n```\\nBrute force has time limit exceed, dp solution passed all tests...\\n\\nif my solution was heplful, rate it ;)",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        \\n        #brute force\\n        #def cnt_appeal(s):\\n            #l=\\'\\'.join(s)\\n            #return len(set(s))\\n    \\n        #cnt=0\\n        #i=1\\n        #while i<=len(s):\\n            #for j in range(len(s)):\\n                #tmp=s[j:j+i]\\n                \\n                #if len(tmp)>=i:\\n                    #cnt+=cnt_appeal(tmp)\\n            #i+=1\\n        #return cnt\\n\\t\\t\\n        n=len(s)    \\n        dp=[0]*(n+1)\\n        last_ind=[-1]*26\\n        ans=0\\n        l=list(s)\\n        for i in range(n):\\n            c=ord(l[i])-ord(\\'a\\')\\n            dp[i+1]=dp[i]+i-last_ind[c]\\n            ans+=dp[i+1]\\n            last_ind[c]=i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651723,
                "title": "c-easy-to-understand-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        vector<int> last(26);\\n        long res = 0, n = s.size();\\n        for (int i = 0; i < n; ++i) {\\n            last[s[i] - \\'a\\'] = i + 1;\\n            for (int j: last)\\n                res += j;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        vector<int> last(26);\\n        long res = 0, n = s.size();\\n        for (int i = 0; i < n; ++i) {\\n            last[s[i] - \\'a\\'] = i + 1;\\n            for (int j: last)\\n                res += j;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642524,
                "title": "java-solution",
                "content": "### ***Please Upvote !!!*** **(\\u25E0\\u203F\\u25E0)**\\n```\\nclass Solution {\\n    public long appealSum(String s) {\\n        int n = s.length();\\n        long[] dp = new long[n + 1];\\n        \\n        int[] lastIdx = new int[26];\\n        Arrays.fill(lastIdx, -1);\\n        \\n        long total = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int c = s.charAt(i) - \\'a\\';\\n            dp[i + 1] = dp[i] + i - lastIdx[c];\\n            total += dp[i + 1];\\n            \\n            lastIdx[c] = i;\\n        }\\n        \\n        return total;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n[Watch this video to understand this solution](https://www.youtube.com/watch?v=D3JXFdGTizg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long appealSum(String s) {\\n        int n = s.length();\\n        long[] dp = new long[n + 1];\\n        \\n        int[] lastIdx = new int[26];\\n        Arrays.fill(lastIdx, -1);\\n        \\n        long total = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int c = s.charAt(i) - \\'a\\';\\n            dp[i + 1] = dp[i] + i - lastIdx[c];\\n            total += dp[i + 1];\\n            \\n            lastIdx[c] = i;\\n        }\\n        \\n        return total;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603225,
                "title": "c-o-n-solution-with-explanation-no-dp",
                "content": "```\\nlong long appealSum(string s) {\\n        // for each character, calculate its contribution to the total appeal\\n        // for char c include right bound, but not left bound to avoid duplicate\\n\\t\\t// Ex, s = c x c x c\\n        // meaning first c will contribute 1 to substring of [0:0] until [0:4], so l=0, r=4, i=0;\\n        // but second c will only contribute 1 to substring of [1:2] until [2:4], so l=1, r=4, i=2;\\n        // basically as a convention only the left most char will contribute to appeal if multiple of the same char exist\\n        // for a char contributing in range [l : r] at index i\\n        // total contribution is (r - i + 1) * (i - l + 1) ie number of substrings contain s[i] within [l : r]\\n\\n        // r is always s.size() - 1\\n        vector<int> left_bound(s.length(), 0);\\n        vector<int> last_char_index(26, -1);\\n        for (int i = 0; i < s.length(); i ++)\\n        {\\n            char c = s.at(i);\\n            if (last_char_index[c - \\'a\\'] != -1)\\n            {\\n                // update left bound if c was seen previously\\n                left_bound[i] = last_char_index[c - \\'a\\'] + 1;\\n            }\\n            last_char_index[c - \\'a\\'] = i;\\n        }\\n\\n        long long ans = 0;\\n        int r = s.length() - 1;\\n        for (int i = 0; i < left_bound.size(); i ++)\\n        {\\n            ans += (r - i + 1) * (i - left_bound[i] + 1);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nlong long appealSum(string s) {\\n        // for each character, calculate its contribution to the total appeal\\n        // for char c include right bound, but not left bound to avoid duplicate\\n\\t\\t// Ex, s = c x c x c\\n        // meaning first c will contribute 1 to substring of [0:0] until [0:4], so l=0, r=4, i=0;\\n        // but second c will only contribute 1 to substring of [1:2] until [2:4], so l=1, r=4, i=2;\\n        // basically as a convention only the left most char will contribute to appeal if multiple of the same char exist\\n        // for a char contributing in range [l : r] at index i\\n        // total contribution is (r - i + 1) * (i - l + 1) ie number of substrings contain s[i] within [l : r]\\n\\n        // r is always s.size() - 1\\n        vector<int> left_bound(s.length(), 0);\\n        vector<int> last_char_index(26, -1);\\n        for (int i = 0; i < s.length(); i ++)\\n        {\\n            char c = s.at(i);\\n            if (last_char_index[c - \\'a\\'] != -1)\\n            {\\n                // update left bound if c was seen previously\\n                left_bound[i] = last_char_index[c - \\'a\\'] + 1;\\n            }\\n            last_char_index[c - \\'a\\'] = i;\\n        }\\n\\n        long long ans = 0;\\n        int r = s.length() - 1;\\n        for (int i = 0; i < left_bound.size(); i ++)\\n        {\\n            ans += (r - i + 1) * (i - left_bound[i] + 1);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2566583,
                "title": "c-solution-using-dp",
                "content": "I have written the steps to arrive at the output  using dynamic programming.\\n\\n- Let appeal[i] be the total appeal of all the substrings\\nformed from arr[0...i].\\n- Let cnt[j] be the total appeal of substrings ending at j\\n- The inductive relation is:\\ni) cnt[i] = cnt[i-1] + i+1 - prev_occ[arr[i]]\\nii) appeal[i] = appeal[i-1] + cnt[i]\\n- appeal[n-1] gives the answer\\n- prev_occ[s[i]] = i;\\n- prev_occ is updated at every index because we want to be able to delete repetitions from all the substrings which end at index i+1.\\n- The updated value will make sure that the correct number of substrings to subtract are calculated.\\n\\nCode:\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long appealSum(string s) {\\n\\t\\t\\tunordered_map<int,int>prev_occ;\\n\\t\\t\\tfor(int i =0;i<26;i++)\\n\\t\\t\\t\\tprev_occ[i] = 0;\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tvector<long long>appeal(n,0);\\n\\t\\t\\tvector<long long>cnt(n,0);\\n\\t\\t\\tappeal[0] = 1;\\n\\t\\t\\tcnt[0] = 1;\\n\\t\\t\\tprev_occ[s[0]-\\'a\\'] = 1;\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{  \\n\\t\\t\\t\\tcnt[i] = cnt[i-1] + i+1 - prev_occ[s[i]-\\'a\\'];\\n\\t\\t\\t\\tappeal[i] = appeal[i-1] + cnt[i] ;\\n\\t\\t\\t\\tprev_occ[s[i]-\\'a\\'] = i+1;\\n\\t\\t\\t}\\n\\t\\t\\treturn appeal[n-1];\\n\\n\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long appealSum(string s) {\\n\\t\\t\\tunordered_map<int,int>prev_occ;\\n\\t\\t\\tfor(int i =0;i<26;i++)\\n\\t\\t\\t\\tprev_occ[i] = 0;\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tvector<long long>appeal(n,0);\\n\\t\\t\\tvector<long long>cnt(n,0);\\n\\t\\t\\tappeal[0] = 1;\\n\\t\\t\\tcnt[0] = 1;\\n\\t\\t\\tprev_occ[s[0]-\\'a\\'] = 1;\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{  \\n\\t\\t\\t\\tcnt[i] = cnt[i-1] + i+1 - prev_occ[s[i]-\\'a\\'];\\n\\t\\t\\t\\tappeal[i] = appeal[i-1] + cnt[i] ;\\n\\t\\t\\t\\tprev_occ[s[i]-\\'a\\'] = i+1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2519021,
                "title": "2262-python",
                "content": "\\tclass Solution:\\n\\t\\tdef appealSum(self, s: str) -> int:\\n\\t\\t\\tdp = [0]\\n\\t\\t\\tprev = [-1]*26\\n\\t\\t\\tfor i,c in enumerate(s):\\n\\t\\t\\t\\tst = ord(c)-ord(\"a\")\\n\\t\\t\\t\\tdp.append(dp[-1] + i - prev[st])\\n\\t\\t\\t\\tprev[st] = i\\n\\n\\t\\t\\treturn sum(dp)",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef appealSum(self, s: str) -> int:\\n\\t\\t\\tdp = [0]\\n\\t\\t\\tprev = [-1]*26\\n\\t\\t\\tfor i,c in enumerate(s):\\n\\t\\t\\t\\tst = ord(c)-ord(\"a\")\\n\\t\\t\\t\\tdp.append(dp[-1] + i - prev[st])\\n\\t\\t\\t\\tprev[st] = i\\n\\n\\t\\t\\treturn sum(dp)",
                "codeTag": "Java"
            },
            {
                "id": 2472167,
                "title": "python-3-lines-commented-easy-formula",
                "content": "For each substring you count some characters, right? Since we count unique, consider only leftmost occurences of characters in the string. Now, how about for each character counting how many times it would be counted instead. \\n\\nSay, you got a string `xaxxxaxxxxxx`. Let\\'s count how many times 2nd `a` character will be counted. Left border for the substring might be anything after 1st `a` character, and right border can be anything after 2nd `a` character. Thus by product rule we just multiply possibilities for left and right. That\\'s it! Just sum this for all characters.\\n\\nFor each character we need to find same character being it\\'s left neighbor. We keep these indexes in `ln` (left neighbor) list. So `ln[5] = 1`, corresponds to 1st `a` character (index 1) being 2nd `a` character\\'s (index 5) left neighbor. We can populate `ln` list in a single loop, check the code. And that\\'s all we need to compute our formula.\\n\\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        n = len(s)\\n        # left neighbor of a character\\n        ln = [-1] * n\\n        # last occurence of a character\\n        c2i = {}\\n        \\n\\t\\t# populate left neighbors\\n        for i, ch in enumerate(s):\\n            if ch in c2i:\\n                ln[i] = c2i[ch]\\n            c2i[ch] = i\\n\\n        # answer\\n        return sum((i - ln[i]) * (n - i) for i in range(n))\\n```\\n\\nEven shorter\\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        n, ln, c2i = len(s), [-1] * len(s), {c: -1 for c in s}\\n        for i, ch in enumerate(s): ln[i], c2i[ch] = c2i[ch], i\\n        return sum((i - ln[i]) * (n - i) for i in range(n))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        n = len(s)\\n        # left neighbor of a character\\n        ln = [-1] * n\\n        # last occurence of a character\\n        c2i = {}\\n        \\n\\t\\t# populate left neighbors\\n        for i, ch in enumerate(s):\\n            if ch in c2i:\\n                ln[i] = c2i[ch]\\n            c2i[ch] = i\\n\\n        # answer\\n        return sum((i - ln[i]) * (n - i) for i in range(n))\\n```\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        n, ln, c2i = len(s), [-1] * len(s), {c: -1 for c in s}\\n        for i, ch in enumerate(s): ln[i], c2i[ch] = c2i[ch], i\\n        return sum((i - ln[i]) * (n - i) for i in range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470688,
                "title": "java-o-n-time-solution-easy-to-understand",
                "content": "Just count how many substrings a single character can be used in. From left to right, if a character has appeared before at index i, then the left bound should be i+1, in that way we can avoid counting repeated character in a substring. \\n```\\nclass Solution {\\n    public long appealSum(String s) {\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        long res = 0;\\n        int len = s.length();\\n        for(int i=0;i<len;i++){\\n            char ch = s.charAt(i);\\n            int left = 0;\\n            int right = len-i;\\n            if(map.containsKey(ch)){\\n                int index = map.get(ch);\\n                left = i-index;\\n            }else{\\n                left = i-0+1;\\n            }\\n            res+=left*right;\\n            map.put(ch,i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long appealSum(String s) {\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        long res = 0;\\n        int len = s.length();\\n        for(int i=0;i<len;i++){\\n            char ch = s.charAt(i);\\n            int left = 0;\\n            int right = len-i;\\n            if(map.containsKey(ch)){\\n                int index = map.get(ch);\\n                left = i-index;\\n            }else{\\n                left = i-0+1;\\n            }\\n            res+=left*right;\\n            map.put(ch,i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2464476,
                "title": "go-o-n-time-o-1-space",
                "content": "TL;DR\\n\\n```go\\n// O(n) solution\\nfunc appealSum(s string) int64 {\\n    const a = \\'a\\'\\n\\tsum := 0\\n\\tcolSum := 0\\n\\tlatestIndex := [26]int{}\\n\\tfor i := range latestIndex {\\n\\t\\tlatestIndex[i] = -1\\n\\t}\\n\\tfor i := range s {\\n\\t\\tcolSum += i - latestIndex[s[i]-a]\\n\\t\\tsum += colSum\\n\\t\\tlatestIndex[s[i]-a] = i\\n\\t}\\n\\treturn int64(sum)\\n}\\n```\\n\\nFirstly,\\n\\nI found the O(n^2) solution like:\\n```\\nconst (\\n\\ta    = \\'a\\'\\n\\tatoz = 26\\n)\\n\\n// O(26*n^2) solution\\nfunc appealSum(s string) int64 {\\n\\tl := len(s)\\n\\tsum := l\\n\\tcurrentMark := [atoz]int{}\\n\\tfor i := range s {\\n\\t\\tcurrentMark[s[i]-a]++\\n\\t\\t// skip first charactor because we have process as assigning 1 above\\n\\t\\tif i == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tnewMark := [atoz]int{}\\n\\t\\tcopy(newMark[:], currentMark[:])\\n\\t\\tsum += countAppeal(newMark[:])\\n\\t\\tfor j := 1; j < l-i; j++ {\\n\\t\\t\\tnewMark[s[j-1]-a]--\\n\\t\\t\\tnewMark[s[i+j]-a]++\\n\\t\\t\\tsum += countAppeal(newMark[:])\\n\\t\\t}\\n\\t}\\n\\treturn int64(sum)\\n}\\n\\n// O(26) ~ O(1)\\nfunc countAppeal(mark []int) int {\\n\\tcount := 0\\n\\tfor i := range mark {\\n\\t\\tif mark[i] > 0 {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\treturn count\\n}\\n```\\n\\nThen, I found the rule that the sum of appeals of all substrings for a new character is related to the last index of this character in the current string and the current length of the string.\\n\\nBecause the sets of substrings have 2 parts:\\n\\n* From `0` to `the last index of this character`: the sum of appeals will be the same (because there are no new characters).\\n* From `the last index of this character` to `i`: the sum of each substring will be increased 1 for each. So, totally, it increases by length of substring from last index to i.",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n// O(n) solution\\nfunc appealSum(s string) int64 {\\n    const a = \\'a\\'\\n\\tsum := 0\\n\\tcolSum := 0\\n\\tlatestIndex := [26]int{}\\n\\tfor i := range latestIndex {\\n\\t\\tlatestIndex[i] = -1\\n\\t}\\n\\tfor i := range s {\\n\\t\\tcolSum += i - latestIndex[s[i]-a]\\n\\t\\tsum += colSum\\n\\t\\tlatestIndex[s[i]-a] = i\\n\\t}\\n\\treturn int64(sum)\\n}\\n```\n```\\nconst (\\n\\ta    = \\'a\\'\\n\\tatoz = 26\\n)\\n\\n// O(26*n^2) solution\\nfunc appealSum(s string) int64 {\\n\\tl := len(s)\\n\\tsum := l\\n\\tcurrentMark := [atoz]int{}\\n\\tfor i := range s {\\n\\t\\tcurrentMark[s[i]-a]++\\n\\t\\t// skip first charactor because we have process as assigning 1 above\\n\\t\\tif i == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tnewMark := [atoz]int{}\\n\\t\\tcopy(newMark[:], currentMark[:])\\n\\t\\tsum += countAppeal(newMark[:])\\n\\t\\tfor j := 1; j < l-i; j++ {\\n\\t\\t\\tnewMark[s[j-1]-a]--\\n\\t\\t\\tnewMark[s[i+j]-a]++\\n\\t\\t\\tsum += countAppeal(newMark[:])\\n\\t\\t}\\n\\t}\\n\\treturn int64(sum)\\n}\\n\\n// O(26) ~ O(1)\\nfunc countAppeal(mark []int) int {\\n\\tcount := 0\\n\\tfor i := range mark {\\n\\t\\tif mark[i] > 0 {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\treturn count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2447784,
                "title": "c-o-n-time-easiest-to-understand-99-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int n = s.size();\\n        \\n        long long sum = 0;\\n        vector<int> prevIndexMap(26, -1);\\n        for(int i = 0; i < n; ++i){\\n            int index = s[i] - \\'a\\';\\n            int prevIndex = prevIndexMap[index];\\n            prevIndexMap[index] = i;\\n            sum += (i - prevIndex) * (n - i);\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n---\\n\\n# Example: \"abbca\"\\n## Givens:\\n- To make each character unique, I will write \"abbca\" as \"a0 b1 b2 c3 a4\"\\n- s = \"abbca\" (AKA \"a0 b1 b2 c3 a4\")\\n- n = 5\\n\\n## Calculations For \"a0\":\\n\\n- \"a0\" will count for all the following substrings:\\n```\\n\\t\"a0\"\\n\\t\"a0 b1\"\\n\\t\"a0 b1 b2\"\\n\\t\"a0 b1 b2 c3\"\\n\\t\"a0 b1 b2 c3 a4\"\\n```\\n\\n\"sum\" after this will be 5 \\n\\t\\n## Calculations For \"b1\":\\n\\n- \"b1\" will count for all the following substrings:\\n```\\n\\t\"a0 b1\"\\n\\t\"a0 b1 b2\"\\n\\t\"a0 b1 b2 c3\"\\n\\t\"a0 b1 b2 c3 a4\"\\n\\t   \"b1\"\\n\\t   \"b1 b2\"\\n\\t   \"b1 b2 c3\"\\n\\t   \"b1 b2 c3 a4\"\\n```\\n\\n\"sum\" after this will be 13\\n\\n## Calculations For \"b2\":\\n\\n- \"b2\" will count for all the following substrings:\\n```\\n\\t\"b2\"\\n\\t\"b2 c3\"\\n\\t\"b2 c3 a4\"\\n```\\n\\n- Notice that \"b2\" has already been accounted for within the following substrings:\\n\\t- \"a0 b1 b2\"\\n\\t- \"a0 b1 b2 c3\"\\n\\t- \"a0 b1 b2 c3 a4\"\\n\\t- \"b1 b2\"\\n\\t- \"b1 b2 c3\"\\n\\t- \"b1 b2 c3 a4\"\\n\\t- In these cases, \"b2\" has already been counted by the calculations done for \"b1\". The intuition here is that we do not want to count \"b2\" for any substring that already has \"b1\" and \"b2\".\\n\\n- Notice that 3 happens to be the result of the following\\n\\t- (distance from i to last instance of character s[i]) * (distance from i to n)\\n\\n\"sum\" after this will be 16\\n\\n## Calculations For \"c3\":\\n\\n- \"c3\" will count for all the following substrings:\\n```\\n\\t\"a0 b1 b2 c3 a4\"\\n\\t\"a0 b1 b2 c3\"\\n\\t   \"b1 b2 c3\"\\n\\t      \"b2 c3\"\\n\\t\\t     \"c3\"\\n\\t   \"b1 b2 c3 a4\"\\n\\t      \"b2 c3 a4\"\\n\\t         \"c3 a4\"\\n```\\n\\n\"sum\" after this will be 24\\n\\n## Calculations For \"a4\":\\n\\n- \"a4\" will count for all the following substrings:\\n```\\n\\t\"b1 b2 c3 a4\"\\n\\t   \"b2 c3 a4\"\\n\\t      \"c3 a4\"\\n\\t         \"a4\"\\n```\\n\\n- Notice that \"a4\" has already been accounted for within the following substrings:\\n\\t- \"a0 b1 b2 c3 a4\"\\n\\t- In this case, \"a4\" has already been counted by the calculations done for \"a0\". The intuition here is that we do not want to count \"a4\" for any substring that already has \"a0\" and \"a4\".\\n\\n- Notice that 4 happens to be the result of the following\\n\\t- (distance from i to last instance of character s[i]) * (distance from i to n)\\n\\n\"sum\" after this will be 28",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int n = s.size();\\n        \\n        long long sum = 0;\\n        vector<int> prevIndexMap(26, -1);\\n        for(int i = 0; i < n; ++i){\\n            int index = s[i] - \\'a\\';\\n            int prevIndex = prevIndexMap[index];\\n            prevIndexMap[index] = i;\\n            sum += (i - prevIndex) * (n - i);\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\n\\t\"a0\"\\n\\t\"a0 b1\"\\n\\t\"a0 b1 b2\"\\n\\t\"a0 b1 b2 c3\"\\n\\t\"a0 b1 b2 c3 a4\"\\n```\n```\\n\\t\"a0 b1\"\\n\\t\"a0 b1 b2\"\\n\\t\"a0 b1 b2 c3\"\\n\\t\"a0 b1 b2 c3 a4\"\\n\\t   \"b1\"\\n\\t   \"b1 b2\"\\n\\t   \"b1 b2 c3\"\\n\\t   \"b1 b2 c3 a4\"\\n```\n```\\n\\t\"b2\"\\n\\t\"b2 c3\"\\n\\t\"b2 c3 a4\"\\n```\n```\\n\\t\"a0 b1 b2 c3 a4\"\\n\\t\"a0 b1 b2 c3\"\\n\\t   \"b1 b2 c3\"\\n\\t      \"b2 c3\"\\n\\t\\t     \"c3\"\\n\\t   \"b1 b2 c3 a4\"\\n\\t      \"b2 c3 a4\"\\n\\t         \"c3 a4\"\\n```\n```\\n\\t\"b1 b2 c3 a4\"\\n\\t   \"b2 c3 a4\"\\n\\t      \"c3 a4\"\\n\\t         \"a4\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438620,
                "title": "c-shortest-code-easy-to-understand-well-documented",
                "content": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        \\n        long long int n = s.size();\\n        unordered_map<char, vector<long long int>>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[s[i]].push_back(i);\\n        }\\n        long long int ans =0;\\n        for(int i=0;i<26;i++)\\n        {\\n            char c = \\'a\\'+i;\\n            vector<long long int>temp = mp[c];\\n            for(int j=0;j<temp.size();j++)\\n            {\\n                long long int left = temp[j]-(j-1>=0? temp[j-1]: -1 ) -1;\\n                long long int right = n-1-temp[j];\\n                ans = ans + (left+1)*(right+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nThe first thought that usually comes to mind is to go through all the substrings and then find the required answer but we all know that it would be disastrous to do it. As there are in total Nc2 substrings and to traverse each of them will be O(n^3). But we can do much better than that. \\n        \\nThink of it this way, how many times will \\'a\\' contribute to my answer and how many times does \\'b\\', \\'c\\', etc.. If we take for eg. \\'a\\' then we just need to find out the no.of substrings that contain \\'a\\' and it will be added to my answer as the contribution from character \\'a\\'. Because in every substring that \\'a\\' contains, it will be counted one time. So we brought down the question to a much simpler part now. To find this simple subpart now, we will just store the indices of \\'a\\' in a vector in increasing order. Suppose this vector is V. Now suppose we are at V[i], then we will see the previous index of \\'a\\' i.e V[i-1] and subtract these two, that many indices are possible before i and n-V[i] on the right side. We multiply these two that means in these many substrings we have \\'a\\'.. so we go on doing this for every i in V. and add that to our answer. Likewise, we do it for all 26 characters and there we have it at the end. \\n\\n*Happy Coding!!*\\n**Please UPVOTE if you found this helpful**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        \\n        long long int n = s.size();\\n        unordered_map<char, vector<long long int>>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[s[i]].push_back(i);\\n        }\\n        long long int ans =0;\\n        for(int i=0;i<26;i++)\\n        {\\n            char c = \\'a\\'+i;\\n            vector<long long int>temp = mp[c];\\n            for(int j=0;j<temp.size();j++)\\n            {\\n                long long int left = temp[j]-(j-1>=0? temp[j-1]: -1 ) -1;\\n                long long int right = n-1-temp[j];\\n                ans = ans + (left+1)*(right+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431358,
                "title": "python-dp-o-n-space-o-1-with-comments",
                "content": "The idea is to iterate along the string and calculate the appeal for substrings ending at current positions,\\nbased on the previously calculated appeal and then sum these values.\\nConstant space comes from the fixed length array holding last seen positions (lowercars english letters limit  its size) + single variable for the current appear which we reuse.\\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        n = len(s)\\n        # cur is the appeal for substrings ending at \\'i\\' \\n        cur, res = 0, 0\\n        # holds last seen positions for a char\\n        last_seen_at = [-1] * 26\\n        \\n        for i, ch in enumerate(s):\\n            char_key = ord(ch) - ord(\\'a\\')\\n            # previous appeal + current contribution which lasts until \\n            # we see the same char in the prefix\\n            cur += i - last_seen_at[char_key]\\n            last_seen_at[char_key] = i   \\n            # the result is sum of appeals\\n            res += cur\\n            \\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        n = len(s)\\n        # cur is the appeal for substrings ending at \\'i\\' \\n        cur, res = 0, 0\\n        # holds last seen positions for a char\\n        last_seen_at = [-1] * 26\\n        \\n        for i, ch in enumerate(s):\\n            char_key = ord(ch) - ord(\\'a\\')\\n            # previous appeal + current contribution which lasts until \\n            # we see the same char in the prefix\\n            cur += i - last_seen_at[char_key]\\n            last_seen_at[char_key] = i   \\n            # the result is sum of appeals\\n            res += cur\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2404168,
                "title": "python-concise-and-detailed-solution",
                "content": "I believe some of the top solutions for this problem are very elegant but are skipping logical steps that are important to consider when explaining the solution. \\n\\nFirst off, thanks to this vid for the explanation, which much of the inspiration for this solution comes from.\\n\\nhttps://www.youtube.com/watch?v=18Agi7XCGAI&ab_channel=ProgrammingLivewithLarry\\n\\nThe important thing to remember is when trying to improve the brute force O(n^2) solution to (n) is the idea of individual contribution of the indices.\\n\\nWe have to think of this problem in terms of individual indices rather than indiviual substrings.\\n\\n**Ie. How much total appeal does each char/index in the string add to the answer?\\nNote that an index only adds appeal for substrings in which it is the first occurence of that particular character in the substring**\\n\\n\\nConsider example \\'abba\\' which has total appeal of all substrings as 15\\n\\nFor the Index 0 or the first \\'a\\', we have 4 different substrings that contain that a as the ***first*** distinct char. This is simple combinatorics:\\n\\nleft half possibilites: Difference between current index and start of string(0)\\n\"\"\\nright half possibilites - Difference between len of string and current index\\n\"\"\\n\"b\"\\n\"bb\"\\n\"bba\"\\n\\nright half possiblilites x  left half possibilites = 4 x 1 = 4 possible subarrays containing index 0 as first distinct char\\n\\n**Now applying same logic this to index 1, which the first \\'b\\' we get**\\n\\nright half possiblilites x  left half possibilites = 3 x 2 = 6 possible subarrays containing index 1 as first distinct char\\n\\n**Now we consider index 2, which is the first special case we get because it is not the first time we have encountered the char \\'b\\'**\\n\\nWhen calculating the substring possibilities for this index we cannot consider the part of the \\'left\\' part which includes the previous \\'b\\' at index 1 because if we do consider it we would be double counting the \\'b\\' or, in the other words, the index 2 \\'b\\' would not be the first distinct occurence  in all variations including the previous index 1 \\'b\\'\\n\\n**So our left possibilties would include the substrings that only include chars before the current index but after last index at which the char was seen. In code, we can use a hashmap or array to store this info**\\n\\nSo in case of index 2, our left possibilities are ( current index - last index at which the char was seen), which in this case just happens to be the empty string or 1:\\n\\n\"\"\\n\\nThe right possibilties are calculated the same way as before because the current index is still the first distinct char for all subarrays that extend into the right. It is the difference between len of string and current index, in this case being 4-2 = 2:\\n\\n\"\"\\n\"a\"\\n\\nSo, right half possiblilites x left half possibilites = 1 x 2 = 2 possible subarrays containing index 2 as first distinct char\\n\\n**Index 3 also happens to be a special case because we have seen the char \\'a\\' before. Applying the same logic as the previous index, we get:**\\n\\nleft half possibilites:\\n\"\"\\n\"b\"\\n\"bb\"\\n\\nright half possiblities:\\n\"\"\\n\\nright half possiblilites x left half possibilites = 1x 3 = 3 possible subarrays containing index 3 as first distinct char\\n\\nAdding up all the indexes possibilities we get 4+6+2+3 = 15, which is the answer.\\n\\nCode : \\n\\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        last = {}\\n        ans = 0\\n        for i, c in enumerate(s):\\n            left = i-(last[c] if c in last else -1)\\n            right = len(s)-i\\n            ans += left*right\\n            last[c] = i\\n        return ans\\n```\\n\\nIf you are wondering we do i - (-1) in case where c has not been seen before, this is saying we see every char at index -1, to properly calcualte the left possibilies that still include the empty string. For example if we calcuate left for index 0, 0 - (-1) = 1 which equalivent to the combinations possbile to the left of the index 0, which is just the empty string. If we used 0 as a defualt instead of -1 we would get 0 as the possbilities which we know shouldnt happen becuase there has to be atleast one possibility.\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        last = {}\\n        ans = 0\\n        for i, c in enumerate(s):\\n            left = i-(last[c] if c in last else -1)\\n            right = len(s)-i\\n            ans += left*right\\n            last[c] = i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375761,
                "title": "java-o-n-solution-with-explanation",
                "content": "Given a string of length n, we have number of n*(n+1)/2 substrings. And we can assume that those substring contains all the characters, which is 26. Thus, the assume appeal of all the substring is ***res*** = (n*(n+1)/2)26. And it is abvious that for the appeal of each substring, we are counting some extra character that does not exist. So for each character, the extra time we count for that char is the number of substrings that does not have this character. we need to substract that number from the ***res***.\\nex: \\n\\tfor \"abb\", all substrings are: a, ab, abb, b, bb, b. for all the substrings we assume their appeal is 26. and we know that for char \\'a\\', our ***res*** count 6 (total number substrings) for it. But 3 substrings don\\'t have it. So we count 3 extra times and we need to substract it from res. Similiar rules apply for all other characters.\\n\\t\\t\\n\\n\\nThe count method is use to count how many substrings that does not contains the given char variable. The idea is to count how many characters ***cnt*** between the given characters. And the number of substring can be formed from this interval is cnt*(cnt+1)/2.\\nex: a####a######a\\nThe number of substring can be formed in first interval is 4*(4+1)/2. So on and so forth. Accumulate the total number of substrings that can be formed.\\n```\\nclass Solution {\\n    public long appealSum(String s) {\\n\\t\\tlong n = s.length();\\n        long ans = n*(n+1)*13;\\n        for(int i=\\'a\\';i<=\\'z\\';i++){\\n            long sum = count(s, (char)i);\\n            ans-=sum;\\n        }\\n        return ans;\\n    }\\n\\t\\n\\tpublic long count(String s, char c) {\\n        long cnt = 0;\\n        long res=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==c){\\n                res+=cnt*(cnt+1)/2;\\n                cnt=0;\\n            }else{\\n                cnt++;\\n            }\\n        }\\n        return res+cnt*(cnt+1)/2;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long appealSum(String s) {\\n\\t\\tlong n = s.length();\\n        long ans = n*(n+1)*13;\\n        for(int i=\\'a\\';i<=\\'z\\';i++){\\n            long sum = count(s, (char)i);\\n            ans-=sum;\\n        }\\n        return ans;\\n    }\\n\\t\\n\\tpublic long count(String s, char c) {\\n        long cnt = 0;\\n        long res=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==c){\\n                res+=cnt*(cnt+1)/2;\\n                cnt=0;\\n            }else{\\n                cnt++;\\n            }\\n        }\\n        return res+cnt*(cnt+1)/2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309758,
                "title": "a-simple-o-n-solution-in-c",
                "content": "With some math simplification, the function can be written as the following.\\n\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int n = s.length();\\n        int _position[26];\\n        for(int i=0; i < 26; ++i) _position[i] = -1; _position[s[0] - \\'a\\'] = 0;\\n        \\n        long long F=1, A=1;\\n        for(int i = 1; i < n; ++i){\\n            A += (i - _position[s[i] - \\'a\\']); // A[n] = A[n-1] + n - previous_location\\n            F += A; // appealSum(s[1..n]) = appealSum(s[1..n-1]) + A[n]\\n            _position[s[i] - \\'a\\'] = i;\\n        }\\n        return F;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int n = s.length();\\n        int _position[26];\\n        for(int i=0; i < 26; ++i) _position[i] = -1; _position[s[0] - \\'a\\'] = 0;\\n        \\n        long long F=1, A=1;\\n        for(int i = 1; i < n; ++i){\\n            A += (i - _position[s[i] - \\'a\\']); // A[n] = A[n-1] + n - previous_location\\n            F += A; // appealSum(s[1..n]) = appealSum(s[1..n-1]) + A[n]\\n            _position[s[i] - \\'a\\'] = i;\\n        }\\n        return F;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220722,
                "title": "recursive-solution",
                "content": "```\\nfunc sum(vals []int) (s int) {\\n    for _, v := range vals {\\n        s += v\\n    }\\n    return\\n}\\n\\nfunc appealSum(s string) int64 {\\n    answers := make([]int, len(s))\\n    lastSeen := map[byte]int{}\\n    appeal(s, 0, answers, lastSeen)\\n    return int64(sum(answers))\\n}\\n\\n// assumption: no duplicates\\nfunc appeal(s string, i int, answers []int, lastSeen map[byte]int) int {\\n    if i == len(s) {return 0} // base case\\n    \\n    nextAns := appeal(s, i+1, answers, lastSeen)\\n    \\n    uniqueCharsFromSubstringsStartingFromMe := 0\\n    if at, seen := lastSeen[s[i]]; seen {\\n        uniqueCharsFromSubstringsStartingFromMe = at - i\\n    } else {\\n        uniqueCharsFromSubstringsStartingFromMe = len(s) - i\\n    }\\n    \\n    lastSeen[s[i]] = i\\n    answers[i] = uniqueCharsFromSubstringsStartingFromMe + nextAns\\n    return answers[i]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc sum(vals []int) (s int) {\\n    for _, v := range vals {\\n        s += v\\n    }\\n    return\\n}\\n\\nfunc appealSum(s string) int64 {\\n    answers := make([]int, len(s))\\n    lastSeen := map[byte]int{}\\n    appeal(s, 0, answers, lastSeen)\\n    return int64(sum(answers))\\n}\\n\\n// assumption: no duplicates\\nfunc appeal(s string, i int, answers []int, lastSeen map[byte]int) int {\\n    if i == len(s) {return 0} // base case\\n    \\n    nextAns := appeal(s, i+1, answers, lastSeen)\\n    \\n    uniqueCharsFromSubstringsStartingFromMe := 0\\n    if at, seen := lastSeen[s[i]]; seen {\\n        uniqueCharsFromSubstringsStartingFromMe = at - i\\n    } else {\\n        uniqueCharsFromSubstringsStartingFromMe = len(s) - i\\n    }\\n    \\n    lastSeen[s[i]] = i\\n    answers[i] = uniqueCharsFromSubstringsStartingFromMe + nextAns\\n    return answers[i]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2213524,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    long long count(string &s, char c){\\n        long long n = s.size();\\n        long long total = (n*(n+1))>>1;\\n        long long res = 0;\\n        long long ct = 0;\\n        for(int i =0;i<n; ++i){\\n            if(s[i] == c){\\n                res+= (ct*(ct+1))>>1;\\n                ct =0;\\n            }\\n            else ct++;\\n        }\\n         res+= (ct*(ct+1))>>1;\\n        return total - res;\\n    }\\npublic:\\n    long long appealSum(string s) {\\n      long long ans = 0;\\n        for(char i = \\'a\\' ; i<=\\'z\\' ; ++i){\\n            ans+= count(s, i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long count(string &s, char c){\\n        long long n = s.size();\\n        long long total = (n*(n+1))>>1;\\n        long long res = 0;\\n        long long ct = 0;\\n        for(int i =0;i<n; ++i){\\n            if(s[i] == c){\\n                res+= (ct*(ct+1))>>1;\\n                ct =0;\\n            }\\n            else ct++;\\n        }\\n         res+= (ct*(ct+1))>>1;\\n        return total - res;\\n    }\\npublic:\\n    long long appealSum(string s) {\\n      long long ans = 0;\\n        for(char i = \\'a\\' ; i<=\\'z\\' ; ++i){\\n            ans+= count(s, i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210411,
                "title": "easy-solution-with-explanation",
                "content": "```\\n/*\\n\\nApproch:\\n________\\n\\n+ We will check how much each charachter is contrubuting to the answer\\n  (for this hard part is how to deal with reapeatating charachter)\\n+ suppose string a b c d e\\n  here c will contribute \\n  string that comes c \\n  that are   a b c\\n             a b c d \\n             a b c d e \\n               b c \\n               b c d \\n               b c d e\\n                 c \\n                 c d \\n                 c d e\\n    so total = (a , b , c)*(d , e) = 3 * 2 = 6\\n    \\n    exception when we will have duplicate elements\\n    string    a  b c d b e f\\n                       _\\n    here the second b will have only subtring stating from first b and ending at end\\n    ex         c d b\\n               c d b e\\n               c d b e f\\n                 d b\\n                 d b e\\n                 d b e f\\n                   b\\n                   b e \\n                   b e f\\n    so total = 3*3 = 9\\n    \\n    so the formula is\\n    \\n    for each char\\n        numbers of char between current char and previous same char came if its first then position of char x\\n        char remained after i\\n        \\n        i.e.   (i - prevOccured[cur_char] + 1)*(n-i)\\n    \\n*/\\n\\n\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int prevOccured[26] = {0};\\n        long long ans = 0;\\n        int sz = s.length();\\n        \\n        for(int i = 0 ; i < sz ; i++){\\n            char cur = s[i];\\n            int contributingTo = (i - prevOccured[cur - \\'a\\']+1);\\n            ans += (contributingTo*(sz-i));\\n            prevOccured[(cur - \\'a\\')] = i+1;\\n            \\n        }\\n        return ans;\\n    }   \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\nApproch:\\n________\\n\\n+ We will check how much each charachter is contrubuting to the answer\\n  (for this hard part is how to deal with reapeatating charachter)\\n+ suppose string a b c d e\\n  here c will contribute \\n  string that comes c \\n  that are   a b c\\n             a b c d \\n             a b c d e \\n               b c \\n               b c d \\n               b c d e\\n                 c \\n                 c d \\n                 c d e\\n    so total = (a , b , c)*(d , e) = 3 * 2 = 6\\n    \\n    exception when we will have duplicate elements\\n    string    a  b c d b e f\\n                       _\\n    here the second b will have only subtring stating from first b and ending at end\\n    ex         c d b\\n               c d b e\\n               c d b e f\\n                 d b\\n                 d b e\\n                 d b e f\\n                   b\\n                   b e \\n                   b e f\\n    so total = 3*3 = 9\\n    \\n    so the formula is\\n    \\n    for each char\\n        numbers of char between current char and previous same char came if its first then position of char x\\n        char remained after i\\n        \\n        i.e.   (i - prevOccured[cur_char] + 1)*(n-i)\\n    \\n*/\\n\\n\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int prevOccured[26] = {0};\\n        long long ans = 0;\\n        int sz = s.length();\\n        \\n        for(int i = 0 ; i < sz ; i++){\\n            char cur = s[i];\\n            int contributingTo = (i - prevOccured[cur - \\'a\\']+1);\\n            ans += (contributingTo*(sz-i));\\n            prevOccured[(cur - \\'a\\')] = i+1;\\n            \\n        }\\n        return ans;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187575,
                "title": "very-easy-cpp-with-map",
                "content": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        map<char,int> mp;\\n        for(int i=0;i<26;i++)mp[\\'a\\'+i]=-1;\\n        long long ans=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            ans+=(i-mp[s[i]])*1ll*(n-i);\\n            mp[s[i]]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        map<char,int> mp;\\n        for(int i=0;i<26;i++)mp[\\'a\\'+i]=-1;\\n        long long ans=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            ans+=(i-mp[s[i]])*1ll*(n-i);\\n            mp[s[i]]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156855,
                "title": "c-o-n-time-o-1-space",
                "content": "* Each char appears in substrings which are starting from the \"Last occurrence index\" up to the current index. (i - lastOcuranceIndex)\\n* Each char appears in substrings that are ending from the current index up to the last index of the string. (n - i)\\n* So in total, each char appears in (i - lastOcuranceIndex)* (n - i) substrings\\n\\n\\n\\n```\\n    public long AppealSum(string s)\\n    {\\n        int n = s.Length;\\n        int[] last = Enumerable.Repeat(-1, 26).ToArray();  //Last index of each char in input string\\n        long result = 0;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            result += (i - last[s[i] - \\'a\\']) * (n - i);\\n            last[s[i] - \\'a\\'] = i;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public long AppealSum(string s)\\n    {\\n        int n = s.Length;\\n        int[] last = Enumerable.Repeat(-1, 26).ToArray();  //Last index of each char in input string\\n        long result = 0;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            result += (i - last[s[i] - \\'a\\']) * (n - i);\\n            last[s[i] - \\'a\\'] = i;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2155802,
                "title": "substrings",
                "content": "\\n\\n// Thought Process : find the contribution of each unique char \\n\\n// contribution here means no of substrings in which that character is present atleast\\n// one time\\n\\n// for eg : lets take a substring \"aacbaa\" here \\'a\\' is present is 4 times but its \\n// contribution will be 1 no matter how many times its present.\\n\\n\\n\\n// so for each unique char , find in how many substrings they are present atleast one time\\n // then add them and thats the answer\\n\\n\\n// Formula : total no of substrings in which char c is present atleast 1 time =  \\n             // totalsubstrings - total substrings containing no such char c\\n                 \\n\\n \\n\\n\\nclass Solution {\\npublic:\\n    \\n     long long ContributionOfChar(char c,string s) {\\n      \\n      long long cnt = 0 ;\\n      long long n = s.size() ;\\n      long long  totalSubstrings = n*(n+1)/2 ;\\n      long long res = 0 ;\\n         \\n      for(int i=0 ;i<n ;i++) {\\n          \\n         if(s[i]==c)\\n         {\\n             \\n             // cnt gives no of  consecutive characters present before c or  after c.\\n             // add the no of substrings u can make through cnt \\n             res +=  cnt*(cnt+1)/2 ;\\n             cnt = 0 ;\\n             \\n         } \\n          else \\n         {\\n             \\n             cnt++ ;\\n         }\\n          \\n      } // loop ends\\n      \\n      // dont forget to consider the consecutive characters present after the last\\n      // occurences of c  , add no of substrings made using them.\\n       res += cnt*(cnt+1)/2 ; \\n      \\n      // now accordeing to formula\\n      long long requiredNo = totalSubstrings - res ;\\n      return requiredNo ;\\n  }\\n    \\n    // TC : O(N*26) SC : O(1)\\n    \\n    long long appealSum(string s) {\\n        \\n        long long ans = 0 ;\\n        \\n        for(char i = \\'a\\' ; i<=\\'z\\' ;i++) {\\n            \\n            ans += ContributionOfChar(i,s) ;\\n        }\\n        return ans ;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n     long long ContributionOfChar(char c,string s) {\\n      \\n      long long cnt = 0 ;\\n      long long n = s.size() ;\\n      long long  totalSubstrings = n*(n+1)/2 ;\\n      long long res = 0 ;\\n         \\n      for(int i=0 ;i<n ;i++) {\\n          \\n         if(s[i]==c)\\n         {\\n             \\n             // cnt gives no of  consecutive characters present before c or  after c.\\n             // add the no of substrings u can make through cnt \\n             res +=  cnt*(cnt+1)/2 ;\\n             cnt = 0 ;\\n             \\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2154796,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        l=len(s)\\n        ans=0\\n        indices=[-1 for i in range(26)]\\n        for i in range(l-1,-1,-1):\\n            indices[ord(s[i])-97]=i\\n            z=sorted(i for i in indices if i!=-1)+[l]\\n            for j in range(1,len(z)):\\n                ans+=(z[j]-z[j-1])*j\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        l=len(s)\\n        ans=0\\n        indices=[-1 for i in range(26)]\\n        for i in range(l-1,-1,-1):\\n            indices[ord(s[i])-97]=i\\n            z=sorted(i for i in indices if i!=-1)+[l]\\n            for j in range(1,len(z)):\\n                ans+=(z[j]-z[j-1])*j\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2151338,
                "title": "observation-from-2d-table-with-picture",
                "content": "```\\nTable indicates number of distinct characters in substring(i to j)\\ndp[0][0]=1  -> indicates 1 distinct character in substing \"a\" from 0th to 0th index\\ndp[0][3]=3  -> indicates 3 distinct characters in substring \"abbc\" from 0th to 3rd index\\n```\\n\\n![image](https://assets.leetcode.com/users/images/21554c6c-30d4-411c-800e-f8f4689eac4e_1655212586.3326821.jpeg)\\n\\n```\\ndraw table like tushar roy in palindrome ques\\nadd numbers in table\\nans += i-prev[s[i]-\\'a\\']\\nand later prev[s[i]-\\'a\\']=i;\\n```\\n\\n## CODE\\n```cpp\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        vector<int> prev(26,-1);\\n        long long sum=0;\\n        long long ans=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            sum += i-prev[s[i]-\\'a\\'];\\n            ans+=sum;\\n            prev[s[i]-\\'a\\']=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nTable indicates number of distinct characters in substring(i to j)\\ndp[0][0]=1  -> indicates 1 distinct character in substing \"a\" from 0th to 0th index\\ndp[0][3]=3  -> indicates 3 distinct characters in substring \"abbc\" from 0th to 3rd index\\n```\n```\\ndraw table like tushar roy in palindrome ques\\nadd numbers in table\\nans += i-prev[s[i]-\\'a\\']\\nand later prev[s[i]-\\'a\\']=i;\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        vector<int> prev(26,-1);\\n        long long sum=0;\\n        long long ans=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            sum += i-prev[s[i]-\\'a\\'];\\n            ans+=sum;\\n            prev[s[i]-\\'a\\']=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131626,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    long long appealSum(string s) \\n    {\\n         vector<int>prev(26,-1);\\n        ll res=0,n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=s[i]-\\'a\\';\\n            ll l=i-prev[x],r=n-i;\\n            res+=l*r;\\n            prev[x]=i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    long long appealSum(string s) \\n    {\\n         vector<int>prev(26,-1);\\n        ll res=0,n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=s[i]-\\'a\\';\\n            ll l=i-prev[x],r=n-i;\\n            res+=l*r;\\n            prev[x]=i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098355,
                "title": "python-solution-with-explanation",
                "content": "The appeal of a string is the number of distinct characters found in the string.\\n-> We only count the char appear first in a string.\\nFor example appeal of \\'**a**aaaa**b**\\' is equal to 2.\\nSo the question becomes for any s[i] in string, how many substrings it is the first?\\nThese question can be disscussed in two cases.\\n1. s[i] appear first in whole string.\\n2. Threre is a same character appear eralier in the string.\\n\\nFor case 1, we count the number of substring contains s[i].\\nObviously, it will be (i + 1) * (n - i)\\n\\t\\nFor case 2 , we need to know th index of the previous identical charcater.\\nWe assume it is pre[s[i]],  the number of substring contains s[i] and s[i] is the first  appearance will be (i - pre[s[i]]) * (n - i)\\nThe pre[s[i]] can be recorded when we go through the iterations.\\n\\nFinally, we can find out the diffference between these two cases is the multiplier.\\nIf we assume for all alphabet, pre[alphabet] = -1 in the first case, these can be merged to **(i - pre[s[i]]) * (n - i)**.\\n\\nTime complexity: O(n)\\nSpace complexity: O(26) -> O(1)\\n\\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        pre = [-1] * 26\\n        ans = 0\\n        n = len(s)\\n        for i in range(n):\\n            ans += (i - pre[ord(s[i]) - 97]) * (n - i)\\n            pre[ord(s[i]) - 97] = i\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        pre = [-1] * 26\\n        ans = 0\\n        n = len(s)\\n        for i in range(n):\\n            ans += (i - pre[ord(s[i]) - 97]) * (n - i)\\n            pre[ord(s[i]) - 97] = i\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050236,
                "title": "c-left-points-right-points",
                "content": "Solution inspired from [votrubac](hthttps://leetcode.com/problems/total-appeal-of-a-string/discuss/1999226/Combinatoricstp://)\\n* **For any character `s[i]` The number of substrings that it is a part of are `(i+1) * (n-i)`.**\\n* Because at any index `i`  number of points to choose from left portion (incuding the current index i) = `i +1` and number of points to choose from right portion (including the current index i) = `(n-i)`. Hence, total possible combinations = `leftChoose * rightChoose.` \\n* But When  we encounter a character that had been previously encountered , we have to subtract the number of points that the previous character was part of (stored in `lastOccur` ) so that we dont repeat count to our answer.\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    ll ans = 0 ;\\n    \\n    ll appealSum(string s) {\\n        vector<int>lastOccur(26) ;\\n        int n = s.size() ;\\n        \\n        for(int i = 0 ; i < n ; ++i ){\\n            ans += 1LL*(i + 1 - lastOccur[s[i]-\\'a\\'] ) * 1LL*(n - i ) ;\\n            lastOccur[s[i]-\\'a\\'] = i + 1 ; //number of starting points \\n        }   \\n        \\n        return ans ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    ll ans = 0 ;\\n    \\n    ll appealSum(string s) {\\n        vector<int>lastOccur(26) ;\\n        int n = s.size() ;\\n        \\n        for(int i = 0 ; i < n ; ++i ){\\n            ans += 1LL*(i + 1 - lastOccur[s[i]-\\'a\\'] ) * 1LL*(n - i ) ;\\n            lastOccur[s[i]-\\'a\\'] = i + 1 ; //number of starting points \\n        }   \\n        \\n        return ans ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046100,
                "title": "python-solution-with-comment",
                "content": "```class Solution(object):\\n    def appealSum(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n=len(s)\\n        lastMe=[-1]*26\\n        # index: what letter, content: what position it\\'s in\\n        totalAppeal=0\\n        \\n        for i in range(n):\\n            j=lastMe[ord(s[i])-ord(\\'a\\')]\\n            totalAppeal+=(i-j)*(n-i)\\n            lastMe[ord(s[i])-ord(\\'a\\')]=i\\n            #This time see letter s[i] in i\\'s position, record it.\\n        \\n        return totalAppeal\\n    \\n\"\"\" count subarray by element\\n\\n   example: XXXaXXaXaXXX\\n               j  i    n-1\\n    on i\\'s left, can take (i-j) paranthesis, like this a[X[X[a\\n    on i\\'s right, can take (n-i) paranthesis, like this a]X]a]X]X]X]\\n    \\n    # of element from a to b, including a and b, is b+1-a\\n    # of element from a to b, excluding a or b, is b-a\\n    \\n    \"\"\" ```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```class Solution(object):\\n    def appealSum(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n=len(s)\\n        lastMe=[-1]*26\\n        # index: what letter, content: what position it\\'s in\\n        totalAppeal=0\\n        \\n        for i in range(n):\\n            j=lastMe[ord(s[i])-ord(\\'a\\')]\\n            totalAppeal+=(i-j)*(n-i)\\n            lastMe[ord(s[i])-ord(\\'a\\')]=i\\n            #This time see letter s[i] in i\\'s position, record it.\\n        \\n        return totalAppeal\\n    \\n\"\"\" count subarray by element\\n\\n   example: XXXaXXaXaXXX\\n               j  i    n-1\\n    on i\\'s left, can take (i-j) paranthesis, like this a[X[X[a\\n    on i\\'s right, can take (n-i) paranthesis, like this a]X]a]X]X]X]\\n    \\n    # of element from a to b, including a and b, is b+1-a\\n    # of element from a to b, excluding a or b, is b-a\\n    \\n    \"\"\" ```",
                "codeTag": "Java"
            },
            {
                "id": 2045547,
                "title": "simple-efficient-solution",
                "content": "```\\ntypedef long long ll;\\n#define endl \\'\\\\n\\'\\nconst ll mod = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    long long appealSum(const string& s) {\\n        ll sz = s.length();\\n        vector<ll>dp(sz), lasPos(26);\\n        lasPos[s.front()-\\'a\\']++;\\n        ++dp.front();\\n        for (ll i = 1;i < sz;++i) {\\n            dp[i] = dp[i - 1] + i + 1 - lasPos[s[i] - \\'a\\'];\\n            lasPos[s[i] - \\'a\\'] = i + 1;\\n        }\\n        return accumulate(dp.begin(), dp.end(), 0LL);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef long long ll;\\n#define endl \\'\\\\n\\'\\nconst ll mod = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    long long appealSum(const string& s) {\\n        ll sz = s.length();\\n        vector<ll>dp(sz), lasPos(26);\\n        lasPos[s.front()-\\'a\\']++;\\n        ++dp.front();\\n        for (ll i = 1;i < sz;++i) {\\n            dp[i] = dp[i - 1] + i + 1 - lasPos[s[i] - \\'a\\'];\\n            lasPos[s[i] - \\'a\\'] = i + 1;\\n        }\\n        return accumulate(dp.begin(), dp.end(), 0LL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024759,
                "title": "c-solution-with-speed-complexity-o-n-and-space-complexity-o-26",
                "content": "### **Thought process**\\n- First we can observe the provided example substring \"abbca\".\\n\\n\\t|index|0|1|2|3|4|\\n\\t|--|---| --| --|--|--|\\n\\t|char |<ins>__a__</ins> |<ins>__b__</ins>|b|<ins>__c__</ins>|a|\\n\\tThe appeal of this substring is 3 by counting \\'a\\', \\'b\\', \\'c\\' at index 0, 1, 3.\\n\\n- Next we compare with another substring \"bbca\", which has same appeal count but counts different index (1, 3, 4).\\n\\t|index|0|1|2|3|4|\\n\\t|--|---| --| --|--|--|\\n\\t|char | |<ins>__b__</ins>|b|<ins>__c__</ins>|<ins>__a__</ins>|\\n\\n- We now observe the \\'a\\' at index 4. \\n\\tThe \\'a\\' at index 0 is absent in the second case. Since there is no other duplicates before index 4, this \\'a\\' is then counted in the substring\\'s appeal.\\n\\n\\tWe now conclude with : for a character to be counted in an appeal, there must be no duplicates before its index. Thus, we can calculate the time for a character to be included in an appeal using this conclusion.\\n\\t\\n\\t0. Let N be the length of the string array. \\n\\t1. Let i be the current index and C be the current character.\\n\\t2. Let i\\' be the closest index befor i where another C appears. If such i\\' DNE, set to -1. (which means it is before the front of the array)\\n\\t3. We have (i - i\\'-1) characters between the two C\\'s, and (n-i-1) characters from i+1 to the end of array.\\n\\t\\t```text\\n\\t\\t| index | ... |  i\\' | ... |  i  | ... |  N  |\\n\\t\\t| char  | ... |  C  | ... |  C  | ... | /0  |\\n\\t\\t\\t\\t\\t\\t\\t   ^           ^\\n\\t\\t\\t\\t \\t    (i-i\\'-1)chars   (n-i-1)chars\\n\\t\\t```\\n\\t\\n\\t4. Including empty string, there are (i-i\\') possible substrings next to index i that doesnot contain C at i\\'. Similarly, there are (n-i) possible substrings after index i. We now can calculate : character C at index i would be counted (i-i\\')*(n-i) times in total.\\n\\t\\n\\tNote : In 2. we can assign an int [26] array withch takes O(26) space to store C\\'s position i\\' for each alphebet.\\n\\t \\n- Fallow down this idea, we can iterate through the array and perform calculatation for each character individualy.\\n\\t\\n### **Code**\\n```c++\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long ans = 0;\\n        long long n = s.size();\\n        vector<int> last_appear(\\'z\\'-\\'a\\'+1, -1);   // record the most recent index of each alphabet\\n        for(int i = 0 ; i < n ; ++i){ \\n            long long left_count  = i - last_appear[s[i]-\\'a\\'];\\n            long long right_count = n - i;     \\n            ans += left_count * right_count ; \\n            // possible substrings that include the current char and exclude the same char appears previously\\n            \\n            last_appear[s[i]-\\'a\\'] = i;   // update the record\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```text\\n\\t\\t| index | ... |  i\\' | ... |  i  | ... |  N  |\\n\\t\\t| char  | ... |  C  | ... |  C  | ... | /0  |\\n\\t\\t\\t\\t\\t\\t\\t   ^           ^\\n\\t\\t\\t\\t \\t    (i-i\\'-1)chars   (n-i-1)chars\\n\\t\\t```\n```c++\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long ans = 0;\\n        long long n = s.size();\\n        vector<int> last_appear(\\'z\\'-\\'a\\'+1, -1);   // record the most recent index of each alphabet\\n        for(int i = 0 ; i < n ; ++i){ \\n            long long left_count  = i - last_appear[s[i]-\\'a\\'];\\n            long long right_count = n - i;     \\n            ans += left_count * right_count ; \\n            // possible substrings that include the current char and exclude the same char appears previously\\n            \\n            last_appear[s[i]-\\'a\\'] = i;   // update the record\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017013,
                "title": "java-o-n-time-and-o-1-space-explanation",
                "content": "Let us take the given example string \"abbca\" \\n\\nThings good to know before you start: \\n1. At each step, the number of substrings added = number of characters up until that point = number of substrings from previous step + 1\\n\\n\\tstep1: \"a\"\\n\\tstep2: \"b\", \"ab\" \\n\\tstep3: \"b\", \"bb\", \"abb\" \\n\\tstep4: \"c\", \"bc\", \"bbc\", \"abbc\"\\n\\tstep5: \"a\", \"ca\", \"bca\", \"bbca\", \"abbca\" \\n\\t\\n\\tWhy? If you look carefully how the substrings are formed, you are taking the substrings from the previous step and appending the new character to it at the end. Also since the character itself forms a substring you get: \\n\\t\\n\\tNumber of substring at step i = Number of substring at step (i - 1) + 1\\n\\t\\n2. Appeal at each step: \\n\\n\\tWhen you take the first character, the appeal will always be 1.\\n\\t\\n\\tWhen you take a new character (next one), you form the substring by adding that to the substrings from previous step. There can be two cases here: \\n\\t\\n\\t1. Some of the substrings can contain the new character being added - in which case it won\\'t contribute anything extra to the appeal (the appeal of that substring from the previous step will remain here too)\\n\\t2. For the substrings from the previous step that don\\'t contain the new character, 1 will be added to the appeal of these substrings. \\n\\n\\nConsidering the above things, we can easily come up with the following equation: \\n\\nScore at step i = 1 (character itself is a substring) + (Previous step appeal) + (Number of substrings in previous step) - (Number of substrings from previous step containing the new character added in current step)\\n\\n\\t\\nWe can have an array of size 26 to store the number of substrings containing a particular character at any step. \\n\\n```\\n\\n    public long appealSum(String s) {\\n        \\n        long result = 0, prev = 0; \\n        \\n        int[] count = new int[26]; \\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            \\n            int c = s.charAt(i) - \\'a\\'; \\n            long cur = 1 + prev + i - count[c]; \\n            result += cur; \\n            prev = cur;\\n            count[c] = i + 1; \\n        }\\n        \\n        return result; \\n    }\\n```\\n\\nTime complexity: O(N)\\nSpace complexity: O(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    public long appealSum(String s) {\\n        \\n        long result = 0, prev = 0; \\n        \\n        int[] count = new int[26]; \\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            \\n            int c = s.charAt(i) - \\'a\\'; \\n            long cur = 1 + prev + i - count[c]; \\n            result += cur; \\n            prev = cur;\\n            count[c] = i + 1; \\n        }\\n        \\n        return result; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2012190,
                "title": "python-o-n-o-1-with-4-versions-to-guide-u-a-simpler-code",
                "content": "```python\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        \"\"\"\\n        All the possible substrings = union of all the substrings which ends at i-th position for i <- 0...N\\n        \\n        f(i) = the appeal count of all the substrings that ends with i-th position \\n        \\n        total or final = sum(f(i) for i <- 0...N)\\n        \\n        f(i+1) = f(i) + (char of i+1 increased appeal count: position i+1 - prev position of char of i+1)\\n        \\n        Take the `abbca` as an example,\\n        when i = 0, end_substrings(0) = [\\'a\\'], f(0) = 1\\n        when i = 1, end_substrings(1) = [\\'b\\', \\'ab\\'], f(1) = 3\\n        when i = 2, end_substrings(2) = [\\'b\\', \\'bb\\', \\'abb\\'], f(2) = 4\\n        ....\\n        as you can see, end_substrings(i+1) can be easily constructed from end_substrings(i):\\n            (1). add char of i+1 position into the list \\n            (2). for each element of end_substrings(i) just concat the char of i+1 position \\n        \\n        the construction progress also indicates the relationship between f(i+1) and f(i):\\n            - not everytime the concatenation of the char of i+1 position to the element of end_substrings(i) \\n              will increase the final appeal count of f(i+1)\\n            - it increases the final appeal count of f(i+1) iff char of i+1 position is a char for the concatenated element of end_substrings(i)\\n            - f(i+1) = f(i) + (char of i+1 increased appeal count: position i+1 - prev position of char of i+1)\\n        \\n        This means that we can get f(i) from f(0), f(i),..,f(N) one by one.\\n        \\n        \"\"\"\\n        return self._v4(s)\\n    \\n    \\n    def _v1(self, s: str) -> int:\\n        \"\"\"\\n        In this version, we don\\'t apply any special optimization skills but only write a right version of the discussion step by step\\n        \"\"\"\\n        position_count_dict, prev_position_dict = dict(), dict()\\n        for i, c in enumerate(s):\\n            if c in prev_position_dict:\\n                prev = prev_position_dict[c]\\n                increased = i - prev\\n            else:\\n                increased = i - (-1)\\n            \\n            if i == 0:\\n                prev_position_count = 0\\n            else:\\n                prev_position_count = position_count_dict[i-1]\\n            \\n            cur_position_count = prev_position_count + increased\\n            position_count_dict[i] = cur_position_count\\n            prev_position_dict[c] = i\\n        \\n        final = sum(position_count_dict.values())\\n        return final\\n        \\n    def _v2(self, s: str) -> int:\\n        \"\"\"\\n        As we can see, in version 1, there are some improvements can be done, especially for the position_count_dict\\n            - if the input string s is very long, the position_count_dict will cost lots of memory\\n            - final is the sum of all the position\\'s total appeal count, there is no need to wait all \\n              the posistion\\'s computing finished and then get the sum, we can do this on the fly\\n        \"\"\"\\n        final = 0\\n        prev_position_count = 0\\n        prev_position_dict = dict()\\n        for i, c in enumerate(s):\\n            if c in prev_position_dict:\\n                prev = prev_position_dict[c]\\n                increased = i - prev\\n            else:\\n                increased = i - (-1)\\n            \\n            cur_position_count = prev_position_count + increased\\n            final += cur_position_count\\n            \\n            prev_position_dict[c] = i\\n            prev_position_count = cur_position_count\\n            \\n        return final      \\n    \\n    \\n    def _v3(self, s: str) -> int:\\n            \"\"\"\\n            Based on version 2, now can even write a much simpler version by \\n\\t\\t\\t\\t- using one-line code style of python\\n\\t\\t\\t\\t- using simpler variable names\\n            \"\"\"\\n            final, prev, pos = 0, 0, dict() \\n            for i, c in enumerate(s):\\n                pp = pos[c] if c in pos else -1\\n                increased = i - pp\\n                \\n                cur = prev + increased\\n                final += cur\\n                prev = cur\\n                pos[c] = i\\n\\n            return final      \\n        \\n    def _v4(self, s: str) -> int:\\n            \"\"\"\\n            let\\'s just make it more simpler\\n            \"\"\"\\n            fin, cur, pos = 0, 0, defaultdict(lambda: -1)\\n            for i, c in enumerate(s):\\n                cur += i - pos[c]\\n                fin += cur\\n                pos[c] = i\\n\\n            return fin               \\n```\\n\\nIf you still feel hard to understand the solution, check hanjo108\\'s explanation here [Python3 | O(N) / O(1) | detail for beginners](https://leetcode.com/problems/total-appeal-of-a-string/discuss/1996300/Python3-or-O(N)-O(1)-or-detail-for-beginners)\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        \"\"\"\\n        All the possible substrings = union of all the substrings which ends at i-th position for i <- 0...N\\n        \\n        f(i) = the appeal count of all the substrings that ends with i-th position \\n        \\n        total or final = sum(f(i) for i <- 0...N)\\n        \\n        f(i+1) = f(i) + (char of i+1 increased appeal count: position i+1 - prev position of char of i+1)\\n        \\n        Take the `abbca` as an example,\\n        when i = 0, end_substrings(0) = [\\'a\\'], f(0) = 1\\n        when i = 1, end_substrings(1) = [\\'b\\', \\'ab\\'], f(1) = 3\\n        when i = 2, end_substrings(2) = [\\'b\\', \\'bb\\', \\'abb\\'], f(2) = 4\\n        ....\\n        as you can see, end_substrings(i+1) can be easily constructed from end_substrings(i):\\n            (1). add char of i+1 position into the list \\n            (2). for each element of end_substrings(i) just concat the char of i+1 position \\n        \\n        the construction progress also indicates the relationship between f(i+1) and f(i):\\n            - not everytime the concatenation of the char of i+1 position to the element of end_substrings(i) \\n              will increase the final appeal count of f(i+1)\\n            - it increases the final appeal count of f(i+1) iff char of i+1 position is a char for the concatenated element of end_substrings(i)\\n            - f(i+1) = f(i) + (char of i+1 increased appeal count: position i+1 - prev position of char of i+1)\\n        \\n        This means that we can get f(i) from f(0), f(i),..,f(N) one by one.\\n        \\n        \"\"\"\\n        return self._v4(s)\\n    \\n    \\n    def _v1(self, s: str) -> int:\\n        \"\"\"\\n        In this version, we don\\'t apply any special optimization skills but only write a right version of the discussion step by step\\n        \"\"\"\\n        position_count_dict, prev_position_dict = dict(), dict()\\n        for i, c in enumerate(s):\\n            if c in prev_position_dict:\\n                prev = prev_position_dict[c]\\n                increased = i - prev\\n            else:\\n                increased = i - (-1)\\n            \\n            if i == 0:\\n                prev_position_count = 0\\n            else:\\n                prev_position_count = position_count_dict[i-1]\\n            \\n            cur_position_count = prev_position_count + increased\\n            position_count_dict[i] = cur_position_count\\n            prev_position_dict[c] = i\\n        \\n        final = sum(position_count_dict.values())\\n        return final\\n        \\n    def _v2(self, s: str) -> int:\\n        \"\"\"\\n        As we can see, in version 1, there are some improvements can be done, especially for the position_count_dict\\n            - if the input string s is very long, the position_count_dict will cost lots of memory\\n            - final is the sum of all the position\\'s total appeal count, there is no need to wait all \\n              the posistion\\'s computing finished and then get the sum, we can do this on the fly\\n        \"\"\"\\n        final = 0\\n        prev_position_count = 0\\n        prev_position_dict = dict()\\n        for i, c in enumerate(s):\\n            if c in prev_position_dict:\\n                prev = prev_position_dict[c]\\n                increased = i - prev\\n            else:\\n                increased = i - (-1)\\n            \\n            cur_position_count = prev_position_count + increased\\n            final += cur_position_count\\n            \\n            prev_position_dict[c] = i\\n            prev_position_count = cur_position_count\\n            \\n        return final      \\n    \\n    \\n    def _v3(self, s: str) -> int:\\n            \"\"\"\\n            Based on version 2, now can even write a much simpler version by \\n\\t\\t\\t\\t- using one-line code style of python\\n\\t\\t\\t\\t- using simpler variable names\\n            \"\"\"\\n            final, prev, pos = 0, 0, dict() \\n            for i, c in enumerate(s):\\n                pp = pos[c] if c in pos else -1\\n                increased = i - pp\\n                \\n                cur = prev + increased\\n                final += cur\\n                prev = cur\\n                pos[c] = i\\n\\n            return final      \\n        \\n    def _v4(self, s: str) -> int:\\n            \"\"\"\\n            let\\'s just make it more simpler\\n            \"\"\"\\n            fin, cur, pos = 0, 0, defaultdict(lambda: -1)\\n            for i, c in enumerate(s):\\n                cur += i - pos[c]\\n                fin += cur\\n                pos[c] = i\\n\\n            return fin               \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008220,
                "title": "python3-o-n-time-and-o-1-space-sorting-hash-map",
                "content": "**Algorithm Walkthrough-**\\n* We consider each index the start of some sub arrays. For each index i, there can be at most 26 unique \\'appeals\\' among all its sub arrays.\\n* If for i, an element x occurs at positions j and k with k>j>i, only the position j will contribute to an increment in the total appeal. The next greater appeal will happen when another character appears for the first time. (Appeal will increase by 1)\\n* So, we can store the first occurences of every character till index i (from the right end), then sort these occurences in ascending order. (Max size will be 26)\\n* Suppose \\'b\\' appears for the first time at index j and \\'c\\' appears at index k. Then each index between k and j will act as end points and form one subarray with index i, these subarrays will have the same appeal (equal to the no of unique characters till c\\'s first occurence).\\n* We can then find out the number of subarrays and their appeals bw each pair of first occuring characters. This part will be done in max O(26Log(26)) which can technically be considered as O(1).\\n* We do the above function for every index in s.\\n\\n**Time Complexity:** O(N*26*Log(26)) -> O(N)\\n**Space Complexity:** O(26) -> O(1)\\n\\n```\\n\\ndef appealSum(self, s: str) -> int:\\n\\n\\tclosestOccurence={}\\n\\n\\tdef calculate(ind):\\n\\t\\ttemp=[]\\n\\t\\t# temp will hold the first occurences of all the unique characters in s[i:]\\n\\t\\tfor i in closestOccurence.keys():\\n\\t\\t\\ttemp.append(closestOccurence[i])\\n\\t\\ttemp.sort()\\n\\t\\ttemp.append(len(s)) # in case the last character has appeared before\\n\\t\\tans=0\\n\\t\\tunique=0\\n\\t\\tfor i in range(len(temp)-1):\\n\\t\\t\\tunique+=1\\n\\t\\t\\t# l=number of subarrays with \\'unique\\' unique elements\\n\\t\\t\\tl=temp[i+1]-temp[i]\\n\\t\\t\\tans+=(l*unique)\\n\\t\\treturn ans\\n\\n\\tres=0\\n\\n\\tfor i in range(len(s)-1,-1,-1):\\n\\t\\t# Update the closest occurence of s[i] to i\\n\\t\\tclosestOccurence[s[i]]=i\\n\\t\\tres+=calculate(i)\\n\\n\\treturn res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\n\\ndef appealSum(self, s: str) -> int:\\n\\n\\tclosestOccurence={}\\n\\n\\tdef calculate(ind):\\n\\t\\ttemp=[]\\n\\t\\t# temp will hold the first occurences of all the unique characters in s[i:]\\n\\t\\tfor i in closestOccurence.keys():\\n\\t\\t\\ttemp.append(closestOccurence[i])\\n\\t\\ttemp.sort()\\n\\t\\ttemp.append(len(s)) # in case the last character has appeared before\\n\\t\\tans=0\\n\\t\\tunique=0\\n\\t\\tfor i in range(len(temp)-1):\\n\\t\\t\\tunique+=1\\n\\t\\t\\t# l=number of subarrays with \\'unique\\' unique elements\\n\\t\\t\\tl=temp[i+1]-temp[i]\\n\\t\\t\\tans+=(l*unique)\\n\\t\\treturn ans\\n\\n\\tres=0\\n\\n\\tfor i in range(len(s)-1,-1,-1):\\n\\t\\t# Update the closest occurence of s[i] to i\\n\\t\\tclosestOccurence[s[i]]=i\\n\\t\\tres+=calculate(i)\\n\\n\\treturn res\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2000735,
                "title": "c-simple-solution-o-n",
                "content": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    ll count(string st,char ch){\\n        ll len = st.length(),res=0,cnt=0;\\n        for(int i=0;i<len;i++){\\n            if(st[i]==ch){\\n                res+= ((cnt)*(cnt+1))/2;\\n                cnt=0;\\n            }else\\n                cnt++;\\n        }\\n        res+= ((cnt)*(cnt+1))/2;\\n        return ((len)*(len+1))/2-res;\\n    }\\n    long long appealSum(string st) {\\n        ll total_cnt=0;\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n            total_cnt+=count(st,ch);\\n        }\\n        return total_cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    ll count(string st,char ch){\\n        ll len = st.length(),res=0,cnt=0;\\n        for(int i=0;i<len;i++){\\n            if(st[i]==ch){\\n                res+= ((cnt)*(cnt+1))/2;\\n                cnt=0;\\n            }else\\n                cnt++;\\n        }\\n        res+= ((cnt)*(cnt+1))/2;\\n        return ((len)*(len+1))/2-res;\\n    }\\n    long long appealSum(string st) {\\n        ll total_cnt=0;\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n            total_cnt+=count(st,ch);\\n        }\\n        return total_cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999560,
                "title": "java-o-n-easy-to-understand-with-example",
                "content": "The question boils down to number of times a character comes in all possible substrings.\\n\\nLet\\'s take string `abc` and character `c`, here `c` comes at index = `2`, in a DP approach if you start to count the substrings this character comes in, you will be by adding characters comming before this character inclusively. i.e., `c`, `bc` and `abc` which gives `3` for this specific character which is also equal to index + 1. Now if character repeats then we need to avoid previous substrings so we keep track of last occuring position of the same character and remove that count from the character contribution.\\n\\nAdding this for all the characters would give total appeal of the string.\\n```\\nclass Solution {\\n    public long appealSum(String s) {\\n        long contribution = 0, sum =0;\\n        int previousCount[] = new int[26];\\n        for(int i=0;i<s.length();i++){\\n            contribution+= i+1 - (previousCount[s.charAt(i)-\\'a\\']);\\n            previousCount[s.charAt(i)-\\'a\\'] = i+1;\\n            sum+=contribution;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long appealSum(String s) {\\n        long contribution = 0, sum =0;\\n        int previousCount[] = new int[26];\\n        for(int i=0;i<s.length();i++){\\n            contribution+= i+1 - (previousCount[s.charAt(i)-\\'a\\']);\\n            previousCount[s.charAt(i)-\\'a\\'] = i+1;\\n            sum+=contribution;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998955,
                "title": "java-easy",
                "content": "Easy Example : \\nabcdb\\n01234\\n\\nCaluclate for position =2 (s.charAt(2)=c)\\nc-----> 1              eqn-(i)\\nbc---> 2              eqn-(ii)\\nabc--->3\\n\\npos(2)=sum=1+2+3=6\\n\\nNow for position = 3( s.charAt(3)=d)\\nd----->1\\ncd---->2\\nbcd--->3\\nabcd-->4\\n\\npos(3)=sum=1+2+3+4=10\\n\\nHow can these be related?\\n\\nNow relating pos 2 with 3:\\nd---> 1\\ncd--->1+1(   second one is for d which was not there in eqn (i))\\nbcd--->2+1( here is for that same d which was not ine eqn (ii) )\\nabcd-->3+1  // understood?\\n\\nso when we move from pos2 to pos 3 we added a 4 extra to previous pos output.\\n\\nNow see for pos 3 and pos 4:\\n\\nNow for position = 3( s.charAt(3)=d)\\nd----->1\\ncd---->2\\nbcd--->3\\nabcd-->4      \\n\\nsum=10\\n\\nNow for position = 4( s.charAt(3)=b)\\nb------>1\\ndb----->1+1\\ncdb---->2+1\\nbcdb--->3+0( b is already there)\\nabcdb-->4 +0( b is already there )\\n \\n sum=10+3 =13\\n\\nwe can deduce fromula from here,\\npos(4)=pos(3)+ 1+ (current positon of newly added b- last repeated psotion-1)\\n      =  10 +  1+   ( 4  -1  -1)\\n\\t  =13\\n1 is added because of the character itself,  at last 1 is substracted because of index issue in string abcdb ,here b\\'s current pos=4 and last repeated pos=1 , so 4-1=3 but in between there are only 2 terms. \\n\\n\\n```\\nclass Solution {\\n    public long appealSum(String s) {\\n        int n=s.length();\\n        long h=0,base=0;\\n        int ch[]=new int[26];\\n        for(int i=0;i<26;i++)\\n            ch[i]=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            base=base+i-ch[s.charAt(i)-\\'a\\'];\\n            ch[s.charAt(i)-\\'a\\']=i;\\n            h+=base;\\n         \\n            System.out.println(h);\\n                \\n        }\\n        return h;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public long appealSum(String s) {\\n        int n=s.length();\\n        long h=0,base=0;\\n        int ch[]=new int[26];\\n        for(int i=0;i<26;i++)\\n            ch[i]=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            base=base+i-ch[s.charAt(i)-\\'a\\'];\\n            ch[s.charAt(i)-\\'a\\']=i;\\n            h+=base;\\n         \\n            System.out.println(h);\\n                \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1998361,
                "title": "o-26-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long n=s.size();\\n        long long ans=0;\\n        for(int i=0;i<26;i++){\\n            char ch=(char)(\\'a\\'+i);\\n            long long c=0;\\n            long long t=0; //no of substrings in which ch isnt present\\n            for(int j=0;j<n;j++){\\n                if(s[j]==ch){\\n                    t+=(c*(c+1))/2;\\n                    c=0;\\n                }\\n                else\\n                    c++;\\n            }\\n            t+=(c*(c+1))/2;\\n            ans+=(n*(n+1))/2-t; //total-not present=appeal\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long n=s.size();\\n        long long ans=0;\\n        for(int i=0;i<26;i++){\\n            char ch=(char)(\\'a\\'+i);\\n            long long c=0;\\n            long long t=0; //no of substrings in which ch isnt present\\n            for(int j=0;j<n;j++){\\n                if(s[j]==ch){\\n                    t+=(c*(c+1))/2;\\n                    c=0;\\n                }\\n                else\\n                    c++;\\n            }\\n            t+=(c*(c+1))/2;\\n            ans+=(n*(n+1))/2-t; //total-not present=appeal\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998266,
                "title": "java-sliding-window",
                "content": "```\\n    // Sliding window\\n    // TC = O(26N)\\n    public long appealSum(String s) {\\n        int n = s.length();\\n        List<Integer>[] oc = new ArrayList[26];\\n        for (int i = 0; i < 26; i++) oc[i] = new ArrayList<>();\\n\\n        for (int i = 0; i < n; i++) oc[s.charAt(i) - \\'a\\'].add(i);\\n\\n        long total = 0L;\\n\\n        for (List<Integer> indexes : oc) {\\n            for (int idx = 0; idx < indexes.size(); idx++) {\\n                // curr = total number of substrings able  to generate from 0 to idx\\n                // next = total number of substrings able  to generate from idx to next of SW\\n                int curr = indexes.get(idx);\\n                int next = idx < indexes.size() - 1 ? indexes.get(idx + 1) : n;\\n                int right = next - curr;\\n                total += (long) (curr + 1) * right;\\n            }\\n        }\\n\\n        return total;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    // Sliding window\\n    // TC = O(26N)\\n    public long appealSum(String s) {\\n        int n = s.length();\\n        List<Integer>[] oc = new ArrayList[26];\\n        for (int i = 0; i < 26; i++) oc[i] = new ArrayList<>();\\n\\n        for (int i = 0; i < n; i++) oc[s.charAt(i) - \\'a\\'].add(i);\\n\\n        long total = 0L;\\n\\n        for (List<Integer> indexes : oc) {\\n            for (int idx = 0; idx < indexes.size(); idx++) {\\n                // curr = total number of substrings able  to generate from 0 to idx\\n                // next = total number of substrings able  to generate from idx to next of SW\\n                int curr = indexes.get(idx);\\n                int next = idx < indexes.size() - 1 ? indexes.get(idx + 1) : n;\\n                int right = next - curr;\\n                total += (long) (curr + 1) * right;\\n            }\\n        }\\n\\n        return total;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1998059,
                "title": "c-2-line-sol-with-comments-o-n",
                "content": "**Approach:**  The number of substrings that contain the alphabetic character is equivalent to 1 plus the index of the last occurrence of the character before **index i + 1**.\\n\\n-> and The total appeal of all substrings ending at index i is the **total sum of the number of substrings** that contain each alphabetic character.\\n\\n**T.C = O(N)\\nS.C = O(1)**\\n\\n```\\nlong long appealSum(string s) {\\n        long long ans = 0;\\n        int n = s.length();\\n        \\n        vector<int> v(26);  // calculate appeal for each character at index i\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n\\t\\t\\tv[s[i] - \\'a\\'] = i + 1;       \\n\\t\\t\\tfor(int j: v) ans += j;    // total appeal is Sum up of the all character at index i\\n        }\\n        return ans;\\n    }\\n```\\n\\n******************************** **Guys If You Like the Sol. then Plz Plz Upvote it** \\uD83D\\uDE0A **************************",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long appealSum(string s) {\\n        long long ans = 0;\\n        int n = s.length();\\n        \\n        vector<int> v(26);  // calculate appeal for each character at index i\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n\\t\\t\\tv[s[i] - \\'a\\'] = i + 1;       \\n\\t\\t\\tfor(int j: v) ans += j;    // total appeal is Sum up of the all character at index i\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1996810,
                "title": "shortest-code-o-n-o-1-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long ans=0;\\n        vector<int> lastIndex(26);\\n        for(int i=0,n=s.size();i<n;i++){\\n            ans+=(i+1-lastIndex[s[i]-\\'a\\'])*(n-i);\\n            lastIndex[s[i]-\\'a\\']=i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long ans=0;\\n        vector<int> lastIndex(26);\\n        for(int i=0,n=s.size();i<n;i++){\\n            ans+=(i+1-lastIndex[s[i]-\\'a\\'])*(n-i);\\n            lastIndex[s[i]-\\'a\\']=i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996773,
                "title": "c-o-26-n-easy-code-highly-understandable-for-beginners-beats-100",
                "content": "1. In questions where we are supposed to process the string in O(N) time, we should focus on ith index and what information we can gain at ith index.\\n2. A second tip is to try what we can do for each character too.\\n3. Combining above two insights and applying on an example we will see how to solve this problem.\\n\\n\\nLet\\'s see for each character how many subarrays ending at ith index are there.\\nWe will also notice the index of last_occurence of that character.\\n\\n\"fxfz\"\\nfor \\'f\\'\\nending at index 0 \"f\"                      -> 1 substring    [last_occurence = 0 index]\\nending at index 1 \"fx\"                    -> 1 substring    [last_occurence = 0 index]\\nending at index 2  \"fxf\", \"xf\", \"f\"     -> 3 substrings  [last_occurence = 2 index]\\nending at index 3 \"fxfz\", \"xfz\", \"fz\" -> 3 substrings  [last_occurence = 2 index]\\nSo, 8 substrings for \\'f\\' in total\\n\\nfor \\'x\\'\\nending at index 0                   -> 0 substring     [last_occurence = NIL]\\nending at index 1 \"fx\", \"x\"      -> 2 substrings    [last_occurence = 1 index]\\nending at index 2  \"fxf\", \"xf\"   -> 2 substrings   [last_occurence = 1 index]\\nending at index 3 \"fxfz\", \"xfz\" -> 2 substrings   [last_occurence = 1 index]\\nSo, 6 substrings for \\'f\\' in total\\n\\nfor \\'z\\'\\nending at index 0                                 -> 0 substring     [last_occurence = NIL]\\nending at index 1                                 -> 0 substring     [last_occurence = NIL]\\nending at index 2                                 -> 0 substring     [last_occurence = NIL]\\nending at index 4 \"fxfz\", \"xfz\", \"fz\", \"z\" -> 4 substrings   [last_occurence = 3 index]\\nSo, 4 substrings for \\'f\\' in total\\n\\nTotal =  18\\n\\n\\nHence we can observe that ith index the contribution of a character c is equal to 1+index of last occurence of c (including current index).\\n\\nSo if we iterate over all possible characters and then in nested loop iterate over the string, we add the contribution at each index. And we update the last_occurence if we find that character at ith index as last_occurence = i+1.\\n\\nHere\\'s the full code for your better understanding.\\n\\n```\\nlong long appealSum(string s) {\\n        long long n=s.size();\\n\\t\\t\\n\\t\\t// we store final ans here\\n        long long ans=0;\\n\\t\\t\\n\\t\\t// we iterate over all possible characters\\n        for(int i=0;i<26;i++)\\n        {\\n\\t\\t\\t// last_occurence tells the last time the character appeared\\n            long long last_occurence = 0;\\n\\t\\t\\t\\n\\t\\t\\t// here we iterate over the string\\n            for(int j=0;j<n;j++)\\n            {\\n\\t\\t\\t\\t// if we find the character at current index then update last_occurence = j+1\\n                if(s[j]-\\'a\\'==i)\\n                    last_occurence = j+1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// add the number of substrings ending at jth index\\n                ans+=last_occurence;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long appealSum(string s) {\\n        long long n=s.size();\\n\\t\\t\\n\\t\\t// we store final ans here\\n        long long ans=0;\\n\\t\\t\\n\\t\\t// we iterate over all possible characters\\n        for(int i=0;i<26;i++)\\n        {\\n\\t\\t\\t// last_occurence tells the last time the character appeared\\n            long long last_occurence = 0;\\n\\t\\t\\t\\n\\t\\t\\t// here we iterate over the string\\n            for(int j=0;j<n;j++)\\n            {\\n\\t\\t\\t\\t// if we find the character at current index then update last_occurence = j+1\\n                if(s[j]-\\'a\\'==i)\\n                    last_occurence = j+1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// add the number of substrings ending at jth index\\n                ans+=last_occurence;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1996754,
                "title": "python-3-dynamic-programming-o-n-o-1",
                "content": "```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        last = collections.defaultdict(lambda: 0)\\n        curAppeal = totalAppeal = 0\\n        for i, c in enumerate(s):\\n            curAppeal += i + 1 - last[c]\\n            last[c] = i + 1\\n            totalAppeal += curAppeal\\n        \\n        return totalAppeal",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        last = collections.defaultdict(lambda: 0)\\n        curAppeal = totalAppeal = 0\\n        for i, c in enumerate(s):\\n            curAppeal += i + 1 - last[c]\\n            last[c] = i + 1\\n            totalAppeal += curAppeal\\n        \\n        return totalAppeal",
                "codeTag": "Java"
            },
            {
                "id": 1996747,
                "title": "o-n-non-dp-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    long long appealSum(string s)\\n    {\\n        long long res = 0;\\n\\n        // count the contribution of each character to the final sum\\n        for (char c=\\'a\\'; c<=\\'z\\'; c++)\\n            res += appealSumUtil(c, s);\\n\\n        return res;\\n    }\\n\\n    long long appealSumUtil(char c, string& s)\\n    {\\n        long long N = s.size();\\n        long long allCombs = N * (N+1)/2;\\n          \\n        long long count = 0;\\n        long long currCombs = 0;\\n\\n        // Find the count of combinations that won\\'t have c in them\\n        for (int i=0; i<N; i++)\\n        {\\n            // Every time you get a c, calculate the number of combinations that are possible from previous \\'count\\' characters.\\n            // Note that the formula for \\'how many combinations can we form with n characters\\' = n * (n+1)/2\\n            if (s[i] == c)\\n            {\\n                currCombs += count*(count+1)/2;\\n                count = 0;\\n            }\\n            else\\n                count++;\\n        }\\n        \\n        // Count the combinations for the last sub-string too\\n        currCombs += count*(count+1)/2;\\n        \\n        // All combinations - (combinations that wont have c)\\n        return allCombs - currCombs;\\n    }\\n};\\n```\\nCredits: https://leetcode.com/discuss/interview-question/1481915/Amazon-or-OA-or-Count-distinct-characters-in-all-substrings/1094159",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long appealSum(string s)\\n    {\\n        long long res = 0;\\n\\n        // count the contribution of each character to the final sum\\n        for (char c=\\'a\\'; c<=\\'z\\'; c++)\\n            res += appealSumUtil(c, s);\\n\\n        return res;\\n    }\\n\\n    long long appealSumUtil(char c, string& s)\\n    {\\n        long long N = s.size();\\n        long long allCombs = N * (N+1)/2;\\n          \\n        long long count = 0;\\n        long long currCombs = 0;\\n\\n        // Find the count of combinations that won\\'t have c in them\\n        for (int i=0; i<N; i++)\\n        {\\n            // Every time you get a c, calculate the number of combinations that are possible from previous \\'count\\' characters.\\n            // Note that the formula for \\'how many combinations can we form with n characters\\' = n * (n+1)/2\\n            if (s[i] == c)\\n            {\\n                currCombs += count*(count+1)/2;\\n                count = 0;\\n            }\\n            else\\n                count++;\\n        }\\n        \\n        // Count the combinations for the last sub-string too\\n        currCombs += count*(count+1)/2;\\n        \\n        // All combinations - (combinations that wont have c)\\n        return allCombs - currCombs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996711,
                "title": "easy-dp-o-n",
                "content": "```\\nlong long appealSum(string s) {\\n        vector<int>arr(26, -1);\\n        long long n = s.length(), tmp;\\n        long long ans = 0;\\n        \\n        vector<long long>dp(n+1, 0);\\n        for(long long i=0; i<n; i++){\\n\\t\\t\\t// checked how many substrings are affected with addition of  this character\\n            tmp = i - arr[s[i] - \\'a\\'];\\n\\t\\t\\t\\n\\t\\t\\t// total number of appeal with addition of this character= total appeal till last character +  total number of substrings affected with addition of this character\\n            dp[i+1] = dp[i] + tmp;\\n\\t\\t\\t\\n\\t\\t\\t// added total number of appeal in our result\\n            ans += dp[i+1];\\n\\t\\t\\t\\n\\t\\t\\t//update last position of current character\\n            arr[s[i] - \\'a\\'] = i;\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nlong long appealSum(string s) {\\n        vector<int>arr(26, -1);\\n        long long n = s.length(), tmp;\\n        long long ans = 0;\\n        \\n        vector<long long>dp(n+1, 0);\\n        for(long long i=0; i<n; i++){\\n\\t\\t\\t// checked how many substrings are affected with addition of  this character\\n            tmp = i - arr[s[i] - \\'a\\'];\\n\\t\\t\\t\\n\\t\\t\\t// total number of appeal with addition of this character= total appeal till last character +  total number of substrings affected with addition of this character\\n            dp[i+1] = dp[i] + tmp;\\n\\t\\t\\t\\n\\t\\t\\t// added total number of appeal in our result\\n            ans += dp[i+1];\\n\\t\\t\\t\\n\\t\\t\\t//update last position of current character\\n            arr[s[i] - \\'a\\'] = i;\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1996641,
                "title": "o-n-in-10-lines-of-kotlin",
                "content": "```\\nfun appealSum(s: String): Long {\\n        var result = 0L\\n        var map = mutableMapOf<Char, Int>()\\n        for (i in s.indices) {\\n            result += (i + 1).toLong() * (s.length - i).toLong()\\n            if (map.containsKey(s[i])) {\\n                result -= (map[s[i]]!! + 1).toLong() * (s.length - i).toLong()\\n            }\\n            map[s[i]] = i\\n        }\\n        return result\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfun appealSum(s: String): Long {\\n        var result = 0L\\n        var map = mutableMapOf<Char, Int>()\\n        for (i in s.indices) {\\n            result += (i + 1).toLong() * (s.length - i).toLong()\\n            if (map.containsKey(s[i])) {\\n                result -= (map[s[i]]!! + 1).toLong() * (s.length - i).toLong()\\n            }\\n            map[s[i]] = i\\n        }\\n        return result\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1996581,
                "title": "simple-combinatorics-just-another-way-of-creating-all-possible-substrings",
                "content": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        \\n        long long ans = 0;\\n        \\n        unordered_map<char,vector<int>> um;\\n        \\n        int n = s.size();\\n        \\n        for(int i=0;i<n;i++){\\n            um[s[i]].push_back(i);    \\n        }\\n        \\n        ans += (n);\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            char ch = s[i];\\n            \\n            auto it = lower_bound(um[s[i]].begin(),um[s[i]].end(),i);\\n            \\n            if(it == um[s[i]].begin()){\\n                ans += (1LL*(n - i - 1)*(i+1) + (i+1));\\n            }else{\\n                --it;\\n                int idx = it - um[s[i]].begin();\\n                idx = um[s[i]][idx];\\n\\n                if(i == idx+1){\\n                    ans += (1LL*(i - idx)*(n-i) );\\n                }else{\\n                    ans += (1LL*(i - idx)*(n-i-1) + (i-idx));\\n                }\\n                \\n            }\\n\\n        }\\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "class Solution {\\npublic:\\n    long long appealSum(string s) {\\n        \\n        long long ans = 0;\\n        \\n        unordered_map<char,vector<int>> um;\\n        \\n        int n = s.size();\\n        \\n        for(int i=0;i<n;i++){\\n            um[s[i]].push_back(i);    \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1996487,
                "title": "count-contribution-of-each-index-c-o-n-solution",
                "content": "The result will be the sum of contribution of each character in the string\\nThe contribution of each character can be given by (number of characters ont he left of character such that the character does not repeat itself) * (total number of characters on the right).\\nThis formula will generate all substrings using the ith character such that the character only repeats on the right side and not on the left side.\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long res = 0;\\n        int n = s.length();\\n        vector<int> left(n, 1);\\n        map<char, int> m;\\n        for(int i=0; i<n; i++){\\n            if(m.count(s[i])) left[i] = i-m[s[i]];\\n            else left[i] = i+1;\\n            m[s[i]] = i;\\n        }\\n        for(int i=0; i<n; i++){\\n            res += left[i] * (n-i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long res = 0;\\n        int n = s.length();\\n        vector<int> left(n, 1);\\n        map<char, int> m;\\n        for(int i=0; i<n; i++){\\n            if(m.count(s[i])) left[i] = i-m[s[i]];\\n            else left[i] = i+1;\\n            m[s[i]] = i;\\n        }\\n        for(int i=0; i<n; i++){\\n            res += left[i] * (n-i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996478,
                "title": "c-single-for-loop-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        unordered_map<int,int> latest;\\n        long long total = 0;\\n        vector<int> count(s.size(), 0);\\n        \\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            count[i] = ((i-1 >= 0) ? count[i-1] : 0) + i + 1 - (latest.find(s[i]) == latest.end() ? 0 : (latest[s[i]] + 1));\\n            latest[s[i]] = i;\\n            total += count[i];\\n        }\\n        \\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        unordered_map<int,int> latest;\\n        long long total = 0;\\n        vector<int> count(s.size(), 0);\\n        \\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            count[i] = ((i-1 >= 0) ? count[i-1] : 0) + i + 1 - (latest.find(s[i]) == latest.end() ? 0 : (latest[s[i]] + 1));\\n            latest[s[i]] = i;\\n            total += count[i];\\n        }\\n        \\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996468,
                "title": "c-solution-with-o-n-time-and-o-26-space",
                "content": "```\\nlong long appealSum(string s) {\\n        long long ans=1;\\n        vector <int> freq (26,0);\\n        freq[s[0]-\\'a\\']=1;\\n        long long sum=1,diff=1;\\n        for(int i=1;i<s.size();i++)\\n        {\\n            if(!freq[s[i]-\\'a\\'])\\n            {\\n                freq[s[i]-\\'a\\']=i+1;\\n                sum+=(i+1);\\n            }\\n            else\\n            {\\n                sum+=((i+1)-freq[s[i]-\\'a\\']);\\n                freq[s[i]-\\'a\\']=i+1;\\n            }\\n            ans+=sum;\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nlong long appealSum(string s) {\\n        long long ans=1;\\n        vector <int> freq (26,0);\\n        freq[s[0]-\\'a\\']=1;\\n        long long sum=1,diff=1;\\n        for(int i=1;i<s.size();i++)\\n        {\\n            if(!freq[s[i]-\\'a\\'])\\n            {\\n                freq[s[i]-\\'a\\']=i+1;\\n                sum+=(i+1);\\n            }\\n            else\\n            {\\n                sum+=((i+1)-freq[s[i]-\\'a\\']);\\n                freq[s[i]-\\'a\\']=i+1;\\n            }\\n            ans+=sum;\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1996447,
                "title": "simple-c",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        \\n        vector<int> v[26];\\n        int n = s.size();\\n        for(int i=n-1; i>=0; --i)\\n        {\\n            v[s[i]-\\'a\\'].push_back(i);\\n        }\\n        \\n        set<int> st;\\n        long long ans = 0;\\n        for(int i=0; i<n; ++i)\\n        {\\n            st.insert(s[i]);\\n            ans+=st.size();\\n        }\\n            \\n        long long fans = ans;\\n        for(int i=0; i<n; ++i)\\n        {\\n            int x = 0;\\n            if(v[s[i]-\\'a\\'].size()>1)\\n            {\\n                v[s[i]-\\'a\\'].pop_back();\\n                x = v[s[i]-\\'a\\'].back()-i;\\n            }\\n            else\\n            {\\n                x = n-i;\\n            }\\n            \\n            fans+=ans-x;\\n            ans-=x;\\n        }\\n        \\n        return fans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        \\n        vector<int> v[26];\\n        int n = s.size();\\n        for(int i=n-1; i>=0; --i)\\n        {\\n            v[s[i]-\\'a\\'].push_back(i);\\n        }\\n        \\n        set<int> st;\\n        long long ans = 0;\\n        for(int i=0; i<n; ++i)\\n        {\\n            st.insert(s[i]);\\n            ans+=st.size();\\n        }\\n            \\n        long long fans = ans;\\n        for(int i=0; i<n; ++i)\\n        {\\n            int x = 0;\\n            if(v[s[i]-\\'a\\'].size()>1)\\n            {\\n                v[s[i]-\\'a\\'].pop_back();\\n                x = v[s[i]-\\'a\\'].back()-i;\\n            }\\n            else\\n            {\\n                x = n-i;\\n            }\\n            \\n            fans+=ans-x;\\n            ans-=x;\\n        }\\n        \\n        return fans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996433,
                "title": "c-solution-in-o-n-time",
                "content": "```\\n long long appealSum(string s) \\n    {\\n        int n = s.size();\\n        \\n        long long ans =1;\\n        \\n        vector<int> v(26,-1);  \\n        vector<long long> p(n,0);\\n        p[0] = 1;\\n        v[s[0]-\\'a\\'] = 0;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(v[s[i]-\\'a\\']==-1)\\n            {\\n                p[i] = p[i-1]+(i)+1; \\n                ans+=p[i];\\n            }\\n            else\\n            {\\n                int j = v[s[i]-\\'a\\'];\\n                if(j==i-1)\\n                {\\n                    p[i] = p[j]+1;\\n                }\\n                else p[i] = p[i-1]-(j+1)+i+1; \\n                ans+=p[i];\\n            }\\n            v[s[i]-\\'a\\'] = i;\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\n long long appealSum(string s) \\n    {\\n        int n = s.size();\\n        \\n        long long ans =1;\\n        \\n        vector<int> v(26,-1);  \\n        vector<long long> p(n,0);\\n        p[0] = 1;\\n        v[s[0]-\\'a\\'] = 0;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(v[s[i]-\\'a\\']==-1)\\n            {\\n                p[i] = p[i-1]+(i)+1; \\n                ans+=p[i];\\n            }\\n            else\\n            {\\n                int j = v[s[i]-\\'a\\'];\\n                if(j==i-1)\\n                {\\n                    p[i] = p[j]+1;\\n                }\\n                else p[i] = p[i-1]-(j+1)+i+1; \\n                ans+=p[i];\\n            }\\n            v[s[i]-\\'a\\'] = i;\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1996382,
                "title": "c-quick-contribution-method",
                "content": "For every substring formed we are just appending ith character to all the substrings previously made and therefore the intuition here is to calculate the total contribution to all those substring formed .\\n-> if ith character has already occured at some index j then it will be contributing to all those substrings which formed after character j and will not affect all those substrings before index j\\n-> so maintain an array of all characters position and sum up the contribution of ith character from the last occured position of this character.\\n\\n```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        ll ans =0;\\n        vector<ll>idx(26,0); // index of already occured characters.\\n        vector<ll>cont(26,0); // contribution of ith character till ith position\\n        ll temp = 0;\\n        for(int i =0; i < s.size(); i++) {\\n            cont[s[i]-\\'a\\'] = (i-(idx[s[i]-\\'a\\'] - 1)); // updating contribution of ith character\\n            temp += cont[s[i]-\\'a\\'];\\n            idx[s[i]-\\'a\\'] = i + 1; // updating last occured position of current character\\n            \\n            ans += temp;\\n        }\\n        return ans ;\\n    }\\n};\\n```\\n**Hope that helps!!**",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        ll ans =0;\\n        vector<ll>idx(26,0); // index of already occured characters.\\n        vector<ll>cont(26,0); // contribution of ith character till ith position\\n        ll temp = 0;\\n        for(int i =0; i < s.size(); i++) {\\n            cont[s[i]-\\'a\\'] = (i-(idx[s[i]-\\'a\\'] - 1)); // updating contribution of ith character\\n            temp += cont[s[i]-\\'a\\'];\\n            idx[s[i]-\\'a\\'] = i + 1; // updating last occured position of current character\\n            \\n            ans += temp;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996290,
                "title": "o-n-solution-with-detailed-explanation",
                "content": "Using \"abbca\" as an example.\\nfor this string length of n==5, if there is no duplicate letter, then we should return 1x5 + 2x4 + 3x3 + 3x4 + 5x1\\nbut there are duplicates for \\n\\'a\\' at position 0, 4\\n\\'b\\' at position 1, 2\\nUsing \\'b\\' as an example:\\nFor any substring of \"abbca\" which includes [1, 2], this substring will have one pair of duplicates (of b), hence we need to subtract 1 (appeal) from the result.\\nThe number of substring that includes [1,2] are all substrings of [i, j] where 0<=i<=1 and 2<=j<=4.\\nThere are 2 * 3 = 6 such substrings. so we substring 6 from result.\\nSame thing for \\'a\\', there are 1 substring [i, j] that has 0<=i<=0 and 4<=j<=4 so we substract 1 from the result.\\nThen we get 35 - 6 -1 = 28.\\nIf there are more than 2 duplicates in the string, i.e. \"ababa\", then we do similarly:\\n\\'a\\': 0, 2, 4\\n\\'b\\': 1, 3\\nIterate \\'a\\' to \\'z\\', and for \\'a\\' in this case, we count [0, 2], then [2, 4] then substract similarly:\\n1x5+2x4+3x3+4x2+5x1 - (0 -0 +1)x(4 -2 +1) - (2 -0 +1) * (4 -4 +1) - (1-0+1)x(4-3+1) = 25\\n```\\nclass Solution {\\n    public long appealSum(String s) {\\n        HashMap<Character, List<Integer>> map = new HashMap<>();\\n        for(char c=\\'a\\'; c<=\\'z\\'; c++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int i=0; i<s.length(); i++) {\\n                if(s.charAt(i) == c) list.add(i);\\n            }\\n            if(list.size() > 1) map.put(c, list);\\n        }\\n        long ret = 0;\\n        long n= (long) s.length();\\n        // count total appeal of all of its substrings when there is no duplicate letters\\n        for(long i=1; i<=n; i++) ret += i*(n-i+1);\\n        for(char key: map.keySet()) {\\n            List<Integer> list = map.get(key);\\n            for(int i=0; i<list.size()-1; i++) {\\n                long a = (long) list.get(i);\\n                long b = (long) list.get(i+1);\\n                // subtract the number of substrings that contains the duplicate letters at position a and position b.\\n                // say the substring starts i and ends j, the number of substrings that contains [a, b] are\\n                // 0 <= i <= a && b <= j <= n-1\\n                ret -= (a - 0 + 1) * (n-1 - b + 1);\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long appealSum(String s) {\\n        HashMap<Character, List<Integer>> map = new HashMap<>();\\n        for(char c=\\'a\\'; c<=\\'z\\'; c++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int i=0; i<s.length(); i++) {\\n                if(s.charAt(i) == c) list.add(i);\\n            }\\n            if(list.size() > 1) map.put(c, list);\\n        }\\n        long ret = 0;\\n        long n= (long) s.length();\\n        // count total appeal of all of its substrings when there is no duplicate letters\\n        for(long i=1; i<=n; i++) ret += i*(n-i+1);\\n        for(char key: map.keySet()) {\\n            List<Integer> list = map.get(key);\\n            for(int i=0; i<list.size()-1; i++) {\\n                long a = (long) list.get(i);\\n                long b = (long) list.get(i+1);\\n                // subtract the number of substrings that contains the duplicate letters at position a and position b.\\n                // say the substring starts i and ends j, the number of substrings that contains [a, b] are\\n                // 0 <= i <= a && b <= j <= n-1\\n                ret -= (a - 0 + 1) * (n-1 - b + 1);\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996267,
                "title": "python3-simple-idea-with-explanation",
                "content": "The key to this problem is to reuse previous information.\\nLet\\'s assume a string `s` has a total number of different characters of `x`\\nWe can notice that if we add a character to the end of `s`, the total number of different characters in the new string is `x + 1` if the new character doesn\\'t appear in `s`, or is `x` if it has already appeared. Here we can make use of previous information.\\nIf we group substrings by their ending indexes, we will find out that adding the next character to one set will form the next set. So we only need to keep track of how many strings in the set don\\'t have a certain character and the sum of different characters in strings in the set.\\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        # numbers of strings don\\'t have this character\\n        lst = [0 for _ in range(26)]\\n        ans = 0\\n        # sum of different characters in strings in the set\\n        tot = 0\\n        for i in s:\\n            # add an empty string\\n            for j in range(26):\\n                lst[j] += 1\\n            # add this character\\n            idx = ord(i) - ord(\\'a\\')\\n            tot += lst[idx]\\n            lst[idx] = 0\\n            ans += tot\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        # numbers of strings don\\'t have this character\\n        lst = [0 for _ in range(26)]\\n        ans = 0\\n        # sum of different characters in strings in the set\\n        tot = 0\\n        for i in s:\\n            # add an empty string\\n            for j in range(26):\\n                lst[j] += 1\\n            # add this character\\n            idx = ord(i) - ord(\\'a\\')\\n            tot += lst[idx]\\n            lst[idx] = 0\\n            ans += tot\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996248,
                "title": "complementary-counting-with-illustration-o-n",
                "content": "Since there are only 26 English letters, we can consider the total appeal of each character separatedly and add them up. In the first round, we count the appeals of \\'a\\', and in the next round, we count the appeal of \\'b\\'. We repeat this for each letter.\\n\\nWhat is the total appeal of \\'a\\' in all substrings? This is just the number of substrings that contains at least one \\'a\\'. However, it\\'s tricky to count this number because some substrings might have more than 1 \\'a\\' in it so it\\'s easy to overcount. If we can complementary counting. The problem becomes much easier.\\n\\n```\\nThe number of substrings with at least 1 \\'a\\' = All possible substrings - the number of substrings without a single \\'a\\'\\n```\\n\\nSay the lengh of the original string is n. We first assume all possible substrings have at least one \\'a\\' in it. That is to say, we assume the total appeal of \\'a\\' is the number of all possible substrings, which is n(n+1)/2. Next, we deduct the number of substrings that doesn\\'t have any \\'a\\' in it. \\n\\nConsider this input: \"dabbca\". We first find out all positions \\'a\\' appears. Step 2 shows that \\'a\\' appears in these positions. As you can see in step 3, two gaps are formed between 2 neighboring \\'a\\'s, and all substrings which reside in this gap doesn\\'t have any \\'a\\' in it, so all substrings in this gap should be deducted from our initial assumption. How many possible substrings are there in gap 2? It\\'s simply (gap width) * (gap width + 1) / 2.![image](https://assets.leetcode.com/users/images/ec4777c8-8194-4113-9c8a-5b2d1e6597b2_1651377688.61433.png)\\n\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int n = s.size();\\n        vector<vector<int>> pos(26);\\n        for (int i=0; i<26; i++) {\\n            pos[i].push_back(-1);\\n        }\\n        for (int i=0; i<s.size(); i++) {\\n            pos[s[i]-\\'a\\'].push_back(i);\\n        }\\n        for (int i=0; i<26; i++) {\\n            pos[i].push_back(n);\\n        }\\n        long long res = 0;\\n        for (int i=0; i<26; i++) {\\n            long long all = (n * (n+1L)) / 2L;\\n            for (int p=1; p < pos[i].size(); p++) {\\n                int gap = pos[i][p] - pos[i][p-1] - 1;\\n                long long substrings = (gap * (gap + 1L)) / 2L;\\n                all -= substrings;\\n            }\\n            res += all;\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nThe number of substrings with at least 1 \\'a\\' = All possible substrings - the number of substrings without a single \\'a\\'\\n```\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int n = s.size();\\n        vector<vector<int>> pos(26);\\n        for (int i=0; i<26; i++) {\\n            pos[i].push_back(-1);\\n        }\\n        for (int i=0; i<s.size(); i++) {\\n            pos[s[i]-\\'a\\'].push_back(i);\\n        }\\n        for (int i=0; i<26; i++) {\\n            pos[i].push_back(n);\\n        }\\n        long long res = 0;\\n        for (int i=0; i<26; i++) {\\n            long long all = (n * (n+1L)) / 2L;\\n            for (int p=1; p < pos[i].size(); p++) {\\n                int gap = pos[i][p] - pos[i][p-1] - 1;\\n                long long substrings = (gap * (gap + 1L)) / 2L;\\n                all -= substrings;\\n            }\\n            res += all;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996245,
                "title": "dp-fully-explained-c",
                "content": "```\\n//We will count the total appeal for all the substrings enfing at index i\\n//if we see clearly each index is following a similar pattern\\n\\n//e.g code\\n//c=1\\n//co=2+1\\n//cod=3+2+1\\n//code=4+3+2+1\\n\\n//i.e we just have to do dp[i]=dp[i-1]+Length of string till now i.e i+1\\n//but for the case when we will have a duplicate character of current index character we just have to subtract\\n//the length of last occurence of s[i] using mp\\n\\n//Dry run yourself for \"abdbc\"\\n//a=1\\n//ab=2+1\\n//abd=3+2+1\\n//abdb=(4+3+2+1)-Length of string for last occurence of current character s[i] +Length of string till now\\n//i.e abdb=(4+3+2+1)-2+3=(3+2+2+1)\\n//abdbc=(4+3+3+2)+length till now i.e 1\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long appealSum(string s) {\\n        ll n=s.size();\\n        ll mp[26];    //to keep the index of last occurunce of current index\\n        memset(mp,-1,sizeof(mp));\\n        vector<ll> dp(n,0);    //to store the value of previous index   \\n        long long ans=0;\\n        for(ll i=0;i<n;++i)\\n        {\\n            dp[i]=(i==0)?0:dp[i-1]+i;\\n            if(mp[s[i]-\\'a\\']!=-1)\\n            {\\n                dp[i]-=mp[s[i]-\\'a\\'];\\n            }\\n            mp[s[i]-\\'a\\']=i+1;\\n            dp[i]++;\\n            ans+=dp[i];\\n        }\\n        return ans;\\n    }\\n};\\n//Like if it helps you :)\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n//We will count the total appeal for all the substrings enfing at index i\\n//if we see clearly each index is following a similar pattern\\n\\n//e.g code\\n//c=1\\n//co=2+1\\n//cod=3+2+1\\n//code=4+3+2+1\\n\\n//i.e we just have to do dp[i]=dp[i-1]+Length of string till now i.e i+1\\n//but for the case when we will have a duplicate character of current index character we just have to subtract\\n//the length of last occurence of s[i] using mp\\n\\n//Dry run yourself for \"abdbc\"\\n//a=1\\n//ab=2+1\\n//abd=3+2+1\\n//abdb=(4+3+2+1)-Length of string for last occurence of current character s[i] +Length of string till now\\n//i.e abdb=(4+3+2+1)-2+3=(3+2+2+1)\\n//abdbc=(4+3+3+2)+length till now i.e 1\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long appealSum(string s) {\\n        ll n=s.size();\\n        ll mp[26];    //to keep the index of last occurunce of current index\\n        memset(mp,-1,sizeof(mp));\\n        vector<ll> dp(n,0);    //to store the value of previous index   \\n        long long ans=0;\\n        for(ll i=0;i<n;++i)\\n        {\\n            dp[i]=(i==0)?0:dp[i-1]+i;\\n            if(mp[s[i]-\\'a\\']!=-1)\\n            {\\n                dp[i]-=mp[s[i]-\\'a\\'];\\n            }\\n            mp[s[i]-\\'a\\']=i+1;\\n            dp[i]++;\\n            ans+=dp[i];\\n        }\\n        return ans;\\n    }\\n};\\n//Like if it helps you :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996206,
                "title": "first-occurrence-at-each-position-o-n-solution",
                "content": "For each position, we calculate how many times this character will be the first occurrence of a substring, as it contributes to the answer.\\nLet\\'s say we have a string `\"abcccb\"`. Let `n` be the length of the string.\\nFind the position that each character occurs.\\n```\\n\\'a\\' : {-1, 0}\\n\\'b\\' : {-1, 1, 5}\\n\\'c\\' : {-1, 2, 3, 4}\\n```\\nFor index 0, we can extend the substring left to its `previous_occurrence_index + 1`, i.e. `-1 + 1 = 0`, and right to the end of the string `n - 1`.\\n`left_cnt = 0 - 0 + 1 = 1, right_cnt = n - 1 - 0 + 1 = n`. The number of substrings with first occurrence of `\\'a\\'` at index 0 is `left_cnt * right_cnt`.\\nSame for other indices.\\n```\\nTime complexity:\\nO(n log(n)) for finding the previous index with binary search\\nor\\nO(n) for finding the previous index with pointer\\n```\\n```\\n// O(n log(n)) Solution\\nusing ll = long long;\\n\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        const int n = (int) s.size();\\n        vector<vector<int>> occur(26);\\n        for(int i = 0; i < 26; ++i) {\\n            occur[i].push_back(-1);\\n        }\\n        for(int i = 0; i < n; ++i) {\\n            occur[s[i] - \\'a\\'].push_back(i);\\n        }\\n        ll ans = 0;\\n        for(int i = 0; i < n; ++i) {\\n            int c = s[i] - \\'a\\';\\n            int L_pos = *prev(lower_bound(occur[c].begin(), occur[c].end(), i));\\n            int R_pos = n;\\n            int l_cnt = i - L_pos;\\n            int r_cnt = n - i;\\n            ans += ll(l_cnt) * r_cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\n// O(n) Solution\\nusing ll = long long;\\n\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        const int n = (int) s.size();\\n        vector<vector<int>> occur(26);\\n        for(int i = 0; i < 26; ++i) {\\n            occur[i].push_back(-1);\\n        }\\n        for(int i = 0; i < n; ++i) {\\n            occur[s[i] - \\'a\\'].push_back(i);\\n        }\\n        vector<int> pointer(26);\\n        ll ans = 0;\\n        for(int i = 0; i < n; ++i) {\\n            int c = s[i] - \\'a\\';\\n            int L_pos = occur[c][pointer[c]];\\n            int R_pos = n;\\n            int l_cnt = i - L_pos;\\n            int r_cnt = n - i;\\n            ans += ll(l_cnt) * r_cnt;\\n            pointer[c] += 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\'a\\' : {-1, 0}\\n\\'b\\' : {-1, 1, 5}\\n\\'c\\' : {-1, 2, 3, 4}\\n```\n```\\nTime complexity:\\nO(n log(n)) for finding the previous index with binary search\\nor\\nO(n) for finding the previous index with pointer\\n```\n```\\n// O(n log(n)) Solution\\nusing ll = long long;\\n\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        const int n = (int) s.size();\\n        vector<vector<int>> occur(26);\\n        for(int i = 0; i < 26; ++i) {\\n            occur[i].push_back(-1);\\n        }\\n        for(int i = 0; i < n; ++i) {\\n            occur[s[i] - \\'a\\'].push_back(i);\\n        }\\n        ll ans = 0;\\n        for(int i = 0; i < n; ++i) {\\n            int c = s[i] - \\'a\\';\\n            int L_pos = *prev(lower_bound(occur[c].begin(), occur[c].end(), i));\\n            int R_pos = n;\\n            int l_cnt = i - L_pos;\\n            int r_cnt = n - i;\\n            ans += ll(l_cnt) * r_cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n// O(n) Solution\\nusing ll = long long;\\n\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        const int n = (int) s.size();\\n        vector<vector<int>> occur(26);\\n        for(int i = 0; i < 26; ++i) {\\n            occur[i].push_back(-1);\\n        }\\n        for(int i = 0; i < n; ++i) {\\n            occur[s[i] - \\'a\\'].push_back(i);\\n        }\\n        vector<int> pointer(26);\\n        ll ans = 0;\\n        for(int i = 0; i < n; ++i) {\\n            int c = s[i] - \\'a\\';\\n            int L_pos = occur[c][pointer[c]];\\n            int R_pos = n;\\n            int l_cnt = i - L_pos;\\n            int r_cnt = n - i;\\n            ans += ll(l_cnt) * r_cnt;\\n            pointer[c] += 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996202,
                "title": "c-subtract-duplicated-score",
                "content": "\\n\\n1. Get total scores for all substring.\\n2. for every two identical char, the duplicated score is left_size * right_size: ----left-----a...a----right---\\n    \\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long n = s.size();\\n        long long ans = n * (n + 1) / 2 * n;\\n        vector<vector<long long> > idx(26);\\n        for(long long i = 0; i < s.size(); i++) {\\n            ans -= (i) * (i + 1);\\n            long long c = s[i] - \\'a\\';\\n            if(idx[c].size() == 0) idx[c].push_back(-1);\\n            idx[c].push_back(i);\\n        }\\n        for(auto &v: idx) {\\n            v.push_back(n);\\n            int m = v.size();\\n            if(v.size() <= 3) continue;\\n            for(int i = 1; i < m - 2; i++) {\\n                ans -= (n - v[i + 1]) * (v[i] + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long n = s.size();\\n        long long ans = n * (n + 1) / 2 * n;\\n        vector<vector<long long> > idx(26);\\n        for(long long i = 0; i < s.size(); i++) {\\n            ans -= (i) * (i + 1);\\n            long long c = s[i] - \\'a\\';\\n            if(idx[c].size() == 0) idx[c].push_back(-1);\\n            idx[c].push_back(i);\\n        }\\n        for(auto &v: idx) {\\n            v.push_back(n);\\n            int m = v.size();\\n            if(v.size() <= 3) continue;\\n            for(int i = 1; i < m - 2; i++) {\\n                ans -= (n - v[i + 1]) * (v[i] + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089121,
                "title": "dp-in-ruby",
                "content": "# Approach\\n`prev` stores the last index of each character. This way, you know how far back in the string you\\'ve seen this character last.\\n\\n`i - prev[ch]` tells you how many substrings **end** at the current character, `ch`.\\n\\n\\n# Code\\n```\\ndef appeal_sum(s)\\n  tsum = cur = 0\\n  prev = Hash.new(-1)\\n\\n  s.each_char.with_index do |ch, i|\\n    cur += i - prev[ch]\\n    prev[ch] = i\\n    tsum += cur\\n  end\\n  tsum\\nend\\n\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Ruby",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef appeal_sum(s)\\n  tsum = cur = 0\\n  prev = Hash.new(-1)\\n\\n  s.each_char.with_index do |ch, i|\\n    cur += i - prev[ch]\\n    prev[ch] = i\\n    tsum += cur\\n  end\\n  tsum\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4065226,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long check(char &ch,string &s)\\n    {\\n        long long res=0;\\n        long long cnt=0;\\n        long long n=s.size();\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if (s[i]==ch)\\n            {\\n                res+=(cnt*(cnt+1))/2;\\n                cnt=0;\\n            }\\n            else cnt++;\\n        }\\n        res+=(cnt*(cnt+1))/2;\\n        return ((n*(n+1))/2)-res;\\n    }\\n    long long appealSum(string s) \\n    {\\n      long long ans=0;\\n      for (char ch=\\'a\\';ch<=\\'z\\';ch++)\\n      {\\n          ans+=check(ch,s);\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long check(char &ch,string &s)\\n    {\\n        long long res=0;\\n        long long cnt=0;\\n        long long n=s.size();\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if (s[i]==ch)\\n            {\\n                res+=(cnt*(cnt+1))/2;\\n                cnt=0;\\n            }\\n            else cnt++;\\n        }\\n        res+=(cnt*(cnt+1))/2;\\n        return ((n*(n+1))/2)-res;\\n    }\\n    long long appealSum(string s) \\n    {\\n      long long ans=0;\\n      for (char ch=\\'a\\';ch<=\\'z\\';ch++)\\n      {\\n          ans+=check(ch,s);\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042757,
                "title": "easy-simple-subarray-counting-no-dp",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        ll n=s.size();\\n        map<char,vector<int>> m;\\n        for(int x=0;x<n;x++){\\n            m[s[x]].push_back(x);\\n        }\\n        ll res=m.size()*(n*(n+1))/2ll;\\n        for(auto &[a,b]:m){\\n            reverse(b.begin(),b.end());\\n            b.push_back(-1);\\n            reverse(b.begin(),b.end());\\n            b.push_back(n);\\n            for(int x=1;x<b.size();x++){\\n                int z=(b[x]-b[x-1]-1);\\n                res-=(z*(z+1))/2;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        ll n=s.size();\\n        map<char,vector<int>> m;\\n        for(int x=0;x<n;x++){\\n            m[s[x]].push_back(x);\\n        }\\n        ll res=m.size()*(n*(n+1))/2ll;\\n        for(auto &[a,b]:m){\\n            reverse(b.begin(),b.end());\\n            b.push_back(-1);\\n            reverse(b.begin(),b.end());\\n            b.push_back(n);\\n            for(int x=1;x<b.size();x++){\\n                int z=(b[x]-b[x-1]-1);\\n                res-=(z*(z+1))/2;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027341,
                "title": "optimize-and-bruteforce-approch-both",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nassume we have string xxxaxxxxb..., with s[i] = a and s[j] = b.\\ns[i] is th last character a before that b.\\n\\nWe want to count, how many substring ending at s[j] contains character a.\\nThey are xxxaxxxxb, xxaxxxxb, xaxxxxb, axxxxb ....,\\ni + 1 substring ending with character a at s[i],\\nso we do res += i + 1.\\n\\nWe repeatly do this for every s[i] and every one of 26 characters.\\n\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\n// TC:- O(n2)\\n// SC:- O(n)\\n    public long appealSum(String s) {/*\\n        long count=0;\\n\\n        for(int i=0; i<s.length(); i++){\\n            Set<Character> set = new HashSet<>();\\n            for(int j=i; j<s.length(); j++){\\n                set.add(s.charAt(j));\\n                count += set.size();\\n            }\\n        }\\n\\n        return count;\\n*/\\n\\n// TC:-O(n)\\n// SC:-O(26)\\n        int [] arr = new int[26];\\n        long res=0;\\n\\n        for(int i=0; i<s.length(); i++){\\n            arr[s.charAt(i)-\\'a\\'] = i+1;\\n            for(int j : arr) res+=j;\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n// TC:- O(n2)\\n// SC:- O(n)\\n    public long appealSum(String s) {/*\\n        long count=0;\\n\\n        for(int i=0; i<s.length(); i++){\\n            Set<Character> set = new HashSet<>();\\n            for(int j=i; j<s.length(); j++){\\n                set.add(s.charAt(j));\\n                count += set.size();\\n            }\\n        }\\n\\n        return count;\\n*/\\n\\n// TC:-O(n)\\n// SC:-O(26)\\n        int [] arr = new int[26];\\n        long res=0;\\n\\n        for(int i=0; i<s.length(); i++){\\n            arr[s.charAt(i)-\\'a\\'] = i+1;\\n            for(int j : arr) res+=j;\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015417,
                "title": "clear-explanation",
                "content": "# General idea\\nWe can iterate through each index **i** of string **s** to check how many subarrays that end at **i** will receive appeal points from the character at **s[i]**. Any subarray that ends before **i** will recieve no points from **s[i]**, and there will always be **i** subarrays in the group of subarrays that end at a given index after **i**.\\n\\n# Breakdown\\n\\nGiven [a,b,c,d,c,b,a] lets look at index 2. The character at **s[i]** is c. At this point, this character c will contribute a point to appeal for subarrays [a,b,c],[b,c], and [c]. \\n\\n***But if we are doing a single pass how can we calculate how the character will contribute to later subarrays?***\\n\\nLet\\'s look at an example of how our c will contribute down the line. If we move to index 3 we can find that our previous c contributes a point to [a,b,c,d],[b,c,d], and [c,d]. This is still the same number of contributed points. \\n\\n***What about when we run into the same character again?***\\n\\nLet\\'s jump ahead two indeces to index 5. The section of the array we are looking at now is [a,b,c,d,c,b]. As you can see we\\'ve crossed another c. Only one of them can contribute to the subarrays that contain both. Let\\'s credit the first instance of the character with the point for any subarray that contains it. Any other c\\'s contained in such subarrays will not gain a point.\\n\\nIn this case we know that for any end index, our first c will contribute 3 points (For index 6: [a,b,c,d,c,b],[b,c,d,c,b],[c,d,c,b]).\\n\\n***What points will subsequent repeated characters contribute?***\\n\\nLet\\'s look at index 5 again. We know that the first c is credited with: [a,b,c,d,c,b],[b,c,d,c,b],[c,d,c,b]. The only other subarrays which the second c is a part of are: [d,c],[c]. In other words, one subarray for every index since the previous occurence of c! As long as we keep track of the previous index of each character we can calculate added appeal from subsequent repeated characters as current_index - previous_index.\\n\\nSo, at a given index i we can calculate how many points a letter will contribute to every index from i through the end of the array. We can either keep track of a current pile of repeated contributions, and add it to our total at every index:\\n    current_pile += current_index - previous_indeces[character]\\n    total_appeal += current_pile\\nOr immediately calculate how many points the character will contribute in total:\\n    total_appeal += (current_index - previous_indeces[character]) * (total_length - current_index)\\n# Code\\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n            \\n\\n        total, previous_indeces = 0, defaultdict(lambda: -1)\\n\\n        for index,char in enumerate(s):\\n            total += (index - previous_indeces[char]) * (len(s) - index)\\n            previous_indeces[char] = index\\n\\n        return total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n            \\n\\n        total, previous_indeces = 0, defaultdict(lambda: -1)\\n\\n        for index,char in enumerate(s):\\n            total += (index - previous_indeces[char]) * (len(s) - index)\\n            previous_indeces[char] = index\\n\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013138,
                "title": "contribution-technique",
                "content": "\\nCertainly! Let\\'s break down the code block you\\'ve provided:\\n\\n\\nint c = s[i-1] - \\'a\\';\\n\\n// Update contribution for this letter and mark its location\\ncontribution[c] = i - prev[c] + contribution[c];\\nprev[c] = i;\\nHere\\'s an explanation of each line:\\n\\nint c = s[i-1] - \\'a\\';:\\n\\nThis line calculates the index (between 0 and 25) of the character at position i-1 in the string s. \\'a\\' is subtracted to convert the character to an index, assuming that s only contains lowercase English letters (\\'a\\' to \\'z\\'). For example, if s[i-1] is \\'b\\', c will be assigned the value 1.\\ncontribution[c] = i - prev[c] + contribution[c];:\\n\\nThis line updates the \"contribution\" of the character c in the string s. The \"contribution\" here represents how many times a character has contributed to the total appeal of the string up to this point.\\ni - prev[c] calculates how many positions are between the current position i and the previous position where character c appeared. This value represents how many times the character c has contributed at this point.\\ncontribution[c] keeps track of the cumulative contribution of character c so far.\\nBy adding i - prev[c] to contribution[c], we update the contribution of c for the current position i.\\nprev[c] = i; updates the prev array to store the most recent position at which character c appeared.\\nIn summary, this block of code calculates and updates the contribution of each character as the string is iterated through. It keeps track of how many times each character has contributed to the total appeal of the string s.\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long totalAppeal = 0;\\n        if (s.size() == 0) return totalAppeal;\\n        int prev[26] = {0};\\n        int contribution[26] = {0};\\n        \\n        // abc\\n        // i = 0 : a        : 1\\n        // i = 1 : b ab     : 3\\n        // i = 2 : c bc abc : 6\\n        \\n        // letter   : contribution\\n        // a        : 3\\n        // b        : 4\\n        // c        : 3\\n        \\n\\t\\t// abcab\\n      //i:  1   2   3   4   5\\n      //c:  a   b   c   a   b\\n    //cnt   1   2   3   3   3\\n    //sum   1   3   6   9  12 = 31\\n        \\n        for (int i = 1; i <= s.size(); i++) {\\n            int c = s[i-1] - \\'a\\';\\n\\t\\t\\t\\n\\t\\t\\t// Update contribution for this letter and mark its location\\n            contribution[c] = i - prev[c] + contribution[c];\\n            prev[c] = i;\\n            \\n            // Add up total contribution for all letters at this point of the string\\n            for (auto j = 0; j < 26; j++)\\n                totalAppeal += contribution[j];\\n            \\n            //cout << totalAppeal << endl;\\n        }\\n        \\n        return totalAppeal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long totalAppeal = 0;\\n        if (s.size() == 0) return totalAppeal;\\n        int prev[26] = {0};\\n        int contribution[26] = {0};\\n        \\n        // abc\\n        // i = 0 : a        : 1\\n        // i = 1 : b ab     : 3\\n        // i = 2 : c bc abc : 6\\n        \\n        // letter   : contribution\\n        // a        : 3\\n        // b        : 4\\n        // c        : 3\\n        \\n\\t\\t// abcab\\n      //i:  1   2   3   4   5\\n      //c:  a   b   c   a   b\\n    //cnt   1   2   3   3   3\\n    //sum   1   3   6   9  12 = 31\\n        \\n        for (int i = 1; i <= s.size(); i++) {\\n            int c = s[i-1] - \\'a\\';\\n\\t\\t\\t\\n\\t\\t\\t// Update contribution for this letter and mark its location\\n            contribution[c] = i - prev[c] + contribution[c];\\n            prev[c] = i;\\n            \\n            // Add up total contribution for all letters at this point of the string\\n            for (auto j = 0; j < 26; j++)\\n                totalAppeal += contribution[j];\\n            \\n            //cout << totalAppeal << endl;\\n        }\\n        \\n        return totalAppeal;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4013053,
                "title": "easiest-hashmap-solution-c-unordered-map",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore occurences of the characters in a map.\\nIf the character was already present in map then we will not consider subarrays previous to the last occurence hence the formula (i-lastoccurence[s[i]])* (n-i).\\nIf the character is new then consider all subarrays using (i+1)*(n-i)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int n=s.size();\\n        unordered_map<char,int>mp;\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(s[i])!=mp.end()){\\n                ans+=(i-mp[s[i]])*(n-i);\\n            }\\n            else{\\n                ans+=(i+1)*(n-i);\\n            }\\n            mp[s[i]]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int n=s.size();\\n        unordered_map<char,int>mp;\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            if(mp.find(s[i])!=mp.end()){\\n                ans+=(i-mp[s[i]])*(n-i);\\n            }\\n            else{\\n                ans+=(i+1)*(n-i);\\n            }\\n            mp[s[i]]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003016,
                "title": "dp-o-n-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ndp[i]  represents sum of all the substring from 0th position to ith position.\\nlets say the string uptill now was\\nab -> a,b,ab -> 1,1,2\\nwe add another a to this to become aba\\nhow does adding a change our answer from previous state?\\n we can additionally have a,ba ,aba -> 1,2,2 now on top of whatever answer we had earlier.\\ngreat but like how do we add this stuff ?\\n\\nfirst we notice  how we are adding on to previous state .\\n\\nlets say for addition of b on a ,i.e.  a->ab\\nwe got new states ab and b.\\n\\nwhen we add a to this our new states are aba , ba  and a.\\nmeaning 2,2,1 .\\nwe add onto the answer (+1)  when the current element we are adding is unique to the substing else the answer remains the same (ab and aba have same value of 2 ).\\n\\nthus we need to check what was the last index where the current character occured .\\n\\nfor the string \"zycanbxvsc\" , when we add \\'a\\' , the values will increase  for nbxvsc by one and then from \\'a\\' of zyca, the values will remain same. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nnow we know the answer for a current state dp[i] = dp[i-1] + newly added values.\\n\\nwhere newly added values represent the value added based on uniqueness of our current character ,s[i].\\n\\nsuppose our current index is i and the last time s[i] occured in the string was at index j , then answer will remain same for 0-j index in the string and answer will increase by 1 for index j+1 ->i-1. makes sense ?\\nc +a ->2 (we got an increase in answer) f(c)=1\\nbc +a ->3(we got an increase in answer) f(bc)=2\\nabc+a-> 3(answer remains the same)      f(abc)=3\\nzabc +a-> 4(answer reamains the same).  f(zabc)=4\\n\\n\\n\\nnow the question is what are we adding to ?\\nwe are adding to whatever the answer the last state increased .\\n\\nlets say ab + a is our current task\\nthen what happened at the previous task?\\na+b \\nwhich was ab ,b,\\'\\' -> 2+1+0\\n \\nwe add onto the previously added answer\\n    aba,ba,a,\\'\\' -> 2+2+1\\n\\nhow do find out what was the gain in previous state ?\\ndp[i-1]-dp[i-2] ;\\nsimple right ?\\n\\n\\nso what is our current dp[i] equal to ?\\nj is the last occurence of s[i].\\ndp[i]=dp[i-1] + (dp[i-1]-d[i-2] ) + (i-1-j) +1;\\n\\nwhy plus one ?\\nwe are adding a new answer, s[i];\\nif we add a to zy .we are introducing a new substring \\'a\\';\\n\\n\\nbit messy to understand but will help if you draw this on paper and practised yourself.  \\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\nusing ll =long long;\\n    long long appealSum(string s) {\\n        int n=s.size();\\n       \\n        vector<ll>dp(n+1,0);\\n        dp[0]=0;\\n        dp[1]=1;\\n\\n        unordered_map<char,int>last;\\n        last[s[0]]=0;\\n        for(int i=1;i<n;i++){\\n            int x=-1;\\n               if(last.find(s[i])!=last.end()){\\n                  x=last[s[i]];\\n               }\\n           dp[i+1]= 2*dp[i] -dp[i-1] + i-x ;   \\n       last[s[i]]=i;\\n        }\\nreturn dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nusing ll =long long;\\n    long long appealSum(string s) {\\n        int n=s.size();\\n       \\n        vector<ll>dp(n+1,0);\\n        dp[0]=0;\\n        dp[1]=1;\\n\\n        unordered_map<char,int>last;\\n        last[s[0]]=0;\\n        for(int i=1;i<n;i++){\\n            int x=-1;\\n               if(last.find(s[i])!=last.end()){\\n                  x=last[s[i]];\\n               }\\n           dp[i+1]= 2*dp[i] -dp[i-1] + i-x ;   \\n       last[s[i]]=i;\\n        }\\nreturn dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992230,
                "title": "c-solution",
                "content": "# Code\\n\\n```\\n//  abc\\n//  a b c \\n//  ab bc\\n//  abc\\n// a-> 1(col)*3(row) | b=2*2 | c=3*1\\n//----------------------------\\n// aac\\n// a a c\\n// aa ac\\n// aac \\n// a-> 1*3 | a=1*2 | c=3*1\\n#define ll long long \\nlong long appealSum(char * s){\\n    ll res=0;\\n    int n=strlen(s);\\n    int *map=calloc(26,sizeof(int));\\n    for(int i=0;i<n;i++){\\n        res+=(ll)(i+1-map[s[i]-\\'a\\'])*(ll)(n-i);\\n        map[s[i]-\\'a\\']=i+1;\\n    }\\n    free(map);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//  abc\\n//  a b c \\n//  ab bc\\n//  abc\\n// a-> 1(col)*3(row) | b=2*2 | c=3*1\\n//----------------------------\\n// aac\\n// a a c\\n// aa ac\\n// aac \\n// a-> 1*3 | a=1*2 | c=3*1\\n#define ll long long \\nlong long appealSum(char * s){\\n    ll res=0;\\n    int n=strlen(s);\\n    int *map=calloc(26,sizeof(int));\\n    for(int i=0;i<n;i++){\\n        res+=(ll)(i+1-map[s[i]-\\'a\\'])*(ll)(n-i);\\n        map[s[i]-\\'a\\']=i+1;\\n    }\\n    free(map);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985617,
                "title": "easy-to-understand-clean-code-two-approaches-o-26-n-time-complexity-o-n-time-complexity",
                "content": "# Intution\\nFirst approach to solve this problem is to itrate over all substring and find sum of all distinct element sum presnt in all substrings but this brute force takes O(N*N) time complaxity which is not good.\\n\\n# Approach -1\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem , we should itrate each alphabat character one by one and find all substring in \\'s\\' string which have at least one current itrating alphabatic character and sum of them to get our resultant subsequence.\\n\\nNow the problem is how to find all substring which have atleast one itrating alphabet or we can say \\n\\n    all substring with atleast one current alphabetic character = \\n    all substrings - all substring which not have current alphabet.\\nNow the approach sounds familier.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(26*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long ans = 0;\\n        for(char i=\\'a\\';i<=\\'z\\';i++){\\n            ans+=helper(i,s);\\n        }\\n        return ans;\\n\\n    }\\n    long long helper(char target,string s){\\n        long long size = 0,ans = 0;\\n        for(int i=0;i<s.length();i++){\\n           if(s[i]==target){\\n               ans+=(size+1)*size/2;\\n               size = 0;\\n           }else{\\n               size++;\\n           }\\n        }\\n        if(s[s.length()-1]!=target){\\n           ans+=(size+1)*size/2;\\n        }\\n        return (s.size()*(s.size()+1)/2)-ans;\\n    }\\n};\\n```\\n# Approach-2 \\n###### We Can also further optimised this solution to O(N) time complaxity\\nIn this approach, we will maintain an array which store last occurance of each distinct character in string.\\nNow We start itrating each character in string \\'s\\'. To find all substring till each charcter of string we use formula,\\n\\nif character has not occured till now,<b> we will add length substring form begining to index \\'i\\'</b> else find length of substring by finding difference of last occurece of curr chacter and current index and store in curr variable which stores sum of distinct substrings.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code \\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long ans = 0;\\n        long long curr = 0;\\n        vector<int>arr(26,-1);\\n        for(int i=0;i<s.size();i++){\\n            if(arr[s[i]-\\'a\\']==-1){\\n                curr += i+1;\\n            }else{\\n                curr += i-arr[s[i]-\\'a\\'];\\n            }\\n            arr[s[i]-\\'a\\'] = i;\\n            ans+=curr;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n### Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Dynamic Programming",
                    "Counting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long ans = 0;\\n        for(char i=\\'a\\';i<=\\'z\\';i++){\\n            ans+=helper(i,s);\\n        }\\n        return ans;\\n\\n    }\\n    long long helper(char target,string s){\\n        long long size = 0,ans = 0;\\n        for(int i=0;i<s.length();i++){\\n           if(s[i]==target){\\n               ans+=(size+1)*size/2;\\n               size = 0;\\n           }else{\\n               size++;\\n           }\\n        }\\n        if(s[s.length()-1]!=target){\\n           ans+=(size+1)*size/2;\\n        }\\n        return (s.size()*(s.size()+1)/2)-ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long ans = 0;\\n        long long curr = 0;\\n        vector<int>arr(26,-1);\\n        for(int i=0;i<s.size();i++){\\n            if(arr[s[i]-\\'a\\']==-1){\\n                curr += i+1;\\n            }else{\\n                curr += i-arr[s[i]-\\'a\\'];\\n            }\\n            arr[s[i]-\\'a\\'] = i;\\n            ans+=curr;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975069,
                "title": "python3-solution-with-using-hashmap",
                "content": "# Code\\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        d = defaultdict(lambda: -1)\\n\\n        res = 0\\n        for idx, c in enumerate(s):\\n            last_idx = d[c] # we shoul find substr without repeated elements\\n            d[c] = idx\\n\\n            # idx - last_idx - substr length\\n            # len(s) - idx - count of substr with len = idx - last_idx\\n            res += (idx - last_idx) * (len(s) - idx)\\n        \\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        d = defaultdict(lambda: -1)\\n\\n        res = 0\\n        for idx, c in enumerate(s):\\n            last_idx = d[c] # we shoul find substr without repeated elements\\n            d[c] = idx\\n\\n            # idx - last_idx - substr length\\n            # len(s) - idx - count of substr with len = idx - last_idx\\n            res += (idx - last_idx) * (len(s) - idx)\\n        \\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953996,
                "title": "individual-contribution-of-each-character",
                "content": "```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        ind = lambda c: ord(s[i]) - ord(\\'a\\')\\n        n = len(s)\\n        res = 0\\n        last = [-1] * 26\\n        for i in range(n):\\n            res += (i - last[ind(s[i])]) * (n - i)\\n            last[ind(s[i])] = i\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        ind = lambda c: ord(s[i]) - ord(\\'a\\')\\n        n = len(s)\\n        res = 0\\n        last = [-1] * 26\\n        for i in range(n):\\n            res += (i - last[ind(s[i])]) * (n - i)\\n            last[ind(s[i])] = i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915620,
                "title": "easy-to-understand-detailed-solution-combinatorics-o-n",
                "content": "# Intuition\\nThe intuition is to think about the **contribution** of each element in the **to the total appeal**. By contribution I mean how much appeal is the element going to bring from all the subarrays it is a part of.\\n\\n# Approach\\nConsider the given testcase from the problem `\"abbca\"`. Let\\'s consider two more things `left` & `right`. `left` is the number of subarrays ending at the number (including it) and `right` is the number of subarrays starting from the number to the end. Our target is the count how many of these are actually meaningful for us.\\nBack to the test case `\"abbca\"`, let\\'s consider the first element `a` at the index 0:\\nFor `a` the number of subarrays starting from beginning including `a` is only 1 i.e `a` itself. Therefore here `left = 1`. So far so good, now let\\'s think about the right part, we have the following possibilities: `a`,`ab`,`abb`,`abbc`,`abbca`. Let us not think about duplicates right now. So we get `right = 5`. Now the number of subarrays that this `a` contributes to is given by `left * right` which is 5. This is pretty self intuitive for any number in an array, the total number of subarrays it can be a part of is given by `left * right`.\\n\\nLet\\'s consider the case of `b`. In the left part we either take `ab` or simply `b` so `left = 2`. For the right part we have `b`,`bb`,`bbc`,`bbca`. Therefore, `right = 2`. Contribution of this `b` is `4*2 = 8`.\\n\\nHere comes the *logic*, sorry to keep you hanging \\uD83D\\uDE42. So the second `b` is the curious case, do I calculate `left` and `right` normally?\\nNo, I would not because this is no longer unique. According to the question **each letter in the alphabet can only contribute at max 1**. Since this b\\'s brother ( the first `b`) already contributed in *some* of the subarrays as 1. This one cannot do that in *those* subarrays. So how do we find out which subarrays to **NOT** count??\\nWe find the unique subarrays which the previous `b` was not a part of.\\nThese are `b`, `bc`, `bca`. What would the `left` and `right` look like? Left\\'s new definition is *the number of subarrays starting after the previous duplicate and ending on this `b`*. While we don\\'t need to bother about right, because we will be traversing from left to right and the present `b` will take care of all the previous `b`\\'s and use all the other right side oppurtunities where it can be a part of. So anymore `b`\\'s to the right will only have to worry about the previous ones.\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N) for the dictionary/hashMap\\n\\n# Code (Python)\\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        N = len(s)\\n        seen = {}; appeal = 0 # this dict keeps track of the just previous duplicate we have seen. We just worry about this one, and not earlier ones because the previous dupe already took care of its previous ones\\n        for idx, char in enumerate(s):\\n            left, right = -1, -1\\n            if char in seen: left = idx - seen[char] # we have to include elements starting from 0\\n            else: left =  idx + 1 # include elements starting after the duplicate\\n            \\n            right = N - idx\\n            appeal += left * right\\n            seen[char] = idx\\n        return appeal\\n        \\n```\\n# Code (C++)\\n```cpp\\nclass Solution{\\n    public:\\n    int appealSum(string &s){\\n        int N = s.size()\\n        unordered_map<char, int> seen;\\n        int appeal = 0;\\n        for(int i = 0; i < N; i++){\\n            int left{}, right{};\\n            if(seen.find(s[i]) != seen.end())\\n                left = i - seen[s[i]];\\n            else\\n                left = i + 1;\\n            right = N - i;\\n            appeal += left * right;\\n            seen[s[i]] = i;\\n        }\\n        return appeal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        N = len(s)\\n        seen = {}; appeal = 0 # this dict keeps track of the just previous duplicate we have seen. We just worry about this one, and not earlier ones because the previous dupe already took care of its previous ones\\n        for idx, char in enumerate(s):\\n            left, right = -1, -1\\n            if char in seen: left = idx - seen[char] # we have to include elements starting from 0\\n            else: left =  idx + 1 # include elements starting after the duplicate\\n            \\n            right = N - idx\\n            appeal += left * right\\n            seen[char] = idx\\n        return appeal\\n        \\n```\n```cpp\\nclass Solution{\\n    public:\\n    int appealSum(string &s){\\n        int N = s.size()\\n        unordered_map<char, int> seen;\\n        int appeal = 0;\\n        for(int i = 0; i < N; i++){\\n            int left{}, right{};\\n            if(seen.find(s[i]) != seen.end())\\n                left = i - seen[s[i]];\\n            else\\n                left = i + 1;\\n            right = N - i;\\n            appeal += left * right;\\n            seen[s[i]] = i;\\n        }\\n        return appeal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843780,
                "title": "solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem by using contibution method.\\nFrom a to z we have to determine how many times each character contributes to any substring.\\nA string of length n has (n+1) C 2 substrings total. For example \\nstring abbca = |a|b|b|c|a|\\nthere are 6 lines. From the six lines if we choose any two lines that would give us a substring.\\nThis can also be calculated by n*(n+1)/2.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long sohel(string s , char c)\\n    {\\n      long long cnt = 0 , res = 0 , n = s.size();\\n      for(char ch : s)\\n      {\\n        if(ch == c)\\n        {\\n          res += cnt*(cnt+1)/2;\\n          cnt = 0;\\n        }\\n        else cnt++;\\n      }\\n      res += (cnt*(cnt+1))/2;\\n      return (n*(n+1))/2 - res;\\n    }\\n    long long appealSum(string s) {\\n        long long ans = 0;\\n        for(char c = \\'a\\' ; c <= \\'z\\' ; c++)\\n        ans += sohel(s , c);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sohel(string s , char c)\\n    {\\n      long long cnt = 0 , res = 0 , n = s.size();\\n      for(char ch : s)\\n      {\\n        if(ch == c)\\n        {\\n          res += cnt*(cnt+1)/2;\\n          cnt = 0;\\n        }\\n        else cnt++;\\n      }\\n      res += (cnt*(cnt+1))/2;\\n      return (n*(n+1))/2 - res;\\n    }\\n    long long appealSum(string s) {\\n        long long ans = 0;\\n        for(char c = \\'a\\' ; c <= \\'z\\' ; c++)\\n        ans += sohel(s , c);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835038,
                "title": "best-explanation-easy-c-solution-contribution-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved using Contribution Technique, where instead of calculating the answer for all the substrings we try to calculate how each element is contributing to the final answer. \\nThis helps us in going from a naive $$O(n^2)$$ solution to a $$O(n)$$ solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInstead of enumerating over all the subarrays and finding the number of distinct characters in each of them, we will try to choose a character and see how it contributes to our final answer.\\n\\nWe can see that there are only 26 (which is very small) distinct characters possible. So, if we are able to calculate how each character \\'a\\', \\'b\\', ... , \\'z\\' is contributing then we can easily find the answer.\\n\\nBut how do we calculate the contribution for each character? \\n\\nFirstly, we know there are $$(n*(n+1)/2)$$ substrings in a string.\\nNow, without losing any generality let\\'s consider the character \\'a\\' and try to find it\\'s contribution.\\n\\nConsider a substring $$s_i......s_j$$, which has the $$s_i$$ as \\'a\\' and $$s_j$$ as \\'a\\' and all the characters in between can be anything other than \\'a\\'.\\n\\nNow, we can\\'t easily find the answer considering just $$s_i$$ or $$s_j$$ because it would require inclusion-exclusion principle, as in some substrings $$s_i$$ occurs or $$s_j$$ occurs or both $$s_i$$ and $$s_j$$ occurs. \\n\\nSo, it\\'s better to find the substrings in which the character \\'a\\' doesn\\'t contribute anything and use it to calculate our final answer.\\n\\nSo, the best contribution the character \\'a\\' can have is by being present in all the substrings. So it would contribute a score of $$(n*(n+1)/2)$$. \\n\\nNow, in $$s_i.....s_j$$ we can say all the substrings in between $$s_{i+1}......s_{j-1}$$ don\\'t have the character \\'a\\' in it. \\n\\nNow, if we just find the length $$(j-i-1)$$ of this substring  and get the total number of substrings in this length, we can say for all such substrings, character \\'a\\' doesn\\'t contribute anything. So, we can subtract that contribution.\\n\\nTherefore, let\\'s make our initial answer to be $$26*n*(n+1)/2$$.\\n\\nNow for every character we can maintain the $$lastOccurrence$$ of the character in the array till now (initially marked with -1). Once we reach this character then we can say for substring $$s_{lastOccurrence+1}.....s_{j-1}$$, all the substrings in it would get no contribution from the current character, so we can find the length and get the number of substrings in it and remove the contribution from our final answer.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(26*N)$$ or $$O(N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(26)$$ or $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    long long nc2(int n){\\n        return (n*1LL*(n+1))/2;\\n    }\\npublic:\\n    long long appealSum(string s) {\\n        int n=(int)s.size();        \\n        long long appeal=(26LL*nc2(n));\\n        vector<int> lastOccurrence(26, -1);\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<n;j++){\\n                if(s[j]-\\'a\\'==i){\\n                    int lenNotContainingCharacter=j-1-lastOccurrence[i];\\n                    appeal-=nc2(lenNotContainingCharacter);\\n                    lastOccurrence[i]=j;\\n                }\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            int lenNotContainingCharacter=n - 1 - lastOccurrence[i];\\n            appeal-=nc2(lenNotContainingCharacter);\\n        }\\n        return appeal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long nc2(int n){\\n        return (n*1LL*(n+1))/2;\\n    }\\npublic:\\n    long long appealSum(string s) {\\n        int n=(int)s.size();        \\n        long long appeal=(26LL*nc2(n));\\n        vector<int> lastOccurrence(26, -1);\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<n;j++){\\n                if(s[j]-\\'a\\'==i){\\n                    int lenNotContainingCharacter=j-1-lastOccurrence[i];\\n                    appeal-=nc2(lenNotContainingCharacter);\\n                    lastOccurrence[i]=j;\\n                }\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            int lenNotContainingCharacter=n - 1 - lastOccurrence[i];\\n            appeal-=nc2(lenNotContainingCharacter);\\n        }\\n        return appeal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793239,
                "title": "cpp-sort-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n       long long ans=0;\\n       int n=s.size();\\n       vector<int> v(26);\\n       for(int i=0;i<n;i++){\\n           v[s[i]-\\'a\\']=i+1;\\n        for(auto i:v)\\n           ans+=i;\\n       }\\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n       long long ans=0;\\n       int n=s.size();\\n       vector<int> v(26);\\n       for(int i=0;i<n;i++){\\n           v[s[i]-\\'a\\']=i+1;\\n        for(auto i:v)\\n           ans+=i;\\n       }\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780682,
                "title": "c-heap-o-n",
                "content": "Since the heap is capped out at size 26 (all lower case letters), the solution is O(n)\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long ans = 0;\\n        vector<int> lastPos(26, -1);\\n        for (int i = 0; i < s.size(); ++i){\\n            char c = s[i];\\n            priority_queue<int> q;\\n            lastPos[c - \\'a\\'] = i;\\n            for (auto& n : lastPos)\\n                if (n != -1) q.push(n);\\n            int rightWindow = -1, curMultiplier = 1;\\n            while (!q.empty()){\\n                int t = q.top();\\n                q.pop();\\n                if (rightWindow == -1){\\n                    rightWindow = t;\\n                }\\n                else{\\n                    ans += curMultiplier++ * (rightWindow - t);\\n                    rightWindow = t;\\n                }\\n            }\\n            ans += curMultiplier * (rightWindow + 1);\\n        }\\n        return ans;\\n    }    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long ans = 0;\\n        vector<int> lastPos(26, -1);\\n        for (int i = 0; i < s.size(); ++i){\\n            char c = s[i];\\n            priority_queue<int> q;\\n            lastPos[c - \\'a\\'] = i;\\n            for (auto& n : lastPos)\\n                if (n != -1) q.push(n);\\n            int rightWindow = -1, curMultiplier = 1;\\n            while (!q.empty()){\\n                int t = q.top();\\n                q.pop();\\n                if (rightWindow == -1){\\n                    rightWindow = t;\\n                }\\n                else{\\n                    ans += curMultiplier++ * (rightWindow - t);\\n                    rightWindow = t;\\n                }\\n            }\\n            ans += curMultiplier * (rightWindow + 1);\\n        }\\n        return ans;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766061,
                "title": "find-the-total-appeal-contributed-by-that-character",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFor each character, find the total appeal contributed by that character.\\nGiven len as the length of the string and i as the index of the character, each character will contribute at least len-i times to the total appeal. As i increases, appeal contributed by the ith character multiplies i times UNLESS the ith character has previously appeared in the string, in which case the ith character\\'s appeal will only be multiplied (i-lastIndexOfI) times :\\n0 1 2 3 4 (i)\\na b b c a\\n5 4 3 2 1 - ith character\\'s contribution to the appeal of substrings from 0 to 4 (a, ab, abb, abbc, abbca)\\n_ 4 0 2 1 - ith character\\'s contribution to the appeal of substrings from 1 to 4 (b, bb, bbc, bbca)\\n_ _ 0 2 1 - ith character\\'s contribution to the appeal of substrings from 2 to 4 (b, bc, bca)\\n_ _ _ 2 1 - ith character\\'s contribution to the appeal of substrings from 3 to 4 (c, ca)\\n_ _ _ _ 0 - ith character\\'s contribution to the appeal of substrings from 4 to 4 (a)\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public long appealSum(String s) {\\n        long appealSum = 0;\\n        if (s != null && !s.isEmpty()) {\\n            HashMap<Character, Integer> lastIndex = new HashMap();\\n            for (int i=0; i<s.length(); i++) {\\n                char ch = s.charAt(i);\\n                int last = lastIndex.get(ch) != null ? lastIndex.get(ch) : -1;\\n                appealSum += (s.length()-i) * (i-last);\\n                lastIndex.put(ch, i);\\n            }\\n        }\\n\\n        return appealSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long appealSum(String s) {\\n        long appealSum = 0;\\n        if (s != null && !s.isEmpty()) {\\n            HashMap<Character, Integer> lastIndex = new HashMap();\\n            for (int i=0; i<s.length(); i++) {\\n                char ch = s.charAt(i);\\n                int last = lastIndex.get(ch) != null ? lastIndex.get(ch) : -1;\\n                appealSum += (s.length()-i) * (i-last);\\n                lastIndex.put(ch, i);\\n            }\\n        }\\n\\n        return appealSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736467,
                "title": "c-python-solution-with-explanation",
                "content": "```cur``` is total appeal of substrings which end at ```i```.\\nFor letter ```s[i]```, we want to find total appeal of substrings which end at ```i```.\\nwe want to update```cur``` from ```i-1``` to ```i```. \\nWe can find previous position of same letter, there are ```i -  previous position - 1``` substrings not has letter ```s[i]```.\\nAnd ```s[i]``` also is a subsubstring  end at ```i```, \\n\\ntotal appeal of substrings which end at ```i``` = ```cur``` + ```i -  previous position```.\\nWe just return sum of each ```cur```.\\ntc is O(n), sc is O(1).\\n\\n\\n```\\ndabc d\\nwhere s[i-1] = c, s[i] is last d.\\ncur[i-1] = sum(appeal of dabc, abc, bc, c) = 10\\nabc, bc, c adding last d will increase appeal value, there are 3 substrings.\\ncur[i] = 10 + 3 + 1 = 14\\n\\ndabcd 4\\nabcd 4\\nbcd 3\\ncd 2\\nd 1\\nsum of appeal = 14\\n```\\n\\n### python\\n```python\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n\\t\\t\\n\\t\\t# previous position before i for each letter\\n        letter = [-1] * 26\\n\\t\\t\\n        ans = 0 # sum of each cur\\n        cur = 0 # total appeal of substrings which end at i\\n\\t\\t\\n\\t\\t# for each letter\\n        for i, ch in enumerate(s):\\n\\t\\t\\n\\t\\t\\t# how many substrings not have letter `ch`\\n            cnt = i - letter[ord(ch) - ord(\\'a\\')]\\n\\t\\t\\t\\n            cur += cnt # total appeal of substrings which end at i\\n\\t\\t\\t\\n\\t\\t\\t# add each cur\\n            ans += cur\\n\\t\\t\\t\\n\\t\\t\\t# update position of letter\\n            letter[ord(ch) - ord(\\'a\\')] = i\\n\\t\\t\\n        return ans\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        vector<int> letter (26, -1);\\n        long long ans = 0, cur = 0;\\n        for (int i = 0, cnt; i < s.size(); i+=1) {\\n            cnt = i - letter[s[i] - \\'a\\'];\\n            cur += cnt;\\n            ans += cur;\\n            letter[s[i] - \\'a\\'] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```cur```\n```i```\n```s[i]```\n```i```\n```cur```\n```i-1```\n```i```\n```i -  previous position - 1```\n```s[i]```\n```s[i]```\n```i```\n```i```\n```cur```\n```i -  previous position```\n```cur```\n```\\ndabc d\\nwhere s[i-1] = c, s[i] is last d.\\ncur[i-1] = sum(appeal of dabc, abc, bc, c) = 10\\nabc, bc, c adding last d will increase appeal value, there are 3 substrings.\\ncur[i] = 10 + 3 + 1 = 14\\n\\ndabcd 4\\nabcd 4\\nbcd 3\\ncd 2\\nd 1\\nsum of appeal = 14\\n```\n```python\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n\\t\\t\\n\\t\\t# previous position before i for each letter\\n        letter = [-1] * 26\\n\\t\\t\\n        ans = 0 # sum of each cur\\n        cur = 0 # total appeal of substrings which end at i\\n\\t\\t\\n\\t\\t# for each letter\\n        for i, ch in enumerate(s):\\n\\t\\t\\n\\t\\t\\t# how many substrings not have letter `ch`\\n            cnt = i - letter[ord(ch) - ord(\\'a\\')]\\n\\t\\t\\t\\n            cur += cnt # total appeal of substrings which end at i\\n\\t\\t\\t\\n\\t\\t\\t# add each cur\\n            ans += cur\\n\\t\\t\\t\\n\\t\\t\\t# update position of letter\\n            letter[ord(ch) - ord(\\'a\\')] = i\\n\\t\\t\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        vector<int> letter (26, -1);\\n        long long ans = 0, cur = 0;\\n        for (int i = 0, cnt; i < s.size(); i+=1) {\\n            cnt = i - letter[s[i] - \\'a\\'];\\n            cur += cnt;\\n            ans += cur;\\n            letter[s[i] - \\'a\\'] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731658,
                "title": "dp-approach-just-store-the-index-of-the-characters",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n(n)\\n\\n- Space complexity:\\nO(26)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int n = s.size();\\n        int charIndex[26];\\n        for( int i = 0; i<26; i++ ) charIndex[i] = 0;\\n\\n        int index = 1;\\n        long long next = 0, ans = 0;\\n        for( int i = n-1; i>=0; i-- ){\\n            int curans = ( n - i - 1 ) + next + 1;\\n            curans -= charIndex[s[i]-\\'a\\'];\\n            ans += curans;\\n\\n            next = curans;\\n            charIndex[ s[i] - \\'a\\' ] = index++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int n = s.size();\\n        int charIndex[26];\\n        for( int i = 0; i<26; i++ ) charIndex[i] = 0;\\n\\n        int index = 1;\\n        long long next = 0, ans = 0;\\n        for( int i = n-1; i>=0; i-- ){\\n            int curans = ( n - i - 1 ) + next + 1;\\n            curans -= charIndex[s[i]-\\'a\\'];\\n            ans += curans;\\n\\n            next = curans;\\n            charIndex[ s[i] - \\'a\\' ] = index++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722903,
                "title": "easy-fast-linear-time-o-n-constant-space-o-1-optimal-c-solution",
                "content": "```\\nclass Solution {\\n   public:\\n    long long appealSum(string s)\\n    {\\n        // * contribution of each character is in all the\\n        // * substrings after its previous occurrence and\\n        // * those which contain it (the current index).\\n        // # start after last occurrence till current\\n        // # end at or after current occurrence\\n        const long long n = size(s);\\n        vector lastPos(26, -1);\\n        long long ans = 0;\\n        for (long long i = 0; i < n; i++)\\n            ans += (i - exchange(lastPos[s[i] - \\'a\\'], i)) *\\n                   (n - i);\\n        return ans;\\n    }\\n};\\n```\\n**If you have any doubts or suggestions, please feel free to comment.\\nIf you find this solution useful, you know where the upvote is :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    long long appealSum(string s)\\n    {\\n        // * contribution of each character is in all the\\n        // * substrings after its previous occurrence and\\n        // * those which contain it (the current index).\\n        // # start after last occurrence till current\\n        // # end at or after current occurrence\\n        const long long n = size(s);\\n        vector lastPos(26, -1);\\n        long long ans = 0;\\n        for (long long i = 0; i < n; i++)\\n            ans += (i - exchange(lastPos[s[i] - \\'a\\'], i)) *\\n                   (n - i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707444,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long int x=1, y=1, k=0;\\n        vector<int>v(26, -1);\\n        v[s[0]-\\'a\\']=1;\\n        for(int i=1;i<s.size();i++){\\n            x += i+1;\\n            if(v[s[i]-\\'a\\']>0){\\n                x -= v[s[i]-\\'a\\'];\\n            }\\n            y += x;\\n            v[s[i]-\\'a\\'] = i+1;\\n        }\\n        return y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long int x=1, y=1, k=0;\\n        vector<int>v(26, -1);\\n        v[s[0]-\\'a\\']=1;\\n        for(int i=1;i<s.size();i++){\\n            x += i+1;\\n            if(v[s[i]-\\'a\\']>0){\\n                x -= v[s[i]-\\'a\\'];\\n            }\\n            y += x;\\n            v[s[i]-\\'a\\'] = i+1;\\n        }\\n        return y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652992,
                "title": "easy-o-n-c-soln-with-explaination-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can easily do it in O(n2) but we need to do it on O(n) to avoid TLE\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhere we count the score of all strings ending at ith locn,that will be the score of the previous character + i+1 because all strings have been extended with length 1;\\nbut if we have already seen a character then the strings starting before the previous position wont have an increase in score because in that string the chacter has already been seen, so the increase will happen only from the point after its seen , so we subtract its previous position\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long appealSum(string s) \\n    {\\n        ios::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n        int n=s.length();\\n        int map[26]={};\\n        long long ans=0,temp=0;\\n        int j=0;\\n        for(const auto & i:s)\\n        {\\n            temp+=j+1-map[i-\\'a\\'];\\n            map[i-\\'a\\']=j+1;\\n            ans+=temp;\\n            j++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long appealSum(string s) \\n    {\\n        ios::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n        int n=s.length();\\n        int map[26]={};\\n        long long ans=0,temp=0;\\n        int j=0;\\n        for(const auto & i:s)\\n        {\\n            temp+=j+1-map[i-\\'a\\'];\\n            map[i-\\'a\\']=j+1;\\n            ans+=temp;\\n            j++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3650674,
                "title": "simple-fast-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def appealSum(self, s):\\n        last = {}\\n        res = 0\\n        for i,c in enumerate(s):\\n            last[c] = i + 1\\n            res += sum(last.values())\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def appealSum(self, s):\\n        last = {}\\n        res = 0\\n        for i,c in enumerate(s):\\n            last[c] = i + 1\\n            res += sum(last.values())\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613381,
                "title": "java-next-index-iterative-left-count-right-count",
                "content": "```\\nclass Solution {\\n    public long appealSum(String s) {\\n        int n=s.length();\\n        int[] ind=new int[26];\\n        int[] nextInd=new int[n];\\n        Arrays.fill(ind, n);\\n        for(int i=n-1; i>=0; i--){\\n            int alpInd=s.charAt(i)-\\'a\\';\\n            nextInd[i]=ind[alpInd];\\n            ind[alpInd]=i;\\n        }\\n        long ans=0;\\n        for(int i=0; i<n; i++){\\n            ans+=(i+1)*(nextInd[i]-i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public long appealSum(String s) {\\n        int n=s.length();\\n        int[] ind=new int[26];\\n        int[] nextInd=new int[n];\\n        Arrays.fill(ind, n);\\n        for(int i=n-1; i>=0; i--){\\n            int alpInd=s.charAt(i)-\\'a\\';\\n            nextInd[i]=ind[alpInd];\\n            ind[alpInd]=i;\\n        }\\n        long ans=0;\\n        for(int i=0; i<n; i++){\\n            ans+=(i+1)*(nextInd[i]-i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556550,
                "title": "c-dp",
                "content": "# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        // H X P e (epsilon is where at) :pokemon-nft:\\n        ll appeal = 0, n = s.size();\\n        for(char c = \\'a\\'; c<=\\'z\\'; c++){\\n            vector<ll>xs; ll ct = 0;\\n            for(ll i=0; i<n; i++){\\n                if(s[i]==c){\\n                    if(ct) xs.push_back(ct); \\n                    ct = 0;\\n                }\\n                else{\\n                    ct++;\\n                }\\n            }\\n            if(s[n-1]!=c){\\n                if(ct) xs.push_back(ct);\\n            }\\n            ct = (n*(n+1)/2); \\n            for(auto x: xs){ \\n                ct -= (x*(x+1)/2);\\n            }\\n            appeal += ct;\\n        }\\n        return appeal;\\n    }    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        // H X P e (epsilon is where at) :pokemon-nft:\\n        ll appeal = 0, n = s.size();\\n        for(char c = \\'a\\'; c<=\\'z\\'; c++){\\n            vector<ll>xs; ll ct = 0;\\n            for(ll i=0; i<n; i++){\\n                if(s[i]==c){\\n                    if(ct) xs.push_back(ct); \\n                    ct = 0;\\n                }\\n                else{\\n                    ct++;\\n                }\\n            }\\n            if(s[n-1]!=c){\\n                if(ct) xs.push_back(ct);\\n            }\\n            ct = (n*(n+1)/2); \\n            for(auto x: xs){ \\n                ct -= (x*(x+1)/2);\\n            }\\n            appeal += ct;\\n        }\\n        return appeal;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548490,
                "title": "beats-100-c-solution",
                "content": "# Intuition\\nFirst thought was to use two for loops, I solved it using same but then for larger inputs code was giving timeout issue. Then I found this solution in other solutions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n26 alphabets array, calcaulate there appeal based on position\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public long AppealSum(string s) {\\n            List<int> list = Enumerable.Repeat(0, 26).ToList();\\n            long sum = 0;\\n            long res = 0;\\n            for(int i = 0; i < s.Length; ++i)\\n            {\\n                //Console.Write(\"i:\"+i+\" \"+s[i]);\\n                //Console.Write(\"  Sum:\" + sum);\\n                //Console.Write(\"  list[s[i] - \\'a\\']:\" + list[s[i] - \\'a\\']);\\n                sum +=i+1-list[s[i] - \\'a\\'];\\n                //Console.Write(\"  Sum:\" + sum);\\n                list[s[i] - \\'a\\'] = i + 1;\\n                //Console.Write(\"  list[s[i] - \\'a\\']:\" + list[s[i] - \\'a\\']);\\n                //Console.Write(\"  res:\" + res);\\n                res += sum;\\n                //Console.WriteLine(\"  res:\" + res);\\n\\n\\n            }\\n            return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long AppealSum(string s) {\\n            List<int> list = Enumerable.Repeat(0, 26).ToList();\\n            long sum = 0;\\n            long res = 0;\\n            for(int i = 0; i < s.Length; ++i)\\n            {\\n                //Console.Write(\"i:\"+i+\" \"+s[i]);\\n                //Console.Write(\"  Sum:\" + sum);\\n                //Console.Write(\"  list[s[i] - \\'a\\']:\" + list[s[i] - \\'a\\']);\\n                sum +=i+1-list[s[i] - \\'a\\'];\\n                //Console.Write(\"  Sum:\" + sum);\\n                list[s[i] - \\'a\\'] = i + 1;\\n                //Console.Write(\"  list[s[i] - \\'a\\']:\" + list[s[i] - \\'a\\']);\\n                //Console.Write(\"  res:\" + res);\\n                res += sum;\\n                //Console.WriteLine(\"  res:\" + res);\\n\\n\\n            }\\n            return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531331,
                "title": "just-analyse-the-transition-from-i-to-i-1",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        map<char, vector<int>> pos;\\n        long long sum = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            pos[s[i]].push_back(i);\\n            \\n            sum += pos.size();\\n        }\\n        \\n        for (auto &[_, indices] : pos) {\\n            reverse(indices.begin(), indices.end());\\n        }\\n        \\n        long long res = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            res += sum;\\n            \\n            auto &indices = pos[s[i]];\\n            indices.pop_back();\\n            \\n            if (indices.size() == 0) {\\n                pos.erase(s[i]);\\n                sum -= s.size() - i; // it was contributing to s.size() - i substrings\\n            }\\n            else {\\n                sum -= indices.back() - i; // substring in which ith was contributing..\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        map<char, vector<int>> pos;\\n        long long sum = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            pos[s[i]].push_back(i);\\n            \\n            sum += pos.size();\\n        }\\n        \\n        for (auto &[_, indices] : pos) {\\n            reverse(indices.begin(), indices.end());\\n        }\\n        \\n        long long res = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            res += sum;\\n            \\n            auto &indices = pos[s[i]];\\n            indices.pop_back();\\n            \\n            if (indices.size() == 0) {\\n                pos.erase(s[i]);\\n                sum -= s.size() - i; // it was contributing to s.size() - i substrings\\n            }\\n            else {\\n                sum -= indices.back() - i; // substring in which ith was contributing..\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518633,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public long appealSum(String s) {\\n        long result=1;\\n        int ans[]=new int[s.length()];\\n        ans[0]=1;\\n        HashMap<Character,Integer> h=new HashMap<Character,Integer>();\\n        h.put(s.charAt(0),0);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(!h.containsKey(s.charAt(i)))\\n            {\\n                h.put(s.charAt(i),i);\\n                ans[i]=ans[i-1]+(i+1);\\n            }\\n            else\\n            {\\n                int index=h.get(s.charAt(i));\\n                ans[i]=ans[i-1]+(i-index);\\n                h.put(s.charAt(i),i);\\n            }\\n            result+=ans[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long appealSum(String s) {\\n        long result=1;\\n        int ans[]=new int[s.length()];\\n        ans[0]=1;\\n        HashMap<Character,Integer> h=new HashMap<Character,Integer>();\\n        h.put(s.charAt(0),0);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(!h.containsKey(s.charAt(i)))\\n            {\\n                h.put(s.charAt(i),i);\\n                ans[i]=ans[i-1]+(i+1);\\n            }\\n            else\\n            {\\n                int index=h.get(s.charAt(i));\\n                ans[i]=ans[i-1]+(i-index);\\n                h.put(s.charAt(i),i);\\n            }\\n            result+=ans[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512888,
                "title": "simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int n=s.size();\\n        vector<long long>dp(n,1);\\n        map<char,int>mp;\\n        for(int i=0;i<26;i++)\\n        {\\n            char c=char(\\'a\\'+i);\\n            mp[c]=n;\\n        }\\n        mp[s[n-1]]=n-1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            dp[i]+=dp[i+1]+(mp[s[i]]-(i+1));\\n            //cout<<mp[s[i]]<<endl;\\n            mp[s[i]]=i;\\n        }\\n        //for(auto it:dp)cout<<it<<\" \";\\n        long long ans=0;\\n        for(auto it:dp)ans+=it;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int n=s.size();\\n        vector<long long>dp(n,1);\\n        map<char,int>mp;\\n        for(int i=0;i<26;i++)\\n        {\\n            char c=char(\\'a\\'+i);\\n            mp[c]=n;\\n        }\\n        mp[s[n-1]]=n-1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            dp[i]+=dp[i+1]+(mp[s[i]]-(i+1));\\n            //cout<<mp[s[i]]<<endl;\\n            mp[s[i]]=i;\\n        }\\n        //for(auto it:dp)cout<<it<<\" \";\\n        long long ans=0;\\n        for(auto it:dp)ans+=it;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3497774,
                "title": "c-incrementally-build-contribution-of-each-char",
                "content": "Incrementally build each char\\'s contribution as appears at end of suffixs\\nThe `a` as in the end of `(*)a([^a]^n)a`, contributes `prev + (n+1)`,\\nwhere `prev` is the contribution of the letter preceeding it.\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long sum = 0;\\n        vector<int> last(26, -1); // last occurrence index/position of each char\\n        for(int cur = 0, i = 0; i < s.size(); ++i) {\\n            int n = i - last[s[i]-\\'a\\'];\\n            last[s[i]-\\'a\\'] = i;\\n            sum += (cur += n);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long sum = 0;\\n        vector<int> last(26, -1); // last occurrence index/position of each char\\n        for(int cur = 0, i = 0; i < s.size(); ++i) {\\n            int n = i - last[s[i]-\\'a\\'];\\n            last[s[i]-\\'a\\'] = i;\\n            sum += (cur += n);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461116,
                "title": "dp-from-a-different-perspective",
                "content": "# Approach\\nAfter the i-th round of the for loop, cnt[k][0] means how many substrings ending at index i don\\'t have the character k, while cnt[k][1] means the opposite. \\n\\nThe i-th character only affects cnt[i][0]. \\n\\nFurthermore, we can dynamically update cnt for all 26 characters. \\n\\nq holds the appeal number for the substrings ending at index i after the i-th round of for loop.\\n\\n\\n# Code\\n\\n## C++\\n```cpp\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int cnt[26][2] = {0};\\n        long long r = 0, q = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            int v = s[i] - \\'a\\';\\n            q += cnt[v][0] + 1;\\n            r += q;\\n            cnt[v][1] += cnt[v][0] + 1;\\n            cnt[v][0] = 0;\\n            for (int j = 0; j < 26; j++) {\\n                if (j != v) {\\n                    cnt[j][0] += 1;\\n                }\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```\\n\\n## Python\\n```python\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        cnt = [[0] * 2 for i in range(26)]\\n        r = 0\\n        q = 0\\n        for i, c in enumerate(s):\\n            v = ord(c) - ord(\\'a\\')\\n            q += cnt[v][0] + 1\\n            r += q\\n            cnt[v][1] += cnt[v][0] + 1\\n            cnt[v][0] = 0\\n            for j in range(26):\\n                if j != v:\\n                    cnt[j][0] += 1\\n            \\n            for j in range(26):\\n                assert(cnt[j][0] + cnt[j][1] == i + 1)\\n        return r\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int cnt[26][2] = {0};\\n        long long r = 0, q = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            int v = s[i] - \\'a\\';\\n            q += cnt[v][0] + 1;\\n            r += q;\\n            cnt[v][1] += cnt[v][0] + 1;\\n            cnt[v][0] = 0;\\n            for (int j = 0; j < 26; j++) {\\n                if (j != v) {\\n                    cnt[j][0] += 1;\\n                }\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        cnt = [[0] * 2 for i in range(26)]\\n        r = 0\\n        q = 0\\n        for i, c in enumerate(s):\\n            v = ord(c) - ord(\\'a\\')\\n            q += cnt[v][0] + 1\\n            r += q\\n            cnt[v][1] += cnt[v][0] + 1\\n            cnt[v][0] = 0\\n            for j in range(26):\\n                if j != v:\\n                    cnt[j][0] += 1\\n            \\n            for j in range(26):\\n                assert(cnt[j][0] + cnt[j][1] == i + 1)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456372,
                "title": "o-26-n-instead-of-o-n-solution-easier-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n      vector<int> hash(26,-1);\\nlong long sum = 0;\\n      for(int i=0; i<s.size(); i++){ //all substrings ending with index i\\n// last occurence of a letter\\n          hash[s[i] - \\'a\\'] = i;\\n// that particular letter will be present in last index+1 substrings, needs a bit of visualization.\\n          for(int j=0; j<26; j++){\\n              if(hash[j] == -1) continue;\\n              sum += hash[j]+1;\\n          }\\n      }\\n      return sum;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n      vector<int> hash(26,-1);\\nlong long sum = 0;\\n      for(int i=0; i<s.size(); i++){ //all substrings ending with index i\\n// last occurence of a letter\\n          hash[s[i] - \\'a\\'] = i;\\n// that particular letter will be present in last index+1 substrings, needs a bit of visualization.\\n          for(int j=0; j<26; j++){\\n              if(hash[j] == -1) continue;\\n              sum += hash[j]+1;\\n          }\\n      }\\n      return sum;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446551,
                "title": "sakshi-awadhiya",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long appealSum(String s) {\\nint last[] = new int[26]; //creating a new array to store the characters\\n        long res = 0; // creating res variable\\n        for (int i = 0; i < s.length(); ++i) { // traverse the whole string\\n            last[s.charAt(i) - \\'a\\'] = i + 1;\\n            for (int j: last)\\n                res += j;\\n        }\\n        return res;\\n    }\\n        \\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long appealSum(String s) {\\nint last[] = new int[26]; //creating a new array to store the characters\\n        long res = 0; // creating res variable\\n        for (int i = 0; i < s.length(); ++i) { // traverse the whole string\\n            last[s.charAt(i) - \\'a\\'] = i + 1;\\n            for (int j: last)\\n                res += j;\\n        }\\n        return res;\\n    }\\n        \\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442574,
                "title": "shortest-easiest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        vector<int>p(26);\\n        long long k=0;\\n        for(int i=0;i<s.length();i++){p[s[i]-\\'a\\']=i+1;for(int j=0;j<p.size();j++)k+=p[j];}\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        vector<int>p(26);\\n        long long k=0;\\n        for(int i=0;i<s.length();i++){p[s[i]-\\'a\\']=i+1;for(int j=0;j<p.size();j++)k+=p[j];}\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437370,
                "title": "o-n-solution-beats-88",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        total = 0\\n        prev = 0\\n        last_idx = {}\\n        for i,c in enumerate(s):\\n            prev += i-last_idx.get(c, -1)\\n            # print(f\"{i=}, count={prev}\")\\n            total += prev\\n            last_idx[c] = i\\n        return total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def appealSum(self, s: str) -> int:\\n        total = 0\\n        prev = 0\\n        last_idx = {}\\n        for i,c in enumerate(s):\\n            prev += i-last_idx.get(c, -1)\\n            # print(f\"{i=}, count={prev}\")\\n            total += prev\\n            last_idx[c] = i\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419073,
                "title": "an-easy-and-short-solution-beat-98-54-runtime-and-92-2-memory",
                "content": "# Approach\\nSuppose dp[$$i$$] is the total appeal of all substrings that end at index $$i$$\\n \\n(dp[$$i$$] = **SUM** of appeal(s[$$j$$:$$i$$]) with 0 <= $$i$$ < s.length() and 0 <= $$j $$<= $$i$$) **(1)**\\n\\nSuppose the last index of the character s[$$i$$] (before $$i$$) is lastest(s[$$i$$])\\n\\nwe have:\\n- appeal(s[$$j$$:$$i$$]) = appeal(s[$$j$$:$$i$$-1]) **If** 0 <= $$j$$ <= lastest(s[$$i$$]) **(2)**\\n- appeal(s[$$j$$:$$i$$]) = appeal(s[$$j$$:$$i$$-1]) + 1 **If** $$i$$ > $$j$$ > lastest(s[$$i$$]) **(3)**\\n- appeal(s[$$i$$:$$i$$]) = 1 **(4)**\\n\\n\\nFrom **(1)-(4)** we have: dp[$$i$$] = d[$$i$$-1] + $$i$$ - lastest(s[$$i$$])\\n\\nThe Final result is equal to SUM of all dp[$$i$$] for $$i$$ = 0 to s.length()-1\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int len = s.length();\\n        vector<int> lastest(26, -1);\\n        int curr = 0;   // dp[i]\\n        int prev = 1;   // dp[i-1], initialized with the value of dp[0]\\n        lastest[s[0] - \\'a\\'] = 0;\\n        long long total = 1;\\n        \\n        for (int i=1; i<len; i++) {\\n            int tmp = s[i]- \\'a\\';\\n            curr = prev + i - lastest[tmp];    // dp[i] = dp[i-1] + i- lastest[s[i]] \\n            lastest[tmp] = i;\\n            prev = curr;\\n            total += curr;\\n        }\\n\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        int len = s.length();\\n        vector<int> lastest(26, -1);\\n        int curr = 0;   // dp[i]\\n        int prev = 1;   // dp[i-1], initialized with the value of dp[0]\\n        lastest[s[0] - \\'a\\'] = 0;\\n        long long total = 1;\\n        \\n        for (int i=1; i<len; i++) {\\n            int tmp = s[i]- \\'a\\';\\n            curr = prev + i - lastest[tmp];    // dp[i] = dp[i-1] + i- lastest[s[i]] \\n            lastest[tmp] = i;\\n            prev = curr;\\n            total += curr;\\n        }\\n\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381095,
                "title": "python-solution",
                "content": "# Intuition\\nThe problem asks for the \"appeal\" of all substrings of the given string s. The appeal of a substring is defined as the number of distinct characters in that substring. To find the answer, we need to find the appeal of each substring and sum them up.\\n\\n# Approach\\nThe approach taken by this solution is to use dynamic programming to keep track of the last position of each character in the string s. For each index i in the string s, we calculate the current substring\\'s appeal and add it to the final answer. The current substring\\'s appeal is the sum of the distance between the current index and the last position of each character in the substring. To avoid recomputing the last position of a character in each substring, we store them in a DP table.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is O(n) because we only loop through the string once and perform constant-time operations inside the loop.\\n\\n- Space complexity:\\nThe space complexity is O(1) because we only use a fixed-size DP table of size 26, regardless of the length of the input string.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def appealSum(self, s):\\n        n = len(s)\\n        dp = [-1] * 26\\n        ans = cur = 0\\n        for i in range(n):\\n            j = ord(s[i]) - 97\\n            cur += i - dp[j]\\n            ans += cur\\n            dp[j] = i\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def appealSum(self, s):\\n        n = len(s)\\n        dp = [-1] * 26\\n        ans = cur = 0\\n        for i in range(n):\\n            j = ord(s[i]) - 97\\n            cur += i - dp[j]\\n            ans += cur\\n            dp[j] = i\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365397,
                "title": "c",
                "content": "```\\nlong long appealSum(char * s){\\n    int n = strlen(s) ;\\n    int last[26] ;       \\n    memset(last, -1, 26*sizeof(int));        \\n    long long ret = 0;\\n    for (int i=0; i<n; i++)\\n    {\\n        int idx = s[i] - \\'a\\' ;\\n        ret += (i - last[idx] ) * (n-i) ;\\n        last[idx] = i;\\n    }       \\n    return ret;  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlong long appealSum(char * s){\\n    int n = strlen(s) ;\\n    int last[26] ;       \\n    memset(last, -1, 26*sizeof(int));        \\n    long long ret = 0;\\n    for (int i=0; i<n; i++)\\n    {\\n        int idx = s[i] - \\'a\\' ;\\n        ret += (i - last[idx] ) * (n-i) ;\\n        last[idx] = i;\\n    }       \\n    return ret;  \\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565929,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Me after seeing solution of this problem\\n![image](https://assets.leetcode.com/users/images/771a43da-5999-4c40-bcb6-1de2c3f4561c_1654415341.7185009.png)\\n"
                    },
                    {
                        "username": "AirpodsKiller",
                        "content": "lmao"
                    },
                    {
                        "username": "scr08212",
                        "content": "lmao"
                    },
                    {
                        "username": "cursydd",
                        "content": "1) Try to count appeal of substrings ending at the ith character.\\n2) Try to solve it for the case when all characters are different \\n3) Try repeating only one single character and see how it changes things. \\n"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "thanks it worked\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "amazing question man."
                    },
                    {
                        "username": "DDDPVPDDD",
                        "content": "// java O(n) time O(26) space\\n\\nclass Solution {\\n    public long appealSum(String s) {\\n        int dp [] = new int[26];\\n        long result = 0L;\\n        for(int index = 0; index < s.length(); index++)\\n        {\\n            dp[s.charAt(index) - \\'a\\'] = index + 1;\\n            for(int num:dp) result += num;\\n        }\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "Haribol12",
                        "content": "Seems straightforward but its actually not ;)"
                    },
                    {
                        "username": "agnishh",
                        "content": "Why does this [solution](https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/submissions/1023710882/) not work? Is it not the exact same question?"
                    },
                    {
                        "username": "altyon",
                        "content": "In that problem, \\'unique characters\\' refer to those that appear only once, and here it\\'s asking for the number of distinct characters. For example, in \\'ABA,\\' there is 1 unique character (\\'B\\') and 2 distinct characters ( \\'A\\', \\'B\\' )."
                    }
                ]
            },
            {
                "id": 1802971,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Me after seeing solution of this problem\\n![image](https://assets.leetcode.com/users/images/771a43da-5999-4c40-bcb6-1de2c3f4561c_1654415341.7185009.png)\\n"
                    },
                    {
                        "username": "AirpodsKiller",
                        "content": "lmao"
                    },
                    {
                        "username": "scr08212",
                        "content": "lmao"
                    },
                    {
                        "username": "cursydd",
                        "content": "1) Try to count appeal of substrings ending at the ith character.\\n2) Try to solve it for the case when all characters are different \\n3) Try repeating only one single character and see how it changes things. \\n"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "thanks it worked\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "amazing question man."
                    },
                    {
                        "username": "DDDPVPDDD",
                        "content": "// java O(n) time O(26) space\\n\\nclass Solution {\\n    public long appealSum(String s) {\\n        int dp [] = new int[26];\\n        long result = 0L;\\n        for(int index = 0; index < s.length(); index++)\\n        {\\n            dp[s.charAt(index) - \\'a\\'] = index + 1;\\n            for(int num:dp) result += num;\\n        }\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "Haribol12",
                        "content": "Seems straightforward but its actually not ;)"
                    },
                    {
                        "username": "agnishh",
                        "content": "Why does this [solution](https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/submissions/1023710882/) not work? Is it not the exact same question?"
                    },
                    {
                        "username": "altyon",
                        "content": "In that problem, \\'unique characters\\' refer to those that appear only once, and here it\\'s asking for the number of distinct characters. For example, in \\'ABA,\\' there is 1 unique character (\\'B\\') and 2 distinct characters ( \\'A\\', \\'B\\' )."
                    }
                ]
            },
            {
                "id": 1945200,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Me after seeing solution of this problem\\n![image](https://assets.leetcode.com/users/images/771a43da-5999-4c40-bcb6-1de2c3f4561c_1654415341.7185009.png)\\n"
                    },
                    {
                        "username": "AirpodsKiller",
                        "content": "lmao"
                    },
                    {
                        "username": "scr08212",
                        "content": "lmao"
                    },
                    {
                        "username": "cursydd",
                        "content": "1) Try to count appeal of substrings ending at the ith character.\\n2) Try to solve it for the case when all characters are different \\n3) Try repeating only one single character and see how it changes things. \\n"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "thanks it worked\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "amazing question man."
                    },
                    {
                        "username": "DDDPVPDDD",
                        "content": "// java O(n) time O(26) space\\n\\nclass Solution {\\n    public long appealSum(String s) {\\n        int dp [] = new int[26];\\n        long result = 0L;\\n        for(int index = 0; index < s.length(); index++)\\n        {\\n            dp[s.charAt(index) - \\'a\\'] = index + 1;\\n            for(int num:dp) result += num;\\n        }\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "Haribol12",
                        "content": "Seems straightforward but its actually not ;)"
                    },
                    {
                        "username": "agnishh",
                        "content": "Why does this [solution](https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/submissions/1023710882/) not work? Is it not the exact same question?"
                    },
                    {
                        "username": "altyon",
                        "content": "In that problem, \\'unique characters\\' refer to those that appear only once, and here it\\'s asking for the number of distinct characters. For example, in \\'ABA,\\' there is 1 unique character (\\'B\\') and 2 distinct characters ( \\'A\\', \\'B\\' )."
                    }
                ]
            },
            {
                "id": 1718423,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Me after seeing solution of this problem\\n![image](https://assets.leetcode.com/users/images/771a43da-5999-4c40-bcb6-1de2c3f4561c_1654415341.7185009.png)\\n"
                    },
                    {
                        "username": "AirpodsKiller",
                        "content": "lmao"
                    },
                    {
                        "username": "scr08212",
                        "content": "lmao"
                    },
                    {
                        "username": "cursydd",
                        "content": "1) Try to count appeal of substrings ending at the ith character.\\n2) Try to solve it for the case when all characters are different \\n3) Try repeating only one single character and see how it changes things. \\n"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "thanks it worked\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "amazing question man."
                    },
                    {
                        "username": "DDDPVPDDD",
                        "content": "// java O(n) time O(26) space\\n\\nclass Solution {\\n    public long appealSum(String s) {\\n        int dp [] = new int[26];\\n        long result = 0L;\\n        for(int index = 0; index < s.length(); index++)\\n        {\\n            dp[s.charAt(index) - \\'a\\'] = index + 1;\\n            for(int num:dp) result += num;\\n        }\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "Haribol12",
                        "content": "Seems straightforward but its actually not ;)"
                    },
                    {
                        "username": "agnishh",
                        "content": "Why does this [solution](https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/submissions/1023710882/) not work? Is it not the exact same question?"
                    },
                    {
                        "username": "altyon",
                        "content": "In that problem, \\'unique characters\\' refer to those that appear only once, and here it\\'s asking for the number of distinct characters. For example, in \\'ABA,\\' there is 1 unique character (\\'B\\') and 2 distinct characters ( \\'A\\', \\'B\\' )."
                    }
                ]
            },
            {
                "id": 2049247,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Me after seeing solution of this problem\\n![image](https://assets.leetcode.com/users/images/771a43da-5999-4c40-bcb6-1de2c3f4561c_1654415341.7185009.png)\\n"
                    },
                    {
                        "username": "AirpodsKiller",
                        "content": "lmao"
                    },
                    {
                        "username": "scr08212",
                        "content": "lmao"
                    },
                    {
                        "username": "cursydd",
                        "content": "1) Try to count appeal of substrings ending at the ith character.\\n2) Try to solve it for the case when all characters are different \\n3) Try repeating only one single character and see how it changes things. \\n"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "thanks it worked\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "amazing question man."
                    },
                    {
                        "username": "DDDPVPDDD",
                        "content": "// java O(n) time O(26) space\\n\\nclass Solution {\\n    public long appealSum(String s) {\\n        int dp [] = new int[26];\\n        long result = 0L;\\n        for(int index = 0; index < s.length(); index++)\\n        {\\n            dp[s.charAt(index) - \\'a\\'] = index + 1;\\n            for(int num:dp) result += num;\\n        }\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "Haribol12",
                        "content": "Seems straightforward but its actually not ;)"
                    },
                    {
                        "username": "agnishh",
                        "content": "Why does this [solution](https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/submissions/1023710882/) not work? Is it not the exact same question?"
                    },
                    {
                        "username": "altyon",
                        "content": "In that problem, \\'unique characters\\' refer to those that appear only once, and here it\\'s asking for the number of distinct characters. For example, in \\'ABA,\\' there is 1 unique character (\\'B\\') and 2 distinct characters ( \\'A\\', \\'B\\' )."
                    }
                ]
            },
            {
                "id": 2017830,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Me after seeing solution of this problem\\n![image](https://assets.leetcode.com/users/images/771a43da-5999-4c40-bcb6-1de2c3f4561c_1654415341.7185009.png)\\n"
                    },
                    {
                        "username": "AirpodsKiller",
                        "content": "lmao"
                    },
                    {
                        "username": "scr08212",
                        "content": "lmao"
                    },
                    {
                        "username": "cursydd",
                        "content": "1) Try to count appeal of substrings ending at the ith character.\\n2) Try to solve it for the case when all characters are different \\n3) Try repeating only one single character and see how it changes things. \\n"
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "thanks it worked\\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "amazing question man."
                    },
                    {
                        "username": "DDDPVPDDD",
                        "content": "// java O(n) time O(26) space\\n\\nclass Solution {\\n    public long appealSum(String s) {\\n        int dp [] = new int[26];\\n        long result = 0L;\\n        for(int index = 0; index < s.length(); index++)\\n        {\\n            dp[s.charAt(index) - \\'a\\'] = index + 1;\\n            for(int num:dp) result += num;\\n        }\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "Haribol12",
                        "content": "Seems straightforward but its actually not ;)"
                    },
                    {
                        "username": "agnishh",
                        "content": "Why does this [solution](https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/submissions/1023710882/) not work? Is it not the exact same question?"
                    },
                    {
                        "username": "altyon",
                        "content": "In that problem, \\'unique characters\\' refer to those that appear only once, and here it\\'s asking for the number of distinct characters. For example, in \\'ABA,\\' there is 1 unique character (\\'B\\') and 2 distinct characters ( \\'A\\', \\'B\\' )."
                    }
                ]
            }
        ]
    }
]