[
    {
        "title": "Robot Bounded In Circle",
        "question_content": "On an infinite plane, a robot initially stands at (0, 0) and faces north. Note that:\n\n\tThe north direction is the positive direction of the y-axis.\n\tThe south direction is the negative direction of the y-axis.\n\tThe east direction is the positive direction of the x-axis.\n\tThe west direction is the negative direction of the x-axis.\n\nThe robot can receive one of three instructions:\n\n\t\"G\": go straight 1 unit.\n\t\"L\": turn 90 degrees to the left (i.e., anti-clockwise direction).\n\t\"R\": turn 90 degrees to the right (i.e., clockwise direction).\n\nThe robot performs the instructions given in order, and repeats them forever.\nReturn true if and only if there exists a circle in the plane such that the robot never leaves the circle.\n&nbsp;\nExample 1:\n\nInput: instructions = \"GGLLGG\"\nOutput: true\nExplanation: The robot is initially at (0, 0) facing the north direction.\n\"G\": move one step. Position: (0, 1). Direction: North.\n\"G\": move one step. Position: (0, 2). Direction: North.\n\"L\": turn 90 degrees anti-clockwise. Position: (0, 2). Direction: West.\n\"L\": turn 90 degrees anti-clockwise. Position: (0, 2). Direction: South.\n\"G\": move one step. Position: (0, 1). Direction: South.\n\"G\": move one step. Position: (0, 0). Direction: South.\nRepeating the instructions, the robot goes into the cycle: (0, 0) --> (0, 1) --> (0, 2) --> (0, 1) --> (0, 0).\nBased on that, we return true.\n\nExample 2:\n\nInput: instructions = \"GG\"\nOutput: false\nExplanation: The robot is initially at (0, 0) facing the north direction.\n\"G\": move one step. Position: (0, 1). Direction: North.\n\"G\": move one step. Position: (0, 2). Direction: North.\nRepeating the instructions, keeps advancing in the north direction and does not go into cycles.\nBased on that, we return false.\n\nExample 3:\n\nInput: instructions = \"GL\"\nOutput: true\nExplanation: The robot is initially at (0, 0) facing the north direction.\n\"G\": move one step. Position: (0, 1). Direction: North.\n\"L\": turn 90 degrees anti-clockwise. Position: (0, 1). Direction: West.\n\"G\": move one step. Position: (-1, 1). Direction: West.\n\"L\": turn 90 degrees anti-clockwise. Position: (-1, 1). Direction: South.\n\"G\": move one step. Position: (-1, 0). Direction: South.\n\"L\": turn 90 degrees anti-clockwise. Position: (-1, 0). Direction: East.\n\"G\": move one step. Position: (0, 0). Direction: East.\n\"L\": turn 90 degrees anti-clockwise. Position: (0, 0). Direction: North.\nRepeating the instructions, the robot goes into the cycle: (0, 0) --> (0, 1) --> (-1, 1) --> (-1, 0) --> (0, 0).\nBased on that, we return true.\n\n&nbsp;\nConstraints:\n\n\t1 <= instructions.length <= 100\n\tinstructions[i] is 'G', 'L' or, 'R'.",
        "solutions": [
            {
                "id": 290856,
                "title": "java-c-python-let-chopper-help-explain",
                "content": "I expect this problem to be medium problem.\\n![image](https://assets.leetcode.com/users/lee215/image_1557633739.png)\\n\\n## **Intuition**\\nLet chopper help explain.\\n\\nStarting at the origin and face north `(0,1)`,\\nafter one sequence of `instructions`,\\n1. if chopper return to the origin, he is obvious in an circle.\\n2. if chopper finishes with face not towards north,\\nit will get back to the initial status in another one or three sequences.\\n<br>\\n\\n## **Explanation**\\n`(x,y)` is the location of chopper.\\n`d[i]` is the direction he is facing.\\n`i = (i + 1) % 4` will turn right\\n`i = (i + 3) % 4` will turn left\\nCheck the final status after `instructions`.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(1)`\\n\\n<br>\\n\\n**Java:**\\n```\\n    public boolean isRobotBounded(String ins) {\\n        int x = 0, y = 0, i = 0, d[][] = {{0, 1}, {1, 0}, {0, -1}, { -1, 0}};\\n        for (int j = 0; j < ins.length(); ++j)\\n            if (ins.charAt(j) == \\'R\\')\\n                i = (i + 1) % 4;\\n            else if (ins.charAt(j) == \\'L\\')\\n                i = (i + 3) % 4;\\n            else {\\n                x += d[i][0]; y += d[i][1];\\n            }\\n        return x == 0 && y == 0 || i > 0;\\n    }\\n```\\n\\n**C++:**\\n```\\n    bool isRobotBounded(string instructions) {\\n        int x = 0, y = 0, i = 0;\\n        vector<vector<int>> d = {{0, 1}, {1, 0}, {0, -1}, { -1, 0}};\\n        for (char & ins : instructions)\\n            if (ins == \\'R\\')\\n                i = (i + 1) % 4;\\n            else if (ins == \\'L\\')\\n                i = (i + 3) % 4;\\n            else\\n                x += d[i][0], y += d[i][1];\\n        return x == 0 && y == 0 || i > 0;\\n    }\\n```\\n\\n**Python:**\\n```\\n    def isRobotBounded(self, instructions):\\n        x, y, dx, dy = 0, 0, 0, 1\\n        for i in instructions:\\n            if i == \\'R\\': dx, dy = dy, -dx\\n            if i == \\'L\\': dx, dy = -dy, dx\\n            if i == \\'G\\': x, y = x + dx, y + dy\\n        return (x, y) == (0, 0) or (dx, dy) != (0,1)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public boolean isRobotBounded(String ins) {\\n        int x = 0, y = 0, i = 0, d[][] = {{0, 1}, {1, 0}, {0, -1}, { -1, 0}};\\n        for (int j = 0; j < ins.length(); ++j)\\n            if (ins.charAt(j) == \\'R\\')\\n                i = (i + 1) % 4;\\n            else if (ins.charAt(j) == \\'L\\')\\n                i = (i + 3) % 4;\\n            else {\\n                x += d[i][0]; y += d[i][1];\\n            }\\n        return x == 0 && y == 0 || i > 0;\\n    }\\n```\n```\\n    bool isRobotBounded(string instructions) {\\n        int x = 0, y = 0, i = 0;\\n        vector<vector<int>> d = {{0, 1}, {1, 0}, {0, -1}, { -1, 0}};\\n        for (char & ins : instructions)\\n            if (ins == \\'R\\')\\n                i = (i + 1) % 4;\\n            else if (ins == \\'L\\')\\n                i = (i + 3) % 4;\\n            else\\n                x += d[i][0], y += d[i][1];\\n        return x == 0 && y == 0 || i > 0;\\n    }\\n```\n```\\n    def isRobotBounded(self, instructions):\\n        x, y, dx, dy = 0, 0, 0, 1\\n        for i in instructions:\\n            if i == \\'R\\': dx, dy = dy, -dx\\n            if i == \\'L\\': dx, dy = -dy, dx\\n            if i == \\'G\\': x, y = x + dx, y + dy\\n        return (x, y) == (0, 0) or (dx, dy) != (0,1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 850969,
                "title": "my-java-solution-with-the-thought-process",
                "content": "```\\nclass Solution {\\n    /*\\n    My thought process:\\n    So in question its given we are initially at 0, 0 at North directions. So we need to keep track of the points as well as the directions in which the robot travels. So we can have x, y = 0 and directions = North\\n    \\n    Now our problem is to find whether the robot is moving outside the circle after following some instructions. So the robot leaves the circle if it keep moving in the North direction.\\n    \\n    So lets loop through each and every character from the instruction string, then:\\n    1. We check whether its G, if G then we have to move one point from the current position.\\n        SO if we are at North direction, then if we consider the coordinate, we are at +y directions, so we will move only up, just understand like that, SO we increment our y by 1, by following this pattern we can automatically deduce that if we are at South, then decrement y by 1. Same way for East, increment x by 1 and for West decrement x by 1.\\n    2. Next we check wheter its L, then we have to move 90 degree left wards.\\n                    North\\n            West                East    , So do a counter clockwise assumption. If we are at a directions North, then its \\n                                          counter clockwis, yes West update direction by west, Same way if our directions is                          South                West, them its counter clockwise south, same way for direction south, update                                                     direction by east. So just rememebr if chaarcter is L, then counter clockwise.\\n    3. Next whetehr the character if R, then we already got it rememebr about clockwise direction and update direction according to it\\n    \\n    Finally we check whetehr the robot get back to the position, if yes, return true as the robot donot go out of the circle.\\n    We check whether the direction is still North, then it will sure go out of the circle, so return false.\\n    If none of the above condition satisfies, then also the robot will be some where inside the circle, so return true.\\n    */\\n    public boolean isRobotBounded(String instructions) {\\n        if (instructions.length() == 0)\\n            return false;\\n        int x = 0;\\n        int y = 0;  // initial points of the robot\\n        String directions = \"North\"; // initial direction of robot\\n        /*\\n                    North\\n            West                East\\n                    South\\n                    \\n        */\\n        for (char ch: instructions.toCharArray()) {\\n            if (ch == \\'G\\') {\\n                if (directions.equals(\"North\"))\\n                    y += 1;\\n                else if (directions.equals(\"South\"))\\n                    y -= 1;\\n                else if(directions.equals(\"East\"))\\n                    x += 1;\\n                else\\n                    x -= 1;\\n            }\\n            else if (ch == \\'L\\') {\\n                if (directions.equals(\"North\"))\\n                    directions = \"West\";\\n                else if (directions.equals(\"West\"))\\n                    directions = \"South\";\\n                else if (directions.equals(\"South\"))\\n                    directions = \"East\";\\n                else directions = \"North\";\\n            }\\n            else if (ch == \\'R\\') {\\n                if (directions.equals(\"North\"))\\n                    directions = \"East\";\\n                else if (directions.equals(\"East\"))\\n                    directions = \"South\";\\n                else if (directions.equals(\"South\"))\\n                    directions = \"West\";\\n                else directions = \"North\";\\n            }\\n        }\\n        if (x == 0 && y == 0)\\n            return true;\\n        if (directions.equals(\"North\"))\\n            return false;\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    My thought process:\\n    So in question its given we are initially at 0, 0 at North directions. So we need to keep track of the points as well as the directions in which the robot travels. So we can have x, y = 0 and directions = North\\n    \\n    Now our problem is to find whether the robot is moving outside the circle after following some instructions. So the robot leaves the circle if it keep moving in the North direction.\\n    \\n    So lets loop through each and every character from the instruction string, then:\\n    1. We check whether its G, if G then we have to move one point from the current position.\\n        SO if we are at North direction, then if we consider the coordinate, we are at +y directions, so we will move only up, just understand like that, SO we increment our y by 1, by following this pattern we can automatically deduce that if we are at South, then decrement y by 1. Same way for East, increment x by 1 and for West decrement x by 1.\\n    2. Next we check wheter its L, then we have to move 90 degree left wards.\\n                    North\\n            West                East    , So do a counter clockwise assumption. If we are at a directions North, then its \\n                                          counter clockwis, yes West update direction by west, Same way if our directions is                          South                West, them its counter clockwise south, same way for direction south, update                                                     direction by east. So just rememebr if chaarcter is L, then counter clockwise.\\n    3. Next whetehr the character if R, then we already got it rememebr about clockwise direction and update direction according to it\\n    \\n    Finally we check whetehr the robot get back to the position, if yes, return true as the robot donot go out of the circle.\\n    We check whether the direction is still North, then it will sure go out of the circle, so return false.\\n    If none of the above condition satisfies, then also the robot will be some where inside the circle, so return true.\\n    */\\n    public boolean isRobotBounded(String instructions) {\\n        if (instructions.length() == 0)\\n            return false;\\n        int x = 0;\\n        int y = 0;  // initial points of the robot\\n        String directions = \"North\"; // initial direction of robot\\n        /*\\n                    North\\n            West                East\\n                    South\\n                    \\n        */\\n        for (char ch: instructions.toCharArray()) {\\n            if (ch == \\'G\\') {\\n                if (directions.equals(\"North\"))\\n                    y += 1;\\n                else if (directions.equals(\"South\"))\\n                    y -= 1;\\n                else if(directions.equals(\"East\"))\\n                    x += 1;\\n                else\\n                    x -= 1;\\n            }\\n            else if (ch == \\'L\\') {\\n                if (directions.equals(\"North\"))\\n                    directions = \"West\";\\n                else if (directions.equals(\"West\"))\\n                    directions = \"South\";\\n                else if (directions.equals(\"South\"))\\n                    directions = \"East\";\\n                else directions = \"North\";\\n            }\\n            else if (ch == \\'R\\') {\\n                if (directions.equals(\"North\"))\\n                    directions = \"East\";\\n                else if (directions.equals(\"East\"))\\n                    directions = \"South\";\\n                else if (directions.equals(\"South\"))\\n                    directions = \"West\";\\n                else directions = \"North\";\\n            }\\n        }\\n        if (x == 0 && y == 0)\\n            return true;\\n        if (directions.equals(\"North\"))\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676710,
                "title": "well-detailed-explaination-java-c-easy-for-mind-to-accept-it",
                "content": "Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# IMPORTANT TIP FOR YOU\\n```\\nIf, you are preperaing for `AMAZON interview` or will prepare. Then according to `LeetCode premium` it is no.1 most asked Question by **Amazon** as per now\\n\\n*`So, Ladies n Gentlemen without any further due, let\\'s start:`*\\n**Intution:**\\nThe robot can face in at most four directions in the 2dimensional plane, such as \"North\", \"South\", \"East\", \"West\".\\n\\nIf the robot\\'s position is bounded in a fix circular radius, the robot must eventually return to its starting position after a fixed number of instruction\\'s.\\n\\n**Approach Explained :**\\n\\nSo, suppose we have a **2 dimensional grid** we have. WIth an instruction of **\"GGLLGG\"**. which states **go-go | turn to left 90 degree-turn to left 90 degree | go-go**. If we gonna repeat forever, we will get **stuck in an infinite loop** for now.. \\n1. Let\\'s kind of simulate it 1st, we intially **start at the origin**. And let\\'s have our direction facing **North** intially we are facing north, we gonna move **twice** and still facing **North** so, what happen is we move by 1, then move by 2 we gonna be in this position **still facing North.**\\n2. And then we **turn left twice**. So, if we turn left 1 90 degree we will be facing Left, if we do twice then we are **facing Down**.\\n3. Then, we **go-go.** Go, down 1 - Go down 2 and we start back at the **origin**. The only difference is now, **instead of facing North** we are **facing South**. But, obviously we get back to start.\\n\\n`Let me show you in a diagram:`\\n![image](https://assets.leetcode.com/users/images/b1e29303-3a2b-4046-a2ee-b53d57add0dc_1641692678.0059028.png)\\n\\n**Now you can ask, can we go for an another loop**. Just as we did before? My answer is **YES**, this path is some kind of a **Vector** on this 2 dimensional grid. So, in the above case the **vector was Up by 2** & then went **staright down by 2**. So, in **total the vector was a net difference of \"0\"** So, basically it started where it\\'s end.\\n\\nEven though, **first we facing North**, now we **facing South**, it\\'s gonna **follow that same path**. It\\'s gonna move by 2 and go back in same direction it\\'s came from. Because **this Vector is a \"0\" vector doesn\\'t move any where**.\\n![image](https://assets.leetcode.com/users/images/05c49dff-1b73-4445-91da-afa6e003011a_1641693089.1963322.png)\\n\\nSo, with this atleast yes, we gonna **return True**. Because this robot stuck in an infinite loop and we only end, if we see a **circlular path**\\n\\n*Now, let\\'s code it up:*\\n`Code each line explained : Similar for C++ & Java`\\n* Step1:\\n```\\n// we know that robot can move in 4 direction\\'s\\n        // Up, left, down, right\\n        int dir[][] = {{0,1}, {-1, 0}, {0, -1}, {1,0}};\\n        int i = 0; // we have to keep tracking those cases where it\\'s not rotating.\\n        // if in the end of execution, we see it\\'s not rotating we will gonna return false;\\n       \\n        // it\\'s origin\\n        int x = 0;\\n        int y = 0;\\n```\\n* Step2:\\n```\\n// let\\'s write an for loop & iterate through the instructions. So, we keep 1 instructions at a time. \\n// And we will keep checking the position of the robot after executing particular instruction.\\n        for(int s = 0; s < instructions.length(); s++){\\n            // Now, we are checking is it a rotation\\n            if(instructions.charAt(s) == \\'L\\'){ // If it\\'s left then update it\\'s head rotation\\n                i = (i + 1) % 4; // since we are increment \"i\". To avoid array out of bound exception, we are moduling by 4\\n            }\\n            else if(instructions.charAt(s) == \\'R\\'){ // If it\\'s right then update it\\'s head rotation\\n                i = (i + 3) % 4;\\n            }\\n            // We are checking it\\'s direction\\n            else{\\n                x = x + dir[i][0];\\n                y = y + dir[i][1];\\n            }\\n        }\\n```\\n* Final Step:\\n```\\n// LAST EDIT : for (x == 0 && y == 0) We are checking is our intial position from where we started and end position where we are finishing both are same! \\n// If so,  return true;\\n\\n// If the robot perform 1 rotation, it means  \"i != 0\" then it will gauranteed perform a circle & after certain rotation it will come back to the origin.\\n        // But if \"i is  0\" , it mean\\'s robot is moving straight, hence there is no cycle. It will never come back to origin. \\n        return x == 0 && y == 0 || i != 0;\\n```\\n**Complete Code :**\\n\\n**Java**\\n```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int dir[][] = {{0,1}, {-1, 0}, {0, -1}, {1,0}};\\n        int i = 0;\\n        int x = 0;\\n        int y = 0;\\n       \\n        for(int s = 0; s < instructions.length(); s++){\\n            if(instructions.charAt(s) == \\'L\\'){\\n                i = (i + 1) % 4;\\n            }\\n            else if(instructions.charAt(s) == \\'R\\'){\\n                i = (i + 3) % 4;\\n            }\\n            else{\\n                x = x + dir[i][0];\\n                y = y + dir[i][1];\\n            }\\n        }\\n        return x == 0 && y == 0 || i != 0;\\n    }\\n}\\n```\\nC++\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        vector<vector<int>> dir = {{0,1}, {-1, 0}, {0, -1}, {1,0}};\\n        int i = 0;\\n        int x = 0;\\n        int y = 0;\\n       \\n        for(int s = 0; s < instructions.size(); s++){\\n            if(instructions.at(s) == \\'L\\'){\\n                i = (i + 1) % 4;\\n            }\\n            else if(instructions.at(s) == \\'R\\'){\\n                i = (i + 3) % 4;\\n            }\\n            else{\\n                x = x + dir[i][0];\\n                y = y + dir[i][1];\\n            }\\n        }\\n        return x == 0 && y == 0 || i != 0;\\n    }\\n};\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(1)\\n\\nIf you have some \\uD83E\\uDD14 doubts feel free to bug me anytime or If you understood than don\\'t forget to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# IMPORTANT TIP FOR YOU\\n```\n```\\n// we know that robot can move in 4 direction\\'s\\n        // Up, left, down, right\\n        int dir[][] = {{0,1}, {-1, 0}, {0, -1}, {1,0}};\\n        int i = 0; // we have to keep tracking those cases where it\\'s not rotating.\\n        // if in the end of execution, we see it\\'s not rotating we will gonna return false;\\n       \\n        // it\\'s origin\\n        int x = 0;\\n        int y = 0;\\n```\n```\\n// let\\'s write an for loop & iterate through the instructions. So, we keep 1 instructions at a time. \\n// And we will keep checking the position of the robot after executing particular instruction.\\n        for(int s = 0; s < instructions.length(); s++){\\n            // Now, we are checking is it a rotation\\n            if(instructions.charAt(s) == \\'L\\'){ // If it\\'s left then update it\\'s head rotation\\n                i = (i + 1) % 4; // since we are increment \"i\". To avoid array out of bound exception, we are moduling by 4\\n            }\\n            else if(instructions.charAt(s) == \\'R\\'){ // If it\\'s right then update it\\'s head rotation\\n                i = (i + 3) % 4;\\n            }\\n            // We are checking it\\'s direction\\n            else{\\n                x = x + dir[i][0];\\n                y = y + dir[i][1];\\n            }\\n        }\\n```\n```\\n// LAST EDIT : for (x == 0 && y == 0) We are checking is our intial position from where we started and end position where we are finishing both are same! \\n// If so,  return true;\\n\\n// If the robot perform 1 rotation, it means  \"i != 0\" then it will gauranteed perform a circle & after certain rotation it will come back to the origin.\\n        // But if \"i is  0\" , it mean\\'s robot is moving straight, hence there is no cycle. It will never come back to origin. \\n        return x == 0 && y == 0 || i != 0;\\n```\n```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int dir[][] = {{0,1}, {-1, 0}, {0, -1}, {1,0}};\\n        int i = 0;\\n        int x = 0;\\n        int y = 0;\\n       \\n        for(int s = 0; s < instructions.length(); s++){\\n            if(instructions.charAt(s) == \\'L\\'){\\n                i = (i + 1) % 4;\\n            }\\n            else if(instructions.charAt(s) == \\'R\\'){\\n                i = (i + 3) % 4;\\n            }\\n            else{\\n                x = x + dir[i][0];\\n                y = y + dir[i][1];\\n            }\\n        }\\n        return x == 0 && y == 0 || i != 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        vector<vector<int>> dir = {{0,1}, {-1, 0}, {0, -1}, {1,0}};\\n        int i = 0;\\n        int x = 0;\\n        int y = 0;\\n       \\n        for(int s = 0; s < instructions.size(); s++){\\n            if(instructions.at(s) == \\'L\\'){\\n                i = (i + 1) % 4;\\n            }\\n            else if(instructions.at(s) == \\'R\\'){\\n                i = (i + 3) % 4;\\n            }\\n            else{\\n                x = x + dir[i][0];\\n                y = y + dir[i][1];\\n            }\\n        }\\n        return x == 0 && y == 0 || i != 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291221,
                "title": "python-o-n-time-o-1-space-beats-100-detailed-explanations",
                "content": "There are only two scenarios where the robot can come back to its original location:\\n1) the robot is already back to its origin by the end of the string traversal, and \\n2) the robot is away from the origin, but heading to a direction different from its initial direction. For example, if the robot is facing left by the end of the first string traversal, after three other traversals of left->left->left, it is back to the origin. A second example is that if the robot is facing down by the end of the first string traversal, it only takes another traversal for it to get back to the origin.\\n\\nAnother tip on how to change the directions. You actually do not need to keep a list of all possible directions [(0,1), (-1,0), (0,-1), (1,0)]. Just swap dx and dy and add a negative sign to one of it to rotate the direction by 90 degrees. The proof is that the dot product of (dx,dy) and (dy,-dx) is 0, meaning that these two vectors are perpendicular to each other. \\n```\\nclass Solution(object):\\n    def isRobotBounded(self, instructions):\\n        \"\"\"\\n        :type instructions: str\\n        :rtype: bool\\n        \"\"\"\\n        di = (0,1)\\n        x,y = 0,0\\n        for instruction in instructions:\\n            if instruction == \\'G\\':\\n                x,y = x+di[0],y+di[1]\\n            elif instruction == \\'L\\':\\n                di = (-di[1],di[0])\\n            else:\\n                di = (di[1],-di[0])\\n            \\n        return (x==0 and y==0) or di!=(0,1)\\n```\\n            \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isRobotBounded(self, instructions):\\n        \"\"\"\\n        :type instructions: str\\n        :rtype: bool\\n        \"\"\"\\n        di = (0,1)\\n        x,y = 0,0\\n        for instruction in instructions:\\n            if instruction == \\'G\\':\\n                x,y = x+di[0],y+di[1]\\n            elif instruction == \\'L\\':\\n                di = (-di[1],di[0])\\n            else:\\n                di = (di[1],-di[0])\\n            \\n        return (x==0 and y==0) or di!=(0,1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677199,
                "title": "c-easy-to-solve-beginner-friendly-with-detailed-explanation-and-dry-run",
                "content": "**Reframing of question :-**\\nThere is a robo who stands at (0,0) and faces north . The robo has three functionalities \\n1. \"G\" =>go straight 1 unit.\\n2. \"L\" =>turn 90 degrees to left.\\n3. \"R\"=>turn 90 degrees to right.\\n\\n**@@A very imp note:-** *The robot performs the instructions given in order, and repeats them forever.*\\nReturn true if the robo comes back to his original position after executing the instructions else return false .\\n***\\n**Intuition:-**\\nThe intuition we can get from question is that if the robo comes back to origin we return true and if not than return false . Let\\'s understand more from the below examples :)\\n***\\n\\n**Now let\\'s take some example dry runs :-**\\nSorry for the bad drawing btw you should also try this dry runs it will help you a lot .\\n![image](https://assets.leetcode.com/users/images/8737467c-8711-4012-b769-37ee68e5dd7b_1641706847.1176744.jpeg)\\n![image](https://assets.leetcode.com/users/images/ef864c3a-070f-4d27-9736-523061d52684_1641706848.979658.jpeg)\\n\\n*From the above dry runs we can conclude that:-*\\n* If the robo comes back to origin the answer is true.\\n* If the robo is facing NORTH direction the answer is always false since we are drifting away from origin.\\n* If the robo is facing any direction except north the answer will be  true since it will became a loop and come back to origin\\n***\\n**Algorithm:-**\\n1. Let `x` and `y` be the co-ordinate points and the ongoing direction that robo depicts be as `current_dir` . Let the 4 directions be North `N`, South `S`, West `W`, EAST `E` . Let current instruction char be depicted by `incoming` .\\n2. After initialization we will create a `originVerifier`  function to chek whether the co-ordinates are origin or not\\n3. We need to loop the `instructions` . During the treaversing of string `instructions ` we have two cases \\n* **1st case:-** If we get `G` as instuction than we need to go straight 1 unit in that current direction\\n* **2nd case:-** In this case there is a chance that we will face directions  `N`, `S`, `W`, `E`. Once we find any of this direction just replace the currrent direction with this direction . \\n4. Now if the robo is at origin or the current direction is not north than return trueor else reutn false [Discussed during dry run\\n***\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    //returns true if the co-ordinates are at origin\\n    bool originVerifier(int x,int y){\\n        if(x == 0 && y == 0)\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n    }\\n\\t\\n    bool isRobotBounded(string instructions) {\\n        //given\\n        char current_dir = \\'N\\';\\n        //co-ordinate points\\n        int x = 0, y= 0;\\n        for(int i=0;i<instructions.length();i++){ \\n            //Case1: If \\'G\\' is in the instruction string\\n            if(instructions[i] == \\'G\\'){\\n                y += current_dir ==\\'N\\' ? 1 : 0;\\n\\t\\t\\t\\ty += current_dir ==\\'S\\' ? -1 : 0;\\n\\t\\t\\t\\tx += current_dir == \\'E\\' ? 1 : 0;\\n\\t\\t\\t\\tx += current_dir == \\'W\\' ? -1 : 0;\\n            }\\n            //case2: If we found \\'directions\\'\\n            else{\\n                char incoming = instructions[i];\\n                if(current_dir == \\'N\\'){\\n                    current_dir = incoming == \\'L\\' ? \\'W\\' : \\'E\\';\\n                }\\n                else if(current_dir == \\'W\\'){\\n                    current_dir = incoming == \\'L\\' ? \\'S\\' : \\'N\\';\\n                }\\n                else if(current_dir == \\'S\\'){\\n                    current_dir = incoming == \\'L\\' ? \\'E\\' : \\'W\\';\\n                }\\n                else{\\n                    current_dir = incoming == \\'L\\' ? \\'N\\' : \\'S\\';\\n                }\\n            } \\n            \\n        }\\n        //if the robo is at origin or the current direction is not north than return true\\n        if(originVerifier(x,y) || current_dir!=\\'N\\')\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```\\n***\\nActually there is one more way to solve this and while i was trying to figure out a good explanation for that, came across this beautiful post so linking his post is the best way to give him credits ;)\\n**2nd Well optimized approach by @SVishal19 :-**\\nhttps://leetcode.com/problems/robot-bounded-in-circle/discuss/1680010/detailed-explanation-cpp-thought-process\\n***\\n\\n**[My Github Repo](https://github.com/Jatin-Shihora/LeetCode-Solutions) where I keep track of my solutions :)))**\\n\\n***\\n***\\n**If you have some doubts feel free to bug me anytime or If you understood than don\\'t forget to upvote ;)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //returns true if the co-ordinates are at origin\\n    bool originVerifier(int x,int y){\\n        if(x == 0 && y == 0)\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n    }\\n\\t\\n    bool isRobotBounded(string instructions) {\\n        //given\\n        char current_dir = \\'N\\';\\n        //co-ordinate points\\n        int x = 0, y= 0;\\n        for(int i=0;i<instructions.length();i++){ \\n            //Case1: If \\'G\\' is in the instruction string\\n            if(instructions[i] == \\'G\\'){\\n                y += current_dir ==\\'N\\' ? 1 : 0;\\n\\t\\t\\t\\ty += current_dir ==\\'S\\' ? -1 : 0;\\n\\t\\t\\t\\tx += current_dir == \\'E\\' ? 1 : 0;\\n\\t\\t\\t\\tx += current_dir == \\'W\\' ? -1 : 0;\\n            }\\n            //case2: If we found \\'directions\\'\\n            else{\\n                char incoming = instructions[i];\\n                if(current_dir == \\'N\\'){\\n                    current_dir = incoming == \\'L\\' ? \\'W\\' : \\'E\\';\\n                }\\n                else if(current_dir == \\'W\\'){\\n                    current_dir = incoming == \\'L\\' ? \\'S\\' : \\'N\\';\\n                }\\n                else if(current_dir == \\'S\\'){\\n                    current_dir = incoming == \\'L\\' ? \\'E\\' : \\'W\\';\\n                }\\n                else{\\n                    current_dir = incoming == \\'L\\' ? \\'N\\' : \\'S\\';\\n                }\\n            } \\n            \\n        }\\n        //if the robo is at origin or the current direction is not north than return true\\n        if(originVerifier(x,y) || current_dir!=\\'N\\')\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290859,
                "title": "java-solution-clear-explanation",
                "content": "First of all, this isn\\'t an easy question. I thought hard about this one. there are two things I found important. One, if you end up where you started, it is a circle. Two, if you end up in a different place with facing north (again), hence you are drifting away. All other scenarios are going to be in a circle (or come back) in infinity no matter. You can think that the starting and the end point form a vector. Unless the end direction is north, concataned vectors will always end up on the starting point eventually (infinity). \\n\\n```\\n    public boolean isRobotBounded(String instructions) {\\n        int[] cur = new int[] {0, 0};\\n        int[][] dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        int dir = 0; // 0:north(up), 1: right, 2: down, 3: left\\n        \\n        for (char in : instructions.toCharArray()) {\\n            if (in == \\'G\\') {\\n                cur[0] += dirs[dir][0];\\n                cur[1] += dirs[dir][1];\\n            } else if (in == \\'L\\') {\\n                dir = (dir + 3) % 4;\\n            } else {\\n                dir = (dir + 1) % 4;\\n            }\\n        }\\n        if (cur[0] == 0 && cur[1] == 0) { // ended up at the same place\\n            return true;\\n        }\\n        if (dir == 0 && !(cur[0] == 0 && cur[1] == 0)) { // if the direction is north and location has changed\\n            return false;\\n        }\\n        return true; // it is always true\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isRobotBounded(String instructions) {\\n        int[] cur = new int[] {0, 0};\\n        int[][] dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        int dir = 0; // 0:north(up), 1: right, 2: down, 3: left\\n        \\n        for (char in : instructions.toCharArray()) {\\n            if (in == \\'G\\') {\\n                cur[0] += dirs[dir][0];\\n                cur[1] += dirs[dir][1];\\n            } else if (in == \\'L\\') {\\n                dir = (dir + 3) % 4;\\n            } else {\\n                dir = (dir + 1) % 4;\\n            }\\n        }\\n        if (cur[0] == 0 && cur[1] == 0) { // ended up at the same place\\n            return true;\\n        }\\n        if (dir == 0 && !(cur[0] == 0 && cur[1] == 0)) { // if the direction is north and location has changed\\n            return false;\\n        }\\n        return true; // it is always true\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850437,
                "title": "python-o-n-solution-explained",
                "content": "Let `dx, dy` be directions of our robot and `x,y` be its coordinates. Then using linear algepra we can say that if we rotate to the left, then `dx, dy = -dy, dx`, similar if we rotate to the right. So, now we can easily follow the place of our robot. How to understand if his path will be bounded by some circle? We need to understand if he is going to loop. There are `3` possible options where path will be bounded.\\n1. In the end it will arrive to the starting position.\\n2. It will not arrive to the starting position and his orientation is rotated to the left or to the right. Then it can be shown easily that after `4` loops robot will return to the original place.\\n3. It will not arrive to the start and his orientation is opposite, then after `2` loops he will arrive at the starting place.\\n\\nSo, let us just check that after `4` times we traverse our `instructions` robot will be at the start, that is all!\\n\\n**Complexity**: Time complexity is `O(4n)`, space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions):\\n        dx, dy, x, y = 0, 1, 0, 0\\n        for l in 4*instructions:\\n            if l == \"G\": \\n                x, y = x+dx, y+dy\\n            elif l == \"L\":\\n                dx, dy = -dy, dx\\n            else:\\n                dx, dy = dy, -dx\\n                \\n        return (x,y) == (0,0)\\n```\\n\\n**PS** I realized that we do not really need to traverse `instructions` 4 times, we can just return `(x,y) == 0 or (dx, dy) != (0,1)`, but this solution was already provided by others, so I left my solution as it is.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions):\\n        dx, dy, x, y = 0, 1, 0, 0\\n        for l in 4*instructions:\\n            if l == \"G\": \\n                x, y = x+dx, y+dy\\n            elif l == \"L\":\\n                dx, dy = -dy, dx\\n            else:\\n                dx, dy = dy, -dx\\n                \\n        return (x,y) == (0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731267,
                "title": "easy-java-accepted-solution",
                "content": "i=0, j=0, dir=1 starting position.\\ndir can be 1 = North, 2 = East, 3 = South, 4 = West.\\n```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        \\n        int i=0;\\n        int j=0;\\n        int dir=1;\\n        \\n        for(char c : instructions.toCharArray()){  // Loop through to follow every instruction\\n            \\n            if(c == \\'G\\'){\\n                if(dir == 1) j++;  //if direction is north, move forward\\n                else if(dir == 2) i++;  //if direction is East, move right\\n                else if(dir == 3) j--;  //if direction is South, move downward\\n                else i--;  //if direction is west, move West\\n            }\\n            else if(c == \\'L\\'){  // if asked to turn left\\n                dir = dir == 1 ? 4 : dir-1; // subtract 1 from current direction to turn left, if  dir == 1 i.e. North, we need to turn towards west i.e. 4\\n            }\\n            else if(c == \\'R\\'){ // if asked to turn right\\n                dir = dir == 4 ? 1 : dir+1;  // add 1 from current direction to turn right, if  dir == 4 i.e. West, we need to turn towards North i.e. 1\\n            }\\n            \\n        }\\n        \\n        return i == 0 && j == 0 || dir > 1;   // check the current position and direction and decide\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        \\n        int i=0;\\n        int j=0;\\n        int dir=1;\\n        \\n        for(char c : instructions.toCharArray()){  // Loop through to follow every instruction\\n            \\n            if(c == \\'G\\'){\\n                if(dir == 1) j++;  //if direction is north, move forward\\n                else if(dir == 2) i++;  //if direction is East, move right\\n                else if(dir == 3) j--;  //if direction is South, move downward\\n                else i--;  //if direction is west, move West\\n            }\\n            else if(c == \\'L\\'){  // if asked to turn left\\n                dir = dir == 1 ? 4 : dir-1; // subtract 1 from current direction to turn left, if  dir == 1 i.e. North, we need to turn towards west i.e. 4\\n            }\\n            else if(c == \\'R\\'){ // if asked to turn right\\n                dir = dir == 4 ? 1 : dir+1;  // add 1 from current direction to turn right, if  dir == 4 i.e. West, we need to turn towards North i.e. 1\\n            }\\n            \\n        }\\n        \\n        return i == 0 && j == 0 || dir > 1;   // check the current position and direction and decide\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850634,
                "title": "python-simple-fastest-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=xgJh5HPCi3A)\\nhttps://www.youtube.com/watch?v=xgJh5HPCi3A\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        direction = (0,1)\\n        start = [0,0]\\n        \\n        for x in instructions:\\n            if x == \\'G\\':\\n                start[0] += direction[0]\\n                start[1] += direction[1]\\n            elif x == \\'L\\':\\n                direction = (-direction[1], direction[0])\\n            elif x == \\'R\\':\\n                direction = (direction[1], -direction[0])\\n        \\n        return start == [0,0] or direction != (0,1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        direction = (0,1)\\n        start = [0,0]\\n        \\n        for x in instructions:\\n            if x == \\'G\\':\\n                start[0] += direction[0]\\n                start[1] += direction[1]\\n            elif x == \\'L\\':\\n                direction = (-direction[1], direction[0])\\n            elif x == \\'R\\':\\n                direction = (direction[1], -direction[0])\\n        \\n        return start == [0,0] or direction != (0,1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851232,
                "title": "easy-direction-wise-c-soution-beats-100",
                "content": "Think by placing yourself at origin.\\nTwo cases arise after the an iteration :\\n1. You end up back at origin.\\n2. You end up somewhere else.\\n\\n**Case 1.**\\nIf you are at origin, answer is true.\\n**Case 2.**\\n1. **Case 2(i) :** You are facing **NORTH** -  Answer is false.\\n2. **Case2(ii) :** You are **Not facing NORTH** - Answer is true.\\n\\n``` \\nclass Solution {\\npublic:\\n    \\n    bool check_origin(unordered_map<char,int> map){\\n        \\n        if(map[\\'N\\'] == map[\\'S\\'] && map[\\'E\\'] == map[\\'W\\'])\\n            return true;\\n        return false;\\n    }\\n\\t\\n    bool isRobotBounded(string instructions) {\\n        \\n        char curr_dir = \\'N\\';\\n    \\n        unordered_map<char,int> map;\\n        \\n        for(int i=0;i<instructions.length();i++){ \\n            if(instructions[i] == \\'G\\'){\\n                map[curr_dir]++;\\n            }\\n            else{\\n                char incoming = instructions[i];\\n                if(curr_dir == \\'N\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'W\\' : \\'E\\';\\n                }\\n                else if(curr_dir == \\'W\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'S\\' : \\'N\\';\\n                }\\n                else if(curr_dir == \\'S\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'E\\' : \\'W\\';\\n                }\\n                else{\\n                    curr_dir = incoming == \\'L\\' ? \\'N\\' : \\'S\\';\\n                }\\n            } \\n            \\n        }\\n        if(check_origin(map) || curr_dir!=\\'N\\')\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n\\n\\n```\\n\\n**EDIT - 1**\\nWe don\\'t need to keep a map to store the steps in every direction. We can do this just with the help of 2 variables.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool check_origin(int h,int v){\\n        if(h == 0 && v == 0)\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n    }\\n\\t\\n    bool isRobotBounded(string instructions) {\\n        \\n        char curr_dir = \\'N\\';\\n    \\n        //unordered_map<char,int> map;\\n        int vertical = 0, horizontal= 0;\\n        for(int i=0;i<instructions.length();i++){ \\n            if(instructions[i] == \\'G\\'){\\n                vertical += curr_dir ==\\'N\\' ? 1 : 0;\\n\\t\\t\\t\\tvertical += curr_dir ==\\'S\\' ? -1 : 0;\\n\\t\\t\\t\\thorizontal += curr_dir == \\'E\\' ? 1 : 0;\\n\\t\\t\\t\\thorizontal += curr_dir == \\'W\\' ? -1 : 0;\\n            }\\n            else{\\n                char incoming = instructions[i];\\n                if(curr_dir == \\'N\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'W\\' : \\'E\\';\\n                }\\n                else if(curr_dir == \\'W\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'S\\' : \\'N\\';\\n                }\\n                else if(curr_dir == \\'S\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'E\\' : \\'W\\';\\n                }\\n                else{\\n                    curr_dir = incoming == \\'L\\' ? \\'N\\' : \\'S\\';\\n                }\\n            } \\n            \\n        }\\n        if(check_origin(horizontal,vertical) || curr_dir!=\\'N\\')\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "``` \\nclass Solution {\\npublic:\\n    \\n    bool check_origin(unordered_map<char,int> map){\\n        \\n        if(map[\\'N\\'] == map[\\'S\\'] && map[\\'E\\'] == map[\\'W\\'])\\n            return true;\\n        return false;\\n    }\\n\\t\\n    bool isRobotBounded(string instructions) {\\n        \\n        char curr_dir = \\'N\\';\\n    \\n        unordered_map<char,int> map;\\n        \\n        for(int i=0;i<instructions.length();i++){ \\n            if(instructions[i] == \\'G\\'){\\n                map[curr_dir]++;\\n            }\\n            else{\\n                char incoming = instructions[i];\\n                if(curr_dir == \\'N\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'W\\' : \\'E\\';\\n                }\\n                else if(curr_dir == \\'W\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'S\\' : \\'N\\';\\n                }\\n                else if(curr_dir == \\'S\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'E\\' : \\'W\\';\\n                }\\n                else{\\n                    curr_dir = incoming == \\'L\\' ? \\'N\\' : \\'S\\';\\n                }\\n            } \\n            \\n        }\\n        if(check_origin(map) || curr_dir!=\\'N\\')\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool check_origin(int h,int v){\\n        if(h == 0 && v == 0)\\n\\t\\t\\treturn true;\\n\\t\\treturn false;\\n    }\\n\\t\\n    bool isRobotBounded(string instructions) {\\n        \\n        char curr_dir = \\'N\\';\\n    \\n        //unordered_map<char,int> map;\\n        int vertical = 0, horizontal= 0;\\n        for(int i=0;i<instructions.length();i++){ \\n            if(instructions[i] == \\'G\\'){\\n                vertical += curr_dir ==\\'N\\' ? 1 : 0;\\n\\t\\t\\t\\tvertical += curr_dir ==\\'S\\' ? -1 : 0;\\n\\t\\t\\t\\thorizontal += curr_dir == \\'E\\' ? 1 : 0;\\n\\t\\t\\t\\thorizontal += curr_dir == \\'W\\' ? -1 : 0;\\n            }\\n            else{\\n                char incoming = instructions[i];\\n                if(curr_dir == \\'N\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'W\\' : \\'E\\';\\n                }\\n                else if(curr_dir == \\'W\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'S\\' : \\'N\\';\\n                }\\n                else if(curr_dir == \\'S\\'){\\n                    curr_dir = incoming == \\'L\\' ? \\'E\\' : \\'W\\';\\n                }\\n                else{\\n                    curr_dir = incoming == \\'L\\' ? \\'N\\' : \\'S\\';\\n                }\\n            } \\n            \\n        }\\n        if(check_origin(horizontal,vertical) || curr_dir!=\\'N\\')\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677124,
                "title": "c-python-java-simple-one-pass-simulation-100-faster",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n* After One-Pass simulation, we can easily get the direction `di` and the position `(x, y)` at last.\\n* 4 possible cases\\n\\t*  `x == 0 and y == 0`, certainly `return True`\\n\\t* `di == 2`, the robot reversed direction, after going through all the instructions **once again, robot comes back to (0, 0)**\\n\\t* `di == 1 or di == 3`, the robot turns left or right, after going through all the instructions **3 times again, robot comes back to (0, 0)**\\n\\t* `di == 0 and not (x == 0 and y == 0)`, the robot moved in one direction and **never came back**.\\n\\n\\n**Python**\\n```\\n#  Runtime: 8 ms, faster than 99.64%\\nclass Solution(object):\\n    def isRobotBounded(self, I):\\n        d = [[1, 0], [0, 1], [-1, 0], [0, -1]]\\n        di = x = y = 0\\n        for i in I:\\n            if i == \\'L\\': di = (di + 1) % 4\\n            elif i == \\'R\\': di = (di - 1) % 4\\n            else: x, y = x + d[di][0], y + d[di][1]\\n        if x == 0 and y == 0 or di > 0: return True\\n        return False\\n```\\n\\n**C++**\\n```\\n// Runtime: 0 ms, faster than 100.00%\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string I) {\\n        int d[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        int di = 0, x = 0, y = 0;\\n        \\n        for (int i = 0; i < I.size(); i ++) {\\n            switch (I[i])\\n            {\\n                case \\'L\\': \\n                    di = (di + 1) % 4; \\n                    break;\\n                case \\'R\\': \\n                    di = (di + 3) % 4;\\n                    break;\\n                default:\\n                    x = x + d[di][0];\\n                    y = y + d[di][1];\\n            }\\n        }\\n        if (x == 0 && y == 0 || di > 0)\\n            return true;\\n        return false;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\n// Runtime: 0 ms, faster than 100.00%\\nclass Solution {\\n    public boolean isRobotBounded(String I) {\\n        int[][] d = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        int di = 0, x = 0, y = 0;\\n        \\n        for (int i = 0; i < I.length(); i ++) {\\n            switch (I.charAt(i))\\n            {\\n                case \\'L\\': \\n                    di = (di + 1) % 4; \\n                    break;\\n                case \\'R\\': \\n                    di = (di + 3) % 4;\\n                    break;\\n                default:\\n                    x = x + d[di][0];\\n                    y = y + d[di][1];\\n            }\\n        }\\n        if (x == 0 && y == 0 || di > 0)\\n            return true;\\n        return false;\\n    }\\n}\\n```\\n\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n#  Runtime: 8 ms, faster than 99.64%\\nclass Solution(object):\\n    def isRobotBounded(self, I):\\n        d = [[1, 0], [0, 1], [-1, 0], [0, -1]]\\n        di = x = y = 0\\n        for i in I:\\n            if i == \\'L\\': di = (di + 1) % 4\\n            elif i == \\'R\\': di = (di - 1) % 4\\n            else: x, y = x + d[di][0], y + d[di][1]\\n        if x == 0 and y == 0 or di > 0: return True\\n        return False\\n```\n```\\n// Runtime: 0 ms, faster than 100.00%\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string I) {\\n        int d[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        int di = 0, x = 0, y = 0;\\n        \\n        for (int i = 0; i < I.size(); i ++) {\\n            switch (I[i])\\n            {\\n                case \\'L\\': \\n                    di = (di + 1) % 4; \\n                    break;\\n                case \\'R\\': \\n                    di = (di + 3) % 4;\\n                    break;\\n                default:\\n                    x = x + d[di][0];\\n                    y = y + d[di][1];\\n            }\\n        }\\n        if (x == 0 && y == 0 || di > 0)\\n            return true;\\n        return false;\\n    }\\n};\\n```\n```\\n// Runtime: 0 ms, faster than 100.00%\\nclass Solution {\\n    public boolean isRobotBounded(String I) {\\n        int[][] d = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        int di = 0, x = 0, y = 0;\\n        \\n        for (int i = 0; i < I.length(); i ++) {\\n            switch (I.charAt(i))\\n            {\\n                case \\'L\\': \\n                    di = (di + 1) % 4; \\n                    break;\\n                case \\'R\\': \\n                    di = (di + 3) % 4;\\n                    break;\\n                default:\\n                    x = x + d[di][0];\\n                    y = y + d[di][1];\\n            }\\n        }\\n        if (x == 0 && y == 0 || di > 0)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290915,
                "title": "python-concise-explanation",
                "content": "In order for the robot to stay within a circle, you need to move in a cycle. The only way you move in a cycle is if you end where you start (the origin at (0, 0)). \\n\\nThe minimum number of instructions you need to repeat is 4 in order to figure out if you\\'re in a cycle.  \\n\\nFor example, if each instruction only rotates 90 degrees, you need to repeat the instructions 4 times to possibly end where you start. \\nIf each instruction rotates 180 degrees, you need to repeat the instructions 2 times to possibly end where you start. \\nIf each instruction rotates 270 degrees, you need to repeat the instruction 4 times to possibly end where you start. \\n\\nIm the real word, you could stop the algo if you have repeated the instructions 2x and it ends on (0,0), but here it is still O(N).\\n\\n```\\nclass Solution(object):\\n    def isRobotBounded(self, instructions):\\n        \"\"\"\\n        :type instructions: str\\n        :rtype: bool\\n        \"\"\"\\n        #up, left, down, right\\n        dir, start, d = ([-1, 0], [0, -1], [1, 0], [0, 1]), [0,0], 0\\n        for i in range(4):\\n            for x in instructions:\\n                if x == \"G\":\\n                    start[0] += dir[d][0]\\n                    start[1] += dir[d][1]\\n                if x == \"L\": d = (d + 1) % 4 \\n                if x == \"R\": d = (d - 1) % 4\\n        return True if start == [0,0] else False \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isRobotBounded(self, instructions):\\n        \"\"\"\\n        :type instructions: str\\n        :rtype: bool\\n        \"\"\"\\n        #up, left, down, right\\n        dir, start, d = ([-1, 0], [0, -1], [1, 0], [0, 1]), [0,0], 0\\n        for i in range(4):\\n            for x in instructions:\\n                if x == \"G\":\\n                    start[0] += dir[d][0]\\n                    start[1] += dir[d][1]\\n                if x == \"L\": d = (d + 1) % 4 \\n                if x == \"R\": d = (d - 1) % 4\\n        return True if start == [0,0] else False \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680010,
                "title": "detailed-explanation-cpp-thought-process",
                "content": "**[Leetcode Question](https://leetcode.com/problems/robot-bounded-in-circle/)** \\n\\nWe have to find if we can make a circle on the infinite plane such that the robot only remains in the circle. So, we have to find where the robot is finishing after each simulation of the string. \\nNow, to figure out the final position of the robot after one simulation we have to find values which should be added to the current position of the robot depending on the direction the robot is facing.\\n\\nSo, on observation\\n\\n| Direction | Add | L | R |\\n| ----------|-----|---|---|\\n| North | (0, 1) | West | East |\\n| West  | (-1, 0) | South | North |\\n| East | (1, 0) | North | South |\\n| South | (0, -1) | East | West |\\n\\nSo, we can make use of the above direction matrix to add the correspoding x and y values in the current position and also to identify the final direction the robot is facing.\\n\\nSo, the key point is.... **Since we are simulating the same string infinite number of times, robot will be contrainted in the same area only when it keeps on rotating the same circular path i.e. after some k simulations of the string the robot should definitely come back to it\\'s original position i.e. (0, 0).**\\n\\n<span style=\"color: red\">**_So the conclusion comes out that - after one simulation the direction of the robot should be changed or if the direction does not change, then the robot should be at (0, 0), i.e. it did not move from it\\'s starting point or again came back to it\\'s starting point after one simulation._**<span>\\n\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string ins) {\\n        vector<pair<int, int>> direction{{1, 2}, {3, 0}, {0, 3}, {2, 1}};\\n        vector<pair<int, int>> addPoints{{0, 1}, {-1, 0}, {1, 0}, {0, -1}};\\n        \\n        if(count(ins.begin(), ins.end(), \\'G\\') == 0) {\\n            return true;\\n        }\\n        \\n        int x = 0, y = 0;\\n        int dir = 0;\\n        for(int i=0; i<ins.size(); i++) {\\n            if(ins[i] == \\'G\\') {\\n                x += addPoints[dir].first;\\n                y += addPoints[dir].second;\\n            } else {\\n                dir = ins[i] == \\'L\\' ? direction[dir].first : direction[dir].second;\\n            }\\n        }\\n        \\n        if((dir != 0) || (x == 0 && y == 0)) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n### A more better way of handling directions\\n----------\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string ins) {\\n        vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n                \\n        int dir = 0;\\n        int x = 0, y = 0;\\n        for(int i=0; i<ins.size(); i++) {\\n            if(ins[i] == \\'G\\') {\\n                x += directions[dir][0];\\n                y += directions[dir][1];\\n            } else {\\n                dir = ins[i] == \\'L\\' ? (dir - 1 + 4)%4 : (dir +1)%4;\\n            }\\n        }\\n        \\n        return (dir != 0) || (x == 0 && y == 0);\\n    }\\n};\\n```\\n\\n### How is the directions working?\\n```\\ni = (i+1) % 4 will turn right\\ni = (i+3) % 4 will turn left\\n```\\n\\nIt\\'s actually like this, we store the directions in an array like this\\n\\n`vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}` \\n\\nIt is basically `[\\'N\\', \\'E\\', \\'S\\', \\'W\\']` all the directions in clockwise directions.\\n\\nNow the initial direction is North i.e. 0, let\\'s save this in the variable i\\nso initially `i = 0`\\n\\nNow, when the robot turns left i.e. we are moving in an anticlockwise direction, our next direction will be west. Since we are storing the directions in a clockwise manner we need to decrement the i value by 1, but the catch is while decrementing i can become negative. \\n\\nFor eg: `i = 0 and then we turn left so i = i - 1 which gives i = -1, turning left when we are facing north results into west direction so to maintain the indexing we do the addition of 4.`\\n\\nSo, final expression becomes `i = (i-1 + 4)%4 = (i+3)%4`\\n\\nThe same thing happens when we turn right, turning right is clockwise so we do increment by 1\\n `i = (i+1)%4` we do a modulo here because after \\'W\\' we will again face \\'N\\' again.\\n\\n\\n**If the post helped you, then please consider up voting. Happy Coding :)**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string ins) {\\n        vector<pair<int, int>> direction{{1, 2}, {3, 0}, {0, 3}, {2, 1}};\\n        vector<pair<int, int>> addPoints{{0, 1}, {-1, 0}, {1, 0}, {0, -1}};\\n        \\n        if(count(ins.begin(), ins.end(), \\'G\\') == 0) {\\n            return true;\\n        }\\n        \\n        int x = 0, y = 0;\\n        int dir = 0;\\n        for(int i=0; i<ins.size(); i++) {\\n            if(ins[i] == \\'G\\') {\\n                x += addPoints[dir].first;\\n                y += addPoints[dir].second;\\n            } else {\\n                dir = ins[i] == \\'L\\' ? direction[dir].first : direction[dir].second;\\n            }\\n        }\\n        \\n        if((dir != 0) || (x == 0 && y == 0)) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string ins) {\\n        vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n                \\n        int dir = 0;\\n        int x = 0, y = 0;\\n        for(int i=0; i<ins.size(); i++) {\\n            if(ins[i] == \\'G\\') {\\n                x += directions[dir][0];\\n                y += directions[dir][1];\\n            } else {\\n                dir = ins[i] == \\'L\\' ? (dir - 1 + 4)%4 : (dir +1)%4;\\n            }\\n        }\\n        \\n        return (dir != 0) || (x == 0 && y == 0);\\n    }\\n};\\n```\n```\\ni = (i+1) % 4 will turn right\\ni = (i+3) % 4 will turn left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678306,
                "title": "well-explained-linear-solution-1-loop-javascript-python-typescript-o-n-time-o-1-space",
                "content": "There are only two ways the robot can come back to its original location:\\n 1. The robot completed all the provided operations and made a loop in one iteration.\\n 2. The robot is not on the origin spot, but heading to any direction different from its initial direction (North). \\n  ***It can complete 1 or 3 additional iterations over the provided operations to make a loop.***\\n\\n\\tLet\\'s look at some examples to make it clear.\\n\\tI drew some paths the robot could face with and:\\n\\t* can make a loop in 4 iterations `\"GGRG\"`\\n\\t* can make a loop in 1 iteration (gets back to the origin) `\"GLGLGLG\"`\\n\\t  *You might see it heads to a different direction and will go through a different path on the next iteration, but it\\'s still a loop*\\n\\t * can make a loop in 2 iterations `\"GGRGR\"`\\n\\t * can\\'t make a loop `\"GGRGL\"`\\n\\n\\n\\t![image](https://assets.leetcode.com/users/images/e70ca499-df6e-4c69-a595-4c16874540ac_1641736376.2303495.png)\\n\\n\\t**Explanation**\\n\\t\\n\\t`x, y` is a set of coordinates\\n\\t`dirs` for all possible direction\\n\\t`[[0, 1], [1, 0], [0, -1], [-1, 0]]`\\n\\t` --^up  ---^right --^down --  ^left `\\n\\n\\t**We can change the direction by using mod operaor:**\\n\\t\\n\\t*On the left turn:*\\n\\t`currentDirectionIndex\\t= (4 + currentDirectionIndex - 1)  %  4`\\n\\t*On the right turn:*\\n\\t`currentDirectionIndex\\t= (4 + currentDirectionIndex + 1)  %  4`\\n\\t\\n\\t**Note that we have to add 4 to get a positive value (but we can simply omit this addition in python language)**\\n\\twhere 4 is the lenght of all possible directions array\\n\\tcurrentDirectionIndex has a default direction 0 (Up) and might take a value of 0, 1 ,2 or 3 (Up, Right, Down, Left respectively)\\n\\t\\n\\t**Complexity** \\n\\t\\n\\tTime `O(N)`\\n\\tSpace `O(1)`\\n\\t\\n\\n\\n\\t### \\tIf you have any doubts feel free to reach me down in the comments section or If you liked my explanation don\\'t forget to *upvote* \\uD83C\\uDF7B\\n\\n\\t\\n\\t**JavaScript**\\n\\t```\\n\\tfunction isRobotBounded(instructions) {\\n\\t\\tconst dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n\\t\\tlet head = 0;\\n\\t\\tlet x = 0;\\n\\t\\tlet y = 0;\\n\\t\\t\\n\\t\\tfor (const instruction of instructions) { \\n\\t\\t\\tif (instruction === \\'G\\') {\\n\\t\\t\\t\\tx = x + dirs[head][0];\\n\\t\\t\\t\\ty = y + dirs[head][1];\\n\\t\\t\\t} else if (instruction === \\'L\\') {\\n\\t\\t\\t\\thead = (4 + head - 1) % 4;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thead = (4 + head + 1) % 4;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tconst isAtOrigin = (x === 0 && y === 0);\\n\\t\\tconst isHeadingNorth = head === 0\\n\\n\\t\\treturn isAtOrigin || (! isHeadingNorth);\\n\\t};\\n\\t```\\n\\t\\n\\t**Python**\\n\\t```\\n\\tdef isRobotBounded(self, instructions):\\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        x, y = 0,0\\n\\t\\thead = 0\\n        for instruction in instructions:\\n            if instruction == \\'G\\':\\n                x, y = x + dirs[head][0], y + dirs[head][1]\\n            elif instruction == \\'L\\':\\n                head =  (4 + head - 1) % 4\\n            else:\\n\\t\\t\\t\\thead =  (4 + head + 1) % 4\\n\\t\\t\\t\\t\\n\\t\\tisHeadingNorth = head == 0\\n\\t\\tisAtOrigin = (x == 0 and y == 0)\\n            \\n        return isAtOrigin or (not isHeadingNorth)\\n\\t```\\n\\t\\n\\t**TypeScript**\\n\\t```\\n\\tfunction isRobotBounded(instructions: string): boolean {\\n\\t\\tconst dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n\\t\\tlet head = 0;\\n\\t\\tlet x = 0;\\n\\t\\tlet y = 0;\\n\\t\\t\\n\\t\\tfor (const instruction of instructions) { \\n\\t\\t\\tif (instruction === \\'G\\') {\\n\\t\\t\\t\\tx = x + dirs[head][0];\\n\\t\\t\\t\\ty = y + dirs[head][1];\\n\\t\\t\\t} else if (instruction === \\'L\\') {\\n\\t\\t\\t\\thead = (4 + head - 1) % 4;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thead = (4 + head + 1) % 4;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tconst isAtOrigin = (x === 0 && y === 0);\\n\\t\\tconst isHeadingNorth = head === 0\\n\\n\\t\\treturn isAtOrigin || (! isHeadingNorth);\\n\\t};\\n\\t```\\n\\t\\n\\n",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n\\tfunction isRobotBounded(instructions) {\\n\\t\\tconst dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n\\t\\tlet head = 0;\\n\\t\\tlet x = 0;\\n\\t\\tlet y = 0;\\n\\t\\t\\n\\t\\tfor (const instruction of instructions) { \\n\\t\\t\\tif (instruction === \\'G\\') {\\n\\t\\t\\t\\tx = x + dirs[head][0];\\n\\t\\t\\t\\ty = y + dirs[head][1];\\n\\t\\t\\t} else if (instruction === \\'L\\') {\\n\\t\\t\\t\\thead = (4 + head - 1) % 4;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thead = (4 + head + 1) % 4;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tconst isAtOrigin = (x === 0 && y === 0);\\n\\t\\tconst isHeadingNorth = head === 0\\n\\n\\t\\treturn isAtOrigin || (! isHeadingNorth);\\n\\t};\\n\\t```\n```\\n\\tdef isRobotBounded(self, instructions):\\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        x, y = 0,0\\n\\t\\thead = 0\\n        for instruction in instructions:\\n            if instruction == \\'G\\':\\n                x, y = x + dirs[head][0], y + dirs[head][1]\\n            elif instruction == \\'L\\':\\n                head =  (4 + head - 1) % 4\\n            else:\\n\\t\\t\\t\\thead =  (4 + head + 1) % 4\\n\\t\\t\\t\\t\\n\\t\\tisHeadingNorth = head == 0\\n\\t\\tisAtOrigin = (x == 0 and y == 0)\\n            \\n        return isAtOrigin or (not isHeadingNorth)\\n\\t```\n```\\n\\tfunction isRobotBounded(instructions: string): boolean {\\n\\t\\tconst dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n\\t\\tlet head = 0;\\n\\t\\tlet x = 0;\\n\\t\\tlet y = 0;\\n\\t\\t\\n\\t\\tfor (const instruction of instructions) { \\n\\t\\t\\tif (instruction === \\'G\\') {\\n\\t\\t\\t\\tx = x + dirs[head][0];\\n\\t\\t\\t\\ty = y + dirs[head][1];\\n\\t\\t\\t} else if (instruction === \\'L\\') {\\n\\t\\t\\t\\thead = (4 + head - 1) % 4;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thead = (4 + head + 1) % 4;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tconst isAtOrigin = (x === 0 && y === 0);\\n\\t\\tconst isHeadingNorth = head === 0\\n\\n\\t\\treturn isAtOrigin || (! isHeadingNorth);\\n\\t};\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 853248,
                "title": "explained-in-detail-java-o-n-beats-100-0ms-runtime",
                "content": "Intution: \\n1) The robot faces north initially at coordinates (0,0). So after 1 iteration if you come back to the same coordinate (0,0) with direction as North then it will definitely form a loop. Example: GRGRGRGR.\\n\\n2) What if you came back to (0,0) but your position is not North, you\\'ll still come back to the initial coordinates after 4 iterations. Hence you\\'ll always be in a circle. For example in **GRGRGRG**, Since you\\'re always turning Right\\n\\n     i) You\\'ll face West after 1st iteration . \\n              (0,1) N, (1,1) E, (1,0) S, (0,0) W.\\n\\n    ii) You\\'ll face South after 2nd iteration.\\n\\t         (-1,0) W, (-1,1) N, (0,1) E, (0,0) S.\\n\\n    iii) You\\'ll face East after 3rd iteration.\\n              (0,-1) S, (-1,-1) W, (-1,0) N, (0,0) E.\\n\\n    iv) You\\'ll face North after 4th iteration.\\n             (1,0) E, (1,-1) S, (0,-1) W, (0,0) N.\\n\\n3) What if you don\\'t end up at (0,0) and you\\'re position is not North. You\\'ll still be inside the same circle since you\\'ll change direction after every iteration. For example if you end with direction left and face West , then in next iteration you\\'ll end at South, next East , next North and so on.\\n\\n\\n```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n       int x=0, y=0, direction = 0;\\n\\n//          N 0\\n//     W 3       E 1\\n//          S 2\\n    \\n        \\n        for(char ch : instructions.toCharArray()){\\n            if(ch == \\'G\\'){         \\n                switch (direction){\\n                case 0: y++; break;\\n                case 1: x++; break;\\n                case 2: y--; break;\\n                case 3: x--; break;\\n                }\\n               \\n            }else if(ch == \\'L\\'){\\n                direction = direction == 0 ? 3 : (direction-1);\\n                \\n            }else if(ch == \\'R\\'){\\n                direction = (direction + 1)%4;\\n            }\\n        }\\n        if(direction!= 0 || (x == 0 && y == 0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nPlease upvote if you like the solution.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n       int x=0, y=0, direction = 0;\\n\\n//          N 0\\n//     W 3       E 1\\n//          S 2\\n    \\n        \\n        for(char ch : instructions.toCharArray()){\\n            if(ch == \\'G\\'){         \\n                switch (direction){\\n                case 0: y++; break;\\n                case 1: x++; break;\\n                case 2: y--; break;\\n                case 3: x--; break;\\n                }\\n               \\n            }else if(ch == \\'L\\'){\\n                direction = direction == 0 ? 3 : (direction-1);\\n                \\n            }else if(ch == \\'R\\'){\\n                direction = (direction + 1)%4;\\n            }\\n        }\\n        if(direction!= 0 || (x == 0 && y == 0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229659,
                "title": "js-solution-w-explanation",
                "content": "```\\n/*\\nIf robot (1) comes back to origin OR (2) faces the north after instructions, the robot is in a circle.\\nTurn right -> i = (i + 1) mod 4, where DIRECTIONS[i] is the direction robot is facing\\nTurn left -> i = (i + 3) mod 4, DIRECTIONS[i] is the direction robot is facing\\n\\nKey points:\\n1. Don\\'t think about middle operations. Think about the start and the end only. We start at (0,0) and\\nend at (x,y). (a) If (x,y) is origin, we\\'ve come back to the origin. No matter where we end up facing, we\\'ll\\nalways come back to origin if we start at origin. (b) If (x,y) is not origin and robot is facing the north,\\nas we repeat instructions, robot will go to (2x,2y), (3x,3y) and so on. Hence, it is NOT in a circle. (c) If (x,y) is not origin and robot is facing a direction other than the north, it will come back to the origin. Why?\\nYou can draw yourself to better understand but the basic idea is if its starting direction and ending direction\\nare different, it will change its direction by the same amount each time instructions are executed. Hence, robot will eventually come back to the origin. In fact, it will be back in 4 times of instructions at most.\\n*/\\nvar isRobotBounded = function(instructions) { \\n    let x = 0, y = 0;\\n    // DIRECTIONS[i] = [x,y], from north to west\\n    let DIRECTIONS = [[0,1],[1,0],[0,-1],[-1,0]];\\n    let i = 0;\\n    for (let j = 0; j < instructions.length; j++) {\\n        if (instructions[j] === \"R\") {\\n            i = (i + 1) % 4;\\n        } else if (instructions[j] === \"L\") {\\n            i = (i + 3) % 4; \\n        } else {\\n            x += DIRECTIONS[i][0];\\n            y += DIRECTIONS[i][1];\\n        }\\n    }\\n    return (x === 0 && y === 0) || i > 0;\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nIf robot (1) comes back to origin OR (2) faces the north after instructions, the robot is in a circle.\\nTurn right -> i = (i + 1) mod 4, where DIRECTIONS[i] is the direction robot is facing\\nTurn left -> i = (i + 3) mod 4, DIRECTIONS[i] is the direction robot is facing\\n\\nKey points:\\n1. Don\\'t think about middle operations. Think about the start and the end only. We start at (0,0) and\\nend at (x,y). (a) If (x,y) is origin, we\\'ve come back to the origin. No matter where we end up facing, we\\'ll\\nalways come back to origin if we start at origin. (b) If (x,y) is not origin and robot is facing the north,\\nas we repeat instructions, robot will go to (2x,2y), (3x,3y) and so on. Hence, it is NOT in a circle. (c) If (x,y) is not origin and robot is facing a direction other than the north, it will come back to the origin. Why?\\nYou can draw yourself to better understand but the basic idea is if its starting direction and ending direction\\nare different, it will change its direction by the same amount each time instructions are executed. Hence, robot will eventually come back to the origin. In fact, it will be back in 4 times of instructions at most.\\n*/\\nvar isRobotBounded = function(instructions) { \\n    let x = 0, y = 0;\\n    // DIRECTIONS[i] = [x,y], from north to west\\n    let DIRECTIONS = [[0,1],[1,0],[0,-1],[-1,0]];\\n    let i = 0;\\n    for (let j = 0; j < instructions.length; j++) {\\n        if (instructions[j] === \"R\") {\\n            i = (i + 1) % 4;\\n        } else if (instructions[j] === \"L\") {\\n            i = (i + 3) % 4; \\n        } else {\\n            x += DIRECTIONS[i][0];\\n            y += DIRECTIONS[i][1];\\n        }\\n    }\\n    return (x === 0 && y === 0) || i > 0;\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850516,
                "title": "c-c-simple-clean-solution-100-faster-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions)\\n    {\\n        vector position = {0, 0}, direction = {0, 1};\\n        \\n        for (size_t i = 0; i < instructions.length(); i++)\\n        {\\n            switch(instructions[i])\\n            {\\n                case \\'L\\':\\n                    direction = {-direction[1], direction[0]};\\n                    break;\\n                case \\'R\\':\\n                    direction = {direction[1], -direction[0]};\\n                    break;\\n                default:\\n                    position = {position[0] + direction[0], position[1] + direction[1]};\\n            }\\n        }\\n        return  (position[0] == 0 && position[1] == 0) || (direction[0] != 0 || direction[1] != 1) ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions)\\n    {\\n        vector position = {0, 0}, direction = {0, 1};\\n        \\n        for (size_t i = 0; i < instructions.length(); i++)\\n        {\\n            switch(instructions[i])\\n            {\\n                case \\'L\\':\\n                    direction = {-direction[1], direction[0]};\\n                    break;\\n                case \\'R\\':\\n                    direction = {direction[1], -direction[0]};\\n                    break;\\n                default:\\n                    position = {position[0] + direction[0], position[1] + direction[1]};\\n            }\\n        }\\n        return  (position[0] == 0 && position[1] == 0) || (direction[0] != 0 || direction[1] != 1) ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850890,
                "title": "java-solution",
                "content": "```\\npublic boolean isRobotBounded(String instructions) {\\n        int x = 0;\\n        int y = 0;\\n\\t\\t//Keep track of directions\\n        String dir = \"North\";\\n    //     N\\n    // W<----->E\\n    //     S\\n\\t\\n\\t//Caluculate position\\n        for(char c : instructions.toCharArray()){\\n            if(c == \\'G\\'){\\n                if(dir.equals(\"North\")){y++;}\\n                else if(dir.equals(\"East\")){x++;}\\n                else if(dir.equals(\"South\")){y--;}\\n                else {x--;}\\n            }\\n            else if(c == \\'L\\'){\\n                if(dir.equals(\"North\")){dir = \"West\";}\\n                else if(dir.equals(\"East\")){dir = \"North\";}\\n                else if(dir.equals(\"South\")){dir = \"East\";}\\n                else {dir = \"South\";}\\n            }\\n            else{\\n                if(dir.equals(\"North\")){dir = \"East\";}\\n                else if(dir.equals(\"East\")){dir = \"South\";}\\n                else if(dir.equals(\"South\")){dir = \"West\";}\\n                else {dir = \"North\";}\\n            }\\n        }\\n        //Check if calutucated position is starting position\\n        if(x == 0 && y == 0){\\n            return true;\\n        }\\n\\t\\t//check if the final faced direction is not North(Strarting DIrection)\\n        if(dir.equals(\"North\")){\\n            return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean isRobotBounded(String instructions) {\\n        int x = 0;\\n        int y = 0;\\n\\t\\t//Keep track of directions\\n        String dir = \"North\";\\n    //     N\\n    // W<----->E\\n    //     S\\n\\t\\n\\t//Caluculate position\\n        for(char c : instructions.toCharArray()){\\n            if(c == \\'G\\'){\\n                if(dir.equals(\"North\")){y++;}\\n                else if(dir.equals(\"East\")){x++;}\\n                else if(dir.equals(\"South\")){y--;}\\n                else {x--;}\\n            }\\n            else if(c == \\'L\\'){\\n                if(dir.equals(\"North\")){dir = \"West\";}\\n                else if(dir.equals(\"East\")){dir = \"North\";}\\n                else if(dir.equals(\"South\")){dir = \"East\";}\\n                else {dir = \"South\";}\\n            }\\n            else{\\n                if(dir.equals(\"North\")){dir = \"East\";}\\n                else if(dir.equals(\"East\")){dir = \"South\";}\\n                else if(dir.equals(\"South\")){dir = \"West\";}\\n                else {dir = \"North\";}\\n            }\\n        }\\n        //Check if calutucated position is starting position\\n        if(x == 0 && y == 0){\\n            return true;\\n        }\\n\\t\\t//check if the final faced direction is not North(Strarting DIrection)\\n        if(dir.equals(\"North\")){\\n            return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850801,
                "title": "swift-solution-clean-concise",
                "content": "**Approach**\\nRepresent the direction using an `(x, y)` coordinate. For example \\n- `(0, 1)` represents facing up \\n- `(1, 0)` represents facing right\\n- `(0, -1)` represents facing down \\n- `(-1, 0)` represents facing left\\n\\nThen changing direction is easy \\n- To go right, swap the coordinates and negate the `y` coordinate \\n- To go left, swap the coordinates and negate the `x` coordinate\\n\\n**Solution**\\n```swift\\nfunc isRobotBounded(_ instructions: String) -> Bool {\\n\\tvar pos = (0, 0) \\n\\tvar dir = (0, 1) \\n\\n\\tfor cmd in instructions {\\n\\t\\tswitch cmd {\\n\\t\\tcase \"G\":\\n\\t\\t\\tpos.0 += dir.0 \\n\\t\\t\\tpos.1 += dir.1 \\n\\t\\tcase \"L\": \\n\\t\\t\\tdir = (-dir.1, dir.0)\\n\\t\\tcase \"R\":\\n\\t\\t\\tdir = (dir.1, -dir.0)\\n\\t\\tdefault:\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn (dir != (0, 1)) || (pos == (0, 0))\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nfunc isRobotBounded(_ instructions: String) -> Bool {\\n\\tvar pos = (0, 0) \\n\\tvar dir = (0, 1) \\n\\n\\tfor cmd in instructions {\\n\\t\\tswitch cmd {\\n\\t\\tcase \"G\":\\n\\t\\t\\tpos.0 += dir.0 \\n\\t\\t\\tpos.1 += dir.1 \\n\\t\\tcase \"L\": \\n\\t\\t\\tdir = (-dir.1, dir.0)\\n\\t\\tcase \"R\":\\n\\t\\t\\tdir = (dir.1, -dir.0)\\n\\t\\tdefault:\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn (dir != (0, 1)) || (pos == (0, 0))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677844,
                "title": "c-python-simple-and-short-solution-explained-0ms-faster-than-100",
                "content": "**Idea:**\\nWe initialize position to 0,0 and direction to north.\\n\\n**Example - going left:**\\n* if pos is [1,1], direction is [0,1] we want to go left - we have to add to pos [-1,0] (left in graph)\\n* if pos is [1,1], direction is [-1,0] we want to go left - we have to add to pos [0,-1] (down in graph)\\n* if pos is [1,1], direction is [0,-1] we want to go left - we have to add to pos [1,0] (right in graph)\\n        \\nThat calculation brings us to the conclusion that for going left we change the direction [x,y] to [-y,x]\\nand for going right we change the direction [x,y] to [y,-x]\\n\\nIf position got back to original, or we changed original direction, the answer is True.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        pair<int, int> pos = {0, 0}, dir = {0, 1};\\n        \\n        for (auto instruct : instructions) {\\n            if (instruct == \\'L\\')\\n                dir = {-dir.second, dir.first};\\n\\n            else if (instruct == \\'R\\')\\n                dir = {dir.second, -dir.first};\\n\\n            else\\n                pos = {pos.first + dir.first, pos.second + dir.second};\\n        }\\n\\n        return ((pos.first == 0 && pos.second == 0) || (dir.first != 0 || dir.second != 1));\\n    }\\n};\\n```\\n****\\n**Python:**\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        pos = [0,0]\\n        direc = [0,1]\\n\\t\\t\\n        for instruct in instructions:\\n            if instruct == \"L\":\\n                direc[0], direc[1] = -direc[1], direc[0]\\n            elif instruct == \"R\":\\n                direc[0], direc[1] = direc[1], -direc[0]\\n            else:\\n                pos[0], pos[1] = pos[0]+direc[0], pos[1]+direc[1]\\n\\n        return pos == [0,0] or direc != [0,1]\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        pair<int, int> pos = {0, 0}, dir = {0, 1};\\n        \\n        for (auto instruct : instructions) {\\n            if (instruct == \\'L\\')\\n                dir = {-dir.second, dir.first};\\n\\n            else if (instruct == \\'R\\')\\n                dir = {dir.second, -dir.first};\\n\\n            else\\n                pos = {pos.first + dir.first, pos.second + dir.second};\\n        }\\n\\n        return ((pos.first == 0 && pos.second == 0) || (dir.first != 0 || dir.second != 1));\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        pos = [0,0]\\n        direc = [0,1]\\n\\t\\t\\n        for instruct in instructions:\\n            if instruct == \"L\":\\n                direc[0], direc[1] = -direc[1], direc[0]\\n            elif instruct == \"R\":\\n                direc[0], direc[1] = direc[1], -direc[0]\\n            else:\\n                pos[0], pos[1] = pos[0]+direc[0], pos[1]+direc[1]\\n\\n        return pos == [0,0] or direc != [0,1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161778,
                "title": "straightforward-o-n-time-beats-95-python-solution-without-thinking-too-much-about-rotations",
                "content": "Many solutions used the fact that if the character in the string is an \"L\", you can do something like `di = (-di[1],di[0])` , however, in an interview setting it may be a little difficult to intuitively come up with this. So, what I did differently is to think about every case in which you can be pointing in a certain direction (given where you are currently looking at and if you will be turning left/right)\\n\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        curr_pos = [0, 0]\\n        curr_dir = \"N\"\\n        directions = {\"N\": (0, 1), \"S\": (0, -1), \"W\": (-1, 0), \"E\": (1, 0)}\\n\\n        # Calculate the final vector of how the robot travels after executing all instructions once - it consists of a change in position plus a change in direction.\\n        for char in instructions:\\n            if char == \"G\":\\n                curr_pos[0] += directions[curr_dir][0]\\n                curr_pos[1] += directions[curr_dir][1]\\n            elif (curr_dir == \"N\" and char == \"L\") or (curr_dir == \"S\" and char == \"R\"):\\n                curr_dir = \"W\"\\n            elif (curr_dir == \"W\" and char == \"L\") or (curr_dir == \"E\" and char == \"R\"):\\n                curr_dir = \"S\"\\n            elif (curr_dir == \"S\" and char == \"L\") or (curr_dir == \"N\" and char == \"R\"):\\n                curr_dir = \"E\"\\n            elif (curr_dir == \"E\" and char == \"L\") or (curr_dir == \"W\" and char == \"R\"):\\n                curr_dir = \"N\"\\n        \\n        # The robot stays in the circle iff (looking at the final vector) it changes direction (ie. doesn\\'t stay pointing north), or it moves 0.``\\n        return curr_dir != \"N\" or curr_pos == [0, 0]",
                "solutionTags": [
                    "Python"
                ],
                "code": "Many solutions used the fact that if the character in the string is an \"L\", you can do something like `di = (-di[1],di[0])` , however, in an interview setting it may be a little difficult to intuitively come up with this. So, what I did differently is to think about every case in which you can be pointing in a certain direction (given where you are currently looking at and if you will be turning left/right)\\n\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        curr_pos = [0, 0]\\n        curr_dir = \"N\"\\n        directions = {\"N\": (0, 1), \"S\": (0, -1), \"W\": (-1, 0), \"E\": (1, 0)}\\n\\n        # Calculate the final vector of how the robot travels after executing all instructions once - it consists of a change in position plus a change in direction.\\n        for char in instructions:\\n            if char == \"G\":\\n                curr_pos[0] += directions[curr_dir][0]\\n                curr_pos[1] += directions[curr_dir][1]\\n            elif (curr_dir == \"N\" and char == \"L\") or (curr_dir == \"S\" and char == \"R\"):\\n                curr_dir = \"W\"\\n            elif (curr_dir == \"W\" and char == \"L\") or (curr_dir == \"E\" and char == \"R\"):\\n                curr_dir = \"S\"\\n            elif (curr_dir == \"S\" and char == \"L\") or (curr_dir == \"N\" and char == \"R\"):\\n                curr_dir = \"E\"\\n            elif (curr_dir == \"E\" and char == \"L\") or (curr_dir == \"W\" and char == \"R\"):\\n                curr_dir = \"N\"\\n        \\n        # The robot stays in the circle iff (looking at the final vector) it changes direction (ie. doesn\\'t stay pointing north), or it moves 0.``\\n        return curr_dir != \"N\" or curr_pos == [0, 0]",
                "codeTag": "Python3"
            },
            {
                "id": 1130234,
                "title": "c-each-line-commented-clearly",
                "content": "` I also did not know the solution, but they were so poorly written that I have to understand it and then I wrote it in the easiest way possible after getting a proper understanding`\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string s) {\\n        int x=0,y=0,i=0;\\n        // x and y are the co-ordinates and i=0 is the current direction which is North.\\n        vector<vector<int>> dir={{0,1},{1,0},{0,-1},{-1,0}}; // N,E,S,W\\n        // dir vector is a 2d vector which stoes all directions Cordinates \\n        \\n        int n=s.length();\\n        for(int j=0;j<n;j++) {\\n            switch(s[j]) {\\n                case \\'G\\':  // Go 1 unit forward\\n                    x+=dir[i][0]; // pick the x part in whichever direction our robot is ponting\\n                    y+=dir[i][1]; // pick the y part in whichever direction our robot is ponting\\n                    break;\\n                case \\'L\\': // If we have to turn left\\n                    i=(i+3)%4; //left is West, which is 3 units in clockwise direction, so just turn left from your current facing position which is my current i value and we did %4 because we are moving in those direction given in the input array infinitely, so %4 basically gives you the correct index between 0 and last index.\\n                    break;\\n                case \\'R\\':\\n                    i=(i+1)%4; //Right is east, which is 1 units in clockwise direction, so just turn right from your current facing position which is my current i value\\n                    break;\\n            }\\n        }\\n        \\n        if((x==0 && y==0) || i != 0) return true; // either we returned to origin OR we are not facing North, which was 0\\n        return false;\\n    }\\n};\\n```\\n\\n```\\nTime Complexity: O(4*N) because in worst case, we have to access the array 4 times, to complete the circle.\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string s) {\\n        int x=0,y=0,i=0;\\n        // x and y are the co-ordinates and i=0 is the current direction which is North.\\n        vector<vector<int>> dir={{0,1},{1,0},{0,-1},{-1,0}}; // N,E,S,W\\n        // dir vector is a 2d vector which stoes all directions Cordinates \\n        \\n        int n=s.length();\\n        for(int j=0;j<n;j++) {\\n            switch(s[j]) {\\n                case \\'G\\':  // Go 1 unit forward\\n                    x+=dir[i][0]; // pick the x part in whichever direction our robot is ponting\\n                    y+=dir[i][1]; // pick the y part in whichever direction our robot is ponting\\n                    break;\\n                case \\'L\\': // If we have to turn left\\n                    i=(i+3)%4; //left is West, which is 3 units in clockwise direction, so just turn left from your current facing position which is my current i value and we did %4 because we are moving in those direction given in the input array infinitely, so %4 basically gives you the correct index between 0 and last index.\\n                    break;\\n                case \\'R\\':\\n                    i=(i+1)%4; //Right is east, which is 1 units in clockwise direction, so just turn right from your current facing position which is my current i value\\n                    break;\\n            }\\n        }\\n        \\n        if((x==0 && y==0) || i != 0) return true; // either we returned to origin OR we are not facing North, which was 0\\n        return false;\\n    }\\n};\\n```\n```\\nTime Complexity: O(4*N) because in worst case, we have to access the array 4 times, to complete the circle.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851445,
                "title": "java-robot-bounded-in-circle",
                "content": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        \\n        char direction=\\'N\\';\\n        \\n        int x=0;\\n        int y=0;\\n        \\n        for(char ch: instructions.toCharArray()){\\n            \\n            if(ch==\\'G\\'){\\n                \\n                if(direction==\\'N\\')  y++; \\n                else if(direction==\\'S\\')  y--; \\n                else if(direction==\\'E\\')  x++; \\n                else if(direction==\\'W\\')  x--; \\n            }\\n            else if(ch==\\'L\\'){\\n                \\n                if(direction==\\'N\\')  direction=\\'W\\'; \\n                else if(direction==\\'S\\')  direction=\\'E\\'; \\n                else if(direction==\\'E\\')  direction=\\'N\\'; \\n                else if(direction==\\'W\\')  direction=\\'S\\'; \\n            }\\n            else if(ch==\\'R\\'){\\n                \\n                if(direction==\\'N\\')  direction=\\'E\\'; \\n                else if(direction==\\'S\\')  direction=\\'W\\'; \\n                else if(direction==\\'E\\')  direction=\\'S\\'; \\n                else if(direction==\\'W\\')  direction=\\'N\\'; \\n            }\\n        }\\n        \\n        if(direction!=\\'N\\' || x==0 && y==0) return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        \\n        char direction=\\'N\\';\\n        \\n        int x=0;\\n        int y=0;\\n        \\n        for(char ch: instructions.toCharArray()){\\n            \\n            if(ch==\\'G\\'){\\n                \\n                if(direction==\\'N\\')  y++; \\n                else if(direction==\\'S\\')  y--; \\n                else if(direction==\\'E\\')  x++; \\n                else if(direction==\\'W\\')  x--; \\n            }\\n            else if(ch==\\'L\\'){\\n                \\n                if(direction==\\'N\\')  direction=\\'W\\'; \\n                else if(direction==\\'S\\')  direction=\\'E\\'; \\n                else if(direction==\\'E\\')  direction=\\'N\\'; \\n                else if(direction==\\'W\\')  direction=\\'S\\'; \\n            }\\n            else if(ch==\\'R\\'){\\n                \\n                if(direction==\\'N\\')  direction=\\'E\\'; \\n                else if(direction==\\'S\\')  direction=\\'W\\'; \\n                else if(direction==\\'E\\')  direction=\\'S\\'; \\n                else if(direction==\\'W\\')  direction=\\'N\\'; \\n            }\\n        }\\n        \\n        if(direction!=\\'N\\' || x==0 && y==0) return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850862,
                "title": "c-solution-using-complex-numbers",
                "content": "**Explanation of strategy:**\\n\\nEach time the instruction sequence is executed, the robot ends up at some location, having altered its orientation. The interesting fact we can use here is, the robot rotates by the same angle after each execution of the instruction, so after 4 repetitions of the instruction sequence, the robot will ALWAYS be facing the same direction it started with. (To see this, picture how rotating left, right, or 180 degrees four times in a row will end up facing in the original direction.) If we want it to stay confined in a certain region, the location of the robot after 4 instructions should also match the location where it started (the origin), otherwise it will continue to move away in the original direction, infinitely far away from the origin.\\n\\nTo actually implement this, we can make use of complex number mathematics. The complex number \\'1j\\' represents a rotation of 90 degrees counter-clockwise on the complex plane, while \\'-1j\\' rotates clockwise; we can use these facts to easily simulate rotating the robot left or right. Since complex numbers add component-wise just like vectors, we can add the direction of the robot to its position when going straight. We loop over the instruction string 4 times, and after we\\'re done, we compare the position of the robot to the origin (where it started). Note that the original direction of the robot doesn\\'t matter here, but I just initialized it as \\'1j\\' to represent that the robot started moving north.\\n\\n**Accompanying code:**\\n\\n```\\nclass Solution {\\n    public:\\n        bool isRobotBounded(string instructions) {\\n            complex<float> p=0, o=0, d = 1j, L = 1j; // p = position, o = origin, d = direction, L = \"turn left\"\\n            for (int it=0;it<4;it++)                 // Loop 4 times\\n                for (char c : instructions)          // Loop over each character in the instructions string\\n                    if (c==\\'L\\') d *= L;              // Multiplying by 1j \"rotates\" the robot counter-clockwise\\n                    else if (c==\\'R\\') d *= (-L);      // Multiplying by -1j \"rotates\" the robot\\'s direction clockwise\\n                    else if (c==\\'G\\') p += d;         // Adding the direction complex number to the current position\\n            return p == o;                           // If it\\'s still at the origin after 4 iterations, we\\'ve found a cycle\\n        }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isRobotBounded(string instructions) {\\n            complex<float> p=0, o=0, d = 1j, L = 1j; // p = position, o = origin, d = direction, L = \"turn left\"\\n            for (int it=0;it<4;it++)                 // Loop 4 times\\n                for (char c : instructions)          // Loop over each character in the instructions string\\n                    if (c==\\'L\\') d *= L;              // Multiplying by 1j \"rotates\" the robot counter-clockwise\\n                    else if (c==\\'R\\') d *= (-L);      // Multiplying by -1j \"rotates\" the robot\\'s direction clockwise\\n                    else if (c==\\'G\\') p += d;         // Adding the direction complex number to the current position\\n            return p == o;                           // If it\\'s still at the origin after 4 iterations, we\\'ve found a cycle\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 712970,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\n\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        short x=0,y=0,dir=0;\\n        for(auto c : instructions)\\n        {  \\n            if (c==\\'G\\')\\n            {\\n                //down:0, left:1, up:2, right:3\\n                if (dir == 0) y+=1;\\n                else if (dir == 1) x-=1;\\n                else if (dir == 2) y-=1;\\n                else x+=1;\\n            }\\n            else if (c==\\'R\\')\\n                dir++;\\n            else\\n                dir--;\\n            dir&=0x3;\\n        }\\n        return ((x==0 && y==0) || dir != 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        short x=0,y=0,dir=0;\\n        for(auto c : instructions)\\n        {  \\n            if (c==\\'G\\')\\n            {\\n                //down:0, left:1, up:2, right:3\\n                if (dir == 0) y+=1;\\n                else if (dir == 1) x-=1;\\n                else if (dir == 2) y-=1;\\n                else x+=1;\\n            }\\n            else if (c==\\'R\\')\\n                dir++;\\n            else\\n                dir--;\\n            dir&=0x3;\\n        }\\n        return ((x==0 && y==0) || dir != 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291382,
                "title": "javascript-60-ms-solution-o-n",
                "content": "```\\nvar isRobotBounded = function(instructions) {\\n    let steps = [\\n        [-1,0],\\n        [0,1],\\n        [1,0],\\n        [0,-1]\\n    ];\\n    let x = y = 0;\\n    \\n    let currStep = 1;\\n    let turn = (direction) =>{\\n        if(direction === \"L\") currStep--;\\n        else if(direction === \"R\") currStep++;\\n        else if(direction === \"G\") {\\n            x += steps[currStep][0];\\n            y += steps[currStep][1];\\n        }\\n        if(currStep < 0) currStep = 3;\\n        if(currStep === 4) currStep = 0;\\n    }\\n    \\n    \\n    for(let i=0; i<instructions.length*4; i++){\\n        turn(instructions[i]);\\n    }\\n\\t// I was stucked at the last return. The following line might be the key line for this problem.\\n\\t// as lone as the robot is at (0,0) or not going north, it should be true.\\n    return (currStep !== 1) || (x ===0 && y===0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isRobotBounded = function(instructions) {\\n    let steps = [\\n        [-1,0],\\n        [0,1],\\n        [1,0],\\n        [0,-1]\\n    ];\\n    let x = y = 0;\\n    \\n    let currStep = 1;\\n    let turn = (direction) =>{\\n        if(direction === \"L\") currStep--;\\n        else if(direction === \"R\") currStep++;\\n        else if(direction === \"G\") {\\n            x += steps[currStep][0];\\n            y += steps[currStep][1];\\n        }\\n        if(currStep < 0) currStep = 3;\\n        if(currStep === 4) currStep = 0;\\n    }\\n    \\n    \\n    for(let i=0; i<instructions.length*4; i++){\\n        turn(instructions[i]);\\n    }\\n\\t// I was stucked at the last return. The following line might be the key line for this problem.\\n\\t// as lone as the robot is at (0,0) or not going north, it should be true.\\n    return (currStep !== 1) || (x ===0 && y===0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3672987,
                "title": "python-solution-pretty-intuitive",
                "content": "My first time posting a solution on Leetcode and I think the solution was unique so really proud of it.\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of sorry for bad English.\\nPretty Intuitive Solution.\\nTook help from the hint given for the question to check if the circle is forming or not.\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        initial_pos = curr_pos = [0, 0]\\n        directions = {\\n            \\'N\\': [0, 1],\\n            \\'S\\': [0, -1],\\n            \\'E\\': [1, 0],\\n            \\'W\\': [-1, 0]\\n        }\\n        nesw = [\\'N\\', \\'E\\', \\'S\\', \\'W\\']\\n        dir = \\'N\\'\\n        for i in range(len(instructions)):\\n            if instructions[i] == \\'G\\':\\n                curr_pos = [x + y for x, y in zip(curr_pos, directions[dir])]\\n            elif instructions[i] == \\'L\\':\\n                dir = nesw[(nesw.index(dir) - 1) % len(nesw)]\\n            elif instructions[i] == \\'R\\':\\n                dir = nesw[(nesw.index(dir) + 1) % len(nesw)]\\n        return initial_pos == curr_pos or dir != \\'N\\'\\n```\\nUpvote pls thx.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        initial_pos = curr_pos = [0, 0]\\n        directions = {\\n            \\'N\\': [0, 1],\\n            \\'S\\': [0, -1],\\n            \\'E\\': [1, 0],\\n            \\'W\\': [-1, 0]\\n        }\\n        nesw = [\\'N\\', \\'E\\', \\'S\\', \\'W\\']\\n        dir = \\'N\\'\\n        for i in range(len(instructions)):\\n            if instructions[i] == \\'G\\':\\n                curr_pos = [x + y for x, y in zip(curr_pos, directions[dir])]\\n            elif instructions[i] == \\'L\\':\\n                dir = nesw[(nesw.index(dir) - 1) % len(nesw)]\\n            elif instructions[i] == \\'R\\':\\n                dir = nesw[(nesw.index(dir) + 1) % len(nesw)]\\n        return initial_pos == curr_pos or dir != \\'N\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676693,
                "title": "python3-simple-4-loops-o-n-time-o-1-space",
                "content": "The idea is to think of the the result of 1 iteration through the instructions, instead of zooming in to every little detail. At every loop, the total rotation will be similar. Example: If the robot turns 90 degrees the first iteration, it will keep turning 90 degrees at future iterations. This implies that the robot will look North within at most 4 iterations. When that happens, we can compare the current position to the robot\\'s initial position (0, 0), and then return true if they are equal, and false otherwise.\\n\\nBelow is the code, please let me know if you have any questions!\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        x = y = 0\\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        i = 0\\n        while True:\\n            for do in instructions:\\n                if do == \\'G\\':\\n                    x += directions[i][0]\\n                    y += directions[i][1]\\n                elif do == \\'R\\':\\n                    i = (i + 1) % 4\\n                else:\\n                    i = (i - 1) % 4\\n                    \\n            if i == 0:\\n                return x == 0 and y == 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        x = y = 0\\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        i = 0\\n        while True:\\n            for do in instructions:\\n                if do == \\'G\\':\\n                    x += directions[i][0]\\n                    y += directions[i][1]\\n                elif do == \\'R\\':\\n                    i = (i + 1) % 4\\n                else:\\n                    i = (i - 1) % 4\\n                    \\n            if i == 0:\\n                return x == 0 and y == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112624,
                "title": "golang-faster-than-100-solution-with-explanation-and-images",
                "content": "**What the problem is asking:**\\n\\nThe problem says that it will give a string with the letters ` \"L\", \"R\"` and `\"G\"` to command a robot. `\"L\"` means to turn left 90 degrees, `\"R\"` means to turn right 90 degrees, and `\"G\"` means to go forward one unit. The problem says to return `true` if the robot can continue in that pattern forever and keep going in a circle. This can be shown with the following example:\\n\\n```\\ninput := \"GL\"\\nexpected output := true\\n```\\n\\nI have depicted how this example works with the following picture:\\n\\n![image](https://assets.leetcode.com/users/images/1855d28f-e9d3-4d48-b4cb-8dd094856b18_1615912827.6652634.jpeg)\\n\\n\\n\\n> * In the first image, we start off at the point `(0, 0)`\\n> * In the second image, we do the input `\"GL\"`, we go up one unit and then turn left, *(I have put a dotted line with an arrow to signify that we are going left in the next move)*\\n> * In the following image, we do the `\"GL\"` again.\\n> * In the fourth image, we do `\"GL\"` again.\\n> * In the fifth image, we have finished the circle by doing `\"GL\"` again.\\n> * And in the sixth image, we can see that this keeps on repeating.\\n>\\n> I have not added anymore because I think it is pretty self-explanatory\\n\\n**What my code is doing:**\\n\\nWe use the variables `x, y\\' and `degree`. `x` and `y` signify where the current position is. And `degree` is what angle you are pointing at. We use `4` numbers to signify this:\\n\\n* `degree = 0` means pointing up\\n* `degree = 1` means pointing right\\n* `degree = 2` means pointing down\\n* `degree = 3` means pointing left\\n\\nNext, we have to know when to add and subtract from `x` and `y\\'.\\n\\n* If `degree == 0 && letter == \\'G\\'` then add one to `y`\\n* If `degree == 1 && letter == \\'G\\'` then add one to `x`\\n* If `degree == 2 && letter == \\'G\\'` then subtract one to `y`\\n* If `degree == 3 && letter == \\'G\\'` then subtract one to `x`\\n\\nThen to check whether `return true || return false`. We can see that if the robot returns to the origin at its last move, it has to be going in a circle, and if it is not facing `up` we know that it will make a circle after some time. If you don\\'t understand the part of not facing up, look at the image below.\\n\\n![image](https://assets.leetcode.com/users/images/01643d29-a9f7-43c2-9ec1-847c85dd5c05_1615912841.1667998.jpeg)\\n\\n\\n> This is the same example as the example above `input := \"GL\"`, when we go through the string we get the image above, as we saw in the last instance, if we continue to make this pattern, we get a circle so as return `true` for this. \\n>\\n> You can try this with an example. It will be `true` for any degree that is not facing up.\\n\\n\\n**The Code:**\\n\\n``` go\\nfunc isRobotBounded(instructions string) bool {\\n    x, y, degree := 0, 0, 0\\n\\n    for _, i := range instructions {\\n        if i == \\'R\\' {\\n            degree = (degree + 1) % 4\\n            continue\\n        } else if i == \\'L\\' {\\n            degree = (degree + 3) % 4\\n            continue\\n        } \\n\\n        switch degree {\\n        case 0:\\n            y++\\n        case 1:\\n            x++\\n        case 2:\\n            y--\\n        case 3:\\n            x--\\n        }\\n    }\\n    return x == 0 && y == 0 || degree != 0\\n}\\n```\\n\\n**We can take out the switch case and make the code:**\\n\\n``` go\\nfunc isRobotBounded(instructions string) bool {\\n    x, y, degree := 0, 0, 0\\n    addSubtractXAndY := []int{1, 1, -1, -1}\\n\\n    for _, i := range instructions {\\n        if i == \\'R\\' {\\n            degree = (degree + 1) % 4\\n        } else if i == \\'L\\' {\\n            degree = (degree + 3) % 4\\n        } else {\\n            if degree == 0 || degree == 2 {\\n                y += addSubtractXAndY[degree]\\n            } else {\\n                x += addSubtractXAndY[degree]\\n            }\\n        }\\n    }\\n    return x == 0 && y == 0 || degree != 0\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ninput := \"GL\"\\nexpected output := true\\n```\n``` go\\nfunc isRobotBounded(instructions string) bool {\\n    x, y, degree := 0, 0, 0\\n\\n    for _, i := range instructions {\\n        if i == \\'R\\' {\\n            degree = (degree + 1) % 4\\n            continue\\n        } else if i == \\'L\\' {\\n            degree = (degree + 3) % 4\\n            continue\\n        } \\n\\n        switch degree {\\n        case 0:\\n            y++\\n        case 1:\\n            x++\\n        case 2:\\n            y--\\n        case 3:\\n            x--\\n        }\\n    }\\n    return x == 0 && y == 0 || degree != 0\\n}\\n```\n``` go\\nfunc isRobotBounded(instructions string) bool {\\n    x, y, degree := 0, 0, 0\\n    addSubtractXAndY := []int{1, 1, -1, -1}\\n\\n    for _, i := range instructions {\\n        if i == \\'R\\' {\\n            degree = (degree + 1) % 4\\n        } else if i == \\'L\\' {\\n            degree = (degree + 3) % 4\\n        } else {\\n            if degree == 0 || degree == 2 {\\n                y += addSubtractXAndY[degree]\\n            } else {\\n                x += addSubtractXAndY[degree]\\n            }\\n        }\\n    }\\n    return x == 0 && y == 0 || degree != 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2276579,
                "title": "shortest-solution-c-100-faster",
                "content": "C++ Solution for the given problem. The code has been split block wise for better understanding.\\n\\nQUESTION : The problem wants us to return \\'TRUE\\' if it is possible to find a circle such that the circle always bounds the robot\\'s postions otherwise wants us to return \\'FALSE\\'\\n\\nLOGIC : If we try to visualise the situation with a pen and paper we observe that the condition required by the problem can only be achieved, if after executing the segment of instructions once or more number of times we are able to return to origin. \\n\\nTARGET : We need to check whether it is possible to return to origin by executing the given segment of instructions by some number of times.\\n\\nEXPLANATION :\\n\\n1. This block has variables indicating position of the robot after following some given instructions\\n2. This block has the variables indicating the direction in which robot is facing (x, y) = (0, 1) -> positive y or north direction. similarily (1, 0) -> positive x or east direction, (0, -1) -> negative y or south direction and (-1, 0) -> negative x or west direction.\\n3. (I\\'ll discuss in the end)\\n4. for each \\'G\\' we get we are incrementing (or decrementing) x (or y) since because of our choice exactly one of them will have a non-zero value the other of dx or dy will be zero.\\n5. as far as this is concerned you can see if we are facing north and we turn left we start looking west imply (0, 1) -> (-1, 0)->(0, -1) ->(1, 0) you can see this is captured in the operations that we are doing (this is a sleek way of writing the code it just hit me)\\n6. This is same as part 5 just for right turns.\\n7. if after all the operations of one segment of instructions I remain at the origin ( x==0 and y==0) then this case returns a true.\\n\\nbut here we have considered only the case in which we reach at origin after one segment of instructions, but is there a case where one segment might not reach at origin but multiple such segments may.... well it seems there are such cases (for example \"GL\") but there is a slight observation that any such case which satisfy the condition will have(must have) to satisfy it for segment of instructions applied 4 times hence this is being managed in point no. 3. in which I\\'m doubling the segment of instructions twice making it 4 times. \\n\\nThis concludes the explanation for the question, I hope you found it useful :)\\n\\n\\n\\n\\n\\n\\t\\'\\'\\'\\n\\t\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n    \\n    bool isRobotBounded(string ins) {\\n        \\n        int y = 0;  // block 1\\n        int x = 0; \\n        \\n        int dy = 1;  // block 2\\n        int dx = 0; \\n        \\n        ins+=ins;  // block 3\\n        ins+=ins; \\n        \\n        for(int i=0; i<ins.size(); i++){\\n            \\n            if(ins[i]==\\'G\\') { // block 4\\n                y+=dy; x+=dx;\\n            } \\n            else if(ins[i]==\\'L\\'){ // block 5\\n                swap(dx, dy);\\n                dx*=-1;\\n            } \\n            else{ // block 6\\n                swap(dx, dy);\\n                dy*=-1;\\n            }\\n            \\n        }\\n        \\n        \\n\\t\\t\\tif(y==0 and x==0) return true; // block 7\\n\\t\\t\\telse return false;\\n\\t\\t}\\n\\t};\\n\\t\\n\\n\\' \\' \\'",
                "solutionTags": [
                    "Math",
                    "String",
                    "Simulation"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n    \\n    bool isRobotBounded(string ins) {\\n        \\n        int y = 0;  // block 1\\n        int x = 0; \\n        \\n        int dy = 1;  // block 2\\n        int dx = 0; \\n        \\n        ins+=ins;  // block 3\\n        ins+=ins; \\n        \\n        for(int i=0; i<ins.size(); i++){\\n            \\n            if(ins[i]==\\'G\\') { // block 4\\n                y+=dy; x+=dx;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1076689,
                "title": "javascript-with-dx-dy",
                "content": "```\\nRuntime: 76 ms, faster than 87.40% of JavaScript online submissions for Robot Bounded In Circle.\\nMemory Usage: 38.6 MB, less than 68.90% of JavaScript online submissions for Robot Bounded In Circle.\\n```\\n```\\nvar isRobotBounded = function(instructions) {\\n    let x = 0;\\n    let y = 0;\\n    let dx = 0;\\n    let dy = 1;\\n\\n    for (let direction of instructions) {\\n        if (direction === \"R\") {\\n            let temp = dx;\\n            dx = dy;\\n            dy = -temp;\\n        } else if (direction === \"L\") {\\n            let temp = dy;\\n            dy = dx;\\n            dx = -temp;\\n        } else {\\n            x = x + dx;\\n            y = y + dy;\\n        }\\n    }\\n    return (!x && !y) || dy !== 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nRuntime: 76 ms, faster than 87.40% of JavaScript online submissions for Robot Bounded In Circle.\\nMemory Usage: 38.6 MB, less than 68.90% of JavaScript online submissions for Robot Bounded In Circle.\\n```\n```\\nvar isRobotBounded = function(instructions) {\\n    let x = 0;\\n    let y = 0;\\n    let dx = 0;\\n    let dy = 1;\\n\\n    for (let direction of instructions) {\\n        if (direction === \"R\") {\\n            let temp = dx;\\n            dx = dy;\\n            dy = -temp;\\n        } else if (direction === \"L\") {\\n            let temp = dy;\\n            dy = dx;\\n            dx = -temp;\\n        } else {\\n            x = x + dx;\\n            y = y + dy;\\n        }\\n    }\\n    return (!x && !y) || dy !== 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850825,
                "title": "99-better-javascript-solution",
                "content": "```\\nvar isRobotBounded = function(instructions) {\\n    const DIRECTION = { \"N\": [0,1], \"S\": [0,-1], \"E\": [1,0], \"W\": [-1,0] };\\n    const LEFT = { \"N\" : \"W\",  \"W\" : \"S\", \"S\" : \"E\", \"E\" : \"N\" };\\n    const RIGHT = { \"N\" : \"E\",  \"E\" : \"S\", \"S\" : \"W\", \"W\" : \"N\" };\\n    // initial starting point of the robot\\n    let robot = [0,0];\\n    // the direction our robot is currently facing (initialized to north)\\n    let facing = \"N\";\\n\\t\\n    for (let i of instructions) {\\n\\t\\t// if G, update the current position of the robot based on the direction\\n        if (i === \"G\") robot = [robot[0] + DIRECTION[facing][0], robot[1] + DIRECTION[facing][1]];\\n\\t\\t// if L, change facing direction of the robot using LEFT\\n        else if (i === \"L\") facing = LEFT[facing];\\n\\t\\t// otherwise (R), change the facing direction of the robot using RIGHT \\n        else facing = RIGHT[facing];\\n    }\\n\\t\\n\\t// if we are facing a new direction or we have not moved we are in a circular pattern, return true\\n    if (facing !== \"N\" || (robot[0] === 0 && robot[1] === 0)) return true;\\n\\t// otherwise return false\\n    return false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isRobotBounded = function(instructions) {\\n    const DIRECTION = { \"N\": [0,1], \"S\": [0,-1], \"E\": [1,0], \"W\": [-1,0] };\\n    const LEFT = { \"N\" : \"W\",  \"W\" : \"S\", \"S\" : \"E\", \"E\" : \"N\" };\\n    const RIGHT = { \"N\" : \"E\",  \"E\" : \"S\", \"S\" : \"W\", \"W\" : \"N\" };\\n    // initial starting point of the robot\\n    let robot = [0,0];\\n    // the direction our robot is currently facing (initialized to north)\\n    let facing = \"N\";\\n\\t\\n    for (let i of instructions) {\\n\\t\\t// if G, update the current position of the robot based on the direction\\n        if (i === \"G\") robot = [robot[0] + DIRECTION[facing][0], robot[1] + DIRECTION[facing][1]];\\n\\t\\t// if L, change facing direction of the robot using LEFT\\n        else if (i === \"L\") facing = LEFT[facing];\\n\\t\\t// otherwise (R), change the facing direction of the robot using RIGHT \\n        else facing = RIGHT[facing];\\n    }\\n\\t\\n\\t// if we are facing a new direction or we have not moved we are in a circular pattern, return true\\n    if (facing !== \"N\" || (robot[0] === 0 && robot[1] === 0)) return true;\\n\\t// otherwise return false\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850699,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn is_robot_bounded(instructions: String) -> bool {\\n        let mut d = (0, 1);\\n        let mut p = (0, 0);\\n        for c in instructions.chars() {\\n            match c {\\n                \\'G\\' => p = (p.0 + d.0, p.1 + d.1),\\n                \\'L\\' => d = (-d.1, d.0),\\n                \\'R\\' => d = (d.1, -d.0),\\n                _ => {}\\n            }\\n        }\\n        p == (0, 0) || d != (0, 1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn is_robot_bounded(instructions: String) -> bool {\\n        let mut d = (0, 1);\\n        let mut p = (0, 0);\\n        for c in instructions.chars() {\\n            match c {\\n                \\'G\\' => p = (p.0 + d.0, p.1 + d.1),\\n                \\'L\\' => d = (-d.1, d.0),\\n                \\'R\\' => d = (d.1, -d.0),\\n                _ => {}\\n            }\\n        }\\n        p == (0, 0) || d != (0, 1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 675196,
                "title": "c-100-faster-2-solutions",
                "content": "1. Iterating the string 4 times and then checking the position\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int dir = 100;\\n        int up = 0;\\n        int side = 0;\\n        for(int j = 0;j<4;j++){\\n            for(int i = 0;i<instructions.length();i++){\\n                if(instructions[i]==\\'G\\'){\\n                    if(dir%4==0){\\n                        up++;\\n                    }\\n                    else if(dir%4==1){\\n                        side++;\\n                    }\\n                    else if(dir%4==2){\\n                        up--;\\n                    }\\n                    else{\\n                        side--;\\n                    }\\n                }\\n                else if(instructions[i]==\\'L\\'){\\n                    dir--;\\n                }\\n                else{\\n                    dir++;\\n                }\\n            }\\n            if(up==0 && side==0){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n2. Iterating once and checking the status:-\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int dir = 100;\\n        int up = 0;\\n        int side = 0;\\n        for(int i = 0;i<instructions.length();i++){\\n            if(instructions[i]==\\'G\\'){\\n                if(dir%4==0){\\n                    up++;\\n                }\\n                else if(dir%4==1){\\n                    side++;\\n                }\\n                else if(dir%4==2){\\n                    up--;\\n                }\\n                else{\\n                    side--;\\n                }\\n            }\\n            else if(instructions[i]==\\'L\\'){\\n                dir--;\\n            }\\n            else{\\n                dir++;\\n            }\\n        }\\n        if((up==0 && side==0) || (dir%4!=0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int dir = 100;\\n        int up = 0;\\n        int side = 0;\\n        for(int j = 0;j<4;j++){\\n            for(int i = 0;i<instructions.length();i++){\\n                if(instructions[i]==\\'G\\'){\\n                    if(dir%4==0){\\n                        up++;\\n                    }\\n                    else if(dir%4==1){\\n                        side++;\\n                    }\\n                    else if(dir%4==2){\\n                        up--;\\n                    }\\n                    else{\\n                        side--;\\n                    }\\n                }\\n                else if(instructions[i]==\\'L\\'){\\n                    dir--;\\n                }\\n                else{\\n                    dir++;\\n                }\\n            }\\n            if(up==0 && side==0){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int dir = 100;\\n        int up = 0;\\n        int side = 0;\\n        for(int i = 0;i<instructions.length();i++){\\n            if(instructions[i]==\\'G\\'){\\n                if(dir%4==0){\\n                    up++;\\n                }\\n                else if(dir%4==1){\\n                    side++;\\n                }\\n                else if(dir%4==2){\\n                    up--;\\n                }\\n                else{\\n                    side--;\\n                }\\n            }\\n            else if(instructions[i]==\\'L\\'){\\n                dir--;\\n            }\\n            else{\\n                dir++;\\n            }\\n        }\\n        if((up==0 && side==0) || (dir%4!=0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300372,
                "title": "python-4-instructions-o-n",
                "content": "This solution is to run the instruction 4 times to see whether the robot can move back to origin\\n```\\nclass Solution(object):\\n    def isRobotBounded(self, instructions):\\n        \"\"\"\\n        :type instructions: str\\n        :rtype: bool\\n        \"\"\"\\n        instructions *= 4\\n        direction = \\'N\\'\\n        directionNext = {\\'N\\': (\\'W\\', \\'E\\'), \\'E\\': (\\'N\\', \\'S\\'), \\'S\\': (\\'E\\', \\'W\\'), \\'W\\': (\\'S\\', \\'N\\')}\\n        x, y = 0, 0\\n        for move in instructions:\\n            if move == \\'G\\':\\n                if direction == \\'N\\':\\n                    y += 1\\n                elif direction == \\'E\\':\\n                    x += 1\\n                elif direction == \\'S\\':\\n                    y -= 1\\n                else:\\n                    x -= 1\\n            elif move == \\'L\\':\\n                direction = directionNext[direction][0]\\n            else: \\n                direction = directionNext[direction][1]\\n        return x == 0 and y == 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isRobotBounded(self, instructions):\\n        \"\"\"\\n        :type instructions: str\\n        :rtype: bool\\n        \"\"\"\\n        instructions *= 4\\n        direction = \\'N\\'\\n        directionNext = {\\'N\\': (\\'W\\', \\'E\\'), \\'E\\': (\\'N\\', \\'S\\'), \\'S\\': (\\'E\\', \\'W\\'), \\'W\\': (\\'S\\', \\'N\\')}\\n        x, y = 0, 0\\n        for move in instructions:\\n            if move == \\'G\\':\\n                if direction == \\'N\\':\\n                    y += 1\\n                elif direction == \\'E\\':\\n                    x += 1\\n                elif direction == \\'S\\':\\n                    y -= 1\\n                else:\\n                    x -= 1\\n            elif move == \\'L\\':\\n                direction = directionNext[direction][0]\\n            else: \\n                direction = directionNext[direction][1]\\n        return x == 0 and y == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678806,
                "title": "c-with-easy-explanation-bruteforce-and-optimal-easy-to-understand",
                "content": "Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivates me to create better post like this \\u270D\\uFE0F\\n![image](https://assets.leetcode.com/users/images/9fac89e7-d694-4f28-9f06-53edd5587bda_1641750744.1594224.png)\\n\\n#### \\u2714\\uFE0F **Question Conclusion**\\n* we have to find wheather the robot repeat the same path it means if we starts from origin at some point it should came again at origin return true else false.\\n\\n#### \\u2714\\uFE0F **Solution - I (Naive Approach)**\\n##### **Intuition :-**\\n* I have made condition for every instruction.\\n* It is the most basic and easy approach.\\n* If you can\\'t think of optimal try atleast for bruteforce.\\n##### **Code :-**\\n```\\nbool isRobotBounded(string instructions)\\n{\\n     int x = 0;\\n     int y = 0;\\n     char direction = \\'N\\';\\n     int count = 100;\\n     while (count--)\\n     {\\n          for (int i = 0; i < instructions.size(); i++)\\n          {\\n               if (instructions[i] == \\'G\\')\\n                    if (direction == \\'N\\')\\n                         y = y + 1;\\n                    else if (direction == \\'W\\')\\n                         x = x - 1;\\n                    else if (direction == \\'E\\')\\n                         x = x + 1;\\n                    else\\n                         y = y - 1;\\n               else if (instructions[i] == \\'L\\')\\n                    if (direction == \\'N\\')\\n                         direction = \\'W\\';\\n                    else if (direction == \\'W\\')\\n                         direction = \\'S\\';\\n                    else if (direction == \\'S\\')\\n                         direction = \\'E\\';\\n                    else\\n                         direction = \\'N\\';\\n               else if (instructions[i] == \\'R\\')\\n                    if (direction == \\'N\\')\\n                         direction = \\'E\\';\\n                    else if (direction == \\'E\\')\\n                         direction = \\'S\\';\\n                    else if (direction == \\'S\\')\\n                         direction = \\'W\\';\\n                    else\\n                         direction = \\'N\\';\\n          }\\n          if (x == 0 && y == 0)\\n               return true;\\n     }\\n     return false;\\n}\\n```\\n**Time Complexity** : `O(maximum instructions = 100)`, as the limit of instruction are less than 100.\\n**Space Complexity** : `O(1)`, no extra space is used.\\n\\n#### \\u2714\\uFE0F **Solution - II (Best Approach)**\\n##### **Intuition :-**\\n* (x,y) is the location of chopper.\\n* d[i] is the direction he is facing.\\n* i = (i + 1) % 4 will turn right\\n* i = (i + 3) % 4 will turn left\\nCheck the final status after instructions.\\n\\n##### **Code :-**\\n```\\nbool isRobotBounded(string instructions)\\n{\\n     int x = 0, y = 0, i = 0;\\n     vector<vector<int>> direction = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n     for (char &ins : instructions)\\n          if (ins == \\'R\\')\\n               i = (i + 1) % 4;\\n          else if (ins == \\'L\\')\\n               i = (i + 3) % 4;\\n          else\\n               x += direction[i][0], y += direction[i][1];\\n     return x == 0 && y == 0 || i > 0;\\n}\\n```\\n**Time Complexity** : `O(N)`, executed instruction only one time.\\n**Space Complexity** : `O(1)`, constant space is used.\\n_____________________________________________________________________________________________________________\\n_____________________________________________________________________________________________________________\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isRobotBounded(string instructions)\\n{\\n     int x = 0;\\n     int y = 0;\\n     char direction = \\'N\\';\\n     int count = 100;\\n     while (count--)\\n     {\\n          for (int i = 0; i < instructions.size(); i++)\\n          {\\n               if (instructions[i] == \\'G\\')\\n                    if (direction == \\'N\\')\\n                         y = y + 1;\\n                    else if (direction == \\'W\\')\\n                         x = x - 1;\\n                    else if (direction == \\'E\\')\\n                         x = x + 1;\\n                    else\\n                         y = y - 1;\\n               else if (instructions[i] == \\'L\\')\\n                    if (direction == \\'N\\')\\n                         direction = \\'W\\';\\n                    else if (direction == \\'W\\')\\n                         direction = \\'S\\';\\n                    else if (direction == \\'S\\')\\n                         direction = \\'E\\';\\n                    else\\n                         direction = \\'N\\';\\n               else if (instructions[i] == \\'R\\')\\n                    if (direction == \\'N\\')\\n                         direction = \\'E\\';\\n                    else if (direction == \\'E\\')\\n                         direction = \\'S\\';\\n                    else if (direction == \\'S\\')\\n                         direction = \\'W\\';\\n                    else\\n                         direction = \\'N\\';\\n          }\\n          if (x == 0 && y == 0)\\n               return true;\\n     }\\n     return false;\\n}\\n```\n```\\nbool isRobotBounded(string instructions)\\n{\\n     int x = 0, y = 0, i = 0;\\n     vector<vector<int>> direction = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n     for (char &ins : instructions)\\n          if (ins == \\'R\\')\\n               i = (i + 1) % 4;\\n          else if (ins == \\'L\\')\\n               i = (i + 3) % 4;\\n          else\\n               x += direction[i][0], y += direction[i][1];\\n     return x == 0 && y == 0 || i > 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1678562,
                "title": "java-100-faster",
                "content": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int dir[][] = {{0,1}, {-1, 0}, {0, -1}, {1,0}};\\n        int i = 0;\\n        int x = 0;\\n        int y = 0;\\n       \\n        for(int s = 0; s < instructions.length(); s++){\\n            if(instructions.charAt(s) == \\'L\\'){\\n                i = (i + 1) % 4;\\n            }\\n            else if(instructions.charAt(s) == \\'R\\'){\\n                i = (i + 3) % 4;\\n            }\\n            else{\\n                x = x + dir[i][0];\\n                y = y + dir[i][1];\\n            }\\n        }\\n        return x == 0 && y == 0 || i != 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int dir[][] = {{0,1}, {-1, 0}, {0, -1}, {1,0}};\\n        int i = 0;\\n        int x = 0;\\n        int y = 0;\\n       \\n        for(int s = 0; s < instructions.length(); s++){\\n            if(instructions.charAt(s) == \\'L\\'){\\n                i = (i + 1) % 4;\\n            }\\n            else if(instructions.charAt(s) == \\'R\\'){\\n                i = (i + 3) % 4;\\n            }\\n            else{\\n                x = x + dir[i][0];\\n                y = y + dir[i][1];\\n            }\\n        }\\n        return x == 0 && y == 0 || i != 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677147,
                "title": "c-best-solution-easy-explanation",
                "content": "The main intuition behind the problem is that there is always a finitely big circle to bind a robot\\'s path, unless it has a **path that goes to infinity**. So, when can the robot go to infinity?\\n\\nIf you think a bit with some examples, suppose the final displacement vector (final position - initial position) after one iteration of instructions is a vector to the east with the robot facing east. (You can make a rotation of the coordinate axis to make any vector that is not pointing east follow this. For example, if you suppose your vector is 45 degrees to the north west, you can rotate the axis 135 degrees with no loss of generality and have it point east). In only 4 iterations, it will return back to its original position. \\n\\n![image](https://assets.leetcode.com/users/images/34cb4ec7-fbb4-429d-833a-0ef0524fecdc_1641705499.4991412.png)\\n\\nAs it turns out, the robot will only go to infinity if in its final position, it is facing north. Then, the displacement vector will continue to get farther and farther away instead of forming some polygonal path. In every other instance, there will be a polygon formed.\\n\\nWhy is the first fact true? The second iteration of the instructions will make a vector exactly the same as the first vector, and so these vectors will keep on adding in the same direction and go to infinity. In any other case, the vectors will circle around to form a polygon. \\n\\n**Corner Case**: The robot can return to its original position after one instruction iteration despite facing north. Obviously, it can be bound by a circle in this case.\\n\\nThus, the solution is trivial after we realize this.\\n\\n\\n```class Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0, y=0;\\n        int dir = 0; // 0 representing north, 1 representing east, 2 representing south, 3 representing west. A concept similar to the Spiral Matrix II problem.\\n        for (int i = 0; i < instructions.size(); ++i) {\\n            if (instructions[i]==\\'G\\') {\\n                if (dir==0) y++;\\n                if (dir==1) x++;\\n                if (dir==2) y--;\\n                if (dir==3) x--;\\n            }\\n            else if (instructions[i]==\\'L\\') {\\n                dir--;\\n                dir = (dir+4)%4; // So that direction is positive after taking mod\\n            }\\n            else {\\n                dir++;\\n                dir %= 4;\\n            }\\n        }\\n        return dir!=0 || (x==0 & y==0);\\n    }\\n};\\n```\\n\\n**Time Complexity: O(N)\\nSpace Complexity: O(1)**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```class Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0, y=0;\\n        int dir = 0; // 0 representing north, 1 representing east, 2 representing south, 3 representing west. A concept similar to the Spiral Matrix II problem.\\n        for (int i = 0; i < instructions.size(); ++i) {\\n            if (instructions[i]==\\'G\\') {\\n                if (dir==0) y++;\\n                if (dir==1) x++;\\n                if (dir==2) y--;\\n                if (dir==3) x--;\\n            }\\n            else if (instructions[i]==\\'L\\') {\\n                dir--;\\n                dir = (dir+4)%4; // So that direction is positive after taking mod\\n            }\\n            else {\\n                dir++;\\n                dir %= 4;\\n            }\\n        }\\n        return dir!=0 || (x==0 & y==0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634298,
                "title": "for-those-who-can-t-start-tip",
                "content": "I just want to provide a direction in which people can start thinking. Start with a pen and paper trace few examples. Try to find when it will not be in a circle. The answer is when the direction on ending is same as the direction of starting. There would be 2 cases:\\n1) When the net direction is 90 or 270 it forms a square every 4 times the machine repeats the instructions.\\n2) When the net is 180 it forms a line, when it\\'s 360 it\\'s not going to be in a circle.\\n\\nOnly exception for the 360 angle is if it ends at the starting point. i.e 0 displacement.\\nIn this case it already made the journey.\\n\\nSimple code which does exactly what I mentioned\\n\\n```\\ndef isRobotBounded(self, ins: str) -> bool:\\n        direc = 0\\n        dist = [0,0,0,0]\\n        i = 0\\n        for ele in ins:\\n            if ele==\\'L\\':\\n                direc += 90\\n                i+= 1\\n            elif ele==\\'R\\':\\n                direc -= 90\\n                i-= 1\\n            else:\\n                dist[i] += 1\\n            i %=4\\n        ud = abs(dist[0] - dist[2])\\n        lr = abs(dist[1] - dist[3])\\n        # print(ud,lr)\\n        if direc%360==0 and ud+lr != 0:\\n            return False\\n        return True\\n\\t```",
                "solutionTags": [],
                "code": "```\\ndef isRobotBounded(self, ins: str) -> bool:\\n        direc = 0\\n        dist = [0,0,0,0]\\n        i = 0\\n        for ele in ins:\\n            if ele==\\'L\\':\\n                direc += 90\\n                i+= 1\\n            elif ele==\\'R\\':\\n                direc -= 90\\n                i-= 1\\n            else:\\n                dist[i] += 1\\n            i %=4\\n        ud = abs(dist[0] - dist[2])\\n        lr = abs(dist[1] - dist[3])\\n        # print(ud,lr)\\n        if direc%360==0 and ud+lr != 0:\\n            return False\\n        return True\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1459979,
                "title": "java-easy-to-understand-solution-with-explanation",
                "content": "**Understanding the Problem:**\\n\\nAs per the problem, the robot starts at (0,0) facing north and we have to find if the robot is not going to leave the circle. \\nBased on this assumption we can say - if after travelling some (x,y) distance, the robot continues to be in the north direction then the robot will leave the circle till which it has travelled till now. If it is in any other direction then we say it is going to be in the circle.\\n\\nFrom this understanding we can deduce the following -\\n- If the robot is in (x, y) plane facing northward/upward and not in the starting position (0,0) then it is **not in a circle**\\n- In all other cases the robot is considered to be **in a circle**\\n\\t- Robot is in starting position (0, 0) pointing to any direction\\n\\t- Robot is in any position (x, y) other than starting, but facing in any of the directions - East, West, South, other than North.\\n\\n**Code:**\\n```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n\\n        // Denotes the \\'N\\', \\'E\\', \\'S\\', \\'W\\' co-ordinates\\n        int dir[][] = {\\n            {0,1},  //North\\n            {1,0},  //East\\n            {0,-1}, //South\\n            {-1,0}  //West\\n        };\\n        \\n        // Co-ordinates in the dir[][] plane\\n        // dir[*][0] --> x\\n        // dir[*][1] --> y\\n        int x=0, y=0;\\n\\n        // Index denoting the direction \\n        // i = 0 --> North/Up\\n        // i = 1 --> East/Right\\n        // i = 2 --> South/Down\\n        // i = 3 --> West/Left\\n        int i=0; \\n                \\n        for(char c : instructions.toCharArray()){\\n            if(c == \\'L\\') \\n                i = (i + 3) % 4;\\n            else if(c == \\'R\\') \\n                i = (i + 1) % 4;\\n            else {\\n                x += dir[i][0]; // Calculating the x distance\\n                y += dir[i][1]; // Calculating the y distance\\n            }\\n        }\\n        return x == 0 && y == 0 || i > 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n\\n        // Denotes the \\'N\\', \\'E\\', \\'S\\', \\'W\\' co-ordinates\\n        int dir[][] = {\\n            {0,1},  //North\\n            {1,0},  //East\\n            {0,-1}, //South\\n            {-1,0}  //West\\n        };\\n        \\n        // Co-ordinates in the dir[][] plane\\n        // dir[*][0] --> x\\n        // dir[*][1] --> y\\n        int x=0, y=0;\\n\\n        // Index denoting the direction \\n        // i = 0 --> North/Up\\n        // i = 1 --> East/Right\\n        // i = 2 --> South/Down\\n        // i = 3 --> West/Left\\n        int i=0; \\n                \\n        for(char c : instructions.toCharArray()){\\n            if(c == \\'L\\') \\n                i = (i + 3) % 4;\\n            else if(c == \\'R\\') \\n                i = (i + 1) % 4;\\n            else {\\n                x += dir[i][0]; // Calculating the x distance\\n                y += dir[i][1]; // Calculating the y distance\\n            }\\n        }\\n        return x == 0 && y == 0 || i > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382214,
                "title": "c-beats-100-simple-trick-and-short-solution",
                "content": "the main idea is simple \\n\"the number of moves that he makes to the left must be equal to number of moves he takes to right \"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t**and** \\n\"the number of moves that he makes to the up must be equal to number of moves he takes to down\" \\nwe can achive that by keeping an array of lenghth 4 where index 0,1,2,3 represents the number of moves he had done in the top,left,down,right respectively. we can check to which direction we are facing by simply keeping maintaing a variable d and increase or decrease depending on the left or right reespectively.\\n ```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string A) {\\n        A=A+A+A+A;\\n        int n=A.size();\\n        int no_moves[]={0,0,0,0};\\n        // top left down right\\n        int d=0;// to detrmine the which direction am i going \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(A[i] == \\'G\\')no_moves[d]++;\\n            else if(A[i] == \\'L\\')d++;\\n            else {\\n                d+=4;\\n                d--;\\n            }\\n            d%=4;\\n        }\\n        return (no_moves[0] == no_moves[2] && no_moves[1] == no_moves[3]);\\n    }\\n};\\n```\\nupvote if you like !!!!!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string A) {\\n        A=A+A+A+A;\\n        int n=A.size();\\n        int no_moves[]={0,0,0,0};\\n        // top left down right\\n        int d=0;// to detrmine the which direction am i going \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(A[i] == \\'G\\')no_moves[d]++;\\n            else if(A[i] == \\'L\\')d++;\\n            else {\\n                d+=4;\\n                d--;\\n            }\\n            d%=4;\\n        }\\n        return (no_moves[0] == no_moves[2] && no_moves[1] == no_moves[3]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158977,
                "title": "python-very-intuitive-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    cur_dir = \\'N\\'\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        self.cur_dir = \\'N\\'\\n        cur_pos = [0,0]\\n        for ins in instructions:\\n            if ins == \\'G\\':\\n                self.ChangePos(cur_pos)\\n            else:\\n                self.ChangeDirection(ins)\\n        if cur_pos[0] == 0 and cur_pos[1] == 0:\\n            return True\\n        if self.cur_dir != \\'N\\':\\n            return True\\n        return False\\n        \\n    def ChangePos(self,cur_pos):\\n        if self.cur_dir == \\'N\\':\\n            cur_pos[1] += 1\\n        elif self.cur_dir == \\'S\\':\\n            cur_pos[1] -= 1\\n        elif self.cur_dir == \\'W\\':\\n            cur_pos[0] -= 1\\n        elif self.cur_dir == \\'E\\':\\n            cur_pos[0] += 1\\n            \\n    #think of a compass...and all possiblities of change in direction\\n    def ChangeDirection(self,d):\\n        if self.cur_dir == \\'N\\' and d == \\'L\\':\\n            self.cur_dir = \\'W\\'\\n        elif self.cur_dir == \\'N\\' and d == \\'R\\':\\n            self.cur_dir = \\'E\\'\\n        elif self.cur_dir == \\'S\\' and d == \\'L\\':\\n            self.cur_dir = \\'E\\'\\n        elif self.cur_dir == \\'S\\' and d == \\'R\\':\\n            self.cur_dir = \\'W\\'\\n        elif self.cur_dir == \\'W\\' and d == \\'L\\':\\n            self.cur_dir = \\'S\\'\\n        elif self.cur_dir == \\'W\\' and d == \\'R\\':\\n            self.cur_dir = \\'N\\'\\n        elif self.cur_dir == \\'E\\' and d == \\'L\\':\\n            self.cur_dir = \\'N\\'\\n        elif self.cur_dir == \\'E\\' and d == \\'R\\':\\n            self.cur_dir = \\'S\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    cur_dir = \\'N\\'\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        self.cur_dir = \\'N\\'\\n        cur_pos = [0,0]\\n        for ins in instructions:\\n            if ins == \\'G\\':\\n                self.ChangePos(cur_pos)\\n            else:\\n                self.ChangeDirection(ins)\\n        if cur_pos[0] == 0 and cur_pos[1] == 0:\\n            return True\\n        if self.cur_dir != \\'N\\':\\n            return True\\n        return False\\n        \\n    def ChangePos(self,cur_pos):\\n        if self.cur_dir == \\'N\\':\\n            cur_pos[1] += 1\\n        elif self.cur_dir == \\'S\\':\\n            cur_pos[1] -= 1\\n        elif self.cur_dir == \\'W\\':\\n            cur_pos[0] -= 1\\n        elif self.cur_dir == \\'E\\':\\n            cur_pos[0] += 1\\n            \\n    #think of a compass...and all possiblities of change in direction\\n    def ChangeDirection(self,d):\\n        if self.cur_dir == \\'N\\' and d == \\'L\\':\\n            self.cur_dir = \\'W\\'\\n        elif self.cur_dir == \\'N\\' and d == \\'R\\':\\n            self.cur_dir = \\'E\\'\\n        elif self.cur_dir == \\'S\\' and d == \\'L\\':\\n            self.cur_dir = \\'E\\'\\n        elif self.cur_dir == \\'S\\' and d == \\'R\\':\\n            self.cur_dir = \\'W\\'\\n        elif self.cur_dir == \\'W\\' and d == \\'L\\':\\n            self.cur_dir = \\'S\\'\\n        elif self.cur_dir == \\'W\\' and d == \\'R\\':\\n            self.cur_dir = \\'N\\'\\n        elif self.cur_dir == \\'E\\' and d == \\'L\\':\\n            self.cur_dir = \\'N\\'\\n        elif self.cur_dir == \\'E\\' and d == \\'R\\':\\n            self.cur_dir = \\'S\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851918,
                "title": "c-solution-with-notes",
                "content": "**Intuition**\\n**The first challenge is how to effectively get the new direction after making a turn.**\\nWe first define a 2-dementional array ```dirs = {{0,1}, {1,0}, {0,-1}, {-1,0}}``` to represent north, east, south and west in order, and also treat ```dirs``` as a **cyclic array**. Now let\\'s assume the current direction is ```dirs[i]```.\\n* For a right turn, we can think of the directions are: ```north -> east -> south -> west -> north ->...```. Making a right turn is equivalent to moving the current direction to its next. So the new directin will be ```dirs[(i + 1) % 4]```.\\n* For a left turn, it can be treated as moving the current direction to its previous one. So the new direction will be ```dirs[(i-1) % 4]```, since we need to ensure ```index >= 0```, so we change ```dirs[(i-1) % 4]```  to ```dirs[(i - 1 + 4) % 4]```, which is ```dirs[(i + 3) % 4]```.\\n\\n**The second challenge is how can we determine the robot can be bounded in a circle.**\\nThere are two cases where the robot will be bounded in a circle.\\n* case 1: Robot is at the original position ```(0,0)``` after finishing the instruction.\\n* case 1: Robot is not at the original position ```(0,0)``` && not facing towards north after finishing the instruction.\\n\\nIn case 1, the robot will go back the original position every time when the instruction is executed. In case 2, we can think of the path that the robot moves as below. So after executing the instruction at most 4 times, the robot will go back to the original position.\\n![image](https://assets.leetcode.com/users/images/0d740ebf-146d-4961-b70c-7ea22db818e0_1621460437.057373.png)\\n\\n\\n\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public bool IsRobotBounded(string instructions) {\\n        \\n        if(instructions == null || instructions.Length == 0)\\n            return true;\\n        \\n        int[,] dirs = new int[,]{{0,1}, {1,0}, {0,-1}, {-1,0}}; // north, east, sourth, west\\n        int i = 0, x = 0, y = 0;\\n        foreach(var c in instructions)\\n        {\\n            if(c == \\'G\\')\\n            {\\n                x += dirs[i,0];\\n                y += dirs[i,1];\\n            }\\n            else if(c == \\'L\\')\\n                i = (i + 3) % 4; // (i - 1 + 4) % 4, % is the remainder operator, -1 % 4 = -1\\n            else\\n                i = (i + 1) % 4;\\n        }\\n        \\n        return (x == 0 && y == 0) || i != 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```dirs = {{0,1}, {1,0}, {0,-1}, {-1,0}}```\n```dirs```\n```dirs[i]```\n```north -> east -> south -> west -> north ->...```\n```dirs[(i + 1) % 4]```\n```dirs[(i-1) % 4]```\n```index >= 0```\n```dirs[(i-1) % 4]```\n```dirs[(i - 1 + 4) % 4]```\n```dirs[(i + 3) % 4]```\n```(0,0)```\n```(0,0)```\n```\\npublic class Solution {\\n    public bool IsRobotBounded(string instructions) {\\n        \\n        if(instructions == null || instructions.Length == 0)\\n            return true;\\n        \\n        int[,] dirs = new int[,]{{0,1}, {1,0}, {0,-1}, {-1,0}}; // north, east, sourth, west\\n        int i = 0, x = 0, y = 0;\\n        foreach(var c in instructions)\\n        {\\n            if(c == \\'G\\')\\n            {\\n                x += dirs[i,0];\\n                y += dirs[i,1];\\n            }\\n            else if(c == \\'L\\')\\n                i = (i + 3) % 4; // (i - 1 + 4) % 4, % is the remainder operator, -1 % 4 = -1\\n            else\\n                i = (i + 1) % 4;\\n        }\\n        \\n        return (x == 0 && y == 0) || i != 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850881,
                "title": "robot-bounded-in-circle-c-easy-switch-case",
                "content": "```\\nbool isRobotBounded(string instructions) {\\n\\tpair<int,int> position = {0,0};\\n\\tconst vector<pair<int,int>> directions = {{0,1},{-1,0},{0,-1},{1,0}};\\n\\tint direction = 0;\\n\\tfor(const auto i : instructions) {\\n\\t\\tswitch(i) {\\n\\t\\t\\tcase \\'G\\':\\n\\t\\t\\t\\tposition.first += directions[direction].first;\\n\\t\\t\\t\\tposition.second += directions[direction].second;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'L\\':\\n\\t\\t\\t\\tdirection = (direction+1)%4;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'R\\':\\n\\t\\t\\t\\tdirection = (direction+3)%4;\\n\\t\\t}\\n\\t}\\n\\treturn direction != 0 || (position.first == 0 && position.second == 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isRobotBounded(string instructions) {\\n\\tpair<int,int> position = {0,0};\\n\\tconst vector<pair<int,int>> directions = {{0,1},{-1,0},{0,-1},{1,0}};\\n\\tint direction = 0;\\n\\tfor(const auto i : instructions) {\\n\\t\\tswitch(i) {\\n\\t\\t\\tcase \\'G\\':\\n\\t\\t\\t\\tposition.first += directions[direction].first;\\n\\t\\t\\t\\tposition.second += directions[direction].second;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'L\\':\\n\\t\\t\\t\\tdirection = (direction+1)%4;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'R\\':\\n\\t\\t\\t\\tdirection = (direction+3)%4;\\n\\t\\t}\\n\\t}\\n\\treturn direction != 0 || (position.first == 0 && position.second == 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850540,
                "title": "java-simple-self-explanatory-solution-o-n-beats-100",
                "content": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int direction = 0, x = 0, y = 0;\\n        for(int i = 0; i < instructions.length(); i++) {\\n            if(instructions.charAt(i) == \\'G\\') {\\n                if(direction == 0) {\\n                    y++;\\n                }\\n                else if(direction == 1) {\\n                    x--;\\n                }\\n                else if(direction == 2) {\\n                    y--;\\n                }\\n                else if(direction == 3) {\\n                    x++;\\n                }\\n            }\\n            else if(instructions.charAt(i) == \\'L\\') {\\n                direction = (direction + 1) % 4;\\n            }\\n            else if(instructions.charAt(i) == \\'R\\') {\\n                direction = direction != 0 ? (direction - 1) : 3;\\n            }\\n        }\\n        if(direction != 0 || (x == 0 && y == 0)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int direction = 0, x = 0, y = 0;\\n        for(int i = 0; i < instructions.length(); i++) {\\n            if(instructions.charAt(i) == \\'G\\') {\\n                if(direction == 0) {\\n                    y++;\\n                }\\n                else if(direction == 1) {\\n                    x--;\\n                }\\n                else if(direction == 2) {\\n                    y--;\\n                }\\n                else if(direction == 3) {\\n                    x++;\\n                }\\n            }\\n            else if(instructions.charAt(i) == \\'L\\') {\\n                direction = (direction + 1) % 4;\\n            }\\n            else if(instructions.charAt(i) == \\'R\\') {\\n                direction = direction != 0 ? (direction - 1) : 3;\\n            }\\n        }\\n        if(direction != 0 || (x == 0 && y == 0)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850464,
                "title": "python-3-simulation-explanation",
                "content": "### Explanation\\n- `direc` is the direction, `pos` is current position `[x, y]`\\n- Simulate the process and find out where the point is at for every instruction\\n- If `pos` return to origin `[0, 0]` or `direction` not facing initial state (`0`), then there is a loop\\n### Implementation\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        direc, pos = 0, [0, 0]\\n        for c in instructions:\\n            if c == \"L\": direc = (direc + 1) % 4\\n            elif c == \"R\": direc = (direc - 1) % 4\\n            elif c == \"G\":\\n                if direc == 0: pos[1] += 1\\n                elif direc == 1: pos[0] -= 1\\n                elif direc == 2: pos[1] -= 1\\n                else: pos[0] += 1\\n        return pos == [0, 0] or direc != 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        direc, pos = 0, [0, 0]\\n        for c in instructions:\\n            if c == \"L\": direc = (direc + 1) % 4\\n            elif c == \"R\": direc = (direc - 1) % 4\\n            elif c == \"G\":\\n                if direc == 0: pos[1] += 1\\n                elif direc == 1: pos[0] -= 1\\n                elif direc == 2: pos[1] -= 1\\n                else: pos[0] += 1\\n        return pos == [0, 0] or direc != 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850441,
                "title": "python-simple-solution-with-explanations",
                "content": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        # initialize position and direction to north:\\n        pos = [0,0]\\n        direc = [0,1]\\n        \\n        # example - going left:\\n        # if pos is [1,1], direction is [0,1] we want to go left - we have to add to pos [-1,0] (left in graph)\\n        # if pos is [1,1], direction is [-1,0] we want to go left - we have to add to pos [0,-1] (down in graph)\\n        # if pos is [1,1], direction is [0,-1] we want to go left - we have to add to pos [1,0] (right in graph)\\n        \\n        # that calculation brings us to the conclusion that for going left we change the direction [x,y] to [-y,x]\\n        # and for going right we change the direction [x,y] to [y,-x]\\n\\t\\t\\n        for instruct in instructions:\\n            if instruct == \"L\":\\n                direc[0], direc[1] = -direc[1], direc[0]\\n            elif instruct == \"R\":\\n                direc[0], direc[1] = direc[1], -direc[0]\\n            else:\\n                pos[0], pos[1] = pos[0]+direc[0], pos[1]+direc[1]\\n\\n        # if position got back to original, or we changed original direction\\n        if pos == [0,0] or direc != [0,1]:\\n            return True\\n        return False\\n```\\n**Like it? please upvote...**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        # initialize position and direction to north:\\n        pos = [0,0]\\n        direc = [0,1]\\n        \\n        # example - going left:\\n        # if pos is [1,1], direction is [0,1] we want to go left - we have to add to pos [-1,0] (left in graph)\\n        # if pos is [1,1], direction is [-1,0] we want to go left - we have to add to pos [0,-1] (down in graph)\\n        # if pos is [1,1], direction is [0,-1] we want to go left - we have to add to pos [1,0] (right in graph)\\n        \\n        # that calculation brings us to the conclusion that for going left we change the direction [x,y] to [-y,x]\\n        # and for going right we change the direction [x,y] to [y,-x]\\n\\t\\t\\n        for instruct in instructions:\\n            if instruct == \"L\":\\n                direc[0], direc[1] = -direc[1], direc[0]\\n            elif instruct == \"R\":\\n                direc[0], direc[1] = direc[1], -direc[0]\\n            else:\\n                pos[0], pos[1] = pos[0]+direc[0], pos[1]+direc[1]\\n\\n        # if position got back to original, or we changed original direction\\n        if pos == [0,0] or direc != [0,1]:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403284,
                "title": "javascript-o-n-simple-solution-explained",
                "content": "There are two ways to make the robot going cicrle:\\n1. after one round it returns to the start position\\n2. after one round it changes direction from the north\\n\\nSo, I decided to store separately directions and current coordinates:\\n\\n```\\n const dir = {\\n        x: 0,\\n        y: 1,\\n    }\\n  \\n    const coord = {\\n        x: 0,\\n        y: 0\\n    }\\n```\\nWhere dir object means coordinates of the vector: north means vector {0, 1}, west {1, 0}, south {0, -1} and east {-1, 0}.\\n\\nThen we just go through each letter of input and check wether it\\'s \\'G\\', \\'R\\' or \\'L\\'.\\nIn case it\\'s \\'G\\', we change our coordinates depending on dir object:\\n```\\ncoord.x += dir.x;\\ncoord.y += dir.y;\\n```\\n\\nIn case it\\'s \\'L\\' or \\'R\\' I decided to check every possible case (there are four of them depending on vector\\'s direction): x = 0 and y = 1, x = 0 and y = -1, x = 1 and y = 0, x = -1 and y = 0. There might be a better mathematical approach, if you know how to get rid of unnessary if else conditions, lmk in the comments.\\n\\nAfter going through the whole string we just need to check wether the coordinate is {0, 0} again or the vector doesn\\'t point to north (in this case we will end up coming back eventually), and in this case return true, otherwise return false.\\n\\nThe whole solution is:\\n```\\n/**\\n * @param {string} instructions\\n * @return {boolean}\\n */\\nvar isRobotBounded = function(instructions) {\\n    const dir = {\\n        x: 0,\\n        y: 1,\\n    }\\n  \\n    const coord = {\\n        x: 0,\\n        y: 0\\n    }\\n    \\n    for(let i = 0; i < instructions.length; i++) {\\n        switch(instructions[i]) {\\n            case \\'G\\':\\n                coord.x += dir.x;\\n                coord.y += dir.y;\\n                break;\\n            case \\'L\\':\\n                if(dir.x === 0 && dir.y === 1) {\\n                    dir.x = -1;\\n                    dir.y = 0;\\n                } else if(dir.x === 0 && dir.y === -1) {\\n                    dir.x = 1;\\n                    dir.y = 0;\\n                } else if(dir.y === 0 && dir.x === -1){\\n                    dir.y = -1;\\n                    dir.x = 0;\\n                } else if(dir.y === 0 && dir.x === 1) {\\n                    dir.y = 1;\\n                    dir.x = 0;\\n                }\\n                break;\\n            case \\'R\\':\\n                if(dir.x === 0 && dir.y === 1) {\\n                    dir.x = 1;\\n                    dir.y = 0;\\n                } else if(dir.x === 0 && dir.y === -1) {\\n                    dir.x = -1;\\n                    dir.y = 0;\\n                } else if(dir.x === -1 && dir.y === 0) {\\n                    dir.y = 1;\\n                    dir.x = 0;\\n                } else if(dir.x === 1 && dir.y === 0) {\\n                    dir.y = -1;\\n                    dir.x = 0;\\n                }\\n                break;\\n        }\\n    }\\n            \\n    if(coord.x === 0 && coord.y === 0) return true;\\n    if(dir.y !== 1) return true;\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n const dir = {\\n        x: 0,\\n        y: 1,\\n    }\\n  \\n    const coord = {\\n        x: 0,\\n        y: 0\\n    }\\n```\n```\\ncoord.x += dir.x;\\ncoord.y += dir.y;\\n```\n```\\n/**\\n * @param {string} instructions\\n * @return {boolean}\\n */\\nvar isRobotBounded = function(instructions) {\\n    const dir = {\\n        x: 0,\\n        y: 1,\\n    }\\n  \\n    const coord = {\\n        x: 0,\\n        y: 0\\n    }\\n    \\n    for(let i = 0; i < instructions.length; i++) {\\n        switch(instructions[i]) {\\n            case \\'G\\':\\n                coord.x += dir.x;\\n                coord.y += dir.y;\\n                break;\\n            case \\'L\\':\\n                if(dir.x === 0 && dir.y === 1) {\\n                    dir.x = -1;\\n                    dir.y = 0;\\n                } else if(dir.x === 0 && dir.y === -1) {\\n                    dir.x = 1;\\n                    dir.y = 0;\\n                } else if(dir.y === 0 && dir.x === -1){\\n                    dir.y = -1;\\n                    dir.x = 0;\\n                } else if(dir.y === 0 && dir.x === 1) {\\n                    dir.y = 1;\\n                    dir.x = 0;\\n                }\\n                break;\\n            case \\'R\\':\\n                if(dir.x === 0 && dir.y === 1) {\\n                    dir.x = 1;\\n                    dir.y = 0;\\n                } else if(dir.x === 0 && dir.y === -1) {\\n                    dir.x = -1;\\n                    dir.y = 0;\\n                } else if(dir.x === -1 && dir.y === 0) {\\n                    dir.y = 1;\\n                    dir.x = 0;\\n                } else if(dir.x === 1 && dir.y === 0) {\\n                    dir.y = -1;\\n                    dir.x = 0;\\n                }\\n                break;\\n        }\\n    }\\n            \\n    if(coord.x === 0 && coord.y === 0) return true;\\n    if(dir.y !== 1) return true;\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2266083,
                "title": "python-simple-solution-with-detailed-explanation",
                "content": "# Explanation\\nWe use simulation to simulate the path the robot goes in. We know if the robot will end up in a circle if it ends back where it is (`x` and `y` both are `0`) or the robot isn\\'t still facing the same direction (direction change is sitll `0, 1`)\\n\\nSo, in the end we only need to check if `x` and `y` are the same or if `di` is still `(0, 1)` north.\\n__________________________________________________________________________________________\\nWe also don\\'t need to store a whole array of directions: to swap the following directions:\\n**left** - set `dx` the opposite of `dy` and `dy` as `dx`. \\n**right** - set `dy` to the opposite of `dx` and `dx` as `dy`.\\nThis is a bit tricky, but once you expand it you\\'ll get it.\\n\\n#### In-Depth Code Explanation\\n1. Define `di` as a tuple where `di[0]` is the change of `x` and `di[1]` is the change of `y`\\n2. Define `x` and `y` coordinates\\n3. Iterate through the list of instructions:\\n4. If the instruction is `\\'G\\'`: add `di` to `x` and `y` (make them move forward in same direction)\\n5. If the instruction is `\\'L\\'`: turn robot left (see above for detailed explanation for how)\\n6. If the instruction is `\\'R\\'`: turn robot right (see above for detailed explanation for how)\\n7. Check if `x` and `y` are still `0` or if `di` is not still `(0, 1)`\\n\\n```py\\nclass Solution(object):\\n    def isRobotBounded(self, instructions):\\n        \"\"\"\\n        :type instructions: str\\n        :rtype: bool\\n        \"\"\"\\n        di = (0,1)\\n        x, y = 0, 0\\n        for instruction in instructions:\\n            if instruction == \\'G\\':\\n                x, y = x + di[0], y + di[1]\\n            elif instruction == \\'L\\':\\n                di = (-di[1], di[0])\\n            elif instruction == \\'R\\':\\n                di = (di[1], -di[0])\\n            \\n        return (x == 0 and y == 0) or di != (0, 1)\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution(object):\\n    def isRobotBounded(self, instructions):\\n        \"\"\"\\n        :type instructions: str\\n        :rtype: bool\\n        \"\"\"\\n        di = (0,1)\\n        x, y = 0, 0\\n        for instruction in instructions:\\n            if instruction == \\'G\\':\\n                x, y = x + di[0], y + di[1]\\n            elif instruction == \\'L\\':\\n                di = (-di[1], di[0])\\n            elif instruction == \\'R\\':\\n                di = (di[1], -di[0])\\n            \\n        return (x == 0 and y == 0) or di != (0, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252616,
                "title": "python-simple-solution-using-dict-no-maths",
                "content": "Hello, I have a simpler solution that involves less of maths and more of logical thinking. \\n\\n```\\n\\tdef isRobotBounded(self, instructions: str) -> bool:\\n        curr_dir = \\'N\\'\\n        curr_pos = [0,0]\\n        directions = {\\'N\\':[0,1], \\'E\\':[1,0], \\'W\\':[-1,0], \\'S\\':[0,-1]}\\n        change_dir = {\\n            \\'N\\':{\\'L\\':\\'W\\', \\'R\\':\\'E\\'},\\n            \\'E\\':{\\'L\\':\\'N\\', \\'R\\':\\'S\\'},\\n            \\'W\\':{\\'L\\':\\'S\\', \\'R\\':\\'N\\'},\\n            \\'S\\':{\\'L\\':\\'E\\', \\'R\\':\\'W\\'}\\n        }\\n        for instruction in instructions:\\n            if instruction == \\'G\\':\\n                curr_pos[1] += directions[curr_dir][1]\\n                curr_pos[0] += directions[curr_dir][0]\\n            else:\\n                curr_dir=change_dir[curr_dir][instruction]\\n        if curr_dir != \\'N\\' or curr_pos == [0,0]:\\n            return True\\n        else:\\n            return False\\n```\\n\\n\\nHope it helps!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\tdef isRobotBounded(self, instructions: str) -> bool:\\n        curr_dir = \\'N\\'\\n        curr_pos = [0,0]\\n        directions = {\\'N\\':[0,1], \\'E\\':[1,0], \\'W\\':[-1,0], \\'S\\':[0,-1]}\\n        change_dir = {\\n            \\'N\\':{\\'L\\':\\'W\\', \\'R\\':\\'E\\'},\\n            \\'E\\':{\\'L\\':\\'N\\', \\'R\\':\\'S\\'},\\n            \\'W\\':{\\'L\\':\\'S\\', \\'R\\':\\'N\\'},\\n            \\'S\\':{\\'L\\':\\'E\\', \\'R\\':\\'W\\'}\\n        }\\n        for instruction in instructions:\\n            if instruction == \\'G\\':\\n                curr_pos[1] += directions[curr_dir][1]\\n                curr_pos[0] += directions[curr_dir][0]\\n            else:\\n                curr_dir=change_dir[curr_dir][instruction]\\n        if curr_dir != \\'N\\' or curr_pos == [0,0]:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2029141,
                "title": "clean-and-clear-python-solution-easy-to-understand",
                "content": "An interesting question!\\n\\n**Two cases** that could make the robot never leaves the circle:\\n**Case 1**: Return to (0, 0).\\n**Case 2**: Face other directions.\\n\\n**Time:** O(n)\\n**Space:** O(1)\\n\\n```\\nDIRECTIONS = {\\n    0: (0, 1),\\n    1: (-1, 0),\\n    2: (0, -1),\\n    3: (1, 0)\\n}\\n\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        \\n        x = y = 0\\n        face = 0\\n        \\n        for i in instructions:\\n            if i == \"L\":\\n                face = (face + 1) % 4\\n            elif i == \"R\":\\n                face = (face + 3) % 4\\n            else:\\n                x += DIRECTIONS[face][0]\\n                y += DIRECTIONS[face][1]\\n\\n        return (x == 0 and y == 0) or face != 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nDIRECTIONS = {\\n    0: (0, 1),\\n    1: (-1, 0),\\n    2: (0, -1),\\n    3: (1, 0)\\n}\\n\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        \\n        x = y = 0\\n        face = 0\\n        \\n        for i in instructions:\\n            if i == \"L\":\\n                face = (face + 1) % 4\\n            elif i == \"R\":\\n                face = (face + 3) % 4\\n            else:\\n                x += DIRECTIONS[face][0]\\n                y += DIRECTIONS[face][1]\\n\\n        return (x == 0 and y == 0) or face != 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949358,
                "title": "easy-java-solution-using-hashmap-1ms",
                "content": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        char[] ins = instructions.toCharArray();\\n        \\n        int[] start = new int[]{0,0};\\n        \\n        Map<Character, int[]> map = new HashMap<>();\\n        map.put(\\'N\\',new int[]{0,1});\\n        map.put(\\'S\\',new int[]{0,-1});\\n        map.put(\\'E\\',new int[]{1,0});\\n        map.put(\\'W\\',new int[]{-1,0});\\n        char facing = \\'N\\';\\n        int i =0;\\n       \\n        while(i < ins.length){\\n            if(ins[i] == \\'G\\'){\\n                start[0] = start[0]+map.get(facing)[0];\\n                start[1] = start[1]+map.get(facing)[1];\\n            } else if(ins[i] == \\'L\\'){\\n                if(facing == \\'N\\') facing = \\'W\\';\\n                else if(facing == \\'W\\') facing = \\'S\\';\\n                else if(facing == \\'S\\') facing = \\'E\\';\\n                else if(facing == \\'E\\') facing = \\'N\\';\\n            } else if(ins[i] == \\'R\\'){\\n                if(facing == \\'N\\') facing = \\'E\\';\\n                else if(facing == \\'E\\') facing = \\'S\\';\\n                else if(facing == \\'S\\') facing = \\'W\\';\\n                else if(facing == \\'W\\') facing = \\'N\\';\\n            }\\n            i++;\\n         \\n        }\\n        if(start[0] == 0 && start[1] == 0) return true;\\n        if(facing == \\'N\\') return false;// This means, robot will go out of circle\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        char[] ins = instructions.toCharArray();\\n        \\n        int[] start = new int[]{0,0};\\n        \\n        Map<Character, int[]> map = new HashMap<>();\\n        map.put(\\'N\\',new int[]{0,1});\\n        map.put(\\'S\\',new int[]{0,-1});\\n        map.put(\\'E\\',new int[]{1,0});\\n        map.put(\\'W\\',new int[]{-1,0});\\n        char facing = \\'N\\';\\n        int i =0;\\n       \\n        while(i < ins.length){\\n            if(ins[i] == \\'G\\'){\\n                start[0] = start[0]+map.get(facing)[0];\\n                start[1] = start[1]+map.get(facing)[1];\\n            } else if(ins[i] == \\'L\\'){\\n                if(facing == \\'N\\') facing = \\'W\\';\\n                else if(facing == \\'W\\') facing = \\'S\\';\\n                else if(facing == \\'S\\') facing = \\'E\\';\\n                else if(facing == \\'E\\') facing = \\'N\\';\\n            } else if(ins[i] == \\'R\\'){\\n                if(facing == \\'N\\') facing = \\'E\\';\\n                else if(facing == \\'E\\') facing = \\'S\\';\\n                else if(facing == \\'S\\') facing = \\'W\\';\\n                else if(facing == \\'W\\') facing = \\'N\\';\\n            }\\n            i++;\\n         \\n        }\\n        if(start[0] == 0 && start[1] == 0) return true;\\n        if(facing == \\'N\\') return false;// This means, robot will go out of circle\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678874,
                "title": "python-o-n-time-o-1-space-simple-solution",
                "content": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        direction = 0\\n        distX = 0\\n        distY = 0\\n        for instruction in instructions:\\n            if instruction == \\'L\\':\\n                direction -= 90\\n            elif instruction == \\'R\\':\\n                direction += 90\\n            else:\\n                if direction == 0:\\n                    distY += 1\\n                elif direction == 90 or direction == -270:\\n                    distX += 1\\n                elif direction == -90 or direction == 270:\\n                    distX -= 1\\n                else:\\n                    distY -= 1\\n            direction %= 360\\n        return direction != 0 or (distX == 0 and distY == 0)\\n```\\n\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        direction = 0\\n        distX = 0\\n        distY = 0\\n        for instruction in instructions:\\n            if instruction == \\'L\\':\\n                direction -= 90\\n            elif instruction == \\'R\\':\\n                direction += 90\\n            else:\\n                if direction == 0:\\n                    distY += 1\\n                elif direction == 90 or direction == -270:\\n                    distX += 1\\n                elif direction == -90 or direction == 270:\\n                    distX -= 1\\n                else:\\n                    distY -= 1\\n            direction %= 360\\n        return direction != 0 or (distX == 0 and distY == 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678663,
                "title": "simplest-solution-c",
                "content": "- Idea is to traverse the whole string and check how far we can go in every four direction `+ x, - x, + y, - y`.\\n- after sufficient iteration I store the max values. \\n- then again iterate over string several times. \\n- at the end I compare if the `stored_maximum`, `stored_minimum` values still same with the updated `maxs, mins` or not.\\n- rest is the implementation\\n\\n```cpp\\nclass Solution {\\n    public:\\n    int max_x, max_y, min_x, min_y;\\n    int x, y;\\n    bool is_vertical;\\n    bool is_positive;\\n\\n    void update() {\\n        max_x = max(max_x, x);\\n        min_x = min(min_x, x);\\n        max_y = max(max_y, y);\\n        min_y = min(min_y, y);\\n    }\\n    void traverse(const string &s) {\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'G\\') {\\n                if (is_vertical)\\n                    (is_positive) ? y++ : y--;\\n                else\\n                    (is_positive) ? x++ : x--;\\n                update();\\n            } else if (s[i] == \\'L\\') {\\n                if (is_vertical)\\n                    (is_positive) ? (is_vertical = is_positive = false)\\n                    : (is_vertical = false, is_positive = true);\\n                else\\n                    (is_positive) ? (is_vertical = is_positive = true)\\n                    : (is_vertical = true, is_positive = false);\\n\\n            } else {\\n                if (is_vertical)\\n                    (is_positive) ? (is_vertical = false, is_positive = true)\\n                    : (is_vertical = false, is_positive = false);\\n                else\\n                    (is_positive) ? (is_vertical = true, is_positive = false)\\n                    : (is_vertical = true, is_positive = true);\\n            }\\n        }\\n    }\\n    bool isRobotBounded(string s) {\\n        max_x = INT_MIN, max_y = INT_MIN, min_x = INT_MAX, min_y = INT_MAX;\\n        x = 0, y = 0;\\n        is_vertical = false;\\n        is_positive = true;\\n\\n        for (int i = 0; i <= s.size(); i++)\\n            traverse(s);\\n\\n        int curr_max_x = max_x, curr_mx_y = max_y;\\n        int curr_min_x = min_x, curr_mn_y = min_y;\\n\\n        for (int i = 0; i < s.size(); i++)\\n            traverse(s);\\n\\n        return (curr_max_x == max_x and curr_mx_y == max_y and\\n                curr_min_x == min_x and curr_mn_y == min_y)\\n            ? true\\n            : false;\\n    }\\n} ob;\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\n    public:\\n    int max_x, max_y, min_x, min_y;\\n    int x, y;\\n    bool is_vertical;\\n    bool is_positive;\\n\\n    void update() {\\n        max_x = max(max_x, x);\\n        min_x = min(min_x, x);\\n        max_y = max(max_y, y);\\n        min_y = min(min_y, y);\\n    }\\n    void traverse(const string &s) {\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'G\\') {\\n                if (is_vertical)\\n                    (is_positive) ? y++ : y--;\\n                else\\n                    (is_positive) ? x++ : x--;\\n                update();\\n            } else if (s[i] == \\'L\\') {\\n                if (is_vertical)\\n                    (is_positive) ? (is_vertical = is_positive = false)\\n                    : (is_vertical = false, is_positive = true);\\n                else\\n                    (is_positive) ? (is_vertical = is_positive = true)\\n                    : (is_vertical = true, is_positive = false);\\n\\n            } else {\\n                if (is_vertical)\\n                    (is_positive) ? (is_vertical = false, is_positive = true)\\n                    : (is_vertical = false, is_positive = false);\\n                else\\n                    (is_positive) ? (is_vertical = true, is_positive = false)\\n                    : (is_vertical = true, is_positive = true);\\n            }\\n        }\\n    }\\n    bool isRobotBounded(string s) {\\n        max_x = INT_MIN, max_y = INT_MIN, min_x = INT_MAX, min_y = INT_MAX;\\n        x = 0, y = 0;\\n        is_vertical = false;\\n        is_positive = true;\\n\\n        for (int i = 0; i <= s.size(); i++)\\n            traverse(s);\\n\\n        int curr_max_x = max_x, curr_mx_y = max_y;\\n        int curr_min_x = min_x, curr_mn_y = min_y;\\n\\n        for (int i = 0; i < s.size(); i++)\\n            traverse(s);\\n\\n        return (curr_max_x == max_x and curr_mx_y == max_y and\\n                curr_min_x == min_x and curr_mn_y == min_y)\\n            ? true\\n            : false;\\n    }\\n} ob;\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678536,
                "title": "java-clear-crisp-approach-logic",
                "content": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        \\n        int x = 0 , y = 0 ;\\n        // Initial Coordinate of  Robot(0,0)\\n        \\n        char currDirection = \\'N\\' ;\\n        // Initial Direction of our Robot         \\n        for(int i = 0 ; i < instructions.length() ; i++){\\n            \\n            //If the current instruction is \\'G\\' that means we need to check the current Direction of the Robot\\n            if(instructions.charAt(i) == \\'G\\'){\\n                y += currDirection == \\'N\\'? 1 : 0 ;  // If Robot goes North that means it gains a coordinate in y-axis \\n                y += currDirection == \\'S\\'?-1 : 0 ;  // If Robot goes South that means it loses a coordinate in y-axis \\n                x += currDirection == \\'E\\'? 1 : 0 ;  // If Robot goes East that means it gains a coordinate in x-axis \\n                x += currDirection == \\'W\\'?-1 : 0 ;  // If Robot goes West that means it loses a coordinate in x-axis \\n                \\n            }\\n            // If current Instruction is not \\'G\\' i.e it is either \\'L\\' or \\'R\\' int that case we have to change the current Direction of the Robot\\n            else{\\n                char ch = instructions.charAt(i) ; // ch holds current instruction\\n                \\n                /*\\n                 * If Robot is facing \\'North\\' and the instruction we got is \\'L\\' then the new direction\\n                 *       will be \\'West\\' \\n                 * else if it is \\'R\\' then new Direction\\n                 *       will be \\'East\\'\\n                */\\n                if(currDirection == \\'N\\'){\\n                    currDirection = ch==\\'L\\' ? \\'W\\' : \\'E\\';\\n                }\\n                \\n                /*\\n                 * If Robot is facing \\'West\\' and the instruction we got is \\'L\\' then the new direction\\n                 *       will be \\'South\\' \\n                 * else if it is \\'R\\' then new Direction\\n                 *       will be \\'North\\'\\n                */\\n                else if(currDirection == \\'W\\'){\\n                    currDirection = ch==\\'L\\' ? \\'S\\' : \\'N\\';\\n                }\\n                \\n                /*\\n                 * If Robot is facing \\'South\\' and the instruction we got is \\'L\\' then the new direction\\n                 *       will be \\'East\\' \\n                 * else if it is \\'R\\' then new Direction\\n                 *       will be \\'West\\'\\n                */\\n                else if(currDirection == \\'S\\'){\\n                    currDirection = ch==\\'L\\' ? \\'E\\' : \\'W\\';\\n                }\\n                \\n                /*\\n                 * If Robot is facing \\'East\\' and the instruction we got is \\'L\\' then the new direction\\n                 *       will be \\'North\\' \\n                 * else if it is \\'R\\' then new Direction\\n                 *       will be \\'South\\'\\n                */\\n                else if(currDirection == \\'E\\'){\\n                    currDirection = ch==\\'L\\' ? \\'N\\' : \\'S\\' ;\\n                }\\n                \\n            }\\n            \\n        }\\n        /*Observation*/\\n        if((x==0 && y==0) || currDirection != \\'N\\' ){\\n            return true ;\\n        }\\n        return false ;\\n    }\\n}\\n```\\n**Observation :**\\n1.   If on complete execution of instruction the final direction is \\'**N**\\' this means no matter how many times we execute the instructions again and again the direction will not change i,e the Robot will go infinitely to \\'**N**\\' direction only and never return to the original starting point.\\n \\n2.  If on complete execution of instruction the final direction is either of \\'**S**\\' or \\'**E**\\' or \\'**W**\\' this means the Robot may be far from original starting point but it  has made some progress in terms of direction.\\nAfter  some other repetation of instructions there definitaly will come a point where it will be back to its starting position.\\n\\nThink practically, suppose there are only 2 directions right and left.\\nIf you go to a certain distance and at the end you face in other direction and repeat the same instruction, you will be back at the original starting point.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        \\n        int x = 0 , y = 0 ;\\n        // Initial Coordinate of  Robot(0,0)\\n        \\n        char currDirection = \\'N\\' ;\\n        // Initial Direction of our Robot         \\n        for(int i = 0 ; i < instructions.length() ; i++){\\n            \\n            //If the current instruction is \\'G\\' that means we need to check the current Direction of the Robot\\n            if(instructions.charAt(i) == \\'G\\'){\\n                y += currDirection == \\'N\\'? 1 : 0 ;  // If Robot goes North that means it gains a coordinate in y-axis \\n                y += currDirection == \\'S\\'?-1 : 0 ;  // If Robot goes South that means it loses a coordinate in y-axis \\n                x += currDirection == \\'E\\'? 1 : 0 ;  // If Robot goes East that means it gains a coordinate in x-axis \\n                x += currDirection == \\'W\\'?-1 : 0 ;  // If Robot goes West that means it loses a coordinate in x-axis \\n                \\n            }\\n            // If current Instruction is not \\'G\\' i.e it is either \\'L\\' or \\'R\\' int that case we have to change the current Direction of the Robot\\n            else{\\n                char ch = instructions.charAt(i) ; // ch holds current instruction\\n                \\n                /*\\n                 * If Robot is facing \\'North\\' and the instruction we got is \\'L\\' then the new direction\\n                 *       will be \\'West\\' \\n                 * else if it is \\'R\\' then new Direction\\n                 *       will be \\'East\\'\\n                */\\n                if(currDirection == \\'N\\'){\\n                    currDirection = ch==\\'L\\' ? \\'W\\' : \\'E\\';\\n                }\\n                \\n                /*\\n                 * If Robot is facing \\'West\\' and the instruction we got is \\'L\\' then the new direction\\n                 *       will be \\'South\\' \\n                 * else if it is \\'R\\' then new Direction\\n                 *       will be \\'North\\'\\n                */\\n                else if(currDirection == \\'W\\'){\\n                    currDirection = ch==\\'L\\' ? \\'S\\' : \\'N\\';\\n                }\\n                \\n                /*\\n                 * If Robot is facing \\'South\\' and the instruction we got is \\'L\\' then the new direction\\n                 *       will be \\'East\\' \\n                 * else if it is \\'R\\' then new Direction\\n                 *       will be \\'West\\'\\n                */\\n                else if(currDirection == \\'S\\'){\\n                    currDirection = ch==\\'L\\' ? \\'E\\' : \\'W\\';\\n                }\\n                \\n                /*\\n                 * If Robot is facing \\'East\\' and the instruction we got is \\'L\\' then the new direction\\n                 *       will be \\'North\\' \\n                 * else if it is \\'R\\' then new Direction\\n                 *       will be \\'South\\'\\n                */\\n                else if(currDirection == \\'E\\'){\\n                    currDirection = ch==\\'L\\' ? \\'N\\' : \\'S\\' ;\\n                }\\n                \\n            }\\n            \\n        }\\n        /*Observation*/\\n        if((x==0 && y==0) || currDirection != \\'N\\' ){\\n            return true ;\\n        }\\n        return false ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678163,
                "title": "detailed-explanation-of-lee215-solution-intution-code-with-comments",
                "content": "**Intution**\\n// There are two cases in which the robot never leaves a circle\\n1) After the first iteration, the final coordinates of Robot are same as initial coordinates (i.e. [0,0])\\n2) If after first iteration the final coordinates are different but it points in some other direction except North, then in that case it will return to its initial position([0,0]) after max 3 more iterations.\\n    2.1) Suppose after first iteration it points in East Direction (90 degree clockwise) then after second iteration it will point in South Direction (90 degree clockwise) then after third iteration in West then in fourth iteration in North Direction (back to its origin)\\n    2.2) Suppose after first iteration it points in South Direction (180 degree clockwise) then after second iteration it will point in North Direction (180 degree clockwise) then after third iteration in South then in fourth iteration in North Direction (back to its origin)\\n    2.3) Suppose after first iteration it points in West Direction (270 degree clockwise) then after second iteration it will point in South Direction (180 degree clockwise) then after third iteration in East then in fourth iteration in North Direction (back to its origin).\\n  \\n// There is one case in which robot will leave a circle    \\n\\n 1. If robot points in North direction with different coordinates than its initial position after first iteration, then in second, third abd fourth iterations, it will continue to move forward inn north direction and will never comeback to origin\\n    \\n**Code Expanation**\\nLet the directions be\\nNorth = 0\\nEast = 1\\nSouth = 2\\nWest = 3\\n    \\nSo if robot is facing in North and we move it left, then it points in East direction i.e i+1. (since north is 0 and east is 1)\\n   if robot is facing in North and we move it right, then it points in West direction i.e i+3. (since north is 0 and west is 3)\\n      \\nGeneralising if we move the robot in Left then i=(i+1)%4\\n             if we move the ronot in Right then i=(i+3)%4\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {        \\n        int x=0, y=0;\\n        int i = 0;\\n        vector<vector<int>>dir ={{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        for(auto it: instructions) {\\n            if(it==\\'G\\') { //Moving it in the direction its pointing by one step\\n                x+=dir[i][0];\\n                y+=dir[i][1];\\n            }\\n            else if(it==\\'L\\') { //changing the direction rotating it 270 degree clockwise\\n                i=(i+3)%4;\\n            }\\n            else if(it==\\'R\\') { //changing the direction rotating it 90 degree clockwise\\n                i=(i+1)%4;\\n            }\\n        }\\n        // After one iteration either it doesnt point in north direction or it returns back to its initial coordinates{0,0}\\n        return (i!=0) || (x==0 && y==0);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {        \\n        int x=0, y=0;\\n        int i = 0;\\n        vector<vector<int>>dir ={{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        for(auto it: instructions) {\\n            if(it==\\'G\\') { //Moving it in the direction its pointing by one step\\n                x+=dir[i][0];\\n                y+=dir[i][1];\\n            }\\n            else if(it==\\'L\\') { //changing the direction rotating it 270 degree clockwise\\n                i=(i+3)%4;\\n            }\\n            else if(it==\\'R\\') { //changing the direction rotating it 90 degree clockwise\\n                i=(i+1)%4;\\n            }\\n        }\\n        // After one iteration either it doesnt point in north direction or it returns back to its initial coordinates{0,0}\\n        return (i!=0) || (x==0 && y==0);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677481,
                "title": "javascript-98-runtime-80-memory-usage-explained",
                "content": "Robot\\'s position is changed only if **G** instruction is executed. For **L** and **R** instructions only direction is changed. \\nTo track the position of the robot we need one variable ***dir*** which tells us that how the coordinates of the robot are changed if it moves to **east**, **west**, **north** or **south** direction.\\n\\n* **East**: x + 1, y \\n* **West**: x - 1, y\\n* **North**: x, y + 1\\n* **South**: x, y - 1 \\n\\nNow, We have to track that if robot follows instructions either ***G***, ***L*** or ***R*** then in which direction its face would be.\\nLet\\'s say currently robot\\'s face is in **North** direction and following instructions are executed.\\n* Instruction ***G***: **North** facing\\n* Instruction ***L***: **West** facing\\n* Instruction ***R***: **East** facing\\n\\nSimilarly, We keep all other scenarios in the ***face*** variable.\\n\\n**Algorithm:**\\n1. create ***dir*** and ***face*** variables as discussed above.\\n2. Initialize robot\\'s initial position and direction\\n3. Execute the instructions.\\n4. For each instruction, Change the position and direction\\n5. After executing all the instructions, \\n\\t\\t1. If robots reaches its initial position then return true; or\\n\\t\\t2. If its face is not in the North direction then return true\\n\\t\\t3. Otherwise, return false\\n\\n\\n\\n\\n\\n\\n```\\n/**\\n * @param {string} instructions\\n * @return {boolean}\\n */\\nvar isRobotBounded = function(instructions) {\\n    const dir = {\\n        E: [1, 0],\\n        W: [-1, 0],\\n        N: [0, 1],\\n        S: [0, -1]\\n    };\\n    \\n    const face = {\\n        E: {\\n            G: \\'E\\',\\n            L: \\'N\\',\\n            R: \\'S\\'\\n        },\\n        W: {\\n            G: \\'W\\',\\n            L: \\'S\\',\\n            R: \\'N\\'\\n        },\\n        N: {\\n            G: \\'N\\',\\n            L: \\'W\\',\\n            R: \\'E\\'\\n        },\\n        S: {\\n            G: \\'S\\',\\n            L: \\'E\\',\\n            R: \\'W\\'\\n        }\\n    }\\n    \\n    let faced = \\'N\\';\\n    let pos = {\\n        x: 0,\\n        y: 0\\n    }\\n    \\n    for(let i = 0; i < instructions.length; i++) {\\n        if(instructions[i] === \\'G\\') {\\n            pos.x += dir[faced][0];\\n            pos.y += dir[faced][1];   \\n        }\\n        faced = face[faced][instructions[i]];\\n    }\\n    \\n    if((pos.x === 0 && pos.y === 0) || faced !== \\'N\\') {\\n        return true;\\n    }\\n    \\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {string} instructions\\n * @return {boolean}\\n */\\nvar isRobotBounded = function(instructions) {\\n    const dir = {\\n        E: [1, 0],\\n        W: [-1, 0],\\n        N: [0, 1],\\n        S: [0, -1]\\n    };\\n    \\n    const face = {\\n        E: {\\n            G: \\'E\\',\\n            L: \\'N\\',\\n            R: \\'S\\'\\n        },\\n        W: {\\n            G: \\'W\\',\\n            L: \\'S\\',\\n            R: \\'N\\'\\n        },\\n        N: {\\n            G: \\'N\\',\\n            L: \\'W\\',\\n            R: \\'E\\'\\n        },\\n        S: {\\n            G: \\'S\\',\\n            L: \\'E\\',\\n            R: \\'W\\'\\n        }\\n    }\\n    \\n    let faced = \\'N\\';\\n    let pos = {\\n        x: 0,\\n        y: 0\\n    }\\n    \\n    for(let i = 0; i < instructions.length; i++) {\\n        if(instructions[i] === \\'G\\') {\\n            pos.x += dir[faced][0];\\n            pos.y += dir[faced][1];   \\n        }\\n        faced = face[faced][instructions[i]];\\n    }\\n    \\n    if((pos.x === 0 && pos.y === 0) || faced !== \\'N\\') {\\n        return true;\\n    }\\n    \\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677136,
                "title": "c-100-faster",
                "content": "* Key Observation \\n\\t* If the robot follows the same path 4 times and reaches the starting point then answer is true else it is false \\n* Code \\n\\t* ``` move ``` function returns the final co-ordinates after following the given path and starting co-ordinates\\n   \\n   \\n ````\\n \\n class Solution {\\npublic:\\n    \\n    pair<int,int> move(int x,int y,string &path)\\n    {\\n        \\n        int dx[4]={0,1,0,-1};\\n        int dy[4]={1,0,-1,0};\\n        \\n        int curr=0;\\n        \\n        int i=0;\\n        while(i<path.size())\\n        {\\n            if(path[i]==\\'G\\')\\n            {\\n                x+=dx[curr];\\n                y+=dy[curr];\\n            }\\n            else if(path[i]==\\'R\\')\\n            {\\n                curr=(curr+1)%4;\\n            }\\n            \\n            else\\n            {\\n                if(curr==0)curr=3;\\n                else curr--;\\n            }        \\n        \\n            \\n            i++;\\n        }\\n        pair<int,int> ret={x,y};\\n        return ret;\\n    }\\n    bool isRobotBounded(string p) {\\n     \\n        string path=p;\\n        path+=path;\\n        path+=path;\\n        pair<int,int> last =move(0,0,path);\\n\\n        if(last.first==0&&last.second==0)return true;\\n        return false;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "``` move ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1676677,
                "title": "c-with-clear-explanation",
                "content": "After one simulation, there are 3 situations:\\n1. the Destination == Origin, in this case, the robot will always be trapped in a circle. (easy to understand)\\n2. the Destination != Origin && new_direction == old_direction, in this case, the robot will head towards one direction forever, so return false.\\n3. the Destination != Origin && new_direction != old_direction.\\n\\tThis case is a little bit complex.\\n\\tDraw a line between Destination and Origin, when you repeat the instructions, there will be edges that can build up a rectangle. (if we allow the robot to move in all directions, rectangle will be replaced by a equilateral polygon.)\\n\\tSo actually there is only one situation that we need to return false.\\n```\\nclass Solution {\\npublic:\\n    const int\\n        NORTH = 0,\\n        EAST = 1,\\n        SOUTH = 2,\\n        WEST = 3;\\n\\n\\n    bool isRobotBounded(string instructions) {\\n        int x = 0, y = 0; // init position;\\n        int dir = NORTH;\\n        for(int i = 0; instructions[i]; i++) {\\n            if (instructions[i] == \\'L\\') {\\n                dir = (dir - 1 + 4) % 4;\\n            } else if (instructions[i] == \\'R\\') {\\n                dir = (dir + 1 + 4) % 4;\\n            } else {\\n                switch(dir) {\\n                    case 0:\\n                        y += 1;\\n                        break;\\n                    case 2:\\n                        y -= 1;\\n                        break;\\n                    case 3:\\n                        x -= 1;\\n                        break;\\n                    case 1:\\n                        x += 1;\\n                        break;\\n                }\\n            }\\n        }\\n        if ((x != 0 || y != 0) && dir == NORTH)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int\\n        NORTH = 0,\\n        EAST = 1,\\n        SOUTH = 2,\\n        WEST = 3;\\n\\n\\n    bool isRobotBounded(string instructions) {\\n        int x = 0, y = 0; // init position;\\n        int dir = NORTH;\\n        for(int i = 0; instructions[i]; i++) {\\n            if (instructions[i] == \\'L\\') {\\n                dir = (dir - 1 + 4) % 4;\\n            } else if (instructions[i] == \\'R\\') {\\n                dir = (dir + 1 + 4) % 4;\\n            } else {\\n                switch(dir) {\\n                    case 0:\\n                        y += 1;\\n                        break;\\n                    case 2:\\n                        y -= 1;\\n                        break;\\n                    case 3:\\n                        x -= 1;\\n                        break;\\n                    case 1:\\n                        x += 1;\\n                        break;\\n                }\\n            }\\n        }\\n        if ((x != 0 || y != 0) && dir == NORTH)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348726,
                "title": "c-easy-understanding-with-comments-and-explantion",
                "content": "```\\n/**\\n * @brief \\n * A robot stands on initially stands at (0, 0) and face North.\\n * Using G, L, R instruction to assemble a command\\n * Return true, if exists a circle.\\n \\n * [Important] \\n *  Key of this question is the rotate instruction is 90 degrees, and 90 is a factor of 180 degrees.\\n *  This provides us an aspect, after a series of movements we might able elimates each movement.\\n *  With command movement k, there will eventually exist a movement that is 180 degree opposite of k.\\n *   - k + -k = 0\\n *  This represents the robot will finally get to the start spot.\\n * \\n *  However, if the robot remain in the same direction after a command and it\\'s location is not (0,0)\\n *  , the ideal situation would not occurs.\\n *  \\n *  As a result, if we want the result be true = circle exist, we should follow the condition below:\\n *  1. After a movement the direction is not north. \\n *  2. if it\\'s remain to north, it should be in (0,0)\\n */\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        // movement - {x, y} with four direction\\n        vector<pair<int, int>> movement{\\n            {0, 1}, // N - idx 0\\n            {1, 0}, // E - idx 1\\n            {0, -1}, // S - idx 2\\n            {-1, 0} // W - idx 3\\n        };\\n        \\n        int locationX = 0, locationY = 0;\\n        int rotationIdx = 0;\\n\\n        for(int instr: instructions) {\\n            if(instr == \\'R\\') {\\n                rotationIdx++;\\n            }\\n            else if(instr == \\'L\\') {\\n                rotationIdx--;\\n            }\\n            else {\\n                // instr == \\'G\\', move the robot\\'s location according to the current facing side\\n                rotationIdx = rotationIdx % 4;\\n                if(rotationIdx < 0) {\\n                    // deal with a negative index\\n                    rotationIdx += 4;\\n                }\\n                locationX += movement[rotationIdx].first;\\n                locationY += movement[rotationIdx].second;\\n            }\\n        }\\n        \\n        if(rotationIdx % 4 == 0) {\\n            if(locationX == 0 && locationY == 0) return true;\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * @brief \\n * A robot stands on initially stands at (0, 0) and face North.\\n * Using G, L, R instruction to assemble a command\\n * Return true, if exists a circle.\\n \\n * [Important] \\n *  Key of this question is the rotate instruction is 90 degrees, and 90 is a factor of 180 degrees.\\n *  This provides us an aspect, after a series of movements we might able elimates each movement.\\n *  With command movement k, there will eventually exist a movement that is 180 degree opposite of k.\\n *   - k + -k = 0\\n *  This represents the robot will finally get to the start spot.\\n * \\n *  However, if the robot remain in the same direction after a command and it\\'s location is not (0,0)\\n *  , the ideal situation would not occurs.\\n *  \\n *  As a result, if we want the result be true = circle exist, we should follow the condition below:\\n *  1. After a movement the direction is not north. \\n *  2. if it\\'s remain to north, it should be in (0,0)\\n */\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        // movement - {x, y} with four direction\\n        vector<pair<int, int>> movement{\\n            {0, 1}, // N - idx 0\\n            {1, 0}, // E - idx 1\\n            {0, -1}, // S - idx 2\\n            {-1, 0} // W - idx 3\\n        };\\n        \\n        int locationX = 0, locationY = 0;\\n        int rotationIdx = 0;\\n\\n        for(int instr: instructions) {\\n            if(instr == \\'R\\') {\\n                rotationIdx++;\\n            }\\n            else if(instr == \\'L\\') {\\n                rotationIdx--;\\n            }\\n            else {\\n                // instr == \\'G\\', move the robot\\'s location according to the current facing side\\n                rotationIdx = rotationIdx % 4;\\n                if(rotationIdx < 0) {\\n                    // deal with a negative index\\n                    rotationIdx += 4;\\n                }\\n                locationX += movement[rotationIdx].first;\\n                locationY += movement[rotationIdx].second;\\n            }\\n        }\\n        \\n        if(rotationIdx % 4 == 0) {\\n            if(locationX == 0 && locationY == 0) return true;\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238856,
                "title": "brute-force-approach-traversing-4-times",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        \\n        int x = 0, y = 0;\\n        char dir = \\'N\\';\\n        int count = 4;\\n        \\n        while(count--) {\\n            \\n            for(char ch : instructions) {\\n                \\n                if(ch == \\'G\\') {\\n                    \\n                    if(dir == \\'N\\') {\\n                        y += 1;\\n                    }\\n                    else if(dir == \\'S\\') {\\n                        y -= 1;\\n                    }\\n                    \\n                    else if(dir == \\'E\\') {\\n                        x += 1;\\n                    }\\n                    \\n                    else if(dir == \\'W\\') {\\n                        x -= 1;\\n                    }\\n                }\\n                \\n                else if(ch == \\'L\\') {\\n                    \\n                    if(dir == \\'N\\') {\\n                        dir = \\'W\\';\\n                    }\\n                    else if(dir == \\'S\\') {\\n                        dir = \\'E\\';\\n                    }\\n                    \\n                    else if(dir == \\'E\\') {\\n                        dir = \\'N\\';\\n                    }\\n                    \\n                    else if(dir == \\'W\\') {\\n                        dir = \\'S\\';\\n                    }\\n                }\\n                \\n                else if(ch == \\'R\\') {\\n                    \\n                    if(dir == \\'N\\') {\\n                        dir = \\'E\\';\\n                    }\\n                    else if(dir == \\'S\\') {\\n                        dir = \\'W\\';\\n                    }\\n                    \\n                    else if(dir == \\'E\\') {\\n                        dir = \\'S\\';\\n                    }\\n                    \\n                    else if(dir == \\'W\\') {\\n                        dir = \\'N\\';\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return (x == 0 and y == 0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        \\n        int x = 0, y = 0;\\n        char dir = \\'N\\';\\n        int count = 4;\\n        \\n        while(count--) {\\n            \\n            for(char ch : instructions) {\\n                \\n                if(ch == \\'G\\') {\\n                    \\n                    if(dir == \\'N\\') {\\n                        y += 1;\\n                    }\\n                    else if(dir == \\'S\\') {\\n                        y -= 1;\\n                    }\\n                    \\n                    else if(dir == \\'E\\') {\\n                        x += 1;\\n                    }\\n                    \\n                    else if(dir == \\'W\\') {\\n                        x -= 1;\\n                    }\\n                }\\n                \\n                else if(ch == \\'L\\') {\\n                    \\n                    if(dir == \\'N\\') {\\n                        dir = \\'W\\';\\n                    }\\n                    else if(dir == \\'S\\') {\\n                        dir = \\'E\\';\\n                    }\\n                    \\n                    else if(dir == \\'E\\') {\\n                        dir = \\'N\\';\\n                    }\\n                    \\n                    else if(dir == \\'W\\') {\\n                        dir = \\'S\\';\\n                    }\\n                }\\n                \\n                else if(ch == \\'R\\') {\\n                    \\n                    if(dir == \\'N\\') {\\n                        dir = \\'E\\';\\n                    }\\n                    else if(dir == \\'S\\') {\\n                        dir = \\'W\\';\\n                    }\\n                    \\n                    else if(dir == \\'E\\') {\\n                        dir = \\'S\\';\\n                    }\\n                    \\n                    else if(dir == \\'W\\') {\\n                        dir = \\'N\\';\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return (x == 0 and y == 0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225836,
                "title": "clean-javascript-solution-split-into-functions",
                "content": "```\\n/**\\n * @param {string} instructions\\n * @return {boolean}\\n */\\nconst isRobotBounded = instructions => {\\n    let position = { x: 0, y: 0 };\\n    let orientation = \\'north\\';\\n    \\n    for (const instruction of [...instructions]) {\\n        ({ position, orientation } = execute(instruction, position, orientation));\\n    }\\n    \\n    return orientation !== \\'north\\' || (position.x === 0 && position.y === 0);\\n};\\n\\nconst execute = (instruction, position, orientation) => {\\n    switch (instruction) {\\n        case \\'G\\':\\n            return goOneUnit(position, orientation);\\n        case \\'L\\':\\n            return rotateLeft(position, orientation);\\n        case \\'R\\':\\n            return rotateRight(position, orientation);\\n    }\\n    \\n    throw new Error(`Unsupported operation ${instruction}`);\\n};\\n\\nconst goOneUnit = (position, orientation) => {\\n    switch (orientation) {\\n        case \\'north\\':\\n            return {\\n                position: {\\n                    x: position.x,\\n                    y: position.y + 1,\\n                },\\n                orientation,\\n            };\\n        case \\'east\\':\\n            return {\\n                position: {\\n                    x: position.x + 1,\\n                    y: position.y,\\n                },\\n                orientation,\\n            };\\n        case \\'south\\':\\n            return {\\n                position: {\\n                    x: position.x,\\n                    y: position.y -1,\\n                },\\n                orientation,\\n            };\\n        case \\'west\\':\\n            return {\\n                position: {\\n                    x: position.x - 1,\\n                    y: position.y,\\n                },\\n                orientation,\\n            };\\n    }\\n    \\n    throw new Error(`Invalid orientation ${orientation}`);\\n};\\n\\nconst rotateLeft = (position, orientation) => {\\n    switch (orientation) {\\n        case \\'north\\':\\n            return {\\n                position,\\n                orientation: \\'west\\',\\n            };\\n        case \\'west\\':\\n            return {\\n                position,\\n                orientation: \\'south\\',\\n            };\\n        case \\'south\\':\\n            return {\\n                position,\\n                orientation: \\'east\\',\\n            };\\n        case \\'east\\':\\n            return {\\n                position,\\n                orientation: \\'north\\',\\n            };\\n    }\\n    \\n    throw new Error(`Invalid rotate left operation: ${orientation}`);\\n}\\n\\nconst rotateRight = (position, orientation) => {\\n    switch (orientation) {\\n        case \\'north\\':\\n            return {\\n                position,\\n                orientation: \\'east\\',\\n            };\\n        case \\'east\\':\\n            return {\\n                position,\\n                orientation: \\'south\\',\\n            };\\n        case \\'south\\':\\n            return {\\n                position,\\n                orientation: \\'west\\',\\n            };\\n        case \\'west\\':\\n            return {\\n                position,\\n                orientation: \\'north\\',\\n            };\\n    }\\n    \\n    throw new Error(`Invalid rotate right operation: ${orientation}`);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} instructions\\n * @return {boolean}\\n */\\nconst isRobotBounded = instructions => {\\n    let position = { x: 0, y: 0 };\\n    let orientation = \\'north\\';\\n    \\n    for (const instruction of [...instructions]) {\\n        ({ position, orientation } = execute(instruction, position, orientation));\\n    }\\n    \\n    return orientation !== \\'north\\' || (position.x === 0 && position.y === 0);\\n};\\n\\nconst execute = (instruction, position, orientation) => {\\n    switch (instruction) {\\n        case \\'G\\':\\n            return goOneUnit(position, orientation);\\n        case \\'L\\':\\n            return rotateLeft(position, orientation);\\n        case \\'R\\':\\n            return rotateRight(position, orientation);\\n    }\\n    \\n    throw new Error(`Unsupported operation ${instruction}`);\\n};\\n\\nconst goOneUnit = (position, orientation) => {\\n    switch (orientation) {\\n        case \\'north\\':\\n            return {\\n                position: {\\n                    x: position.x,\\n                    y: position.y + 1,\\n                },\\n                orientation,\\n            };\\n        case \\'east\\':\\n            return {\\n                position: {\\n                    x: position.x + 1,\\n                    y: position.y,\\n                },\\n                orientation,\\n            };\\n        case \\'south\\':\\n            return {\\n                position: {\\n                    x: position.x,\\n                    y: position.y -1,\\n                },\\n                orientation,\\n            };\\n        case \\'west\\':\\n            return {\\n                position: {\\n                    x: position.x - 1,\\n                    y: position.y,\\n                },\\n                orientation,\\n            };\\n    }\\n    \\n    throw new Error(`Invalid orientation ${orientation}`);\\n};\\n\\nconst rotateLeft = (position, orientation) => {\\n    switch (orientation) {\\n        case \\'north\\':\\n            return {\\n                position,\\n                orientation: \\'west\\',\\n            };\\n        case \\'west\\':\\n            return {\\n                position,\\n                orientation: \\'south\\',\\n            };\\n        case \\'south\\':\\n            return {\\n                position,\\n                orientation: \\'east\\',\\n            };\\n        case \\'east\\':\\n            return {\\n                position,\\n                orientation: \\'north\\',\\n            };\\n    }\\n    \\n    throw new Error(`Invalid rotate left operation: ${orientation}`);\\n}\\n\\nconst rotateRight = (position, orientation) => {\\n    switch (orientation) {\\n        case \\'north\\':\\n            return {\\n                position,\\n                orientation: \\'east\\',\\n            };\\n        case \\'east\\':\\n            return {\\n                position,\\n                orientation: \\'south\\',\\n            };\\n        case \\'south\\':\\n            return {\\n                position,\\n                orientation: \\'west\\',\\n            };\\n        case \\'west\\':\\n            return {\\n                position,\\n                orientation: \\'north\\',\\n            };\\n    }\\n    \\n    throw new Error(`Invalid rotate right operation: ${orientation}`);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1079387,
                "title": "simple-easy-to-understand-java-solution-0ms-with-instructions",
                "content": "Here my goal is to find the final direction and position of the robot after a set of instructions. \\ndir = 0 means North; \\ndir = 1 means east; \\ndir = 2 means south; \\ndir = 3 means west; \\nand x = 0 and y=0 initially.\\n\\nNow using the **move() function** i am going to make a move(which is easy to understand). \\nfinally, If the robot is pointing a different direction then it will definitely come back after 4 moves so return true. Now, there is a case, If the direction is same but it is on the exact starting point then it will repeat that and it is bounded so return true.\\n\\nelse it will always moving in a direction and pointing to north after the instructions. So the displacement will always increase and hence will never come back.\\n```\\nclass Solution {\\n    int x,y,dir;\\n    public boolean isRobotBounded(String instructions) {\\n        x=0;\\n        y=0;\\n        dir=0;\\n        for(char c:instructions.toCharArray()){\\n            move(c);\\n        }\\n        \\n        if(dir!=0)return true;\\n        if(x==0 && y==0)return true;\\n        \\n        return false;\\n    }\\n    public void move(char c){\\n        if(c==\\'L\\'){\\n            dir++;\\n            if(dir==4)dir=0;\\n        }\\n        else if(c==\\'R\\'){\\n            dir--;\\n            if(dir==-1)dir=3;\\n        }\\n        else{ // it\\'s G\\n            if(dir==0){\\n                x--;\\n            }\\n            else if(dir==1){\\n                y++;\\n            }\\n            else if(dir==2){\\n                x++;\\n            }\\n            else{//dir ==3\\n                y--;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int x,y,dir;\\n    public boolean isRobotBounded(String instructions) {\\n        x=0;\\n        y=0;\\n        dir=0;\\n        for(char c:instructions.toCharArray()){\\n            move(c);\\n        }\\n        \\n        if(dir!=0)return true;\\n        if(x==0 && y==0)return true;\\n        \\n        return false;\\n    }\\n    public void move(char c){\\n        if(c==\\'L\\'){\\n            dir++;\\n            if(dir==4)dir=0;\\n        }\\n        else if(c==\\'R\\'){\\n            dir--;\\n            if(dir==-1)dir=3;\\n        }\\n        else{ // it\\'s G\\n            if(dir==0){\\n                x--;\\n            }\\n            else if(dir==1){\\n                y++;\\n            }\\n            else if(dir==2){\\n                x++;\\n            }\\n            else{//dir ==3\\n                y--;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950608,
                "title": "standard-java-solution",
                "content": "### Theory\\nNo tricks here, just simulate the robot movement. The robot is constraint if it ends back at the origin or if ends up elsewhere facing any direction but north.\\n\\n### Solution\\n```\\n    public boolean isRobotBounded(String instructions) {\\n        DIRECTION dir = DIRECTION.NORTH;\\n        int[] pos = new int[] {0, 0};\\n        for (int i = 0; i < instructions.length(); i++) {\\n            Character c = instructions.charAt(i);\\n            if (c == \\'G\\') move(dir, pos);\\n            else dir = turn(dir, c);\\n        }\\n        \\n        boolean atOrigin = pos[0] == 0 && pos[1] == 0;\\n        boolean facingNorth = dir == DIRECTION.NORTH;\\n        \\n        \\n        return atOrigin || !facingNorth;\\n        \\n    }\\n    \\n    private void move(DIRECTION dir, int[] pos) {\\n        if (dir == DIRECTION.NORTH) {\\n            pos[1]++;\\n        } else if (dir == DIRECTION.SOUTH) {\\n            pos[1]--;\\n        } else if (dir == DIRECTION.EAST) {\\n            pos[0]++;\\n        } else {\\n            pos[0]--;\\n        }\\n    }\\n    \\n    private DIRECTION turn(DIRECTION dir, Character c) {\\n        if (c == \\'L\\') {\\n            if (dir == DIRECTION.NORTH) return DIRECTION.WEST;\\n            else if (dir == DIRECTION.WEST) return DIRECTION.SOUTH;\\n            else if (dir == DIRECTION.SOUTH) return DIRECTION.EAST;\\n            else if (dir == DIRECTION.EAST) return DIRECTION.NORTH;\\n            return null;\\n        } else {\\n            if (dir == DIRECTION.NORTH) return DIRECTION.EAST;\\n            else if (dir == DIRECTION.EAST) return DIRECTION.SOUTH;\\n            else if (dir == DIRECTION.SOUTH) return DIRECTION.WEST;\\n            else if (dir == DIRECTION.WEST) return DIRECTION.NORTH;\\n            return null;\\n        }\\n    }\\n    \\n    private enum DIRECTION {\\n        NORTH, WEST, SOUTH, EAST;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isRobotBounded(String instructions) {\\n        DIRECTION dir = DIRECTION.NORTH;\\n        int[] pos = new int[] {0, 0};\\n        for (int i = 0; i < instructions.length(); i++) {\\n            Character c = instructions.charAt(i);\\n            if (c == \\'G\\') move(dir, pos);\\n            else dir = turn(dir, c);\\n        }\\n        \\n        boolean atOrigin = pos[0] == 0 && pos[1] == 0;\\n        boolean facingNorth = dir == DIRECTION.NORTH;\\n        \\n        \\n        return atOrigin || !facingNorth;\\n        \\n    }\\n    \\n    private void move(DIRECTION dir, int[] pos) {\\n        if (dir == DIRECTION.NORTH) {\\n            pos[1]++;\\n        } else if (dir == DIRECTION.SOUTH) {\\n            pos[1]--;\\n        } else if (dir == DIRECTION.EAST) {\\n            pos[0]++;\\n        } else {\\n            pos[0]--;\\n        }\\n    }\\n    \\n    private DIRECTION turn(DIRECTION dir, Character c) {\\n        if (c == \\'L\\') {\\n            if (dir == DIRECTION.NORTH) return DIRECTION.WEST;\\n            else if (dir == DIRECTION.WEST) return DIRECTION.SOUTH;\\n            else if (dir == DIRECTION.SOUTH) return DIRECTION.EAST;\\n            else if (dir == DIRECTION.EAST) return DIRECTION.NORTH;\\n            return null;\\n        } else {\\n            if (dir == DIRECTION.NORTH) return DIRECTION.EAST;\\n            else if (dir == DIRECTION.EAST) return DIRECTION.SOUTH;\\n            else if (dir == DIRECTION.SOUTH) return DIRECTION.WEST;\\n            else if (dir == DIRECTION.WEST) return DIRECTION.NORTH;\\n            return null;\\n        }\\n    }\\n    \\n    private enum DIRECTION {\\n        NORTH, WEST, SOUTH, EAST;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 906465,
                "title": "explanation-with-drawings",
                "content": "The trick I found after several drawings of different trajectories is that, what really matters is the ***end point*** of the trajectory as well as the ***direction*** when the robot reaches the end point, regardless of what exactly the trajectory is. Thus, we can use a vector from start to end to represent all the trajectories from the same start to the same end. \\n\\nAs shown in the drawing below, each vector represents a trajectory with the given instructions. At the starting point, the robot is facing north. After excuting the instructions once, the robot stops at a point which is to the right of the direction that it faces at the beginning (North), with a angle of *theta*. There are four possible directions when the robot reaches the point:\\n1) Face north (upward), as the short black arrow. Then, when repeating the instructions, the robot will keep moving in the same direction forever. In this case, the robot can get back to the origin only if it returns to the origin after each excution of the given instructions (i.e., the vector has length 0).\\n2) Face south (downward), as the short blue arrow. Then, with one more excution of the instructions, the robot will return to the origin facing north, as when it starts.\\n3) Face east (right), as the short red arrow. In this case, note that the current direction (east) is 90 degrees to the right of the initial direction (north), and with each excution of the given instructions, the robot moves to a point which is to the right of the direction that it faces with a angle of *theta*. So the second vector is 90 degrees to the right of the direction of the first vector, the third vector is 90 degrees to the right of the direction of the second vector, and so on. Thus, four excutions of the instructions form a square and the robot moves back to the origin then.\\n4) Face west (left), as the short green arrow. It is the same as the red case but in opposite direction.\\n\\n***To summerize, the robot cannot return to origin only if after excuting the instructions once, it stops at a point which is not origin and face north.***\\n\\n![image](https://assets.leetcode.com/users/images/1310a8cd-165b-4232-9eda-1d4106e533f6_1603412056.5589578.png)\\n\\nNow, the problem is to:\\n1) find the ***direction*** at the end point (if not facing north, return True)\\n2) find the ***end point*** of each trajectory (if it is the origin, return True)\\n\\nTo find the direction at the end point, we only need to care about the number of \"L\" and \"R\" instructions. One \"L\" can cancel out one \"R\". In the code below, variable *count* denotes the amount (# of \"L\" - # of \"R\"). Once a \"L\" in the instructions, *count = count + 1*, once a \"R\" in the instructions, *count = count - 1*. *count* is reset to 0 once either \"L\" or \"R\" appears four times (i.e., *count == 4* or *count == -4*). If at last *count == 0*, it means the direction of the robot doesn\\'t change (i.e., face north).\\n\\nTo find the end point of a trajectory, just start from point (0, 0) and follow the instructions given to move the robot in the four directions [(0, 1), (-1, 0), (0, -1), (1, 0)] respectively.\\n\\n**Code:**\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        count = 0\\n        d     = 0\\n        \\n        loc   = (0, 0)\\n        dirs  = [(0, 1), (-1, 0), (0, -1), (1, 0)]\\n        \\n        for l in instructions:\\n            if l == \\'L\\':\\n                count = (count + 1) % 4\\n                d     = (d + 1) % 4\\n            \\n            if l == \\'R\\':\\n                count = (count - 1) % 4\\n                d     = (d - 1) % 4\\n            \\n            if l == \\'G\\':\\n                loc = (loc[0] + dirs[d][0], loc[1] + dirs[d][1])\\n        \\n        return count != 0 or loc == (0, 0)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        count = 0\\n        d     = 0\\n        \\n        loc   = (0, 0)\\n        dirs  = [(0, 1), (-1, 0), (0, -1), (1, 0)]\\n        \\n        for l in instructions:\\n            if l == \\'L\\':\\n                count = (count + 1) % 4\\n                d     = (d + 1) % 4\\n            \\n            if l == \\'R\\':\\n                count = (count - 1) % 4\\n                d     = (d - 1) % 4\\n            \\n            if l == \\'G\\':\\n                loc = (loc[0] + dirs[d][0], loc[1] + dirs[d][1])\\n        \\n        return count != 0 or loc == (0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851262,
                "title": "robot-bounded-in-circle-python-geometry-explanation-approaching-to-geometry",
                "content": "Before starting, I personally define this problem as a GEOMETRY problem because it uses coordiates and degrees.\\nAlthough the usage in this is simple and not as much difficult or complecated as that in questions possibly labeled hard, it is one of geometry questions.\\n\\nNow, we are going to move a robot which follows simple sets of rules.\\n1. Move 1 unit toward its facing direction by a single instruction of \\'G\\'.\\n2. Turn 90 degrees to the left with \\'L\\', whereas turn the same degree to the right with \\'R\\'.\\n\\nThe result will be ```true``` iff it creates a circle after being repeated.\\n\\nSince we have two values for the result, ```true``` or ```false```, we can choose that we are going to filter true things out or do it for the opposite direction. In this problem, choosing either way doesn\\'t make any difference. However, in certain problems, choosing one way makes your life much easier than doing the other way, or sometimes it would be the only way to solve a problem.\\n\\nI\\'m going to focus on finding **true cases** because I think I might read some clues in the description. The first thing we have to do is finding conditions to draw a circle. Needless to say, if a robot doesn\\'t move, it\\'ll draw a circle. Also, we can check it after 2 performs, 3 performs, ... to N performs.\\n\\nSo, the terminate conditions can be reduced to these two cases.\\n1. A robot returns to the origin after a set of instructions, 1 perform.\\n2. A robot returns to the origin after several sets of instructions, N performs.\\n\\nThe obstacle at this point is that the 2nd condition is not going to be helpful for us at all. Then, we should re-write it or approach this question from finding false cases.\\nThe conditions for false cases are\\n1. A robot **doesn\\'t return** to the origin after a set of instructions, 1 perform.\\n2. A robot **doesn\\'t return** to the origin after several sets of instructions, N performs.\\n\\nand the pain point was the number of performs so that it is not going to be helpful.\\nWhich means rewriting the 2nd condition is the only option to solve it and the key will be finding N, the number of performs.\\n\\nIt describs \\'*repeats instructions forever*\\' in the question, but it is quite obvious that we don\\'t need to play it infinitely to check whether it makes a circle after about 100 years later. Rather than that, it is more reasonable and delightful for us that it will be determined after several iterations. In other words, the key is recognizing how many times we have to repeat the same set of instructions to conclude and the number should be very small.\\n\\nSo, let\\'s find the number.\\nSomething of which property contains repeativeness in this problem is *degree*.\\nIt is a well-known fact that 360 degrees on a 2D coordiate system represents 0 degree as well. Since each ```\\'L\\'```, ```\\'R\\'``` operations rotates to the left and the right, respectively, a robot will face one of folloing four directions, *North, West, South, East*, at the end of instructions. And those points of compass can be denoted to ```(0,1), (-1, 0), (0, -1), (1, 0)```, respectively, as a vector representation.\\n\\nThanks to the property of degree, I think we have found the maximum N which is 4 because\\n* The possible cases of where a robot is facing after each perfom are North, West, South, East, which are the results of rotations of 0(or 360), 90, 180, 270 degrees toward the left, respectively \\n* In case of West, East, they need at least 4 performs to be a multiplication of 360 degrees\\n* In case of South, it needs at least two performs to be a multiplication of 360 degrees\\n* In case of North, it has to return after one perform; otherwise it goes somewhere else\\n\\nand 4 is L.C.M of 1,2,4.\\n\\nBecause 4 performs contain 1 peform, the naive code will be\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n\\t\\tinstructions *= 4\\n\\t\\tturns = [(0, 1), (-1,0), (0, -1), (1, 0)]\\n\\t\\tface = 0\\n\\t\\tx, y = 0, 0\\n\\t\\tfor instruction in instructions:\\n\\t\\t\\tif instruction == \\'L\\':\\n                face += 1\\n            elif instruction == \\'R\\':\\n                face -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdx, dy = turns[face%4]\\n\\t\\t\\t\\tx += dx\\n\\t\\t\\t\\ty += dy\\n\\t\\treturn x == 0 and y == 0\\n```\\nTime complexity is ```O(N)``` derived from ```O(4*N)```, where N is the length of instructions.\\nSpace complexity is the same because I assigned instructions again.\\n\\nAt this point, somebody wants not to multiply 4 because it wastes space, and I totally agree with that idea. Then, what if we can derive other terminate condition from findinds?\\n\\nMultiplied by 4 is performed to cover the results of facing West and East at the end of a instructions set. In other words, when a robot faces West and East, it returns to the origin after 4 performs. All we have to do is it is going to be applied to all situations. \\n\\nAccroding to these,\\n* Moving toward (x, y) and doing toward (-x, -y) after the movemet change nothing \\n* Changing sequence of movements doesn\\'t affect anything if the direction is perserved\\n* A set of instructions can be denoted to (x, y), which is the coordination of the point at the end of the instructions\\n\\nThe first perform moves the point toward (x, y) and the third perform will return the point to the origin because of changing sequence availibility. So does the combination of the second perform and the fourth perform, which are the reflection of each other. \\n\\nNow we can remove ```N``` in cases of facing West and East. \\nFunny thing is that in case of facing South, 2 performs exactly reflects each other. Of course, there is no possibility when a robot doesn\\'t return to the origin while facing North. That means we can define the terminate conditions again such that\\n* ```(x, y) == (0, 0)``` after singe perform\\n* ```(x, y) != (0, 0)``` and not facing North after single perfom\\n\\nWe can improve the code like\\n\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n\\t\\tturns = [(0, 1), (-1,0), (0, -1), (1, 0)]\\n\\t\\tface = 0\\n\\t\\tx, y = 0, 0\\n\\t\\tfor instruction in instructions:\\n\\t\\t\\tif instruction == \\'L\\':\\n                face += 1\\n            elif instruction == \\'R\\':\\n                face -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdx, dy = turns[face%4]\\n\\t\\t\\t\\tx += dx\\n\\t\\t\\t\\ty += dy\\n\\t\\treturn (x, y) == (0, 0) or face%4\\n```\\n\\nAlso it could be \\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n\\t\\tx, y, dx, dy = 0, 0, 0, 1 # turns=[(0,1), (-1,0), (0,-1), (1,0)]\\n\\t\\tfor instruction in instructions:\\n\\t\\t\\tif instruction == \\'L\\':\\n                dx, dy = -dy, dx\\n            elif instruction == \\'R\\':\\n                dx, dy = dy, -dx\\n\\t\\t\\telse:\\n\\t\\t\\t\\tx, y = x+dx, y+dy\\n\\t\\treturn (x, y) == (0, 0) or (dx, dy) != (0, 1)\\n```\\nto reduce space usages by using direction\\'s charactar of repeativeness.\\n\\nTIme complexity is not going to be changed while Space complexity will be ```O(1)```.\\n\\nLast one.\\nAt this point, it is cristal clear that it can be easily solved if we started with vectors.\\nThat\\'s right. A lot of geometry and coordiation problems will be easier when you find the connection with vectors.\\nDespite the fact, I wanted to show how to approach to the answer in case of not recognizing it is a vector problem at the point of an interview or not having a solid confidence in math.\\n\\nI hope it would be helpful.\\n\\nAlso, I\\'m a very big fan of writing pythonic-code although this isn\\'t obviously.\\nSo, if you guys have a woderful idea, please don\\'t hesitate to share for others.\\n\\nThanks a lot for your attention.\\n\\np.s.) Any comment will be welcomed including typo, gramatical error since English is my second language.\\n",
                "solutionTags": [
                    "Python",
                    "Geometry"
                ],
                "code": "```true```\n```true```\n```false```\n```\\'L\\'```\n```\\'R\\'```\n```(0,1), (-1, 0), (0, -1), (1, 0)```\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n\\t\\tinstructions *= 4\\n\\t\\tturns = [(0, 1), (-1,0), (0, -1), (1, 0)]\\n\\t\\tface = 0\\n\\t\\tx, y = 0, 0\\n\\t\\tfor instruction in instructions:\\n\\t\\t\\tif instruction == \\'L\\':\\n                face += 1\\n            elif instruction == \\'R\\':\\n                face -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdx, dy = turns[face%4]\\n\\t\\t\\t\\tx += dx\\n\\t\\t\\t\\ty += dy\\n\\t\\treturn x == 0 and y == 0\\n```\n```O(N)```\n```O(4*N)```\n```N```\n```(x, y) == (0, 0)```\n```(x, y) != (0, 0)```\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n\\t\\tturns = [(0, 1), (-1,0), (0, -1), (1, 0)]\\n\\t\\tface = 0\\n\\t\\tx, y = 0, 0\\n\\t\\tfor instruction in instructions:\\n\\t\\t\\tif instruction == \\'L\\':\\n                face += 1\\n            elif instruction == \\'R\\':\\n                face -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdx, dy = turns[face%4]\\n\\t\\t\\t\\tx += dx\\n\\t\\t\\t\\ty += dy\\n\\t\\treturn (x, y) == (0, 0) or face%4\\n```\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n\\t\\tx, y, dx, dy = 0, 0, 0, 1 # turns=[(0,1), (-1,0), (0,-1), (1,0)]\\n\\t\\tfor instruction in instructions:\\n\\t\\t\\tif instruction == \\'L\\':\\n                dx, dy = -dy, dx\\n            elif instruction == \\'R\\':\\n                dx, dy = dy, -dx\\n\\t\\t\\telse:\\n\\t\\t\\t\\tx, y = x+dx, y+dy\\n\\t\\treturn (x, y) == (0, 0) or (dx, dy) != (0, 1)\\n```\n```O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 850427,
                "title": "c-simple-solution-explained-100-time-60-space",
                "content": "The intuition to solve this problem is that our finite state machine is going to be in a cyclical condition in 2 cases:\\n* it does not move at the end of the tick;\\n* it points in a different direction.\\n\\nIn order to verify that, we set a few variables:\\n* `dir`, representing our direction in a `0 - 3` range, initially set to `0` (North);\\n* `x` and `y`, both initialised to `0` and meant to register the overall movement from the start;\\n* `moves` an array of updates associated with movements for different values of `dir`, which I admitted doing just to avoid having to type 4 different conditionals to update the coordinates, sacrificing a bit more of memory.\\n\\nThen we parse through the string of commands character by character, updating either `dir` (for either `\\'L\\'` or `\\'G\\'`) or `x` and `y` (for `\\'G\\'`) as we go.\\n\\nAt the end, I return if the robot either did not move at all at the end of the turn (both `x` and `y` are `0`) or if did not change its direction (`dir` is still set to `0`) :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        // dir 0 => N, 1 => W, 2 => S, 3 => E\\n        int dir = 0, x = 0, y = 0,\\n\\t\\t// moving N, W, S and E\\n\\t\\tmoves[4][2] = {{0, 1}, {-1, 0}, {0, -1}, {1, 0}};\\n        for (char c: instructions) {\\n            switch(c) {\\n                // going forward\\n\\t\\t\\t\\tcase \\'G\\':\\n                    // updating the coordinates\\n\\t\\t\\t\\t\\tx += moves[dir][0];\\n                    y += moves[dir][1];\\n                    break;\\n                // turning left\\n\\t\\t\\t\\tcase \\'L\\':\\n                    dir = (dir + 1) % 4;\\n                    break;\\n                // turning right\\n                case \\'R\\':\\n                    dir = (dir + 3) % 4;\\n                    break;\\n            }\\n        }\\n        // return if it didn\\'t move or didn\\'t turn\\n\\t\\treturn !x && !y || dir;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        // dir 0 => N, 1 => W, 2 => S, 3 => E\\n        int dir = 0, x = 0, y = 0,\\n\\t\\t// moving N, W, S and E\\n\\t\\tmoves[4][2] = {{0, 1}, {-1, 0}, {0, -1}, {1, 0}};\\n        for (char c: instructions) {\\n            switch(c) {\\n                // going forward\\n\\t\\t\\t\\tcase \\'G\\':\\n                    // updating the coordinates\\n\\t\\t\\t\\t\\tx += moves[dir][0];\\n                    y += moves[dir][1];\\n                    break;\\n                // turning left\\n\\t\\t\\t\\tcase \\'L\\':\\n                    dir = (dir + 1) % 4;\\n                    break;\\n                // turning right\\n                case \\'R\\':\\n                    dir = (dir + 3) % 4;\\n                    break;\\n            }\\n        }\\n        // return if it didn\\'t move or didn\\'t turn\\n\\t\\treturn !x && !y || dir;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293201,
                "title": "0ms-java-solution-fairly-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int x = 0, y = 0, vx = 0, vy = 1; // position (x, y), direction (vx, vy). \\n        for(char c : instructions.toCharArray()){\\n            if(c == \\'G\\'){ // go 1 step along the direction (vx, vy), new positon = old position + 1*(vx, vy). \\n                x += vx; \\n                y += vy;\\n            }else if(c == \\'L\\'){ // turn left is (vx, vy) ->(-vy, vx)\\n                int tmp = vx;\\n                vx = -vy;\\n                vy = tmp;\\n            }else{ // trun right is (vx, vy) -> (vy, -vx)\\n                int tmp = vx;\\n                vx = vy;\\n                vy = -tmp;\\n            }\\n        }\\n        if(x*x + y*y > 0 && vx == 0 && vy == 1) return false; //if we travel some distance, in the meanwhile facing the north, sky is the limit!\\n        else return true; //stay the same position or travel an angle, with many steps you will be back, stuck in limbo. \\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int x = 0, y = 0, vx = 0, vy = 1; // position (x, y), direction (vx, vy). \\n        for(char c : instructions.toCharArray()){\\n            if(c == \\'G\\'){ // go 1 step along the direction (vx, vy), new positon = old position + 1*(vx, vy). \\n                x += vx; \\n                y += vy;\\n            }else if(c == \\'L\\'){ // turn left is (vx, vy) ->(-vy, vx)\\n                int tmp = vx;\\n                vx = -vy;\\n                vy = tmp;\\n            }else{ // trun right is (vx, vy) -> (vy, -vx)\\n                int tmp = vx;\\n                vx = vy;\\n                vy = -tmp;\\n            }\\n        }\\n        if(x*x + y*y > 0 && vx == 0 && vy == 1) return false; //if we travel some distance, in the meanwhile facing the north, sky is the limit!\\n        else return true; //stay the same position or travel an angle, with many steps you will be back, stuck in limbo. \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713619,
                "title": "java-simple-solution",
                "content": "# Intuition\\nIf robot is still facing north and not at origin, return false\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIf robot is still facing north and not at origin, return false\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int x = 0, y = 0;\\n        char dir = \\'N\\';\\n        for(char ch : instructions.toCharArray()){\\n            if(ch == \\'G\\'){\\n                switch(dir){\\n                    case \\'N\\':   y++; break;\\n                    case \\'E\\':   x++; break;\\n                    case \\'W\\':   x--; break;\\n                    case \\'S\\':   y--; break;          \\n                }\\n            }\\n            else if( ch == \\'L\\'){\\n                switch(dir){\\n                    case \\'N\\':   dir = \\'W\\'; break;\\n                    case \\'E\\':   dir = \\'N\\'; break;\\n                    case \\'W\\':   dir = \\'S\\'; break;\\n                    case \\'S\\':   dir = \\'E\\'; break;       \\n                } \\n            }\\n            else{\\n                switch(dir){\\n                    case \\'N\\':   dir = \\'E\\'; break;\\n                    case \\'E\\':   dir = \\'S\\'; break;\\n                    case \\'W\\':   dir = \\'N\\'; break;\\n                    case \\'S\\':   dir = \\'W\\'; break;          \\n                }\\n            }\\n        }\\n\\n        if(x == 0 && y == 0) return true;\\n\\n        if(dir == \\'N\\') return false;\\n        \\n        return true;\\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int x = 0, y = 0;\\n        char dir = \\'N\\';\\n        for(char ch : instructions.toCharArray()){\\n            if(ch == \\'G\\'){\\n                switch(dir){\\n                    case \\'N\\':   y++; break;\\n                    case \\'E\\':   x++; break;\\n                    case \\'W\\':   x--; break;\\n                    case \\'S\\':   y--; break;          \\n                }\\n            }\\n            else if( ch == \\'L\\'){\\n                switch(dir){\\n                    case \\'N\\':   dir = \\'W\\'; break;\\n                    case \\'E\\':   dir = \\'N\\'; break;\\n                    case \\'W\\':   dir = \\'S\\'; break;\\n                    case \\'S\\':   dir = \\'E\\'; break;       \\n                } \\n            }\\n            else{\\n                switch(dir){\\n                    case \\'N\\':   dir = \\'E\\'; break;\\n                    case \\'E\\':   dir = \\'S\\'; break;\\n                    case \\'W\\':   dir = \\'N\\'; break;\\n                    case \\'S\\':   dir = \\'W\\'; break;          \\n                }\\n            }\\n        }\\n\\n        if(x == 0 && y == 0) return true;\\n\\n        if(dir == \\'N\\') return false;\\n        \\n        return true;\\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642530,
                "title": "simulation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x = 0, y = 0, d = 0;\\n        for(char c : instructions) {\\n            if(c == \\'G\\') {\\n                if(d % 4 == 0) y++;\\n                else if(d % 4 == 1) x++;\\n                else if(d % 4 == 2) y--;\\n                else x--;\\n            }\\n            else if(c == \\'R\\') d++;\\n            else d += 3; \\n        }\\n        return x == 0 && y == 0 || d % 4 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x = 0, y = 0, d = 0;\\n        for(char c : instructions) {\\n            if(c == \\'G\\') {\\n                if(d % 4 == 0) y++;\\n                else if(d % 4 == 1) x++;\\n                else if(d % 4 == 2) y--;\\n                else x--;\\n            }\\n            else if(c == \\'R\\') d++;\\n            else d += 3; \\n        }\\n        return x == 0 && y == 0 || d % 4 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598330,
                "title": "c-hot-and-trending-solution-super-easy-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string s) {\\n        int x = 0;\\n        int y = 0;\\n        char dir = \\'N\\';\\n        int n = s.size();\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'G\\'){\\n                switch(dir){\\n                    case \\'N\\': y += 1; break;\\n                    case \\'S\\': y -= 1; break;\\n                    case \\'E\\': x += 1; break;\\n                    case \\'W\\': x -= 1;\\n                }\\n            }\\n            else if(s[i] == \\'L\\'){\\n                switch(dir){\\n                    case \\'N\\': dir = \\'W\\'; break;\\n                    case \\'S\\': dir = \\'E\\'; break;\\n                    case \\'E\\': dir = \\'N\\'; break;\\n                    case \\'W\\': dir = \\'S\\';\\n                }\\n            }\\n            else{\\n                switch(dir){\\n                    case \\'N\\': dir = \\'E\\'; break;\\n                    case \\'S\\': dir = \\'W\\'; break;\\n                    case \\'E\\': dir = \\'S\\'; break;\\n                    case \\'W\\': dir = \\'N\\';\\n                }\\n            }\\n        }\\n        if(x == 0 && y == 0) return true;\\n        if(dir == \\'N\\') return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string s) {\\n        int x = 0;\\n        int y = 0;\\n        char dir = \\'N\\';\\n        int n = s.size();\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'G\\'){\\n                switch(dir){\\n                    case \\'N\\': y += 1; break;\\n                    case \\'S\\': y -= 1; break;\\n                    case \\'E\\': x += 1; break;\\n                    case \\'W\\': x -= 1;\\n                }\\n            }\\n            else if(s[i] == \\'L\\'){\\n                switch(dir){\\n                    case \\'N\\': dir = \\'W\\'; break;\\n                    case \\'S\\': dir = \\'E\\'; break;\\n                    case \\'E\\': dir = \\'N\\'; break;\\n                    case \\'W\\': dir = \\'S\\';\\n                }\\n            }\\n            else{\\n                switch(dir){\\n                    case \\'N\\': dir = \\'E\\'; break;\\n                    case \\'S\\': dir = \\'W\\'; break;\\n                    case \\'E\\': dir = \\'S\\'; break;\\n                    case \\'W\\': dir = \\'N\\';\\n                }\\n            }\\n        }\\n        if(x == 0 && y == 0) return true;\\n        if(dir == \\'N\\') return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527420,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0, y=0;\\n        char d=\\'u\\';\\n        for(int i=0; i<instructions.size(); i++){\\n            if(instructions[i]==\\'G\\'){\\n                if(d==\\'u\\'){\\n                    y++;\\n                }\\n                else if(d==\\'d\\'){\\n                    y--;\\n                }\\n                else if(d==\\'l\\'){\\n                    x--;\\n                }\\n                else if(d==\\'r\\'){\\n                    x++;\\n                }\\n            }\\n            else if(instructions[i]==\\'L\\'){\\n                if(d==\\'u\\'){\\n                    d=\\'l\\';\\n                }\\n                else if(d==\\'d\\'){\\n                    d=\\'r\\';\\n                }\\n                else if(d==\\'l\\'){\\n                    d=\\'d\\';\\n                }\\n                else if(d==\\'r\\'){\\n                    d=\\'u\\';\\n                }\\n            }\\n            else if(instructions[i]==\\'R\\'){\\n                if(d==\\'u\\'){\\n                    d=\\'r\\';\\n                }\\n                else if(d==\\'d\\'){\\n                    d=\\'l\\';\\n                }\\n                else if(d==\\'l\\'){\\n                    d=\\'u\\';\\n                }\\n                else if(d==\\'r\\'){\\n                    d=\\'d\\';\\n                }\\n            }\\n        }\\n        if(x==0 && y==0 || d!=\\'u\\'){return true;}\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0, y=0;\\n        char d=\\'u\\';\\n        for(int i=0; i<instructions.size(); i++){\\n            if(instructions[i]==\\'G\\'){\\n                if(d==\\'u\\'){\\n                    y++;\\n                }\\n                else if(d==\\'d\\'){\\n                    y--;\\n                }\\n                else if(d==\\'l\\'){\\n                    x--;\\n                }\\n                else if(d==\\'r\\'){\\n                    x++;\\n                }\\n            }\\n            else if(instructions[i]==\\'L\\'){\\n                if(d==\\'u\\'){\\n                    d=\\'l\\';\\n                }\\n                else if(d==\\'d\\'){\\n                    d=\\'r\\';\\n                }\\n                else if(d==\\'l\\'){\\n                    d=\\'d\\';\\n                }\\n                else if(d==\\'r\\'){\\n                    d=\\'u\\';\\n                }\\n            }\\n            else if(instructions[i]==\\'R\\'){\\n                if(d==\\'u\\'){\\n                    d=\\'r\\';\\n                }\\n                else if(d==\\'d\\'){\\n                    d=\\'l\\';\\n                }\\n                else if(d==\\'l\\'){\\n                    d=\\'u\\';\\n                }\\n                else if(d==\\'r\\'){\\n                    d=\\'d\\';\\n                }\\n            }\\n        }\\n        if(x==0 && y==0 || d!=\\'u\\'){return true;}\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509395,
                "title": "c-easy-and-simple-solution-time-o-n-space-o-1",
                "content": "# Intuition\\nIn this problem we see that we just have to follow given instructions and see the outcome or the final position to check wether a loop will be created or not.\\nWe start at the origin facing north, we follow the given instruction once. after that we chck if we are  back at the origin or not. if we are back at the origin, it means that it is a loop and we return true.\\nNow the catch is that these statements/instructions are followed infinitely so, even after we follow the instructions once and do not reach the origin, we have to check the dirction we are facing at that time. If we are facing north direction, it means that we are not at the starting point and we will be moving towards north i.e. we will be moving away from the starting point thus no loop is created and we return false. If we are not facing north direction at the end, it means we will be not moving away from the starting point and thus a loop will be created later on.\\n\\n# Approach\\nWe take two variables x and y for the current position of the robot and a variable d for the current direction it is facing.\\niterate the instructions and update the values of x,y,d accordingly.\\nat last check if x==0 && y==0 || d!=north. if the condition is satisfied,return true otherwise return false.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0,y=0;char d=\\'N\\';  //starting pos and direction of robot\\n        for(auto i:instructions){\\n            if(i==\\'G\\'){ //updating the curr pos of the robot according to the direction\\n                if(d==\\'N\\'){y++;}\\n                else if(d==\\'E\\'){x++;}\\n                else if(d==\\'S\\'){y--;}\\n                else{x--;}    \\n            }\\n            else if(i==\\'L\\'){  // updating direction if left instruction\\n                if(d==\\'N\\'){d=\\'W\\';}  //change to west, if curr direction is north and so forth according to the left \\n                else if(d==\\'E\\'){d=\\'N\\';}\\n                else if(d==\\'S\\'){d=\\'E\\';}\\n                else{d=\\'S\\';}\\n            }\\n            else{   //updating direction if right instruction\\n                if(d==\\'N\\'){d=\\'E\\';}  //change to east, if curr direction is north and so forth according to the right\\n                else if(d==\\'E\\'){d=\\'S\\';}\\n                else if(d==\\'S\\'){d=\\'W\\';}\\n                else{d=\\'N\\';}\\n            }\\n        }\\n        if(x==0 && y==0 || d!=\\'N\\'){return true;} //cheacking the final conditions\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0,y=0;char d=\\'N\\';  //starting pos and direction of robot\\n        for(auto i:instructions){\\n            if(i==\\'G\\'){ //updating the curr pos of the robot according to the direction\\n                if(d==\\'N\\'){y++;}\\n                else if(d==\\'E\\'){x++;}\\n                else if(d==\\'S\\'){y--;}\\n                else{x--;}    \\n            }\\n            else if(i==\\'L\\'){  // updating direction if left instruction\\n                if(d==\\'N\\'){d=\\'W\\';}  //change to west, if curr direction is north and so forth according to the left \\n                else if(d==\\'E\\'){d=\\'N\\';}\\n                else if(d==\\'S\\'){d=\\'E\\';}\\n                else{d=\\'S\\';}\\n            }\\n            else{   //updating direction if right instruction\\n                if(d==\\'N\\'){d=\\'E\\';}  //change to east, if curr direction is north and so forth according to the right\\n                else if(d==\\'E\\'){d=\\'S\\';}\\n                else if(d==\\'S\\'){d=\\'W\\';}\\n                else{d=\\'N\\';}\\n            }\\n        }\\n        if(x==0 && y==0 || d!=\\'N\\'){return true;} //cheacking the final conditions\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383283,
                "title": "c-very-simple-approach-for-handling-directions-by-degree",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to find if the robot in the end remains at any other position than origin(beginning point) and is in north direction, then by this we can conclude it will never be able to reach back at the same position with same direction.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, where n is length of the string.\\n\\n- Space complexity:\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int degree = 0, pointx = 0, pointy = 0;\\n        for(int i=0; i<instructions.size(); i++){\\n            if(instructions[i] == \\'G\\'){\\n                if(degree == 0) pointy += 1;\\n                else if(degree == 90 || degree == -270) pointx += 1;\\n                else if(degree == 180 || degree == -180) pointy -= 1;\\n                else if(degree == -90 || degree == 270) pointx -= 1;\\n            }\\n            else if(instructions[i] == \\'L\\'){\\n                degree -= 90;\\n                if(degree == -360) degree = 0;\\n            }\\n            else if(instructions[i] == \\'R\\'){\\n                degree += 90;\\n                if(degree == 360) degree = 0;\\n            }\\n        }\\n        if(degree == 0 && (pointx != 0 || pointy != 0)) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int degree = 0, pointx = 0, pointy = 0;\\n        for(int i=0; i<instructions.size(); i++){\\n            if(instructions[i] == \\'G\\'){\\n                if(degree == 0) pointy += 1;\\n                else if(degree == 90 || degree == -270) pointx += 1;\\n                else if(degree == 180 || degree == -180) pointy -= 1;\\n                else if(degree == -90 || degree == 270) pointx -= 1;\\n            }\\n            else if(instructions[i] == \\'L\\'){\\n                degree -= 90;\\n                if(degree == -360) degree = 0;\\n            }\\n            else if(instructions[i] == \\'R\\'){\\n                degree += 90;\\n                if(degree == 360) degree = 0;\\n            }\\n        }\\n        if(degree == 0 && (pointx != 0 || pointy != 0)) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974561,
                "title": "100-0-ms-easy-concise-proof",
                "content": "# UPVOTE PLS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/e1e3d1af-35d4-45d3-8239-a83fd4b6cf56_1672474349.4752996.png)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    public boolean isRobotBounded(String I) {\\n        int x=0,y=0,i=0,l=I.length(),D[][]={{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int j=0;j<l;j++){ char ch=I.charAt(j);\\n            if(ch==\\'L\\')  i=(i+3)%4;\\n            else if(ch==\\'R\\') i=(i+1)%4;\\n            else {\\n                x+=D[i][0];y+=D[i][1];\\n            }\\n        }return x==0 && y==0 || i>0;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    public boolean isRobotBounded(String I) {\\n        int x=0,y=0,i=0,l=I.length(),D[][]={{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int j=0;j<l;j++){ char ch=I.charAt(j);\\n            if(ch==\\'L\\')  i=(i+3)%4;\\n            else if(ch==\\'R\\') i=(i+1)%4;\\n            else {\\n                x+=D[i][0];y+=D[i][1];\\n            }\\n        }return x==0 && y==0 || i>0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2822746,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n       bool isRobotBounded(string instructions) {\\n        int x = 0, y = 0, i = 0;\\n        vector<vector<int>> d = {{0, 1}, {1, 0}, {0, -1}, { -1, 0}};\\n        for (char & ins : instructions)\\n            if (ins == \\'R\\')\\n                i = (i + 1) % 4;\\n            else if (ins == \\'L\\')\\n                i = (i + 3) % 4;\\n            else\\n                x += d[i][0], y += d[i][1];\\n        return x == 0 && y == 0 || i > 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       bool isRobotBounded(string instructions) {\\n        int x = 0, y = 0, i = 0;\\n        vector<vector<int>> d = {{0, 1}, {1, 0}, {0, -1}, { -1, 0}};\\n        for (char & ins : instructions)\\n            if (ins == \\'R\\')\\n                i = (i + 1) % 4;\\n            else if (ins == \\'L\\')\\n                i = (i + 3) % 4;\\n            else\\n                x += d[i][0], y += d[i][1];\\n        return x == 0 && y == 0 || i > 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607311,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\n    vector <int> dx = {0,1,0,-1};\\n    vector <int> dy = {1,0,-1,0};\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int direction = 0,x=0,y=0;\\n        for(int i=0;i<instructions.length();i++){\\n            if(instructions[i] == \\'L\\')\\n                direction--;\\n            else if(instructions[i] == \\'R\\')\\n                direction++;\\n            else{\\n                x += dx[direction];\\n                y += dy[direction];\\n            }\\n            direction = (direction+4) % 4;\\n        }\\n        if(direction != 0 || (!x && !y))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    vector <int> dx = {0,1,0,-1};\\n    vector <int> dy = {1,0,-1,0};\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int direction = 0,x=0,y=0;\\n        for(int i=0;i<instructions.length();i++){\\n            if(instructions[i] == \\'L\\')\\n                direction--;\\n            else if(instructions[i] == \\'R\\')\\n                direction++;\\n            else{\\n                x += dx[direction];\\n                y += dy[direction];\\n            }\\n            direction = (direction+4) % 4;\\n        }\\n        if(direction != 0 || (!x && !y))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459963,
                "title": "c-100-faster-easy-to-understand",
                "content": "**Code**\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int counter = 0;        bool shift = true;\\n        pair<int, int> pos = {0, 0};        \\n        int x = 0, y = 1;\\n        for(int i = 0; i < instructions.size(); ++i){\\n            if(instructions[i] == \\'L\\'){\\n                if(y == 1){\\n                    x = -1, y = 0;\\n                } else if(y == 0 && x == -1){\\n                    x = 0, y = -1;\\n                } else if(y == -1 && x == 0){\\n                    x = 1, y = 0;\\n                } else{\\n                    x = 0, y = 1;\\n                }\\n                ++counter;\\n            } else if(instructions[i] == \\'R\\'){\\n                if(y == 1){\\n                    x = 1, y = 0;\\n                } else if(y == 0 && x == -1){\\n                    x = 0, y = 1;\\n                } else if(y == -1 && x == 0){\\n                    x = -1, y = 0;\\n                } else{\\n                    x = 0, y = -1;\\n                }\\n                --counter;\\n            } else{\\n                pos = {pos.first + x, pos.second + y};\\n                shift = true;\\n            }\\n        }\\n        counter = counter % 4;\\n        \\n      \\n        if(counter != 0 || !shift || (pos.first == 0 && pos.second == 0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n**Output**\\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Robot Bounded In Circle.\\nMemory Usage: 6.2 MB, less than 52.55% of C++ online submissions for Robot Bounded In Circle.\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int counter = 0;        bool shift = true;\\n        pair<int, int> pos = {0, 0};        \\n        int x = 0, y = 1;\\n        for(int i = 0; i < instructions.size(); ++i){\\n            if(instructions[i] == \\'L\\'){\\n                if(y == 1){\\n                    x = -1, y = 0;\\n                } else if(y == 0 && x == -1){\\n                    x = 0, y = -1;\\n                } else if(y == -1 && x == 0){\\n                    x = 1, y = 0;\\n                } else{\\n                    x = 0, y = 1;\\n                }\\n                ++counter;\\n            } else if(instructions[i] == \\'R\\'){\\n                if(y == 1){\\n                    x = 1, y = 0;\\n                } else if(y == 0 && x == -1){\\n                    x = 0, y = 1;\\n                } else if(y == -1 && x == 0){\\n                    x = -1, y = 0;\\n                } else{\\n                    x = 0, y = -1;\\n                }\\n                --counter;\\n            } else{\\n                pos = {pos.first + x, pos.second + y};\\n                shift = true;\\n            }\\n        }\\n        counter = counter % 4;\\n        \\n      \\n        if(counter != 0 || !shift || (pos.first == 0 && pos.second == 0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Robot Bounded In Circle.\\nMemory Usage: 6.2 MB, less than 52.55% of C++ online submissions for Robot Bounded In Circle.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416399,
                "title": "simple-java-with-explanation",
                "content": "```\\n/*\\n    The below solution might seem long, but is very easy if you understand the intuition.\\n    If we think deep, at the end of the execution of all instructions if the robot remained in the \\n    initial coordinate, it is running into circles. \\n    Or if the direction has changed say for ex: S is the direction at the end of execution of instructions.\\n    that means if we execute the same instruction again, it would face north and go back the steps it has \\n    taken.\\n    \\n    Similarly, if the direction is set to E or W, if we execute the instruction 3 more times it would go back \\n    to where it was initially.\\n    \\n    So just return true, if initial direction has changed or if the coordinate hasnot changed.\\n*/\\n```\\n\\nclass Solution {\\n    \\n    class Coordinate{\\n        int x;\\n        int y;\\n        Coordinate(int x, int y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    public boolean isRobotBounded(String instructions) {\\n        char direction = \\'N\\';\\n        Coordinate curr = new Coordinate(0,0);\\n        \\n        for(int i=0;i<instructions.length();i++){\\n            char ins = instructions.charAt(i);\\n            direction = changeDirection(ins,direction);\\n            curr = changeCoordinate(ins, direction,curr);\\n        }\\n        \\n        int x = curr.x;\\n        int y= curr.y;\\n        return (curr.x==0 && curr.y==0) || direction!=\\'N\\';\\n    }\\n    \\n    // helper method to change coordinate.\\n    private Coordinate changeCoordinate(char ins, char currDir,Coordinate currCor){\\n        switch(currDir){\\n            case \\'N\\': \\n                if(ins==\\'G\\')\\n                    return new Coordinate(currCor.x,currCor.y+1);\\n                \\n            case \\'E\\': \\n                if(ins==\\'G\\')\\n                    return new Coordinate(currCor.x+1,currCor.y);\\n                \\n            case \\'W\\': \\n                if(ins==\\'G\\')\\n                    return new Coordinate(currCor.x-1,currCor.y);\\n\\n            case \\'S\\': \\n                if(ins==\\'G\\')\\n                    return new Coordinate(currCor.x,currCor.y-1);\\n                \\n            default: return currCor;\\n        }\\n    }\\n    \\n    //helper method to change direction.\\n    private char changeDirection(char ins,char currDir){\\n        switch(currDir){\\n            case \\'N\\':\\n                if(ins==\\'L\\')\\n                    return \\'W\\';\\n                else if(ins==\\'R\\')\\n                    return \\'E\\';\\n            case \\'W\\':\\n                if(ins==\\'L\\')\\n                    return \\'S\\';\\n                else if(ins==\\'R\\')\\n                    return \\'N\\';\\n            case \\'E\\':\\n                if(ins==\\'L\\')\\n                    return \\'N\\';\\n                else if(ins==\\'R\\')\\n                    return \\'S\\';\\n            case \\'S\\':\\n                if(ins==\\'L\\')\\n                    return \\'E\\';\\n                else if(ins==\\'R\\')\\n                    return \\'W\\';\\n            default:\\n                return currDir;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n    The below solution might seem long, but is very easy if you understand the intuition.\\n    If we think deep, at the end of the execution of all instructions if the robot remained in the \\n    initial coordinate, it is running into circles. \\n    Or if the direction has changed say for ex: S is the direction at the end of execution of instructions.\\n    that means if we execute the same instruction again, it would face north and go back the steps it has \\n    taken.\\n    \\n    Similarly, if the direction is set to E or W, if we execute the instruction 3 more times it would go back \\n    to where it was initially.\\n    \\n    So just return true, if initial direction has changed or if the coordinate hasnot changed.\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2378324,
                "title": "best-beats-100-submissions",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    bool isRobotBounded(string S) {\\n        int x = 0;\\n        int y = 0;\\n        int direction = 0;\\n\\n            for(int i = 0; i < S.size(); i++)\\n            {\\n                if(S[i] == \\'L\\')\\n                    direction = (direction + 3) % 4;\\n                else if(S[i] == \\'R\\')\\n                    direction = (direction + 1) % 4;\\n                else\\n                {\\n                    switch(direction)\\n                    {\\n                        case 0: {\\n                            y++;\\n                            break;\\n                        }\\n                        case 1: {\\n                            x++;\\n                            break;\\n                        }\\n                        case 2:{\\n                            y--;\\n                            break;\\n                        }\\n                        case 3:{\\n                            x--;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n\\n        if(direction != 0 || (x == 0 && y == 0))\\n                return true;\\n        else \\n            return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool isRobotBounded(string S) {\\n        int x = 0;\\n        int y = 0;\\n        int direction = 0;\\n\\n            for(int i = 0; i < S.size(); i++)\\n            {\\n                if(S[i] == \\'L\\')\\n                    direction = (direction + 3) % 4;\\n                else if(S[i] == \\'R\\')\\n                    direction = (direction + 1) % 4;\\n                else\\n                {\\n                    switch(direction)\\n                    {\\n                        case 0: {\\n                            y++;\\n                            break;\\n                        }\\n                        case 1: {\\n                            x++;\\n                            break;\\n                        }\\n                        case 2:{\\n                            y--;\\n                            break;\\n                        }\\n                        case 3:{\\n                            x--;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n\\n        if(direction != 0 || (x == 0 && y == 0))\\n                return true;\\n        else \\n            return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298635,
                "title": "python-straightforward-o-n-solution",
                "content": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        hashmap={}\\n        start=[0,0]\\n        facing=\"N\"\\n        LA={\"N\":\"W\",\"W\":\"S\",\"S\":\"E\",\"E\":\"N\"}\\n        RC={\"N\":\"E\",\"E\":\"S\",\"S\":\"W\",\"W\":\"N\"}\\n        res=[]\\n        for i in instructions:\\n            if i==\"G\":\\n                if facing==\"N\": start[1] += 1\\n                elif facing==\"E\": start[0] += 1\\n                elif facing==\"W\": start[0] -= 1\\n                elif facing==\"S\": start[1] -= 1\\n            elif i==\"L\":\\n                facing=LA[facing]\\n            elif i==\"R\":\\n                facing=RC[facing]\\n        if start==[0,0] or facing!=\"N\": return True\\n        else: return False\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        hashmap={}\\n        start=[0,0]\\n        facing=\"N\"\\n        LA={\"N\":\"W\",\"W\":\"S\",\"S\":\"E\",\"E\":\"N\"}\\n        RC={\"N\":\"E\",\"E\":\"S\",\"S\":\"W\",\"W\":\"N\"}\\n        res=[]\\n        for i in instructions:\\n            if i==\"G\":\\n                if facing==\"N\": start[1] += 1\\n                elif facing==\"E\": start[0] += 1\\n                elif facing==\"W\": start[0] -= 1\\n                elif facing==\"S\": start[1] -= 1\\n            elif i==\"L\":\\n                facing=LA[facing]\\n            elif i==\"R\":\\n                facing=RC[facing]\\n        if start==[0,0] or facing!=\"N\": return True\\n        else: return False\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094926,
                "title": "c-solution-explained-100-faster-time-o-n-space-o-1",
                "content": "**It can be proved that after following the instruction once, if we are back at the origin or if we are at some other position and not facing towards north, then we will eventually reach the origin either after one or three more repetitions of the instructions**\\nThe proof for it requires a some mathematical understanding of co-ordinate geometry. Hence, I am skipping the proof in this discussion. I suggest you to try proving this once on your own if you are curious. If you are unable to prove this then I would be more than happy to share the proof with you (just ping me up once in the comments, if you wish to know the proof as well).\\n\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        // 0: North,  1: East, 2: South, 3: West\\n        vector<vector<int>>movement={{0,1},{1,0},{0,-1},{-1,0}}; // Movements in x, y co-ordinate according to direction \\n        int x=0,y=0,i=0;\\n        for(char c: instructions)\\n        {\\n            if(c==\\'R\\') i=(i+1)%4; // changing direction\\n            if(c==\\'L\\') i=(i+3)%4; // changing direction\\n            if(c==\\'G\\')\\n            {\\n                //  Moving according to current direction\\n                x+=movement[i][0];\\n                y+=movement[i][1];\\n            }\\n        }\\n        // In the end if we are at (0,0) then return true. Or if, we are at some other place and we are not facing North then we will reach at (0,0) either after 1 or 3 more steps. Hence return true.\\n        return  ((x==0 && y==0 ) || i!=0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        // 0: North,  1: East, 2: South, 3: West\\n        vector<vector<int>>movement={{0,1},{1,0},{0,-1},{-1,0}}; // Movements in x, y co-ordinate according to direction \\n        int x=0,y=0,i=0;\\n        for(char c: instructions)\\n        {\\n            if(c==\\'R\\') i=(i+1)%4; // changing direction\\n            if(c==\\'L\\') i=(i+3)%4; // changing direction\\n            if(c==\\'G\\')\\n            {\\n                //  Moving according to current direction\\n                x+=movement[i][0];\\n                y+=movement[i][1];\\n            }\\n        }\\n        // In the end if we are at (0,0) then return true. Or if, we are at some other place and we are not facing North then we will reach at (0,0) either after 1 or 3 more steps. Hence return true.\\n        return  ((x==0 && y==0 ) || i!=0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994516,
                "title": "c-easy-to-understand-robot-bounded",
                "content": "Irrespective of what path you take, the result is only based on your final direction and final distance from the origin. Possible cases to be in a cycle are:\\n1. First one is that after following the instructions, you **end up at origin** which clearly indicates that you are in a cycle irrespective of what direction you end up facing. This is because after following the instructions at max 4 times, you will be in initial state at origin and direction (0,1)\\n2. Second one is if you do not end up at origin after following the instructions, you must have a **direction different from the initial direction** to be in a cycle. This is because summing 4 vectors of same length from origin to final position and each at +90deg in case final direction is \\'L\\' or (-1,0) (or -90 in case final direction is \\'R\\' or (1,0)) will lead you to origin. Or in case the final direction is (0,-1), the vector will take you back to origin after two cycles only.\\n```\\nbool isRobotBounded(string instructions) {\\n        pair<int,int> start = make_pair(0,0), init_direction = make_pair(0,1);\\n        pair<int,int> direction = init_direction, dist = make_pair(0,0);\\n        for(auto& i:instructions) {\\n            switch(i) {\\n                case \\'G\\': {\\n                    dist.first += direction.first;\\n                    dist.second += direction.second; \\n                    break;\\n                }\\n                case \\'L\\': {\\n                    swap(direction.first, direction.second);\\n                    direction.first *= -1; \\n                    break;\\n                }\\n                case \\'R\\': {\\n                    swap(direction.first, direction.second);\\n                    direction.second *= -1; \\n                    break;\\n                }\\n            }\\n        }\\n        return (direction != init_direction || (!dist.first && !dist.second));\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Irrespective of what path you take, the result is only based on your final direction and final distance from the origin. Possible cases to be in a cycle are:\\n1. First one is that after following the instructions, you **end up at origin** which clearly indicates that you are in a cycle irrespective of what direction you end up facing. This is because after following the instructions at max 4 times, you will be in initial state at origin and direction (0,1)\\n2. Second one is if you do not end up at origin after following the instructions, you must have a **direction different from the initial direction** to be in a cycle. This is because summing 4 vectors of same length from origin to final position and each at +90deg in case final direction is \\'L\\' or (-1,0) (or -90 in case final direction is \\'R\\' or (1,0)) will lead you to origin. Or in case the final direction is (0,-1), the vector will take you back to origin after two cycles only.\\n```\\nbool isRobotBounded(string instructions) {\\n        pair<int,int> start = make_pair(0,0), init_direction = make_pair(0,1);\\n        pair<int,int> direction = init_direction, dist = make_pair(0,0);\\n        for(auto& i:instructions) {\\n            switch(i) {\\n                case \\'G\\': {\\n                    dist.first += direction.first;\\n                    dist.second += direction.second; \\n                    break;\\n                }\\n                case \\'L\\': {\\n                    swap(direction.first, direction.second);\\n                    direction.first *= -1; \\n                    break;\\n                }\\n                case \\'R\\': {\\n                    swap(direction.first, direction.second);\\n                    direction.second *= -1; \\n                    break;\\n                }\\n            }\\n        }\\n        return (direction != init_direction || (!dist.first && !dist.second));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1699551,
                "title": "c-self-explanatory-easy-100-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        char dir=\\'N\\';\\n        int x=0;int y=0;\\n        int n=instructions.size();\\n        for(int i=0;i<n;i++){\\n            \\n            //move straight\\n            if(instructions[i] == \\'G\\'){\\n                if(dir == \\'N\\') y+=1;\\n                else if(dir == \\'S\\') y-=1;\\n                else if(dir == \\'E\\') x+=1;\\n                else x-=1;\\n            }\\n            \\n            //turning to left direction\\n            else if(instructions[i] == \\'L\\'){\\n                if(dir == \\'N\\') dir=\\'W\\';\\n                else if(dir == \\'S\\') dir=\\'E\\';\\n                else if(dir == \\'E\\') dir=\\'N\\';\\n                else dir=\\'S\\';\\n            }\\n            \\n            //turning to right direction\\n            else{\\n                if(dir == \\'N\\') dir=\\'E\\';\\n                else if(dir == \\'S\\') dir=\\'W\\';\\n                else if(dir == \\'E\\') dir=\\'S\\';\\n                else dir=\\'N\\';\\n            }            \\n        }\\n        if(x==0 && y==0) return true;       //means it returns to original points.\\n        if(dir == \\'N\\') return false;               //since we are moving away from origin.\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        char dir=\\'N\\';\\n        int x=0;int y=0;\\n        int n=instructions.size();\\n        for(int i=0;i<n;i++){\\n            \\n            //move straight\\n            if(instructions[i] == \\'G\\'){\\n                if(dir == \\'N\\') y+=1;\\n                else if(dir == \\'S\\') y-=1;\\n                else if(dir == \\'E\\') x+=1;\\n                else x-=1;\\n            }\\n            \\n            //turning to left direction\\n            else if(instructions[i] == \\'L\\'){\\n                if(dir == \\'N\\') dir=\\'W\\';\\n                else if(dir == \\'S\\') dir=\\'E\\';\\n                else if(dir == \\'E\\') dir=\\'N\\';\\n                else dir=\\'S\\';\\n            }\\n            \\n            //turning to right direction\\n            else{\\n                if(dir == \\'N\\') dir=\\'E\\';\\n                else if(dir == \\'S\\') dir=\\'W\\';\\n                else if(dir == \\'E\\') dir=\\'S\\';\\n                else dir=\\'N\\';\\n            }            \\n        }\\n        if(x==0 && y==0) return true;       //means it returns to original points.\\n        if(dir == \\'N\\') return false;               //since we are moving away from origin.\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694103,
                "title": "java-easiest-solution-readable",
                "content": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        String currentpos=\"north\";\\n        int x=0;\\n        int y=0;\\n        for(int i=0;i<instructions.length();i++){\\n            char alpha=instructions.charAt(i);\\n            switch(alpha){\\n                case \\'G\\':\\n                    currentpos=currentpos;\\n                    if(currentpos==\"north\"){\\n                        y+=1;\\n                    }else if(currentpos==\"west\"){\\n                        x-=1;\\n                    }else if(currentpos==\"south\"){\\n                        y-=1;\\n                    }else if(currentpos==\"east\"){\\n                        x+=1;\\n                    }\\n                    break;\\n                case \\'L\\':\\n                    if(currentpos==\"north\"){\\n                        currentpos=\"west\";\\n                    }else if(currentpos==\"west\"){\\n                        currentpos=\"south\";\\n                    }else if(currentpos==\"south\"){\\n                        currentpos=\"east\";\\n                    }else if(currentpos==\"east\"){\\n                        currentpos=\"north\";\\n                    }\\n                    break;\\n                case \\'R\\':\\n                    if(currentpos==\"north\"){\\n                        currentpos=\"east\";\\n                    }else if(currentpos==\"east\"){\\n                        currentpos=\"south\";\\n                    }else if(currentpos==\"south\"){\\n                        currentpos=\"west\";\\n                    }else if(currentpos==\"west\"){\\n                        currentpos=\"north\";\\n                    }\\n                    break;\\n                \\n                    \\n            }\\n        }\\n        if(x==0&&y==0){return true;}\\n        if(currentpos==\"north\"){return false;}//if the robot is facing north then it\\'s not bounded inside a circle.\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        String currentpos=\"north\";\\n        int x=0;\\n        int y=0;\\n        for(int i=0;i<instructions.length();i++){\\n            char alpha=instructions.charAt(i);\\n            switch(alpha){\\n                case \\'G\\':\\n                    currentpos=currentpos;\\n                    if(currentpos==\"north\"){\\n                        y+=1;\\n                    }else if(currentpos==\"west\"){\\n                        x-=1;\\n                    }else if(currentpos==\"south\"){\\n                        y-=1;\\n                    }else if(currentpos==\"east\"){\\n                        x+=1;\\n                    }\\n                    break;\\n                case \\'L\\':\\n                    if(currentpos==\"north\"){\\n                        currentpos=\"west\";\\n                    }else if(currentpos==\"west\"){\\n                        currentpos=\"south\";\\n                    }else if(currentpos==\"south\"){\\n                        currentpos=\"east\";\\n                    }else if(currentpos==\"east\"){\\n                        currentpos=\"north\";\\n                    }\\n                    break;\\n                case \\'R\\':\\n                    if(currentpos==\"north\"){\\n                        currentpos=\"east\";\\n                    }else if(currentpos==\"east\"){\\n                        currentpos=\"south\";\\n                    }else if(currentpos==\"south\"){\\n                        currentpos=\"west\";\\n                    }else if(currentpos==\"west\"){\\n                        currentpos=\"north\";\\n                    }\\n                    break;\\n                \\n                    \\n            }\\n        }\\n        if(x==0&&y==0){return true;}\\n        if(currentpos==\"north\"){return false;}//if the robot is facing north then it\\'s not bounded inside a circle.\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687315,
                "title": "c-easy-solution-19-lines-code-0-ms-runtime",
                "content": "When you run the instructions 4 times continuously and if you\\'re coming back to 0,0 then it can be contained inside a circle else not\\n\\n```\\nbool isRobotBounded(string s) {\\n        int l=0,x=0,y=0;\\n        s+=s;\\n        s+=s;\\n        for(char c:s){\\n            l+=c==\\'L\\';\\n            l-=c==\\'R\\';\\n            if(c==\\'G\\'){\\n                l=l%4;\\n                l+=4;\\n                l=l%4;\\n                if(l==0)y++;\\n                else if(l==1) x--;\\n                else if(l==2) y--;\\n                else if(l==3) x++;\\n            }\\n        }\\n        return x==0 && y==0;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isRobotBounded(string s) {\\n        int l=0,x=0,y=0;\\n        s+=s;\\n        s+=s;\\n        for(char c:s){\\n            l+=c==\\'L\\';\\n            l-=c==\\'R\\';\\n            if(c==\\'G\\'){\\n                l=l%4;\\n                l+=4;\\n                l=l%4;\\n                if(l==0)y++;\\n                else if(l==1) x--;\\n                else if(l==2) y--;\\n                else if(l==3) x++;\\n            }\\n        }\\n        return x==0 && y==0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1679424,
                "title": "java-0-ms-explained",
                "content": "**Idea:**\\n* To change position (G), move one step along the current facing direction\\n* To turn left, `(X, Y) -> (-Y, X)`. [Read more here](https://math.stackexchange.com/questions/1330161/how-to-rotate-points-through-90-degree/1330166#1330166)\\n* To turn right, `(X, Y) -> (Y, -X)`\\n* At the end the robot is bounded if:\\n\\t* it returns to Origin (zero displacement), or\\n\\t* the facing direction has changed, which can happen with a change in either horizontal or vertical component of the direction\\n>**T/S:** O(n)/O(1), where n = size(instructions)\\n```\\npublic boolean isRobotBounded(String instructions) {\\n\\tvar x = 0; // horizontal position\\n\\tvar y = 0; // vertical position\\n\\tvar dirs = new int[]{0, 1}; // horizontal and vertical directions respectively, initially facing north\\n\\n\\tfor (var i = 0; i < instructions.length(); i++)\\n\\t\\tswitch (instructions.charAt(i)) {\\n\\t\\t\\tcase \\'G\\' -> {\\n\\t\\t\\t\\tx += dirs[0];\\n\\t\\t\\t\\ty += dirs[1];\\n\\t\\t\\t}\\n\\t\\t\\tcase \\'L\\' -> swap(dirs, true);\\n\\t\\t\\tcase \\'R\\' -> swap(dirs, false);\\n\\t\\t}\\n\\n\\treturn x == 0 && y == 0 || dirs[0] != 0 || dirs[1] != 1;\\n}\\n\\nprivate void swap(int[] dirs, boolean negativeY) {\\n\\tvar temp = dirs[0];\\n\\tdirs[0] = negativeY ? -dirs[1] : dirs[1];\\n\\tdirs[1] = negativeY ? temp : -temp;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean isRobotBounded(String instructions) {\\n\\tvar x = 0; // horizontal position\\n\\tvar y = 0; // vertical position\\n\\tvar dirs = new int[]{0, 1}; // horizontal and vertical directions respectively, initially facing north\\n\\n\\tfor (var i = 0; i < instructions.length(); i++)\\n\\t\\tswitch (instructions.charAt(i)) {\\n\\t\\t\\tcase \\'G\\' -> {\\n\\t\\t\\t\\tx += dirs[0];\\n\\t\\t\\t\\ty += dirs[1];\\n\\t\\t\\t}\\n\\t\\t\\tcase \\'L\\' -> swap(dirs, true);\\n\\t\\t\\tcase \\'R\\' -> swap(dirs, false);\\n\\t\\t}\\n\\n\\treturn x == 0 && y == 0 || dirs[0] != 0 || dirs[1] != 1;\\n}\\n\\nprivate void swap(int[] dirs, boolean negativeY) {\\n\\tvar temp = dirs[0];\\n\\tdirs[0] = negativeY ? -dirs[1] : dirs[1];\\n\\tdirs[1] = negativeY ? temp : -temp;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1679049,
                "title": "c-o-n-solution-100-time-thinking-process-explained",
                "content": "# Let us think through the algo\\n\\n\\uD83E\\uDD14 **My thoughts were like**\\n- Oh, let\\u2018s just add 1 if it turns left, and subtract 1 if right, then if we had (counter mod 4) == 1 -> we won... *wait why is it medium then* ><\\n- Although it helped with all the type-1 problems, we had type-2 problems (check picture) -> I decided to handle the exceptions, but there was too many of them\\n- So I thought to play with the resulting vector\\u2019s coordinates a little bit.\\n\\n![image](https://assets.leetcode.com/users/images/2a376280-7fe2-46d2-aedb-48d2fe92ec12_1641757488.1144092.jpeg)\\n\\n\\uD83E\\uDD16 **Thinking of the resulting move after the first set of commands, one can easily notice, that:**\\n- If we didn\\u2018t move after the whole bunch of instructions execution, we can catch our robot in a circle easily :)\\n- If we moved somewhere, but at the end we are pointing north again, the circle does not exist at all, it is like a building block for our robot to escape the circle. Check the picture if my explaination is too cloudy for you)\\n\\n![image](https://assets.leetcode.com/users/images/3c308f6a-57a3-4df8-b851-9c8cbfb25fed_1641758390.9230664.jpeg)\\n\\n\\uD83D\\uDED1 This is the way of deciding whether the circle exists, the rest is about code, then let\\u2018s go coding!\\n\\nProof that this is a 100%-time code: ![image](https://assets.leetcode.com/users/images/0c4e2d98-a935-4491-bd70-170cd3f02aa3_1641758701.2274578.png)\\n\\n\\uD83D\\uDCBB Code with comments downhere, **upvote if the explaination was helpful** please!\\n\\n```\\nclass Solution {\\n public:\\n  bool isRobotBounded(string instructions) {\\n    // current coords vector in (x, y)-form\\n    int current_vec[2] = {0, 0};\\n    // all turns possibilities clockwise in (x, y)-form\\n    int turns[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    // where is our robot pointing, index at turned list\\n    int index = 0;\\n    \\n    for (auto iteration : instructions) {\\n      if (iteration == \\'L\\' or iteration == \\'R\\') {\\n        // if we are turning left -> pointing ar index-1,\\n        // if right -> index+1\\n\\t\\t    index += iteration == \\'L\\' ? -1 : 1;\\n        // because -1 % 4 is still -1 -> out of bounds error\\n        index = (index % 4 + 4) % 4;\\n      }\\n      else if (iteration == \\'G\\') {\\n        // after all the turns going by the pointing vector\\n        current_vec[0] += turns[index][0];\\n        current_vec[1] += turns[index][1];\\n      }\\n    }\\n    // our robot stays in the circle iff it either changes direction...\\n    bool no_sideways_turn = !(turns[index][0] == 0 and turns[index][1] == 1); \\n    // ...or if it did not move at all!\\n    bool no_place_change = current_vec[0] == 0 and current_vec[1] == 0;\\n    \\n    return no_place_change or no_sideways_turn;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  bool isRobotBounded(string instructions) {\\n    // current coords vector in (x, y)-form\\n    int current_vec[2] = {0, 0};\\n    // all turns possibilities clockwise in (x, y)-form\\n    int turns[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    // where is our robot pointing, index at turned list\\n    int index = 0;\\n    \\n    for (auto iteration : instructions) {\\n      if (iteration == \\'L\\' or iteration == \\'R\\') {\\n        // if we are turning left -> pointing ar index-1,\\n        // if right -> index+1\\n\\t\\t    index += iteration == \\'L\\' ? -1 : 1;\\n        // because -1 % 4 is still -1 -> out of bounds error\\n        index = (index % 4 + 4) % 4;\\n      }\\n      else if (iteration == \\'G\\') {\\n        // after all the turns going by the pointing vector\\n        current_vec[0] += turns[index][0];\\n        current_vec[1] += turns[index][1];\\n      }\\n    }\\n    // our robot stays in the circle iff it either changes direction...\\n    bool no_sideways_turn = !(turns[index][0] == 0 and turns[index][1] == 1); \\n    // ...or if it did not move at all!\\n    bool no_place_change = current_vec[0] == 0 and current_vec[1] == 0;\\n    \\n    return no_place_change or no_sideways_turn;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678891,
                "title": "c-clean-and-clear-code-beats-100-fast-and-simple",
                "content": "```\\n bool isRobotBounded(string instructions) {\\n     /* North : 0,East:1,South:2,West:3\\n        Right : +1 ,Left : -1\\n        Coordinate change in each Direction N,E,S,W resp.\\n                    {0,1,0,-1}\\n                    {1,0,-1,0}\\n        */\\n        vector<int> xCo = {0,1,0,-1};\\n        vector<int> yCo = {1,0,-1,0};\\n        int x=0,y=0;//Initial coordinates of Robots\\n        int currentDirection =0;//North\\n        for(int i=0;i<instructions.size();i++)\\n        {\\n            if(instructions[i]==\\'R\\')\\n            {\\n                currentDirection = (currentDirection+1)%4;\\n            }\\n            else if(instructions[i]==\\'L\\')\\n            {\\n                currentDirection = (4+(currentDirection-1))%4; \\n            }\\n            else\\n            {\\n                x+=xCo[currentDirection];\\n                y+=yCo[currentDirection];\\n            }\\n        }\\n        return currentDirection != 0 || (x==0 && y==0);\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n bool isRobotBounded(string instructions) {\\n     /* North : 0,East:1,South:2,West:3\\n        Right : +1 ,Left : -1\\n        Coordinate change in each Direction N,E,S,W resp.\\n                    {0,1,0,-1}\\n                    {1,0,-1,0}\\n        */\\n        vector<int> xCo = {0,1,0,-1};\\n        vector<int> yCo = {1,0,-1,0};\\n        int x=0,y=0;//Initial coordinates of Robots\\n        int currentDirection =0;//North\\n        for(int i=0;i<instructions.size();i++)\\n        {\\n            if(instructions[i]==\\'R\\')\\n            {\\n                currentDirection = (currentDirection+1)%4;\\n            }\\n            else if(instructions[i]==\\'L\\')\\n            {\\n                currentDirection = (4+(currentDirection-1))%4; \\n            }\\n            else\\n            {\\n                x+=xCo[currentDirection];\\n                y+=yCo[currentDirection];\\n            }\\n        }\\n        return currentDirection != 0 || (x==0 && y==0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1678696,
                "title": "javascript-easy-to-understand-1-loop",
                "content": "// Image an x-y plane, the original posion is [0, 0], the final position is [x, y];\\n    // The following situations that robot will go away which is a false result:\\n    // the final posion is not original posion and direction is not changed.\\n    // And other situations will result to a circulation movement, that means robot won\\'t leave a circle,\\n    // and return true\\n    // This is why it happens. If the final posion is on the original position, no matter how the directions change, the next operations will take it back to original position.\\n    // If the final position is not original position, that means an offset happens at some direction and some distance. If the final direction is not changed, the same offset will happen after another operation. That is the robot will go away forever.\\n    // If the final direction is changed by 180 degree, the next operation will result to an oppsite offset which bring the robot back to the original position.\\n    // If the final direction is changed by 90 degree, the next operation will result to an 90 degree offset with the same distance changes. And four times of this happens will brings the robot to the original positions\\n    // set direction 0 -> up, 1 -> right, 2 -> down, 3 -> left.\\n    // if next direction is L, then direction substract 1 and add 4 then mod 4 (add 4 in case the number is less than 0)\\n    // which is simply plus 3 then mod 4.\\n    // if next direction is R, then direction add 1 then mod 4.\\n    // set original posion is [0, 0], original direction is 0 -> up.\\n    // record the final position and final direction.\\n\\t// If the final position is not original position and the final direction is still 0 (up), then return false, else return true\\n \\n ```\\nvar isRobotBounded = function(instructions) {\\n    let x = 0, y = 0;\\n    let direction = 0;\\n    for (let operation of instructions) {\\n        if (operation === \\'G\\') {\\n            if (direction === 0) { // up\\n                y++;\\n            } else if (direction === 1) { // right\\n                x++;\\n            } else if (direction === 2) { // down\\n                y--;\\n            } else { // left\\n                x--;\\n            }\\n        } else if (operation === \\'L\\') {\\n            direction = (direction + 3) % 4;\\n        } else {\\n            direction = (direction + 1) % 4;\\n        }\\n    }\\n    if ((x !== 0 || y !== 0) && direction === 0) {\\n        return false;\\n    } else {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isRobotBounded = function(instructions) {\\n    let x = 0, y = 0;\\n    let direction = 0;\\n    for (let operation of instructions) {\\n        if (operation === \\'G\\') {\\n            if (direction === 0) { // up\\n                y++;\\n            } else if (direction === 1) { // right\\n                x++;\\n            } else if (direction === 2) { // down\\n                y--;\\n            } else { // left\\n                x--;\\n            }\\n        } else if (operation === \\'L\\') {\\n            direction = (direction + 3) % 4;\\n        } else {\\n            direction = (direction + 1) % 4;\\n        }\\n    }\\n    if ((x !== 0 || y !== 0) && direction === 0) {\\n        return false;\\n    } else {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1678569,
                "title": "c-solution-daily-leetcoding-challenge-jan-9",
                "content": "The robot can travel these 4 directions: d (0-up, 1-left, 2-down, 3-right) when it is in the north direction. The variables  `x` and `y` shows the positions of the robot on the plane . The variable `d` shows the direction of the robot.\\n\\nThe conditons to return true after all the iterations:\\n1. `d` should not be equal to 0\\n2.  The robot should return to origin, i.e., `x == 0 && y == 0`.\\n\\nTime Complexity : O(n)\\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Robot Bounded In Circle.\\nMemory Usage: 6.3 MB, less than 19.45% of C++ online submissions for Robot Bounded In Circle.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) \\n    {\\n        int x = 0, y = 0;\\n        int d = 0;\\n        vector<vector<int>> pos= {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(auto i : instructions)\\n        {\\n            if(i == \\'G\\')\\n            {\\n                x += pos[d][0];\\n                y += pos[d][1];\\n            }\\n            else if(i == \\'L\\')\\n            {\\n                d = (d+3) % 4;\\n            }\\n            else if(i == \\'R\\')\\n            {\\n                d = (d+1) % 4;\\n            }\\n        }\\n        return (d != 0 || (x == 0 && y == 0));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Robot Bounded In Circle.\\nMemory Usage: 6.3 MB, less than 19.45% of C++ online submissions for Robot Bounded In Circle.\\n```\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) \\n    {\\n        int x = 0, y = 0;\\n        int d = 0;\\n        vector<vector<int>> pos= {{0,1},{1,0},{0,-1},{-1,0}};\\n        for(auto i : instructions)\\n        {\\n            if(i == \\'G\\')\\n            {\\n                x += pos[d][0];\\n                y += pos[d][1];\\n            }\\n            else if(i == \\'L\\')\\n            {\\n                d = (d+3) % 4;\\n            }\\n            else if(i == \\'R\\')\\n            {\\n                d = (d+1) % 4;\\n            }\\n        }\\n        return (d != 0 || (x == 0 && y == 0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678243,
                "title": "python-solution-leetcode-solution-neetcode-s-explanation",
                "content": "Idea:\\nExample - going left:\\n\\nif pos is [1,1],\\n\\n* (North in graph)\\ndirection is [0,1]  - we want to go left - we have to add to pos [-1,0] \\n\\n* (west in graph) \\ndirection is [-1,0]  - we want to go left - we have to add to pos [0,-1] \\n \\n* (south in graph) \\ndirection is [0,-1] we want to go left - we have to add to pos [1,0] \\n\\n* (east in graph) \\ndirection is [1,0] we want to go left - we have to add to pos [0,1] \\n\\nExample - going right:\\n\\nif pos is [1,1], \\n* (North in graph)\\ndirection is [0,1] we want to go right - we have to add to pos [1,0] \\n\\n* (west in graph) \\ndirection is [-1,0] we want to go right - we have to add to pos [0,1] \\n\\n* (south in graph)\\ndirection is [0,-1] we want to go right - we have to add to pos [-1,0] \\n\\n* (east in graph)\\ndirection is [1,0] we want to go right - we have to add to pos [0,-1] \\n\\nThat calculation brings us to the conclusion that:\\n* For going left we change the direction [x,y] to [-y,x]\\n* For going right we change the direction [x,y] to [y,-x]\\n\\nWe initialize position to 0,0 and direction to north.\\nIf position got back to original, or we changed original direction, the answer is True.\\n\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        dirX, dirY = 0 , 1 # north\\n        x , y = 0 , 0\\n        \\n        for i in instructions:\\n            if i == \"G\":\\n                x , y = x + dirX, y + dirY\\n            elif i == \"L\":\\n                dirX, dirY = -1 * dirY , dirX\\n            else:\\n                dirX, dirY = dirY , -1 * dirX\\n                \\n        return (x,y) == (0,0) or (dirX , dirY) != (0,1) # if we are back at same point or if direction is not facing north after first circle. Then we are bound to come back and form a circle.\\n```\\n\\nWe do not need to run 4 cycles to identify the limit cycle trajectory. One cycle is enough. There could be two situations here.\\n\\nFirst, if the robot returns to the initial point after one cycle, that\\'s the limit cycle trajectory.\\n\\nSecond, if the robot doesn\\'t face north at the end of the first cycle, that\\'s the limit cycle trajectory. Once again, that\\'s the consequence of the plane symmetry for the repeated cycles.",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        dirX, dirY = 0 , 1 # north\\n        x , y = 0 , 0\\n        \\n        for i in instructions:\\n            if i == \"G\":\\n                x , y = x + dirX, y + dirY\\n            elif i == \"L\":\\n                dirX, dirY = -1 * dirY , dirX\\n            else:\\n                dirX, dirY = dirY , -1 * dirX\\n                \\n        return (x,y) == (0,0) or (dirX , dirY) != (0,1) # if we are back at same point or if direction is not facing north after first circle. Then we are bound to come back and form a circle.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677892,
                "title": "1041-java-solution-robot-bounded-in-circle",
                "content": "Here is my solution for the Robot Bounded In Circle\\n```\\n    public boolean isRobotBounded(String instructions) {\\n        int[][] directions = {{0,1},{-1,0},{0,-1},{1,0}};       // Direction array [up, left, down, right]. Its index will be used in the below dir variable.\\n\\t\\tint mx = 0;                                                       // moving x coordinate of the robot\\n\\t\\tint my = 0;                                                       // moving y coordinate of the robot\\n        int dir = 0;          // direction variable to fetch the data from above direction array, default value is 0[up]. \\n\\t\\t\\t\\t\\t\\t\\n\\t\\t// Now we will loop through the string instructions\\n\\t\\t// If we counter \\'G\\' then we will add the x and y coordinate of that particular x and y direction in the mx and my. \\n\\t\\t// If we counter \\'L\\' or \\'R\\' then as per the previous direction we will change the dir variable. \\n\\t\\tfor(int i = 0; i<instructions.length(); i++){  \\n            char ch = instructions.charAt(i);\\n            if(ch == \\'G\\'){\\n                mx += directions[dir][0];\\n                my += directions[dir][1];\\n            }else if(ch == \\'L\\'){\\n                if(dir == 0) dir = 1;\\n                else if(dir == 1) dir = 2;\\n                else if(dir == 2) dir = 3;\\n                else dir = 0;\\n            }else if(ch == \\'R\\'){\\n                if(dir == 0) dir = 3;\\n                else if(dir == 3) dir = 2;\\n                else if(dir == 2) dir = 1;\\n                else dir = 0;\\n            }\\n        }\\n        \\n\\t\\t// After the loop ends, there are two conditions to check. If they satisy return true or return false\\n\\t\\t// 1. If the robot\\'s x and y coordinate is 0 and 0 then it means that it has reached to its original position \\n\\t\\t// OR \\n\\t\\t// 2. If the direction is changed i.e dir is not 0 that means at some later point of time it will reach to its original position.\\n\\t\\t//( Think in the way of vectors)\\n        if((mx == 0 && my == 0)||(dir != 0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n    public boolean isRobotBounded(String instructions) {\\n        int[][] directions = {{0,1},{-1,0},{0,-1},{1,0}};       // Direction array [up, left, down, right]. Its index will be used in the below dir variable.\\n\\t\\tint mx = 0;                                                       // moving x coordinate of the robot\\n\\t\\tint my = 0;                                                       // moving y coordinate of the robot\\n        int dir = 0;          // direction variable to fetch the data from above direction array, default value is 0[up]. \\n\\t\\t\\t\\t\\t\\t\\n\\t\\t// Now we will loop through the string instructions\\n\\t\\t// If we counter \\'G\\' then we will add the x and y coordinate of that particular x and y direction in the mx and my. \\n\\t\\t// If we counter \\'L\\' or \\'R\\' then as per the previous direction we will change the dir variable. \\n\\t\\tfor(int i = 0; i<instructions.length(); i++){  \\n            char ch = instructions.charAt(i);\\n            if(ch == \\'G\\'){\\n                mx += directions[dir][0];\\n                my += directions[dir][1];\\n            }else if(ch == \\'L\\'){\\n                if(dir == 0) dir = 1;\\n                else if(dir == 1) dir = 2;\\n                else if(dir == 2) dir = 3;\\n                else dir = 0;\\n            }else if(ch == \\'R\\'){\\n                if(dir == 0) dir = 3;\\n                else if(dir == 3) dir = 2;\\n                else if(dir == 2) dir = 1;\\n                else dir = 0;\\n            }\\n        }\\n        \\n\\t\\t// After the loop ends, there are two conditions to check. If they satisy return true or return false\\n\\t\\t// 1. If the robot\\'s x and y coordinate is 0 and 0 then it means that it has reached to its original position \\n\\t\\t// OR \\n\\t\\t// 2. If the direction is changed i.e dir is not 0 that means at some later point of time it will reach to its original position.\\n\\t\\t//( Think in the way of vectors)\\n        if((mx == 0 && my == 0)||(dir != 0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677690,
                "title": "my-attempt-to-give-an-intuitive-explanation-as-to-why-most-accepted-solutions-work",
                "content": "### There are four states in which robot may end up after executing the instruction one number of time:\\n\\n- Robots returns to its initial position in one operation hence `x = 0 & y = 0` in this case. (example: `GLLG`)\\n- Robot ends at some point `(x, y)` but faces `South` direction at the end so doing one more operation will reverse the changes and it returns to it initial position. (example: `GLL`)\\n- Robot ends up at some point `(x,y)` and faces either `West` or `East` direction which will take 3 more instructions to reverse the changes so in total of 4 times executions of the instruction robot will return to its original initial position.(example: `GL`)\\n- Robot ends up at some point `(x,y)` and faces `North` direction in which case it will never ever return to it\\'s initial position even after infinite numbers of executions of the instruction.(example: `GLR`)\\n\\n**JAVA Solution implementing above idea:**\\n\\n```java\\nclass Solution {\\n    public boolean isRobotBounded(String ins) {\\n        int x = 0, y = 0, i = 0, d[][] = {{0, 1}, {1, 0}, {0, -1}, { -1, 0}};\\n        for (int j = 0; j < ins.length(); ++j)\\n            if (ins.charAt(j) == \\'R\\')\\n                i = (i + 1) % 4;\\n            else if (ins.charAt(j) == \\'L\\')\\n                i = (i + 3) % 4;\\n            else {\\n                x += d[i][0]; y += d[i][1];\\n            }\\n        return x == 0 && y == 0 || i != 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math",
                    "String",
                    "Simulation"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean isRobotBounded(String ins) {\\n        int x = 0, y = 0, i = 0, d[][] = {{0, 1}, {1, 0}, {0, -1}, { -1, 0}};\\n        for (int j = 0; j < ins.length(); ++j)\\n            if (ins.charAt(j) == \\'R\\')\\n                i = (i + 1) % 4;\\n            else if (ins.charAt(j) == \\'L\\')\\n                i = (i + 3) % 4;\\n            else {\\n                x += d[i][0]; y += d[i][1];\\n            }\\n        return x == 0 && y == 0 || i != 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677476,
                "title": "c-easy-robot-bounded-in-circle-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0,y=0;\\n        int dir = 0; //{ 0 = N, 1 = E , 2 = S , 3 = W}\\n        for(char c: instructions)\\n        {\\n            if(c==\\'G\\')\\n            {\\n                if(dir == 0)\\n                    x++;\\n                else if (dir == 1)\\n                    y++;\\n                else if (dir == 2)\\n                    x--;\\n                else if(dir == 3)\\n                    y--;\\n            }\\n            else if(c==\\'L\\')\\n                dir = (dir+1)%4;\\n            \\n            else if (c==\\'R\\')\\n                dir = (dir + 4 -1)%4;\\n        }\\n        \\n        //checking if it is on origin or not\\n        if(x==0 && y==0)\\n            return true;\\n        \\n        //checking if the vector is pointing towards north\\n        if(dir == 0)\\n            return false;\\n        else return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0,y=0;\\n        int dir = 0; //{ 0 = N, 1 = E , 2 = S , 3 = W}\\n        for(char c: instructions)\\n        {\\n            if(c==\\'G\\')\\n            {\\n                if(dir == 0)\\n                    x++;\\n                else if (dir == 1)\\n                    y++;\\n                else if (dir == 2)\\n                    x--;\\n                else if(dir == 3)\\n                    y--;\\n            }\\n            else if(c==\\'L\\')\\n                dir = (dir+1)%4;\\n            \\n            else if (c==\\'R\\')\\n                dir = (dir + 4 -1)%4;\\n        }\\n        \\n        //checking if it is on origin or not\\n        if(x==0 && y==0)\\n            return true;\\n        \\n        //checking if the vector is pointing towards north\\n        if(dir == 0)\\n            return false;\\n        else return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677067,
                "title": "simple-math-solution-python",
                "content": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        position = [0, 0]\\n        direction = [0, 1]\\n        d = {\"L\": [[0, -1], [1, 0]], \"R\": [[0, 1], [-1, 0]]}\\n        \\n        for action in instructions:\\n            if action == \"G\":\\n                position[0] += direction[0]\\n                position[1] += direction[1]\\n            elif action == \"L\":\\n                direction = self.mal_mul(d[\"L\"], direction)\\n            else:\\n                direction = self.mal_mul(d[\"R\"], direction)\\n                \\n        return position == [0, 0] or direction != [0, 1]\\n                \\n        \\n        \\n        \\n    def mal_mul(self, M, v):\\n        \\n        return [M[0][0] * v[0] + M[0][1] * v[1], M[1][0] * v[0] + M[1][1] * v[1]]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        position = [0, 0]\\n        direction = [0, 1]\\n        d = {\"L\": [[0, -1], [1, 0]], \"R\": [[0, 1], [-1, 0]]}\\n        \\n        for action in instructions:\\n            if action == \"G\":\\n                position[0] += direction[0]\\n                position[1] += direction[1]\\n            elif action == \"L\":\\n                direction = self.mal_mul(d[\"L\"], direction)\\n            else:\\n                direction = self.mal_mul(d[\"R\"], direction)\\n                \\n        return position == [0, 0] or direction != [0, 1]\\n                \\n        \\n        \\n        \\n    def mal_mul(self, M, v):\\n        \\n        return [M[0][0] * v[0] + M[0][1] * v[1], M[1][0] * v[0] + M[1][1] * v[1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677059,
                "title": "easy-c-approach-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int dirx=1, diry=0 , x=0,y=0,d=0;\\n        int dir[4][2]={{1,0},\\n                {0,1},\\n                {-1,0},\\n                {0,-1}};\\n        for(auto a: instructions){\\n            if(a==\\'G\\'){\\n                if(dirx!=0){\\n                    x+=dirx;\\n                }else{\\n                    y+=diry;\\n                }\\n            }else if(a==\\'L\\'){\\n                d++;\\n                d%=4;\\n                dirx=dir[d][0];\\n                diry=dir[d][1];\\n            }else{\\n                d+=3;\\n                d%=4;\\n                dirx=dir[d][0];\\n                diry=dir[d][1];\\n            }\\n        }\\n        if(x==0 and y==0)return true;\\n        if(dirx!=1 or diry!=0)return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int dirx=1, diry=0 , x=0,y=0,d=0;\\n        int dir[4][2]={{1,0},\\n                {0,1},\\n                {-1,0},\\n                {0,-1}};\\n        for(auto a: instructions){\\n            if(a==\\'G\\'){\\n                if(dirx!=0){\\n                    x+=dirx;\\n                }else{\\n                    y+=diry;\\n                }\\n            }else if(a==\\'L\\'){\\n                d++;\\n                d%=4;\\n                dirx=dir[d][0];\\n                diry=dir[d][1];\\n            }else{\\n                d+=3;\\n                d%=4;\\n                dirx=dir[d][0];\\n                diry=dir[d][1];\\n            }\\n        }\\n        if(x==0 and y==0)return true;\\n        if(dirx!=1 or diry!=0)return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677046,
                "title": "easy-java-solution",
                "content": "```\\n// In case of Left and right just change face.\\n// In case of \\'G\\' just move towards face. \\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int x = 0;\\n        int y = 0;\\n        char[] fx = instructions.toCharArray();\\n\\n        char face = \\'N\\';\\n        int counter = 4;\\n        while(counter-- > 0){\\n            for (char c: fx) {\\n                if (c == \\'L\\') {\\n                    if (face == \\'N\\') face = \\'W\\';\\n                    else if (face == \\'W\\') face = \\'S\\';\\n                    else if (face == \\'S\\') face = \\'E\\';\\n                    else face = \\'N\\';\\n                }\\n\\n                if (c == \\'R\\') {\\n                    if (face == \\'N\\') face = \\'E\\';\\n                    else if (face == \\'E\\') face = \\'S\\';\\n                    else if (face == \\'S\\') face = \\'W\\';\\n                    else face = \\'N\\';\\n                }\\n\\n                if(c == \\'G\\'){\\n                    if (face == \\'N\\') y += 1;\\n                    if (face == \\'S\\') y -= 1;\\n                    if (face == \\'W\\') x -= 1;\\n                    if (face == \\'E\\') x += 1;\\n                }\\n            }\\n            if(x == 0 && y == 0)break;\\n        }\\n        return x == 0 && y == 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int x = 0;\\n        int y = 0;\\n        char[] fx = instructions.toCharArray();\\n\\n        char face = \\'N\\';\\n        int counter = 4;\\n        while(counter-- > 0){\\n            for (char c: fx) {\\n                if (c == \\'L\\') {\\n                    if (face == \\'N\\') face = \\'W\\';\\n                    else if (face == \\'W\\') face = \\'S\\';\\n                    else if (face == \\'S\\') face = \\'E\\';\\n                    else face = \\'N\\';\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1676814,
                "title": "c-intuitive-solution-w-clear-explanation",
                "content": "* By intuition, if after a sequence of indstructions, the robot returns to the initial position or changes direction, then it\\'s bounded in a circle otherwise not.\\n \\n* If the intruction is ```\\'G\\'```, ```x``` & ```y``` coordinates of the robot change according to the following rules :\\n        1.  If current direction is North, then \\u2018G\\u2019 increments y and doesn\\u2019t change x. \\n        2. If current direction is East, then \\u2018G\\u2019 increments x and doesn\\u2019t change y. \\n        3. If current direction is South, then \\u2018G\\u2019 decrements y and doesn\\u2019t change x. \\n        4. If current direction is West, then \\u2018G\\u2019 decrements x and doesn\\u2019t change y.\\n* If the instructions are ```\\'L\\'``` & ```\\'R\\'```, then ```x``` & ```y``` coordinates don\\'t change but the direction changes accoding to the following rules :\\n       1. If current direction is North, then \\u2018L\\u2019 changes direction to West and \\u2018R\\u2019 changes to East \\n       2. If current direction is East, then \\u2018L\\u2019 changes direction to North and \\u2018R\\u2019 changes to South \\n       3. If current direction is South, then \\u2018L\\u2019 changes direction to East and \\u2018R\\u2019 changes to West \\n       4. If current direction is West, then \\u2018L\\u2019 changes direction to South and \\u2018R\\u2019 changes to North.\\n\\nLet\\'s implement this idea using code ;)\\n\\n**Code :**\\n```\\n#define N 0\\n#define W 1\\n#define S 2\\n#define E 3\\n\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0, y=0, i=0;\\n        for(auto ins : instructions){\\n            if(ins == \\'G\\'){\\n                switch(i){\\n                    case 0 :  //N\\n                        y++;\\n                        break;\\n                    case 1 :  //W\\n                        x--;\\n                        break;\\n                    case 2 :  //S\\n                        y--;\\n                        break;\\n                    case 3 :  //E\\n                        x++;\\n                        break;\\n                }\\n            }else if(ins == \\'L\\') i = (i+1)%4; //%4 is done so that i remains in range [0, 3]\\n            \\n            else i = (i+3)%4;\\n        }\\n        return x==0 && y==0 || i != 0;\\n    }\\n};\\n```\\n\\nLet\\'s modify the above code a little bit :)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions){\\n        vector<vector<int>> dir = {{0, 1}, {-1, 0}, {0, -1}, {1, 0}};\\n        \\n        int i=0, x=0, y=0;\\n        \\n        for(auto ins : instructions){\\n            if(ins == \\'G\\'){\\n                x += dir[i][0]; y += dir[i][1];\\n            }\\n            else if(ins == \\'L\\') i = (i+1)%4;\\n            \\n            else i = (i+3)%4;   \\n        }\\n        return (x==0 && y==0) || i!=0;\\n    }\\n};\\n```\\n\\n**Time Complexity :** O(n) - n=size of the string\\n\\n**Space Complexity :** O(1)\\n\\n**If you like my solutions & explanation, please do upvote my post :)**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\'G\\'```\n```x```\n```y```\n```\\'L\\'```\n```\\'R\\'```\n```x```\n```y```\n```\\n#define N 0\\n#define W 1\\n#define S 2\\n#define E 3\\n\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0, y=0, i=0;\\n        for(auto ins : instructions){\\n            if(ins == \\'G\\'){\\n                switch(i){\\n                    case 0 :  //N\\n                        y++;\\n                        break;\\n                    case 1 :  //W\\n                        x--;\\n                        break;\\n                    case 2 :  //S\\n                        y--;\\n                        break;\\n                    case 3 :  //E\\n                        x++;\\n                        break;\\n                }\\n            }else if(ins == \\'L\\') i = (i+1)%4; //%4 is done so that i remains in range [0, 3]\\n            \\n            else i = (i+3)%4;\\n        }\\n        return x==0 && y==0 || i != 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions){\\n        vector<vector<int>> dir = {{0, 1}, {-1, 0}, {0, -1}, {1, 0}};\\n        \\n        int i=0, x=0, y=0;\\n        \\n        for(auto ins : instructions){\\n            if(ins == \\'G\\'){\\n                x += dir[i][0]; y += dir[i][1];\\n            }\\n            else if(ins == \\'L\\') i = (i+1)%4;\\n            \\n            else i = (i+3)%4;   \\n        }\\n        return (x==0 && y==0) || i!=0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676745,
                "title": "python3-linear-explained",
                "content": "The robot stays in the circle only if at the end of instructions the angle between the final heading vector and the initial vector is not equal to 0. Only one exclusion is the case when the final position is the initial position. In this case, the final heading is not important, because it doesn\\'t matter where the robot moves, it will always return to the start point. To find angle between two vectors we could use formula `cos(angle) = a dot b / |a| * |b|`. But in our case, the robot can have just 4 different directions, so comparing the initial and final headings will be enough.\\n\\nWhy the angle between two directions is important? The robot executes instructions forever, so if at the end of the first run it looks in the same directions and it\\'s not in the starting position that means the distance from the start will increase constantly as the robot will repeat THE SAME moves over and over again. If the angle is different that means that the robot will spin within a certain bounded area.\\n\\nTime: **O(n)** - for instructions\\nSpace: **O(1)** - nothing stored\\n\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        pos, head = (0, 0), 0\\n\\t\\t\\n        for ch in instructions:\\n            if ch == \"G\":\\n                pos = (pos[0] + dirs[head][0], pos[1] + dirs[head][1])\\n            elif ch == \"L\":\\n                head = (head - 1) % 4\\n            else:\\n                head = (head + 1) % 4\\n\\n        return pos == (0, 0) or head != 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        pos, head = (0, 0), 0\\n\\t\\t\\n        for ch in instructions:\\n            if ch == \"G\":\\n                pos = (pos[0] + dirs[head][0], pos[1] + dirs[head][1])\\n            elif ch == \"L\":\\n                head = (head - 1) % 4\\n            else:\\n                head = (head + 1) % 4\\n\\n        return pos == (0, 0) or head != 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676591,
                "title": "simple-4-loops-in-python",
                "content": "Perform the given instruction for **at most four times**, and if the robot does not come back to the origin, then it never comes back to the origin no matter how many times it keeps performing the instruction. Because the direction is only 4 ways and after performing the instruction 4 times, it should head to the north. \\n\\nYou can prove this like this:\\nIf we represent each direction in integer (0 to 3), the possible change of the directions are like this.\\n(Here, 0=North, 1=West, 2=South, 3=East)\\n\\n* 0 -> 1 -> 2 -> 3 -> 0\\n* 0 -> 2 -> 0 -> 2 -> 0\\n* 0 -> 3 -> 2 -> 1 -> 0\\n* 0 -> 0 -> 0 -> 0 -> 0\\n\\nIn any case, the direction is north after performing 4 instructions.\\n\\nWhen it is facing north, the position must be the origin in order to be in the circle. If the position is not the origin, then it keeps going away from the origin.\\n\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        def do_instruction(i, j, dir):\\n            for char in instructions:\\n                if char == \\'G\\':\\n                    if dir == 0:\\n                        i -= 1\\n                    elif dir == 1:\\n                        j -= 1\\n                    elif dir == 2:\\n                        i += 1\\n                    else:\\n                        j += 1\\n                elif char == \\'L\\':\\n                    dir = (dir + 1) % 4\\n                else:\\n                    dir = (dir - 1) % 4\\n            return i, j, dir\\n        \\n        i, j, dir = 0, 0, 0\\n        for _ in range(4):\\n            i, j, dir = do_instruction(i, j, dir)\\n            if i == 0 and j == 0:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        def do_instruction(i, j, dir):\\n            for char in instructions:\\n                if char == \\'G\\':\\n                    if dir == 0:\\n                        i -= 1\\n                    elif dir == 1:\\n                        j -= 1\\n                    elif dir == 2:\\n                        i += 1\\n                    else:\\n                        j += 1\\n                elif char == \\'L\\':\\n                    dir = (dir + 1) % 4\\n                else:\\n                    dir = (dir - 1) % 4\\n            return i, j, dir\\n        \\n        i, j, dir = 0, 0, 0\\n        for _ in range(4):\\n            i, j, dir = do_instruction(i, j, dir)\\n            if i == 0 and j == 0:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676588,
                "title": "c-with-detailed-explanation-0-ms-o-n-100-faster",
                "content": "We need to first of all take care of the instructions and to not get that messy in the actual code, I created a function named follow to take instructions and do accordingly. \\nTake two directions ```x``` and ```y```, and the increments as ```dx``` and ```dy```. Initially set ```x = 0, y = 0, dx = 1 and dy = 0```. Now if our robot takes a left turn change dx and dy accordingly. Similar for a right turn. Now, if robot takes one step forward, now ```x``` will become ```x + dx```\\nand ```y``` will become ```y + dy```. \\nFinally, we just need to see that to complete a circle or a bounded path robot must return to the initial state of ```x = 0, y = 0, dx = 1, dy = 0``` which means that all the movements made by robot have been nullified by other movements after 4 rotations. If so happens, then robot is moving in a bound path.\\n\\nI have attached my code below for reference :)\\n```\\nclass Solution {\\npublic:\\n    void follow(int& x, int& y, int& dx, int& dy, char instruction)\\n    {\\n        if(instruction == \\'L\\')\\n        {\\n            if(dx == 1 && dy == 0)\\n            {\\n                dx = 0;\\n                dy = 1;\\n            }\\n            else if(dx == -1 && dy == 0)\\n            {\\n                dx = 0;\\n                dy = -1;\\n            }\\n            else if(dx == 0 && dy == 1)\\n            {\\n                dx = -1;\\n                dy = 0;\\n            }\\n            else if(dx == 0 && dy == -1)\\n            {\\n                dx = 1;\\n                dy = 0;\\n            }\\n        }\\n        else if(instruction == \\'R\\')\\n        {\\n            if(dx == 1 && dy == 0)\\n            {\\n                dx = 0;\\n                dy = -1;\\n            }\\n            else if(dx == -1 && dy == 0)\\n            {\\n                dx = 0;\\n                dy = 1;\\n            }\\n            else if(dx == 0 && dy == 1)\\n            {\\n                dx = 1;\\n                dy = 0;\\n            }\\n            else if(dx == 0 && dy == -1)\\n            {\\n                dx = -1;\\n                dy = 0;\\n            }\\n        }\\n        else\\n        {\\n            x += dx;\\n            y += dy;\\n        }\\n    }\\n    \\n    bool isRobotBounded(string instructions) {\\n        int dx = 1;\\n        int dy = 0;\\n        int x = 0;\\n        int y = 0;\\n\\t\\tint n = 4;\\n\\t\\t\\n        while(n--)\\n\\t\\t\\tfor(int i = 0; i < instructions.length(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfollow(x,y,dx,dy,instructions[i]);\\n\\t\\t\\t}\\n        }\\n        \\n        if(x == 0 && y == 0) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```x```\n```y```\n```dx```\n```dy```\n```x = 0, y = 0, dx = 1 and dy = 0```\n```x```\n```x + dx```\n```y```\n```y + dy```\n```x = 0, y = 0, dx = 1, dy = 0```\n```\\nclass Solution {\\npublic:\\n    void follow(int& x, int& y, int& dx, int& dy, char instruction)\\n    {\\n        if(instruction == \\'L\\')\\n        {\\n            if(dx == 1 && dy == 0)\\n            {\\n                dx = 0;\\n                dy = 1;\\n            }\\n            else if(dx == -1 && dy == 0)\\n            {\\n                dx = 0;\\n                dy = -1;\\n            }\\n            else if(dx == 0 && dy == 1)\\n            {\\n                dx = -1;\\n                dy = 0;\\n            }\\n            else if(dx == 0 && dy == -1)\\n            {\\n                dx = 1;\\n                dy = 0;\\n            }\\n        }\\n        else if(instruction == \\'R\\')\\n        {\\n            if(dx == 1 && dy == 0)\\n            {\\n                dx = 0;\\n                dy = -1;\\n            }\\n            else if(dx == -1 && dy == 0)\\n            {\\n                dx = 0;\\n                dy = 1;\\n            }\\n            else if(dx == 0 && dy == 1)\\n            {\\n                dx = 1;\\n                dy = 0;\\n            }\\n            else if(dx == 0 && dy == -1)\\n            {\\n                dx = -1;\\n                dy = 0;\\n            }\\n        }\\n        else\\n        {\\n            x += dx;\\n            y += dy;\\n        }\\n    }\\n    \\n    bool isRobotBounded(string instructions) {\\n        int dx = 1;\\n        int dy = 0;\\n        int x = 0;\\n        int y = 0;\\n\\t\\tint n = 4;\\n\\t\\t\\n        while(n--)\\n\\t\\t\\tfor(int i = 0; i < instructions.length(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfollow(x,y,dx,dy,instructions[i]);\\n\\t\\t\\t}\\n        }\\n        \\n        if(x == 0 && y == 0) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676581,
                "title": "python-solution-with-complex-numbers",
                "content": "We know the robot will be contained in a circle if it eventually ends up back where it started. We simulate the robot\\'s movement. If the robot can make it back, it will after 1, 2, or 4 runs, so we run its movements 4 times. We can ~~abuse~~ utilize complex numbers and Python\\'s `complex` class.\\n\\n\\n```python\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        dirs = {\"L\": 0 + 1j, \"R\": 0 - 1j}\\n        pos = 0j\\n        face = 1j\\n        for _ in range(4):\\n            for c in instructions:\\n                if c in \"LR\":\\n                    face *= dirs[c]\\n                else:\\n                    pos += face\\n        return pos == 0j\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        dirs = {\"L\": 0 + 1j, \"R\": 0 - 1j}\\n        pos = 0j\\n        face = 1j\\n        for _ in range(4):\\n            for c in instructions:\\n                if c in \"LR\":\\n                    face *= dirs[c]\\n                else:\\n                    pos += face\\n        return pos == 0j\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634939,
                "title": "advertise-java-solution-with-detailed-explanation",
                "content": "Firstly I will give the conclusion, **how to we determine the the rob is bounded in a circle**? 2 cases:\\n\\n1. After the instruction is executed once, it goes back to orignal position `[0, 0]` no matter what is the direction after the execution\\n2. It goes to a different position, but in a different direction compared with initial direction\\n\\nThe proval is simple, we just need to focus on **the relative rob position between intial and final state, and forgot the middle process!** I will exlain each rule one by one below\\n\\n---\\n**For the 1st rule**:  After the instruction is executed once, it goes back to orignal position `[0, 0]` no matter what is the direction after the execution\\n1. If it goes to original position after one execution, let\\'s forget the middle process, only care about the effect of the instruction. The effect is: **Stay in the same place, and change direction**. Then if we execute it multiple times, then **it will still stay in the same place as well, only direction changed.** But we do not care of direction, we only care about where it falls into finally. So it is bounded in a circle\\n**We can drill down a little bit**:  Let\\'s say we changed the direction from \"North\" to \"West\" in the 1st execution. If we execute the instruction the 2nd time, then it will stay in the place, and **the final direction will be changed in relative to \"West\"**. **Relative** means: you simulate move the map to make \\u201DWest\" side to \"North\" side and execute the instruction. Or you can understand from this way: For the 1st execution, direction changed from \"North\" to \"West\", so **direction turns left**. Then the 2nd execution, it will do the same thing, the direction change left too, so **\"West\" turns left is \"South\"**. Then multiple execution will be like:\\n\\n\\t```\\n\\t\"Same Position, North to West\" -> \"Same Position, West to South\" -> \"Same Position, South to East\" -> \"Same Position, East to North\"\\n\\t```\\n\\t\\n\\tAnd repeat in this pattern\\n\\n**For the 2nd rule**: It goes to a different position, but in a different direction compared with initial direction\\n1. First understand if position changes, and direction is still \"North\" after execution, **why it is not in circle**?\\nBecause **it will just repeat the postion changes in the same direction(direction here means position change direction)**, e.g. if it moves to bottom right position 2 from 1, then next execution will moves it position to bottom right again based on new postion 2, i.e. move from 2 to 3 and so on. We can see it is not bounded in a circle\\n![image](https://assets.leetcode.com/users/images/8809b519-f09f-42d3-af2b-3f7b681af9f1_1639877832.7344205.png)\\n\\n\\n2. **If it is other directions, then it will definitely move back the original position**. why?\\nIt is simple, if the execution changes direction, then the angel changed is definitely multiple of 90 degree, i.e. one of them: 90, 180, 270(or -90), (not including 360 as we are talking about the case where the direction changed)\\n- If direction change is 180 degree, next instruction execution, the direction change will still be 180 degree, and position change will be 180 degree as well, then it will be like:\\n\\n\\t![image](https://assets.leetcode.com/users/images/57ed613d-9bc0-4584-9d88-d2d0b761706c_1639878920.8232384.png)\\n\\t\\n\\tIt will go back to origin place like **a round trip**\\n- If direction change is 90 or -90(270) degree, then **next execution, the direction change and position direction change will change 90 or -90 degree as well**. After 3 times execution, it will be 90 \\\\* 4=360 degree or -360 degree. If we draw the robot position in each step in the picture, it will form an square, and go back to original position. For example, 90 degree will be as below:\\n\\n![image](https://assets.leetcode.com/users/images/0d725cdf-0155-46a3-9e94-a3afcac17087_1639885781.0605257.png)\\n\\nIt will be the similar for -90 degree, I will skip it. \\n\\n**Conclusion**\\n- If direction change is 0 degree, then it will only change direction, position will not change\\n- If direction change is 90 or -90(270) degree with a position change, then after 4 execution, it will go back to original position. Since 90 * 4 = 360 degree\\n- If direction is 180 degree, then 2 executions will bring robot back. Because 180 * 2 = 360 degree\\n\\n---\\n**Final Code**\\n```java\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        // intial direction is [0, 0]\\n        int[] pos = new int[]{0, 0};\\n        \\n\\t\\t// represents north, east, south, west each direction change\\n        int[][] directions = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        int dirIdx = 0;\\n        \\n        for(char instruction : instructions.toCharArray()){\\n            if(instruction == \\'G\\'){\\n                pos[0] += directions[dirIdx][0];\\n                pos[1] += directions[dirIdx][1]; \\n            }else if(instruction == \\'L\\'){\\n                dirIdx = dirIdx - 1 < 0 ? 3 : dirIdx - 1;\\n            }else{\\n                dirIdx = dirIdx + 1 > 3 ? 0 : dirIdx + 1;\\n            }\\n        }\\n        \\n        if(pos[0] == 0 && pos[1] == 0) return true;\\n        if(dirIdx == 0) return false;\\n        return true;\\n    }\\n}\\n```\\n\\n---\\n**Complexity Analysis**\\n- Time: `O(n)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```\\n\\t\"Same Position, North to West\" -> \"Same Position, West to South\" -> \"Same Position, South to East\" -> \"Same Position, East to North\"\\n\\t```\n```java\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        // intial direction is [0, 0]\\n        int[] pos = new int[]{0, 0};\\n        \\n\\t\\t// represents north, east, south, west each direction change\\n        int[][] directions = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        int dirIdx = 0;\\n        \\n        for(char instruction : instructions.toCharArray()){\\n            if(instruction == \\'G\\'){\\n                pos[0] += directions[dirIdx][0];\\n                pos[1] += directions[dirIdx][1]; \\n            }else if(instruction == \\'L\\'){\\n                dirIdx = dirIdx - 1 < 0 ? 3 : dirIdx - 1;\\n            }else{\\n                dirIdx = dirIdx + 1 > 3 ? 0 : dirIdx + 1;\\n            }\\n        }\\n        \\n        if(pos[0] == 0 && pos[1] == 0) return true;\\n        if(dirIdx == 0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620979,
                "title": "c-basic-solution",
                "content": "After little bit of experimenting on paper, one can realize that the only situation that it does not land up at origin is if we do not end up on origin after one round and are also facing north.\\nThe other two cases are:\\n- Ending up on origin: Obviously it is `true`\\n- Not ending up on origin but facing South/East/West: This is also true because after 2 rounds(South) or 4 rounds(East/West), we will again land at origin.\\n\\nNow for implementation, we will use three variables:\\n- `a` for x-coordinate\\n- `b` for y-coordinate\\n- `c` for direction\\n\\nAll 3 are integers. One important thing to notice is that we can use `c` variable for direction as follows:\\n- If you see \\'L\\',  increment c by 1\\n- If you see \\'R\\', increment c by 3\\n- If you see \\'G\\', do not change c\\n\\nFurther we can check which direction we are facing:\\n- `c%4=0` means North\\n- `c%4=1` means West\\n- `c%4=2` means South\\n- `c%4=3` means East\\n\\n\\nNow the logic is that:\\n- If you see G, find out which direction you are facing and modify the coordinates accordingly. This will change either a or b.\\n- If you see L or R, change the variable c as per rule given above. Variables a and b do not change in this case.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int a=0,b=0,c=0;\\n        for(char ch: instructions)\\n        {\\n            if(ch==\\'G\\')\\n            {\\n                if(c%4==0)b++;\\n                if(c%4==1)a--;\\n                if(c%4==2)b--;\\n                if(c%4==3)a++;\\n            }\\n            if(ch==\\'L\\') c++;\\n            if(ch==\\'R\\') c+=3;\\n        }\\n        cout << a << \\' \\' << b << \\' \\' << c << endl;\\n        if(c%4==0 && (a!=0 || b!=0)) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int a=0,b=0,c=0;\\n        for(char ch: instructions)\\n        {\\n            if(ch==\\'G\\')\\n            {\\n                if(c%4==0)b++;\\n                if(c%4==1)a--;\\n                if(c%4==2)b--;\\n                if(c%4==3)a++;\\n            }\\n            if(ch==\\'L\\') c++;\\n            if(ch==\\'R\\') c+=3;\\n        }\\n        cout << a << \\' \\' << b << \\' \\' << c << endl;\\n        if(c%4==0 && (a!=0 || b!=0)) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1596533,
                "title": "easy-to-understand-python-using-maps",
                "content": "This solution uses hashmaps to easily compute the next direction and move to take by including one array for the direction and what to add to x and y and then a left and right array to compute the next direction D based of inputs L and R. \\n\\nThe answer is a circle if we either end at the origin facing North or we end somewhere not facing north as after 4 cylces we will eventually reach the origin. \\n\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        \\n\\t\\t# next coordinate to move on G to based on direction \\n        moves = {\\'N\\': (0, 1), \\'E\\': (1, 0), \\'S\\': (0, -1), \\'W\\': (-1, 0)}\\n\\t\\t# next left direction based on current direction \\n        left  = {\\'N\\': \\'W\\', \\'E\\': \\'N\\', \\'S\\': \\'E\\', \\'W\\': \\'S\\'}\\n\\t\\t# next right direction based on current direction \\n        right = {\\'N\\': \\'E\\', \\'E\\': \\'S\\', \\'S\\': \\'W\\', \\'W\\': \\'N\\'}\\n        \\n        origin = [0, 0]\\n        \\n        D = \\'N\\'\\n        \\n        for nxt in instructions: \\n            if nxt == \\'G\\':\\n                x, y = moves[D]\\n                \\n                origin[0] += x\\n                origin[1] += y\\n                \\n            if nxt == \"L\":\\n                D = left[D]\\n                \\n            if nxt == \\'R\\':\\n                D = right[D]\\n        \\n        if origin == [0, 0] or D != \\'N\\':\\n            return True\\n        \\n        return False\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        \\n\\t\\t# next coordinate to move on G to based on direction \\n        moves = {\\'N\\': (0, 1), \\'E\\': (1, 0), \\'S\\': (0, -1), \\'W\\': (-1, 0)}\\n\\t\\t# next left direction based on current direction \\n        left  = {\\'N\\': \\'W\\', \\'E\\': \\'N\\', \\'S\\': \\'E\\', \\'W\\': \\'S\\'}\\n\\t\\t# next right direction based on current direction \\n        right = {\\'N\\': \\'E\\', \\'E\\': \\'S\\', \\'S\\': \\'W\\', \\'W\\': \\'N\\'}\\n        \\n        origin = [0, 0]\\n        \\n        D = \\'N\\'\\n        \\n        for nxt in instructions: \\n            if nxt == \\'G\\':\\n                x, y = moves[D]\\n                \\n                origin[0] += x\\n                origin[1] += y\\n                \\n            if nxt == \"L\":\\n                D = left[D]\\n                \\n            if nxt == \\'R\\':\\n                D = right[D]\\n        \\n        if origin == [0, 0] or D != \\'N\\':\\n            return True\\n        \\n        return False\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1574160,
                "title": "c-complex-number-o-n-clean-solution-0ms",
                "content": "Since multiplying a complex number by `i` rotates it by 90\\xB0 anti-clockwise around origin on the complex plane, the rest is just treating complex numbers as vectors.\\n\\n```C++\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        const std::complex<int> i(0, 1);\\n        const std::complex<int> initial_position(0, 0);\\n        const std::complex<int> initial_direction(0, 1);\\n        \\n        std::complex<int> position = initial_position;\\n        std::complex<int> direction = initial_direction;\\n        \\n        for (char instruction : instructions) {\\n            switch (instruction) {\\n            case \\'G\\':\\n                position += direction;\\n                break;\\n            case \\'L\\':\\n                direction *= i;\\n                break;\\n            case \\'R\\':\\n                direction *= -i;\\n                break;\\n            }\\n        }\\n        \\n        return direction != initial_direction || position == initial_position;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        const std::complex<int> i(0, 1);\\n        const std::complex<int> initial_position(0, 0);\\n        const std::complex<int> initial_direction(0, 1);\\n        \\n        std::complex<int> position = initial_position;\\n        std::complex<int> direction = initial_direction;\\n        \\n        for (char instruction : instructions) {\\n            switch (instruction) {\\n            case \\'G\\':\\n                position += direction;\\n                break;\\n            case \\'L\\':\\n                direction *= i;\\n                break;\\n            case \\'R\\':\\n                direction *= -i;\\n                break;\\n            }\\n        }\\n        \\n        return direction != initial_direction || position == initial_position;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472762,
                "title": "0-ms-easy-c-solution-faster-than-100-described-with-comments",
                "content": "Please Upvote my solution, if you like it.\\n\\n```class Solution {\\npublic:\\n    bool isRobotBounded(string ins) {\\n       \\n\\t   // 4 directions [ 0- North, 1- West, 2-South, 3-East] \\n        vector<int> dir(4,0);\\n        \\n        int cur = 0;\\n        \\n\\t\\t// Looping over 4 times as total we have 4 directions\\n        for(int i = 0; i < 4; i++) {\\n            for(int j = 0; j < ins.size(); j++) {\\n\\t\\t\\t\\n\\t\\t\\t\\t// If character is G, increment the value at current pointer\\n                if(ins[j] == \\'G\\')\\n                    dir[cur]++;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// In case it is L, Just do (cur + 1) % 4\\n\\t\\t\\t\\t// As left means \"WEST\", so we are increasing it by 1 and\\n\\t\\t\\t\\t//It may go out of bound, so modulo 4.\\n\\t\\t\\t\\t\\n                else if(ins[j] == \\'L\\')\\n                    cur = (cur + 1) % 4;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t// Similarly do it for \\'R\\' case. R means EAST so we have to do +3 instread of +1\\n\\t\\t\\t\\t\\n                else\\n                    cur = (cur + 3) % 4;\\n            }\\n        }\\n\\t\\t\\n        // At last if the movement of North and South is same\\n\\t\\t// and movement of East and West is also same. \\n\\t\\t//This means we are at starting position again\\n\\t\\t\\n        if(dir[0] == dir[2] && dir[1] == dir[3])\\n            return true;\\n        return false;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    bool isRobotBounded(string ins) {\\n       \\n\\t   // 4 directions [ 0- North, 1- West, 2-South, 3-East] \\n        vector<int> dir(4,0);\\n        \\n        int cur = 0;\\n        \\n\\t\\t// Looping over 4 times as total we have 4 directions\\n        for(int i = 0; i < 4; i++) {\\n            for(int j = 0; j < ins.size(); j++) {\\n\\t\\t\\t\\n\\t\\t\\t\\t// If character is G, increment the value at current pointer\\n                if(ins[j] == \\'G\\')\\n                    dir[cur]++;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// In case it is L, Just do (cur + 1) % 4\\n\\t\\t\\t\\t// As left means \"WEST\", so we are increasing it by 1 and\\n\\t\\t\\t\\t//It may go out of bound, so modulo 4.\\n\\t\\t\\t\\t\\n                else if(ins[j] == \\'L\\')\\n                    cur = (cur + 1) % 4;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t// Similarly do it for \\'R\\' case. R means EAST so we have to do +3 instread of +1\\n\\t\\t\\t\\t\\n                else\\n                    cur = (cur + 3) % 4;\\n            }\\n        }\\n\\t\\t\\n        // At last if the movement of North and South is same\\n\\t\\t// and movement of East and West is also same. \\n\\t\\t//This means we are at starting position again\\n\\t\\t\\n        if(dir[0] == dir[2] && dir[1] == dir[3])\\n            return true;\\n        return false;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1472520,
                "title": "easy-to-understand-c-solution-faster-than-100",
                "content": "We start with north facing at the origin. After running through the input instructions, we check the ending orientation of the robot using the \\'d\\' variable and the ending coordinates using the \\'x\\' and \\'y\\' variables.\\n\\nIf the orientation is the different from the starting orientation or the ending coordinates are same as the starting coordinates (ie: origin), we say that the path can be bounded by a circle and return true.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0, y=0, d=90;\\n        for(char ch:instructions){\\n            switch(ch){\\n                case \\'G\\': \\n                    if(d%360==0)\\n                        x++;\\n                    else if(d%360==90)\\n                        y++;\\n                    else if(d%360==180)\\n                        x--;\\n                    else if(d%360==270)\\n                        y--;\\n                    break;\\n                case \\'L\\':\\n                    d+=90;\\n                    break;\\n                case \\'R\\':\\n                    d-=90;\\n                    if(d<0)\\n                        d+=360;\\n                    break;\\n            } \\n        }\\n        \\n        return ((d%360!=90)||((x==0)&&(y==0)));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int x=0, y=0, d=90;\\n        for(char ch:instructions){\\n            switch(ch){\\n                case \\'G\\': \\n                    if(d%360==0)\\n                        x++;\\n                    else if(d%360==90)\\n                        y++;\\n                    else if(d%360==180)\\n                        x--;\\n                    else if(d%360==270)\\n                        y--;\\n                    break;\\n                case \\'L\\':\\n                    d+=90;\\n                    break;\\n                case \\'R\\':\\n                    d-=90;\\n                    if(d<0)\\n                        d+=360;\\n                    break;\\n            } \\n        }\\n        \\n        return ((d%360!=90)||((x==0)&&(y==0)));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450060,
                "title": "c-just-one-instruction-pass",
                "content": "If your final position is different from starting position after one instruction pass but orientation is same as before then it can\\'t be bounded. Here\\'s my simple c++ code:\\n```\\nclass Solution {\\npublic:\\n    int dx[4] = {0, -1, 0, 1};\\n    int dy[4] = {1, 0, -1, 0};\\n    bool isRobotBounded(string instructions) {\\n        int x = 0, y = 0, o = 0;\\n        // o -> 0, 1, 2, 3\\n        // if final pos after 1 instruction pass is diff but orientation is same then no circle, otherwise circle\\n        //         ^0\\n        //      1 < > 3\\n        //         v2\\n        \\n        for(int i = 0; i < instructions.size(); i++) {\\n            if(instructions[i] == \\'G\\') {\\n                x += dx[o];\\n                y += dy[o];\\n            } else if(instructions[i] == \\'L\\') {\\n                o = (o + 1) % 4;\\n            } else if(instructions[i] == \\'R\\') {\\n                o = (o - 1 + 4) % 4;\\n            }\\n        }\\n        if((x != 0 || y != 0) && o == 0)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0, -1, 0, 1};\\n    int dy[4] = {1, 0, -1, 0};\\n    bool isRobotBounded(string instructions) {\\n        int x = 0, y = 0, o = 0;\\n        // o -> 0, 1, 2, 3\\n        // if final pos after 1 instruction pass is diff but orientation is same then no circle, otherwise circle\\n        //         ^0\\n        //      1 < > 3\\n        //         v2\\n        \\n        for(int i = 0; i < instructions.size(); i++) {\\n            if(instructions[i] == \\'G\\') {\\n                x += dx[o];\\n                y += dy[o];\\n            } else if(instructions[i] == \\'L\\') {\\n                o = (o + 1) % 4;\\n            } else if(instructions[i] == \\'R\\') {\\n                o = (o - 1 + 4) % 4;\\n            }\\n        }\\n        if((x != 0 || y != 0) && o == 0)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431450,
                "title": "python-robot-in-a-circle-good-question",
                "content": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        \"\"\"\\n        \\n        Here is the intuition of this problem:\\n        from @lee215: https://leetcode.com/problems/robot-bounded-in-circle/discuss/290856/JavaC%2B%2BPython-Let-Chopper-Help-Explain\\n        \\n        1. If after one iteration, the robot returns to 0,0 then we are good.\\n        2. If after one iteration, the robot does not return 0,0 but faces north, then we have merely shifted the starting point and it will keep shifting. So false.\\n        3. In all other cases, I just guessed it to be true. LOL.\\n        \\n        The important thing is to keep track of directions.\\n        \\n              1\\n              |\\n              |\\n        -1----+----1\\n              |\\n              |\\n              -1\\n\\n        if north, then dx = 0 (since no horizontal component), dy = 1\\n        if east,  then dx = 1, dy = 0 (since no vertical component)\\n        if turn left, the val of x-component goes to y and the negative of y goes to x. See with an example on the map above.\\n        Turning left is the opposite if turning right.\\n        \"\"\"\\n        x, y = 0, 0\\n        dx, dy = 0, 1\\n        for i in instructions:\\n            if i == \\'G\\': x, y = x + dx, y + dy\\n            if i == \\'L\\': dx, dy = -dy, dx\\n            if i == \\'R\\': dx, dy = dy, -dx\\n        \\n        return (x, y) == (0, 0) or (dx, dy) != (0, 1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        \"\"\"\\n        \\n        Here is the intuition of this problem:\\n        from @lee215: https://leetcode.com/problems/robot-bounded-in-circle/discuss/290856/JavaC%2B%2BPython-Let-Chopper-Help-Explain\\n        \\n        1. If after one iteration, the robot returns to 0,0 then we are good.\\n        2. If after one iteration, the robot does not return 0,0 but faces north, then we have merely shifted the starting point and it will keep shifting. So false.\\n        3. In all other cases, I just guessed it to be true. LOL.\\n        \\n        The important thing is to keep track of directions.\\n        \\n              1\\n              |\\n              |\\n        -1----+----1\\n              |\\n              |\\n              -1\\n\\n        if north, then dx = 0 (since no horizontal component), dy = 1\\n        if east,  then dx = 1, dy = 0 (since no vertical component)\\n        if turn left, the val of x-component goes to y and the negative of y goes to x. See with an example on the map above.\\n        Turning left is the opposite if turning right.\\n        \"\"\"\\n        x, y = 0, 0\\n        dx, dy = 0, 1\\n        for i in instructions:\\n            if i == \\'G\\': x, y = x + dx, y + dy\\n            if i == \\'L\\': dx, dy = -dy, dx\\n            if i == \\'R\\': dx, dy = dy, -dx\\n        \\n        return (x, y) == (0, 0) or (dx, dy) != (0, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380227,
                "title": "java-0ms-faster-than-100-in-layman-s-terms-such-that-anyone-can-understand-with-clear-explanation",
                "content": "\\n        \\n        /* \\n            There were several other solutions following a similar approach. But, this solution is built around an idea where we don\\'t have to consider a particular direction of rotation or the start to be fixed as North. This works for all the directions of starts, regardless.\\n            I have tried understanding and explaining the problem in the most layman terms and have written the description such that you can start visualizing the moves in an easy way.\\n            Let\\'s consider the circle in terms of 4 quadrants 0/360, 90, 180, 270. I am not even following an order in typing the directions for a reason - to emphasize on the independence of metrics for this solution.\\n            \\n\\t\\t\\tEvery move either adds a 90 degrees or a -90(or 270) degrees or nothing.\\n            The resultant direction after the move must be the current degrees (cd+move)%360\\n            We would also have a map for coordinate updates, otherwise. But, here we wouldn\\'t need that. As in any direction to move straight we know that one of the coordinates remains contant. And, hence it becomes obvious that the other coordinate has to be either incremented or decremented by a value. Since, each move is equal to one unit of the coordinate system in this problem (we don\\'t allow movements of more than a unit. No x = x+2 or y = y+1) Basically x = x+ (0 or 1 or -1 when current direction being faced is North or South) and so is true to y as well when the staright movement is along the x direction (East or West)\\n            \\n\\t\\t\\tAnd, from any direction, the only time when we have to compute the next coordinate is when the move is straight.\\n\\t\\t\\tAssumption: 0 or 360 degrees would be facing North and along x-axis.\\n\\t\\t\\tTherefore, if facing \\n                0 North: To go straight -> y-constant, x++\\n                180 South: To go straight -> y-constant, x--;\\n                90 East: To go straight -> x-constant, y++\\n                270 West: To go straight -> x-constant, y--;\\n\\n\\t\\t\\tIn the end if the degrees is 0 or 360 it is a loop/circle.\\n            Or also if x=0 and y=0 then, it means that end is same as the start as we know that from the question (North is the start and the assumption is 0 is North in this solution with (x=0, y=0)).\\n            Moreover, other than a straight line everything else is a circle or a loop as it didn\\'t end at the same point where it started after completing the first iteration of the whole sequence of instruction. Therefore, it will definitely not end up in the same (current direction as well) in the next iteration for sure and the next one and the next one. And, has to come back to one of the previously visited coordinates at least once in the next 3 iterations max(as there are only 3 moves possible).\\n\\t\\t\\tTime Complexity: O(N) Have ot iterate through all the instructions at least once.\\n\\t\\t\\tSpace Complexity: O(1) Constant space. Our space consumption is not proprotional to the length of our input instruction sequence or just input length rather in general.\\n\\t\\t\\tThank you. I have not written a lot of solutions before; but have learnt a lot from the people who have written(and are writing) great ones. Please do upvote if you liked it. Helps reach more people.\\n        */\\n\\t\\t\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic boolean isRobotBounded(String ins) {\\n\\t\\t\\t\\tint x = 0, y = 0;\\n\\t\\t\\t\\tint cd = 0; // Assuming North is zero and is the currentDirection\\n\\t\\t\\t\\tfor(int i=0; i<ins.length(); i++) {\\n\\t\\t\\t\\t\\tif(ins.charAt(i) == \\'R\\') {\\n\\t\\t\\t\\t\\t\\t// add -90 degrees or 270 degrees\\n\\t\\t\\t\\t\\t\\tcd  = (cd+270)%360;\\n\\t\\t\\t\\t\\t} else if(ins.charAt(i) == \\'L\\') {\\n\\t\\t\\t\\t\\t\\t// add 90 degrees\\n\\t\\t\\t\\t\\t\\tcd  = (cd+90)%360;\\n\\t\\t\\t\\t\\t} else { // G move\\n\\t\\t\\t\\t\\t\\tif(cd == 0){\\n\\t\\t\\t\\t\\t\\t\\tx++;\\n\\t\\t\\t\\t\\t\\t} else if(cd == 180) {\\n\\t\\t\\t\\t\\t\\t\\tx--;\\n\\t\\t\\t\\t\\t\\t} else if(cd == 90) {\\n\\t\\t\\t\\t\\t\\t\\ty++;\\n\\t\\t\\t\\t\\t\\t} else { // cd == 270\\n\\t\\t\\t\\t\\t\\t\\ty--;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn (x == 0 && y == 0) || cd>0;\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t\\tpublic boolean isRobotBounded(String ins) {\\n\\t\\t\\t\\tint x = 0, y = 0;\\n\\t\\t\\t\\tint cd = 0; // Assuming North is zero and is the currentDirection\\n\\t\\t\\t\\tfor(int i=0; i<ins.length(); i++) {\\n\\t\\t\\t\\t\\tif(ins.charAt(i) == \\'R\\') {\\n\\t\\t\\t\\t\\t\\t// add -90 degrees or 270 degrees\\n\\t\\t\\t\\t\\t\\tcd  = (cd+270)%360;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1253320,
                "title": "simple-java-faster-than-100-0-ms",
                "content": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int x = 0;\\n        int y = 0;\\n        int direction = 90; // North\\n        for (char inst : instructions.toCharArray()) {\\n            switch (inst) {\\n                case \\'G\\':\\n                    if (direction == 90) y = y + 1; // North\\n                    if (direction == 270) y = y -1; // South\\n                    if (direction == 180) x = x - 1; // West\\n                    if (direction == 0) x = x + 1; // East\\n                    break;\\n                case \\'L\\':\\n                    direction = Math.floorMod(direction - 90, 360);\\n                    break;\\n                case \\'R\\':\\n                    direction = Math.floorMod(direction + 90, 360);\\n                    break;\\n            }\\n        }\\n        return (x == 0 && y == 0) || direction != 90;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int x = 0;\\n        int y = 0;\\n        int direction = 90; // North\\n        for (char inst : instructions.toCharArray()) {\\n            switch (inst) {\\n                case \\'G\\':\\n                    if (direction == 90) y = y + 1; // North\\n                    if (direction == 270) y = y -1; // South\\n                    if (direction == 180) x = x - 1; // West\\n                    if (direction == 0) x = x + 1; // East\\n                    break;\\n                case \\'L\\':\\n                    direction = Math.floorMod(direction - 90, 360);\\n                    break;\\n                case \\'R\\':\\n                    direction = Math.floorMod(direction + 90, 360);\\n                    break;\\n            }\\n        }\\n        return (x == 0 && y == 0) || direction != 90;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252872,
                "title": "c-100-faster",
                "content": "**If you like it then please upvote!!**\\n```\\nbool isRobotBounded(string instructions) {\\n        int x = 0;\\n        int y = 0;\\n        char dirn = \\'N\\';\\n        \\n        for(char c: instructions){\\n            if(c==\\'G\\'){\\n                if(dirn==\\'E\\'){\\n                    x = x+1;\\n                }\\n                else if(dirn==\\'W\\'){\\n                    x = x-1;\\n                }\\n                else if(dirn==\\'N\\'){\\n                    y = y+1;\\n                }\\n                else if(dirn==\\'S\\'){\\n                    y = y-1;\\n                }\\n            }\\n            if(c==\\'L\\'){\\n                if(dirn ==\\'E\\'){\\n                    dirn = \\'N\\';\\n                }\\n                else if(dirn==\\'W\\'){\\n                    dirn = \\'S\\';\\n                }\\n                else if(dirn==\\'S\\'){\\n                    dirn = \\'E\\';\\n                }\\n                else if(dirn==\\'N\\'){\\n                    dirn = \\'W\\';\\n                }\\n            }\\n            if(c==\\'R\\'){\\n                if(dirn ==\\'E\\'){\\n                    dirn = \\'S\\';\\n                }\\n                else if(dirn==\\'W\\'){\\n                    dirn = \\'N\\';\\n                }\\n                else if(dirn==\\'S\\'){\\n                    dirn = \\'W\\';\\n                }\\n                else if(dirn==\\'N\\'){\\n                    dirn = \\'E\\';\\n                }\\n            }\\n        }\\n        if(x==0&&y==0){\\n            return true;\\n        }\\n        if(dirn==\\'N\\'){\\n            return false;\\n        }\\n       return true;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nbool isRobotBounded(string instructions) {\\n        int x = 0;\\n        int y = 0;\\n        char dirn = \\'N\\';\\n        \\n        for(char c: instructions){\\n            if(c==\\'G\\'){\\n                if(dirn==\\'E\\'){\\n                    x = x+1;\\n                }\\n                else if(dirn==\\'W\\'){\\n                    x = x-1;\\n                }\\n                else if(dirn==\\'N\\'){\\n                    y = y+1;\\n                }\\n                else if(dirn==\\'S\\'){\\n                    y = y-1;\\n                }\\n            }\\n            if(c==\\'L\\'){\\n                if(dirn ==\\'E\\'){\\n                    dirn = \\'N\\';\\n                }\\n                else if(dirn==\\'W\\'){\\n                    dirn = \\'S\\';\\n                }\\n                else if(dirn==\\'S\\'){\\n                    dirn = \\'E\\';\\n                }\\n                else if(dirn==\\'N\\'){\\n                    dirn = \\'W\\';\\n                }\\n            }\\n            if(c==\\'R\\'){\\n                if(dirn ==\\'E\\'){\\n                    dirn = \\'S\\';\\n                }\\n                else if(dirn==\\'W\\'){\\n                    dirn = \\'N\\';\\n                }\\n                else if(dirn==\\'S\\'){\\n                    dirn = \\'W\\';\\n                }\\n                else if(dirn==\\'N\\'){\\n                    dirn = \\'E\\';\\n                }\\n            }\\n        }\\n        if(x==0&&y==0){\\n            return true;\\n        }\\n        if(dirn==\\'N\\'){\\n            return false;\\n        }\\n       return true;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1237313,
                "title": "c-easy-2-solutions",
                "content": "```\\npublic class Solution {\\n    public bool IsRobotBounded(string instructions) {\\n        \\n        //**** Method 1: Without Modulo ****//\\n        //Visualizing Clock wise motion //\\n        \\n        int x = 0;\\n        int y = 0;\\n        int dx = 0;\\n        int dy = 1;\\n        \\n        foreach(var ch in instructions)\\n        {\\n            if(ch == \\'G\\')\\n            {\\n                x += dx;\\n                y += dy;\\n            }\\n            else if(ch == \\'R\\')\\n            {\\n                var temp = dx;\\n                dx = dy;\\n                dy = -temp;\\n            }\\n            else if(ch == \\'L\\')\\n            {\\n                var temp = dy;\\n                dy = dx;\\n                dx = -temp;\\n            }\\n        }\\n        return (x == 0 && y == 0 || dy != 1);\\n    }\\n}\\n```\\n```\\npublic class Solution {\\n    public bool IsRobotBounded(string instructions) {\\n        \\n        //**** Method 2: With Modulo ****//\\n        \\n        var dx = new int[] {0, 1, 0, -1};\\n        var dy = new int[] {1, 0, -1, 0}; \\n        int x = 0;\\n        int y = 0;\\n        int dir = 0; // UP(0), RIgHT(1), DOWN(2), LEFT(3)\\n        \\n        for(int i = 0; i < instructions.Length; i++)\\n        {\\n            if(instructions[i] == \\'G\\')\\n            {\\n                x += dx[dir];\\n                y += dy[dir];\\n            }\\n            else if(instructions[i] == \\'R\\')\\n            {\\n                dir = (dir + 1)%4;\\n            }\\n            else if(instructions[i] == \\'L\\')\\n            {\\n                dir = (dir + 3)%4;\\n            }\\n        }\\n        return (x == 0 && y == 0 || dir != 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsRobotBounded(string instructions) {\\n        \\n        //**** Method 1: Without Modulo ****//\\n        //Visualizing Clock wise motion //\\n        \\n        int x = 0;\\n        int y = 0;\\n        int dx = 0;\\n        int dy = 1;\\n        \\n        foreach(var ch in instructions)\\n        {\\n            if(ch == \\'G\\')\\n            {\\n                x += dx;\\n                y += dy;\\n            }\\n            else if(ch == \\'R\\')\\n            {\\n                var temp = dx;\\n                dx = dy;\\n                dy = -temp;\\n            }\\n            else if(ch == \\'L\\')\\n            {\\n                var temp = dy;\\n                dy = dx;\\n                dx = -temp;\\n            }\\n        }\\n        return (x == 0 && y == 0 || dy != 1);\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool IsRobotBounded(string instructions) {\\n        \\n        //**** Method 2: With Modulo ****//\\n        \\n        var dx = new int[] {0, 1, 0, -1};\\n        var dy = new int[] {1, 0, -1, 0}; \\n        int x = 0;\\n        int y = 0;\\n        int dir = 0; // UP(0), RIgHT(1), DOWN(2), LEFT(3)\\n        \\n        for(int i = 0; i < instructions.Length; i++)\\n        {\\n            if(instructions[i] == \\'G\\')\\n            {\\n                x += dx[dir];\\n                y += dy[dir];\\n            }\\n            else if(instructions[i] == \\'R\\')\\n            {\\n                dir = (dir + 1)%4;\\n            }\\n            else if(instructions[i] == \\'L\\')\\n            {\\n                dir = (dir + 3)%4;\\n            }\\n        }\\n        return (x == 0 && y == 0 || dir != 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124690,
                "title": "simple-java-solution-with-explanation-beats-100-of-java-submissions",
                "content": "I am trying to make it super simple to understand . Please read my explanation and solution below:\\nSimple Explanation. If the robot reaches where it started after one sequence of commands it means it is bounded in a circle as it will be keep doing the same directions and keep reaching at the origin.\\n\\nOr if the robot reaches a direction other than north ,let say East , Think relatively, if it will follow the similar sequence of directions, it should reach south and third time it should reach west and then north respectively . Similarly it will keep moving in a circle .\\n\\n```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        char[] ins=instructions.toCharArray();\\n        int x=0;\\n        int y=0;\\n        char dir=\\'N\\';\\n        \\n        for(char pos:ins){\\n            \\n            switch(pos){\\n                case \\'G\\':\\n                    if(dir==\\'E\\')\\n                        x++;\\n                    else if(dir==\\'W\\')\\n                        x--;\\n                    else if(dir==\\'N\\')\\n                        y++;\\n                    else if(dir==\\'S\\')\\n                        y--;\\n                    break;\\n                case \\'L\\':\\n                    if(dir==\\'E\\')\\n                        dir=\\'N\\';\\n                    else if(dir==\\'W\\')\\n                        dir=\\'S\\';\\n                    else if(dir==\\'N\\')\\n                        dir=\\'W\\';\\n                    else if(dir==\\'S\\')\\n                        dir=\\'E\\';\\n                    break;\\n                case \\'R\\':\\n                    if(dir==\\'E\\')\\n                        dir=\\'S\\';\\n                    else if(dir==\\'W\\')\\n                        dir=\\'N\\';\\n                    else if(dir==\\'N\\')\\n                        dir=\\'E\\';\\n                    else if(dir==\\'S\\')\\n                        dir=\\'W\\';\\n                    break;\\n            }\\n                        \\n        }\\n        \\n        \\n        if((x==0 && y==0) || dir!=\\'N\\'){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        char[] ins=instructions.toCharArray();\\n        int x=0;\\n        int y=0;\\n        char dir=\\'N\\';\\n        \\n        for(char pos:ins){\\n            \\n            switch(pos){\\n                case \\'G\\':\\n                    if(dir==\\'E\\')\\n                        x++;\\n                    else if(dir==\\'W\\')\\n                        x--;\\n                    else if(dir==\\'N\\')\\n                        y++;\\n                    else if(dir==\\'S\\')\\n                        y--;\\n                    break;\\n                case \\'L\\':\\n                    if(dir==\\'E\\')\\n                        dir=\\'N\\';\\n                    else if(dir==\\'W\\')\\n                        dir=\\'S\\';\\n                    else if(dir==\\'N\\')\\n                        dir=\\'W\\';\\n                    else if(dir==\\'S\\')\\n                        dir=\\'E\\';\\n                    break;\\n                case \\'R\\':\\n                    if(dir==\\'E\\')\\n                        dir=\\'S\\';\\n                    else if(dir==\\'W\\')\\n                        dir=\\'N\\';\\n                    else if(dir==\\'N\\')\\n                        dir=\\'E\\';\\n                    else if(dir==\\'S\\')\\n                        dir=\\'W\\';\\n                    break;\\n            }\\n                        \\n        }\\n        \\n        \\n        if((x==0 && y==0) || dir!=\\'N\\'){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038242,
                "title": "java-one-pass-explain-why-direction-1-4",
                "content": "```\\nclass Solution {\\n    /*\\n\\t\\n\\ti is the direction for north: 0; east:1, south:2; west:3\\n\\t\\n    Why (i + 1) in (i + 1) % 4 ?\\n\\n    see we face north: 0, turn right: 1 => (0+1)%4=1\\n    see we face east: 1, turn right: 2 => (1+1)%4=2\\n    See we face south: 2, turn right: 3 => (2+1)%4=3\\n    See we face west: 3, turn right: 0 => (3+1)%4=0\\n    \\n    Notice if we add 1 to the left and then modulo 4 we get the numbers on the right\\n    Hence i = (i + 1) % 4\\n    \\n    Why (i + 3) in (i + 3) % 4 ?\\n    see we face north: 0, turn left: 3 => (0+3)%4=3\\n    see we face east: 1, turn left: 0 => (1+3)%4=0\\n    See we face south: 2, turn left: 1 => (2+3)%4=1\\n    See we face west: 3, turn left: 2 => (3+3)%4=2\\n    \\n    Notice if we add 3 to the left and then modulo 4 we get the numbers on the right\\n    Hence i = (i + 3) % 4\\n    \\n    */\\n    public boolean isRobotBounded(String instructions) {\\n       \\n        int x = 0, y = 0, i = 0; // initially north\\n        int d[][] = {{0, 1}, {1, 0}, {0, -1}, { -1, 0}};\\n        \\n        for (int j = 0; j < instructions.length(); ++j)\\n            if (instructions.charAt(j) == \\'R\\')\\n                i = (i + 1) % 4;\\n            else if (instructions.charAt(j) == \\'L\\')\\n                i = (i + 3) % 4;\\n            else {\\n                x += d[i][0]; \\n                y += d[i][1];\\n            }\\n        // in the end as long as we return to the starting point or direction is not north\\n        // we have a true answer\\n        return x == 0 && y == 0 || i > 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n\\t\\n\\ti is the direction for north: 0; east:1, south:2; west:3\\n\\t\\n    Why (i + 1) in (i + 1) % 4 ?\\n\\n    see we face north: 0, turn right: 1 => (0+1)%4=1\\n    see we face east: 1, turn right: 2 => (1+1)%4=2\\n    See we face south: 2, turn right: 3 => (2+1)%4=3\\n    See we face west: 3, turn right: 0 => (3+1)%4=0\\n    \\n    Notice if we add 1 to the left and then modulo 4 we get the numbers on the right\\n    Hence i = (i + 1) % 4\\n    \\n    Why (i + 3) in (i + 3) % 4 ?\\n    see we face north: 0, turn left: 3 => (0+3)%4=3\\n    see we face east: 1, turn left: 0 => (1+3)%4=0\\n    See we face south: 2, turn left: 1 => (2+3)%4=1\\n    See we face west: 3, turn left: 2 => (3+3)%4=2\\n    \\n    Notice if we add 3 to the left and then modulo 4 we get the numbers on the right\\n    Hence i = (i + 3) % 4\\n    \\n    */\\n    public boolean isRobotBounded(String instructions) {\\n       \\n        int x = 0, y = 0, i = 0; // initially north\\n        int d[][] = {{0, 1}, {1, 0}, {0, -1}, { -1, 0}};\\n        \\n        for (int j = 0; j < instructions.length(); ++j)\\n            if (instructions.charAt(j) == \\'R\\')\\n                i = (i + 1) % 4;\\n            else if (instructions.charAt(j) == \\'L\\')\\n                i = (i + 3) % 4;\\n            else {\\n                x += d[i][0]; \\n                y += d[i][1];\\n            }\\n        // in the end as long as we return to the starting point or direction is not north\\n        // we have a true answer\\n        return x == 0 && y == 0 || i > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024484,
                "title": "simple-python-solution-read-comments-you-will-understand-for-sure",
                "content": "```\\n# Solution 1: O(n) time complexity and o(1) space complexity\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        # initial poition\\n        x = y = 0\\n        # intially facing north\\n        direction = 0\\n        # 0 = north, 1 = east, 2 = south, 3 = west\\n        # With a move (G) in any direction, you will go 1 unit.\\n        # So you need to add 1 unit with x or y depending on\\n        # which direction you are going. For example,\\n        # if you go north from (x,y), then new position would be\\n        # (x, y+1) which is you get by x = x+0, y = y+1.\\n        # Now think about how you can get new position for other direction\\n        # So creating a dictionary with directions as keys and the\\n        # amount we need to add with x and y while we go for 1 unit\\n        # as value. \\n        possible_moves = {0: [0,1], 1: [1,0], 2: [0,-1], 3: [-1,0]}\\n        \\n        # Now the idea is if after executing the instructions, if you \\n        # get your final position at (0,0) or if you are not facing north\\n        # direction, that means you will be in circle. Not facing north\\n        # direction means, as you can repeat the instructions, if you are \\n        # not facing north after 1st execution of the instructions, just\\n        # repeat 3 more times of the same instructions, you will see \\n        # yourself at the origin. Think about with \\'GL\\' or \\'GR\\' \\n        # instructions as an example. With instruction \\'GLGR\\', you \\n        # can\\'t be back at origin, no matter how many times you repeat.\\n        for instruction in instructions:\\n            # turning left means, you will get the same direction \\n            # if you turn right 3 times. modulo beacuse we have \\n            # only 4 directions to consider. \\n            if instruction == \\'L\\':\\n                direction = (direction + 3)% 4\\n            elif instruction == \\'R\\':\\n                direction = (direction + 1)% 4\\n            # If we see \\'G\\' means we need to go 1 unit and\\n            # change x or y value according to the direction \\n            # we are going. By this we will get new position. \\n            else:\\n                x = x + possible_moves[direction][0]\\n                y = y + possible_moves[direction][1]\\n        # Finally, if you get your final position at (0,0) or if you \\n        # are not facing north direction, that means you will be \\n        # in circle.\\n        return (x==0 and y ==0) or direction !=0\\n                \\n        \\n        \\n```\\nMemory Usage: 14 MB, less than 98.82% of Python3 online submissions for Robot Bounded In Circle.",
                "solutionTags": [],
                "code": "```\\n# Solution 1: O(n) time complexity and o(1) space complexity\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        # initial poition\\n        x = y = 0\\n        # intially facing north\\n        direction = 0\\n        # 0 = north, 1 = east, 2 = south, 3 = west\\n        # With a move (G) in any direction, you will go 1 unit.\\n        # So you need to add 1 unit with x or y depending on\\n        # which direction you are going. For example,\\n        # if you go north from (x,y), then new position would be\\n        # (x, y+1) which is you get by x = x+0, y = y+1.\\n        # Now think about how you can get new position for other direction\\n        # So creating a dictionary with directions as keys and the\\n        # amount we need to add with x and y while we go for 1 unit\\n        # as value. \\n        possible_moves = {0: [0,1], 1: [1,0], 2: [0,-1], 3: [-1,0]}\\n        \\n        # Now the idea is if after executing the instructions, if you \\n        # get your final position at (0,0) or if you are not facing north\\n        # direction, that means you will be in circle. Not facing north\\n        # direction means, as you can repeat the instructions, if you are \\n        # not facing north after 1st execution of the instructions, just\\n        # repeat 3 more times of the same instructions, you will see \\n        # yourself at the origin. Think about with \\'GL\\' or \\'GR\\' \\n        # instructions as an example. With instruction \\'GLGR\\', you \\n        # can\\'t be back at origin, no matter how many times you repeat.\\n        for instruction in instructions:\\n            # turning left means, you will get the same direction \\n            # if you turn right 3 times. modulo beacuse we have \\n            # only 4 directions to consider. \\n            if instruction == \\'L\\':\\n                direction = (direction + 3)% 4\\n            elif instruction == \\'R\\':\\n                direction = (direction + 1)% 4\\n            # If we see \\'G\\' means we need to go 1 unit and\\n            # change x or y value according to the direction \\n            # we are going. By this we will get new position. \\n            else:\\n                x = x + possible_moves[direction][0]\\n                y = y + possible_moves[direction][1]\\n        # Finally, if you get your final position at (0,0) or if you \\n        # are not facing north direction, that means you will be \\n        # in circle.\\n        return (x==0 and y ==0) or direction !=0\\n                \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 902563,
                "title": "c-clean-code",
                "content": "Assuming the robot starts from origin(0,0), after repeating the command 4 times, the robot should come back to the origin in order for it to be contained within a finate space. \\n\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        vector<int> dx{1, 0, -1, 0};  \\n        vector<int> dy{0, 1, 0, -1};\\n        int dir=1, x=0, y=0; \\n        \\n        for(int k=0; k<4; k++){\\n            for(auto ch:instructions){\\n                if(ch==\\'L\\'){\\n                    dir = (dir==3) ? 0 : dir+1;\\n                }else if(ch==\\'R\\'){\\n                    dir = (dir==0) ? 3 : dir-1;\\n                }else{\\n                    x += dx.at(dir); \\n                    y += dy.at(dir); \\n                }\\n            }\\n        }\\n        \\n        return x==0 && y==0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        vector<int> dx{1, 0, -1, 0};  \\n        vector<int> dy{0, 1, 0, -1};\\n        int dir=1, x=0, y=0; \\n        \\n        for(int k=0; k<4; k++){\\n            for(auto ch:instructions){\\n                if(ch==\\'L\\'){\\n                    dir = (dir==3) ? 0 : dir+1;\\n                }else if(ch==\\'R\\'){\\n                    dir = (dir==0) ? 3 : dir-1;\\n                }else{\\n                    x += dx.at(dir); \\n                    y += dy.at(dir); \\n                }\\n            }\\n        }\\n        \\n        return x==0 && y==0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852664,
                "title": "java-100-faster-solution-than-you-can-imagine-using-array",
                "content": "```\\npublic boolean isRobotBounded(String instructions) {\\n        int pos[] = new int[4];\\n        int idx = 0;\\n        //N E S W\\n        //0 1 2 3\\n        for(int i=0;i<instructions.length();i++){\\n            char c = instructions.charAt(i);\\n            \\n            if( c == \\'G\\'){\\n                pos[idx]++;\\n            } else {\\n               int d = (c == \\'L\\') ? -1 : 1;\\n               idx = (4+idx+d)%4;\\n            }\\n        }\\n        int vertical = pos[0]-pos[2];\\n        int horizontal = pos[1]-pos[3];   \\n        int finalDirection = idx;\\n        \\n        //if it return back at same point\\n        if(vertical==0 && horizontal==0)\\n            return true;\\n        //if same direction,       \\n         \\n        return finalDirection!=0;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isRobotBounded(String instructions) {\\n        int pos[] = new int[4];\\n        int idx = 0;\\n        //N E S W\\n        //0 1 2 3\\n        for(int i=0;i<instructions.length();i++){\\n            char c = instructions.charAt(i);\\n            \\n            if( c == \\'G\\'){\\n                pos[idx]++;\\n            } else {\\n               int d = (c == \\'L\\') ? -1 : 1;\\n               idx = (4+idx+d)%4;\\n            }\\n        }\\n        int vertical = pos[0]-pos[2];\\n        int horizontal = pos[1]-pos[3];   \\n        int finalDirection = idx;\\n        \\n        //if it return back at same point\\n        if(vertical==0 && horizontal==0)\\n            return true;\\n        //if same direction,       \\n         \\n        return finalDirection!=0;\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 851545,
                "title": "c-faster-than-100-simple-solution-with-explanation",
                "content": "There are **two condition** robot will go in Circle loop.\\n1. instructions endpoint at (0,0)\\n2. instructions not equal to **N**(direction) and endpoint not equal to (0,0)\\n\\n**explanation**:\\n\\n![image](https://assets.leetcode.com/users/images/32a83430-2a50-4175-ad6b-59212e022485_1600393925.7353935.png)\\n\\n**code :**\\n\\n```c++\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string str) {\\n        int x=0;\\n        int y=0;\\n        int d=0;\\n        for(int i=0;i<str.size();i++){\\n            if(str[i] == \\'L\\'){\\n                d = d+1 > 3 ? 0 : d+1;\\n            }else if(str[i] == \\'R\\'){\\n                d = d-1 < 0 ? 3 : d-1;\\n            }else if(str[i] == \\'G\\'){\\n                switch(d){\\n                    case 0 : y+=1;\\n                        break;\\n                    case 1 : x+=1;\\n                        break;\\n                    case 2 : y-=1;\\n                        break;\\n                    case 3 : x-=1;\\n                        break;\\n                    default: break;\\n                }\\n            }\\n        }\\n        \\n        return (x==0 && y==0) ? true : d!=0 ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string str) {\\n        int x=0;\\n        int y=0;\\n        int d=0;\\n        for(int i=0;i<str.size();i++){\\n            if(str[i] == \\'L\\'){\\n                d = d+1 > 3 ? 0 : d+1;\\n            }else if(str[i] == \\'R\\'){\\n                d = d-1 < 0 ? 3 : d-1;\\n            }else if(str[i] == \\'G\\'){\\n                switch(d){\\n                    case 0 : y+=1;\\n                        break;\\n                    case 1 : x+=1;\\n                        break;\\n                    case 2 : y-=1;\\n                        break;\\n                    case 3 : x-=1;\\n                        break;\\n                    default: break;\\n                }\\n            }\\n        }\\n        \\n        return (x==0 && y==0) ? true : d!=0 ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851012,
                "title": "javascript-simple-solution-w-explanation-97-96",
                "content": "First, we declare a variable to hold the current direction, and an array to keep track of the directional moves. Then, iterate through the commands, and if it\\'s a forward move, increment the appropriate move value. If the command is a turn, update the direction variable, using a +1 for one direction and +3 for the other to keep the mod 4 value positive.\\n\\nThe important thing is to recognize that a set of commands that ends up with the robot facing a side results in a circular route leading back to the origin after 4 moves. A set of commands that ends up with the robot facing backwards will result in immediately reversing the action and will return to the origin after 2 moves. And a set of commands that ends up with the robot facing forwards will result in a false unless the robot ends the turn exactly at the origin.\\n\\nSo if the direction at the end is anything othe than the starting value, 0, or if the robot is still at the origin (if all forward and backward moves cancel out and all left and right moves cancel out), the return true, otherwise false.\\n\\n```\\nvar isRobotBounded = function(ins) {\\n    let dir = 0, mov = [0,0,0,0]\\n    for (let i = 0; i < ins.length; i++)\\n        if (ins[i] === \"G\") mov[dir]++\\n        else dir = (dir + (ins[i] === \"L\" ?  1 : 3)) % 4\\n    return dir || (!(mov[0]-mov[2]) && !(mov[1]-mov[3])) ? true : false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isRobotBounded = function(ins) {\\n    let dir = 0, mov = [0,0,0,0]\\n    for (let i = 0; i < ins.length; i++)\\n        if (ins[i] === \"G\") mov[dir]++\\n        else dir = (dir + (ins[i] === \"L\" ?  1 : 3)) % 4\\n    return dir || (!(mov[0]-mov[2]) && !(mov[1]-mov[3])) ? true : false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850867,
                "title": "c-one-run-solution-with-idea-explanation",
                "content": "Thanks for the [idea](https://leetcode.com/problems/robot-bounded-in-circle/discuss/850540/Java-Simple-self-explanatory-solution-or-O(n)-or-beats-100) to @mihirkiran\\n\\nJust run through instructions and check conditions:\\nA cycle exists if\\n- robot in the initial position with inititial direction\\nor\\n- the robot looks in another direction\\n(means that repeating the same instructions sequency robot will return to initial point with initial direction)\\n```\\n        public bool IsRobotBounded(string instructions) {\\n            int x = 0,\\n                y = 0,\\n                direction = 0;\\n            foreach (var instruction in instructions) {\\n                switch (instruction) {\\n                    case \\'L\\': direction = (direction + 1) % 4; break;\\n                    case \\'R\\': direction = (direction + 3) % 4; break;\\n                    case \\'G\\':\\n                        switch (direction) {\\n                            case 0: y++; break;\\n                            case 1: x--; break;\\n                            case 2: y--; break;\\n                            case 3: x++; break;\\n                        } break;\\n                }\\n            }\\n            return direction != 0 || (x == 0 && y == 0);\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public bool IsRobotBounded(string instructions) {\\n            int x = 0,\\n                y = 0,\\n                direction = 0;\\n            foreach (var instruction in instructions) {\\n                switch (instruction) {\\n                    case \\'L\\': direction = (direction + 1) % 4; break;\\n                    case \\'R\\': direction = (direction + 3) % 4; break;\\n                    case \\'G\\':\\n                        switch (direction) {\\n                            case 0: y++; break;\\n                            case 1: x--; break;\\n                            case 2: y--; break;\\n                            case 3: x++; break;\\n                        } break;\\n                }\\n            }\\n            return direction != 0 || (x == 0 && y == 0);\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850596,
                "title": "python-complex-numbers",
                "content": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        pos, initialpos = complex(0, 0), complex(0, 0)\\n        way, initialway = complex(0, 1), complex(0, 1)\\n        for inst in instructions:\\n            if inst == \\'G\\':\\n                pos += way\\n            elif inst == \\'L\\':\\n                way *= complex(0, 1)\\n            elif inst == \\'R\\':\\n                way *= complex(0, -1)\\n        if pos == initialpos or way != initialway:\\n            return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        pos, initialpos = complex(0, 0), complex(0, 0)\\n        way, initialway = complex(0, 1), complex(0, 1)\\n        for inst in instructions:\\n            if inst == \\'G\\':\\n                pos += way\\n            elif inst == \\'L\\':\\n                way *= complex(0, 1)\\n            elif inst == \\'R\\':\\n                way *= complex(0, -1)\\n        if pos == initialpos or way != initialway:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850491,
                "title": "java-o-n-100-faster-simple-solution-commented",
                "content": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int direction = 0; // 0: north, 1: west, 2: south, 3: east\\n        int pos[] = new int[]{0,0}; //initial position X and Y co-ordinate\\n        for(char instruction: instructions.toCharArray()){\\n            if(instruction == \\'L\\'){\\n                direction = ++direction%4; //direction always takes values in 0 to 3\\n            }else if(instruction == \\'R\\'){\\n                direction--;\\n                if(direction<0){\\n                    direction = 3;\\n                }\\n            }else{\\n                if(direction==0){\\n                    pos[1]++; //increase y co-ordinate\\n                }else if(direction==1){\\n                    pos[0]--; //decrease x co-ordinate\\n                }else if(direction==2){\\n                    pos[1]--; //decrease y co-ordinate\\n                }else{\\n                    pos[0]++;  //increase x co-ordinate\\n                }\\n            }\\n            \\n        }\\n    \\n        return (pos[0]==0 && pos[1]==0)?true:(direction!=0); //return true if initial postion = final position and if direction has changed\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int direction = 0; // 0: north, 1: west, 2: south, 3: east\\n        int pos[] = new int[]{0,0}; //initial position X and Y co-ordinate\\n        for(char instruction: instructions.toCharArray()){\\n            if(instruction == \\'L\\'){\\n                direction = ++direction%4; //direction always takes values in 0 to 3\\n            }else if(instruction == \\'R\\'){\\n                direction--;\\n                if(direction<0){\\n                    direction = 3;\\n                }\\n            }else{\\n                if(direction==0){\\n                    pos[1]++; //increase y co-ordinate\\n                }else if(direction==1){\\n                    pos[0]--; //decrease x co-ordinate\\n                }else if(direction==2){\\n                    pos[1]--; //decrease y co-ordinate\\n                }else{\\n                    pos[0]++;  //increase x co-ordinate\\n                }\\n            }\\n            \\n        }\\n    \\n        return (pos[0]==0 && pos[1]==0)?true:(direction!=0); //return true if initial postion = final position and if direction has changed\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850387,
                "title": "o-n-c-0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int p[2]={0,0};//coordinate of the position\\n        char ptr=\\'n\\';//facing direction\\n        for(int i=0;i<instructions.length();i++)\\n        {\\n            if(instructions[i]==\\'G\\')\\n            {\\n                if(ptr==\\'n\\')\\n                    p[1]+=1;//move north in y direction\\n                else if(ptr==\\'w\\')\\n                    p[0]-=1;//move west in x direction\\n                else if(ptr==\\'s\\')\\n                    p[1]-=1;//move south in y direction\\n                else\\n                    p[0]+=1;//move east in x direction\\n            }\\n            else if(instructions[i]==\\'L\\')\\n            {\\n                if(ptr==\\'n\\')\\n                    ptr=\\'w\\';//turn left(west from north)\\n                else if(ptr==\\'w\\')\\n                    ptr=\\'s\\';//turn left(south from west)\\n                else if(ptr==\\'s\\')\\n                    ptr=\\'e\\';//turn left(east from south)\\n                else\\n                    ptr=\\'n\\';//turn left(north from east)\\n            }\\n            else\\n            {\\n                if(ptr==\\'n\\')\\n                    ptr=\\'e\\';//turn right(east from north)\\n                else if(ptr==\\'w\\')\\n                    ptr=\\'n\\';//turn right(north fro west)\\n                else if(ptr==\\'s\\')\\n                    ptr=\\'w\\';//turn right(west from south)\\n                else\\n                    ptr=\\'s\\';//turn right(south from east)\\n            }\\n        }\\n        if(ptr!=\\'n\\'||(p[0]==0&&p[1]==0))\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        int p[2]={0,0};//coordinate of the position\\n        char ptr=\\'n\\';//facing direction\\n        for(int i=0;i<instructions.length();i++)\\n        {\\n            if(instructions[i]==\\'G\\')\\n            {\\n                if(ptr==\\'n\\')\\n                    p[1]+=1;//move north in y direction\\n                else if(ptr==\\'w\\')\\n                    p[0]-=1;//move west in x direction\\n                else if(ptr==\\'s\\')\\n                    p[1]-=1;//move south in y direction\\n                else\\n                    p[0]+=1;//move east in x direction\\n            }\\n            else if(instructions[i]==\\'L\\')\\n            {\\n                if(ptr==\\'n\\')\\n                    ptr=\\'w\\';//turn left(west from north)\\n                else if(ptr==\\'w\\')\\n                    ptr=\\'s\\';//turn left(south from west)\\n                else if(ptr==\\'s\\')\\n                    ptr=\\'e\\';//turn left(east from south)\\n                else\\n                    ptr=\\'n\\';//turn left(north from east)\\n            }\\n            else\\n            {\\n                if(ptr==\\'n\\')\\n                    ptr=\\'e\\';//turn right(east from north)\\n                else if(ptr==\\'w\\')\\n                    ptr=\\'n\\';//turn right(north fro west)\\n                else if(ptr==\\'s\\')\\n                    ptr=\\'w\\';//turn right(west from south)\\n                else\\n                    ptr=\\'s\\';//turn right(south from east)\\n            }\\n        }\\n        if(ptr!=\\'n\\'||(p[0]==0&&p[1]==0))\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 608858,
                "title": "java-easy-time-100-and-space-100",
                "content": "```\\npublic boolean isRobotBounded(String instructions) {\\n        \\n        int[] currCor = new int[2];\\n        int[][] dir =  {{0,1}, {1,0}, {0,-1}, {-1,0}};\\n        \\n        int ind = 0;\\n        \\n        for(int i = 0; i < instructions.length(); i++){\\n            \\n            if(instructions.charAt(i) == \\'L\\'){\\n                ind = (ind + 3) % 4;\\n                continue;\\n            }\\n            if(instructions.charAt(i) == \\'R\\'){\\n                ind = (ind + 1) % 4;\\n                continue;\\n            }\\n            \\n            currCor[0] += dir[ind][0];\\n            currCor[1] += dir[ind][1];\\n        }\\n        \\n        return (currCor[0] == 0 && currCor[1] == 0) || (ind > 0) ? true:false;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic boolean isRobotBounded(String instructions) {\\n        \\n        int[] currCor = new int[2];\\n        int[][] dir =  {{0,1}, {1,0}, {0,-1}, {-1,0}};\\n        \\n        int ind = 0;\\n        \\n        for(int i = 0; i < instructions.length(); i++){\\n            \\n            if(instructions.charAt(i) == \\'L\\'){\\n                ind = (ind + 3) % 4;\\n                continue;\\n            }\\n            if(instructions.charAt(i) == \\'R\\'){\\n                ind = (ind + 1) % 4;\\n                continue;\\n            }\\n            \\n            currCor[0] += dir[ind][0];\\n            currCor[1] += dir[ind][1];\\n        }\\n        \\n        return (currCor[0] == 0 && currCor[1] == 0) || (ind > 0) ? true:false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 571377,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func isRobotBounded(_ instructions: String) -> Bool {\\n        var currentPosition: (x: Int, y: Int) = (0, 0)\\n        var currentDirection: Direction = .north\\n        \\n        guard !instructions.isEmpty else { return true }\\n        \\n        let instrutionsArray = instructions.map { String($0) }\\n        \\n        for instruction in instrutionsArray {\\n            switch instruction {\\n                case \"G\":\\n                    let coordinates = currentDirection.coordinates\\n                    currentPosition.x += coordinates.x\\n                    currentPosition.y += coordinates.y\\n                case \"L\", \"R\":\\n                    currentDirection = currentDirection.getNewDirection(instruction)\\n                default:\\n                    continue\\n            }\\n        }\\n        \\n        if (currentDirection != .north) || currentPosition == (0, 0) {\\n            return true\\n        }\\n        return false\\n    }\\n}\\n\\nenum Direction {\\n    case north\\n    case west\\n    case east\\n    case south\\n    \\n    var coordinates: (x: Int, y: Int) {\\n        switch self {\\n            case .north:\\n                return (x: 0, y: 1)\\n            case .west:\\n                return (x: 1, y: 0)\\n            case .east:\\n                return (x: -1, y: 0)\\n            case .south:\\n                return (x: 0, y: -1)\\n        }\\n    }\\n    \\n    func getNewDirection(_ movement: String) -> Direction {\\n        switch self {\\n            case .south:\\n                return (movement == \"L\") ? .east : .west\\n            case .north:\\n                return (movement == \"L\") ? .west : .east\\n            case .west:\\n                return (movement == \"L\") ? .south : .north\\n            case .east:\\n                return (movement == \"L\") ? .north : .south\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func isRobotBounded(_ instructions: String) -> Bool {\\n        var currentPosition: (x: Int, y: Int) = (0, 0)\\n        var currentDirection: Direction = .north\\n        \\n        guard !instructions.isEmpty else { return true }\\n        \\n        let instrutionsArray = instructions.map { String($0) }\\n        \\n        for instruction in instrutionsArray {\\n            switch instruction {\\n                case \"G\":\\n                    let coordinates = currentDirection.coordinates\\n                    currentPosition.x += coordinates.x\\n                    currentPosition.y += coordinates.y\\n                case \"L\", \"R\":\\n                    currentDirection = currentDirection.getNewDirection(instruction)\\n                default:\\n                    continue\\n            }\\n        }\\n        \\n        if (currentDirection != .north) || currentPosition == (0, 0) {\\n            return true\\n        }\\n        return false\\n    }\\n}\\n\\nenum Direction {\\n    case north\\n    case west\\n    case east\\n    case south\\n    \\n    var coordinates: (x: Int, y: Int) {\\n        switch self {\\n            case .north:\\n                return (x: 0, y: 1)\\n            case .west:\\n                return (x: 1, y: 0)\\n            case .east:\\n                return (x: -1, y: 0)\\n            case .south:\\n                return (x: 0, y: -1)\\n        }\\n    }\\n    \\n    func getNewDirection(_ movement: String) -> Direction {\\n        switch self {\\n            case .south:\\n                return (movement == \"L\") ? .east : .west\\n            case .north:\\n                return (movement == \"L\") ? .west : .east\\n            case .west:\\n                return (movement == \"L\") ? .south : .north\\n            case .east:\\n                return (movement == \"L\") ? .north : .south\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560216,
                "title": "c-100-100-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int cr[2]={0,0};\\n    char dir=\\'N\\';\\n    bool isRobotBounded(string instructions) \\n    {  \\n      for(auto ch:instructions)\\n      {\\n        if(ch==\\'G\\')\\n          move();\\n        else\\n          turn(ch);\\n       }\\n      if(cr[0]==0&&cr[1]==0)\\n        return true;\\n      if(dir==\\'N\\')\\n        return false; \\n      return true;\\n    }\\n  void move()\\n  {\\n      if(dir==\\'N\\')\\n        cr[0]++;\\n      else if(dir==\\'S\\')\\n        cr[0]--;\\n      else if(dir==\\'L\\')\\n        cr[1]--;\\n      else if(dir==\\'R\\')\\n        cr[1]++;\\n    return;\\n  }\\n  void turn(char ch)\\n  {\\n    if(dir==\\'N\\')\\n      dir=ch;\\n    else if(dir==\\'S\\')\\n      dir=ch==\\'L\\'?\\'R\\':\\'L\\';\\n    else if(dir==\\'L\\')\\n      dir=ch==\\'L\\'?\\'S\\':\\'N\\';\\n    else\\n      dir=ch==\\'R\\'?\\'S\\':\\'N\\';\\n   return;   \\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int cr[2]={0,0};\\n    char dir=\\'N\\';\\n    bool isRobotBounded(string instructions) \\n    {  \\n      for(auto ch:instructions)\\n      {\\n        if(ch==\\'G\\')\\n          move();\\n        else\\n          turn(ch);\\n       }\\n      if(cr[0]==0&&cr[1]==0)\\n        return true;\\n      if(dir==\\'N\\')\\n        return false; \\n      return true;\\n    }\\n  void move()\\n  {\\n      if(dir==\\'N\\')\\n        cr[0]++;\\n      else if(dir==\\'S\\')\\n        cr[0]--;\\n      else if(dir==\\'L\\')\\n        cr[1]--;\\n      else if(dir==\\'R\\')\\n        cr[1]++;\\n    return;\\n  }\\n  void turn(char ch)\\n  {\\n    if(dir==\\'N\\')\\n      dir=ch;\\n    else if(dir==\\'S\\')\\n      dir=ch==\\'L\\'?\\'R\\':\\'L\\';\\n    else if(dir==\\'L\\')\\n      dir=ch==\\'L\\'?\\'S\\':\\'N\\';\\n    else\\n      dir=ch==\\'R\\'?\\'S\\':\\'N\\';\\n   return;   \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 381045,
                "title": "o-n-simple-java-solution-beats-100",
                "content": "```class Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int ctL = 0;\\n        int ctR = 0;\\n        //North = 1, East = 2, South = 3, West = 4\\n        int dir = 1;\\n        int y = 0;\\n        int x = 0;\\n        for(int i = 0; i < instructions.length(); i++) {\\n            char c = instructions.charAt(i);\\n            if(c == \\'L\\') {\\n                if(dir == 1) dir = 4;\\n                else dir--;\\n            }\\n            \\n            else if(c == \\'R\\') {\\n                if(dir == 4) dir = 1;\\n                else dir++;\\n            }\\n            else {\\n                if(dir == 1) y++;\\n                else if(dir == 2) x++;\\n                else if(dir == 4) x--;\\n                else if(dir == 3) y--;\\n            }\\n        }\\n        if(dir == 1) {\\n            if(y == 0 && x == 0) return true;\\n            return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isRobotBounded(String instructions) {\\n        int ctL = 0;\\n        int ctR = 0;\\n        //North = 1, East = 2, South = 3, West = 4\\n        int dir = 1;\\n        int y = 0;\\n        int x = 0;\\n        for(int i = 0; i < instructions.length(); i++) {\\n            char c = instructions.charAt(i);\\n            if(c == \\'L\\') {\\n                if(dir == 1) dir = 4;\\n                else dir--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 338167,
                "title": "slow-but-very-easy-to-come-up-with-solution",
                "content": "Actually I solved it with simple simulations without thinking.\\nJust simulate a long enough sequence of moves and then check if the robot is near its starting position.\\n```\\n    bool isRobotBounded(string instructions) {\\n        int MOVE[][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int x = 0;\\n        int y = 0;\\n        int dir = 0;\\n        for (int i = 0; i < 1000000; ++i) {\\n           switch (instructions[i % instructions.size()]) {\\n              case \\'L\\': \\n                  dir = (dir + 1) % 4;\\n                  break;\\n              case \\'R\\':\\n                  dir = dir == 0 ? 3 : (dir - 1);\\n                  break;\\n              case \\'G\\':\\n                  x += MOVE[dir][0];\\n                  y += MOVE[dir][1];\\n           }\\n        }\\n        return x >= -10000 && x <= 10000 && y <= 10000 && y >= -10000;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool isRobotBounded(string instructions) {\\n        int MOVE[][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int x = 0;\\n        int y = 0;\\n        int dir = 0;\\n        for (int i = 0; i < 1000000; ++i) {\\n           switch (instructions[i % instructions.size()]) {\\n              case \\'L\\': \\n                  dir = (dir + 1) % 4;\\n                  break;\\n              case \\'R\\':\\n                  dir = dir == 0 ? 3 : (dir - 1);\\n                  break;\\n              case \\'G\\':\\n                  x += MOVE[dir][0];\\n                  y += MOVE[dir][1];\\n           }\\n        }\\n        return x >= -10000 && x <= 10000 && y <= 10000 && y >= -10000;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 304977,
                "title": "1041-c-solution-beats-100-runtime-and-100-memory-with-explanation",
                "content": "[**Proof** (Click for Submission Details)](https://leetcode.com/submissions/detail/233388735/)\\n![image](https://assets.leetcode.com/users/rafaelwi/image_1559587060.png)\\n\\n\\n**Code**\\n```c\\nbool isRobotBounded(char * instructions){\\n    int x = 0;\\n    int y = 0;\\n    int dx = 0;\\n    int dy = 1; // facing north\\n    int temp = 0;\\n    \\n    for (int i = 0; i < strlen(instructions); i++){\\n        switch(instructions[i]){\\n            case \\'R\\':\\n                temp = dx;\\n                dx = dy;\\n                dy = -temp;\\n                break;\\n            case \\'L\\':\\n                temp = dx;\\n                dx = -dy;\\n                dy = temp;\\n                break;\\n            case \\'G\\':\\n                x += dx;\\n                y += dy;\\n                break;\\n        } // end switch\\n    } // end for\\n    \\n    return (((x == 0) && (y == 0)) || ((dx != 0) || (dy != 1)));\\n} // end isRobotBounded\\n```\\n\\n**Explanation**\\nThe idea here is that if the robot returns to origin (0, 0) OR if the robot is not facing north (with north being dx = 0, dy = 1), then the robot is bounded within a circle. Otherwise, we are not bounded by a circle. \\n\\nThis is becuase if you are facing north at the end of a set of instructions, then you have either a) not done any L or R instructions or b) # of L instructions == # of R instructions. This means that with repeated runs of that set of instuctions, you will continue to face north at the end and continuously drift away from the center. However, if # of L instructions != # of R instructions, with enough runs of the instructions, in this case 4 times, as we only have four directions we can travel in (thank you @Achilles_NLP!), you will either return to (0, 0) or nearby.",
                "solutionTags": [],
                "code": "```c\\nbool isRobotBounded(char * instructions){\\n    int x = 0;\\n    int y = 0;\\n    int dx = 0;\\n    int dy = 1; // facing north\\n    int temp = 0;\\n    \\n    for (int i = 0; i < strlen(instructions); i++){\\n        switch(instructions[i]){\\n            case \\'R\\':\\n                temp = dx;\\n                dx = dy;\\n                dy = -temp;\\n                break;\\n            case \\'L\\':\\n                temp = dx;\\n                dx = -dy;\\n                dy = temp;\\n                break;\\n            case \\'G\\':\\n                x += dx;\\n                y += dy;\\n                break;\\n        } // end switch\\n    } // end for\\n    \\n    return (((x == 0) && (y == 0)) || ((dx != 0) || (dy != 1)));\\n} // end isRobotBounded\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 295640,
                "title": "python-7-lines",
                "content": "**Explanation**\\nN\\n|\\nW-E\\n|\\nS\\nThe move \\u2018G\\u2019 changes either x or y according to following rules.\\na) If current direction is North, then \\u2018G\\u2019 increments y and doesn\\u2019t change x.\\nb) If current direction is East, then \\u2018G\\u2019 increments x and doesn\\u2019t change y.\\nc) If current direction is South, then \\u2018G\\u2019 decrements y and doesn\\u2019t change x.\\nd) If current direction is West, then \\u2018G\\u2019 decrements x and doesn\\u2019t change y.\\n\\nThe moves \\u2018L\\u2019 and \\u2018R\\u2019, do not change x and y coordinates, they only change direction according to following rule.\\na) If current direction is North, then \\u2018L\\u2019 changes direction to West and \\u2018R\\u2019 changes to East\\nb) If current direction is East, then \\u2018L\\u2019 changes direction to North and \\u2018R\\u2019 changes to South\\nc) If current direction is South, then \\u2018L\\u2019 changes direction to East and \\u2018R\\u2019 changes to West\\nd) If current direction is West, then \\u2018L\\u2019 changes direction to South and \\u2018R\\u2019 changes to North\\n\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        x,y,dirX,dirY = 0,0,0,1\\n        instructions *= 4\\n        \\n        for i in instructions:\\n            if i == \\'L\\': dirX,dirY = -dirY,dirX\\n            elif i == \\'R\\': dirX,dirY = dirY,-dirX\\n            else: x,y = x+dirX, y+dirY\\n        \\n        return x == 0 and y == 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        x,y,dirX,dirY = 0,0,0,1\\n        instructions *= 4\\n        \\n        for i in instructions:\\n            if i == \\'L\\': dirX,dirY = -dirY,dirX\\n            elif i == \\'R\\': dirX,dirY = dirY,-dirX\\n            else: x,y = x+dirX, y+dirY\\n        \\n        return x == 0 and y == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293120,
                "title": "python-o-n-6-line-solution-beats-100",
                "content": "Tricks:\\n- Complex number suits this question well.\\n- Combinations like \"LLLL\", \"RRRR\", \"RL\", \"LR\" does not have any effect, removing these combinations are considered very efficient in python, which will lead to a ~15% performance gain.\\n```\\nclass Solution:\\n    def isRobotBounded(self, ins: str) -> bool:\\n        ins = ins.replace(\\'LLLL\\', \\'\\').replace(\\'RRRR\\', \\'\\').replace(\\'RL\\', \\'\\').replace(\\'LR\\', \\'\\')\\n        d, p = 1, 0\\n        for c in ins:\\n            if c == \\'G\\': p += d\\n            else: d *= {\\'L\\':1j, \\'R\\':-1j}[c]\\n        return d.real == 0 or p == 0 or d.real < 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, ins: str) -> bool:\\n        ins = ins.replace(\\'LLLL\\', \\'\\').replace(\\'RRRR\\', \\'\\').replace(\\'RL\\', \\'\\').replace(\\'LR\\', \\'\\')\\n        d, p = 1, 0\\n        for c in ins:\\n            if c == \\'G\\': p += d\\n            else: d *= {\\'L\\':1j, \\'R\\':-1j}[c]\\n        return d.real == 0 or p == 0 or d.real < 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291566,
                "title": "sexy-java-solution-1-ms",
                "content": "```\\npublic boolean isRobotBounded(String instructions) {\\n        Direction dir = Direction.N;\\n        int north = 0, east = 0;\\n        char[] chars = instructions.toCharArray();\\n        for (int i = 0; i < 4; i++) {\\n            for (char c : chars) {\\n                switch (c) {\\n                    case \\'G\\':\\n                        switch (dir) {\\n                            case N:\\n                                north++;\\n                                break;\\n                            case S:\\n                                north--;\\n                                break;\\n                            case E:\\n                                east++;\\n                                break;\\n                            case W:\\n                                east--;\\n                                break;\\n                        }\\n                        break;\\n                    case \\'L\\':\\n                        dir = dir.left();\\n                        break;\\n                    case \\'R\\':\\n                        dir = dir.right();\\n                        break;\\n                }\\n            }\\n            if (north+east == 0) return true;\\n        }\\n        return north+east == 0;\\n    }\\n    enum Direction {\\n        N,S,E,W;\\n\\n        public Direction right() {\\n            switch (this) {\\n                case N:\\n                    return Direction.E;\\n                case S:\\n                    return Direction.W;\\n                case E:\\n                    return Direction.S;\\n                case W:\\n                    return Direction.N;\\n            }\\n            return this;\\n        }\\n        public Direction left() {\\n            return this.right().right().right();\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean isRobotBounded(String instructions) {\\n        Direction dir = Direction.N;\\n        int north = 0, east = 0;\\n        char[] chars = instructions.toCharArray();\\n        for (int i = 0; i < 4; i++) {\\n            for (char c : chars) {\\n                switch (c) {\\n                    case \\'G\\':\\n                        switch (dir) {\\n                            case N:\\n                                north++;\\n                                break;\\n                            case S:\\n                                north--;\\n                                break;\\n                            case E:\\n                                east++;\\n                                break;\\n                            case W:\\n                                east--;\\n                                break;\\n                        }\\n                        break;\\n                    case \\'L\\':\\n                        dir = dir.left();\\n                        break;\\n                    case \\'R\\':\\n                        dir = dir.right();\\n                        break;\\n                }\\n            }\\n            if (north+east == 0) return true;\\n        }\\n        return north+east == 0;\\n    }\\n    enum Direction {\\n        N,S,E,W;\\n\\n        public Direction right() {\\n            switch (this) {\\n                case N:\\n                    return Direction.E;\\n                case S:\\n                    return Direction.W;\\n                case E:\\n                    return Direction.S;\\n                case W:\\n                    return Direction.N;\\n            }\\n            return this;\\n        }\\n        public Direction left() {\\n            return this.right().right().right();\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 290966,
                "title": "java-o-n-solution-explained-in-only-one-case-the-robot-is-not-bounded",
                "content": "**Explanation:**\\nOnly if the robot returns to a **different position with the same facing direction** as the start point after the instructions, it will go infinitly away from the start point.\\nIn all other cases, i.e.,\\n\\n1. same position, same direction;\\n2. same position, different direction;\\n2. different position, different direction,\\n\\nthe robot with be bounded in a circle.\\n```\\npublic boolean isRobotBounded(String instructions) {\\n    int x = 0, y = 0, direction = 0;\\n\\t// north: 0, east: 1, south: 2, west: 3;\\n    for (int i = 0; i < instructions.length(); i++) {\\n\\t    // update the direction\\n\\t\\tchar c = instructions.charAt(i);\\n\\t    if (c == \\'L\\') direction = Math.floorMod(--direction, 4);\\n        if (c == \\'R\\') direction = Math.floorMod(++direction, 4);\\n\\t\\tif (c == \\'G\\') {\\n\\t\\t    // move the robot according to its direction \\n\\t        if (direction == 0) y++;\\n            if (direction == 1) x++;\\n\\t\\t\\tif (direction == 2) y--;\\n            if (direction == 3) x--;\\n        }\\n    }\\n\\t// only if robot returns to a different position with the same facing direction\\n\\t// as the start point, return false\\n    if (direction == 0 && (x != 0 || y != 0)) return false;\\n\\treturn true;\\n}\\n```\\n**Complexity:**\\nTime: O(N)\\nSpace: O(1)",
                "solutionTags": [],
                "code": "```\\npublic boolean isRobotBounded(String instructions) {\\n    int x = 0, y = 0, direction = 0;\\n\\t// north: 0, east: 1, south: 2, west: 3;\\n    for (int i = 0; i < instructions.length(); i++) {\\n\\t    // update the direction\\n\\t\\tchar c = instructions.charAt(i);\\n\\t    if (c == \\'L\\') direction = Math.floorMod(--direction, 4);\\n        if (c == \\'R\\') direction = Math.floorMod(++direction, 4);\\n\\t\\tif (c == \\'G\\') {\\n\\t\\t    // move the robot according to its direction \\n\\t        if (direction == 0) y++;\\n            if (direction == 1) x++;\\n\\t\\t\\tif (direction == 2) y--;\\n            if (direction == 3) x--;\\n        }\\n    }\\n\\t// only if robot returns to a different position with the same facing direction\\n\\t// as the start point, return false\\n    if (direction == 0 && (x != 0 || y != 0)) return false;\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3940290,
                "title": "beats-100-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake a 2 size array defining x and y axis\\nUpdate that array according to directions\\nReturn true if final direction is not north\\nof It returns to origin\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O[n]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O[1]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n\\n        // Bascially Our x and y axis\\n        int[] ans = new int[2];\\n\\n        // To circulate between changing directions\\n        char[] directions =  {\\'n\\',\\'w\\',\\'s\\',\\'e\\'};\\n\\n        // index we used to circulate among directions\\n        int idx = 0;\\n        // It represents north direction\\n\\n        for (char k : instructions.toCharArray())\\n        {   \\n            // If character is L which means move towards right in Array\\n            if (k==\\'L\\') \\n            {\\n                idx++;\\n                // If index exceeds 3 index reset it to north i.e. zero\\n                if (idx==4) idx=0;\\n            }\\n\\n            // If character is R which means move towards left in array\\n            if (k==\\'R\\')\\n            {\\n                idx--;\\n                // If index get lower than 0 reset it to 3 i.e. East\\n                if (idx==-1) idx=3;\\n            }\\n\\n            if (k==\\'G\\')\\n            {\\n                // According to conditions given in question update ans array of x and y axis   \\n                // if direction is north means positive y direction\\n                if (directions[idx]==\\'n\\') ans[1]++; \\n\\n                // if direction is south means negetive y direction\\n                if (directions[idx]==\\'s\\') ans[1]--;\\n\\n                // if direction is east means positive x direction\\n                if (directions[idx]==\\'e\\') ans[0]++;\\n\\n                // if direction is west means negetive x direction\\n                if (directions[idx]==\\'w\\') ans[0]--;\\n            }\\n        }\\n\\n        // If it is facing some another direction then there will be a possiblity that it never leaves the circle\\n\\n        // And if it return to origin it is win win i.e. true\\n        if ((ans[0]==0 && ans[1]==0) || idx!=0) return true;\\n\\n        // Return false otherwise\\n        return false;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRobotBounded(String instructions) {\\n\\n        // Bascially Our x and y axis\\n        int[] ans = new int[2];\\n\\n        // To circulate between changing directions\\n        char[] directions =  {\\'n\\',\\'w\\',\\'s\\',\\'e\\'};\\n\\n        // index we used to circulate among directions\\n        int idx = 0;\\n        // It represents north direction\\n\\n        for (char k : instructions.toCharArray())\\n        {   \\n            // If character is L which means move towards right in Array\\n            if (k==\\'L\\') \\n            {\\n                idx++;\\n                // If index exceeds 3 index reset it to north i.e. zero\\n                if (idx==4) idx=0;\\n            }\\n\\n            // If character is R which means move towards left in array\\n            if (k==\\'R\\')\\n            {\\n                idx--;\\n                // If index get lower than 0 reset it to 3 i.e. East\\n                if (idx==-1) idx=3;\\n            }\\n\\n            if (k==\\'G\\')\\n            {\\n                // According to conditions given in question update ans array of x and y axis   \\n                // if direction is north means positive y direction\\n                if (directions[idx]==\\'n\\') ans[1]++; \\n\\n                // if direction is south means negetive y direction\\n                if (directions[idx]==\\'s\\') ans[1]--;\\n\\n                // if direction is east means positive x direction\\n                if (directions[idx]==\\'e\\') ans[0]++;\\n\\n                // if direction is west means negetive x direction\\n                if (directions[idx]==\\'w\\') ans[0]--;\\n            }\\n        }\\n\\n        // If it is facing some another direction then there will be a possiblity that it never leaves the circle\\n\\n        // And if it return to origin it is win win i.e. true\\n        if ((ans[0]==0 && ans[1]==0) || idx!=0) return true;\\n\\n        // Return false otherwise\\n        return false;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895586,
                "title": "simple-kotlin-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun isRobotBounded(instructions: String): Boolean {\\n        val steps = listOf(1 to 0, 0 to 1, -1 to 0, 0 to -1)\\n        var step = 0\\n        var y = 0\\n        var x = 0\\n        for (c in instructions.repeat(4)) {\\n            when (c) {\\n                \\'R\\' -> step = (step + 1) % steps.size\\n                \\'L\\' -> step = (step - 1 + steps.size) % steps.size\\n                else -> steps[step].also { (dy, dx) -> y += dy; x += dx }\\n            }\\n        }\\n        return y == 0 && x == 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun isRobotBounded(instructions: String): Boolean {\\n        val steps = listOf(1 to 0, 0 to 1, -1 to 0, 0 to -1)\\n        var step = 0\\n        var y = 0\\n        var x = 0\\n        for (c in instructions.repeat(4)) {\\n            when (c) {\\n                \\'R\\' -> step = (step + 1) % steps.size\\n                \\'L\\' -> step = (step - 1 + steps.size) % steps.size\\n                else -> steps[step].also { (dy, dx) -> y += dy; x += dx }\\n            }\\n        }\\n        return y == 0 && x == 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640714,
                "title": "intuitive-code",
                "content": "# Code\\n```\\nfunc isRobotBounded(instructions string) bool {\\n\\tfor i := 0; i < 2; i++ {\\n\\t\\tinstructions = instructions + instructions\\n\\t}\\n\\tdirections := []byte{\\'N\\', \\'W\\', \\'S\\', \\'E\\'}\\n\\tpoint_to_dir := 0\\n\\tcoords := [2]int{0, 0}\\n\\tfor _, instruction := range instructions {\\n\\t\\tswitch instruction {\\n\\t\\tcase \\'G\\':\\n\\t\\t\\tdirection := directions[point_to_dir]\\n\\t\\t\\tswitch direction {\\n\\t\\t\\tcase \\'N\\':\\n\\t\\t\\t\\tcoords[1] += 1\\n\\t\\t\\tcase \\'S\\':\\n\\t\\t\\t\\tcoords[1] -= 1\\n\\t\\t\\tcase \\'W\\':\\n\\t\\t\\t\\tcoords[0] -= 1\\n\\t\\t\\tcase \\'E\\':\\n\\t\\t\\t\\tcoords[0] += 1\\n\\t\\t\\t}\\n\\n\\t\\tcase \\'L\\':\\n\\t\\t\\tif point_to_dir != len(directions)-1 {\\n\\t\\t\\t\\tpoint_to_dir += 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpoint_to_dir = 0\\n\\t\\t\\t}\\n\\t\\tcase \\'R\\':\\n\\t\\t\\tif point_to_dir != 0 {\\n\\t\\t\\t\\tpoint_to_dir -= 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpoint_to_dir = len(directions) - 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn coords[0] == 0 && coords[1] == 0\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isRobotBounded(instructions string) bool {\\n\\tfor i := 0; i < 2; i++ {\\n\\t\\tinstructions = instructions + instructions\\n\\t}\\n\\tdirections := []byte{\\'N\\', \\'W\\', \\'S\\', \\'E\\'}\\n\\tpoint_to_dir := 0\\n\\tcoords := [2]int{0, 0}\\n\\tfor _, instruction := range instructions {\\n\\t\\tswitch instruction {\\n\\t\\tcase \\'G\\':\\n\\t\\t\\tdirection := directions[point_to_dir]\\n\\t\\t\\tswitch direction {\\n\\t\\t\\tcase \\'N\\':\\n\\t\\t\\t\\tcoords[1] += 1\\n\\t\\t\\tcase \\'S\\':\\n\\t\\t\\t\\tcoords[1] -= 1\\n\\t\\t\\tcase \\'W\\':\\n\\t\\t\\t\\tcoords[0] -= 1\\n\\t\\t\\tcase \\'E\\':\\n\\t\\t\\t\\tcoords[0] += 1\\n\\t\\t\\t}\\n\\n\\t\\tcase \\'L\\':\\n\\t\\t\\tif point_to_dir != len(directions)-1 {\\n\\t\\t\\t\\tpoint_to_dir += 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpoint_to_dir = 0\\n\\t\\t\\t}\\n\\t\\tcase \\'R\\':\\n\\t\\t\\tif point_to_dir != 0 {\\n\\t\\t\\t\\tpoint_to_dir -= 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpoint_to_dir = len(directions) - 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn coords[0] == 0 && coords[1] == 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3485375,
                "title": "python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        x, y, dx, dy = 0, 0, 0, 1\\n        for ins in instructions:\\n            if ins == \\'G\\':\\n                x, y = x + dx, y + dy\\n            elif ins == \\'L\\':\\n                dx, dy = -dy, dx\\n            elif ins == \\'R\\':\\n                dx, dy = dy, -dx\\n        return (x, y) == (0, 0) or (dx, dy) != (0, 1)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        x, y, dx, dy = 0, 0, 0, 1\\n        for ins in instructions:\\n            if ins == \\'G\\':\\n                x, y = x + dx, y + dy\\n            elif ins == \\'L\\':\\n                dx, dy = -dy, dx\\n            elif ins == \\'R\\':\\n                dx, dy = dy, -dx\\n        return (x, y) == (0, 0) or (dx, dy) != (0, 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447938,
                "title": "swift-solution-beats-100",
                "content": "\\n```\\nclass Solution {\\n    func isRobotBounded(_ instructions: String) -> Bool {\\n    \\n        let potentialMovements = [[0, 1], [1, 0], [0, -1], [-1, 0]]\\n        var directionIndex = 0\\n        var currX = 0, currY = 0\\n        \\n        for instruction in instructions {\\n            switch instruction {\\n            case \"L\":\\n                directionIndex = (directionIndex + 3) % 4\\n            case \"R\":\\n                directionIndex = (directionIndex + 1) % 4\\n            default:\\n                currX += potentialMovements[directionIndex][0]\\n                currY += potentialMovements[directionIndex][1]\\n            }\\n        }\\n\\n        return directionIndex != 0 || (currX == 0 && currY == 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isRobotBounded(_ instructions: String) -> Bool {\\n    \\n        let potentialMovements = [[0, 1], [1, 0], [0, -1], [-1, 0]]\\n        var directionIndex = 0\\n        var currX = 0, currY = 0\\n        \\n        for instruction in instructions {\\n            switch instruction {\\n            case \"L\":\\n                directionIndex = (directionIndex + 3) % 4\\n            case \"R\":\\n                directionIndex = (directionIndex + 1) % 4\\n            default:\\n                currX += potentialMovements[directionIndex][0]\\n                currY += potentialMovements[directionIndex][1]\\n            }\\n        }\\n\\n        return directionIndex != 0 || (currX == 0 && currY == 0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207056,
                "title": "simple-c-solution-with-comments",
                "content": "Comment your doubts. Please **upvote** if you found this helpful :)\\n```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        unordered_map<int,int>mp; //to store distance travelled in each direction\\n        \\n        int direc = 0; //inititally facing north direction\\n        \\n    //          north\\n    //            0 \\n    //    west 1     3 east\\n    //            2  \\n    //          south  \\n        \\n        for(auto it: instructions){\\n            if(it == \\'L\\') direc++;\\n            else if(it == \\'R\\') direc--;\\n            else{\\n                mp[direc]++; \\n            }\\n            if(direc < 0){\\n                direc = (4+direc)%4;\\n            }\\n            else{\\n                direc = direc%4;\\n            }\\n        }\\n        \\n        //0,2 distance travelled vertically. 1,3 distance travelled horizontally. \\n        if((mp[0]==mp[2] && mp[1]==mp[3]) || direc!=0) return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        unordered_map<int,int>mp; //to store distance travelled in each direction\\n        \\n        int direc = 0; //inititally facing north direction\\n        \\n    //          north\\n    //            0 \\n    //    west 1     3 east\\n    //            2  \\n    //          south  \\n        \\n        for(auto it: instructions){\\n            if(it == \\'L\\') direc++;\\n            else if(it == \\'R\\') direc--;\\n            else{\\n                mp[direc]++; \\n            }\\n            if(direc < 0){\\n                direc = (4+direc)%4;\\n            }\\n            else{\\n                direc = direc%4;\\n            }\\n        }\\n        \\n        //0,2 distance travelled vertically. 1,3 distance travelled horizontally. \\n        if((mp[0]==mp[2] && mp[1]==mp[3]) || direc!=0) return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051872,
                "title": "kotlin-repeat-4-times",
                "content": "# Intuition\\nJust execute 4 times and check if you at [0, 0] position again\\n\\n# Code\\n```\\nclass Solution {\\n    fun isRobotBounded(s: String): Boolean {\\n        var r = 0\\n        var c = 0\\n        var d = 0\\n        for (i in 0 until 4) {\\n            for (ch in s) {\\n                when (ch) {\\n                    \\'G\\' -> {\\n                        when (d) {\\n                            0 -> r++\\n                            1 -> c++\\n                            2 -> r--\\n                            else -> c--\\n                        }\\n                    }\\n                    \\'L\\' -> {\\n                        d--\\n                        if (d == -1) d = 3\\n                    }\\n                    else -> {\\n                        d++\\n                        if (d == 4) d = 0\\n                    }\\n                }\\n            }\\n        }\\n\\n        return r == 0 && c == 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun isRobotBounded(s: String): Boolean {\\n        var r = 0\\n        var c = 0\\n        var d = 0\\n        for (i in 0 until 4) {\\n            for (ch in s) {\\n                when (ch) {\\n                    \\'G\\' -> {\\n                        when (d) {\\n                            0 -> r++\\n                            1 -> c++\\n                            2 -> r--\\n                            else -> c--\\n                        }\\n                    }\\n                    \\'L\\' -> {\\n                        d--\\n                        if (d == -1) d = 3\\n                    }\\n                    else -> {\\n                        d++\\n                        if (d == 4) d = 0\\n                    }\\n                }\\n            }\\n        }\\n\\n        return r == 0 && c == 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786332,
                "title": "simple-c-solution-using-switch",
                "content": "try to perform the operations, and after that see if we reach (0, 0) or not.\\nIf we reach the origin then problem is solved and we will give true.\\nBut if not, then we will see where robot is currently facing, if we face north this implies we will keep moving away from origin hence return false, otherwise return true.\\n```\\n#define f first\\n#define s second\\n\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        vector<pair<pair<int,int>, char>> pos;\\n        pos.push_back({{0,0}, \\'N\\'});\\n        unordered_map<char,pair<int,int>> dirs={\\n            {\\'N\\', {0, 1}},\\n            {\\'S\\', {0, -1}},\\n            {\\'E\\', {1, 0}},\\n            {\\'W\\', {-1, 0}}\\n        };\\n        for(char c:instructions)\\n        {\\n            switch(c)\\n            {\\n                case \\'G\\':{\\n                    auto v = pos.back();\\n                    int x = v.f.f;\\n                    int y = v.f.s;\\n                    char d = v.s;\\n                    int nx = dirs[d].f+x;\\n                    int ny = dirs[d].s+y;\\n                    pos.push_back({{nx, ny}, d});\\n                    break;\\n                }\\n                case \\'L\\':{\\n                    auto v = pos.back();\\n                    int x = v.f.f;\\n                    int y = v.f.s;\\n                    char d = v.s;\\n                    if(d==\\'N\\') d = \\'W\\';\\n                    else if(d==\\'W\\') d = \\'S\\';\\n                    else if(d==\\'S\\') d = \\'E\\';\\n                    else if(d==\\'E\\') d = \\'N\\';\\n                    pos.push_back({{x, y}, d});\\n                    break;\\n                }  \\n                case \\'R\\':{\\n                    auto v = pos.back();\\n                    int x = v.f.f;\\n                    int y = v.f.s;\\n                    char d = v.s;\\n                    if(d==\\'N\\') d = \\'E\\';\\n                    else if(d==\\'E\\') d = \\'S\\';\\n                    else if(d==\\'S\\') d = \\'W\\';\\n                    else if(d==\\'W\\') d = \\'N\\';\\n                    pos.push_back({{x, y}, d});\\n                    break;\\n                }\\n            }\\n        }\\n        auto v = pos.back();\\n        int x = v.f.f;\\n        int y = v.f.s;\\n        char d = v.s;\\n        if(x==0&&y==0) return true;\\n        return d!=\\'N\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "Geometry",
                    "Simulation"
                ],
                "code": "```\\n#define f first\\n#define s second\\n\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        vector<pair<pair<int,int>, char>> pos;\\n        pos.push_back({{0,0}, \\'N\\'});\\n        unordered_map<char,pair<int,int>> dirs={\\n            {\\'N\\', {0, 1}},\\n            {\\'S\\', {0, -1}},\\n            {\\'E\\', {1, 0}},\\n            {\\'W\\', {-1, 0}}\\n        };\\n        for(char c:instructions)\\n        {\\n            switch(c)\\n            {\\n                case \\'G\\':{\\n                    auto v = pos.back();\\n                    int x = v.f.f;\\n                    int y = v.f.s;\\n                    char d = v.s;\\n                    int nx = dirs[d].f+x;\\n                    int ny = dirs[d].s+y;\\n                    pos.push_back({{nx, ny}, d});\\n                    break;\\n                }\\n                case \\'L\\':{\\n                    auto v = pos.back();\\n                    int x = v.f.f;\\n                    int y = v.f.s;\\n                    char d = v.s;\\n                    if(d==\\'N\\') d = \\'W\\';\\n                    else if(d==\\'W\\') d = \\'S\\';\\n                    else if(d==\\'S\\') d = \\'E\\';\\n                    else if(d==\\'E\\') d = \\'N\\';\\n                    pos.push_back({{x, y}, d});\\n                    break;\\n                }  \\n                case \\'R\\':{\\n                    auto v = pos.back();\\n                    int x = v.f.f;\\n                    int y = v.f.s;\\n                    char d = v.s;\\n                    if(d==\\'N\\') d = \\'E\\';\\n                    else if(d==\\'E\\') d = \\'S\\';\\n                    else if(d==\\'S\\') d = \\'W\\';\\n                    else if(d==\\'W\\') d = \\'N\\';\\n                    pos.push_back({{x, y}, d});\\n                    break;\\n                }\\n            }\\n        }\\n        auto v = pos.back();\\n        int x = v.f.f;\\n        int y = v.f.s;\\n        char d = v.s;\\n        if(x==0&&y==0) return true;\\n        return d!=\\'N\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503217,
                "title": "c-logic-based-explained-intuititons",
                "content": "```\\n#define pp pair<int , int>\\n\\nclass Solution {\\npublic:\\n    \\n    // Intuition -> after having the full iteration once of given path \\n    \\n    // If directions remains same as original & it did not reached origin in between \\n    \\n    // Then its not going to be in the cycle \\n    \\n    bool isRobotBounded(string s) {\\n        \\n        // We will store the possible direction after rotation \\n        \\n        // Rotating North (\\'L\\' , \\'R\\') , West , South , East\\n        \\n        // We will also store the value of each directions \\'G\\' moving\\n        \\n        vector<pp> curr_path={{0 , 1} , {-1 , 0} , {0 , -1} , {1 , 0}};\\n        \\n                            // North , west     , south     , east\\n        \\n        vector<pp> rotation={ {1,3} , {2,0} , {3 , 1} , {0,2}};\\n          // First rotating north , west , south , east \\n        \\n          // after rotation pair of values , first represents \\'L\\' Rotation , second\\n          // \\'R\\' rotation of direction\\n        \\n        // Rotation stores the index of the dirns which is currently after rotations\\n         \\n        // pair of value , in which first represents for Rotating left , Rotating right\\n        int x=0 , y=0;\\n        int dirn=0;\\n        \\n        // dirn = 0 (North ) , 1 (west) , 2 (south) , 3 (east)\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'G\\')\\n            {\\n                x+=curr_path[dirn].first;\\n                y+=curr_path[dirn].second;\\n            }\\n            else\\n            {\\n                if(s[i]==\\'L\\')\\n                dirn=rotation[dirn].first;\\n                else\\n                    dirn=rotation[dirn].second;\\n            }\\n            \\n            // if here in betwwen origin comes , we will not guarantee\\n            \\n            // it will be moving in cycle as path changes differnetly\\n            \\n            // after it .\\n\\n        }\\n       \\n        if((x==0 && y==0) || dirn!=0) // finally dirn has changed\\n        {\\n            return true;\\n        }\\n        \\n        // after one full iteration , direction  changed or it is at origin\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define pp pair<int , int>\\n\\nclass Solution {\\npublic:\\n    \\n    // Intuition -> after having the full iteration once of given path \\n    \\n    // If directions remains same as original & it did not reached origin in between \\n    \\n    // Then its not going to be in the cycle \\n    \\n    bool isRobotBounded(string s) {\\n        \\n        // We will store the possible direction after rotation \\n        \\n        // Rotating North (\\'L\\' , \\'R\\') , West , South , East\\n        \\n        // We will also store the value of each directions \\'G\\' moving\\n        \\n        vector<pp> curr_path={{0 , 1} , {-1 , 0} , {0 , -1} , {1 , 0}};\\n        \\n                            // North , west     , south     , east\\n        \\n        vector<pp> rotation={ {1,3} , {2,0} , {3 , 1} , {0,2}};\\n          // First rotating north , west , south , east \\n        \\n          // after rotation pair of values , first represents \\'L\\' Rotation , second\\n          // \\'R\\' rotation of direction\\n        \\n        // Rotation stores the index of the dirns which is currently after rotations\\n         \\n        // pair of value , in which first represents for Rotating left , Rotating right\\n        int x=0 , y=0;\\n        int dirn=0;\\n        \\n        // dirn = 0 (North ) , 1 (west) , 2 (south) , 3 (east)\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'G\\')\\n            {\\n                x+=curr_path[dirn].first;\\n                y+=curr_path[dirn].second;\\n            }\\n            else\\n            {\\n                if(s[i]==\\'L\\')\\n                dirn=rotation[dirn].first;\\n                else\\n                    dirn=rotation[dirn].second;\\n            }\\n            \\n            // if here in betwwen origin comes , we will not guarantee\\n            \\n            // it will be moving in cycle as path changes differnetly\\n            \\n            // after it .\\n\\n        }\\n       \\n        if((x==0 && y==0) || dirn!=0) // finally dirn has changed\\n        {\\n            return true;\\n        }\\n        \\n        // after one full iteration , direction  changed or it is at origin\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423262,
                "title": "python-explained",
                "content": "The robot will be trapped in a circle if and only if after completing the instructions it did not finish at the point where it began, or it\\'s general orientation had changed from the orientation it had when it began (which is North).\\n\\nIt\\'s enough to check if the robot had finished taking any steps in North-South, or East-West (without tracking the position because it doesn\\'t matter where it ended), and also to check if the orientation had changed from North.\\n\\n\"\"\"\\t\\t\\n\\n        def isRobotBounded(self, instructions):\\n                direction_dict = {\\'R\\': 1, \\'L\\': -1}\\n                orientation = 0\\n                ns = 0  #represent movement on North-South axis\\n                ew = 0  #represent  movement on East-West axis\\n\\n                for inst in instructions:\\n                    if inst == \\'G\\':\\n                        if orientation == 0:  # if orientation is towards North\\n                            ns += 1\\n                        elif orientation == 1:  # East\\n                            ew += 1\\n                        elif orientation == 2:  # South\\n                            ns -= 1\\n                        elif orientation == 3:  # West\\n                            ew -= 1\\n                    else:  # otherwise, instructions are L or R, meaning orientation needs to be updated. North, East, South, West are cyclic (you get from West to North), so modulo 4 will always keep us within these four\\n                        orientation = (orientation + direction_dict[inst]) % 4\\n\\n                if ns == 0 and ew == 0:  # Robot had stayed/returned to beginning point\\n                    return True\\n                if orientation != 0:  # orientation isn\\'t pointed at North\\n                    return True\\n                return False\\n\"\"\"",
                "solutionTags": [
                    "Python"
                ],
                "code": "The robot will be trapped in a circle if and only if after completing the instructions it did not finish at the point where it began, or it\\'s general orientation had changed from the orientation it had when it began (which is North).\\n\\nIt\\'s enough to check if the robot had finished taking any steps in North-South, or East-West (without tracking the position because it doesn\\'t matter where it ended), and also to check if the orientation had changed from North.\\n\\n\"\"\"\\t\\t\\n\\n        def isRobotBounded(self, instructions):\\n                direction_dict = {\\'R\\': 1, \\'L\\': -1}\\n                orientation = 0\\n                ns = 0  #represent movement on North-South axis\\n                ew = 0  #represent  movement on East-West axis\\n\\n                for inst in instructions:\\n                    if inst == \\'G\\':\\n                        if orientation == 0:  # if orientation is towards North\\n                            ns += 1\\n                        elif orientation == 1:  # East\\n                            ew += 1\\n                        elif orientation == 2:  # South\\n                            ns -= 1\\n                        elif orientation == 3:  # West\\n                            ew -= 1\\n                    else:  # otherwise, instructions are L or R, meaning orientation needs to be updated. North, East, South, West are cyclic (you get from West to North), so modulo 4 will always keep us within these four\\n                        orientation = (orientation + direction_dict[inst]) % 4\\n\\n                if ns == 0 and ew == 0:  # Robot had stayed/returned to beginning point\\n                    return True\\n                if orientation != 0:  # orientation isn\\'t pointed at North\\n                    return True\\n                return False\\n\"\"\"",
                "codeTag": "Python3"
            },
            {
                "id": 2370492,
                "title": "easy-c-solution-proper-variable-naming",
                "content": "````\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n       \\n        char direction=\\'N\\';\\n        int x=0,y=0;\\n        int n=instructions.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(instructions[i]==\\'G\\')\\n            {\\n                if(direction==\\'N\\')\\n                {\\n                    y++;\\n                }\\n                if(direction==\\'S\\')\\n                {\\n                    y--;\\n                }\\n                if(direction==\\'E\\')\\n                {\\n                    x++;\\n                }\\n                if(direction==\\'W\\')\\n                {\\n                    x--;\\n                }\\n            }\\n            else if(instructions[i]==\\'L\\')\\n            {\\n                if(direction==\\'N\\')\\n                {\\n                    direction=\\'W\\';\\n                }\\n                else if (direction==\\'W\\')\\n                {\\n                    direction=\\'S\\';\\n                }\\n                else if(direction==\\'S\\')\\n                {\\n                    direction=\\'E\\';\\n                }\\n                else if(direction==\\'E\\')\\n                {\\n                    direction=\\'N\\';\\n                }\\n                    \\n            }\\n            else if(instructions[i]==\\'R\\')\\n            {\\n                if(direction==\\'N\\')\\n                {\\n                    direction=\\'E\\';\\n                }\\n                else if (direction==\\'E\\')\\n                {\\n                    direction=\\'S\\';\\n                }\\n                else if(direction==\\'S\\')\\n                {\\n                    direction=\\'W\\';\\n                }\\n                else if(direction==\\'W\\')\\n                {\\n                    direction=\\'N\\';\\n                }\\n            }\\n        }\\n        \\n        if((x==0 && y==0) ||(direction!=\\'N\\')) return true;\\n        \\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n       \\n        char direction=\\'N\\';\\n        int x=0,y=0;\\n        int n=instructions.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(instructions[i]==\\'G\\')\\n            {\\n                if(direction==\\'N\\')\\n                {\\n                    y++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2336015,
                "title": "best-proof-of-correctness-you-will-ever-see-for-this-problem",
                "content": "Once we find the initial vector, v\\nWe can find all 4 direction of movement available to us\\n\\nTo be contained in a circle, our path should form a polygon.\\nTo form a polygon of degree N, you need to have at-least N directions of movement.\\n\\nSince the direction of movement available to us are 4, we can cannot form any polygon with degree > 4.\\nSo if a path doesn\\'t encounter 0,0 before 4 edges are formed. It will never become bounded.",
                "solutionTags": [
                    "Math"
                ],
                "code": "Once we find the initial vector, v\\nWe can find all 4 direction of movement available to us\\n\\nTo be contained in a circle, our path should form a polygon.\\nTo form a polygon of degree N, you need to have at-least N directions of movement.\\n\\nSince the direction of movement available to us are 4, we can cannot form any polygon with degree > 4.\\nSo if a path doesn\\'t encounter 0,0 before 4 edges are formed. It will never become bounded.",
                "codeTag": "Unknown"
            },
            {
                "id": 2199554,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        \\n        def move(s,direction):\\n            if direction==\"N\":\\n                s[1]+=1\\n            elif direction==\"E\":\\n                s[0]+=1\\n            elif direction==\"W\":\\n                s[0]-=1\\n            else:\\n                s[1]-=1\\n                \\n        def get_directionl(curr_dir):\\n            if curr_dir==\"N\":\\n                return \"W\"\\n            elif curr_dir==\"E\":\\n                return \"N\"\\n            elif curr_dir==\"W\":\\n                return \"S\"\\n            else:\\n                return \"E\"\\n        \\n        def get_directionr(curr_dir):\\n            if curr_dir==\"N\":\\n                return \"E\"\\n            elif curr_dir==\"E\":\\n                return \"S\"\\n            elif curr_dir==\"W\":\\n                return \"N\"\\n            else:\\n                return \"W\"\\n        \\n        s = [0,0]\\n        d  = \"N\"\\n        for i in instructions:\\n            if i==\"G\":\\n                move(s,d)\\n                \\n            elif i==\"L\":\\n                d = get_directionl(d)\\n            \\n            else:\\n                d = get_directionr(d)\\n        \\n        return (s[0]==0 and s[1]==0) or d!=\"N\"\\n                \\n            \\n                \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRobotBounded(self, instructions: str) -> bool:\\n        \\n        def move(s,direction):\\n            if direction==\"N\":\\n                s[1]+=1\\n            elif direction==\"E\":\\n                s[0]+=1\\n            elif direction==\"W\":\\n                s[0]-=1\\n            else:\\n                s[1]-=1\\n                \\n        def get_directionl(curr_dir):\\n            if curr_dir==\"N\":\\n                return \"W\"\\n            elif curr_dir==\"E\":\\n                return \"N\"\\n            elif curr_dir==\"W\":\\n                return \"S\"\\n            else:\\n                return \"E\"\\n        \\n        def get_directionr(curr_dir):\\n            if curr_dir==\"N\":\\n                return \"E\"\\n            elif curr_dir==\"E\":\\n                return \"S\"\\n            elif curr_dir==\"W\":\\n                return \"N\"\\n            else:\\n                return \"W\"\\n        \\n        s = [0,0]\\n        d  = \"N\"\\n        for i in instructions:\\n            if i==\"G\":\\n                move(s,d)\\n                \\n            elif i==\"L\":\\n                d = get_directionl(d)\\n            \\n            else:\\n                d = get_directionr(d)\\n        \\n        return (s[0]==0 and s[1]==0) or d!=\"N\"\\n                \\n            \\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 2166095,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        pair<int, int> end;\\n        end = {0, 0};\\n        char currDir = \\'N\\';\\n        \\n        for(auto each : instructions) {\\n            switch(each) {\\n                case \\'G\\':\\n                    switch(currDir) {\\n                        case \\'N\\':\\n                            end.second++;\\n                            break;\\n                        case \\'S\\':\\n                            end.second--;\\n                            break;\\n                        case \\'E\\':\\n                            end.first++;\\n                            break;\\n                        case \\'W\\':\\n                            end.first--;\\n                            break;\\n                    }\\n                    break;\\n                case \\'L\\':\\n                  switch(currDir) {\\n                        case \\'N\\':\\n                            currDir = \\'W\\';\\n                            break;\\n                        case \\'S\\':\\n                            currDir = \\'E\\';\\n                            break;\\n                        case \\'E\\':\\n                            currDir = \\'N\\';\\n                            break;\\n                        case \\'W\\':\\n                            currDir = \\'S\\';\\n                            break;\\n                    }\\n                    break;  \\n                case \\'R\\':\\n                  switch(currDir) {\\n                        case \\'N\\':\\n                            currDir = \\'E\\';\\n                            break;\\n                        case \\'S\\':\\n                            currDir = \\'W\\';\\n                            break;\\n                        case \\'E\\':\\n                            currDir = \\'S\\';\\n                            break;\\n                        case \\'W\\':\\n                            currDir = \\'N\\';\\n                            break;\\n                    }\\n                    break;\\n            }\\n        }\\n        \\n        return ((end.first == 0 && end.second == 0) || currDir != \\'N\\') ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRobotBounded(string instructions) {\\n        pair<int, int> end;\\n        end = {0, 0};\\n        char currDir = \\'N\\';\\n        \\n        for(auto each : instructions) {\\n            switch(each) {\\n                case \\'G\\':\\n                    switch(currDir) {\\n                        case \\'N\\':\\n                            end.second++;\\n                            break;\\n                        case \\'S\\':\\n                            end.second--;\\n                            break;\\n                        case \\'E\\':\\n                            end.first++;\\n                            break;\\n                        case \\'W\\':\\n                            end.first--;\\n                            break;\\n                    }\\n                    break;\\n                case \\'L\\':\\n                  switch(currDir) {\\n                        case \\'N\\':\\n                            currDir = \\'W\\';\\n                            break;\\n                        case \\'S\\':\\n                            currDir = \\'E\\';\\n                            break;\\n                        case \\'E\\':\\n                            currDir = \\'N\\';\\n                            break;\\n                        case \\'W\\':\\n                            currDir = \\'S\\';\\n                            break;\\n                    }\\n                    break;  \\n                case \\'R\\':\\n                  switch(currDir) {\\n                        case \\'N\\':\\n                            currDir = \\'E\\';\\n                            break;\\n                        case \\'S\\':\\n                            currDir = \\'W\\';\\n                            break;\\n                        case \\'E\\':\\n                            currDir = \\'S\\';\\n                            break;\\n                        case \\'W\\':\\n                            currDir = \\'N\\';\\n                            break;\\n                    }\\n                    break;\\n            }\\n        }\\n        \\n        return ((end.first == 0 && end.second == 0) || currDir != \\'N\\') ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565301,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1564601,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1568654,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1565157,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1566412,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1574383,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 2005470,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1574384,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1575488,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1570399,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1565301,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1564601,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1568654,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1565157,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1566412,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1574383,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 2005470,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1574384,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1575488,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            },
            {
                "id": 1570399,
                "content": [
                    {
                        "username": "boo-m",
                        "content": "Given that `The robot performs the instructions given in order, and repeats them forever.`\\n\\n**What does Bounded in circle mean?**\\nIt means at some point in time the robot will be back to the point where it started (origin).\\n\\n**How to solve this problem?**\\nEither If after first iteration the robot is back to the starting point or it is facing any other direction other than north. It will at some point be back to the starting point.\\n\\nAfter first iteration, If robot is not at start position and is facing North, it would mean the robot will drift away from the origin with each iteration.\\n\\nCheck out some sample instructions and the route of robot after few iterations, for better understanding\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/c0a94239-43e0-4275-89f3-89a5e01e59bb_1600335884.9367726.png)\\n"
                    },
                    {
                        "username": "alenny",
                        "content": "This problem is easy. Just return true if the final position does not change or the facing direction is different from the beginning.\\nHowever, this problem is tricky. And I don\\'t think a tricky problem can test or improve a developer\\'s programming skill. \\nI find more and more tricky problems recently. I feel it is not a good trend if LeetCode goes deeper into it."
                    },
                    {
                        "username": "StrongHire",
                        "content": "The key observation is that the trajectory of the path does not matter but **the direction after one run of the instruction does!** \\n\\nFirst and for most, when we look at this problem, the simpliest thing we can do is to run the instruction once and see if we can find out any pattern(picture below after one instruction). The easiest case is if we return to the origin after one run, then it will be a circle. \\n![image](https://assets.leetcode.com/users/images/5b662d3e-1bec-4b19-8f3a-ce720c1cc272_1632516220.9481091.png)\\n\\nSecondly, if the robot ends with north direction after one run, we are certain that it will never form a circle(it just goes to the north further and further).\\n![image](https://assets.leetcode.com/users/images/9efe6c53-6ffc-4332-9082-aa340b25a7e6_1632516358.2065537.png)\\n\\nLastly, if the robot ends with other directions(either East, West, or South), it will still stay in the circle. Why? We can draw some examples to see this. (Note: **the trajectary of the instruction does not matter, the direction after each instruction run does.**)\\n![image](https://assets.leetcode.com/users/images/10104c7f-fd4c-482b-8539-408892f31afa_1632517596.9934626.png)\\n\\nIf the ending direction is East or West, it will need 4 runs to form a circle in order to return to the origin. And if ending direction is South, then it only takes 2 runs to go back to the origin(one run upward, then one more run downward).\\nNow, we can see that, the robot can always return to the origin as long as the ending direction is not north after one run. \\n\\nPlease give an upvote if you find this helpful. Thank you!\\n\\n"
                    },
                    {
                        "username": "Banra123",
                        "content": "I would just go through the mathematics behind this problem. The implementation part is easy if this is understood.\\nLet\\'s for the sake of argument assume that after performing all the instructions a person from point (x,y) reaches (x+a,y+b).  Now here the direction also matters.\\n4 cases are possible now:\\nThe final direction is :\\n Towards East- Now after performing the instructions again he would point towards south ,then west and finally towards east!. \\nCLAIM:  After performing the instrictions for 4 times he would point towards the same north and at the same position wherefrom he began.\\nPROOF: We assumed his current position is (x+a,y+b) and he is facing east. (He started from (x,y) facing towards NORTH). Now from here we can visualize a positive for a y while he started facing North  would here be a positive  for x and a positive for x is a negatie for y, so starting from (x+a,y+b) in East he ends up at (x+a+b,y+b-a), facing SOUTH. Now from here he exactly goes opposite to what he originally did when he started journey facing North, so in this case it\\'s negative for both, so he reaches at point (x+a+b-a,y+b-a-b), facing WEST. Now he would go exactly the oppposite he went while he completed one quarter of his journey while starting from (x+a,y+b) facing East, so he reaches (x+a+b-a-b,y+a+b-a-b) i.e. (x,y). \\n\\nThe same can be shown the other cases as well. It\\'s fairly easy if he reaches towards SOUTH afetr performing the instructions for once, i.e. let he reaches (x+a,y+b) facing SOUTH after 1 st time , and then reaches (x+a-a,y+b-b) i.e (x,y) towards EAST.\\n \\n Thus he reaches the same point wherefrom he started in each case if here reaches in a point facing EAST/ WEST/ SOUTH. \\n \\n CASE_2:  He reaches a point (x+a,y+b) facing the same North. So it\\'s fairly easy in guessing what would happen next, i.e. he will reache (x+a+a,y+b+b) and (x+a+a+a,y+b+b+b).....(x+na, y+nb) (after n times), so it (a or b if not equal to 0 then it would be go on limitlessly.\\n Keeping this idea in mind it\\'s fairly easy to code it out!!."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/robot-bounded-in-circle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "HippoSan",
                        "content": "\"GLGLGGLGL\"\\nshouldn\\'t  this case be TRUE ?\\nthe first G in the second repeat will lead it back to the start.\\nCant wrap my head around this can someone please explain?\\nThank you soooo much ><\\n\\n\\n\\n| - | <- **start first G of first repeat\\n| _ | <- [first G of second repeat]   => isnt this a circle? \\n  **^[End of first repeat facing north]"
                    },
                    {
                        "username": "Kalp05",
                        "content": "if you continue to execute instructions after this then you robot will go left(west) and move 1 unit. but in first iteration the robot moves 1 unit north. meaning it will not follow the same path as it followed during the first iteration.\\nSimply dry run two more instructions(characters in string) and u will find that robot is not FLLOWING same path "
                    },
                    {
                        "username": "shashant",
                        "content": "It was quite an interesting problem to solve requiring intuition and geometry maths. One simple intution is that the path formed by following a set of instructions n times results in figure which is a regular n sized polygon if this set of commands is cyclic. \nThis is because distance between any two consecutive point vectors and and angle formed between any three consecutive point should be uniform as it is generated by a command which does not care about initial position\nInternal angle between any three consecutive points  =  (n-2)/n * pi\nWe take any three consecutive points generated by the command lets say starting at (0,0). Then we can get value of n from the angle formed. If this n is a whole number,then this is a cyclic command"
                    },
                    {
                        "username": "rajpatel62506",
                        "content": "\\nMany have posted solution that if \\n1)it reaches at initial position after 1st loop\\n2)final direction is not initial direction then cycle exists.\\n\\n\\nlet\\'s say initially it at (0,0) now 1st  case is easy.let\\'s consider 2nd;\\ninitial position (0,0) direction north and as final direction can be left of initial or right in this case,let\\'s\\nconsider final direction after each cycle is left of initial direction.\\n1st loop)let\\'s it reaches at (x,y) and as final direction is left of initial,final direction is west.\\n2nd loop) for north initial direction change along x-direction was x and in y-axis was y,for west direction change in x-direction will be -y and change in y direction will be x\\nso after 2nd loop final position is (x-y,y+x)\\n3rd loop)similarly we can final position (x-y-x,y+x-y)\\n4th loop)final position (x-y-x+y,y+x-y-x)i.e(0,0)"
                    },
                    {
                        "username": "letMeLC",
                        "content": "Hello,  \\n\\nI\\'m unable to understand how a different final direction will result in a circle. Also, I don\\'t understand how repeating the instructions 4 times is enough? Can someone please explain with some examples?"
                    },
                    {
                        "username": "vehshee",
                        "content": "I am not able to understand the simple logic about \"north\" why do we need to make sure it doesnt face north?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Nodes in the Sub-Tree With the Same Label",
        "question_content": "<p>You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code> and exactly <code>n - 1</code> <code>edges</code>. The <strong>root</strong> of the tree is the node <code>0</code>, and each node of the tree has <strong>a label</strong> which is a lower-case character given in the string <code>labels</code> (i.e. The node with the number <code>i</code> has the label <code>labels[i]</code>).</p>\n\n<p>The <code>edges</code> array is given on the form <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>, which means there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree.</p>\n\n<p>Return <em>an array of size <code>n</code></em> where <code>ans[i]</code> is the number of nodes in the subtree of the <code>i<sup>th</sup></code> node which have the same label as node <code>i</code>.</p>\n\n<p>A subtree of a tree <code>T</code> is the tree consisting of a node in <code>T</code> and all of its descendant nodes.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/01/q3e1.jpg\" style=\"width: 400px; height: 291px;\" />\n<pre>\n<strong>Input:</strong> n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = &quot;abaedcd&quot;\n<strong>Output:</strong> [2,1,1,1,1,1,1]\n<strong>Explanation:</strong> Node 0 has label &#39;a&#39; and its sub-tree has node 2 with label &#39;a&#39; as well, thus the answer is 2. Notice that any node is part of its sub-tree.\nNode 1 has a label &#39;b&#39;. The sub-tree of node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have different labels than node 1, the answer is just 1 (the node itself).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/01/q3e2.jpg\" style=\"width: 300px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> n = 4, edges = [[0,1],[1,2],[0,3]], labels = &quot;bbbb&quot;\n<strong>Output:</strong> [4,2,1,1]\n<strong>Explanation:</strong> The sub-tree of node 2 contains only node 2, so the answer is 1.\nThe sub-tree of node 3 contains only node 3, so the answer is 1.\nThe sub-tree of node 1 contains nodes 1 and 2, both have label &#39;b&#39;, thus the answer is 2.\nThe sub-tree of node 0 contains nodes 0, 1, 2 and 3, all with label &#39;b&#39;, thus the answer is 4.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/01/q3e3.jpg\" style=\"width: 300px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = &quot;aabab&quot;\n<strong>Output:</strong> [3,2,1,1,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>labels.length == n</code></li>\n\t<li><code>labels</code> is consisting of only of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 743133,
                "title": "java-python-3-dfs-w-brief-explanation-and-analysis",
                "content": "The problem does NOT specify it is binary tree or not, so I treat it as a general tree.\\n1. Build the graph of the tree;\\n2. Use a HashSet `seen` to avoid duplicate visits, `ans` is the result array, and `cnt[i]` is the total number of corresponding char;\\n3. Use DFS to traverse the tree and count each label and sum it in the return array; At the same time update the result: `ans` array.\\n\\n```java\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        Map<Integer, List<Integer>> g = new HashMap<>();\\n        for (int[] e : edges) {\\n            g.computeIfAbsent(e[0], l -> new ArrayList<>()).add(e[1]);\\n            g.computeIfAbsent(e[1], l -> new ArrayList<>()).add(e[0]);\\n        }\\n        int[] ans = new int[n];\\n        Set<Integer> seen = new HashSet<>();\\n        dfs(g, 0, labels, ans, seen);\\n        return ans;\\n    }\\n    private int[] dfs(Map<Integer, List<Integer>> g, int node, String labels, int[] ans, Set<Integer> seen) {\\n        int[] cnt = new int[26];\\n        if (seen.add(node)) {\\n            char c = labels.charAt(node);\\n            for (int child : g.getOrDefault(node, Collections.emptyList())) {\\n                int[] sub = dfs(g, child, labels, ans, seen);\\n                for (int i = 0; i < 26; ++i) {\\n                    cnt[i] += sub[i];\\n                }\\n            }\\n            ++cnt[c - \\'a\\'];\\n            ans[node] = cnt[c - \\'a\\'];\\n        }\\n        return cnt;\\n    }\\n```\\n```python\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        \\n        def dfs(node: int):\\n            cnt = Counter()\\n            if node not in seen:\\n                cnt[labels[node]] += 1 \\n                seen.add(node)\\n                for child in g.get(node, []):\\n                    cnt += dfs(child)\\n                ans[node] = cnt[labels[node]]\\n            return cnt\\n        \\n        g, ans, seen = defaultdict(list), [0] * n, set()\\n        for a, b in edges:\\n            g[a] += [b]\\n            g[b] += [a]\\n        dfs(0)\\n        return ans\\n```\\n\\n----\\nSince it is a tree, we can avoid duplicate visiting by checking if  its neighbor is its parent; Therefore, the following code is simplified by removal of set `seen`. - credit to **@jaazzz**.\\n```java\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        Map<Integer, List<Integer>> g = new HashMap<>();\\n        for (int[] e : edges) {\\n            g.computeIfAbsent(e[0], l -> new ArrayList<>()).add(e[1]);\\n            g.computeIfAbsent(e[1], l -> new ArrayList<>()).add(e[0]);\\n        }\\n        int[] ans = new int[n];\\n        dfs(g, 0, -1, labels, ans);\\n        return ans;\\n    }\\n    private int[] dfs(Map<Integer, List<Integer>> g, int node, int parent, String labels, int[] ans) {\\n        int[] cnt = new int[26];\\n        char c = labels.charAt(node);\\n        for (int child : g.getOrDefault(node, Collections.emptyList())) {\\n            if (child != parent) {\\n                int[] sub = dfs(g, child, node, labels, ans);\\n                for (int i = 0; i < 26; ++i) {\\n                    cnt[i] += sub[i];\\n                }\\n            }\\n        }\\n        ++cnt[c - \\'a\\'];\\n        ans[node] = cnt[c - \\'a\\'];\\n        return cnt;\\n    }\\n```\\n```python\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        \\n        def dfs(node: int, parent: int):\\n            cnt = Counter(labels[node])\\n            for child in g.get(node, []):\\n                if child != parent:\\n                    cnt += dfs(child, node)\\n            ans[node] = cnt[labels[node]]\\n            return cnt\\n        \\n        g, ans = defaultdict(list), [0] * n\\n        for a, b in edges:\\n            g[a] += [b]\\n            g[b] += [a]\\n        dfs(0, -1)\\n        return ans    \\n```\\n**Analysis:**\\n\\nTime & space: `O(n)`.\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```java\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        Map<Integer, List<Integer>> g = new HashMap<>();\\n        for (int[] e : edges) {\\n            g.computeIfAbsent(e[0], l -> new ArrayList<>()).add(e[1]);\\n            g.computeIfAbsent(e[1], l -> new ArrayList<>()).add(e[0]);\\n        }\\n        int[] ans = new int[n];\\n        Set<Integer> seen = new HashSet<>();\\n        dfs(g, 0, labels, ans, seen);\\n        return ans;\\n    }\\n    private int[] dfs(Map<Integer, List<Integer>> g, int node, String labels, int[] ans, Set<Integer> seen) {\\n        int[] cnt = new int[26];\\n        if (seen.add(node)) {\\n            char c = labels.charAt(node);\\n            for (int child : g.getOrDefault(node, Collections.emptyList())) {\\n                int[] sub = dfs(g, child, labels, ans, seen);\\n                for (int i = 0; i < 26; ++i) {\\n                    cnt[i] += sub[i];\\n                }\\n            }\\n            ++cnt[c - \\'a\\'];\\n            ans[node] = cnt[c - \\'a\\'];\\n        }\\n        return cnt;\\n    }\\n```\n```python\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        \\n        def dfs(node: int):\\n            cnt = Counter()\\n            if node not in seen:\\n                cnt[labels[node]] += 1 \\n                seen.add(node)\\n                for child in g.get(node, []):\\n                    cnt += dfs(child)\\n                ans[node] = cnt[labels[node]]\\n            return cnt\\n        \\n        g, ans, seen = defaultdict(list), [0] * n, set()\\n        for a, b in edges:\\n            g[a] += [b]\\n            g[b] += [a]\\n        dfs(0)\\n        return ans\\n```\n```java\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        Map<Integer, List<Integer>> g = new HashMap<>();\\n        for (int[] e : edges) {\\n            g.computeIfAbsent(e[0], l -> new ArrayList<>()).add(e[1]);\\n            g.computeIfAbsent(e[1], l -> new ArrayList<>()).add(e[0]);\\n        }\\n        int[] ans = new int[n];\\n        dfs(g, 0, -1, labels, ans);\\n        return ans;\\n    }\\n    private int[] dfs(Map<Integer, List<Integer>> g, int node, int parent, String labels, int[] ans) {\\n        int[] cnt = new int[26];\\n        char c = labels.charAt(node);\\n        for (int child : g.getOrDefault(node, Collections.emptyList())) {\\n            if (child != parent) {\\n                int[] sub = dfs(g, child, node, labels, ans);\\n                for (int i = 0; i < 26; ++i) {\\n                    cnt[i] += sub[i];\\n                }\\n            }\\n        }\\n        ++cnt[c - \\'a\\'];\\n        ans[node] = cnt[c - \\'a\\'];\\n        return cnt;\\n    }\\n```\n```python\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        \\n        def dfs(node: int, parent: int):\\n            cnt = Counter(labels[node])\\n            for child in g.get(node, []):\\n                if child != parent:\\n                    cnt += dfs(child, node)\\n            ans[node] = cnt[labels[node]]\\n            return cnt\\n        \\n        g, ans = defaultdict(list), [0] * n\\n        for a, b in edges:\\n            g[a] += [b]\\n            g[b] += [a]\\n        dfs(0, -1)\\n        return ans    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3037881,
                "title": "c-dfs-dp-beats-79-solution-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n  vector<int> fun(vector<vector<int>> &adj, string &labels, int i,vector<int>&result){\\n    vector<int> ans(26, 0);\\n    result[i] = 1;\\n    ans[labels[i] - \\'a\\'] = 1;\\n    \\n    for(int j = 0; j != adj[i].size(); j++)\\n      if(!result[adj[i][j]]){\\n        vector<int> tmp = fun(adj, labels,adj[i][j],result);\\n        for(int k = 0; k != 26; k++) ans[k] += tmp[k];\\n      }\\n    \\n    result[i] = ans[labels[i] - \\'a\\'];\\n    \\n    return ans;\\n  }\\n  \\n  vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n    vector<vector<int>> adj(n);\\n    vector<int> result(n,0);\\n    for(int i = 0; i != edges.size(); i++)\\n     {adj[edges[i][0]].push_back(edges[i][1]);\\n      adj[edges[i][1]].push_back(edges[i][0]);\\n     }\\n    \\n    fun(adj, labels, 0,result);\\n    return result;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> fun(vector<vector<int>> &adj, string &labels, int i,vector<int>&result){\\n    vector<int> ans(26, 0);\\n    result[i] = 1;\\n    ans[labels[i] - \\'a\\'] = 1;\\n    \\n    for(int j = 0; j != adj[i].size(); j++)\\n      if(!result[adj[i][j]]){\\n        vector<int> tmp = fun(adj, labels,adj[i][j],result);\\n        for(int k = 0; k != 26; k++) ans[k] += tmp[k];\\n      }\\n    \\n    result[i] = ans[labels[i] - \\'a\\'];\\n    \\n    return ans;\\n  }\\n  \\n  vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n    vector<vector<int>> adj(n);\\n    vector<int> result(n,0);\\n    for(int i = 0; i != edges.size(); i++)\\n     {adj[edges[i][0]].push_back(edges[i][1]);\\n      adj[edges[i][1]].push_back(edges[i][0]);\\n     }\\n    \\n    fun(adj, labels, 0,result);\\n    return result;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038104,
                "title": "python3-dfs-explained",
                "content": "**Code with no comments at the end, in case you don\\'t want to read the story but just want to compare mine with yours**\\n\\nThis problem is very simillar to yesterday\\'s daily challenge **[1443. Minimum Time to Collect All Apples in a Tree](https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/)**, and my solution for that is **[Here](https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/discuss/3033301/Python3-DFS-(Explained))**. The algorithm presented in this post is very similar to the other one.\\n\\n**Intuition**\\n\\n - One way or another we will have to construct the ```tree``` first, since the ```tree``` is undriected, we just add both directions. I\\'m using a hashmap to represent the ```tree```, where key represents a starting node, and value is a list representing the neighbor nodes of the key node.\\n - The difference between tree and graph is that tree doesn\\'t contain any cycles in it, however since this tree is undirected, a node\\'s neighbor nodes will also contain its parent node (I just called it one edge cycle) e.g., node A connected to node B means B is also connected to A. (We need to check this one edge cycle when doing the search, so we are not going backwards)\\n - We do a dfs starting from ```node``` 0 to update the result array.\\n - At each node, we need to know how many children nodes have the same letter as the current node. If we do this naively, we will need to check all children nodes at each node, which will result in a algorithm with time complexity of O(N^2).\\n - Note that, labels is consisting of only of lowercase English letters, **this is a hint**, there are at most 26 unique letters in this tree, so at each node, instead of just counting the children nodes with the same letter as the current node, **we can simply count the frequency of all letters**.\\n - At the end of each DFS:\\n \\t- We increase the letter\\'s frequency of the current label in ```count```.\\n \\t- We need to update the result array at each node by simplying looking up for the label in ```count```.\\n \\t- Return ```count```.\\n\\n**TC: O(26 * N) == O(N)** 26 comes from the counting of all lowercase English letters at each node.\\n\\n**Code with comments**\\n```python\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        # Construct the tree using the edges.\\n        # Since the tree is undricted, we need to add both directions in the tree.\\n        tree = defaultdict(list)\\n        for s,e in edges:\\n            tree[s].append(e)\\n            tree[e].append(s)\\n        \\n        # The result of length n will be returned at the end.\\n        # It is being modified in the dfs.\\n        res = [0] * n\\n        \\n        # node is the current node we are examing.\\n        # par is the node\\'s direct parent node.\\n        def dfs(node, par):\\n            nonlocal res\\n            # Using count to store the count of each letters in the sub-tree rooted at the current node.\\n            # The size of this hashmap (count) will be at most 26, \\n            # Since there are at most 26 lowercase English letters \\n            count = Counter()\\n            for nei in tree[node]:\\n                # Make sure we are not going backward to its parent node.\\n                if nei != par:\\n                    # Update count with the letters\\' frequency in the children nodes\\n                    # This is the same as going through a to z and increase the frequency of each letter.\\n                    count += dfs(nei, node)\\n            \\n            # Adding 1 to count with the current label\\n            count[labels[node]] += 1\\n            # Update the result.\\n            res[node] = count[labels[node]]\\n            \\n            return count\\n        \\n        # Starting from node 0, and assign fake parent -1 for it.\\n        dfs(0,-1)\\n        return res\\n```\\n\\n**Code without comments**\\n```python\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n\\n        tree = defaultdict(list)\\n        for s,e in edges:\\n            tree[s].append(e)\\n            tree[e].append(s)\\n        \\n        res = [0] * n\\n        \\n        def dfs(node, par):\\n            nonlocal res\\n            count = Counter()\\n            for nei in tree[node]:\\n                if nei != par:\\n                    count += dfs(nei, node)\\n            \\n            count[labels[node]] += 1\\n            res[node] = count[labels[node]]\\n            \\n            return count\\n        \\n        dfs(0,-1)\\n        return res\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```tree```\n```tree```\n```tree```\n```node```\n```count```\n```count```\n```count```\n```python\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        # Construct the tree using the edges.\\n        # Since the tree is undricted, we need to add both directions in the tree.\\n        tree = defaultdict(list)\\n        for s,e in edges:\\n            tree[s].append(e)\\n            tree[e].append(s)\\n        \\n        # The result of length n will be returned at the end.\\n        # It is being modified in the dfs.\\n        res = [0] * n\\n        \\n        # node is the current node we are examing.\\n        # par is the node\\'s direct parent node.\\n        def dfs(node, par):\\n            nonlocal res\\n            # Using count to store the count of each letters in the sub-tree rooted at the current node.\\n            # The size of this hashmap (count) will be at most 26, \\n            # Since there are at most 26 lowercase English letters \\n            count = Counter()\\n            for nei in tree[node]:\\n                # Make sure we are not going backward to its parent node.\\n                if nei != par:\\n                    # Update count with the letters\\' frequency in the children nodes\\n                    # This is the same as going through a to z and increase the frequency of each letter.\\n                    count += dfs(nei, node)\\n            \\n            # Adding 1 to count with the current label\\n            count[labels[node]] += 1\\n            # Update the result.\\n            res[node] = count[labels[node]]\\n            \\n            return count\\n        \\n        # Starting from node 0, and assign fake parent -1 for it.\\n        dfs(0,-1)\\n        return res\\n```\n```python\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n\\n        tree = defaultdict(list)\\n        for s,e in edges:\\n            tree[s].append(e)\\n            tree[e].append(s)\\n        \\n        res = [0] * n\\n        \\n        def dfs(node, par):\\n            nonlocal res\\n            count = Counter()\\n            for nei in tree[node]:\\n                if nei != par:\\n                    count += dfs(nei, node)\\n            \\n            count[labels[node]] += 1\\n            res[node] = count[labels[node]]\\n            \\n            return count\\n        \\n        dfs(0,-1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743330,
                "title": "c-dfs-counting",
                "content": "Well, since edges in the input are undirected, we need to first build an adjacency list.\\n\\nI am passing the array instead of vector since I got a better runtime this way (800 ms vs. 1200 ms).\\n\\n```cpp\\nvoid dfs(int i, string &l, vector<vector<int>>& al, int cnt[], vector<int> &res) {\\n    if (res[i] == 0) {\\n        res[i] = 1;\\n        for (auto j : al[i]) {\\n            int cnt1[26] = {};\\n            dfs(j, l, al, cnt1, res);\\n            for (auto k = 0; k < 26; ++k)\\n                cnt[k] += cnt1[k];\\n        }\\n        res[i] = ++cnt[l[i] - \\'a\\'];\\n    }\\n}\\nvector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n    vector<int> res(n);\\n    int cnt[26] = {};\\n    vector<vector<int>> al(n);\\n    for (auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    dfs(0, labels, al, cnt, res);\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvoid dfs(int i, string &l, vector<vector<int>>& al, int cnt[], vector<int> &res) {\\n    if (res[i] == 0) {\\n        res[i] = 1;\\n        for (auto j : al[i]) {\\n            int cnt1[26] = {};\\n            dfs(j, l, al, cnt1, res);\\n            for (auto k = 0; k < 26; ++k)\\n                cnt[k] += cnt1[k];\\n        }\\n        res[i] = ++cnt[l[i] - \\'a\\'];\\n    }\\n}\\nvector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n    vector<int> res(n);\\n    int cnt[26] = {};\\n    vector<vector<int>> al(n);\\n    for (auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    dfs(0, labels, al, cnt, res);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3038451,
                "title": "c-dfs-beats-99-solution-easy-medium-solution",
                "content": "# Intuition\\nIf we think in terms of DFS, we need a running count of the character frequency in all the child nodes. The only issue is that if we maintain a running count, our frequency map might contain the frequency of all the node (including parent). So how do we solve this?\\n\\n# Approach\\nThis can be achieved in DFS by maintaining a Pre Order count of the char frequency till current node and subtracting it from the Post Order frequency as shown below. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(n)\\n\\nBoth of the above without the overhead of extra time and space required to maintain a separate array/map for every node.\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    void dfsCountAndUpdate(int node, int prevNode, vector<vector<int>>& adjVec,\\n                           string& labels, vector<int>& solution, vector<int>& freqMap) {\\n        // Maintain a count of freq till now.\\n        int prevCount = freqMap[labels[node] - \\'a\\'];\\n\\n        freqMap[labels[node] - \\'a\\'] += 1;\\n        // Count the no. of chars in all the child subtrees.\\n        for (int nextNode : adjVec[node]) {\\n            if (prevNode == nextNode) continue;\\n            dfsCountAndUpdate(nextNode, node, adjVec, labels, solution, freqMap);\\n        }\\n\\n        solution[node] = freqMap[labels[node] - \\'a\\'] - prevCount;\\n    }\\n\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adjVec(n, vector<int>());\\n\\n        for (vector<int>& edge : edges) {\\n            adjVec[edge[0]].push_back(edge[1]);\\n            adjVec[edge[1]].push_back(edge[0]);\\n        }\\n\\n        vector<int> solution(n, 0);\\n        vector<int> freqMap = vector<int>(26, 0);\\n        dfsCountAndUpdate(0, 0, adjVec, labels, solution, freqMap);\\n\\n        return solution;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void dfsCountAndUpdate(int node, int prevNode, vector<vector<int>>& adjVec,\\n                           string& labels, vector<int>& solution, vector<int>& freqMap) {\\n        // Maintain a count of freq till now.\\n        int prevCount = freqMap[labels[node] - \\'a\\'];\\n\\n        freqMap[labels[node] - \\'a\\'] += 1;\\n        // Count the no. of chars in all the child subtrees.\\n        for (int nextNode : adjVec[node]) {\\n            if (prevNode == nextNode) continue;\\n            dfsCountAndUpdate(nextNode, node, adjVec, labels, solution, freqMap);\\n        }\\n\\n        solution[node] = freqMap[labels[node] - \\'a\\'] - prevCount;\\n    }\\n\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adjVec(n, vector<int>());\\n\\n        for (vector<int>& edge : edges) {\\n            adjVec[edge[0]].push_back(edge[1]);\\n            adjVec[edge[1]].push_back(edge[0]);\\n        }\\n\\n        vector<int> solution(n, 0);\\n        vector<int> freqMap = vector<int>(26, 0);\\n        dfsCountAndUpdate(0, 0, adjVec, labels, solution, freqMap);\\n\\n        return solution;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038923,
                "title": "java-solution-with-explanation",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The approach used in this code is a Depth-First Search (DFS) algorithm. The DFS algorithm starts from the root node (node 0 in this case) and explores as far as possible along each branch before backtracking. The code uses an adjacency list to represent the tree, where each index of the list represents a node and the elements in the list at that index represent the nodes that are connected to it.\\n\\n2. The DFS function takes in the current node and the labels as inputs, and performs the following steps:\\n\\n- It marks the current node as visited to avoid counting it again.\\n- It initializes an array of size 26 to count the occurrences of each letter in the subtree rooted at the current node.\\n- It iterates over the neighboring nodes of the current node and recursively calls the DFS function on them if they have not been visited yet.\\n- It adds the count of the letters of the subtree rooted at each neighboring node to the count array.\\n- It increments the count of the letter corresponding to the current node\\'s label in the count array.\\n- It updates the result array at the index corresponding to the current node with the count of the current node\\'s label in the count array.\\n- It returns the count array.\\n3. Finally, the main function calls the DFS function on the root node and returns the result array.\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n  int [] result;\\n  List<List<Integer>> adj;\\n  boolean[] visited;\\n//This function takes in the number of nodes in a tree, the edges that connect the nodes and the labels of the nodes\\n   public int[] countSubTrees(int n, int[][] edges, String labels) {\\n//Creating an adjacency list to store the edges\\n     adj = new ArrayList<>(n);\\n     result = new int[n];\\n    //initializing the adjacency list\\n    for(int i = 0; i < n; i++){\\n        adj.add(new ArrayList<>());\\n    }\\n    //populating the adjacency list with the edges\\n    for(int[] edge : edges){\\n        adj.get(edge[0]).add(edge[1]);\\n        adj.get(edge[1]).add(edge[0]);\\n    }\\n    //keep track of visited nodes\\n     visited = new boolean[n];\\n    //calling the dfs function to count the subtrees starting from the root node\\n    dfs(0,labels);\\n    return result;\\n}\\n//dfs function to traverse the tree and count the subtrees\\nint[] dfs(int node, String labels){\\n    visited[node] = true;\\n    int[] count = new int[26];\\n    //visiting all the neighbours of the current node\\n    for(int nbr : adj.get(node)){\\n        if(!visited[nbr]){\\n            int [] adjCount = dfs(nbr, labels);\\n            //updating the count array with the count of the subtrees of the neighbours\\n            for(int i = 0 ; i < 26; i++){\\n                count[i] += adjCount[i];\\n            }\\n        }\\n    }\\n    //incrementing the count of the current node label\\n    char ch = labels.charAt(node);\\n    count[ch-\\'a\\']++;\\n    //storing the count of the subtrees of the current node\\n    result[node] = count[ch-\\'a\\'];\\n    return count;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  int [] result;\\n  List<List<Integer>> adj;\\n  boolean[] visited;\\n//This function takes in the number of nodes in a tree, the edges that connect the nodes and the labels of the nodes\\n   public int[] countSubTrees(int n, int[][] edges, String labels) {\\n//Creating an adjacency list to store the edges\\n     adj = new ArrayList<>(n);\\n     result = new int[n];\\n    //initializing the adjacency list\\n    for(int i = 0; i < n; i++){\\n        adj.add(new ArrayList<>());\\n    }\\n    //populating the adjacency list with the edges\\n    for(int[] edge : edges){\\n        adj.get(edge[0]).add(edge[1]);\\n        adj.get(edge[1]).add(edge[0]);\\n    }\\n    //keep track of visited nodes\\n     visited = new boolean[n];\\n    //calling the dfs function to count the subtrees starting from the root node\\n    dfs(0,labels);\\n    return result;\\n}\\n//dfs function to traverse the tree and count the subtrees\\nint[] dfs(int node, String labels){\\n    visited[node] = true;\\n    int[] count = new int[26];\\n    //visiting all the neighbours of the current node\\n    for(int nbr : adj.get(node)){\\n        if(!visited[nbr]){\\n            int [] adjCount = dfs(nbr, labels);\\n            //updating the count array with the count of the subtrees of the neighbours\\n            for(int i = 0 ; i < 26; i++){\\n                count[i] += adjCount[i];\\n            }\\n        }\\n    }\\n    //incrementing the count of the current node label\\n    char ch = labels.charAt(node);\\n    count[ch-\\'a\\']++;\\n    //storing the count of the subtrees of the current node\\n    result[node] = count[ch-\\'a\\'];\\n    return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743150,
                "title": "clean-python-3-dfs-with-counter",
                "content": "Perform dfs from node 0 and return counter of each child.\\nTime: `O(N)`\\nSpace: `O(N)`\\n```\\nimport collections\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        def dfs(node: int, parent: int):\\n            counter = collections.Counter()\\n            for child in tree[node]:\\n                if child == parent: continue\\n                counter += dfs(child, node)\\n            counter[labels[node]] += 1\\n            result[node] = counter[labels[node]]\\n            return counter\\n\\n        tree = collections.defaultdict(list)\\n        for a, b in edges:\\n            tree[a].append(b)\\n            tree[b].append(a)\\n        result = [0] * n\\n        dfs(0, None)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        def dfs(node: int, parent: int):\\n            counter = collections.Counter()\\n            for child in tree[node]:\\n                if child == parent: continue\\n                counter += dfs(child, node)\\n            counter[labels[node]] += 1\\n            result[node] = counter[labels[node]]\\n            return counter\\n\\n        tree = collections.defaultdict(list)\\n        for a, b in edges:\\n            tree[a].append(b)\\n            tree[b].append(a)\\n        result = [0] * n\\n        dfs(0, None)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037960,
                "title": "java-c-javascript-dfs-explained-beats-100-concise-and-clean",
                "content": "## Approach:\\n   * Use DFS for Traversal\\n   * Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n   * store that count for each node label in the output array\\n\\n## Complexity:\\n\\n* **Time Complexity**: O(n)\\n* **Space Complexity**: O(26*n)\\n\\n\\n``` java []\\nclass Solution {\\n    int[] array;\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n\\n        array = new int[n]; //output array\\n    \\n        //creating adjacency list\\n        ArrayList<Integer>[] a = new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            a[i] = new ArrayList<Integer>();\\n        }\\n\\n        for(int[] x:edges){\\n            a[x[0]].add(x[1]);\\n            a[x[1]].add(x[0]);\\n        }\\n\\n        dfs(-1,0,a,labels);\\n        return array;\\n    }\\n\\n    private int[] dfs(int prev,int curr,ArrayList<Integer>[] a,String labels)\\n    {\\n        int[] ans = new int[26];  //freq array \\n        for(int x:a[curr])\\n        {\\n            if(prev!=x)\\n            {\\n                // array return by the children node\\n                int[] res = dfs(curr,x,a,labels);  \\n                // combining the frequencies of left and right subtrees into one array\\n                for(int i=0;i<res.length;i++)  \\n                    ans[i]+=res[i];\\n            }\\n        }\\n        // incrementing the freq of curr node label and storing in output array\\n        array[curr] = ++ans[labels.charAt(curr)-\\'a\\']; \\n        return ans;\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\n    vector<int> array;\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        array.resize(n); //output array\\n        \\n        //creating adjacency list\\n        vector<vector<int>> a(n);\\n        for(auto x:edges){\\n            a[x[0]].push_back(x[1]);\\n            a[x[1]].push_back(x[0]);\\n        }\\n        dfs(-1,0,a,labels);\\n        return array;\\n    }\\n\\n    vector<int> dfs(int prev,int curr,vector<vector<int>>& a,string& labels)\\n    {\\n        vector<int> ans(26); \\n        for(auto x:a[curr])\\n        {\\n            if(prev!=x)\\n            {\\n            // array return by the children node\\n                vector<int> res = dfs(curr,x,a,labels); \\n            // combining the frequencies of left and right subtrees into one array\\n                for(int i=0;i<26;i++) \\n                    ans[i]+=res[i];\\n            }\\n        }\\n        // incrementing the freq of curr node label and storing in output array\\n        array[curr] = ++ans[labels[curr]-\\'a\\'];\\n        return ans;\\n    }\\n};\\n```\\n``` javascript []\\nvar countSubTrees = function(n, edges, labels) {\\n        let array = new Array(n);  //output array\\n\\n        // creating adjacency list\\n        let a = new Array(n);\\n        for (let i = 0; i < n; i++) {\\n            a[i] = [];\\n        }\\n        for (let x of edges) {\\n            a[x[0]].push(x[1]);\\n            a[x[1]].push(x[0]);\\n        }\\n\\n        dfs(-1, 0, a, labels,array);\\n        return array;\\n    }\\n\\n    function dfs(prev, curr, a, labels,array) {\\n        const ans = new Array(26).fill(0);\\n\\n        for (let x of a[curr]) {\\n            if (prev !== x) {\\n            // array return by the children node\\n                const res = dfs(curr, x, a, labels, array);  \\n            // combining the frequencies of left and right subtrees into one array\\n                for (let i = 0; i < 26; i++)  \\n                    ans[i] += res[i];\\n            }\\n        }\\n        // incrementing the freq of curr node label and storing in output array\\n        array[curr] = ++ans[labels.charCodeAt(curr) - \\'a\\'.charCodeAt(0)];\\n        return ans;\\n    }\\n```\\n\\nNote: Here, in Java and C++ code, the output array is declared globally to avoid passing in recursion call.\\n\\n## *UPVOTE, IF U LIKE IT*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "``` java []\\nclass Solution {\\n    int[] array;\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n\\n        array = new int[n]; //output array\\n    \\n        //creating adjacency list\\n        ArrayList<Integer>[] a = new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            a[i] = new ArrayList<Integer>();\\n        }\\n\\n        for(int[] x:edges){\\n            a[x[0]].add(x[1]);\\n            a[x[1]].add(x[0]);\\n        }\\n\\n        dfs(-1,0,a,labels);\\n        return array;\\n    }\\n\\n    private int[] dfs(int prev,int curr,ArrayList<Integer>[] a,String labels)\\n    {\\n        int[] ans = new int[26];  //freq array \\n        for(int x:a[curr])\\n        {\\n            if(prev!=x)\\n            {\\n                // array return by the children node\\n                int[] res = dfs(curr,x,a,labels);  \\n                // combining the frequencies of left and right subtrees into one array\\n                for(int i=0;i<res.length;i++)  \\n                    ans[i]+=res[i];\\n            }\\n        }\\n        // incrementing the freq of curr node label and storing in output array\\n        array[curr] = ++ans[labels.charAt(curr)-\\'a\\']; \\n        return ans;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\n    vector<int> array;\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        array.resize(n); //output array\\n        \\n        //creating adjacency list\\n        vector<vector<int>> a(n);\\n        for(auto x:edges){\\n            a[x[0]].push_back(x[1]);\\n            a[x[1]].push_back(x[0]);\\n        }\\n        dfs(-1,0,a,labels);\\n        return array;\\n    }\\n\\n    vector<int> dfs(int prev,int curr,vector<vector<int>>& a,string& labels)\\n    {\\n        vector<int> ans(26); \\n        for(auto x:a[curr])\\n        {\\n            if(prev!=x)\\n            {\\n            // array return by the children node\\n                vector<int> res = dfs(curr,x,a,labels); \\n            // combining the frequencies of left and right subtrees into one array\\n                for(int i=0;i<26;i++) \\n                    ans[i]+=res[i];\\n            }\\n        }\\n        // incrementing the freq of curr node label and storing in output array\\n        array[curr] = ++ans[labels[curr]-\\'a\\'];\\n        return ans;\\n    }\\n};\\n```\n``` javascript []\\nvar countSubTrees = function(n, edges, labels) {\\n        let array = new Array(n);  //output array\\n\\n        // creating adjacency list\\n        let a = new Array(n);\\n        for (let i = 0; i < n; i++) {\\n            a[i] = [];\\n        }\\n        for (let x of edges) {\\n            a[x[0]].push(x[1]);\\n            a[x[1]].push(x[0]);\\n        }\\n\\n        dfs(-1, 0, a, labels,array);\\n        return array;\\n    }\\n\\n    function dfs(prev, curr, a, labels,array) {\\n        const ans = new Array(26).fill(0);\\n\\n        for (let x of a[curr]) {\\n            if (prev !== x) {\\n            // array return by the children node\\n                const res = dfs(curr, x, a, labels, array);  \\n            // combining the frequencies of left and right subtrees into one array\\n                for (let i = 0; i < 26; i++)  \\n                    ans[i] += res[i];\\n            }\\n        }\\n        // incrementing the freq of curr node label and storing in output array\\n        array[curr] = ++ans[labels.charCodeAt(curr) - \\'a\\'.charCodeAt(0)];\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037908,
                "title": "python-3-11-lines-recursion-w-explanation-t-m-100-95",
                "content": "Here\\'s the plan:\\n1. We build the graph`g` from`edges`.\\n2. We traverse the tree by recursion, keeping track of each node\\'s parent`par`so we do not revisit an already visited node.\\n3. During the traversal, we keep track of the label counts in`ans`.\\n4. Once the travesal is completed, we`return ans`.\\n```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        g, labelCt, ans = defaultdict(list), defaultdict(int), [0] * n\\n        \\n        for a, b in edges:                              #  <-- 1     \\n            g[a].append(b)\\n            g[b].append(a)\\n        \\n        def dfs(node=0, par=None):                      #  <-- 2\\n            prev = labelCt[labels[node]]\\n            labelCt[labels[node]] += 1\\n            \\n            for child in g[node]:\\n                if child != par: dfs(child, node)\\n\\n            ans[node] = labelCt[labels[node]] - prev    # <-- 3\\n\\n        dfs()\\n        return ans                                      # <-- 4\\n```\\n[https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876447690/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        g, labelCt, ans = defaultdict(list), defaultdict(int), [0] * n\\n        \\n        for a, b in edges:                              #  <-- 1     \\n            g[a].append(b)\\n            g[b].append(a)\\n        \\n        def dfs(node=0, par=None):                      #  <-- 2\\n            prev = labelCt[labels[node]]\\n            labelCt[labels[node]] += 1\\n            \\n            for child in g[node]:\\n                if child != par: dfs(child, node)\\n\\n            ans[node] = labelCt[labels[node]] - prev    # <-- 3\\n\\n        dfs()\\n        return ans                                      # <-- 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743192,
                "title": "why-am-i-getting-tle-for-o-n-26-solution-c-very-poor-time-limit-set",
                "content": "```\\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\nclass Solution {\\npublic:\\n    vector<int > graph[100001];\\n    vector<int > countNodes;\\n    vector<bool > visited;\\n    vector<int > dfs(int source,string labels){\\n        visited[source]=1;\\n        \\n        vector<int > currNodeState(26,0);\\n        \\n        for(int child: graph[source]){\\n            if(!visited[child]){\\n                vector<int > state = dfs(child,labels);\\n                for(int j=0;j<26;j++)\\n                    currNodeState[j]+=state[j];\\n            }\\n        }\\n        \\n        countNodes[source]=1;\\n        countNodes[source]+=currNodeState[labels[source]-\\'a\\'];\\n        currNodeState[labels[source]-\\'a\\']++;\\n     \\n        return currNodeState;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        \\n        IOS;\\n        for(vector<int > vec: edges){\\n            graph[vec[0]].push_back(vec[1]);\\n            graph[vec[1]].push_back(vec[0]);\\n        }\\n        \\n        countNodes.resize(n);\\n        visited.resize(n);\\n        for(int i=0;i<n;i++)\\n            countNodes[i]=0,visited[i]=0;\\n        \\n        vector<int > temp = dfs(0,labels);\\n        return countNodes;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\nclass Solution {\\npublic:\\n    vector<int > graph[100001];\\n    vector<int > countNodes;\\n    vector<bool > visited;\\n    vector<int > dfs(int source,string labels){\\n        visited[source]=1;\\n        \\n        vector<int > currNodeState(26,0);\\n        \\n        for(int child: graph[source]){\\n            if(!visited[child]){\\n                vector<int > state = dfs(child,labels);\\n                for(int j=0;j<26;j++)\\n                    currNodeState[j]+=state[j];\\n            }\\n        }\\n        \\n        countNodes[source]=1;\\n        countNodes[source]+=currNodeState[labels[source]-\\'a\\'];\\n        currNodeState[labels[source]-\\'a\\']++;\\n     \\n        return currNodeState;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        \\n        IOS;\\n        for(vector<int > vec: edges){\\n            graph[vec[0]].push_back(vec[1]);\\n            graph[vec[1]].push_back(vec[0]);\\n        }\\n        \\n        countNodes.resize(n);\\n        visited.resize(n);\\n        for(int i=0;i<n;i++)\\n            countNodes[i]=0,visited[i]=0;\\n        \\n        vector<int > temp = dfs(0,labels);\\n        return countNodes;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 743220,
                "title": "c-dfs-dp-vector-counter-implementation-o-n",
                "content": "This is a classic sub-tree class problem where you have to update child counts and then the parent\\'s count.\\n\\nEach counter is stored in its own `dp[node]`\\n\\nFirst update the `child` and then update the `parent` count vector using:\\n```\\n\\tfor (int i=0; i<27; i++) {\\n\\t\\t\\tdp[node][i] += dp[child][i];\\n\\t}\\n```\\n\\nTime Complexity : `O(n)`\\nSpace : `O(27*n)`\\n\\nC++ Solution : \\n```\\nclass Solution {\\npublic:\\n    void dfs (int node, int par, vector<vector<int>> &g, vector<vector<int>> &dp, vector<int> &ans, string &labels) {\\n        dp[node][labels[node]-\\'a\\']++;\\n        for (auto &child: g[node]) {\\n            if (child != par) {\\n                dfs(child, node, g, dp, ans, labels);\\n                for (int i=0; i<27; i++) {\\n                    dp[node][i] += dp[child][i];\\n                }\\n            }\\n        }\\n        ans[node] = dp[node][labels[node]-\\'a\\'];\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> g(n);\\n        for (int i=0; i<edges.size(); i++) {\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector <vector<int>> dp(n, vector<int>(27, 0));\\n        vector<int> ans(n);\\n        dfs(0, -1, g, dp, ans, labels);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\n\\tfor (int i=0; i<27; i++) {\\n\\t\\t\\tdp[node][i] += dp[child][i];\\n\\t}\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs (int node, int par, vector<vector<int>> &g, vector<vector<int>> &dp, vector<int> &ans, string &labels) {\\n        dp[node][labels[node]-\\'a\\']++;\\n        for (auto &child: g[node]) {\\n            if (child != par) {\\n                dfs(child, node, g, dp, ans, labels);\\n                for (int i=0; i<27; i++) {\\n                    dp[node][i] += dp[child][i];\\n                }\\n            }\\n        }\\n        ans[node] = dp[node][labels[node]-\\'a\\'];\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> g(n);\\n        for (int i=0; i<edges.size(); i++) {\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector <vector<int>> dp(n, vector<int>(27, 0));\\n        vector<int> ans(n);\\n        dfs(0, -1, g, dp, ans, labels);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038487,
                "title": "c-easy-solution-dfs-approach-beats-82-heavily-commented",
                "content": "# **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFDFS Approach beats 82% SOLUTION**\\n# **Please Upvote as it really motivates me**\\n```\\nclass Solution {\\npublic:\\n    vector<int> dfs(vector<vector<int>>&g,string &s,vector<int>&vis,int val,vector<int> &a){\\n\\t\\t//We have a temp vector to keep the account of char in the sub trees\\n        vector<int>temp(26);\\n\\t\\t//Making the visited node true or marking it visited\\n        vis[val]=1;\\n\\t\\t\\n\\t\\t//Now we start Traversing the neighboring nodes of the val node.\\n        for(int neig:g[val]){\\n\\t\\t//We will call dfs only for the node which are not visited\\n            if(!vis[neig]){\\n                vector<int> child= dfs(g,s,vis,neig,a);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//adding the label to the temp vector\\n                temp[s[neig]-\\'a\\']++;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//adding the labels of all the subtree labels\\n                for(int i=0;i<26;i++){\\n                    temp[i]+=child[i];\\n                }\\n            }\\n        }\\n\\t\\t//Finally adding temp value to the ans vector.\\n        a[val]+=temp[s[val]-\\'a\\']+1;\\n        return temp;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& e, string labels) {\\n        vector<vector<int>>g(n);\\n\\t\\t//First step is to convert the edges into the graph\\n\\t\\t//so as given undirected graph so we have made 2d vector for graph\\n        for(int i=0;i<e.size();i++){\\n            g[e[i][0]].push_back(e[i][1]);\\n            g[e[i][1]].push_back(e[i][0]);\\n        }\\n\\t\\t//Second step is to make the visited vector \\n\\t\\t//inorder to keep the count of the node that has been visited.\\n        vector<int>vis(n),ans(n),temp(26);\\n        dfs(g,labels,vis,0,ans);\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dfs(vector<vector<int>>&g,string &s,vector<int>&vis,int val,vector<int> &a){\\n\\t\\t//We have a temp vector to keep the account of char in the sub trees\\n        vector<int>temp(26);\\n\\t\\t//Making the visited node true or marking it visited\\n        vis[val]=1;\\n\\t\\t\\n\\t\\t//Now we start Traversing the neighboring nodes of the val node.\\n        for(int neig:g[val]){\\n\\t\\t//We will call dfs only for the node which are not visited\\n            if(!vis[neig]){\\n                vector<int> child= dfs(g,s,vis,neig,a);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//adding the label to the temp vector\\n                temp[s[neig]-\\'a\\']++;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//adding the labels of all the subtree labels\\n                for(int i=0;i<26;i++){\\n                    temp[i]+=child[i];\\n                }\\n            }\\n        }\\n\\t\\t//Finally adding temp value to the ans vector.\\n        a[val]+=temp[s[val]-\\'a\\']+1;\\n        return temp;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& e, string labels) {\\n        vector<vector<int>>g(n);\\n\\t\\t//First step is to convert the edges into the graph\\n\\t\\t//so as given undirected graph so we have made 2d vector for graph\\n        for(int i=0;i<e.size();i++){\\n            g[e[i][0]].push_back(e[i][1]);\\n            g[e[i][1]].push_back(e[i][0]);\\n        }\\n\\t\\t//Second step is to make the visited vector \\n\\t\\t//inorder to keep the count of the node that has been visited.\\n        vector<int>vis(n),ans(n),temp(26);\\n        dfs(g,labels,vis,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037983,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> adj[n];\\n        for(auto &i:edges){\\n            int u=i[0],v=i[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        ans.resize(n,0);\\n        vector<int> count(26,0);\\n        dfs(0,-1,count,adj,labels);\\n        return ans;\\n    }\\n    void dfs(int node,int parent,vector<int>& count,vector<int> adj[],string &labels){\\n        for(auto &i:adj[node]){\\n            if(i!=parent){\\n                vector<int> counting(26,0);\\n                dfs(i,node,counting,adj,labels);\\n                for(int i=0;i<26;i++){\\n                    count[i]=count[i]+counting[i];\\n                }\\n            }\\n        }\\n        count[labels[node]-\\'a\\']++;\\n        ans[node]=count[labels[node]-\\'a\\'];\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/ebab7a19-f60e-4bea-bbeb-041539469d8b_1673486711.666036.png)",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> adj[n];\\n        for(auto &i:edges){\\n            int u=i[0],v=i[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        ans.resize(n,0);\\n        vector<int> count(26,0);\\n        dfs(0,-1,count,adj,labels);\\n        return ans;\\n    }\\n    void dfs(int node,int parent,vector<int>& count,vector<int> adj[],string &labels){\\n        for(auto &i:adj[node]){\\n            if(i!=parent){\\n                vector<int> counting(26,0);\\n                dfs(i,node,counting,adj,labels);\\n                for(int i=0;i<26;i++){\\n                    count[i]=count[i]+counting[i];\\n                }\\n            }\\n        }\\n        count[labels[node]-\\'a\\']++;\\n        ans[node]=count[labels[node]-\\'a\\'];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441578,
                "title": "python-3-dfs-graph-counter-explanation",
                "content": "### Explanation\\n- First you need to note that:\\n\\t- The tree is not guarantee to be a `bianry tree`\\n\\t- `edges[i]` doesn\\'t guarantee in order of `[parent, child]` \\n- Given above, we can\\'t make it a directed tree with parent-child structure, but luckily, we know the root is always node `0`\\n- Thus, we will start a DFS from root and avoid revisited any visited nodes\\n- Meanwhile, take a dictionary to count frequency of labels at each node, see comments below for more content\\n- Time Complexity: `O(N)`, build tree and DFS each takes `O(N)`, together still `O(N)`\\n- Space Complexity: `O(N)`, technically `O(26N)` since there are 26 letters, but 26 is a constant, we will use just `O(N)`\\n### Implementation\\n```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        ans = [0] * n\\n        tree = collections.defaultdict(list)\\n        for a, b in edges:                             # build tree\\n            tree[a].append(b)\\n            tree[b].append(a)\\n        def dfs(node):                                 # dfs\\n            nonlocal visited, ans, tree\\n            c = collections.Counter(labels[node])\\n            for nei in tree[node]:\\n                if nei in visited: continue            # avoid revisit\\n                visited.add(nei)\\n                c += dfs(nei)                          # add counter (essentially adding a 26 elements dictionary)\\n            ans[node] = c.get(labels[node])            # assign count of label to this node\\n            return c\\n        visited = set([0])\\n        dfs(0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        ans = [0] * n\\n        tree = collections.defaultdict(list)\\n        for a, b in edges:                             # build tree\\n            tree[a].append(b)\\n            tree[b].append(a)\\n        def dfs(node):                                 # dfs\\n            nonlocal visited, ans, tree\\n            c = collections.Counter(labels[node])\\n            for nei in tree[node]:\\n                if nei in visited: continue            # avoid revisit\\n                visited.add(nei)\\n                c += dfs(nei)                          # add counter (essentially adding a 26 elements dictionary)\\n            ans[node] = c.get(labels[node])            # assign count of label to this node\\n            return c\\n        visited = set([0])\\n        dfs(0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743546,
                "title": "c-faster-than-100-with-explanation",
                "content": "We can solve the question using dfs and some optimizations easily. First of all, we store the graph in an adjacency list format. It is given that the root node will always contain the value \\'0\\'.\\nWe went with global vectors for storing graph and the resultant vector as the solution contains recursion and global variables would help in reducing the memory stack.\\n\\nWe start our dfs from the root node with parent as -1 since the root node does not have any parent. When we reach a particular node, we start maintaining a frequency vector which would store the frequency of all the characters present in the subtree with current node as the root node.\\n\\nWe traverse through the children nodes using the same concept and keep returning the frequency count of the nodes to their parent nodes for adding up in their own resultant array.\\n\\n**Time complexity - O(N)**\\n*Kindly upvote if you find the solution helpful :)*\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    vector<vector<int>>g;\\n    \\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n\\t\\t//clearing the ans and graph for storing the current ones since these are global, it might happen \\n\\t\\t//that the values from previous test cases might still be present within them which could alter \\n\\t\\t//the answer of present test case.\\n        ans.resize(n,0);\\n        g.resize(n,vector<int>{});\\n        \\n\\t\\t//Creating the adjacency list for the graph\\n        for(auto it:edges) {\\n            g[it[0]].push_back(it[1]);\\n            g[it[1]].push_back(it[0]);\\n        }\\n        \\n\\t\\t//starting traversal of graph from the 0 node and parent as -1\\n        dfs(0, -1, labels); //<current node, parent node, labels string>\\n        \\n        return ans;\\n    }\\n    \\n    vector<int> dfs(int s, int par, string &labels) {\\n\\t\\t//maintaining the frequency count of the subtree with **s** as the node\\n        vector<int>res(26,0);\\n        res[labels[s]-\\'a\\']++; //adding the value of current node\\n        \\n        for(int it:g[s]) {\\n            \\n            if(it == par)\\n                continue;\\n            \\n            vector<int>f = dfs(it, s, labels); //frequency count of subtree with it(child) as root\\n            for(int i=0; i<26; ++i) {\\n                res[i]+=f[i];\\n            }\\n        }\\n        \\n        ans[s] = res[labels[s]-\\'a\\']; //since we want the number of occurences of the char in current node\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    vector<vector<int>>g;\\n    \\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n\\t\\t//clearing the ans and graph for storing the current ones since these are global, it might happen \\n\\t\\t//that the values from previous test cases might still be present within them which could alter \\n\\t\\t//the answer of present test case.\\n        ans.resize(n,0);\\n        g.resize(n,vector<int>{});\\n        \\n\\t\\t//Creating the adjacency list for the graph\\n        for(auto it:edges) {\\n            g[it[0]].push_back(it[1]);\\n            g[it[1]].push_back(it[0]);\\n        }\\n        \\n\\t\\t//starting traversal of graph from the 0 node and parent as -1\\n        dfs(0, -1, labels); //<current node, parent node, labels string>\\n        \\n        return ans;\\n    }\\n    \\n    vector<int> dfs(int s, int par, string &labels) {\\n\\t\\t//maintaining the frequency count of the subtree with **s** as the node\\n        vector<int>res(26,0);\\n        res[labels[s]-\\'a\\']++; //adding the value of current node\\n        \\n        for(int it:g[s]) {\\n            \\n            if(it == par)\\n                continue;\\n            \\n            vector<int>f = dfs(it, s, labels); //frequency count of subtree with it(child) as root\\n            for(int i=0; i<26; ++i) {\\n                res[i]+=f[i];\\n            }\\n        }\\n        \\n        ans[s] = res[labels[s]-\\'a\\']; //since we want the number of occurences of the char in current node\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743174,
                "title": "c-easy-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> dfs(vector<vector<int>> &adj,int curr,string &label,vector<bool> &vis,vector<int> &ans)\\n    {\\n        vis[curr]=true;\\n        vector<int> v(26,0);\\n        v[label[curr]-\\'a\\']=1;\\n        for(int i=0;i<adj[curr].size();i++)\\n        {\\n            if(vis[adj[curr][i]])\\n                   continue;\\n            vector<int> r=dfs(adj,adj[curr][i],label,vis,ans);\\n            for(int i=0;i<26;i++)\\n                v[i]+=r[i];\\n        }\\n        ans[curr]=v[label[curr]-\\'a\\'];\\n        return v;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adj(n+1,vector<int>());\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> ans(n,1);\\n        vector<bool> vis(n+1,0);\\n        dfs(adj,0,labels,vis,ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> dfs(vector<vector<int>> &adj,int curr,string &label,vector<bool> &vis,vector<int> &ans)\\n    {\\n        vis[curr]=true;\\n        vector<int> v(26,0);\\n        v[label[curr]-\\'a\\']=1;\\n        for(int i=0;i<adj[curr].size();i++)\\n        {\\n            if(vis[adj[curr][i]])\\n                   continue;\\n            vector<int> r=dfs(adj,adj[curr][i],label,vis,ans);\\n            for(int i=0;i<26;i++)\\n                v[i]+=r[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3037954,
                "title": "python-o-1-space",
                "content": "# Intuition\\n\\n**Disclaimer**: first, we talk about \"additional\" space here, so output parameters like `ans` do not count. Second, I do not consider the graph to take additional space, since it\\'s a result of a poor input format choice.\\n\\n# Approach\\n\\nLet\\'s imagine that we run a timed depth first search on our tree. \"Timed\" as in \"a counter is incremented when entering and exiting a vertex\". We\\'ll denote entrance and exit (in and out) times for a vertex $$v$$ as $$t_i(v)$$ and $$t_o(v)$$ respectively. Further denote the set of visited vertices at time $$t$$ as $$S(t)$$.\\n\\n**Lemma**: A subtree of a vertex $$v$$ is $$S(t_o(v)) \\\\setminus S(t_i(v))$$.\\n_Proof_: all vertices in a subtree of $$v$$ get exited before $$v$$, so they all belong to $$S(t_o(v))$$. All vertices in a subtree of $$v$$ are entered after $$v$$, so none of them belongs to $$S(t_i(v))$$.\\n\\nNow let\\'s maintain a frequency table of labels during the dfs. The answer for a given vertex will be the difference between the label\\'s frequencies at times $$t_o$$ and $$t_i$$ due to the above lemma. \\n\\nUpvote so that more people learn this trick!\\n\\n_Note_ (in case you are wondering why this is so important). Imagine that labels are integers instead of letters. Then all $$O(n)$$ of your hashmaps from a naive solution suddenly take $$O(n)$$ space. Merging them takes $$O(n)$$ time too, for a total of $$O(n^2)$$. However, this solution will remain $$O(n + n) = O(n)$$.\\n\\n# Complexity\\n\\n- Time complexity: $$O(n)$$.\\n\\n- Space complexity: $$O(1)$$, or $$O(|\\\\Sigma| + h)$$ if you want to be pedantic.\\n\\n# Code\\n\\n```python\\nimport collections\\n\\n\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: list[list[int]], labels: str) -> list[int]:\\n        graph = [[] for _ in range(n)]\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n\\n        ans = [0] * n\\n\\n        def dfs(vertex: int, parent: int, cnt: collections.Counter) -> None:\\n            before = cnt[labels[vertex]]\\n\\n            for adjacent in graph[vertex]:\\n                if adjacent != parent:\\n                    dfs(adjacent, vertex, cnt)\\n\\n            cnt[labels[vertex]] += 1\\n            ans[vertex] = cnt[labels[vertex]] - before\\n\\n        dfs(0, 0, collections.Counter())\\n        return ans\\n   \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Depth-First Search",
                    "Counting"
                ],
                "code": "```python\\nimport collections\\n\\n\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: list[list[int]], labels: str) -> list[int]:\\n        graph = [[] for _ in range(n)]\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n\\n        ans = [0] * n\\n\\n        def dfs(vertex: int, parent: int, cnt: collections.Counter) -> None:\\n            before = cnt[labels[vertex]]\\n\\n            for adjacent in graph[vertex]:\\n                if adjacent != parent:\\n                    dfs(adjacent, vertex, cnt)\\n\\n            cnt[labels[vertex]] += 1\\n            ans[vertex] = cnt[labels[vertex]] - before\\n\\n        dfs(0, 0, collections.Counter())\\n        return ans\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516863,
                "title": "c-faster-99-25-python-faster-99-39-go-faster-100-time-space-o-n",
                "content": "The trick is in that the graph is undirected, so we don\\'t know which node is a parent and which is a child in the edges array. The only way to know is to start from the root which is always `0` and recursively search \"children\" for every next node. To make this process efficient, we need to create a data structure that will return a list of possible next nodes IDs in constant time. This structure could be a hash map, but, since we know the number of nodes from the start, array or list is more time-efficient and space-efficient data structure.\\n\\nThen we just do DFS through all nodes and fill `labelCount` \\u2014 an array of integer values length 26, where 0 \\u2014 count for \\'a\\', 1 \\u2014 count for \\'b\\', 25 \\u2014 for \\'z\\'. When we are visiting a node, at first we remember `labelCount` for the node label. Then going to all possible children and assume that new `labelCount` for the node label minus the old one that we saved before == count of nodes with the same label in \"subtree\" of the current node. Don\\'t forget to count the proceeding node.\\n\\n<iframe src=\"https://leetcode.com/playground/eZ5SpEX6/shared\" frameBorder=\"0\" width=\"100%\" height=\"700\"></iframe>\\n\\n\\nMy best submissions of this code:\\n```\\nRuntime: 360 ms, faster than 99.25% of C++ online submissions for Number of Nodes in the Sub-Tree With the Same Label.\\nMemory Usage: 149.8 MB, less than 98.51% of C++ online submissions for Number of Nodes in the Sub-Tree With the Same Label.\\n```\\n```\\nRuntime: 1456 ms, faster than 99.39% of Python3 online submissions for Number of Nodes in the Sub-Tree With the Same Label.\\nMemory Usage: 174.7 MB, less than 89.02% of Python3 online submissions for Number of Nodes in the Sub-Tree With the Same Label.\\n```\\n```\\nRuntime: 244 ms, faster than 100.00% of Go online submissions for Number of Nodes in the Sub-Tree With the Same Label.\\nMemory Usage: 42.9 MB, less than 100.00% of Go online submissions for Number of Nodes in the Sub-Tree With the Same Label.\\n```\\n\\nSpace compexity: `O(N) where N is a number of nodes, because of creating vector of vectors (list of lists for Python) with size N and response is a new object of size N`\\nTime coplexity: `O(2N) == O(N), where N is a number of nodes, because we have one loop over edges(which are N - 1) and then visit every node exactly once in the dfs function recursion`\\n\\n**If you found it useful, please upvote to help share!**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\nRuntime: 360 ms, faster than 99.25% of C++ online submissions for Number of Nodes in the Sub-Tree With the Same Label.\\nMemory Usage: 149.8 MB, less than 98.51% of C++ online submissions for Number of Nodes in the Sub-Tree With the Same Label.\\n```\n```\\nRuntime: 1456 ms, faster than 99.39% of Python3 online submissions for Number of Nodes in the Sub-Tree With the Same Label.\\nMemory Usage: 174.7 MB, less than 89.02% of Python3 online submissions for Number of Nodes in the Sub-Tree With the Same Label.\\n```\n```\\nRuntime: 244 ms, faster than 100.00% of Go online submissions for Number of Nodes in the Sub-Tree With the Same Label.\\nMemory Usage: 42.9 MB, less than 100.00% of Go online submissions for Number of Nodes in the Sub-Tree With the Same Label.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 743200,
                "title": "java-dfs-by-treebuild",
                "content": "```\\nclass Solution {\\n    int[] res;\\n    public int[] countSubTrees(int n, int[][] es, String l) {\\n        Node root = build(n, es, l);\\n        res = new int[n];\\n        dfs(root);\\n        return res;\\n    }\\n    \\n    private Map<Character, Integer> dfs(Node node) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        if (node == null) return map;\\n        map.put(node.c, 1);\\n        for (Node child : node.cs) {\\n            Map<Character, Integer> cmap = dfs(child);\\n            for (char c : cmap.keySet()) {\\n                map.put(c, map.getOrDefault(c, 0) + cmap.get(c));\\n            }\\n        }\\n        res[node.key] = map.get(node.c);\\n        return map;\\n    }\\n    \\n    private Node build(int n, int[][] es, String l) {\\n        Map<Integer, List<Integer>> g = new HashMap<>();\\n        for (int[] e : es) {\\n            g.computeIfAbsent(e[0], k -> new ArrayList<>());\\n            g.computeIfAbsent(e[1], k -> new ArrayList<>());\\n            g.get(e[1]).add(e[0]);\\n            g.get(e[0]).add(e[1]);\\n        }\\n        Node root = new Node(0);\\n        root.c = l.charAt(0);\\n        Queue<Node> q = new LinkedList<>();\\n        q.offer(root);\\n        while (!q.isEmpty()) {\\n            Node curr = q.poll();\\n            for (int neig : g.getOrDefault(curr.key, new ArrayList<>())) {\\n                if (curr.p == null || neig != curr.p.key) {\\n                    Node next = new Node(neig);\\n                    next.c = l.charAt(neig);\\n                    next.p = curr;\\n                    curr.cs.add(next);\\n                    q.offer(next);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n\\t\\n\\tclass Node{\\n        char c;\\n        int key;\\n        List<Node> cs;\\n        Node p;\\n        public Node(int key){\\n            this.key = key;\\n            cs = new ArrayList<>();\\n            this.p = null;\\n        };\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] res;\\n    public int[] countSubTrees(int n, int[][] es, String l) {\\n        Node root = build(n, es, l);\\n        res = new int[n];\\n        dfs(root);\\n        return res;\\n    }\\n    \\n    private Map<Character, Integer> dfs(Node node) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        if (node == null) return map;\\n        map.put(node.c, 1);\\n        for (Node child : node.cs) {\\n            Map<Character, Integer> cmap = dfs(child);\\n            for (char c : cmap.keySet()) {\\n                map.put(c, map.getOrDefault(c, 0) + cmap.get(c));\\n            }\\n        }\\n        res[node.key] = map.get(node.c);\\n        return map;\\n    }\\n    \\n    private Node build(int n, int[][] es, String l) {\\n        Map<Integer, List<Integer>> g = new HashMap<>();\\n        for (int[] e : es) {\\n            g.computeIfAbsent(e[0], k -> new ArrayList<>());\\n            g.computeIfAbsent(e[1], k -> new ArrayList<>());\\n            g.get(e[1]).add(e[0]);\\n            g.get(e[0]).add(e[1]);\\n        }\\n        Node root = new Node(0);\\n        root.c = l.charAt(0);\\n        Queue<Node> q = new LinkedList<>();\\n        q.offer(root);\\n        while (!q.isEmpty()) {\\n            Node curr = q.poll();\\n            for (int neig : g.getOrDefault(curr.key, new ArrayList<>())) {\\n                if (curr.p == null || neig != curr.p.key) {\\n                    Node next = new Node(neig);\\n                    next.c = l.charAt(neig);\\n                    next.p = curr;\\n                    curr.cs.add(next);\\n                    q.offer(next);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n\\t\\n\\tclass Node{\\n        char c;\\n        int key;\\n        List<Node> cs;\\n        Node p;\\n        public Node(int key){\\n            this.key = key;\\n            cs = new ArrayList<>();\\n            this.p = null;\\n        };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039787,
                "title": "explanation-with-simulation-images-clean-and-simple-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a variation of the problem: [Minimum Time to Collect All Apples in a Tree](https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/description/)\\n\\nSuppose, we have this input graph given to us:\\n\\n![image.png](https://assets.leetcode.com/users/images/75a79632-81d9-49f6-b0bb-7d58bf460ed2_1673514772.6349287.png)\\n\\nWe first need to construct an adjacency list. We can create it using HashMaps in Java.\\n\\n![image.png](https://assets.leetcode.com/users/images/3f8c04a9-d1a8-49cb-89b3-c6c135d5fac0_1673514909.0082629.png)\\n\\n# Aprroach:\\nOur dfs function will do the following things:\\n\\n- `Int[] dfs( int node, int parent ) :`\\n\\n- For, Node 0 , Parent -1:\\n\\n    - Initialize `nodeCounts[]` array that will keep the count of nodes having same labels.\\n    - We have an upper hand as labels will consist only of lower case English letters. This tells us that we can initialize the array with length = 26.\\n    - Our current node has label **\\u2018a\\u2019** \\n    So, `nodeCounts[\\u2018a\\u2019-\\u2019a\\u2019]  = nodeCounts[0] = 1`;\\n    - Now, get `childCounts[]` for each `child` from `adjList[node]`.\\n    `childCounts[] = dfs(child, node)`\\n    - Update ``nodeCounts[]` for each `label` with the `childCounts[]`.\\n    \\n- Finally, update `ans[]` array, `ans[node] = nodeCounts[\\u2018a\\u2019]`\\n- return `nodeCounts[]`;\\n\\n\\n# Simulation of left subtree from root:\\n\\nWe recursively go and visit the leaf node which is the left most subtree.\\n\\n![image.png](https://assets.leetcode.com/users/images/ce271b89-3b26-419b-b018-04a603b6febe_1673515243.359908.png)\\n\\nThen, we do as mentioned above and return to **node 1**.\\n\\nNow, we do calculations in **node 1**.\\n\\n![image.png](https://assets.leetcode.com/users/images/740f84d5-5d8e-4e28-a4b1-d142e322f74e_1673515328.6632729.png)\\n\\nIn the above figure you can see the childCounts returned from left subtree. Then, we have updated the nodeCounts array using it. We haven\\'t shown the right subtree **node 5** in this calculation.\\n\\nFinally, we calculate the `ans[1]`. You can see from the figure that we found it to be 1.\\n\\nThen, we return the updated `nodeCounts[]` we got from the subtree.\\n\\nNow, after returning at the root node:\\n\\n![image.png](https://assets.leetcode.com/users/images/99156bf0-da69-4137-bfdd-7667aca25771_1673515844.6126533.png)\\n\\n\\nWe do this calculation and update our `ans[]` array. You can see from the figure that `ans[0] = 1`. But it will be $$2$$ after we have traversed the right subtree.\\n\\n**Be aware that we have only shown the calculations of the left subtrees in the example.**\\n\\n\\nAfter our final calculation of both subtrees:\\n\\n![image.png](https://assets.leetcode.com/users/images/422b9471-e703-4e9c-858f-42188504b964_1673516013.8307922.png)\\n\\nOur final ans array will be: `ans[] = {2, 1, 1, 1, 1, 1, 1}`\\n\\n# Complexity\\n- Time complexity: $$O(26*n) = O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(26*n) = O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> adjList;\\n    int[] ans;\\n    String labels;\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        adjList = new HashMap<>();\\n        ans = new int[n];\\n        this.labels = labels;\\n        for(int[] edge : edges){\\n            List<Integer> fromList = adjList.getOrDefault(edge[0], new ArrayList<>());\\n            fromList.add(edge[1]);\\n            adjList.put(edge[0], fromList);\\n\\n            List<Integer> toList = adjList.getOrDefault(edge[1], new ArrayList<>());\\n            toList.add(edge[0]);\\n            adjList.put(edge[1], toList);\\n        }\\n        dfs(0, -1);\\n        return ans;\\n    }\\n\\n    int[] dfs(int node, int parent){\\n        char ch = labels.charAt(node);\\n        int[] nodeCounts = new int[26];\\n        nodeCounts[ch - \\'a\\'] = 1;\\n        \\n        if (!adjList.containsKey(node)){\\n            return nodeCounts;\\n        }\\n        \\n        for(Integer child : adjList.getOrDefault(node, new ArrayList<>())){\\n            if(child == parent){\\n                continue;\\n            }\\n            int[] childCounts = dfs(child, node);\\n            for (int i = 0; i < 26; i++) {\\n                nodeCounts[i] += childCounts[i];\\n            }\\n        }\\n\\n        ans[node] = nodeCounts[ch - \\'a\\'];\\n\\n        return nodeCounts;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, List<Integer>> adjList;\\n    int[] ans;\\n    String labels;\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        adjList = new HashMap<>();\\n        ans = new int[n];\\n        this.labels = labels;\\n        for(int[] edge : edges){\\n            List<Integer> fromList = adjList.getOrDefault(edge[0], new ArrayList<>());\\n            fromList.add(edge[1]);\\n            adjList.put(edge[0], fromList);\\n\\n            List<Integer> toList = adjList.getOrDefault(edge[1], new ArrayList<>());\\n            toList.add(edge[0]);\\n            adjList.put(edge[1], toList);\\n        }\\n        dfs(0, -1);\\n        return ans;\\n    }\\n\\n    int[] dfs(int node, int parent){\\n        char ch = labels.charAt(node);\\n        int[] nodeCounts = new int[26];\\n        nodeCounts[ch - \\'a\\'] = 1;\\n        \\n        if (!adjList.containsKey(node)){\\n            return nodeCounts;\\n        }\\n        \\n        for(Integer child : adjList.getOrDefault(node, new ArrayList<>())){\\n            if(child == parent){\\n                continue;\\n            }\\n            int[] childCounts = dfs(child, node);\\n            for (int i = 0; i < 26; i++) {\\n                nodeCounts[i] += childCounts[i];\\n            }\\n        }\\n\\n        ans[node] = nodeCounts[ch - \\'a\\'];\\n\\n        return nodeCounts;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038142,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=AYKZT3Mnhpg&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=12) if you are interested.\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> ans(n);\\n        vector<vector<int>> g(n);\\n        for (auto x : edges) {\\n\\t\\t\\t// x[0] can go to x[1]\\n            g[x[0]].push_back(x[1]);\\n\\t\\t\\t// x[1] can go to x[0]\\n            g[x[1]].push_back(x[0]);\\n        }\\n        // u = current node\\n        // p = parent node\\n        function<vector<int>(int, int)> dfs = [&] (int u, int p) {\\n            // count each label in the subtree\\n            vector<int> cnt(26);\\n            // init the current label\\n            cnt[labels[u] - \\'a\\'] = 1;\\n            // traverse the children of u\\n            for (auto v : g[u]) {\\n                // if v is not same as p\\n                if (p ^ v) {\\n                    // get the count of labels in subtree\\n                    vector<int> cnt2 = dfs(v, u);\\n                    // add it back to cnt\\n                    for (int i = 0; i < 26; i++) cnt[i] += cnt2[i];\\n                }\\n            }\\n            // set the answer\\n            ans[u] = cnt[labels[u] - \\'a\\'];\\n            return cnt;\\n        };\\n        dfs(0, -1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> ans(n);\\n        vector<vector<int>> g(n);\\n        for (auto x : edges) {\\n\\t\\t\\t// x[0] can go to x[1]\\n            g[x[0]].push_back(x[1]);\\n\\t\\t\\t// x[1] can go to x[0]\\n            g[x[1]].push_back(x[0]);\\n        }\\n        // u = current node\\n        // p = parent node\\n        function<vector<int>(int, int)> dfs = [&] (int u, int p) {\\n            // count each label in the subtree\\n            vector<int> cnt(26);\\n            // init the current label\\n            cnt[labels[u] - \\'a\\'] = 1;\\n            // traverse the children of u\\n            for (auto v : g[u]) {\\n                // if v is not same as p\\n                if (p ^ v) {\\n                    // get the count of labels in subtree\\n                    vector<int> cnt2 = dfs(v, u);\\n                    // add it back to cnt\\n                    for (int i = 0; i < 26; i++) cnt[i] += cnt2[i];\\n                }\\n            }\\n            // set the answer\\n            ans[u] = cnt[labels[u] - \\'a\\'];\\n            return cnt;\\n        };\\n        dfs(0, -1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038448,
                "title": "easy-c-solution-short-simple-best-method-easy-to-understand",
                "content": "# Intuition\\n Please UPVOTE if you LIKE! \\uD83D\\uDE01\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      vector<int> dfs(vector<vector<int>>& adjList, string& labels, int parent, int cur, vector<int>& ans){\\n         vector<int> counter(26, 0);\\n        char c = labels[cur]-\\'a\\';\\n        counter[c] = 1;\\n        \\n        for(int nei : adjList[cur]){\\n            if(nei != parent){\\n                vector<int> subcounter = dfs(adjList, labels, cur, nei, ans);\\n                for(int i = 0; i < counter.size(); ++i){\\n                    counter[i] += subcounter[i];\\n                }\\n            }\\n        }\\n        //since we are using dfs, now counter\\'s coverage is the subtree rooted at cur\\n        ans[cur] = counter[c];\\n        \\n        return counter;\\n    };\\n    \\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adjList(n);\\n        vector<vector<int>> counter(n, vector<int>(26, -1));\\n        \\n        //bi-directional\\n        for(vector<int>& edge : edges){\\n            adjList[edge[0]].push_back(edge[1]);\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<int> ans(n, 0);\\n        int parent = -1;\\n        \\n        dfs(adjList, labels, -1, 0, ans);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      vector<int> dfs(vector<vector<int>>& adjList, string& labels, int parent, int cur, vector<int>& ans){\\n         vector<int> counter(26, 0);\\n        char c = labels[cur]-\\'a\\';\\n        counter[c] = 1;\\n        \\n        for(int nei : adjList[cur]){\\n            if(nei != parent){\\n                vector<int> subcounter = dfs(adjList, labels, cur, nei, ans);\\n                for(int i = 0; i < counter.size(); ++i){\\n                    counter[i] += subcounter[i];\\n                }\\n            }\\n        }\\n        //since we are using dfs, now counter\\'s coverage is the subtree rooted at cur\\n        ans[cur] = counter[c];\\n        \\n        return counter;\\n    };\\n    \\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adjList(n);\\n        vector<vector<int>> counter(n, vector<int>(26, -1));\\n        \\n        //bi-directional\\n        for(vector<int>& edge : edges){\\n            adjList[edge[0]].push_back(edge[1]);\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<int> ans(n, 0);\\n        int parent = -1;\\n        \\n        dfs(adjList, labels, -1, 0, ans);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038085,
                "title": "beats-100-solutions-in-time-and-space-both",
                "content": "Just Store the count of current node in the frequency array before going for subtree traversal and then post completion of traversal ->\\n\\n ans [node]  =  total Frequency Till Now  - initialCount;\\n \\n \\n \\n ```\\n \\n class Solution {\\nprivate:\\n    \\n    void findTotalCount( int n, string &labels, vector<int>adj[], int node, vector<int>&freq, vector<int>&ans, int parent){\\n        \\n        int initial = freq[labels[node]-\\'a\\'];\\n        \\n       \\n         freq[labels[node]-\\'a\\']++;\\n            \\n        for(auto num: adj[node]){\\n            if(num == parent){\\n                continue;\\n            }\\n            \\n            findTotalCount(n, labels, adj, num, freq, ans, node);\\n        }\\n        \\n        ans[node] =  freq[labels[node]-\\'a\\'] - initial;\\n    }\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        \\n        vector<int>freq(26, 0);\\n        \\n        vector<int>adj[n];\\n        vector<int>ans(n,0);\\n        \\n        for(int index = 0; index < edges.size(); index++){\\n            \\n            adj[edges[index][0]].push_back(edges[index][1]);\\n             adj[edges[index][1]].push_back(edges[index][0]);\\n        }\\n        \\n        findTotalCount(n,labels, adj, 0, freq, ans, -1);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph",
                    "Recursion",
                    "Counting"
                ],
                "code": "```\\n \\n class Solution {\\nprivate:\\n    \\n    void findTotalCount( int n, string &labels, vector<int>adj[], int node, vector<int>&freq, vector<int>&ans, int parent){\\n        \\n        int initial = freq[labels[node]-\\'a\\'];\\n        \\n       \\n         freq[labels[node]-\\'a\\']++;\\n            \\n        for(auto num: adj[node]){\\n            if(num == parent){\\n                continue;\\n            }\\n            \\n            findTotalCount(n, labels, adj, num, freq, ans, node);\\n        }\\n        \\n        ans[node] =  freq[labels[node]-\\'a\\'] - initial;\\n    }\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        \\n        vector<int>freq(26, 0);\\n        \\n        vector<int>adj[n];\\n        vector<int>ans(n,0);\\n        \\n        for(int index = 0; index < edges.size(); index++){\\n            \\n            adj[edges[index][0]].push_back(edges[index][1]);\\n             adj[edges[index][1]].push_back(edges[index][0]);\\n        }\\n        \\n        findTotalCount(n,labels, adj, 0, freq, ans, -1);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041416,
                "title": "ett-cumulative-sum",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n * alphabet size)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * alphabet size)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code in python3\\n```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\n        # ETT\\n        time_stamp = 1\\n        start_time = [0] * n\\n        end_time = [0] * n\\n        csum = [[0] * 26 for _ in range(n + 1)]\\n\\n        def dfs(node, parent):\\n            nonlocal time_stamp\\n            start_time[node] = time_stamp\\n            csum[time_stamp][ord(labels[node]) - ord(\\'a\\')] = 1\\n            time_stamp += 1\\n            for child in graph[node]:\\n                if child != parent:\\n                    dfs(child, node)\\n            end_time[node] = time_stamp - 1\\n\\n        dfs(0, -1)\\n\\n        for i in range(1, n + 1):\\n            for j in range(26):\\n                csum[i][j] += csum[i - 1][j]\\n\\n        ans = [0] * n\\n        for i in range(n):\\n            ans[i] = csum[end_time[i]][ord(labels[i]) - ord(\\'a\\')] - csum[start_time[i] - 1][ord(labels[i]) - ord(\\'a\\')]\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\n        # ETT\\n        time_stamp = 1\\n        start_time = [0] * n\\n        end_time = [0] * n\\n        csum = [[0] * 26 for _ in range(n + 1)]\\n\\n        def dfs(node, parent):\\n            nonlocal time_stamp\\n            start_time[node] = time_stamp\\n            csum[time_stamp][ord(labels[node]) - ord(\\'a\\')] = 1\\n            time_stamp += 1\\n            for child in graph[node]:\\n                if child != parent:\\n                    dfs(child, node)\\n            end_time[node] = time_stamp - 1\\n\\n        dfs(0, -1)\\n\\n        for i in range(1, n + 1):\\n            for j in range(26):\\n                csum[i][j] += csum[i - 1][j]\\n\\n        ans = [0] * n\\n        for i in range(n):\\n            ans[i] = csum[end_time[i]][ord(labels[i]) - ord(\\'a\\')] - csum[start_time[i] - 1][ord(labels[i]) - ord(\\'a\\')]\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040026,
                "title": "java-dfs-commented-explanation",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    // globally declaring the ans array and adjacency list \\n    private int[] ans; \\n    private List<Integer>[] adj;\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        adj = new List[n];     // initialising the adjacency list\\n        for (int i = 0; i < n; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {     // populating the adjacency list\\n            adj[e[0]].add(e[1]);\\n            adj[e[1]].add(e[0]);\\n        }\\n\\n        ans = new int[n];      // initialising the answer array\\n        dfs(0, -1, labels);    // calling the dfs\\n        return ans;\\n    }\\n\\n    private int[] dfs(int currNode, int parent, String labels) {\\n        // Our DFS will go to the depth and bring us frequencies of characters present in each subtree, \\n        // go to bottom and come back to top with frequencies\\n        int[] currSubtreeFreq = new int[26];    // records the frequency of all characters in the current node\\'s subtree\\n        for (int child : adj[currNode]) {       // we look at all the nodes connected to our current node\\n            // we don\\'t want to go back to parent node where we came from\\n            if (child == parent) {  // so keep iterating if child is equal to parent              \\n                continue;\\n            }\\n            // we now call dfs to record the frequencies of all characters present in the subtree of the child\\n            int[] childSubtreeFreq = dfs(child, currNode, labels);     // child becomes new the currentNode, currentNode becomes the new parent\\n            // we update our currSubtreeFreq array after we get childSubtreeFreq array populated\\n            // because child\\'s subtree is a part of our current node\\'s subtree\\n            for (int i = 0; i < 26; i++) {      \\n                currSubtreeFreq[i] += childSubtreeFreq[i];\\n            }\\n        }\\n        // the current node is also associated to a character so we update currSubtreeFreq\\n        currSubtreeFreq[labels.charAt(currNode) - \\'a\\']++;\\n        // now, currSubtreeFreq contains the frequency of all characters present in subtree.\\n        // but now we just need the frequency of that particular character which is associated to our current node\\n        // say current node value is 1 and the letter associated is \\'a\\'. \\n        // so we need the frequency of \\'a\\'s that are in the subtree\\n        ans[currNode] = currSubtreeFreq[labels.charAt(currNode) - \\'a\\'];\\n        return currSubtreeFreq;    // we return the current subtree frequency array which will be utilised upon backtracking\\n    }\\n}\\n\\n// TC: O(e + v), SC: (e + v)\\n```\\n**PS:** \\n*Using an array of arraylists yields better runtime than using a hashmap to record the adjacency.*\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Counting"
                ],
                "code": "``` java []\\nclass Solution {\\n    // globally declaring the ans array and adjacency list \\n    private int[] ans; \\n    private List<Integer>[] adj;\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        adj = new List[n];     // initialising the adjacency list\\n        for (int i = 0; i < n; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {     // populating the adjacency list\\n            adj[e[0]].add(e[1]);\\n            adj[e[1]].add(e[0]);\\n        }\\n\\n        ans = new int[n];      // initialising the answer array\\n        dfs(0, -1, labels);    // calling the dfs\\n        return ans;\\n    }\\n\\n    private int[] dfs(int currNode, int parent, String labels) {\\n        // Our DFS will go to the depth and bring us frequencies of characters present in each subtree, \\n        // go to bottom and come back to top with frequencies\\n        int[] currSubtreeFreq = new int[26];    // records the frequency of all characters in the current node\\'s subtree\\n        for (int child : adj[currNode]) {       // we look at all the nodes connected to our current node\\n            // we don\\'t want to go back to parent node where we came from\\n            if (child == parent) {  // so keep iterating if child is equal to parent              \\n                continue;\\n            }\\n            // we now call dfs to record the frequencies of all characters present in the subtree of the child\\n            int[] childSubtreeFreq = dfs(child, currNode, labels);     // child becomes new the currentNode, currentNode becomes the new parent\\n            // we update our currSubtreeFreq array after we get childSubtreeFreq array populated\\n            // because child\\'s subtree is a part of our current node\\'s subtree\\n            for (int i = 0; i < 26; i++) {      \\n                currSubtreeFreq[i] += childSubtreeFreq[i];\\n            }\\n        }\\n        // the current node is also associated to a character so we update currSubtreeFreq\\n        currSubtreeFreq[labels.charAt(currNode) - \\'a\\']++;\\n        // now, currSubtreeFreq contains the frequency of all characters present in subtree.\\n        // but now we just need the frequency of that particular character which is associated to our current node\\n        // say current node value is 1 and the letter associated is \\'a\\'. \\n        // so we need the frequency of \\'a\\'s that are in the subtree\\n        ans[currNode] = currSubtreeFreq[labels.charAt(currNode) - \\'a\\'];\\n        return currSubtreeFreq;    // we return the current subtree frequency array which will be utilised upon backtracking\\n    }\\n}\\n\\n// TC: O(e + v), SC: (e + v)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038951,
                "title": "my-java-solution-o-n-100-faster-too-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        ArrayList<Integer> graph[]=new ArrayList[n];\\n        int i;\\n        for(i=0;i<n;i++)\\n        graph[i]=new ArrayList<>();\\n        for(i=0;i<edges.length;i++)\\n        {\\n            graph[edges[i][0]].add(edges[i][1]);\\n            graph[edges[i][1]].add(edges[i][0]);\\n        }\\n        int ans[]=new int[n];\\n        int freq[]=new int[26];\\n        boolean dp[]=new boolean[n];\\n        dfs(0,ans,freq,dp,labels,graph);\\n        return ans;\\n    }\\npublic void dfs(int i,int ans[],int freq[],boolean dp[],String s,ArrayList<Integer> graph[])\\n{\\n    if(dp[i])\\n    return;\\n    dp[i]=true;\\n    int c=s.charAt(i)-\\'a\\';\\n    int tmp=freq[c];\\n    freq[c]=1;\\n    for(int it:graph[i])\\n    dfs(it,ans,freq,dp,s,graph);\\n    ans[i]=freq[c];\\n    freq[c]+=tmp;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        ArrayList<Integer> graph[]=new ArrayList[n];\\n        int i;\\n        for(i=0;i<n;i++)\\n        graph[i]=new ArrayList<>();\\n        for(i=0;i<edges.length;i++)\\n        {\\n            graph[edges[i][0]].add(edges[i][1]);\\n            graph[edges[i][1]].add(edges[i][0]);\\n        }\\n        int ans[]=new int[n];\\n        int freq[]=new int[26];\\n        boolean dp[]=new boolean[n];\\n        dfs(0,ans,freq,dp,labels,graph);\\n        return ans;\\n    }\\npublic void dfs(int i,int ans[],int freq[],boolean dp[],String s,ArrayList<Integer> graph[])\\n{\\n    if(dp[i])\\n    return;\\n    dp[i]=true;\\n    int c=s.charAt(i)-\\'a\\';\\n    int tmp=freq[c];\\n    freq[c]=1;\\n    for(int it:graph[i])\\n    dfs(it,ans,freq,dp,s,graph);\\n    ans[i]=freq[c];\\n    freq[c]+=tmp;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038680,
                "title": "python-dfs-video-solution",
                "content": "You can check the whole explanation [here](https://youtu.be/X8WZApluMEw).\\n\\nThis is very similar to any DFS problem like calculating height of a tree.\\n\\nWe have to call it for child nodes, and then add 1  to our answer.\\n\\nBut, the catch is we just don\\'t need the result for `label` of parent. \\n\\nWe need it for all the 26 characters, because it may be useful for other ancestor nodes.\\n\\nWe are keeping a `Counter` because we can do a `+` operation, otherwise we would have to add manually for all the 26 characters.\\n\\nSo, we keep track of the count of all 26 characters in a Map for each node.\\n\\n**Time**: `O(26.N)`\\n\\n**Space**: `O26.N)`\\n\\nIf this was helpful, please Upvote, like the video and subscribe to the channel.\\n\\nCheers.\\n\\n```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        g = defaultdict(list)\\n        for a,b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n        \\n        res = [0] * n\\n\\n        def dfs(node, prev):\\n            count = Counter()\\n            label = labels[node]\\n            count[label]=1\\n            \\n            for nei in g[node]:\\n                if nei == prev:\\n                    continue\\n                count += dfs(nei, node)\\n                                    \\n            res[node] = count[label]\\n            return count\\n        \\n        dfs(0, None)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        g = defaultdict(list)\\n        for a,b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n        \\n        res = [0] * n\\n\\n        def dfs(node, prev):\\n            count = Counter()\\n            label = labels[node]\\n            count[label]=1\\n            \\n            for nei in g[node]:\\n                if nei == prev:\\n                    continue\\n                count += dfs(nei, node)\\n                                    \\n            res[node] = count[label]\\n            return count\\n        \\n        dfs(0, None)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356116,
                "title": "simple-java-solution-dfs-o-26-n",
                "content": "```\\nclass Solution {\\n    public int[] helper(char[] label,int[] res,int node,int parent,ArrayList<Integer>[] graph){\\n        int[] freq = new int[26];\\n        for(int child : graph[node]){\\n            if(child == parent) continue;\\n            int[] get = helper(label,res,child,node,graph);\\n            for(int i = 0;i<26;i++) freq[i] += get[i];\\n        }\\n        res[node] = ++freq[label[node]-\\'a\\'];\\n        return freq;\\n    }\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        char[] label = labels.toCharArray();\\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        for(int i = 0;i<n;i++) graph[i] = new ArrayList<>();\\n        for(int[] edge : edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        int[] res = new int[n];\\n        helper(label,res,0,-1,graph);\\n        return res;\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] helper(char[] label,int[] res,int node,int parent,ArrayList<Integer>[] graph){\\n        int[] freq = new int[26];\\n        for(int child : graph[node]){\\n            if(child == parent) continue;\\n            int[] get = helper(label,res,child,node,graph);\\n            for(int i = 0;i<26;i++) freq[i] += get[i];\\n        }\\n        res[node] = ++freq[label[node]-\\'a\\'];\\n        return freq;\\n    }\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        char[] label = labels.toCharArray();\\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        for(int i = 0;i<n;i++) graph[i] = new ArrayList<>();\\n        for(int[] edge : edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        int[] res = new int[n];\\n        helper(label,res,0,-1,graph);\\n        return res;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743508,
                "title": "java-dfs-counter-merge-o-n-detailed-explanation",
                "content": "Keys:\\n1) A tree, is also a connected, undirected graph that has no cycles; since the input edges are out of order and for each edge we don\\'t konw which end of this edge is the parent, thus, it\\'s better to treat this relationship as connected-neighbors instead of parent-child;\\n2) DFS: we know that 0 is always the root(start node in this undirected acyclic graph), thus during dfs, we just have to let the function to rule out the parent node from current node\\'s neighbors and we know that there\\'s no circle in this graph, therefore, this dfs works perfectly;\\n3) Counter: a node needs a counter of all the labels in its subtree(including itself), and this counter can be obatined by merging all its children\\'s counters and adding the counter of its label by 1(divide and conquer, the reason for using dfs).\\n\\nThus, here\\'s what this code does:\\n1) build map, for each edge [a, b], put a into b.neighbors and put b into a.neighbors; \\n2) DFS, starts from 0, for each node, iterate through all its children(neighbors except parent), obtain and merge all the children\\'s subtree counters(I use hashmap in this code), update the counter by increntment the counter of current node\\'s label, put current node\\'s labels\\' counter into the record map(where we store the result of this problem), then return the counter of current node;\\n3) transform the record map into the ans array, and return.\\n\\nTime: O(n)\\n1) Initialization - O(n), since there are `n-1`edges;\\n2) DFS - O(n), visit each node once & each edge once;\\n3) Transform - O(n), because of n nodes.\\n\\nSpace: O(n)\\n1) 2 Maps & ans array - O(n), because of n nodes\\n2) Counter - O(26n) -> O(n), since labels are lower-case characters, the size of each counter would not be larger than 26. \\n\\nAlso, using array with length of 26 as counter might be easier and faster.\\n```\\nclass Node{\\n    public List<Integer> neighbors;\\n    public Node(){\\n        neighbors = new ArrayList<Integer>();\\n    }\\n}\\n\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        // 1) Initialize\\n        HashMap<Integer, Node> map = new HashMap<>();\\n        for(int[] edge : edges){\\n            Node node1 = getNode(map, edge[0]);\\n            Node node2 = getNode(map, edge[1]);\\n            node1.neighbors.add(edge[1]);\\n            node2.neighbors.add(edge[0]);\\n        }\\n        \\n        // 2) DFS\\n        HashMap<Integer, Integer> record = new HashMap<>();\\n        helper(map, record, 0, labels, -1);\\n        int[] ans = new int[n];\\n        for(Map.Entry<Integer, Integer> entry : record.entrySet())\\n            ans[entry.getKey()] = entry.getValue();\\n        return ans;\\n    }\\n    \\n    public HashMap<Character, Integer> helper(HashMap<Integer, Node> map, HashMap<Integer, Integer> record, int n, String labels, int parent){\\n        Node node = getNode(map, n);\\n        HashMap<Character, Integer> counter = new HashMap<>();\\n        counter.put(labels.charAt(n), 1);\\n        for(Integer child : node.neighbors){\\n            // Parent is one of the neighbors but should not be counted as part of subtree\\n            if(child == parent)\\n                continue;\\n            HashMap<Character, Integer> childCounter = helper(map, record, child, labels, n);\\n            for(Map.Entry<Character, Integer> entry : childCounter.entrySet()){\\n                // Merge child\\'s counter\\n                Character key = entry.getKey();\\n                Integer val = entry.getValue();\\n                counter.put(key, counter.getOrDefault(key, 0) + val);\\n            }\\n        }\\n        record.put(n, counter.get(labels.charAt(n)));\\n        return counter;\\n    }\\n    \\n    \\n    public Node getNode(HashMap<Integer, Node> map, Integer n){\\n        if(map.containsKey(n))\\n            return map.get(n);\\n        Node node = new Node();\\n        map.put(n, node);\\n        return node;\\n    }\\n}\\n```\\n\\n*** Update: no need to create a node class, directly use map to store neighbors lists instead.\\n```\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        // 1) Initialize\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        for(int[] edge : edges){\\n            map.computeIfAbsent(edge[0], k -> new ArrayList<Integer>()).add(edge[1]);\\n            map.computeIfAbsent(edge[1], k -> new ArrayList<Integer>()).add(edge[0]);\\n        }\\n        \\n        // 2) DFS\\n        HashMap<Integer, Integer> record = new HashMap<>();\\n        helper(map, record, 0, labels, -1);\\n        int[] ans = new int[n];\\n        for(Map.Entry<Integer, Integer> entry : record.entrySet())\\n            ans[entry.getKey()] = entry.getValue();\\n        return ans;\\n    }\\n    \\n    public HashMap<Character, Integer> helper(HashMap<Integer, List<Integer>> map, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tHashMap<Integer, Integer> record, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint node, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tString labels, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint parent){\\n        HashMap<Character, Integer> counter = new HashMap<>();\\n        counter.put(labels.charAt(node), 1);\\n        for(Integer child : map.get(node)){\\n            // Parent is one of the neighbors but should not be counted as part of subtree\\n            if(child == parent)\\n                continue;\\n            HashMap<Character, Integer> childCounter = helper(map, record, child, labels, node);\\n            for(Map.Entry<Character, Integer> entry : childCounter.entrySet()){\\n                // Merge child\\'s counter\\n                Character key = entry.getKey();\\n                Integer val = entry.getValue();\\n                counter.put(key, counter.getOrDefault(key, 0) + val);\\n            }\\n        }\\n        record.put(node, counter.get(labels.charAt(node)));\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Node{\\n    public List<Integer> neighbors;\\n    public Node(){\\n        neighbors = new ArrayList<Integer>();\\n    }\\n}\\n\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        // 1) Initialize\\n        HashMap<Integer, Node> map = new HashMap<>();\\n        for(int[] edge : edges){\\n            Node node1 = getNode(map, edge[0]);\\n            Node node2 = getNode(map, edge[1]);\\n            node1.neighbors.add(edge[1]);\\n            node2.neighbors.add(edge[0]);\\n        }\\n        \\n        // 2) DFS\\n        HashMap<Integer, Integer> record = new HashMap<>();\\n        helper(map, record, 0, labels, -1);\\n        int[] ans = new int[n];\\n        for(Map.Entry<Integer, Integer> entry : record.entrySet())\\n            ans[entry.getKey()] = entry.getValue();\\n        return ans;\\n    }\\n    \\n    public HashMap<Character, Integer> helper(HashMap<Integer, Node> map, HashMap<Integer, Integer> record, int n, String labels, int parent){\\n        Node node = getNode(map, n);\\n        HashMap<Character, Integer> counter = new HashMap<>();\\n        counter.put(labels.charAt(n), 1);\\n        for(Integer child : node.neighbors){\\n            // Parent is one of the neighbors but should not be counted as part of subtree\\n            if(child == parent)\\n                continue;\\n            HashMap<Character, Integer> childCounter = helper(map, record, child, labels, n);\\n            for(Map.Entry<Character, Integer> entry : childCounter.entrySet()){\\n                // Merge child\\'s counter\\n                Character key = entry.getKey();\\n                Integer val = entry.getValue();\\n                counter.put(key, counter.getOrDefault(key, 0) + val);\\n            }\\n        }\\n        record.put(n, counter.get(labels.charAt(n)));\\n        return counter;\\n    }\\n    \\n    \\n    public Node getNode(HashMap<Integer, Node> map, Integer n){\\n        if(map.containsKey(n))\\n            return map.get(n);\\n        Node node = new Node();\\n        map.put(n, node);\\n        return node;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        // 1) Initialize\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        for(int[] edge : edges){\\n            map.computeIfAbsent(edge[0], k -> new ArrayList<Integer>()).add(edge[1]);\\n            map.computeIfAbsent(edge[1], k -> new ArrayList<Integer>()).add(edge[0]);\\n        }\\n        \\n        // 2) DFS\\n        HashMap<Integer, Integer> record = new HashMap<>();\\n        helper(map, record, 0, labels, -1);\\n        int[] ans = new int[n];\\n        for(Map.Entry<Integer, Integer> entry : record.entrySet())\\n            ans[entry.getKey()] = entry.getValue();\\n        return ans;\\n    }\\n    \\n    public HashMap<Character, Integer> helper(HashMap<Integer, List<Integer>> map, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tHashMap<Integer, Integer> record, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint node, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tString labels, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tint parent){\\n        HashMap<Character, Integer> counter = new HashMap<>();\\n        counter.put(labels.charAt(node), 1);\\n        for(Integer child : map.get(node)){\\n            // Parent is one of the neighbors but should not be counted as part of subtree\\n            if(child == parent)\\n                continue;\\n            HashMap<Character, Integer> childCounter = helper(map, record, child, labels, node);\\n            for(Map.Entry<Character, Integer> entry : childCounter.entrySet()){\\n                // Merge child\\'s counter\\n                Character key = entry.getKey();\\n                Integer val = entry.getValue();\\n                counter.put(key, counter.getOrDefault(key, 0) + val);\\n            }\\n        }\\n        record.put(node, counter.get(labels.charAt(node)));\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743184,
                "title": "why-answer-for-this-test-case-is-1-1-2-1",
                "content": "Why the answer for this test case is [1,1,2,1]\\n```\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n```\\n\\nShouldn\\'t it be [1,2,1,1] \\n\\nSince, 1 has a child which is also \\'e\\' and 2 is also \\'e\\' ?",
                "solutionTags": [],
                "code": "```\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3364961,
                "title": "c-easy-solution-dfs",
                "content": "# Intuition\\nAs we must count the number of characters from the leaf node, we use DFS.\\n\\n# Approach\\nWe just traverse the graph using DFS. Whenever we visit the node mark it as visited and if its children are not visited, visit them.\\n\\nHere First let us previous count of the label because the count is from parent and after traversal we get total count of label. Now total count of label - previous count of label is current count of label.\\n\\n# Complexity\\n- Time complexity:\\nO(N+M)\\n\\n- Space complexity:\\nO(H) where is maximum height of the tree.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(int node,vector<bool>&vis,vector<int>adj[],vector<int>&ans,vector<int>&freqmap,string& labels){\\n    vis[node] = 1;\\n    int prevc = freqmap[labels[node]-\\'a\\'];\\n    for(auto i:adj[node]){\\n        if(!vis[i]){\\n            dfs(i,vis,adj,ans,freqmap,labels);\\n        }\\n    }\\n    freqmap[labels[node]-\\'a\\']++;\\n    ans[node] = freqmap[labels[node]-\\'a\\']-prevc;\\n}\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int>adj[n];\\n        for(auto i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        vector<int>ans(n,0);\\n        vector<int>freqmap(26,0);\\n        vector<bool>vis(n,0);\\n        dfs(0,vis,adj,ans,freqmap,labels);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(int node,vector<bool>&vis,vector<int>adj[],vector<int>&ans,vector<int>&freqmap,string& labels){\\n    vis[node] = 1;\\n    int prevc = freqmap[labels[node]-\\'a\\'];\\n    for(auto i:adj[node]){\\n        if(!vis[i]){\\n            dfs(i,vis,adj,ans,freqmap,labels);\\n        }\\n    }\\n    freqmap[labels[node]-\\'a\\']++;\\n    ans[node] = freqmap[labels[node]-\\'a\\']-prevc;\\n}\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int>adj[n];\\n        for(auto i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        vector<int>ans(n,0);\\n        vector<int>freqmap(26,0);\\n        vector<bool>vis(n,0);\\n        dfs(0,vis,adj,ans,freqmap,labels);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041007,
                "title": "c-crisp-explanation-with-commented-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Step 1: -** Standing on root node, we will calculate the number of occurences of each alphabet i.e. ```target``` in every possible subtree.\\n**Step 2: -** Store the count in ```hash```.\\n**Step 3: -** Return the count of the desired target i.e. ```hash[target]``` simultaneously updating the value of ```res[root_node] = hash[labels[root_node]-\\'a\\']```.\\n\\nThe above process is done for each node of the tree.\\n\\n# Approach\\nThe above Intuition will result in ```TLE``` because above intuition have a time complexity of ```26^(height of the tree)``` when tree is skewed tree.\\n\\n*For complete tree it results in ```26^(height of the tree) * constant```. Here constant is sum of children of each node.*\\n\\nSo, in order to prevent repeated computations, we can store the result in a ```unordered_map<int, vector<int>> m``` and return the required target value without computing it again. \\nThus, making the time complexity ```O(N)```.\\n\\n# Complexity\\n- Time complexity: ```O(N)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(height of the tree + n + n*26)```\\nHere,\\n n - adjacency list\\n      n*26 - unordered_map \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> m;\\n\\n    int helper (vector<int> *adj, string &labels, int vertex, int target, vector<int>&res, int parent){\\n        if (m.find (vertex) != m.end ()) return m[vertex][target]; //return cached result\\n\\n        // Base condition\\n        if ((adj[vertex].size () == 1 && adj[vertex][0] == parent) || adj[vertex].size () == 0){\\n            res[vertex] = 1;\\n\\n            if (target == (labels[vertex]-\\'a\\')) return 1;\\n            return 0;\\n        }\\n\\n        vector<int> hash (26); // store coun of each alphabet\\n        \\n        //exploring each alphabet for every subtree\\n        for (int i = 0; i < 26; i++){\\n            int ans = 0;\\n            if (i == (labels[vertex]-\\'a\\')) ans++;\\n\\n            for (auto x: adj[vertex]){\\n                if (parent != x)\\n                ans += helper (adj, labels, x, i, res, vertex);\\n            }\\n\\n            hash[i] = ans;\\n        }\\n\\n        m[vertex] = hash; // caching the result\\n        res[vertex] = hash[labels[vertex]-\\'a\\'];\\n\\n        if (target == -1) return{};  // to prevent root element to give runtime error     \\n        return hash[target];\\n\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> res (n); // for result\\n        vector<int> adj [n];\\n\\n        for (int i = 0; i < edges.size (); i++){\\n            adj[edges[i][0]].push_back (edges[i][1]);\\n            adj[edges[i][1]].push_back (edges[i][0]);\\n        }\\n\\n        \\n        helper (adj, labels, 0, -1, res, 0);\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```target```\n```hash```\n```hash[target]```\n```res[root_node] = hash[labels[root_node]-\\'a\\']```\n```TLE```\n```26^(height of the tree)```\n```26^(height of the tree) * constant```\n```unordered_map<int, vector<int>> m```\n```O(N)```\n```O(N)```\n```O(height of the tree + n + n*26)```\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> m;\\n\\n    int helper (vector<int> *adj, string &labels, int vertex, int target, vector<int>&res, int parent){\\n        if (m.find (vertex) != m.end ()) return m[vertex][target]; //return cached result\\n\\n        // Base condition\\n        if ((adj[vertex].size () == 1 && adj[vertex][0] == parent) || adj[vertex].size () == 0){\\n            res[vertex] = 1;\\n\\n            if (target == (labels[vertex]-\\'a\\')) return 1;\\n            return 0;\\n        }\\n\\n        vector<int> hash (26); // store coun of each alphabet\\n        \\n        //exploring each alphabet for every subtree\\n        for (int i = 0; i < 26; i++){\\n            int ans = 0;\\n            if (i == (labels[vertex]-\\'a\\')) ans++;\\n\\n            for (auto x: adj[vertex]){\\n                if (parent != x)\\n                ans += helper (adj, labels, x, i, res, vertex);\\n            }\\n\\n            hash[i] = ans;\\n        }\\n\\n        m[vertex] = hash; // caching the result\\n        res[vertex] = hash[labels[vertex]-\\'a\\'];\\n\\n        if (target == -1) return{};  // to prevent root element to give runtime error     \\n        return hash[target];\\n\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> res (n); // for result\\n        vector<int> adj [n];\\n\\n        for (int i = 0; i < edges.size (); i++){\\n            adj[edges[i][0]].push_back (edges[i][1]);\\n            adj[edges[i][1]].push_back (edges[i][0]);\\n        }\\n\\n        \\n        helper (adj, labels, 0, -1, res, 0);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039352,
                "title": "c-dfs-hashing-simple-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust do simple dfs for traversing nodes and at each step check how many labels of subtree are equal to its parent and return the vector in which occurences are stored.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS with Hashing \\n# Complexity\\n- Time complexity:O(n*26)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`we doing dfs traversal so worse can be traversing n nodes so O(n) and 26 for checking hash map occurences`\\n- Space complexity:)(n*26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    - n can be maximum recursive call stack memory\\n    - 26 for hash table\\n\\n---\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    vector<int>ans;\\n    vector<int> dfs(int node ,int par,string &lables){\\n        vector<int>rootC(26);\\n        rootC[lables[node]-\\'a\\']=1;\\n        for(auto x:adj[node]){\\n            if(x!=par){\\n                auto childC=dfs(x,node,lables);\\n                for(int i=0;i<26;i++)rootC[i]+=childC[i];\\n            }\\n        }\\n        ans[node]=rootC[lables[node]-\\'a\\'];\\n        return rootC;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string lables) {\\n        adj.resize(n);\\n        ans.resize(n);\\n        for(auto e:edges){\\n             adj[e[0]].push_back(e[1]);\\n             adj[e[1]].push_back(e[0]);\\n        }\\n        dfs(0,-1,lables);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    vector<int>ans;\\n    vector<int> dfs(int node ,int par,string &lables){\\n        vector<int>rootC(26);\\n        rootC[lables[node]-\\'a\\']=1;\\n        for(auto x:adj[node]){\\n            if(x!=par){\\n                auto childC=dfs(x,node,lables);\\n                for(int i=0;i<26;i++)rootC[i]+=childC[i];\\n            }\\n        }\\n        ans[node]=rootC[lables[node]-\\'a\\'];\\n        return rootC;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string lables) {\\n        adj.resize(n);\\n        ans.resize(n);\\n        for(auto e:edges){\\n             adj[e[0]].push_back(e[1]);\\n             adj[e[1]].push_back(e[0]);\\n        }\\n        dfs(0,-1,lables);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038635,
                "title": "c-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSeeing it,its easy to say its DFS Problem. We are going to keep frequency count of lower char(\\'a-z\\') for each node. As we go forward we store each node char value in ans array.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(26*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    o(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //vector<int>ans;\\n    vector<vector<int>>adj;\\n    vector<int> dfs(string &labels,int node,int par,vector<int>&ans,vector<int>fre){\\n        //fre[labels[node]-\\'a\\']++;\\n        vector<int>temp = fre;\\n        for(auto x:adj[node]){\\n            if(x!=par){\\n\\n                vector<int>tem = dfs(labels,x,node,ans,temp);\\n                for(int i=0;i<fre.size();i++){\\n                    //cout<<node<<\" \"<<char(i+\\'a\\')<<\" \"<<tem[i]<<\"\\\\n\";\\n                    fre[i]+=tem[i];\\n                }\\n            }\\n        }\\n        fre[labels[node]-\\'a\\']++;\\n        ans[node] = fre[labels[node]-\\'a\\'];\\n        return fre;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        adj.resize(n);\\n        for(int i=0;i<edges.size();i++)\\n            adj[edges[i][0]].push_back(edges[i][1]),adj[edges[i][1]].push_back(edges[i][0]);\\n        vector<int>ans(n,0);\\n        vector<int>fre(26,0);\\n        dfs(labels,0,-1,ans,fre);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //vector<int>ans;\\n    vector<vector<int>>adj;\\n    vector<int> dfs(string &labels,int node,int par,vector<int>&ans,vector<int>fre){\\n        //fre[labels[node]-\\'a\\']++;\\n        vector<int>temp = fre;\\n        for(auto x:adj[node]){\\n            if(x!=par){\\n\\n                vector<int>tem = dfs(labels,x,node,ans,temp);\\n                for(int i=0;i<fre.size();i++){\\n                    //cout<<node<<\" \"<<char(i+\\'a\\')<<\" \"<<tem[i]<<\"\\\\n\";\\n                    fre[i]+=tem[i];\\n                }\\n            }\\n        }\\n        fre[labels[node]-\\'a\\']++;\\n        ans[node] = fre[labels[node]-\\'a\\'];\\n        return fre;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        adj.resize(n);\\n        for(int i=0;i<edges.size();i++)\\n            adj[edges[i][0]].push_back(edges[i][1]),adj[edges[i][1]].push_back(edges[i][0]);\\n        vector<int>ans(n,0);\\n        vector<int>fre(26,0);\\n        dfs(labels,0,-1,ans,fre);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3038304,
                "title": "c-158-1-mb-less-than-100-00-of-c-427-ms-faster-than-99-26-of-c",
                "content": "# Way 1 ( not efficient )\\n* Solving by adding counts from children at every node is obvious solution, but we need to iterate 26 times every time to add all the count \\n\\n# Way 2 ( efficient )\\n* We dont really need to add count at everynode\\n![image](https://assets.leetcode.com/users/images/808be534-15bd-4a77-9c14-7b10ce8f1bf7_1673495052.585634.png)\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &G, \\n             vector<int> &visited, \\n             string &labels, \\n             vector<int> &ans, \\n             int v, \\n             vector<int> &count \\n    ){\\n        if(visited[v]) return;\\n        visited[v] = true;\\n\\n        // before the subtree is explored\\n        int curr_label = labels[v]-\\'a\\';\\n        int count_before_exploring_subtree = count[curr_label];\\n        \\n        // explore the subtree now \\n        count[curr_label]++;\\n        for( auto u : G[v] )\\n            if(!visited[u]) dfs( G, visited, labels, ans, u, count );\\n        \\n        // after the subtree is explored\\n        int count_after_exploring_subtree = count[curr_label];\\n        ans[v] = count_after_exploring_subtree - count_before_exploring_subtree;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> ans(n);\\n        vector<vector<int>> G(n);\\n        for(auto &e : edges){\\n            G[e[0]].push_back(e[1]);\\n            G[e[1]].push_back(e[0]);\\n        }\\n        vector<int> visited(n,0);\\n        vector<int> count(26, 0);\\n        dfs( G, visited, labels, ans, 0, count);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &G, \\n             vector<int> &visited, \\n             string &labels, \\n             vector<int> &ans, \\n             int v, \\n             vector<int> &count \\n    ){\\n        if(visited[v]) return;\\n        visited[v] = true;\\n\\n        // before the subtree is explored\\n        int curr_label = labels[v]-\\'a\\';\\n        int count_before_exploring_subtree = count[curr_label];\\n        \\n        // explore the subtree now \\n        count[curr_label]++;\\n        for( auto u : G[v] )\\n            if(!visited[u]) dfs( G, visited, labels, ans, u, count );\\n        \\n        // after the subtree is explored\\n        int count_after_exploring_subtree = count[curr_label];\\n        ans[v] = count_after_exploring_subtree - count_before_exploring_subtree;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> ans(n);\\n        vector<vector<int>> G(n);\\n        for(auto &e : edges){\\n            G[e[0]].push_back(e[1]);\\n            G[e[1]].push_back(e[0]);\\n        }\\n        vector<int> visited(n,0);\\n        vector<int> count(26, 0);\\n        dfs( G, visited, labels, ans, 0, count);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037976,
                "title": "swift-dfs",
                "content": "**DFS (accepted answer)**\\n```\\nclass Solution {\\n    func countSubTrees(_ n: Int, _ edges: [[Int]], _ labels: String) -> [Int] {\\n        let graph = edges.reduce(into: Array(repeating: [Int](), count:n)) { graph, edge in \\n            graph[edge[0]].append(edge[1])\\n            graph[edge[1]].append(edge[0])\\n        }        \\n        let labels = labels.map { Int($0.asciiValue!) - 97 }\\n        var result = Array(repeating: 0, count: n)\\n        var ancestors = Array(repeating: [Int](), count: 26)\\n        \\n        func visit(_ node:Int, _ label: Int) {\\n            ancestors[label].append(node)\\n            ancestors[label].forEach { i in\\n                result[i] += 1\\n            }\\n            for child in graph[node] where result[child] == 0 {\\n                visit(child, labels[child])                \\n            }\\n            ancestors[label].removeLast()\\n        }\\n        \\n        visit(0, labels[0])\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countSubTrees(_ n: Int, _ edges: [[Int]], _ labels: String) -> [Int] {\\n        let graph = edges.reduce(into: Array(repeating: [Int](), count:n)) { graph, edge in \\n            graph[edge[0]].append(edge[1])\\n            graph[edge[1]].append(edge[0])\\n        }        \\n        let labels = labels.map { Int($0.asciiValue!) - 97 }\\n        var result = Array(repeating: 0, count: n)\\n        var ancestors = Array(repeating: [Int](), count: 26)\\n        \\n        func visit(_ node:Int, _ label: Int) {\\n            ancestors[label].append(node)\\n            ancestors[label].forEach { i in\\n                result[i] += 1\\n            }\\n            for child in graph[node] where result[child] == 0 {\\n                visit(child, labels[child])                \\n            }\\n            ancestors[label].removeLast()\\n        }\\n        \\n        visit(0, labels[0])\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743231,
                "title": "java-dfs-clean-code",
                "content": "core idea is to use dfs to count the occurance of every character in its subtree.\\n\\n```java\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        char[] lab = labels.toCharArray();\\n        List<Integer>[] adj = new List[n];\\n        for(int i = 0; i < n; i++) adj[i] = new ArrayList<>();\\n        \\n        for(int[] edge : edges){\\n            adj[edge[0]].add(edge[1]);\\n            adj[edge[1]].add(edge[0]);\\n        }\\n        \\n        int[] ans = new int[n];\\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        dfs(0, ans, adj, lab, visited);\\n\\n        return ans;\\n    }\\n    \\n    int[] dfs(int curr, int[] ans, List<Integer>[] adj, char[] lab, boolean[] visited){\\n        int[] counter = new int[128];\\n        char currChar = lab[curr];\\n        counter[currChar]++;\\n        ans[curr] = counter[currChar];\\n        \\n        for(int nxt : adj[curr]){\\n            if(visited[nxt]) continue;\\n            visited[nxt] = true;\\n            int[] nxtCounter = dfs(nxt, ans, adj, lab, visited);\\n            for(int i=0; i<128;i++){\\n                counter[i]+= nxtCounter[i];\\n            }\\n        }\\n        \\n        ans[curr] = counter[currChar];\\n        \\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        char[] lab = labels.toCharArray();\\n        List<Integer>[] adj = new List[n];\\n        for(int i = 0; i < n; i++) adj[i] = new ArrayList<>();\\n        \\n        for(int[] edge : edges){\\n            adj[edge[0]].add(edge[1]);\\n            adj[edge[1]].add(edge[0]);\\n        }\\n        \\n        int[] ans = new int[n];\\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        dfs(0, ans, adj, lab, visited);\\n\\n        return ans;\\n    }\\n    \\n    int[] dfs(int curr, int[] ans, List<Integer>[] adj, char[] lab, boolean[] visited){\\n        int[] counter = new int[128];\\n        char currChar = lab[curr];\\n        counter[currChar]++;\\n        ans[curr] = counter[currChar];\\n        \\n        for(int nxt : adj[curr]){\\n            if(visited[nxt]) continue;\\n            visited[nxt] = true;\\n            int[] nxtCounter = dfs(nxt, ans, adj, lab, visited);\\n            for(int i=0; i<128;i++){\\n                counter[i]+= nxtCounter[i];\\n            }\\n        }\\n        \\n        ans[curr] = counter[currChar];\\n        \\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039309,
                "title": "java-c-100-solution-using-depth-first-search",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java Code\\n```\\nclass Solution {\\n    public void dfs(Map<Integer, ArrayList<Integer>> graph,String labels, int[] ans, int[] freqMap,int currNode, int prevNode) {\\n       int prevCount = freqMap[labels.charAt(currNode) - \\'a\\'];\\n\\n       freqMap[labels.charAt(currNode) - \\'a\\'] += 1;\\n\\n       for (int nextNode : graph.get(currNode)) {\\n           if (prevNode == nextNode) continue;\\n           dfs(graph, labels, ans, freqMap,nextNode, currNode);\\n       }\\n\\n       ans[currNode] = freqMap[labels.charAt(currNode) - \\'a\\'] - prevCount;\\n   }\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        Map<Integer, ArrayList<Integer>> graph = new HashMap<>();\\n        int[] ans = new int[n];\\n        int[] freqMap = new int[26];\\n\\n        for(int[] edge : edges)\\n        {\\n            graph.putIfAbsent(edge[0], new ArrayList<>());\\n            graph.putIfAbsent(edge[1], new ArrayList<>());\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n\\n        dfs(graph, labels, ans, freqMap,0, 0);\\n        return ans;\\n    }\\n}\\n```\\n# C++ Code\\n```\\nclass Solution {\\n   void dfs(vector<vector<int>>& graph,string& labels, vector<int>& ans, vector<int>& freqMap,int currNode, int prevNode) {\\n       int prevCount = freqMap[labels[currNode] - \\'a\\'];\\n\\n       freqMap[labels[currNode] - \\'a\\'] += 1;\\n\\n       for (int nextNode : graph[currNode]) {\\n           if (prevNode == nextNode) continue;\\n           dfs(graph, labels, ans, freqMap,nextNode, currNode);\\n       }\\n\\n       ans[currNode] = freqMap[labels[currNode] - \\'a\\'] - prevCount;\\n   }\\n\\npublic:\\n   vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n       vector<vector<int>> graph(n, vector<int>());\\n       vector<int> ans(n, 0);\\n       vector<int> freqMap = vector<int>(26, 0);\\n\\n       for (vector<int>& edge : edges) {\\n           graph[edge[0]].push_back(edge[1]);\\n           graph[edge[1]].push_back(edge[0]);\\n       }\\n\\n       dfs(graph, labels, ans, freqMap,0, 0);\\n       return ans;\\n   }\\n};\\n```\\nUpvote and Code By: [Arnav Sharma](https://www.linkedin.com/in/arnavsharma2711/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public void dfs(Map<Integer, ArrayList<Integer>> graph,String labels, int[] ans, int[] freqMap,int currNode, int prevNode) {\\n       int prevCount = freqMap[labels.charAt(currNode) - \\'a\\'];\\n\\n       freqMap[labels.charAt(currNode) - \\'a\\'] += 1;\\n\\n       for (int nextNode : graph.get(currNode)) {\\n           if (prevNode == nextNode) continue;\\n           dfs(graph, labels, ans, freqMap,nextNode, currNode);\\n       }\\n\\n       ans[currNode] = freqMap[labels.charAt(currNode) - \\'a\\'] - prevCount;\\n   }\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        Map<Integer, ArrayList<Integer>> graph = new HashMap<>();\\n        int[] ans = new int[n];\\n        int[] freqMap = new int[26];\\n\\n        for(int[] edge : edges)\\n        {\\n            graph.putIfAbsent(edge[0], new ArrayList<>());\\n            graph.putIfAbsent(edge[1], new ArrayList<>());\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n\\n        dfs(graph, labels, ans, freqMap,0, 0);\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n   void dfs(vector<vector<int>>& graph,string& labels, vector<int>& ans, vector<int>& freqMap,int currNode, int prevNode) {\\n       int prevCount = freqMap[labels[currNode] - \\'a\\'];\\n\\n       freqMap[labels[currNode] - \\'a\\'] += 1;\\n\\n       for (int nextNode : graph[currNode]) {\\n           if (prevNode == nextNode) continue;\\n           dfs(graph, labels, ans, freqMap,nextNode, currNode);\\n       }\\n\\n       ans[currNode] = freqMap[labels[currNode] - \\'a\\'] - prevCount;\\n   }\\n\\npublic:\\n   vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n       vector<vector<int>> graph(n, vector<int>());\\n       vector<int> ans(n, 0);\\n       vector<int> freqMap = vector<int>(26, 0);\\n\\n       for (vector<int>& edge : edges) {\\n           graph[edge[0]].push_back(edge[1]);\\n           graph[edge[1]].push_back(edge[0]);\\n       }\\n\\n       dfs(graph, labels, ans, freqMap,0, 0);\\n       return ans;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038866,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> \\nWe can consider computing the answer of a parent node from its child nodes. Let\\'s say there is a node **P**, that has two children, **C1** and **C2**. If nodes **C1** and **C2** have the total count of each label **(a to z)** in their respective subtrees, then it would be easy to compute the answer for node p. Using the count of each label in **C1** and **C2**, we can compute the count in **P\\'s** subtree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create an adjacency list \\n2. Initialize an array for storing the answer of each node \\n3. Start a DFS traversal\\n* We use a dfs function to perform the traversal. For each call, pass node, parent, adj, labels and ans as the parameters. It returns an array which stores the count of each label in the node\\'s subtree. We start with node 0. We also keep track of the parent node of the current node so that we don\\u2019t visit the node\\u2019s parent as it has already been visited.\\n* Initialize an array **ncnt** to store the count of each label in the node\\'s subtree. Initialize it with 0 except for the node label, which should be 1.\\n* Iterate over all the children of the node (nodes that share an edge) and check if any child is equal to the parent. If the child is equal to the parent, we will not visit it again.\\n* If the child is not equal to the parent, recursively call the dfs function with the node as child and the parent as node. Store the count of all labels in its subtree in Ccnt.\\n* Add Ccnt to ncnt.\\nAfter looping through all the children, set the $$ans[node]$$ to $$ans[node]$$ = $$ncnt[labels[node]]$$.\\n* Return **ncnt**\\n\\n4. Retun $$ans$$\\n\\n# Complexity\\n- Time complexity: $$ O(26*N) = O(N) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(26*N) = O(N) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> helper(int node,int par,vector<vector<int>>& adj,string& labels,vector<int>& ans)\\n    {\\n        vector<int>ncnt(26); // maintaining the cnt of all the letters for currnt node\\n        ncnt[labels[node] -\\'a\\'] = 1;\\n\\n        for(auto i:adj[node])\\n        {\\n            if(i == par)\\n            {\\n                continue;\\n            }\\n\\n            vector<int>Ccnt = helper(i,node,adj,labels,ans); // calculating the count of lables for subarrays\\n            for(int j=0;j<26;j++)\\n            {\\n                ncnt[j] += Ccnt[j];\\n            }\\n        }\\n\\n        ans[node] = ncnt[labels[node] - \\'a\\'];\\n        return ncnt;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) \\n    {\\n        vector<vector<int>>adj(n);\\n\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }        \\n        \\n        vector<int>ans(n);\\n        vector<int>fans = helper(0,-1,adj,labels,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> helper(int node,int par,vector<vector<int>>& adj,string& labels,vector<int>& ans)\\n    {\\n        vector<int>ncnt(26); // maintaining the cnt of all the letters for currnt node\\n        ncnt[labels[node] -\\'a\\'] = 1;\\n\\n        for(auto i:adj[node])\\n        {\\n            if(i == par)\\n            {\\n                continue;\\n            }\\n\\n            vector<int>Ccnt = helper(i,node,adj,labels,ans); // calculating the count of lables for subarrays\\n            for(int j=0;j<26;j++)\\n            {\\n                ncnt[j] += Ccnt[j];\\n            }\\n        }\\n\\n        ans[node] = ncnt[labels[node] - \\'a\\'];\\n        return ncnt;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) \\n    {\\n        vector<vector<int>>adj(n);\\n\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }        \\n        \\n        vector<int>ans(n);\\n        vector<int>fans = helper(0,-1,adj,labels,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038263,
                "title": "the-only-optimal-solution-get-rid-of-n-26-make-it-flat-o-n-using-my-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution uses DFS (depth-first search) to traverse the tree, it starts from the root node (0) and visits all the child nodes recursively. It uses an array `alph` to store the count of each label, and an array `subtrees` to store the child nodes of each node. The function dfs() takes 6 arguments: the current node, parent node, the `alph` array, the `subtrees` array, an array `ans` to store the result, and the `labels` array. The function updates the `alph` array and `ans` array as it traverses the tree.\\n\\nMy solution uses DFS to traverse the tree, starting from the root node (0) and visiting all child nodes recursively.\\n\\nThe function dfs() takes six arguments:\\n\\n1. node: the current node that is being processed\\n2. parent: the parent node of the current node\\n3. alph: an array of size 26 to store the count of each label\\n4. subtree: an array of vectors, where subtree[i] stores the child nodes of node i\\n5. ans: an array to store the result, where ans[i] is the number of vertices in the subtree rooted at the ith vertex that have the same label as it\\n6. labels: an array of strings, where labels[i] is the label of the ith vertex\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The function starts by getting the label of the current node c and storing it in a variable temp. Then it changes the count of c in the alph array to 1. Next, it iterates through all the child nodes of the current node using the subtree array. If the child node is not the parent node, the function calls itself recursively with the child node as the current node and the current node as the parent node.\\n\\nAfter visiting all the child nodes, the function stores the count of c in the ans array at the index of the current node. Finally, it increments the count of the current node\\'s label in the alph array by the value of temp.\\n\\nThe final result is an array ans, where ans[i] is the number of vertices in the subtree rooted at the ith vertex that have the same label as it.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## Java\\n```\\nclass Solution {\\n\\n\\tprivate List<Integer>[] newList(int n) {\\n\\t\\tList<Integer>[] ans = new ArrayList[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tans[i] = new ArrayList<>();\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic int[] countSubTrees(int n, int[][] edges, String labels) {\\n\\t\\tint[] alph = new int[26];\\n\\t\\tint[] ans = new int[n];\\n\\n\\t\\tList<Integer>[] subtrees = newList(n);\\n\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\tsubtrees[edge[0]].add(edge[1]);\\n\\t\\t\\tsubtrees[edge[1]].add(edge[0]);\\n\\t\\t}\\n\\n\\t\\tdfs(0, n, alph, subtrees, ans, labels);\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate void dfs(int node, int parent, int[] alph, List<Integer>[] subtrees, int[] ans, String labels) {\\n\\t\\tint c = labels.charAt(node) - \\'a\\';\\n\\t\\tint temp = alph[c];\\n\\t\\talph[c] = 1;\\n\\n\\t\\tfor (int child : subtrees[node]) {\\n\\t\\t\\tif (child == parent)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tdfs(child, node, alph, subtrees, ans, labels);\\n\\t\\t}\\n\\n\\t\\tans[node] = alph[c];\\n\\t\\talph[c] += temp;\\n\\t}\\n}\\n```\\n\\n## Rust\\n```\\nimpl Solution {\\n    pub fn count_sub_trees(n: i32, edges: Vec<Vec<i32>>, labels: String) -> Vec<i32> {\\n        let n = n as usize;\\n        let mut alph = [0; 26];\\n        let labels = labels\\n            .into_bytes()\\n            .iter()\\n            .map(|v| (*v - 97) as usize)\\n            .collect::<Vec<usize>>();\\n        let mut ans = vec![0; n];\\n\\n        let mut subtrees = vec![Vec::new(); n];\\n        for edge in edges {\\n            let a = edge[0] as usize;\\n            let b = edge[1] as usize;\\n            subtrees[a].push(b);\\n            subtrees[b].push(a);\\n        }\\n\\n        Self::dfs(0, n, &mut alph, &subtrees, &mut ans, &labels);\\n\\n        ans\\n    }\\n\\n    fn dfs(\\n        node: usize,\\n        parent: usize,\\n        alph: &mut [usize; 26],\\n        subtree: &Vec<Vec<usize>>,\\n        ans: &mut Vec<i32>,\\n        labels: &Vec<usize>,\\n    ) {\\n        let c = labels[node];\\n        let temp = alph[c];\\n        alph[c] = 1;\\n\\n        for child in subtree[node].iter() {\\n            let child = *child;\\n            if child == parent {\\n                continue;\\n            }\\n\\n            Self::dfs(child, node, alph, subtree, ans, labels);\\n        }\\n\\n        ans[node] = alph[c] as i32;\\n        alph[c] += temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n\\tprivate List<Integer>[] newList(int n) {\\n\\t\\tList<Integer>[] ans = new ArrayList[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tans[i] = new ArrayList<>();\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic int[] countSubTrees(int n, int[][] edges, String labels) {\\n\\t\\tint[] alph = new int[26];\\n\\t\\tint[] ans = new int[n];\\n\\n\\t\\tList<Integer>[] subtrees = newList(n);\\n\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\tsubtrees[edge[0]].add(edge[1]);\\n\\t\\t\\tsubtrees[edge[1]].add(edge[0]);\\n\\t\\t}\\n\\n\\t\\tdfs(0, n, alph, subtrees, ans, labels);\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate void dfs(int node, int parent, int[] alph, List<Integer>[] subtrees, int[] ans, String labels) {\\n\\t\\tint c = labels.charAt(node) - \\'a\\';\\n\\t\\tint temp = alph[c];\\n\\t\\talph[c] = 1;\\n\\n\\t\\tfor (int child : subtrees[node]) {\\n\\t\\t\\tif (child == parent)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tdfs(child, node, alph, subtrees, ans, labels);\\n\\t\\t}\\n\\n\\t\\tans[node] = alph[c];\\n\\t\\talph[c] += temp;\\n\\t}\\n}\\n```\n```\\nimpl Solution {\\n    pub fn count_sub_trees(n: i32, edges: Vec<Vec<i32>>, labels: String) -> Vec<i32> {\\n        let n = n as usize;\\n        let mut alph = [0; 26];\\n        let labels = labels\\n            .into_bytes()\\n            .iter()\\n            .map(|v| (*v - 97) as usize)\\n            .collect::<Vec<usize>>();\\n        let mut ans = vec![0; n];\\n\\n        let mut subtrees = vec![Vec::new(); n];\\n        for edge in edges {\\n            let a = edge[0] as usize;\\n            let b = edge[1] as usize;\\n            subtrees[a].push(b);\\n            subtrees[b].push(a);\\n        }\\n\\n        Self::dfs(0, n, &mut alph, &subtrees, &mut ans, &labels);\\n\\n        ans\\n    }\\n\\n    fn dfs(\\n        node: usize,\\n        parent: usize,\\n        alph: &mut [usize; 26],\\n        subtree: &Vec<Vec<usize>>,\\n        ans: &mut Vec<i32>,\\n        labels: &Vec<usize>,\\n    ) {\\n        let c = labels[node];\\n        let temp = alph[c];\\n        alph[c] = 1;\\n\\n        for child in subtree[node].iter() {\\n            let child = *child;\\n            if child == parent {\\n                continue;\\n            }\\n\\n            Self::dfs(child, node, alph, subtree, ans, labels);\\n        }\\n\\n        ans[node] = alph[c] as i32;\\n        alph[c] += temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038052,
                "title": "rust-dfs-solution",
                "content": "I literally copy-pasted [yesterday\\'s solution](https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/solutions/3034185/rust-elixir-dfs-solution/) to use half of the code and modified the remaining.\\n\\nShame for no Elixir option...\\n# Code\\n```rust\\nimpl Solution {\\n    pub fn count_sub_trees(n: i32, edges: Vec<Vec<i32>>, labels: String) -> Vec<i32> {\\n        let mut adj = vec![Vec::new(); n as usize];\\n        for e in edges.iter() {\\n            adj[e[0] as usize].push(e[1] as usize);\\n            adj[e[1] as usize].push(e[0] as usize);\\n        }\\n        let mut ans = vec![0; n as usize];\\n        Self::dfs(n as usize, 0, &mut ans, &adj, labels.as_bytes());\\n        ans\\n    }\\n\\n    fn dfs(prev: usize, curr: usize, ans: &mut Vec<i32>, adj: &Vec<Vec<usize>>, bytes: &[u8]) -> [i32; 26] {\\n        let mut count = [0; 26];\\n        for &i in adj[curr].iter() {\\n            if i != prev {\\n                let count2 = Self::dfs(curr, i, ans, adj, bytes);\\n                for j in 0..26 {\\n                    count[j] += count2[j];\\n                }\\n            }\\n        }\\n        let abc = (bytes[curr] - b\\'a\\') as usize;\\n        count[abc] += 1;\\n        ans[curr] = count[abc];\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn count_sub_trees(n: i32, edges: Vec<Vec<i32>>, labels: String) -> Vec<i32> {\\n        let mut adj = vec![Vec::new(); n as usize];\\n        for e in edges.iter() {\\n            adj[e[0] as usize].push(e[1] as usize);\\n            adj[e[1] as usize].push(e[0] as usize);\\n        }\\n        let mut ans = vec![0; n as usize];\\n        Self::dfs(n as usize, 0, &mut ans, &adj, labels.as_bytes());\\n        ans\\n    }\\n\\n    fn dfs(prev: usize, curr: usize, ans: &mut Vec<i32>, adj: &Vec<Vec<usize>>, bytes: &[u8]) -> [i32; 26] {\\n        let mut count = [0; 26];\\n        for &i in adj[curr].iter() {\\n            if i != prev {\\n                let count2 = Self::dfs(curr, i, ans, adj, bytes);\\n                for j in 0..26 {\\n                    count[j] += count2[j];\\n                }\\n            }\\n        }\\n        let abc = (bytes[curr] - b\\'a\\') as usize;\\n        count[abc] += 1;\\n        ans[curr] = count[abc];\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3037985,
                "title": "easy-c-solution-dfs-o-n-tc-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst Thoughts were to perform dfs and return frequency of letter and keep them in ans vector.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConverted edges 2D vector to Adjcency list than performed DFS which returns frequency of all letters yet arrived.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dfs(vector<vector<int>> &x,vector<int> &ans,int i,string& labels){\\n        vector<int> a(26,0);\\n        if(ans[i]) return a;\\n        ans[i]=1;\\n        a[labels[i]-\\'a\\']++;\\n        for(int j=0;j<x[i].size();j++){\\n            vector<int> b = dfs(x,ans,x[i][j],labels);\\n            for(int k=0;k<26;k++){\\n                a[k]+=b[k];\\n            }\\n        }\\n        ans[i]=a[labels[i]-\\'a\\'];\\n        return a;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> x(n,vector<int>());\\n        for(int i=0;i<n-1;i++){\\n            x[edges[i][0]].push_back(edges[i][1]);\\n            x[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> ans(n,0);\\n        dfs(x,ans,0,labels);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dfs(vector<vector<int>> &x,vector<int> &ans,int i,string& labels){\\n        vector<int> a(26,0);\\n        if(ans[i]) return a;\\n        ans[i]=1;\\n        a[labels[i]-\\'a\\']++;\\n        for(int j=0;j<x[i].size();j++){\\n            vector<int> b = dfs(x,ans,x[i][j],labels);\\n            for(int k=0;k<26;k++){\\n                a[k]+=b[k];\\n            }\\n        }\\n        ans[i]=a[labels[i]-\\'a\\'];\\n        return a;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> x(n,vector<int>());\\n        for(int i=0;i<n-1;i++){\\n            x[edges[i][0]].push_back(edges[i][1]);\\n            x[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> ans(n,0);\\n        dfs(x,ans,0,labels);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037948,
                "title": "explained-java-dfs",
                "content": "We need to return the number of nodes in the subtree of the curr node which have the same label as current node . To do that we use a map of labels that are present in the subtree of the current node.\\nSo we use a function helper to do the same.\\n1. **node** -> an integer representing the current node being visited \\n2. **labels** -> a character array representing the labels of the nodes in the tree.\\n3. **answer**-> an integer array where answer[i] will store the number of subtrees with the same label as the i-th node.\\n4. **visited** ->a boolean array where visited[i] will be used to keep track of whether the i-th node has been visited during the traversal.\\n\\nThis funtion will return a map with all the **lables** along with their **counts** of that subtree.\\nThe **required output** is stored in the **array answer**.\\n\\n```\\nclass Solution \\n{\\n    List<Integer>[] canVisit;\\n    public int[] countSubTrees(int n, int[][] edges, String labels) \\n    {\\n        canVisit = new ArrayList[n];\\n        for(int i=0; i<n; i++)\\n            canVisit[i] = new ArrayList<>();\\n        for(int[] edge : edges)\\n        {\\n            canVisit[edge[0]].add(edge[1]);\\n            canVisit[edge[1]].add(edge[0]); \\n        }\\n        boolean[] visited = new boolean[n];\\n        int[] answer = new int[n];\\n        helper(0,labels.toCharArray(),answer,visited);\\n        return answer;\\n    }\\n    Map<Character,Integer> helper(int node, char[] labels, int[] answer, boolean[] visited)\\n    {\\n        Map<Character,Integer> currMap = new HashMap<>();\\n        visited[node] = true; \\n        for(int i : canVisit[node])\\n        {\\n            if(visited[i]) continue;\\n            Map<Character,Integer> map = helper(i, labels, answer, visited);\\n            for (var entry : map.entrySet()) \\n            {\\n                currMap.put(entry.getKey(), currMap.getOrDefault(entry.getKey(),0)+ + entry.getValue());\\n            }\\n        }\\n        currMap.put(labels[node], currMap.getOrDefault(labels[node],0)+1);\\n        answer[node] = currMap.get(labels[node]);\\n        return currMap;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    List<Integer>[] canVisit;\\n    public int[] countSubTrees(int n, int[][] edges, String labels) \\n    {\\n        canVisit = new ArrayList[n];\\n        for(int i=0; i<n; i++)\\n            canVisit[i] = new ArrayList<>();\\n        for(int[] edge : edges)\\n        {\\n            canVisit[edge[0]].add(edge[1]);\\n            canVisit[edge[1]].add(edge[0]); \\n        }\\n        boolean[] visited = new boolean[n];\\n        int[] answer = new int[n];\\n        helper(0,labels.toCharArray(),answer,visited);\\n        return answer;\\n    }\\n    Map<Character,Integer> helper(int node, char[] labels, int[] answer, boolean[] visited)\\n    {\\n        Map<Character,Integer> currMap = new HashMap<>();\\n        visited[node] = true; \\n        for(int i : canVisit[node])\\n        {\\n            if(visited[i]) continue;\\n            Map<Character,Integer> map = helper(i, labels, answer, visited);\\n            for (var entry : map.entrySet()) \\n            {\\n                currMap.put(entry.getKey(), currMap.getOrDefault(entry.getKey(),0)+ + entry.getValue());\\n            }\\n        }\\n        currMap.put(labels[node], currMap.getOrDefault(labels[node],0)+1);\\n        answer[node] = currMap.get(labels[node]);\\n        return currMap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050099,
                "title": "python-bfs-with-hashmap-process-leaves-first-using-degree-information",
                "content": "```\\n\\n\\'\\'\\'\\nw: tree traversal\\nh: we use degree as an indicator, traverse from leaves to root\\n    1) we use n * 26 matrix to store the number of label we have met at current node\\n    2) leaves have degree of 1, we traverse these leaves first, process the results of leaves\\n        to their parents, and decrease the degree of the parent by 1, if the parent degree is 1\\n        we add it to the queue\\n    3) repeat 2) until we hit root, which is always 0\\n    \\n\\'\\'\\'\\n\\nimport collections\\n\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        tree = collections.defaultdict(set)\\n        rec = [[0] * 26 for _ in range(n)]\\n        \\n        for node1, node2 in edges:\\n            tree[node1].add(node2)\\n            tree[node2].add(node1)\\n            \\n        degrees = {}\\n        deque = collections.deque([])\\n        for node in tree:\\n            degrees[node] = len(tree[node])\\n            if degrees[node] == 1:\\n                deque.append(node)\\n        \\n        \\n        while deque:\\n            node = deque.popleft()\\n            label = labels[node]\\n            position = ord(label) - ord(\\'a\\') \\n            rec[node][position] += 1 # update number of each label at current node\\n            if node != 0:\\n                parent = tree[node].pop() # we only have one element at the node\\n                degrees[parent] -= 1 # parenet degree decrease by 1\\n                tree[parent].remove(node) # remove the child from the parent\\n                for i in range(26):\\n                    rec[parent][i] += rec[node][i] #update the number of label we meet for the parent\\'s nodes\\n                    \\n                if degrees[parent] == 1: # now the parent becomes a leaf \\n                    deque.append(parent)\\n        \\n        res = [0] * n\\n        for i in range(n):\\n            position = ord(labels[i]) - ord(\\'a\\')\\n            res[i] = rec[i][position]\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\n\\'\\'\\'\\nw: tree traversal\\nh: we use degree as an indicator, traverse from leaves to root\\n    1) we use n * 26 matrix to store the number of label we have met at current node\\n    2) leaves have degree of 1, we traverse these leaves first, process the results of leaves\\n        to their parents, and decrease the degree of the parent by 1, if the parent degree is 1\\n        we add it to the queue\\n    3) repeat 2) until we hit root, which is always 0\\n    \\n\\'\\'\\'\\n\\nimport collections\\n\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        tree = collections.defaultdict(set)\\n        rec = [[0] * 26 for _ in range(n)]\\n        \\n        for node1, node2 in edges:\\n            tree[node1].add(node2)\\n            tree[node2].add(node1)\\n            \\n        degrees = {}\\n        deque = collections.deque([])\\n        for node in tree:\\n            degrees[node] = len(tree[node])\\n            if degrees[node] == 1:\\n                deque.append(node)\\n        \\n        \\n        while deque:\\n            node = deque.popleft()\\n            label = labels[node]\\n            position = ord(label) - ord(\\'a\\') \\n            rec[node][position] += 1 # update number of each label at current node\\n            if node != 0:\\n                parent = tree[node].pop() # we only have one element at the node\\n                degrees[parent] -= 1 # parenet degree decrease by 1\\n                tree[parent].remove(node) # remove the child from the parent\\n                for i in range(26):\\n                    rec[parent][i] += rec[node][i] #update the number of label we meet for the parent\\'s nodes\\n                    \\n                if degrees[parent] == 1: # now the parent becomes a leaf \\n                    deque.append(parent)\\n        \\n        res = [0] * n\\n        for i in range(n):\\n            position = ord(labels[i]) - ord(\\'a\\')\\n            res[i] = rec[i][position]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788263,
                "title": "java-dfs-solution-very-easy-to-understand",
                "content": "int[] first : the number of different labels in this node and its sub-Tree\\nmap store nodes and their child nodes\\n```\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        //define parameters\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int[] res = new int[n];\\n        boolean[] visited = new boolean[n];\\n        \\n        //initialize\\n        for(int[] edge : edges) {\\n            if(!map.containsKey(edge[0])) map.put(edge[0], new ArrayList<>());\\n            if(!map.containsKey(edge[1])) map.put(edge[1], new ArrayList<>());\\n            map.get(edge[0]).add(edge[1]);\\n            map.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        dfs(map, labels, res, 0, visited);\\n        \\n        return res;\\n    }\\n    \\n    public int[] dfs(Map<Integer, List<Integer>> map, String labels, int[] res, int start, boolean[] visited) {\\n        \\n        visited[start] = true;\\n        int[] first = new int[26];\\n\\n        first[labels.charAt(start) - \\'a\\'] ++;\\n        for(Integer i : map.get(start)) {\\n            if(!visited[i]) {\\n                int[] second = dfs(map, labels, res, i.intValue(), visited);\\n                for(int j = 0; j < 26; j ++) {\\n                    first[j] += second[j];\\n                }\\n            }\\n        }\\n        res[start] = first[labels.charAt(start) - \\'a\\'];\\n        return first;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        //define parameters\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int[] res = new int[n];\\n        boolean[] visited = new boolean[n];\\n        \\n        //initialize\\n        for(int[] edge : edges) {\\n            if(!map.containsKey(edge[0])) map.put(edge[0], new ArrayList<>());\\n            if(!map.containsKey(edge[1])) map.put(edge[1], new ArrayList<>());\\n            map.get(edge[0]).add(edge[1]);\\n            map.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        dfs(map, labels, res, 0, visited);\\n        \\n        return res;\\n    }\\n    \\n    public int[] dfs(Map<Integer, List<Integer>> map, String labels, int[] res, int start, boolean[] visited) {\\n        \\n        visited[start] = true;\\n        int[] first = new int[26];\\n\\n        first[labels.charAt(start) - \\'a\\'] ++;\\n        for(Integer i : map.get(start)) {\\n            if(!visited[i]) {\\n                int[] second = dfs(map, labels, res, i.intValue(), visited);\\n                for(int j = 0; j < 26; j ++) {\\n                    first[j] += second[j];\\n                }\\n            }\\n        }\\n        res[start] = first[labels.charAt(start) - \\'a\\'];\\n        return first;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743335,
                "title": "c-postorder-dfs",
                "content": "**Highlight:**\\nThe explicit return statement inside dfs function can be commented. \\nBut I love and insist the following formular to get a sense of security:\\n```\\nDFS = base case + recursive case\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs (int node, int parent, vector<vector<int>> &g, vector<vector<int>> &dp, const string &labels) {        \\n        dp[node][labels[node]-\\'a\\']++; \\n        if(g[node].size() == 1 && node != 0 ) return; //\\uD83D\\uDED1 base case: node is not root and out-degree is 1, it means current is leaf and we are done.\\n        for (auto &child: g[node]) { // \\uD83D\\uDE80 recursive case\\n            if (child != parent) {\\n                dfs(child, node, g, dp, labels);\\n                for (int i=0; i<26; i++)\\n                    dp[node][i] += dp[child][i];                \\n            }\\n        }              \\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> g(n);\\n        for(auto& e: edges) { // undirected graph, must record bi-direction\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        vector <vector<int>> dp(n, vector<int>(26, 0));        \\n        dfs(0, -1, g, dp, labels); // Note -1 is dummy supper root to start the logic flow, or \\'first law of motion\\'\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++) ans[i] = dp[i][labels[i]-\\'a\\'];\\n        return ans;\\n    }\\n};\\n```\\nreference: https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/discuss/743220/C%2B%2B-DFS-%2B-DP-or-Vector-Counter-Implementation",
                "solutionTags": [],
                "code": "```\\nDFS = base case + recursive case\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs (int node, int parent, vector<vector<int>> &g, vector<vector<int>> &dp, const string &labels) {        \\n        dp[node][labels[node]-\\'a\\']++; \\n        if(g[node].size() == 1 && node != 0 ) return; //\\uD83D\\uDED1 base case: node is not root and out-degree is 1, it means current is leaf and we are done.\\n        for (auto &child: g[node]) { // \\uD83D\\uDE80 recursive case\\n            if (child != parent) {\\n                dfs(child, node, g, dp, labels);\\n                for (int i=0; i<26; i++)\\n                    dp[node][i] += dp[child][i];                \\n            }\\n        }              \\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> g(n);\\n        for(auto& e: edges) { // undirected graph, must record bi-direction\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        vector <vector<int>> dp(n, vector<int>(26, 0));        \\n        dfs(0, -1, g, dp, labels); // Note -1 is dummy supper root to start the logic flow, or \\'first law of motion\\'\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++) ans[i] = dp[i][labels[i]-\\'a\\'];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040319,
                "title": "dfs-simple-readable-c",
                "content": "```\\n   //Easy\\n    void solve(int x,int p,vector<vector<int>>&adj,string &labels,vector<vector<int>>&store)\\n    {\\n        char now= labels[x];\\n        store[x][now-\\'a\\']++;\\n        for(int j:adj[x])\\n        {\\n            if(j!=p)\\n            {\\n                solve(j,x,adj,labels,store);\\n                for(int k=0;k<26;k++)\\n                {\\n                    store[x][k]+= store[j][k];\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) \\n    {\\n        vector<vector<int>>store(n,vector<int>(26,0));\\n        vector<vector<int>>adj(n);\\n        for(vector<int>x:edges)\\n        {\\n            int a= x[0]; int b=x[1];\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n     solve(0,0,adj,labels,store);   \\n     vector<int>ans;\\n     for(int i=0;i<n;i++)\\n     {\\n         char x=labels[i];\\n         ans.push_back(store[i][x-\\'a\\']);\\n     }\\n     return ans;\\n      \\n    }",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n   //Easy\\n    void solve(int x,int p,vector<vector<int>>&adj,string &labels,vector<vector<int>>&store)\\n    {\\n        char now= labels[x];\\n        store[x][now-\\'a\\']++;\\n        for(int j:adj[x])\\n        {\\n            if(j!=p)\\n            {\\n                solve(j,x,adj,labels,store);\\n                for(int k=0;k<26;k++)\\n                {\\n                    store[x][k]+= store[j][k];\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) \\n    {\\n        vector<vector<int>>store(n,vector<int>(26,0));\\n        vector<vector<int>>adj(n);\\n        for(vector<int>x:edges)\\n        {\\n            int a= x[0]; int b=x[1];\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n     solve(0,0,adj,labels,store);   \\n     vector<int>ans;\\n     for(int i=0;i<n;i++)\\n     {\\n         char x=labels[i];\\n         ans.push_back(store[i][x-\\'a\\']);\\n     }\\n     return ans;\\n      \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3039733,
                "title": "ruby-solution-t-549-ms-beats-100-m-281-7-mb-beats-100",
                "content": "# Approach\\n\\nLet me explain my approach with an example;\\n\\n![image.png](https://assets.leetcode.com/users/images/c950a483-7ad8-4178-bcd4-ea02cc37c2ad_1673549150.097833.png)\\n\\nFirstly, an empty hash `label_values` is defined. Also, `label_val` is found by using the label of a node from the hash `label_values`.\\n\\n![image.png](https://assets.leetcode.com/users/images/ac35ea86-6beb-4f5c-91dc-7cc7a4581745_1673549393.7981226.png)\\n\\nThen, the value of the `label` key of `label_values` is increased by 1.\\n\\nThen, we are repeating same procedure for next nodes.\\n\\n![image.png](https://assets.leetcode.com/users/images/4dd67d34-57d4-49a7-a787-e1818666f0e4_1673549592.0835855.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/307e1862-62bd-4615-842c-f9055c623b2d_1673549745.030707.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/052603ee-48dc-42c7-9c45-6339ebd7e635_1673549895.458853.png)\\n\\n\\nNow, node `2` doesn\\'t have a next node. So, it\\'s result value can be found by calculating the difference of the value of the key `label` of `label_values` and `label_val`; `2 - 1 => 1`\\n\\n![image.png](https://assets.leetcode.com/users/images/4e0e6d5d-ea62-484b-aba7-45c74a2a3765_1673552040.1125143.png)\\n\\nLet\\'s continue the next node of node `1`.\\n\\n![image.png](https://assets.leetcode.com/users/images/d4c8ae6b-8812-4119-8178-40198e9e82fe_1673550286.2342446.png)\\n\\nAgain, node `3` doesn\\'t have a next node. So, its result value can be found; `3 - 2 => 1`. \\n\\n![image.png](https://assets.leetcode.com/users/images/59a3c296-6ad0-4024-ba16-c78f37f08078_1673552325.7338817.png)\\n\\n\\nNow, all nodes of node `1` is checked, so the result of node `1` can be found; `1 - 0 => 1`.\\n\\n![image.png](https://assets.leetcode.com/users/images/3b9db1a3-78ee-423b-962b-54053c581ecd_1673550591.2752597.png)\\n\\n\\nLet me skip nodes `4`, `5` and `6` quickly. Basically, the previous procedure is followed for these nodes.\\n\\n![image.png](https://assets.leetcode.com/users/images/e355c1c6-2581-4ea0-a7cd-a0f7a5fc2c0d_1673550838.6619885.png)\\n\\n\\nNow, let\\'s find the result of node `0`; `4 - 0 => 4`\\n\\n![image.png](https://assets.leetcode.com/users/images/af8fd2f9-5e7e-4719-9c28-3ee725b2b9a3_1673550863.2570934.png)\\n\\nCredit: I have used [excalidraw](https://excalidraw.com/) to draw.\\n\\n# Code\\n```ruby []\\n# @param {Integer} n\\n# @param {Integer[][]} edges\\n# @param {String} labels\\n# @return {Integer[]}\\ndef count_sub_trees(n, edges, labels)\\n  @tree = build_tree(edges)  \\n\\n  count_labels(labels)  \\nend\\n\\ndef build_tree(edges)\\n  tree = { 0 => []}\\n  \\n  edges.each do |start_node, end_node|\\n    if tree[start_node]\\n      tree[start_node] << end_node\\n      tree[end_node] = []\\n    else\\n      tree[end_node] << start_node\\n      tree[start_node] = []\\n    end\\n  end\\n\\n  tree\\nend\\n\\ndef count_labels(labels)\\n  @result = []\\n  @labels = labels.split(\"\")\\n  @label_values = Hash.new(0)\\n\\n  starting_node = 0\\n  check_node(starting_node, @labels[starting_node])\\n  @result\\nend\\n\\ndef check_node(node_val, label)\\n  label_val = @label_values[ label ]\\n  @label_values[ label ] += 1\\n  @tree[node_val].each { |node| check_node(node, @labels[node]) }\\n  @result[node_val] = @label_values[label] - label_val\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby []\\n# @param {Integer} n\\n# @param {Integer[][]} edges\\n# @param {String} labels\\n# @return {Integer[]}\\ndef count_sub_trees(n, edges, labels)\\n  @tree = build_tree(edges)  \\n\\n  count_labels(labels)  \\nend\\n\\ndef build_tree(edges)\\n  tree = { 0 => []}\\n  \\n  edges.each do |start_node, end_node|\\n    if tree[start_node]\\n      tree[start_node] << end_node\\n      tree[end_node] = []\\n    else\\n      tree[end_node] << start_node\\n      tree[start_node] = []\\n    end\\n  end\\n\\n  tree\\nend\\n\\ndef count_labels(labels)\\n  @result = []\\n  @labels = labels.split(\"\")\\n  @label_values = Hash.new(0)\\n\\n  starting_node = 0\\n  check_node(starting_node, @labels[starting_node])\\n  @result\\nend\\n\\ndef check_node(node_val, label)\\n  label_val = @label_values[ label ]\\n  @label_values[ label ] += 1\\n  @tree[node_val].each { |node| check_node(node, @labels[node]) }\\n  @result[node_val] = @label_values[label] - label_val\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3039542,
                "title": "c-dfs-hashing",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> dfs(int node , vector<int> adj[] , vector<bool> &vis , string &labels , vector<int> &ans){\\n        vis[node]=true; \\n        vector<int> temp(26 ,0);\\n        for(auto adjnode : adj[node]){\\n            if(!vis[adjnode]){\\n                vector<int> lab_adjnode =  dfs(adjnode , adj , vis , labels , ans);\\n                transform (temp.begin(), temp.end(), lab_adjnode.begin(), temp.begin(), std::plus<int>());  \\n            }\\n        }\\n        temp[labels[node]-\\'a\\']++;\\n        ans[node] = temp[labels[node]-\\'a\\'];\\n        return temp;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> ans(n ,0);\\n        vector<int> adj[n];\\n        for(int i=0 ; i<edges.size() ; i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<bool> vis(n , false);\\n        dfs(0 , adj , vis , labels ,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> dfs(int node , vector<int> adj[] , vector<bool> &vis , string &labels , vector<int> &ans){\\n        vis[node]=true; \\n        vector<int> temp(26 ,0);\\n        for(auto adjnode : adj[node]){\\n            if(!vis[adjnode]){\\n                vector<int> lab_adjnode =  dfs(adjnode , adj , vis , labels , ans);\\n                transform (temp.begin(), temp.end(), lab_adjnode.begin(), temp.begin(), std::plus<int>());  \\n            }\\n        }\\n        temp[labels[node]-\\'a\\']++;\\n        ans[node] = temp[labels[node]-\\'a\\'];\\n        return temp;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> ans(n ,0);\\n        vector<int> adj[n];\\n        for(int i=0 ; i<edges.size() ; i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<bool> vis(n , false);\\n        dfs(0 , adj , vis , labels ,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039382,
                "title": "c-dfs-solution-that-beats-100-without-inner-loops",
                "content": "# Intuition\\nAs in other approaches we will build adjacency graph and use postorder DFS to get value of `answer[node]`. Also we need a frequency array `int freq[26]` to count symbols below current node.\\n\\n# Approach\\nUsing postorder DFS guarantees us that child nodes will be handled just before current node is. So all we need is to count frequency of symbol of current node in all child nodes, add 1 to it and save it to `answer[node]`.\\n\\nBut imagine we\\'ve got tree like this (first test case of question):\\n![image.png](https://assets.leetcode.com/users/images/d987e359-d5fd-4e3c-a695-f7b9791c7726_1673509897.5763085.png)\\nwhen we will handle node 6, we already handled node 4 and got `freq[\\'d\\'] = 1` and after adding 1 to it, we will get wrong result! Actually it\\'s very easy to handle. All we need is just remember old `freq[\\'d\\']`, make `freq[\\'d\\'] = 0` for current node and after we handle all of node 6 childs (if there was any) we write `answer[node] = ++freq[\\'d\\']` and restore our freq: `freq[\\'d\\'] += prevFreq`.\\n\\nThat\\'s all!\\n\\n# Complexity\\n- Time complexity: $$O(n)$$. Not even $$O(26 \\\\cdot n)$$ since we haven\\'t any inner loops!  \\n\\n- Space complexity: also $$O(n)$$ for graph structure and callstack.\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>> adj;\\n    int freq[26] = {};\\n    vector<int> answer;\\n\\n    void dfs(int node, int parent, const string& labels) {\\n        int iChar = labels[node] - \\'a\\';\\n        int prevFreq = freq[iChar];\\n        freq[iChar] = 0;\\n\\n        for (int child : adj[node]) {\\n            if (child == parent)\\n                continue;\\n            dfs(child, node, labels);\\n        }\\n\\n        answer[node] = ++freq[iChar];\\n        freq[iChar] += prevFreq;\\n    }\\n\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        adj.resize(n);\\n        // build adj graph\\n        for (const auto& edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        // get answer\\n        answer.resize(n);\\n        dfs(0, -1, labels);\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> adj;\\n    int freq[26] = {};\\n    vector<int> answer;\\n\\n    void dfs(int node, int parent, const string& labels) {\\n        int iChar = labels[node] - \\'a\\';\\n        int prevFreq = freq[iChar];\\n        freq[iChar] = 0;\\n\\n        for (int child : adj[node]) {\\n            if (child == parent)\\n                continue;\\n            dfs(child, node, labels);\\n        }\\n\\n        answer[node] = ++freq[iChar];\\n        freq[iChar] += prevFreq;\\n    }\\n\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        adj.resize(n);\\n        // build adj graph\\n        for (const auto& edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        // get answer\\n        answer.resize(n);\\n        dfs(0, -1, labels);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038326,
                "title": "fast-easy-solution",
                "content": "## Solution for today\\'s problem:\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> fun(vector<vector<int>> &adj, string &labels, int i,vector<int>&result){\\n        vector<int> ans(26, 0);\\n        result[i] = 1;\\n        ans[labels[i] - \\'a\\'] = 1;\\n        \\n        for(int j = 0; j != adj[i].size(); j++)\\n        if(!result[adj[i][j]]){\\n            vector<int> tmp = fun(adj, labels,adj[i][j],result);\\n            for(int k = 0; k != 26; k++) ans[k] += tmp[k];\\n        }\\n        \\n        result[i] = ans[labels[i] - \\'a\\'];\\n        \\n        return ans;\\n    }\\n    \\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adj(n);\\n        vector<int> result(n,0);\\n        for(int i = 0; i != edges.size(); i++)\\n        {adj[edges[i][0]].push_back(edges[i][1]);\\n        adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        fun(adj, labels, 0,result);\\n        return result;\\n    }\\n};\\n```\\n\\n*Upvote if it helped*",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> fun(vector<vector<int>> &adj, string &labels, int i,vector<int>&result){\\n        vector<int> ans(26, 0);\\n        result[i] = 1;\\n        ans[labels[i] - \\'a\\'] = 1;\\n        \\n        for(int j = 0; j != adj[i].size(); j++)\\n        if(!result[adj[i][j]]){\\n            vector<int> tmp = fun(adj, labels,adj[i][j],result);\\n            for(int k = 0; k != 26; k++) ans[k] += tmp[k];\\n        }\\n        \\n        result[i] = ans[labels[i] - \\'a\\'];\\n        \\n        return ans;\\n    }\\n    \\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adj(n);\\n        vector<int> result(n,0);\\n        for(int i = 0; i != edges.size(); i++)\\n        {adj[edges[i][0]].push_back(edges[i][1]);\\n        adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        fun(adj, labels, 0,result);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038252,
                "title": "most-optimized-python-solution-dfs-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(V+E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(V*E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dfs(self,node,grid,visited,fst,labels):\\n        visited[node]=1\\n        lst=[0]*26\\n        lst[ord(labels[node])-97]=1\\n        for i in grid[node]:\\n            if visited[i]==1:\\n                continue\\n            x=self.dfs(i,grid,visited,fst,labels)\\n            for j in range(26):\\n                lst[j]+=x[j]\\n        fst[node]=lst[ord(labels[node])-97]\\n        return lst\\n\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        grid=[[] for _ in range(n)]\\n        for i,j in edges:\\n            grid[i].append(j)\\n            grid[j].append(i)\\n\\n        visited=[0]*n\\n        fst=[0]*n\\n        self.dfs(0,grid,visited,fst,labels)\\n        return fst\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dfs(self,node,grid,visited,fst,labels):\\n        visited[node]=1\\n        lst=[0]*26\\n        lst[ord(labels[node])-97]=1\\n        for i in grid[node]:\\n            if visited[i]==1:\\n                continue\\n            x=self.dfs(i,grid,visited,fst,labels)\\n            for j in range(26):\\n                lst[j]+=x[j]\\n        fst[node]=lst[ord(labels[node])-97]\\n        return lst\\n\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        grid=[[] for _ in range(n)]\\n        for i,j in edges:\\n            grid[i].append(j)\\n            grid[j].append(i)\\n\\n        visited=[0]*n\\n        fst=[0]*n\\n        self.dfs(0,grid,visited,fst,labels)\\n        return fst\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038109,
                "title": "golang-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc countSubTrees(n int, edges [][]int, labels string) []int {\\n    ans := make([]int, n)\\n    adjList := make([][]int, n)\\n\\n    for _, edge :=  range edges {\\n        i, j := edge[0], edge[1]\\n        adjList[i] = append(adjList[i], j)\\n        adjList[j] = append(adjList[j], i)\\n    }\\n\\n    visited := make([]bool, n)\\n    _ = dfs(0, adjList, ans, labels, visited)\\n    return ans\\n}\\n\\nfunc dfs(node int, adjList [][]int, ans []int, labels string, visited []bool) []int {\\n    count := make([]int , 26)\\n    if visited[node] {\\n        return count\\n    }\\n\\n    visited[node] = true\\n    for _, child := range adjList[node] {\\n        cCount := dfs(child, adjList, ans, labels, visited)\\n        for i := range cCount {\\n            count[i] += cCount[i]\\n        }\\n    }\\n    \\n    label := int(labels[node] - \\'a\\')\\n    count[label]++\\n    ans[node] = count[label]\\n    return count\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countSubTrees(n int, edges [][]int, labels string) []int {\\n    ans := make([]int, n)\\n    adjList := make([][]int, n)\\n\\n    for _, edge :=  range edges {\\n        i, j := edge[0], edge[1]\\n        adjList[i] = append(adjList[i], j)\\n        adjList[j] = append(adjList[j], i)\\n    }\\n\\n    visited := make([]bool, n)\\n    _ = dfs(0, adjList, ans, labels, visited)\\n    return ans\\n}\\n\\nfunc dfs(node int, adjList [][]int, ans []int, labels string, visited []bool) []int {\\n    count := make([]int , 26)\\n    if visited[node] {\\n        return count\\n    }\\n\\n    visited[node] = true\\n    for _, child := range adjList[node] {\\n        cCount := dfs(child, adjList, ans, labels, visited)\\n        for i := range cCount {\\n            count[i] += cCount[i]\\n        }\\n    }\\n    \\n    label := int(labels[node] - \\'a\\')\\n    count[label]++\\n    ans[node] = count[label]\\n    return count\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3038062,
                "title": "dfs-hashmap-detailed",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n \\uD835\\uDDD7\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDD4\\uD835\\uDDFD\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF5 \\uD835\\uDDD8\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\n\\uD835\\uDDD6\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDEE\\uD835\\uDDFF\\uD835\\uDDF2 \\uD835\\uDDEE\\uD835\\uDDFD\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDF2\\uD835\\uDDF0\\uD835\\uDDF6\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF2\\uD835\\uDDF1\\nhttps://youtu.be/TRmkE98UqlI\\n# Complexity\\n- Time complexity:  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar countSubTrees = function(n, edges, labels) {\\n    labels = labels.split(\"\")\\n\\n    let adj = new Array(n)\\n    for (let i = 0; i < n; i++) {\\n        adj[i] = new Array()\\n    }\\n    for (let edge of edges) {\\n        adj[edge[0]].push(edge[1])\\n        adj[edge[1]].push(edge[0])\\n    }\\n\\n    let res = new Array(n)\\n    let dfs = function (node, parent) {\\n        let map = {}\\n        for (let neighbor of adj[node]) {\\n            if (neighbor === parent) continue\\n            let val = dfs(neighbor, node)\\n            for (let [label, count] of Object.entries(val)) {\\n                if (!map[label]) map[label] = 0\\n                map[label] += count\\n            }\\n        }\\n        if (!map[labels[node]]) map[labels[node]] = 0\\n        map[labels[node]]++\\n        res[node] = map[labels[node]]\\n        return map\\n    }\\n\\n    dfs(0)\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Counting"
                ],
                "code": "```\\nvar countSubTrees = function(n, edges, labels) {\\n    labels = labels.split(\"\")\\n\\n    let adj = new Array(n)\\n    for (let i = 0; i < n; i++) {\\n        adj[i] = new Array()\\n    }\\n    for (let edge of edges) {\\n        adj[edge[0]].push(edge[1])\\n        adj[edge[1]].push(edge[0])\\n    }\\n\\n    let res = new Array(n)\\n    let dfs = function (node, parent) {\\n        let map = {}\\n        for (let neighbor of adj[node]) {\\n            if (neighbor === parent) continue\\n            let val = dfs(neighbor, node)\\n            for (let [label, count] of Object.entries(val)) {\\n                if (!map[label]) map[label] = 0\\n                map[label] += count\\n            }\\n        }\\n        if (!map[labels[node]]) map[labels[node]] = 0\\n        map[labels[node]]++\\n        res[node] = map[labels[node]]\\n        return map\\n    }\\n\\n    dfs(0)\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3037917,
                "title": "python3-dfs-with-quick-explanation",
                "content": "# Intuition\\n\\nTraverse the tree and each node should return a vector to its parent node. The vector should  have the count of all the labels in the sub-tree of this node.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we make a graph of the tree so we can traverse it. Then we use a dfs algorithm to traverse the tree and count the number of all characters in its subtree. As we traverse, we discard the parent node from the graph of the child node so the parent node will not be revisited by the child node.\\n\\nWe use ret as our return array and we use count as our hashtable to add up all characters in the subtree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        # get vector of counts of all letters for subtree\\n        def dfs(node):\\n            count = Counter(labels[node])\\n            for child in graph[node]:\\n                # discard so no repeat\\n                graph[child].discard(node)\\n\\n                # add characters of all subtrees\\n                count += dfs(child)\\n\\n            ret[node] = count[labels[node]]\\n            return count\\n        # make graph of the tree\\n        graph = collections.defaultdict(set)\\n        for x, y in edges:\\n            graph[x].add(y)\\n            graph[y].add(x)\\n    \\n        ret = [0] * n\\n        dfs(0)\\n        return ret\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        # get vector of counts of all letters for subtree\\n        def dfs(node):\\n            count = Counter(labels[node])\\n            for child in graph[node]:\\n                # discard so no repeat\\n                graph[child].discard(node)\\n\\n                # add characters of all subtrees\\n                count += dfs(child)\\n\\n            ret[node] = count[labels[node]]\\n            return count\\n        # make graph of the tree\\n        graph = collections.defaultdict(set)\\n        for x, y in edges:\\n            graph[x].add(y)\\n            graph[y].add(x)\\n    \\n        ret = [0] * n\\n        dfs(0)\\n        return ret\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037858,
                "title": "daily-leetcoding-challenge-january-day-12",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2438511,
                "title": "dfs-with-hash-table-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int vis[100000];\\n    map<int,vector<int>> adj;\\n    void dfs(string &labels, int idx, vector<vector<int>>&ans){\\n        if(idx>=adj.size() || vis[idx])\\n            return;\\n        \\n        vis[idx] = 1;\\n        ans[idx][labels[idx]-\\'a\\']++;\\n        for(auto i:adj[idx]){\\n            if(!vis[i]){\\n                dfs(labels,i,ans);\\n                for(int k=0;k<26;k++){\\n                    ans[idx][k] += ans[i][k];\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<int> countSubTrees(int &n, vector<vector<int>>& edges, string &labels) {\\n        vector<vector<int>> ans(n,vector<int>(26));\\n        vector<int> res(n,1);\\n\\n        for(auto &i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        \\n\\t\\t// 0 is root node\\n        dfs(labels,0,ans);\\n        for(int i=0;i<n;i++){\\n            res[i] = ans[i][labels[i]-\\'a\\'];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int vis[100000];\\n    map<int,vector<int>> adj;\\n    void dfs(string &labels, int idx, vector<vector<int>>&ans){\\n        if(idx>=adj.size() || vis[idx])\\n            return;\\n        \\n        vis[idx] = 1;\\n        ans[idx][labels[idx]-\\'a\\']++;\\n        for(auto i:adj[idx]){\\n            if(!vis[i]){\\n                dfs(labels,i,ans);\\n                for(int k=0;k<26;k++){\\n                    ans[idx][k] += ans[i][k];\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<int> countSubTrees(int &n, vector<vector<int>>& edges, string &labels) {\\n        vector<vector<int>> ans(n,vector<int>(26));\\n        vector<int> res(n,1);\\n\\n        for(auto &i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        \\n\\t\\t// 0 is root node\\n        dfs(labels,0,ans);\\n        for(int i=0;i<n;i++){\\n            res[i] = ans[i][labels[i]-\\'a\\'];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354458,
                "title": "c-easy-to-understand-1-pass-dfs-solution",
                "content": "The idea is to get the count of all 26 characters from subgraphs and check the count of root character in the returned value\\nBefore evaluating a node, we need to the counts of its subtrees, so we will perform a simple bfs\\n\\n               0a----1b\\n\\t\\t\\t   |\\n\\t\\t\\t   |\\n\\t\\t\\t   2a\\n\\n2 will return 1 a\\n1 will return 1 b\\nand if 0 has some parent, then it will return 2a and 1 b to its parent\\nand lets suppose parent is having character c, then it will see that how many c\\'s are returned to it and add to its answer\\n\\n\\n**Steps**\\n1. Create ans array to store answer of each node\\n2. Create a Adjacency list graph\\n3. Run a Simple DFS\\n\\t\\tDFS-\\n\\t\\t\\t\\t1. ans[node] = 1, as the node itself will have 1 character\\t\\n\\t\\t\\t\\t2. Now we need to return the count of charecters to node\\'s parent, toReturn array will return the count of characters in current subgraph with node as root\\n\\t\\t\\t\\t3. Iterate all adjacent of nodes and get count of characters from its subgraphs and add the net count to toReturn array and update the answer for current node\\n\\t\\t\\t\\t4. Once All adjacent nodes are traversed, add the node\\'s charecter also to toReturn, toReturn[labels[node]-1] +=1\\n\\t\\t\\t\\t5. Return the count of characters in current subgraph to its parent\\n\\n\\n\\n\\n**Note-**\\nWhy we are using ans, graph and global globally?\\nfor each dfs call a copy of data is made and passed to function so there will a memory limit or time limit error thats why we are using them globally so that once created they are used everytime\\n\\n\\n\\n\\n```\\nclass Solution {\\n    vector<int> ans;\\n    vector<vector<int>> graph;\\n    string global;\\npublic:\\n    \\n    \\n    vector<int> getAns(int u, int parent){\\n        ans[u] = 1;\\n        char rootChar = global[u];\\n        vector<int> toReturn = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\\n        \\n        for(int adj : graph[u]){\\n            if(adj != parent){\\n                vector<int> c = getAns(adj, u);\\n                for(int i = 0 ; i < 26 ; i++){\\n                    toReturn[i] += c[i];\\n                } \\n                ans[u] += c[rootChar-\\'a\\'];\\n            }\\n            \\n        }\\n        toReturn[rootChar-\\'a\\'] += 1;\\n        return toReturn;\\n    }\\n    \\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        ans.resize(n);\\n        graph.resize(n);\\n        global = labels;\\n        \\n        \\n        \\n        for(vector<int> edge : edges){\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        int root = 0;\\n        int parent =  -1;  \\n        getAns(root, parent);\\n        return ans;\\n \\n    }\\n};\\n```\\n\\n*Time Complexity - O((N+E)26)*\\n*Space Complexity - O(26)*",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> ans;\\n    vector<vector<int>> graph;\\n    string global;\\npublic:\\n    \\n    \\n    vector<int> getAns(int u, int parent){\\n        ans[u] = 1;\\n        char rootChar = global[u];\\n        vector<int> toReturn = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\\n        \\n        for(int adj : graph[u]){\\n            if(adj != parent){\\n                vector<int> c = getAns(adj, u);\\n                for(int i = 0 ; i < 26 ; i++){\\n                    toReturn[i] += c[i];\\n                } \\n                ans[u] += c[rootChar-\\'a\\'];\\n            }\\n            \\n        }\\n        toReturn[rootChar-\\'a\\'] += 1;\\n        return toReturn;\\n    }\\n    \\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        ans.resize(n);\\n        graph.resize(n);\\n        global = labels;\\n        \\n        \\n        \\n        for(vector<int> edge : edges){\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        int root = 0;\\n        int parent =  -1;  \\n        getAns(root, parent);\\n        return ans;\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769896,
                "title": "c-easy-to-understand-well-commented-solution-well-explained-time-complexity-o-n",
                "content": "So the basic idea of the code is to, call all children of the node and they will return frequency array(which will have constant size of 26) telling frequency of all different labels, which we will add to current frequency array. Then we will also add current node label in frequency array. \\nThis node answer will be freqArr[currentLabel].\\nAnd then we will return this array.\\nTime Complexity : O(n)*26 => O(n)\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> countSubTreesH(unordered_map<int,vector<int>>& m,string& labels,vector<int>& ans,int node,vector<bool>& visited){\\n        visited[node]=true;\\n        char ch=labels[node];\\n        vector<int> freqLabels(26,0);\\n        vector<int> subTree;\\n        //I have to find number of descendants in all subtrees\\n        for(int i=0;i<m[node].size();i++){\\n            if(!visited[m[node][i]]){\\n                subTree=countSubTreesH(m,labels,ans,m[node][i],visited);\\n                for(int j=0;j<26;j++){\\n                    freqLabels[j]+=subTree[j];\\n                }\\n            }\\n        }\\n        //Adding root value also\\n        freqLabels[ch-\\'a\\']++;\\n        \\n        ans[node]=freqLabels[ch-\\'a\\'];\\n        visited[node]=false;\\n        return freqLabels;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        //I should return a frequency array consisiting of labels from all subtrees as labels have constant size\\n        //It will be of size 26, therefore tc will be n*26\\n        \\n        //Firstly I gotta construct this tree or undirected graph with no edges\\n        //I dont know parent child relationship edges[i][0] can be parent of edges[i][0] and vice versa also\\n        unordered_map<int,vector<int>> m;\\n        for(int i=0;i<edges.size();i++){\\n            m[edges[i][0]].push_back(edges[i][1]);\\n            m[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<bool> visited(n,false);\\n        vector<int> ans(n,0);\\n        countSubTreesH(m,labels,ans,0,visited);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> countSubTreesH(unordered_map<int,vector<int>>& m,string& labels,vector<int>& ans,int node,vector<bool>& visited){\\n        visited[node]=true;\\n        char ch=labels[node];\\n        vector<int> freqLabels(26,0);\\n        vector<int> subTree;\\n        //I have to find number of descendants in all subtrees\\n        for(int i=0;i<m[node].size();i++){\\n            if(!visited[m[node][i]]){\\n                subTree=countSubTreesH(m,labels,ans,m[node][i],visited);\\n                for(int j=0;j<26;j++){\\n                    freqLabels[j]+=subTree[j];\\n                }\\n            }\\n        }\\n        //Adding root value also\\n        freqLabels[ch-\\'a\\']++;\\n        \\n        ans[node]=freqLabels[ch-\\'a\\'];\\n        visited[node]=false;\\n        return freqLabels;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        //I should return a frequency array consisiting of labels from all subtrees as labels have constant size\\n        //It will be of size 26, therefore tc will be n*26\\n        \\n        //Firstly I gotta construct this tree or undirected graph with no edges\\n        //I dont know parent child relationship edges[i][0] can be parent of edges[i][0] and vice versa also\\n        unordered_map<int,vector<int>> m;\\n        for(int i=0;i<edges.size();i++){\\n            m[edges[i][0]].push_back(edges[i][1]);\\n            m[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<bool> visited(n,false);\\n        vector<int> ans(n,0);\\n        countSubTreesH(m,labels,ans,0,visited);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749295,
                "title": "a-few-solutions",
                "content": "Recursively traverse the tree and accumulate the count `cnt` of each character label in the input array `A` as the recursive stack unwinds.\\n\\n**Note:** Kotlin & Python3 solutions are AC, but the Javascript & C++ solutions result in TLE\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countSubTrees(N: Int, E: Array<IntArray>, A: String): IntArray {\\n        var adj = mutableMapOf<Int, MutableSet<Int>>()\\n        for (i in 0 until N)\\n            adj[i] = mutableSetOf<Int>()\\n        for ((u, v) in E) {\\n            adj[u]!!.add(v)\\n            adj[v]!!.add(u)\\n        }\\n        var ans = IntArray(N){ 0 }    \\n        fun go(u: Int = 0, seen: MutableSet<Int> = mutableSetOf<Int>(0)): MutableMap<Char, Int> {\\n            var cnt = mutableMapOf<Char, Int>()\\n            for (v in adj[u]!!) {\\n                if (seen.contains(v))\\n                    continue\\n                seen.add(v)\\n                var m = go(v, seen)\\n                for (c in \"abcdefghijklmnopqrstuvwxyz\")\\n                    cnt[c] = (cnt[c] ?: 0) + (m[c] ?: 0)\\n            }\\n            cnt[A[u]] = 1 + (cnt[A[u]] ?: 0)\\n            ans[u] = cnt[A[u]]!!\\n            return cnt\\n        }\\n        go()\\n        return ans\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countSubTrees = (N, E, A, K = 26, ans = Array(N).fill(0)) => {\\n    let ord = c => c.charCodeAt(0),\\n        key = c => ord(c) - ord(\\'a\\');\\n    let adj = new Map([...Array(N).keys()].map(i => [i, new Set()]));\\n    for (let [u, v] of E) {\\n        adj.get(u).add(v);\\n        adj.get(v).add(u);\\n    }\\n    let go = (u = 0, seen = new Set([0])) => {\\n        let cnt = new Map([...Array(K).keys()].map(c => [c, 0]));\\n        for (let v of adj.get(u)) {\\n            if (seen.has(v))\\n                continue;\\n            seen.add(v);\\n            let m = go(v, seen);\\n            for (let i = 0; i < K; ++i)\\n                cnt.set(i, cnt.get(i) + m.get(i));\\n        }\\n        cnt.set(key(A[u]), 1 + cnt.get(key(A[u])));\\n        ans[u] = cnt.get(key(A[u]));\\n        return cnt;\\n    };\\n    go();\\n    return ans;\\n};\\n\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countSubTrees(self, N: int, E: List[List[int]], A: str) -> List[int]:\\n        adj = defaultdict(set)\\n        for u, v in E:\\n            adj[u].add(v)\\n            adj[v].add(u)\\n        ans = [0] * N\\n        def go(u = 0, seen = set([0])):\\n            cnt = Counter()\\n            for v in adj[u]:\\n                if v in seen:\\n                    continue\\n                seen.add(v)\\n                cnt += go(v, seen)\\n            cnt[A[u]] += 1\\n            ans[u] = cnt[A[u]]\\n            return cnt\\n        go()\\n        return ans\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Set = unordered_set<int>;\\n    using Map = unordered_map<char, int>;\\n    using Adj = unordered_map<int, Set>;\\n    using fun = function<Map(int, Set&&)>;\\n    VI countSubTrees(int N, VVI& E, string A, Adj adj = {}) {\\n        for (auto& edge: E) {\\n            auto [u, v] = tie(edge[0], edge[1]);\\n            adj[u].insert(v);\\n            adj[v].insert(u);\\n        }\\n        VI ans(N);\\n        fun go = [&](auto u, auto&& seen) {\\n            Map cnt;\\n            for (auto v: adj[u]) {\\n                if (!seen.insert(v).second)\\n                    continue;\\n                auto m = go(v, move(seen));\\n                for (auto c{ \\'a\\' }; c <= \\'z\\'; ++c)\\n                    cnt[c] += m[c];\\n            }\\n            ans[u] = ++cnt[A[u]];\\n            return cnt;\\n        };\\n        go(0, {0});\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun countSubTrees(N: Int, E: Array<IntArray>, A: String): IntArray {\\n        var adj = mutableMapOf<Int, MutableSet<Int>>()\\n        for (i in 0 until N)\\n            adj[i] = mutableSetOf<Int>()\\n        for ((u, v) in E) {\\n            adj[u]!!.add(v)\\n            adj[v]!!.add(u)\\n        }\\n        var ans = IntArray(N){ 0 }    \\n        fun go(u: Int = 0, seen: MutableSet<Int> = mutableSetOf<Int>(0)): MutableMap<Char, Int> {\\n            var cnt = mutableMapOf<Char, Int>()\\n            for (v in adj[u]!!) {\\n                if (seen.contains(v))\\n                    continue\\n                seen.add(v)\\n                var m = go(v, seen)\\n                for (c in \"abcdefghijklmnopqrstuvwxyz\")\\n                    cnt[c] = (cnt[c] ?: 0) + (m[c] ?: 0)\\n            }\\n            cnt[A[u]] = 1 + (cnt[A[u]] ?: 0)\\n            ans[u] = cnt[A[u]]!!\\n            return cnt\\n        }\\n        go()\\n        return ans\\n    }\\n}\\n```\n```\\nlet countSubTrees = (N, E, A, K = 26, ans = Array(N).fill(0)) => {\\n    let ord = c => c.charCodeAt(0),\\n        key = c => ord(c) - ord(\\'a\\');\\n    let adj = new Map([...Array(N).keys()].map(i => [i, new Set()]));\\n    for (let [u, v] of E) {\\n        adj.get(u).add(v);\\n        adj.get(v).add(u);\\n    }\\n    let go = (u = 0, seen = new Set([0])) => {\\n        let cnt = new Map([...Array(K).keys()].map(c => [c, 0]));\\n        for (let v of adj.get(u)) {\\n            if (seen.has(v))\\n                continue;\\n            seen.add(v);\\n            let m = go(v, seen);\\n            for (let i = 0; i < K; ++i)\\n                cnt.set(i, cnt.get(i) + m.get(i));\\n        }\\n        cnt.set(key(A[u]), 1 + cnt.get(key(A[u])));\\n        ans[u] = cnt.get(key(A[u]));\\n        return cnt;\\n    };\\n    go();\\n    return ans;\\n};\\n\\n```\n```\\nclass Solution:\\n    def countSubTrees(self, N: int, E: List[List[int]], A: str) -> List[int]:\\n        adj = defaultdict(set)\\n        for u, v in E:\\n            adj[u].add(v)\\n            adj[v].add(u)\\n        ans = [0] * N\\n        def go(u = 0, seen = set([0])):\\n            cnt = Counter()\\n            for v in adj[u]:\\n                if v in seen:\\n                    continue\\n                seen.add(v)\\n                cnt += go(v, seen)\\n            cnt[A[u]] += 1\\n            ans[u] = cnt[A[u]]\\n            return cnt\\n        go()\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Set = unordered_set<int>;\\n    using Map = unordered_map<char, int>;\\n    using Adj = unordered_map<int, Set>;\\n    using fun = function<Map(int, Set&&)>;\\n    VI countSubTrees(int N, VVI& E, string A, Adj adj = {}) {\\n        for (auto& edge: E) {\\n            auto [u, v] = tie(edge[0], edge[1]);\\n            adj[u].insert(v);\\n            adj[v].insert(u);\\n        }\\n        VI ans(N);\\n        fun go = [&](auto u, auto&& seen) {\\n            Map cnt;\\n            for (auto v: adj[u]) {\\n                if (!seen.insert(v).second)\\n                    continue;\\n                auto m = go(v, move(seen));\\n                for (auto c{ \\'a\\' }; c <= \\'z\\'; ++c)\\n                    cnt[c] += m[c];\\n            }\\n            ans[u] = ++cnt[A[u]];\\n            return cnt;\\n        };\\n        go(0, {0});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743957,
                "title": "java-dfs-iterative-solution-beats-100-both-in-runtime-memory",
                "content": "**Intuition behind the algorithm:**\\n\\nA depth first search is evident given the problem statement, although to compute the Number of nodes in the sub-tree with same label we would need to maintain state bottom up. Like, each node should return it\\'s state (i.e. number of nodes with different labels in it\\'s subtree).\\n\\n**Steps**:\\n\\n1: Build a adjacency list from the given edges.\\n2: Maintain an auxiliary count array which keeps count of each character on every node in tree. Size of this is fixed to 26 because of the given constraint in problem that labels can only be lower case alphabets.\\n3: Keep a parent map to maintain parent of each node. This will be useful to return state to parent node while doing DFS.\\n4: While doing DFS, only pop the nodes from the stack when it has no nodes below it or no unvisited nodes left. While doing that, keep the result of popped node in results array & also send the state of the popped node to it\\'s parent node.\\n\\nHope this helps! Please let me know in case anyone has questions on the same.\\n\\n**PFB the working code**:\\n\\n```\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        \\n        Map<Integer, List<Integer>> adjList = new HashMap<>();\\n        \\n        for (int i = 0; i < edges.length; i++) {\\n            adjList.putIfAbsent(edges[i][0], new ArrayList<>());\\n            adjList.putIfAbsent(edges[i][1], new ArrayList<>());\\n            adjList.get(edges[i][0]).add(edges[i][1]);\\n            adjList.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        \\n        int[] result = new int[n];\\n        Arrays.fill(result, 1);\\n        \\n        Map<Integer, Integer> parent = new HashMap<>();\\n        boolean[] visited = new boolean[n];\\n        int[][] auxiliaryCount = new int[n][26];\\n        \\n        for (int i = 0; i < n; i++) {\\n            char ch = labels.charAt(i);\\n            int idx = Character.getNumericValue(ch) - 10;\\n            auxiliaryCount[i][idx] = 1;\\n        }\\n        \\n        Stack<Integer> s = new Stack<>();\\n        s.push(0);\\n        parent.put(0, null);\\n        \\n        while (!s.isEmpty()) {\\n            int val = s.peek();\\n            visited[val] = true;\\n            \\n            boolean noUnvisitedNeighbour = true;\\n            \\n            for (int neighbour : adjList.get(val)) {\\n                if (!visited[neighbour]) {\\n                    s.push(neighbour);\\n                    parent.put(neighbour, val);\\n                    noUnvisitedNeighbour = false;\\n                }\\n            }\\n            \\n            if (noUnvisitedNeighbour) {\\n                char ch = labels.charAt(val);\\n                int idx = Character.getNumericValue(ch) - 10;\\n                result[val] = auxiliaryCount[val][idx];\\n                \\n                Integer p = parent.get(val);\\n                \\n                if (p != null) {\\n                    for (int i = 0; i < 26; i++) {\\n                        auxiliaryCount[p][i] += auxiliaryCount[val][i];\\n                    }\\n                }\\n                \\n                s.pop();\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        \\n        Map<Integer, List<Integer>> adjList = new HashMap<>();\\n        \\n        for (int i = 0; i < edges.length; i++) {\\n            adjList.putIfAbsent(edges[i][0], new ArrayList<>());\\n            adjList.putIfAbsent(edges[i][1], new ArrayList<>());\\n            adjList.get(edges[i][0]).add(edges[i][1]);\\n            adjList.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        \\n        int[] result = new int[n];\\n        Arrays.fill(result, 1);\\n        \\n        Map<Integer, Integer> parent = new HashMap<>();\\n        boolean[] visited = new boolean[n];\\n        int[][] auxiliaryCount = new int[n][26];\\n        \\n        for (int i = 0; i < n; i++) {\\n            char ch = labels.charAt(i);\\n            int idx = Character.getNumericValue(ch) - 10;\\n            auxiliaryCount[i][idx] = 1;\\n        }\\n        \\n        Stack<Integer> s = new Stack<>();\\n        s.push(0);\\n        parent.put(0, null);\\n        \\n        while (!s.isEmpty()) {\\n            int val = s.peek();\\n            visited[val] = true;\\n            \\n            boolean noUnvisitedNeighbour = true;\\n            \\n            for (int neighbour : adjList.get(val)) {\\n                if (!visited[neighbour]) {\\n                    s.push(neighbour);\\n                    parent.put(neighbour, val);\\n                    noUnvisitedNeighbour = false;\\n                }\\n            }\\n            \\n            if (noUnvisitedNeighbour) {\\n                char ch = labels.charAt(val);\\n                int idx = Character.getNumericValue(ch) - 10;\\n                result[val] = auxiliaryCount[val][idx];\\n                \\n                Integer p = parent.get(val);\\n                \\n                if (p != null) {\\n                    for (int i = 0; i < 26; i++) {\\n                        auxiliaryCount[p][i] += auxiliaryCount[val][i];\\n                    }\\n                }\\n                \\n                s.pop();\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743376,
                "title": "java-clean-bfs",
                "content": "```\\npublic int[] countSubTrees(int n, int[][] edges, String labels) {\\n\\tList<Integer>[] list = new List[n];\\n\\tint[] indegree = new int[n];``\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tlist[i] = new ArrayList<>();\\n\\t}\\n\\tfor (int[] edge : edges) {//build tree\\n\\t\\tlist[edge[0]].add(edge[1]);\\n\\t\\tlist[edge[1]].add(edge[0]);\\n\\t\\tindegree[edge[0]]++;\\n\\t\\tindegree[edge[1]]++;\\n\\t}\\n\\tindegree[0]++;\\n\\t//0 is the root node, consider this case: [(0,1), (1, 2),(0,3)].\\n\\t//I want to traverse node 0 after traverse both 2 and 3,\\n\\t//so indegre[0]++.\\n\\n\\n\\n\\t//bfs code\\n\\t//map[i] means the number of all characters for node i(map[i] is an 1d array).\\n\\tboolean[] visit = new boolean[n];\\n\\tQueue<Integer> q = new LinkedList<>();\\n\\tint[][] map = new int[n][128];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tmap[i][labels.charAt(i)]++;//initial map\\n\\t}\\n\\tfor (int i = 1; i < n; i++) {//initial indegree array\\n\\t\\tif (indegree[i] == 1) {\\n\\t\\t\\tq.offer(i);\\n\\t\\t\\tvisit[i] = true;\\n\\t\\t``}\\n\\t}\\n\\tint[] res = new int[n];\\n\\twhile (!q.isEmpty()) {\\n\\t\\tint cur = q.poll();\\n\\t\\tres[cur] = map[cur][labels.charAt(cur)];\\n\\t\\tfor (int next : list[cur]) {\\n\\t\\t\\tif (!visit[next]) {\\n\\t\\t\\t\\tif (--indegree[next] == 1) {\\n\\t\\t\\t\\t\\tq.offer(next);\\n\\t\\t\\t\\t\\tvisit[next] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tadd(map[next], map[cur]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n\\npublic void add(int[] map1, int[] map2) {\\n\\tfor (int i = 0; i < 128; i++) {\\n\\t\\tmap1[i] += map2[i];\\n\\t}\\n}\\n\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int[] countSubTrees(int n, int[][] edges, String labels) {\\n\\tList<Integer>[] list = new List[n];\\n\\tint[] indegree = new int[n];``\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tlist[i] = new ArrayList<>();\\n\\t}\\n\\tfor (int[] edge : edges) {//build tree\\n\\t\\tlist[edge[0]].add(edge[1]);\\n\\t\\tlist[edge[1]].add(edge[0]);\\n\\t\\tindegree[edge[0]]++;\\n\\t\\tindegree[edge[1]]++;\\n\\t}\\n\\tindegree[0]++;\\n\\t//0 is the root node, consider this case: [(0,1), (1, 2),(0,3)].\\n\\t//I want to traverse node 0 after traverse both 2 and 3,\\n\\t//so indegre[0]++.\\n\\n\\n\\n\\t//bfs code\\n\\t//map[i] means the number of all characters for node i(map[i] is an 1d array).\\n\\tboolean[] visit = new boolean[n];\\n\\tQueue<Integer> q = new LinkedList<>();\\n\\tint[][] map = new int[n][128];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tmap[i][labels.charAt(i)]++;//initial map\\n\\t}\\n\\tfor (int i = 1; i < n; i++) {//initial indegree array\\n\\t\\tif (indegree[i] == 1) {\\n\\t\\t\\tq.offer(i);\\n\\t\\t\\tvisit[i] = true;\\n\\t\\t``}\\n\\t}\\n\\tint[] res = new int[n];\\n\\twhile (!q.isEmpty()) {\\n\\t\\tint cur = q.poll();\\n\\t\\tres[cur] = map[cur][labels.charAt(cur)];\\n\\t\\tfor (int next : list[cur]) {\\n\\t\\t\\tif (!visit[next]) {\\n\\t\\t\\t\\tif (--indegree[next] == 1) {\\n\\t\\t\\t\\t\\tq.offer(next);\\n\\t\\t\\t\\t\\tvisit[next] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tadd(map[next], map[cur]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n\\npublic void add(int[] map1, int[] map2) {\\n\\tfor (int i = 0; i < 128; i++) {\\n\\t\\tmap1[i] += map2[i];\\n\\t}\\n}\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 743357,
                "title": "c-simple-solution-used-hints",
                "content": "```\\npublic class Solution {\\n    public int[] CountSubTrees(int n, int[][] edges, string labels) \\n    {\\n        List<List<int>> adj = new List<List<int>>(n);\\n        \\n        for(int i=0;i<n;i++)\\n            adj.Add(new List<int>());\\n        \\n        for(int i=0;i<edges.Length;i++)\\n        {\\n            adj[edges[i][0]].Add(edges[i][1]);\\n            adj[edges[i][1]].Add(edges[i][0]);\\n        }\\n        \\n        int[] ans = new int[n];\\n        int[] visited = new int[n];\\n        Dfs(adj,0,labels,visited,ans);\\n        return ans;\\n    }\\n    \\n    private int[] Dfs(List<List<int>> adj, int root, string labels,int[] visited,int[] ans)\\n    {\\n        if(visited[root]==1)\\n            return new int[26];\\n        \\n        int[] charCount = new int[26];\\n        charCount[labels[root]-\\'a\\']++;\\n        visited[root] = 1;\\n            \\n        for(int i=0; i<adj[root].Count; i++)\\n        {\\n            int[] chCnt = Dfs(adj,adj[root][i],labels,visited,ans);\\n            \\n            for(int j=0;j<26;j++)\\n                charCount[j]+=chCnt[j];\\n        }\\n        \\n        ans[root] = charCount[labels[root]-\\'a\\'];\\n        \\n        return charCount;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] CountSubTrees(int n, int[][] edges, string labels) \\n    {\\n        List<List<int>> adj = new List<List<int>>(n);\\n        \\n        for(int i=0;i<n;i++)\\n            adj.Add(new List<int>());\\n        \\n        for(int i=0;i<edges.Length;i++)\\n        {\\n            adj[edges[i][0]].Add(edges[i][1]);\\n            adj[edges[i][1]].Add(edges[i][0]);\\n        }\\n        \\n        int[] ans = new int[n];\\n        int[] visited = new int[n];\\n        Dfs(adj,0,labels,visited,ans);\\n        return ans;\\n    }\\n    \\n    private int[] Dfs(List<List<int>> adj, int root, string labels,int[] visited,int[] ans)\\n    {\\n        if(visited[root]==1)\\n            return new int[26];\\n        \\n        int[] charCount = new int[26];\\n        charCount[labels[root]-\\'a\\']++;\\n        visited[root] = 1;\\n            \\n        for(int i=0; i<adj[root].Count; i++)\\n        {\\n            int[] chCnt = Dfs(adj,adj[root][i],labels,visited,ans);\\n            \\n            for(int j=0;j<26;j++)\\n                charCount[j]+=chCnt[j];\\n        }\\n        \\n        ans[root] = charCount[labels[root]-\\'a\\'];\\n        \\n        return charCount;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743351,
                "title": "simple-python-3-solution-dfs",
                "content": "\\tTerrible description for the question, as mentioned got stuck in the [0, 2], [0, 3] and [1, 2] question as well. The key missing point is that you can only traverse the tree from the root.\\n\\t\\nHere is a simple python3 dfs solution: \\n```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        \\n        graph = defaultdict(list)\\n        val = dict()\\n        \\n        res = [0] * n\\n        \\n        for i in range(n):\\n            graph[i] = []\\n        \\n        for i, (s, d) in enumerate(edges):\\n            graph[s].append(d)\\n            graph[d].append(s)\\n            val[s] = labels[s]\\n            val[d] = labels[d]\\n\\n        \\n        def dfs(node, counter, parent):\\n            for neigh in graph[node]:\\n                if neigh != parent:\\n                    dfs_res = dfs(neigh, defaultdict(int), node)\\n                    for v in dfs_res:\\n                        counter[v] += dfs_res[v]\\n                \\n            counter[val[node]] += 1\\n            res[node] = counter[val[node]]\\n            return counter\\n            \\n        dfs(0, defaultdict(int), -1)\\n        \\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        \\n        graph = defaultdict(list)\\n        val = dict()\\n        \\n        res = [0] * n\\n        \\n        for i in range(n):\\n            graph[i] = []\\n        \\n        for i, (s, d) in enumerate(edges):\\n            graph[s].append(d)\\n            graph[d].append(s)\\n            val[s] = labels[s]\\n            val[d] = labels[d]\\n\\n        \\n        def dfs(node, counter, parent):\\n            for neigh in graph[node]:\\n                if neigh != parent:\\n                    dfs_res = dfs(neigh, defaultdict(int), node)\\n                    for v in dfs_res:\\n                        counter[v] += dfs_res[v]\\n                \\n            counter[val[node]] += 1\\n            res[node] = counter[val[node]]\\n            return counter\\n            \\n        dfs(0, defaultdict(int), -1)\\n        \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043090,
                "title": "c-o-n-algorithm-to-support-o-n-label",
                "content": "```C++\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> mp;//mapping vertex to its neighborhoods\\n    vector<int> count; //count number for each node according to the condition of same label.\\n    unordered_map<int, vector<int>> stks; \\n    \\n    //the same label\\'s stack for DFS to trace their same label parent(closest ancestor with same label)    \\n    vector<bool> visited;//for DFS algorithm to check travel status\\n    string labels;\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labelss) {\\n        count = vector<int>(n,0);\\n        \\n        labels = labelss;\\n        visited = vector<bool>(n,false);\\n        for(auto &e: edges) {\\n            mp[e[0]].push_back(e[1]);\\n            mp[e[1]].push_back(e[0]);\\n        }\\n        dfs(0);\\n        return count;\\n    }\\n    \\n    void dfs(int root) {\\n        visited[root] = true;\\n        count[root] = 1;\\n        //get the closest ancestor of root with same label\\n        int parent_node = -1;\\n        \\n        if(!stks[labels[root]].empty()) \\n            parent_node = stks[labels[root]].back();\\n        \\n        stks[labels[root]].push_back(root);\\n        for(auto &child: mp[root]) \\n            if(visited[child] == false) \\n                dfs(child);\\n        stks[labels[root]].pop_back();\\n        \\n        if(parent_node>=0) \\n            count[parent_node] = count[parent_node] + count[root];\\n    }\\n};\\n```\\n\\n# Complexity \\ntime complexity O(N)\\nspace complexity O(N)",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> mp;//mapping vertex to its neighborhoods\\n    vector<int> count; //count number for each node according to the condition of same label.\\n    unordered_map<int, vector<int>> stks; \\n    \\n    //the same label\\'s stack for DFS to trace their same label parent(closest ancestor with same label)    \\n    vector<bool> visited;//for DFS algorithm to check travel status\\n    string labels;\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labelss) {\\n        count = vector<int>(n,0);\\n        \\n        labels = labelss;\\n        visited = vector<bool>(n,false);\\n        for(auto &e: edges) {\\n            mp[e[0]].push_back(e[1]);\\n            mp[e[1]].push_back(e[0]);\\n        }\\n        dfs(0);\\n        return count;\\n    }\\n    \\n    void dfs(int root) {\\n        visited[root] = true;\\n        count[root] = 1;\\n        //get the closest ancestor of root with same label\\n        int parent_node = -1;\\n        \\n        if(!stks[labels[root]].empty()) \\n            parent_node = stks[labels[root]].back();\\n        \\n        stks[labels[root]].push_back(root);\\n        for(auto &child: mp[root]) \\n            if(visited[child] == false) \\n                dfs(child);\\n        stks[labels[root]].pop_back();\\n        \\n        if(parent_node>=0) \\n            count[parent_node] = count[parent_node] + count[root];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042335,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> g[100005];\\n\\n    vector<int> dfs(int u, int parent, string& labels, vector<int>& ans) {\\n        vector<int> nodeCounts(26);\\n        nodeCounts[labels[u] - \\'a\\'] = 1;\\n        for(auto v: g[u]) {\\n            if(v == parent) continue;\\n            vector<int> childCounts = dfs(v, u, labels, ans);\\n            for (int i=0; i<26; i++) {\\n                nodeCounts[i] += childCounts[i];\\n            }\\n        }\\n        ans[u] = nodeCounts[labels[u] - \\'a\\'];\\n        return nodeCounts;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        for(auto x: edges) {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n        }\\n        vector<int> ans(n, 0);\\n        dfs(0, -1, labels, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> g[100005];\\n\\n    vector<int> dfs(int u, int parent, string& labels, vector<int>& ans) {\\n        vector<int> nodeCounts(26);\\n        nodeCounts[labels[u] - \\'a\\'] = 1;\\n        for(auto v: g[u]) {\\n            if(v == parent) continue;\\n            vector<int> childCounts = dfs(v, u, labels, ans);\\n            for (int i=0; i<26; i++) {\\n                nodeCounts[i] += childCounts[i];\\n            }\\n        }\\n        ans[u] = nodeCounts[labels[u] - \\'a\\'];\\n        return nodeCounts;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        for(auto x: edges) {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n        }\\n        vector<int> ans(n, 0);\\n        dfs(0, -1, labels, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041253,
                "title": "java-solution-using-recursion-very-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n                List<List<Integer>> graph = new ArrayList<List<Integer>>();\\n                for(int i = 0; i<n ; i++) graph.add(new ArrayList<Integer>());\\n                for(int[] edge : edges){\\n                    graph.get(edge[0]).add(edge[1]);\\n                    graph.get(edge[1]).add(edge[0]);\\n                }\\n                int[] ans = new int[n];\\n                int[] visited = new int[n];\\n                find(0,graph,ans,labels,visited);\\n                return ans;\\n    }\\n    public int[] find(int node,List<List<Integer>> graph,int[] ans,String labels,int[] visited)\\n{\\n    int[] curr = new int[26];\\n    visited[node] = 1;\\n    for(int i : graph.get(node)){\\n        if(visited[i]==0){\\n        int[] contains = find(i,graph,ans,labels,visited);\\n        for(int ind = 0; ind<26; ind++) curr[ind]+=contains[ind];\\n        }\\n    }\\n    curr[labels.charAt(node)-\\'a\\']++;\\n    ans[node] = curr[labels.charAt(node)-\\'a\\'];\\n    return curr;\\n}}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n                List<List<Integer>> graph = new ArrayList<List<Integer>>();\\n                for(int i = 0; i<n ; i++) graph.add(new ArrayList<Integer>());\\n                for(int[] edge : edges){\\n                    graph.get(edge[0]).add(edge[1]);\\n                    graph.get(edge[1]).add(edge[0]);\\n                }\\n                int[] ans = new int[n];\\n                int[] visited = new int[n];\\n                find(0,graph,ans,labels,visited);\\n                return ans;\\n    }\\n    public int[] find(int node,List<List<Integer>> graph,int[] ans,String labels,int[] visited)\\n{\\n    int[] curr = new int[26];\\n    visited[node] = 1;\\n    for(int i : graph.get(node)){\\n        if(visited[i]==0){\\n        int[] contains = find(i,graph,ans,labels,visited);\\n        for(int ind = 0; ind<26; ind++) curr[ind]+=contains[ind];\\n        }\\n    }\\n    curr[labels.charAt(node)-\\'a\\']++;\\n    ans[node] = curr[labels.charAt(node)-\\'a\\'];\\n    return curr;\\n}}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040966,
                "title": "java-dfs-easy-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[] array;\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n\\n        array = new int[n]; //output array\\n    \\n        //creating adjacency list\\n        ArrayList<Integer>[] a = new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            a[i] = new ArrayList<Integer>();\\n        }\\n\\n        for(int[] x:edges){\\n            a[x[0]].add(x[1]);\\n            a[x[1]].add(x[0]);\\n        }\\n\\n        dfs(-1,0,a,labels);\\n        return array;\\n    }\\n\\n    private int[] dfs(int prev,int curr,ArrayList<Integer>[] a,String labels)\\n    {\\n        int[] ans = new int[26];  //freq array \\n        for(int x:a[curr])\\n        {\\n            if(prev!=x)\\n            {\\n                // array return by the children node\\n                int[] res = dfs(curr,x,a,labels);  \\n                // combining the frequencies of left and right subtrees into one array\\n                for(int i=0;i<res.length;i++)  \\n                    ans[i]+=res[i];\\n            }\\n        }\\n        // incrementing the freq of curr node label and storing in output array\\n        array[curr] = ++ans[labels.charAt(curr)-\\'a\\']; \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] array;\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n\\n        array = new int[n]; //output array\\n    \\n        //creating adjacency list\\n        ArrayList<Integer>[] a = new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            a[i] = new ArrayList<Integer>();\\n        }\\n\\n        for(int[] x:edges){\\n            a[x[0]].add(x[1]);\\n            a[x[1]].add(x[0]);\\n        }\\n\\n        dfs(-1,0,a,labels);\\n        return array;\\n    }\\n\\n    private int[] dfs(int prev,int curr,ArrayList<Integer>[] a,String labels)\\n    {\\n        int[] ans = new int[26];  //freq array \\n        for(int x:a[curr])\\n        {\\n            if(prev!=x)\\n            {\\n                // array return by the children node\\n                int[] res = dfs(curr,x,a,labels);  \\n                // combining the frequencies of left and right subtrees into one array\\n                for(int i=0;i<res.length;i++)  \\n                    ans[i]+=res[i];\\n            }\\n        }\\n        // incrementing the freq of curr node label and storing in output array\\n        array[curr] = ++ans[labels.charAt(curr)-\\'a\\']; \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040605,
                "title": "easy-c-dfs-solution-beating-97",
                "content": "# Intuition\\nI want to return upwards what characters I have seen somehow during dfs.\\n\\n# Approach\\nMake adjacency list for faster access to connected nodes. Using int array found to store the cnt of every char seen. And finally res vector to store the result. I keep track of the parent node so I don\\'t just return randomly upwards. For every child I make another newFound int array because if I use the same one the result will be wrong for some nodes.\\n\\n# Complexity\\n- Time complexity:\\nO(N) for making adj list and another O(N) for dfs (every node is visited only once). So in total O(N).\\n\\n- Space complexity:\\nO(C*N), where C is some constant, so O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n    void cnt(int cur, int parent, int found[], string &labels, vector<int> &res)\\n    {\\n        for (int child : adj[cur])\\n        {\\n            if (child != parent)\\n            {\\n                int newFound[26] = {0,};\\n                cnt(child, cur, newFound, labels, res);\\n\\n                for (int i = 0; i < 26; ++i)\\n                {\\n                    found[i] += newFound[i];\\n                }\\n            }\\n        }\\n\\n        ++found[labels[cur] - \\'a\\'];\\n        res[cur] = found[labels[cur] - \\'a\\'];\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        adj.resize(n);\\n        for (const vector<int> &e : edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        int found[26] = {0, };\\n        vector<int> res(n);\\n\\n        cnt(0, -1, found, labels, res);\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n    void cnt(int cur, int parent, int found[], string &labels, vector<int> &res)\\n    {\\n        for (int child : adj[cur])\\n        {\\n            if (child != parent)\\n            {\\n                int newFound[26] = {0,};\\n                cnt(child, cur, newFound, labels, res);\\n\\n                for (int i = 0; i < 26; ++i)\\n                {\\n                    found[i] += newFound[i];\\n                }\\n            }\\n        }\\n\\n        ++found[labels[cur] - \\'a\\'];\\n        res[cur] = found[labels[cur] - \\'a\\'];\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        adj.resize(n);\\n        for (const vector<int> &e : edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        int found[26] = {0, };\\n        vector<int> res(n);\\n\\n        cnt(0, -1, found, labels, res);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040179,
                "title": "c-dfs-very-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node, int parent, vector<int> *adj, string &labels, unordered_map<char,int> &m, vector<int> &ans){\\n        char ch=labels[node];\\n        int temp=m[ch];\\n        m[ch]++;\\n        for(auto child: adj[node]){\\n            if(child==parent) continue;\\n            dfs(child,node,adj,labels,m,ans);\\n        }\\n        ans[node]=m[ch]-temp;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> adj[n];\\n        for(auto it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        unordered_map<char,int> m;\\n        vector<int> ans(n,0);\\n        dfs(0,-1,adj,labels,m,ans);\\n        return ans;\\n    }\\n};\\n```\\n# Please hit the UPVOTE button. ^^",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node, int parent, vector<int> *adj, string &labels, unordered_map<char,int> &m, vector<int> &ans){\\n        char ch=labels[node];\\n        int temp=m[ch];\\n        m[ch]++;\\n        for(auto child: adj[node]){\\n            if(child==parent) continue;\\n            dfs(child,node,adj,labels,m,ans);\\n        }\\n        ans[node]=m[ch]-temp;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> adj[n];\\n        for(auto it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        unordered_map<char,int> m;\\n        vector<int> ans(n,0);\\n        dfs(0,-1,adj,labels,m,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039991,
                "title": "go-recursive-dfs",
                "content": "# Approach\\nWe simply traverse the tree top-down, incrementing each label counter whenever occured. Main idea is to remember label counter before we started traversing subtree and put the difference after it\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity:\\n$$O(n)$$\\n# Code\\n```\\nfunc countSubTrees(n int, edges [][]int, labels string) []int {\\n    children := make([][]int, n)\\n    results := make([]int, n)\\n    for _, edge := range edges {\\n        i, j := edge[0], edge[1]\\n        children[i] = append(children[i], j)\\n        children[j] = append(children[j], i)\\n    }\\n    var counts [26]int\\n    var traverse func(int, int)\\n    traverse = func(i, parent int){\\n        label := labels[i] - \\'a\\'\\n        before := counts[label]\\n        counts[label]++\\n        for _, c := range children[i]{\\n            if c != parent {\\n                traverse(c, i)\\n            }\\n        }\\n        results[i] = counts[label] - before\\n    }\\n    traverse(0, -1)\\n    \\n    return results\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nfunc countSubTrees(n int, edges [][]int, labels string) []int {\\n    children := make([][]int, n)\\n    results := make([]int, n)\\n    for _, edge := range edges {\\n        i, j := edge[0], edge[1]\\n        children[i] = append(children[i], j)\\n        children[j] = append(children[j], i)\\n    }\\n    var counts [26]int\\n    var traverse func(int, int)\\n    traverse = func(i, parent int){\\n        label := labels[i] - \\'a\\'\\n        before := counts[label]\\n        counts[label]++\\n        for _, c := range children[i]{\\n            if c != parent {\\n                traverse(c, i)\\n            }\\n        }\\n        results[i] = counts[label] - before\\n    }\\n    traverse(0, -1)\\n    \\n    return results\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3039556,
                "title": "c-simple-and-precise-dfs-similar-to-the-problem-minimum-time-to-collect-all-apples-in-a-tree",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> dfs(int src, vector<int> adj[], vector<int>& vis, string& labels, vector<int>& ans) {\\n        vis[src] = 1;\\n        \\n        vector<int> parentcnt(26,0), childcnt(26,0);\\n\\n        parentcnt[labels[src] - \\'a\\'] = 1;\\n\\n        for(auto child : adj[src]) {\\n            if(!vis[child]) {\\n                childcnt = dfs(child,adj,vis,labels,ans);\\n                for(int k=0;k<26;k++) {\\n                    parentcnt[k] += childcnt[k];\\n                }\\n            }\\n        }\\n\\n        ans[src] = parentcnt[labels[src] - \\'a\\'];\\n        return parentcnt;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> vis(n,0);\\n        vector<int> ans(n);\\n\\n        vector<int> adj[n];\\n\\n        for(int i=0;i<edges.size();i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        dfs(0,adj,vis,labels,ans);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> dfs(int src, vector<int> adj[], vector<int>& vis, string& labels, vector<int>& ans) {\\n        vis[src] = 1;\\n        \\n        vector<int> parentcnt(26,0), childcnt(26,0);\\n\\n        parentcnt[labels[src] - \\'a\\'] = 1;\\n\\n        for(auto child : adj[src]) {\\n            if(!vis[child]) {\\n                childcnt = dfs(child,adj,vis,labels,ans);\\n                for(int k=0;k<26;k++) {\\n                    parentcnt[k] += childcnt[k];\\n                }\\n            }\\n        }\\n\\n        ans[src] = parentcnt[labels[src] - \\'a\\'];\\n        return parentcnt;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> vis(n,0);\\n        vector<int> ans(n);\\n\\n        vector<int> adj[n];\\n\\n        for(int i=0;i<edges.size();i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        dfs(0,adj,vis,labels,ans);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039554,
                "title": "c-python-3-solutions-dictionary-dfs",
                "content": "# Approach\\nIn this approach, we traverse from the root nodes to the leaf node and count the number of characters using DFS. \\nWe don\\u2019t need to create counts array and iterate over it in every call. Instead, we can store single array for all calls, which has counts of visited labels for all time. Then, the answer for some node is the difference between this label visits count before and after handling this node. Thanks to **@8symbols**.\\n\\n**If you like it, please upvote. Thanks**\\n\\n![\\u0438\\u0437\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u0438\\u0435.png](https://assets.leetcode.com/users/images/f41c837c-5940-481a-aa9b-47b73f30e36d_1673512228.648279.png)\\n\\n\\n# Code - C#\\n```\\npublic class Solution {\\n    public int[] CountSubTrees(int n, int[][] edges, string labels) {\\n        int[] answer = new int[n];\\n        Dictionary<char, int> counts = new();\\n        Dictionary<int,List<int>> tree = BuildTree(edges);\\n        void DFS(int node, int parent) {\\n            if(!counts.ContainsKey(labels[node]))\\n                counts.Add(labels[node], 0);\\n\\n            int previous = counts[labels[node]];\\n            counts[labels[node]]++;\\n\\n            foreach (int child in tree[node])\\n                if (child != parent) DFS(child, node);\\n            \\n            answer[node] = counts[labels[node]] - previous;\\n        }\\n        DFS(0, -1);\\n        return answer;\\n    }\\n\\n    public Dictionary<int,List<int>> BuildTree(int[][] edges){\\n        Dictionary<int,List<int>> tree = new();\\n        foreach(var edge in edges){\\n            int a = edge[0], b = edge[1];\\n            if(!tree.ContainsKey(a)) tree.Add(a,new List<int>());\\n            if(!tree.ContainsKey(b)) tree.Add(b, new List<int>());\\n            tree[a].Add(b);\\n            tree[b].Add(a);\\n        }\\n        return tree;\\n    }\\n}\\n```\\n![\\u0438\\u0437\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u0438\\u0435.png](https://assets.leetcode.com/users/images/1a26d416-02bc-4ab0-aa38-a6e0cdf238ff_1673514148.8736303.png)\\n\\n# Code - Python 3\\n```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        graph = [[] for _ in range(n)]\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            \\n        counts = {}\\n        answer = [0] * n\\n        \\n        def dfs(node, parent):\\n            if labels[node] not in counts:\\n                counts[labels[node]] = 0\\n\\n            previous = counts[labels[node]]\\n            counts[labels[node]] += 1\\n            \\n            for child in graph[node]:\\n                if child != parent:\\n                    dfs(child, node)\\n                    \\n            answer[node] = counts[labels[node]] - previous\\n        \\n        dfs(0, -1)\\n        return answer\\n```",
                "solutionTags": [
                    "Python3",
                    "C#",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] CountSubTrees(int n, int[][] edges, string labels) {\\n        int[] answer = new int[n];\\n        Dictionary<char, int> counts = new();\\n        Dictionary<int,List<int>> tree = BuildTree(edges);\\n        void DFS(int node, int parent) {\\n            if(!counts.ContainsKey(labels[node]))\\n                counts.Add(labels[node], 0);\\n\\n            int previous = counts[labels[node]];\\n            counts[labels[node]]++;\\n\\n            foreach (int child in tree[node])\\n                if (child != parent) DFS(child, node);\\n            \\n            answer[node] = counts[labels[node]] - previous;\\n        }\\n        DFS(0, -1);\\n        return answer;\\n    }\\n\\n    public Dictionary<int,List<int>> BuildTree(int[][] edges){\\n        Dictionary<int,List<int>> tree = new();\\n        foreach(var edge in edges){\\n            int a = edge[0], b = edge[1];\\n            if(!tree.ContainsKey(a)) tree.Add(a,new List<int>());\\n            if(!tree.ContainsKey(b)) tree.Add(b, new List<int>());\\n            tree[a].Add(b);\\n            tree[b].Add(a);\\n        }\\n        return tree;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        graph = [[] for _ in range(n)]\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            \\n        counts = {}\\n        answer = [0] * n\\n        \\n        def dfs(node, parent):\\n            if labels[node] not in counts:\\n                counts[labels[node]] = 0\\n\\n            previous = counts[labels[node]]\\n            counts[labels[node]] += 1\\n            \\n            for child in graph[node]:\\n                if child != parent:\\n                    dfs(child, node)\\n                    \\n            answer[node] = counts[labels[node]] - previous\\n        \\n        dfs(0, -1)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039505,
                "title": "python-3-post-order-dfs-faster-than-90-mapping",
                "content": "**Intuition-**\\nTraverse the tree in a depth-first manner, counting the number of nodes in each subtree that have the same label as the current node. Before returning from the DFS function, you add the count of the current node to the count of its parent node. This gives the final count of nodes in the subtree of each node that have the same label as that node.\\n\\n**Logic behind code -**\\n\\ti. Initialize an array of size n called \"counts\" to store the number of nodes in the subtree of each node that have the same label as that node.\\n\\tii. Perform a depth-first search on the tree, starting at the root node (node 0).\\n\\tiii. For each node visited in the DFS, increment the count of that node in the \"counts\" array by 1.\\n\\tiv. For each child node of the current node, recursively call the DFS function, passing in the child node as the new starting point.\\n\\tv. Before returning from the DFS function, add the count of the current node to the count of its parent node.\\n\\tvi. Return the \"counts\" array as the result.\\n\\n```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        alphas = [{} for i in range(n)]\\n        \\n        adj = [[] for i in range(n)]\\n        \\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        \\n        ans = [0]*n \\n        \\n        queue = [0]\\n        q = 1 \\n        \\n        vis = [0]*n \\n        vis[0] = 1 \\n        \\n        par = [0]*n \\n        \\n        while q > 0:\\n            s = queue[-1]\\n            \\n            leaf = True \\n            flag = True\\n            \\n            for z in adj[s]:\\n                if par[s] == z:  \\n                    continue \\n                leaf = False \\n                if not vis[z]:\\n                    flag = False\\n                    vis[z] = 1 \\n                    queue.append(z)\\n                    q += 1 \\n                    par[z] = s\\n                    \\n            if leaf:\\n\\n                curr = labels[s]\\n                ans[s] = 1 \\n                alphas[s][curr] = 1\\n                queue.pop()\\n                q -= 1 \\n\\n                continue \\n                \\n            elif flag:\\n                \\n                curr = labels[s]\\n                \\n                alphas[s][curr] = 1 \\n\\n                \\n                for z in adj[s]:\\n                    for k, v in alphas[z].items():\\n                        if k not in alphas[s]:\\n                            alphas[s][k] = 0\\n                        alphas[s][k] += v \\n                        \\n                ans[s] = alphas[s][curr]\\n\\n                q -= 1 \\n                queue.pop()\\n                continue \\n\\n        return ans\\n```\\n                \\n                 \\n                    \\n                \\n                \\n        \\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        alphas = [{} for i in range(n)]\\n        \\n        adj = [[] for i in range(n)]\\n        \\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        \\n        ans = [0]*n \\n        \\n        queue = [0]\\n        q = 1 \\n        \\n        vis = [0]*n \\n        vis[0] = 1 \\n        \\n        par = [0]*n \\n        \\n        while q > 0:\\n            s = queue[-1]\\n            \\n            leaf = True \\n            flag = True\\n            \\n            for z in adj[s]:\\n                if par[s] == z:  \\n                    continue \\n                leaf = False \\n                if not vis[z]:\\n                    flag = False\\n                    vis[z] = 1 \\n                    queue.append(z)\\n                    q += 1 \\n                    par[z] = s\\n                    \\n            if leaf:\\n\\n                curr = labels[s]\\n                ans[s] = 1 \\n                alphas[s][curr] = 1\\n                queue.pop()\\n                q -= 1 \\n\\n                continue \\n                \\n            elif flag:\\n                \\n                curr = labels[s]\\n                \\n                alphas[s][curr] = 1 \\n\\n                \\n                for z in adj[s]:\\n                    for k, v in alphas[z].items():\\n                        if k not in alphas[s]:\\n                            alphas[s][k] = 0\\n                        alphas[s][k] += v \\n                        \\n                ans[s] = alphas[s][curr]\\n\\n                q -= 1 \\n                queue.pop()\\n                continue \\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039195,
                "title": "c",
                "content": "Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] CountSubTrees(int n, int[][] edges, string labels) {\\n        \\n        var graph = new List<IList<int>>();\\n        var res = new int[n];\\n\\n        while(graph.Count < n)\\n            graph.Add(new List<int>());\\n\\n        foreach(var edge in edges) {\\n            graph[edge[0]].Add(edge[1]);\\n            graph[edge[1]].Add(edge[0]);\\n        }\\n\\n        DFS(graph, labels, 0, -1, ref res);\\n\\n        return res;\\n    }\\n\\n    private int[] DFS(List<IList<int>> graph, string labels, int curr, int prev, ref int[] res) {\\n\\n        var bucket = new int[26];\\n\\n        bucket[labels[curr] - \\'a\\']++;\\n\\n        foreach(var next in graph[curr]) {\\n\\n            if (next == prev)\\n                continue;\\n\\n            var temp = DFS(graph, labels, next, curr, ref res);\\n\\n            for(int i = 0; i < 26; i++) \\n                bucket[i] += temp[i];\\n        }\\n\\n        res[curr] = bucket[labels[curr]-\\'a\\'];\\n\\n        return bucket;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] CountSubTrees(int n, int[][] edges, string labels) {\\n        \\n        var graph = new List<IList<int>>();\\n        var res = new int[n];\\n\\n        while(graph.Count < n)\\n            graph.Add(new List<int>());\\n\\n        foreach(var edge in edges) {\\n            graph[edge[0]].Add(edge[1]);\\n            graph[edge[1]].Add(edge[0]);\\n        }\\n\\n        DFS(graph, labels, 0, -1, ref res);\\n\\n        return res;\\n    }\\n\\n    private int[] DFS(List<IList<int>> graph, string labels, int curr, int prev, ref int[] res) {\\n\\n        var bucket = new int[26];\\n\\n        bucket[labels[curr] - \\'a\\']++;\\n\\n        foreach(var next in graph[curr]) {\\n\\n            if (next == prev)\\n                continue;\\n\\n            var temp = DFS(graph, labels, next, curr, ref res);\\n\\n            for(int i = 0; i < 26; i++) \\n                bucket[i] += temp[i];\\n        }\\n\\n        res[curr] = bucket[labels[curr]-\\'a\\'];\\n\\n        return bucket;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039148,
                "title": "python-solution-beats-99-38",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        adj = [[] for _ in range(n)]\\n\\n        for a, b in edges:\\n            adj[a].append(b)\\n            adj[b].append(a)\\n\\n        count = [0]*len(string.ascii_lowercase)\\n        answer = [0]*n\\n\\n        def dfs(node, parent):\\n            index = ord(labels[node]) - ord(\\'a\\')\\n            previous = count[index]\\n\\n            count[index] += 1\\n\\n            for child in adj[node]:\\n                if child != parent:\\n                    dfs(child,node)\\n            answer[node] = count[index] - previous\\n        dfs(0,-1)\\n        return answer\\n\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        adj = [[] for _ in range(n)]\\n\\n        for a, b in edges:\\n            adj[a].append(b)\\n            adj[b].append(a)\\n\\n        count = [0]*len(string.ascii_lowercase)\\n        answer = [0]*n\\n\\n        def dfs(node, parent):\\n            index = ord(labels[node]) - ord(\\'a\\')\\n            previous = count[index]\\n\\n            count[index] += 1\\n\\n            for child in adj[node]:\\n                if child != parent:\\n                    dfs(child,node)\\n            answer[node] = count[index] - previous\\n        dfs(0,-1)\\n        return answer\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039023,
                "title": "c-dfs-solution",
                "content": "# Code With Adjacency List\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> dfs(int node,vector<vector<int>>&adj,string& label,vector<int>&vis,vector<int>&ans)\\n    {\\n        vector<int>res(26,0);\\n        vis[node]=1;\\n        res[label[node]-\\'a\\']++;\\n        for(auto &i:adj[node])\\n        {\\n            if(!vis[i])\\n            {\\n                vector<int>temp=dfs(i,adj,label,vis,ans);\\n                for(int i=0;i<26;i++)\\n                {\\n                    res[i]+=temp[i];\\n                }\\n            }\\n        }\\n        ans[node]=res[label[node]-\\'a\\'];\\n        return res;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>>adj(n);\\n        int x,y;\\n        for(auto&i:edges)\\n        {\\n            x=i[0];\\n            y=i[1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        vector<int>count(26,0);\\n        vector<int>vis(n,0);\\n        vector<int>ans(n,0);\\n        dfs(0,adj,labels,vis,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Code Without Adjacency List\\n```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    vector<int> dfs(int node,int parent,vector<vector<int>>&adj,string&label)\\n    {\\n        vector<int>res(26,0);\\n        // vis[node]=1;\\n        // res[label[node]-\\'a\\']++;\\n        for(auto &i:adj[node])\\n        {\\n            if(i!=parent)\\n            {\\n                vector<int>temp=dfs(i,node,adj,label);\\n                for(int i=0;i<26;i++)\\n                {\\n                    res[i]+=temp[i];\\n                }\\n            }\\n        }\\n        ans[node]=++res[label[node]-\\'a\\'];\\n        return res;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>>adj(n);\\n        int x,y;\\n        for(auto&i:edges)\\n        {\\n            x=i[0];\\n            y=i[1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        vector<int>count(26,0);\\n        // vector<int>vis(n,0);\\n        ans.resize(n,0);\\n        dfs(0,-1,adj,labels);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> dfs(int node,vector<vector<int>>&adj,string& label,vector<int>&vis,vector<int>&ans)\\n    {\\n        vector<int>res(26,0);\\n        vis[node]=1;\\n        res[label[node]-\\'a\\']++;\\n        for(auto &i:adj[node])\\n        {\\n            if(!vis[i])\\n            {\\n                vector<int>temp=dfs(i,adj,label,vis,ans);\\n                for(int i=0;i<26;i++)\\n                {\\n                    res[i]+=temp[i];\\n                }\\n            }\\n        }\\n        ans[node]=res[label[node]-\\'a\\'];\\n        return res;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>>adj(n);\\n        int x,y;\\n        for(auto&i:edges)\\n        {\\n            x=i[0];\\n            y=i[1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        vector<int>count(26,0);\\n        vector<int>vis(n,0);\\n        vector<int>ans(n,0);\\n        dfs(0,adj,labels,vis,ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    vector<int> dfs(int node,int parent,vector<vector<int>>&adj,string&label)\\n    {\\n        vector<int>res(26,0);\\n        // vis[node]=1;\\n        // res[label[node]-\\'a\\']++;\\n        for(auto &i:adj[node])\\n        {\\n            if(i!=parent)\\n            {\\n                vector<int>temp=dfs(i,node,adj,label);\\n                for(int i=0;i<26;i++)\\n                {\\n                    res[i]+=temp[i];\\n                }\\n            }\\n        }\\n        ans[node]=++res[label[node]-\\'a\\'];\\n        return res;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>>adj(n);\\n        int x,y;\\n        for(auto&i:edges)\\n        {\\n            x=i[0];\\n            y=i[1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        vector<int>count(26,0);\\n        // vector<int>vis(n,0);\\n        ans.resize(n,0);\\n        dfs(0,-1,adj,labels);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038924,
                "title": "c-begineer-friendly-easy-understanding-dfs-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n **C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=wfmBwyuHnfM/\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n \\u2003 vector<vector<int>>adjlist;\\n     vector<int>ans;\\n\\n    vector<int>  dfs(string &labels,int currentNode,int parent){\\n        // to store the count vector at each node\\n        vector<int>count(26,0);\\n        for(auto x:adjlist[currentNode]){\\n            // check only for children.\\n            if(x != parent){\\n                // it will return count vector for childern.\\n                  auto temp = dfs(labels,x,currentNode);\\n                // add temp freq to count freq .\\n                for(int i=0;i<26;i++){\\n                    count[i]+=temp[i];\\n                }\\n            }\\n         }\\n        //  cal for current node also and add it to the count vector\\n        int ch = labels[currentNode]-\\'a\\'; // for b i.e index ch = 1;\\n        count[ch]++;\\n        // store for the currentNode in ans.\\n        ans[currentNode] = count[ch];\\n        return count;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n\\u2003\\u2003\\u2003adjlist.resize(n);\\n        \\u2003ans.resize(n,1);\\n        for(auto x:edges){\\n            adjlist[x[0]].push_back(x[1]);\\n            adjlist[x[1]].push_back(x[0]);\\n        }\\n        // current node =0 , parent node =-1,distance or level from root.\\n        dfs(labels,0,-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\u2003 vector<vector<int>>adjlist;\\n     vector<int>ans;\\n\\n    vector<int>  dfs(string &labels,int currentNode,int parent){\\n        // to store the count vector at each node\\n        vector<int>count(26,0);\\n        for(auto x:adjlist[currentNode]){\\n            // check only for children.\\n            if(x != parent){\\n                // it will return count vector for childern.\\n                  auto temp = dfs(labels,x,currentNode);\\n                // add temp freq to count freq .\\n                for(int i=0;i<26;i++){\\n                    count[i]+=temp[i];\\n                }\\n            }\\n         }\\n        //  cal for current node also and add it to the count vector\\n        int ch = labels[currentNode]-\\'a\\'; // for b i.e index ch = 1;\\n        count[ch]++;\\n        // store for the currentNode in ans.\\n        ans[currentNode] = count[ch];\\n        return count;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n\\u2003\\u2003\\u2003adjlist.resize(n);\\n        \\u2003ans.resize(n,1);\\n        for(auto x:edges){\\n            adjlist[x[0]].push_back(x[1]);\\n            adjlist[x[1]].push_back(x[0]);\\n        }\\n        // current node =0 , parent node =-1,distance or level from root.\\n        dfs(labels,0,-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038724,
                "title": "detailed-explanation-beats-100-59ms-java",
                "content": "# Intiution\\nThe intuition behind this code is to use a depth-first search traversal of the tree, starting from the root node to visit each node in the tree, and while traversing the tree, keeping track of the number of subtrees with a specific label at each node.\\n\\nThe goal is to find the number of subtrees that have a specific label at each node. To achieve this, the code starts at the root node and traverses the tree in a depth-first manner, visiting each node and its children.\\nAs it visits each node, it keeps track of the number of subtrees that have a specific label at that node, by counting the number of times that label appears in the subtrees rooted at that node.\\nDuring the traversal, it also updates the count of the subtrees that have a specific label at the current node and returns it as the output.\\n# Approach \\n1. Create an adjacency list representation of the tree using the edges input.(here: ***graph***)\\n2. Initialize an array ***count*** with the same length as the number of nodes in the tree.\\n3. Start a depth-first search traversal of the tree, starting from the root node (node 0).\\n4. For each node visited in the traversal:\\n    1. Initialize an array ***countArray*** with length 26 to keep  the count of the number of subtrees that have a specific label.\\n    2. For each child of the current node:\\n        1. If the child is not the parent of the current node, recursively call the depth-first search function passing the child as the current node, its parent, the graph, labels, and count array.\\n        2. For each element in the returned count array, add it to the countArray.\\n    1. Update the count array at the current node with countArray at the label of the current node\\n1. Return the count array as the output\\n\\n# Time Complexity\\nThe time complexity of this code is **O(n + m)** where n is the number of nodes in the tree, and m is the number of edges in the tree.\\n\\nThe reason for this is that during the depth-first search, we visit each node in the tree once, and for each node, we iterate over its children, which are represented by the edges in the tree.\\n\\nSince each edge is visited twice (once for each node it connects), the total number of edge visits is 2*m. So the total time complexity is O(n + m).\\n\\n# Space Complexity\\nThe space complexity of this solution is **O(n + m)** because we are using an adjacency list(***graph***) to store the edges in the tree, which requires O(n + m) space.\\nWe also use an array of length n as ***count*** array and an array of length 26 as ***countArray*** which are also taking O(n) space. So the overall space complexity is O(n + m)\\n# Code\\n```\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        int[] count = new int[n];\\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        for(int i = 0; i < n; i++){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int[] edge : edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        dfs(0, -1, graph, labels, count);\\n        return count;\\n    }\\n    private int[] dfs(int currentNode, int parentNode, ArrayList<Integer>[] graph, String labels, int[] count){\\n        int[] countArray = new int[26];\\n        for(int childNode: graph[currentNode]){\\n            if(childNode != parentNode){\\n                int[] res = dfs(childNode, currentNode, graph, labels, count);\\n                for(int i = 0; i < res.length; i++){\\n                    countArray[i] += res[i];\\n                }\\n            }\\n        }\\n        count[currentNode] = ++countArray[labels.charAt(currentNode) - \\'a\\'];\\n        return countArray;\\n  \\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        int[] count = new int[n];\\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        for(int i = 0; i < n; i++){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int[] edge : edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        dfs(0, -1, graph, labels, count);\\n        return count;\\n    }\\n    private int[] dfs(int currentNode, int parentNode, ArrayList<Integer>[] graph, String labels, int[] count){\\n        int[] countArray = new int[26];\\n        for(int childNode: graph[currentNode]){\\n            if(childNode != parentNode){\\n                int[] res = dfs(childNode, currentNode, graph, labels, count);\\n                for(int i = 0; i < res.length; i++){\\n                    countArray[i] += res[i];\\n                }\\n            }\\n        }\\n        count[currentNode] = ++countArray[labels.charAt(currentNode) - \\'a\\'];\\n        return countArray;\\n  \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038678,
                "title": "100-0ms-dfs-faster-concise-ordo-n-adj-matrix-vs-adj-list",
                "content": "# upvote pls\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        int[] ans = new int[n];\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<Integer>();\\n        }\\n        for(int[] edge: edges) {\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        helper(graph, ans, 0, -1, labels);\\n        return ans;\\n    }\\n\\n    public int[] helper(List<Integer>[] graph, int[] ans, int cur, int parent, String labels) {\\n        int[] cnt = new int[26];\\n        for(int next: graph[cur]) {\\n            if(next == parent) continue;\\n            int[] arr = helper(graph, ans, next, cur, labels);\\n            for(int i = 0; i < 26; i++) {\\n                cnt[i] = cnt[i] + arr[i];\\n            }\\n        }\\n        char c = labels.charAt(cur);\\n        cnt[c - \\'a\\']++;\\n        ans[cur] = cnt[c - \\'a\\'];\\n        return cnt;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n    // private List<List<Integer>> adjList;\\n    // private int[] ans;\\n    // private Set<Integer> vist;\\n    // public int[] countSubTrees(int n, int[][] edges, String labels) {\\n    //     ans = new int[n];\\n    //     adjList = new ArrayList<>(n);\\n    //     for(int i=0;i<n;i++){\\n    //         adjList.add(new ArrayList<>());\\n    //     }\\n    //     for(int[] i:edges){\\n    //         adjList.get(i[0]).add(i[1]);\\n    //         adjList.get(i[1]).add(i[0]);\\n    //     }\\n    //     vist=new HashSet<Integer>(n);\\n    //     dfs(0,labels);\\n    //     return ans;\\n    // }\\n    // private int[] dfs(int node,String lab){\\n    //     vist.add(node);\\n    //     int cot[]=new int[26];\\n    //     for(var v: adjList.get(node)){\\n    //         if(!vist.contains(v)){\\n    //             int adjct[]=dfs(v,lab);\\n    //             for(int i=0;i<26;i++){\\n    //                 cot[i]+=adjct[i];\\n    //             }\\n    //         }\\n    //     }\\n    //     char c=lab.charAt(node);\\n    //     cot[c-\\'a\\']++;\\n    //     ans[node]=cot[c-\\'a\\'];\\n    //     return cot;\\n    // }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        int[] ans = new int[n];\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<Integer>();\\n        }\\n        for(int[] edge: edges) {\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        helper(graph, ans, 0, -1, labels);\\n        return ans;\\n    }\\n\\n    public int[] helper(List<Integer>[] graph, int[] ans, int cur, int parent, String labels) {\\n        int[] cnt = new int[26];\\n        for(int next: graph[cur]) {\\n            if(next == parent) continue;\\n            int[] arr = helper(graph, ans, next, cur, labels);\\n            for(int i = 0; i < 26; i++) {\\n                cnt[i] = cnt[i] + arr[i];\\n            }\\n        }\\n        char c = labels.charAt(cur);\\n        cnt[c - \\'a\\']++;\\n        ans[cur] = cnt[c - \\'a\\'];\\n        return cnt;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n    // private List<List<Integer>> adjList;\\n    // private int[] ans;\\n    // private Set<Integer> vist;\\n    // public int[] countSubTrees(int n, int[][] edges, String labels) {\\n    //     ans = new int[n];\\n    //     adjList = new ArrayList<>(n);\\n    //     for(int i=0;i<n;i++){\\n    //         adjList.add(new ArrayList<>());\\n    //     }\\n    //     for(int[] i:edges){\\n    //         adjList.get(i[0]).add(i[1]);\\n    //         adjList.get(i[1]).add(i[0]);\\n    //     }\\n    //     vist=new HashSet<Integer>(n);\\n    //     dfs(0,labels);\\n    //     return ans;\\n    // }\\n    // private int[] dfs(int node,String lab){\\n    //     vist.add(node);\\n    //     int cot[]=new int[26];\\n    //     for(var v: adjList.get(node)){\\n    //         if(!vist.contains(v)){\\n    //             int adjct[]=dfs(v,lab);\\n    //             for(int i=0;i<26;i++){\\n    //                 cot[i]+=adjct[i];\\n    //             }\\n    //         }\\n    //     }\\n    //     char c=lab.charAt(node);\\n    //     cot[c-\\'a\\']++;\\n    //     ans[node]=cot[c-\\'a\\'];\\n    //     return cot;\\n    // }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038604,
                "title": "why-tle-here-is-the-solution-c",
                "content": "# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we can think directly think brute force approach that we first go to the first node from this we call dfs and traverse whole tree and count that character of the node and store it and do this stuff with all the nodes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe are traversing the tree for each node and we know that traversing a tree (bfs or dfs) get o(n) time complexity and we have n nodes so total time complexity is o(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIts space complexity is o(n^2) beacuse we store the adjacent edges take approximate n^2 nodes\\n\\n# Approach 2\\n<!-- Describe your approach to solving the problem. -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter observing the tree we get that if we are storing the result from leaves and in which we check count the character frequency from both the sides and also check the frequency of with its own character and then store into the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwe are only traversing the tree once and make a loop of 26 iterations which is constant so overall time complexity is o(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIts space complexity is o(n^2) beacuse we store the adjacent edges take approximate n^2 nodes\\n\\n# Reason of getting TLE\\nThe main reason is that you are passing the string as a value and it always copy the string with its call that increase the time and we are getting tle. So for avoiding this you can pass the string by reference. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node,vector<vector<int>> &adj,string &labels,vector<int> &output,vector<bool> &vis){\\n        vis[node]=true;\\n        int n=adj[node].size();\\n        vector<int> freq(26,0);\\n        for(int j=0;j<n;j++){\\n            if(!vis[adj[node][j]]){\\n                vector<int> cnt=dfs(adj[node][j],adj,labels,output,vis);\\n                for(int i=0;i<26;i++){\\n                    freq[i]+=cnt[i];\\n                }\\n            }\\n        }\\n        int val=labels[node]-\\'a\\';\\n        freq[val]++;\\n        output[node]=freq[val];\\n        return freq;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adj(n);\\n        vector<int> output(n,0);\\n        vector<bool> vis(n,0);\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        dfs(0,adj,labels,output,vis);\\n        return output;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node,vector<vector<int>> &adj,string &labels,vector<int> &output,vector<bool> &vis){\\n        vis[node]=true;\\n        int n=adj[node].size();\\n        vector<int> freq(26,0);\\n        for(int j=0;j<n;j++){\\n            if(!vis[adj[node][j]]){\\n                vector<int> cnt=dfs(adj[node][j],adj,labels,output,vis);\\n                for(int i=0;i<26;i++){\\n                    freq[i]+=cnt[i];\\n                }\\n            }\\n        }\\n        int val=labels[node]-\\'a\\';\\n        freq[val]++;\\n        output[node]=freq[val];\\n        return freq;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adj(n);\\n        vector<int> output(n,0);\\n        vector<bool> vis(n,0);\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        dfs(0,adj,labels,output,vis);\\n        return output;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038499,
                "title": "c-recursive-approach-approach-discussed",
                "content": "# Intuition\\nBased on DFS\\n\\n# Approach\\nFirst we will create a adjacency list using the edges vector.Now we will apply DFS to it starting from the root node 0.In DFS call first we will initialize a vector for storing count of number of each character in its subtrees including that node.Now we will traverse the adjacents of that node excluding its parent and count the number of each character.Now we will store the answer for that node in our answer vector.After performing DFS, we will simply return our answer.\\nHack : In DFS pass string as a reference otherwise will get TLE because our complexity will become O(n*2)\\n\\n# Complexity\\n- Time complexity:\\nO(n*26)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dfs(int curr,int prev,vector<int> adj[],string &s,vector<int> &ans){\\n        vector<int> v(26,0);\\n        for(int i=0;i<adj[curr].size();i++){\\n            if(adj[curr][i]!=prev){\\n                vector<int> left=dfs(adj[curr][i],curr,adj,s,ans);\\n                 for(int i=0;i<26;i++) v[i]+=left[i];\\n            }\\n           \\n        }\\n        v[s[curr]-97]++;\\n        ans[curr]=v[s[curr]-97];\\n        return v;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> adj[n];\\n        vector<int> ans(n,0);\\n        for(int i=0;i<n-1;i++){\\n            // cout<<edges[i][0]<<\" \"<<edges[i][1]<<endl;\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        dfs(0,-1,adj,labels,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dfs(int curr,int prev,vector<int> adj[],string &s,vector<int> &ans){\\n        vector<int> v(26,0);\\n        for(int i=0;i<adj[curr].size();i++){\\n            if(adj[curr][i]!=prev){\\n                vector<int> left=dfs(adj[curr][i],curr,adj,s,ans);\\n                 for(int i=0;i<26;i++) v[i]+=left[i];\\n            }\\n           \\n        }\\n        v[s[curr]-97]++;\\n        ans[curr]=v[s[curr]-97];\\n        return v;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> adj[n];\\n        vector<int> ans(n,0);\\n        for(int i=0;i<n-1;i++){\\n            // cout<<edges[i][0]<<\" \"<<edges[i][1]<<endl;\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        dfs(0,-1,adj,labels,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3038330,
                "title": "python3-simple-solution-dfs-dictionary-great-explanation-97-optimal",
                "content": "Note: Skip to \"**How to Solve**\" section if you have basic understanding of DFS.\\nAlso the **code has proper comments**, skips to the code directly if you prefer :)\\n\\n# Approach\\nSo heres the deal, first of all the questions asks us to consider about undirected trees, by that what they are implying is to consider your data structure as a graph instead of a tree. Secondly, after readin the question, you should be able to understand it is somehow related to depth first search, though you might not know what exactly to do, your intiution would have suggested to use Depth First Search.\\n\\n# Concentration\\nWe need to keep track of all the labels in a subtree along with their frequencies. You can do this with a dictionary where the key is the label and the frequency is the value. Dotn forget to the add the label of the current node to dictionary of it\\'s subtree\\'s labels\\n\\n# Recursion vs Iterative approach\\nAs you would know, there are 2 ways of performing DFS in graphs, one using recurrsion and another using a stack datastructure. But for this particular question, we will be using recursion as it will be easier to keep track of the labels. labels of each child node will be passed to the parent node and in the parent node, we add all the labels of all its\\'s children\\'s subtrees.\\n\\n# DFS initiation\\nOur plan here is to perform DFS on the given data structure which we will assume to be a graph. To perform DFS on a graph, we need to know the neighbours of each node. We can construct a dictionary using edges list.\\nYou do it in the following way:\\n```\\nd = collections.defaultdict(list)\\nfor i in edges:\\n    d[i[0]].append(i[1])\\n    d[i[1]].append(i[0])\\n```\\n\\nNow we can perform DFS. Also remeber to keep track of the nodes that you have visited using a list/set. \\n\\n# How to solve\\nNote: For better understanding, read this along with the code. \\n\\nPerforming a DFS is a trival task, but we also need to keep track of the labels and their frequency for each subtree. We can create a dictionary and call it labels_dict. In this dict, we keep track of all the labels in a node\\'s subtree. Then we return labels_dict at the end of dfs, which means, we will be passing a subtree\\'s result to its parent(except for root).\\n\\nHow to keep track of subtree\\'s labels:\\n1. Add the current label to the dictionary.\\n2. Perform dfs on each child node, this returns the labels in each child\\'s subtree which we will add to our current dictionary\\n3. Update the results array\\n4. return the labels_dict(current dictionary) at the end of dfs(in this step we return the subtree\\'s labels to its parent node where we continue steps 2-4)\\n\\nLet me know any questions or concerns\\n\\nHope my solution helps. Happy coding:)\\n\\n# Time Complexity : $$$O(n^2)$$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        neighbours = collections.defaultdict(list) # Dictioanry to keep track of neighbours for each node\\n        result = [-1]*n # result vector with -1 for all positions\\n        for edge in edges: # Populate d with neighbours\\n            neighbours[edge[0]].append(edge[1])\\n            neighbours[edge[1]].append(edge[0])\\n\\n        visited = [-1]*n # Visited vector to keep track of visited nodes\\n\\n        def dfs(edge):\\n            labels_dict = collections.defaultdict(int) # Dictionary to keep track of all the labels in the subtree\\n            labels_dict[labels[edge]] += 1 # Update the dictionary with the current label\\n            for i in neighbours[edge]: # Iterate through all neighbours\\n                if visited[i] == -1:\\n                    visited[i] = 1\\n                    subtree_labels = dfs(i) # Call dfs(edge) if the edge has not been visited yet, it returns labels of subtree\\n                    for j in subtree_labels: # Add all the contents of subtree_labels to current labels\\n                        if j in labels_dict:\\n                            labels_dict[j]+= subtree_labels[j]\\n                        else:\\n                            labels_dict[j] = subtree_labels[j]\\n            # Now labels contains all the labels in its subtree along with their frequency \\n            result[edge] = labels_dict[labels[edge]] # Update results with the label count\\n            return labels_dict # Return labels to its parent\\n\\n        visited[0] = 1 # Update visited of root to 1\\n        dfs(0) # Call dfs on the root node\\n        return result #Return the result\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nd = collections.defaultdict(list)\\nfor i in edges:\\n    d[i[0]].append(i[1])\\n    d[i[1]].append(i[0])\\n```\n```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        neighbours = collections.defaultdict(list) # Dictioanry to keep track of neighbours for each node\\n        result = [-1]*n # result vector with -1 for all positions\\n        for edge in edges: # Populate d with neighbours\\n            neighbours[edge[0]].append(edge[1])\\n            neighbours[edge[1]].append(edge[0])\\n\\n        visited = [-1]*n # Visited vector to keep track of visited nodes\\n\\n        def dfs(edge):\\n            labels_dict = collections.defaultdict(int) # Dictionary to keep track of all the labels in the subtree\\n            labels_dict[labels[edge]] += 1 # Update the dictionary with the current label\\n            for i in neighbours[edge]: # Iterate through all neighbours\\n                if visited[i] == -1:\\n                    visited[i] = 1\\n                    subtree_labels = dfs(i) # Call dfs(edge) if the edge has not been visited yet, it returns labels of subtree\\n                    for j in subtree_labels: # Add all the contents of subtree_labels to current labels\\n                        if j in labels_dict:\\n                            labels_dict[j]+= subtree_labels[j]\\n                        else:\\n                            labels_dict[j] = subtree_labels[j]\\n            # Now labels contains all the labels in its subtree along with their frequency \\n            result[edge] = labels_dict[labels[edge]] # Update results with the label count\\n            return labels_dict # Return labels to its parent\\n\\n        visited[0] = 1 # Update visited of root to 1\\n        dfs(0) # Call dfs on the root node\\n        return result #Return the result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038260,
                "title": "c-dfs-solution-with-diagrams",
                "content": "The first solution that came to mind is just brute force by looping through each node (x) and calling a DFS from that node with its label and comparing each node with the label then returning the number of appearances as an answer for the node (x), regardless of time limits the problem was that tree is an undirected graph so instead of going downwards from the node (x) to its subtree, it goes up to its parent (y) - as undirect graph node (x) is a child of (y) and (y) is a child of (x) - which cause a wrong answer. \\nSo we need to make sure we are going downwards from the root to consider the solution of node (x) is in its subtree to achieve that we will:-\\n- start our DFS from the root (node 0) and calculate a frequency table by its children \\n- call DFS with children all the way downwards \\n- the answer of leaf nodes will equal the frequency of the label on its table + 1 \\'its own appearance\\n- return the frequency table to the parent\\n- parent\\'s frequency table = parent\\'s frequency table + its child frequency table\\n- after there are no more children, now the parent has all the appearances of its own subtree\\n- the answer of the node = frequancy[its label] + 1\\n- by the end of our DFS we will have the answer vector\\n* ![image](https://assets.leetcode.com/users/images/3b828677-0f27-47be-b7d5-0d127fb79845_1673492710.3796654.jpeg)\\n\\n* ![image](https://assets.leetcode.com/users/images/9b860f69-3890-4982-bcdf-fbb8b1e5bee5_1673492719.6145325.jpeg)\\n\\n* ![image](https://assets.leetcode.com/users/images/4c9f6666-d2fa-4abc-bb4c-2bf4c4c94ff6_1673492729.1244879.jpeg)\\n\\n* ![image](https://assets.leetcode.com/users/images/c9d19a91-4f87-4ac2-ad78-00ebb4ef937c_1673492738.4381778.jpeg)\\n\\n* ![image](https://assets.leetcode.com/users/images/724ce3a0-1461-4d5d-970e-05f4b9703c0d_1673492749.9713583.jpeg)\\n\\n* ![image](https://assets.leetcode.com/users/images/973fd001-e536-4e3f-b101-8bc65fe9098d_1673492760.1334562.jpeg)\\n\\n* ![image](https://assets.leetcode.com/users/images/b44ac40a-aa38-4301-9f28-06593fbf6a29_1673492768.7035508.jpeg)\\n\\n# **code**\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    vector<int> dfs(int s,vector<vector<int>>& adj,vector<bool>& visited,string& labs,vector<int>& ans){\\n        visited[s]=true;\\n        vector<int>freq(26,0);//node frequency table\\n        for(auto child:adj[s]){\\n            if(!visited[child]){\\n                freq[labs[child]-\\'a\\']++;//children appearance\\n                vector<int>get;\\n                get=dfs(child,adj,visited,labs,ans);//receive child freq table\\n                for(int i=0;i<26;i++)freq[i]+=get[i];//combine tables\\n            }\\n        }\\n        \\n        ans[s]=freq[labs[s]-\\'a\\'] + 1;// +1 for its own appearance\\n        return freq;//return freq table to parent\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>>adj(n);\\n        vector<bool>visited(n);\\n        vector<int>ans(n);\\n        \\n        for(int i=0;i<n-1;i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        dfs(0,adj,visited,labels,ans);\\n        return ans;\\n    }\\n};\\n\\'\\'\\'\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> dfs(int s,vector<vector<int>>& adj,vector<bool>& visited,string& labs,vector<int>& ans){\\n        visited[s]=true;\\n        vector<int>freq(26,0);//node frequency table\\n        for(auto child:adj[s]){\\n            if(!visited[child]){\\n                freq[labs[child]-\\'a\\']++;//children appearance\\n                vector<int>get;\\n                get=dfs(child,adj,visited,labs,ans);//receive child freq table\\n                for(int i=0;i<26;i++)freq[i]+=get[i];//combine tables\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3038047,
                "title": "easy-to-understand-postorder-dfs-with-testcases",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeKotlin/src/main/kotlin/leetcode/medium/graph/SubtreeNodesSameLabel.kt",
                "solutionTags": [
                    "Kotlin",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3038002,
                "title": "java-dfs-o-n-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse DFS to visit every node starting with the root node. From each node return an `int[]` that contains the summed up count of all node letters of the current node and all its children. Look up the `int[]` map at each node to record the desired count in the final result `int[]`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Compute an adjacency list for all nodes using `int[][] edges`.\\n2. Intiate a DFS traversal from the root node (#0).\\n3. At each node, create a `int[]` map which will store the count of each lowercase letter contained in the subtree.\\n4. Update the `int[]` map to account for the current node\\'s label.\\n5. Sum up the values of the `int[]` maps of each of the child nodes with the current node\\'s map.\\n6. Record the count of the current node\\'s label character in the `int[]` result structure. This count will have accounted for all the nodes in the subtree.\\n6. Return the current node\\'s `int[]` map to the parent.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int[] ans;\\n  List<List<Integer>> adj = new ArrayList<>();\\n\\n  private int[] dfs(int node, int parent, String labels) {\\n    int[] map = new int[26];\\n    map[labels.charAt(node) - \\'a\\']++;\\n\\n    for (int child : adj.get(node)) {\\n      if (child != parent) {\\n        int[] childMap = dfs(child, node, labels);\\n\\n        for (int i=0; i<26; i++)\\n          map[i] += childMap[i];\\n      }\\n    }\\n    ans[node] = map[labels.charAt(node) - \\'a\\'];\\n    return map;\\n  }\\n\\n  public int[] countSubTrees(int n, int[][] edges, String labels) {\\n    ans = new int[n];\\n    for (int i=0; i<n; i++)\\n      adj.add(new ArrayList<>());\\n\\n    for (int[] edge : edges) {\\n      adj.get(edge[0]).add(edge[1]);\\n      adj.get(edge[1]).add(edge[0]);\\n    }\\n    dfs(0, -1, labels);\\n\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n  int[] ans;\\n  List<List<Integer>> adj = new ArrayList<>();\\n\\n  private int[] dfs(int node, int parent, String labels) {\\n    int[] map = new int[26];\\n    map[labels.charAt(node) - \\'a\\']++;\\n\\n    for (int child : adj.get(node)) {\\n      if (child != parent) {\\n        int[] childMap = dfs(child, node, labels);\\n\\n        for (int i=0; i<26; i++)\\n          map[i] += childMap[i];\\n      }\\n    }\\n    ans[node] = map[labels.charAt(node) - \\'a\\'];\\n    return map;\\n  }\\n\\n  public int[] countSubTrees(int n, int[][] edges, String labels) {\\n    ans = new int[n];\\n    for (int i=0; i<n; i++)\\n      adj.add(new ArrayList<>());\\n\\n    for (int[] edge : edges) {\\n      adj.get(edge[0]).add(edge[1]);\\n      adj.get(edge[1]).add(edge[0]);\\n    }\\n    dfs(0, -1, labels);\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975271,
                "title": "c-dfs-simple-solution-with-explanation",
                "content": "We first build adjacent list using `edges` into `rel` then perform dfs starting from root node `0`.\\nFor each recursion, we get all frequencies count `tmp` given by subtree recursion and update into current frequency array `cnt`\\nAfter that, update current node frequencies by `res[now]` = `cnt[lables[now]-\\'a\\']+1`\\n\\n`v`: # of nodes in the tree, `e`: # of edges in the tree\\n* time: `O(v+e)`\\n* space: `O(v+e)`\\n```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    vector<vector<int>> rel;\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        rel.resize(n);\\n        res.resize(n, 0);\\n        for (auto &edge: edges) {\\n            rel[edge[0]].push_back(edge[1]);\\n            rel[edge[1]].push_back(edge[0]);\\n        }\\n        dfs(0, -1, labels);\\n        return res;\\n    }\\n    vector<int> dfs(int now, int p, string &labels) {\\n        vector<int> cnt(26, 0);\\n        for (auto &child: rel[now]) {\\n            if (p == child) {\\n                continue;\\n            }\\n            auto tmp = dfs(child, now, labels);\\n            for (int i = 0; i < 26; ++i) {\\n                cnt[i] += tmp[i];\\n            }\\n        }\\n        res[now] = ++cnt[labels[now]-\\'a\\'];\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    vector<vector<int>> rel;\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        rel.resize(n);\\n        res.resize(n, 0);\\n        for (auto &edge: edges) {\\n            rel[edge[0]].push_back(edge[1]);\\n            rel[edge[1]].push_back(edge[0]);\\n        }\\n        dfs(0, -1, labels);\\n        return res;\\n    }\\n    vector<int> dfs(int now, int p, string &labels) {\\n        vector<int> cnt(26, 0);\\n        for (auto &child: rel[now]) {\\n            if (p == child) {\\n                continue;\\n            }\\n            auto tmp = dfs(child, now, labels);\\n            for (int i = 0; i < 26; ++i) {\\n                cnt[i] += tmp[i];\\n            }\\n        }\\n        res[now] = ++cnt[labels[now]-\\'a\\'];\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385325,
                "title": "c-memory-efficient-90-speed-87-memory",
                "content": "Pass labelCount(26) as the reference in each stack and only care about the label count of the given node before and after calling the subtrees.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adjList(n, vector<int>());\\n        for(auto edge : edges) {\\n            adjList[edge[0]].push_back(edge[1]);\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<int> labelCount(26, 0);\\n        vector<int> nodeLabelCount(n, 0);\\n        vector<bool> visited(n, false);\\n        countSubTreeLabels(0, adjList, labelCount, visited, nodeLabelCount, labels);\\n        return nodeLabelCount;\\n    }\\n    \\n    void countSubTreeLabels(int node, vector<vector<int>> &adjList, vector<int> &labelCount, vector<bool> &visited, vector<int> &subTreeCount, string &labels) {\\n        if(visited[node]) return;\\n        visited[node] = true;\\n        int countBefore = labelCount[labels[node]-\\'a\\'];\\n        // cout<<node<<\" \"<<labels[node]<<\" \"<<countBefore<<endl;\\n        \\n        ++labelCount[labels[node]-\\'a\\'];\\n        for(auto adjElem : adjList[node]) {\\n            countSubTreeLabels(adjElem, adjList, labelCount, visited, subTreeCount, labels);\\n        }\\n        // cout<<\"after \"<<node<<\" \"<<labels[node]<<\" \"<<labelCount[labels[node]-\\'a\\']<<endl;\\n        subTreeCount[node] = labelCount[labels[node]-\\'a\\'] - countBefore;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adjList(n, vector<int>());\\n        for(auto edge : edges) {\\n            adjList[edge[0]].push_back(edge[1]);\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<int> labelCount(26, 0);\\n        vector<int> nodeLabelCount(n, 0);\\n        vector<bool> visited(n, false);\\n        countSubTreeLabels(0, adjList, labelCount, visited, nodeLabelCount, labels);\\n        return nodeLabelCount;\\n    }\\n    \\n    void countSubTreeLabels(int node, vector<vector<int>> &adjList, vector<int> &labelCount, vector<bool> &visited, vector<int> &subTreeCount, string &labels) {\\n        if(visited[node]) return;\\n        visited[node] = true;\\n        int countBefore = labelCount[labels[node]-\\'a\\'];\\n        // cout<<node<<\" \"<<labels[node]<<\" \"<<countBefore<<endl;\\n        \\n        ++labelCount[labels[node]-\\'a\\'];\\n        for(auto adjElem : adjList[node]) {\\n            countSubTreeLabels(adjElem, adjList, labelCount, visited, subTreeCount, labels);\\n        }\\n        // cout<<\"after \"<<node<<\" \"<<labels[node]<<\" \"<<labelCount[labels[node]-\\'a\\']<<endl;\\n        subTreeCount[node] = labelCount[labels[node]-\\'a\\'] - countBefore;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 829564,
                "title": "java-2-solution-concept-is-same-dfs-slight-change-in-implementation",
                "content": "```\\n1.\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        int [] frequency = new int [n];\\n        List<List<Integer>> adjacent = new ArrayList<>();\\n        for (int i=0; i<n; i++)\\n            adjacent.add(new LinkedList<>());\\n        for (int [] edge: edges) {\\n            adjacent.get(edge[0]).add(edge[1]);\\n            adjacent.get(edge[1]).add(edge[0]);\\n        }\\n        boolean visited [] = new boolean[n];\\n        DFSHelper(0, visited, labels, adjacent, frequency);\\n        return frequency;\\n    }\\n    public int [] DFSHelper(int v, boolean [] visited, String labels, List<List<Integer>> adjacent, int [] frequency) {\\n        visited[v] = true;\\n        int [] countLabel = new int [26];\\n        List<Integer> children = adjacent.get(v);\\n        int index = labels.charAt(v) - \\'a\\';\\n        for (Integer child: children) {\\n            if (!visited[child]) {\\n                int [] childCount = DFSHelper(child, visited, labels, adjacent, frequency);\\n                for (int i=0; i<26; i++) {\\n                countLabel[i] += childCount[i];\\n            }\\n            }\\n        }\\n        countLabel[index] += 1;\\n        frequency[v] = countLabel[index];\\n        return countLabel;\\n    }\\n}\\n```\\n\\n\\n```\\n2.\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        int [] frequency = new int [n];\\n        List<List<Integer>> adjacent = new ArrayList<>();\\n        for (int i=0; i<n; i++)\\n            adjacent.add(new ArrayList<>());\\n        for (int [] edge: edges) {\\n            adjacent.get(edge[0]).add(edge[1]);\\n            adjacent.get(edge[1]).add(edge[0]);\\n        }\\n        boolean visited [] = new boolean[n];\\n        DFSHelper(0, visited, labels, adjacent, frequency);\\n        return frequency;\\n    }\\n    public int [] DFSHelper(int v, boolean [] visited, String labels, List<List<Integer>> adjacent, int [] frequency) {\\n        visited[v] = true;\\n        int [] countLabel = new int [26];\\n        List<int[]> children = new ArrayList<>();\\n        int index = labels.charAt(v) - \\'a\\';\\n        for (int child: adjacent.get(v)) {\\n            if (!visited[child]) {\\n                children.add(DFSHelper(child, visited, labels, adjacent, frequency));\\n            }\\n        }\\n        for (int [] child: children) {\\n            for (int i=0; i<26; i++) {\\n                countLabel[i] += child[i];\\n            }\\n        }\\n        countLabel[index] ++;\\n        frequency[v] = countLabel[index];\\n        return countLabel;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n1.\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        int [] frequency = new int [n];\\n        List<List<Integer>> adjacent = new ArrayList<>();\\n        for (int i=0; i<n; i++)\\n            adjacent.add(new LinkedList<>());\\n        for (int [] edge: edges) {\\n            adjacent.get(edge[0]).add(edge[1]);\\n            adjacent.get(edge[1]).add(edge[0]);\\n        }\\n        boolean visited [] = new boolean[n];\\n        DFSHelper(0, visited, labels, adjacent, frequency);\\n        return frequency;\\n    }\\n    public int [] DFSHelper(int v, boolean [] visited, String labels, List<List<Integer>> adjacent, int [] frequency) {\\n        visited[v] = true;\\n        int [] countLabel = new int [26];\\n        List<Integer> children = adjacent.get(v);\\n        int index = labels.charAt(v) - \\'a\\';\\n        for (Integer child: children) {\\n            if (!visited[child]) {\\n                int [] childCount = DFSHelper(child, visited, labels, adjacent, frequency);\\n                for (int i=0; i<26; i++) {\\n                countLabel[i] += childCount[i];\\n            }\\n            }\\n        }\\n        countLabel[index] += 1;\\n        frequency[v] = countLabel[index];\\n        return countLabel;\\n    }\\n}\\n```\n```\\n2.\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        int [] frequency = new int [n];\\n        List<List<Integer>> adjacent = new ArrayList<>();\\n        for (int i=0; i<n; i++)\\n            adjacent.add(new ArrayList<>());\\n        for (int [] edge: edges) {\\n            adjacent.get(edge[0]).add(edge[1]);\\n            adjacent.get(edge[1]).add(edge[0]);\\n        }\\n        boolean visited [] = new boolean[n];\\n        DFSHelper(0, visited, labels, adjacent, frequency);\\n        return frequency;\\n    }\\n    public int [] DFSHelper(int v, boolean [] visited, String labels, List<List<Integer>> adjacent, int [] frequency) {\\n        visited[v] = true;\\n        int [] countLabel = new int [26];\\n        List<int[]> children = new ArrayList<>();\\n        int index = labels.charAt(v) - \\'a\\';\\n        for (int child: adjacent.get(v)) {\\n            if (!visited[child]) {\\n                children.add(DFSHelper(child, visited, labels, adjacent, frequency));\\n            }\\n        }\\n        for (int [] child: children) {\\n            for (int i=0; i<26; i++) {\\n                countLabel[i] += child[i];\\n            }\\n        }\\n        countLabel[index] ++;\\n        frequency[v] = countLabel[index];\\n        return countLabel;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753049,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        int [] sol = new int[n];\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for(int i= 0 ; i < n ; i++){\\n            graph.put(i, new ArrayList<>());\\n        }\\n        for(int [] edge : edges){\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        boolean [] visited = new boolean[n];\\n        // count array contains count of each character\\n\\t\\tint [] count = new int [26];\\n\\t\\t// Starting from \"0\", since the question says the root is always 0\\n        dfs(graph, visited, sol, 0, labels, count);\\n        return sol;\\n    }\\n    \\n    void dfs(Map<Integer, List<Integer>> graph, boolean[] visited, int [] sol, int current, String label, int [] count){\\n        if(visited[current]){\\n            return;\\n        }\\n        visited[current] = true;\\n        for(Integer neighbour : graph.get(current)){\\n            if(!visited[neighbour]){\\n\\t\\t\\t\\t// creating new count array for the children\\n                int [] temp = new int[26];\\n                dfs(graph, visited, sol, neighbour, label, temp);\\n\\t\\t\\t\\t// adding the values of count from children to parent\\n                for(int i = 0 ; i < 26 ; i++){\\n                    count[i] += temp[i];\\n                }\\n            }\\n        }\\n        count[label.charAt(current) - \\'a\\']++;\\n\\t\\t// After traversing children of current parent assign count of the current character as the  solution\\n        sol[current] = count[label.charAt(current)-\\'a\\'];\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        int [] sol = new int[n];\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for(int i= 0 ; i < n ; i++){\\n            graph.put(i, new ArrayList<>());\\n        }\\n        for(int [] edge : edges){\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        boolean [] visited = new boolean[n];\\n        // count array contains count of each character\\n\\t\\tint [] count = new int [26];\\n\\t\\t// Starting from \"0\", since the question says the root is always 0\\n        dfs(graph, visited, sol, 0, labels, count);\\n        return sol;\\n    }\\n    \\n    void dfs(Map<Integer, List<Integer>> graph, boolean[] visited, int [] sol, int current, String label, int [] count){\\n        if(visited[current]){\\n            return;\\n        }\\n        visited[current] = true;\\n        for(Integer neighbour : graph.get(current)){\\n            if(!visited[neighbour]){\\n\\t\\t\\t\\t// creating new count array for the children\\n                int [] temp = new int[26];\\n                dfs(graph, visited, sol, neighbour, label, temp);\\n\\t\\t\\t\\t// adding the values of count from children to parent\\n                for(int i = 0 ; i < 26 ; i++){\\n                    count[i] += temp[i];\\n                }\\n            }\\n        }\\n        count[label.charAt(current) - \\'a\\']++;\\n\\t\\t// After traversing children of current parent assign count of the current character as the  solution\\n        sol[current] = count[label.charAt(current)-\\'a\\'];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743578,
                "title": "c-accepted-dfs-backtracking-solution-with-comments-and-explanation",
                "content": "We are traversing in a DFS manner. cstHelper returns count of all the labels in the sub-tree of this node and also sets result for the node in the result.\\n\\nPlease be careful not to pass the count values to be shared between child and parent.\\n\\n*PS: Please upvote, if you find it helpful :)*\\n\\n\\n    /*\\n    Start traversing the tree and each node should return a vector to its parent node.\\n    The vector should be of length 26 and have the count of all the labels in the sub-tree of this node.\\n    */\\n    class Solution {\\n        unordered_map<int, vector<int>> adjList;\\n        vector<int> result;\\n        string labels;\\n    public:\\n        \\n        //Returns count of all the labels in the sub-tree of this node.\\n        //And sets result for the node in the result.\\n        vector<int> cstHelper(int node, vector<int> &charCount){\\n            result[node]=1;\\n            for(int i=0;i<adjList[node].size();i++){\\n                //Visit only unvisited nodes.\\n                if(result[adjList[node][i]]==0){\\n                    vector<int> charCountNew(26,0);\\n                    //I don\\'t want values to propagate between childs. Hence new copy. \\n\\t\\t\\t\\t\\t//Child don\\'t need parent values anyways.\\n                    cstHelper(adjList[node][i], charCountNew);\\n\\t\\t\\t\\t\\t//But child must share count values with parent, Hence adding to parent array.\\n                    for(int j=0;j<26;j++)\\n                        charCount[j]+=charCountNew[j];\\n                }\\n            }\\n            charCount[labels[node]-\\'a\\']++;\\n            result[node]=charCount[labels[node]-\\'a\\'];\\n            return charCount;\\n        }\\n        \\n        vector<int> countSubTrees(int n, vector<vector<int>>& edges, string l) {\\n            result.resize(n,0);\\n            labels=l;\\n            vector<int> charCount(26,0);\\n            for(int i=0;i<edges.size();i++){\\n                adjList[edges[i][0]].push_back(edges[i][1]);\\n                adjList[edges[i][1]].push_back(edges[i][0]);\\n            }\\n            cstHelper(0, charCount);\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n        unordered_map<int, vector<int>> adjList;\\n        vector<int> result;\\n        string labels;\\n    public:\\n        \\n        //Returns count of all the labels in the sub-tree of this node.\\n        //And sets result for the node in the result.\\n        vector<int> cstHelper(int node, vector<int> &charCount){\\n            result[node]=1;\\n            for(int i=0;i<adjList[node].size();i++){\\n                //Visit only unvisited nodes.\\n                if(result[adjList[node][i]]==0){\\n                    vector<int> charCountNew(26,0);\\n                    //I don\\'t want values to propagate between childs. Hence new copy. \\n\\t\\t\\t\\t\\t//Child don\\'t need parent values anyways.\\n                    cstHelper(adjList[node][i], charCountNew);\\n\\t\\t\\t\\t\\t//But child must share count values with parent, Hence adding to parent array.\\n                    for(int j=0;j<26;j++)\\n                        charCount[j]+=charCountNew[j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 743510,
                "title": "simple-python-dfs-recursive-solution",
                "content": "```\\nimport collections\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        tree = collections.defaultdict(list)\\n        for i,j in edges:\\n            tree[i].append(j)  \\n            tree[j].append(i)\\n        \\n        res = [0]*n \\n        visited = [False]*n\\n        \\n        def dfs(node):\\n            visited[node] = True\\n            count = [0]*26\\n            for nei in tree[node]:\\n                if visited[nei] == False:\\n                    ret = dfs(nei)\\n\\t\\t\\t\\t\\t\\n                    for i in range(26):\\n                        count[i] += ret[i]\\n                    \\n            count[ord(labels[node])%ord(\\'a\\')] += 1\\n            res[node] = count[ord(labels[node])%ord(\\'a\\')]\\n\\t\\t\\t\\n            return count\\n        \\n        dfs(0)\\n        return res\\n```\\nPlease Upvote : )",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        tree = collections.defaultdict(list)\\n        for i,j in edges:\\n            tree[i].append(j)  \\n            tree[j].append(i)\\n        \\n        res = [0]*n \\n        visited = [False]*n\\n        \\n        def dfs(node):\\n            visited[node] = True\\n            count = [0]*26\\n            for nei in tree[node]:\\n                if visited[nei] == False:\\n                    ret = dfs(nei)\\n\\t\\t\\t\\t\\t\\n                    for i in range(26):\\n                        count[i] += ret[i]\\n                    \\n            count[ord(labels[node])%ord(\\'a\\')] += 1\\n            res[node] = count[ord(labels[node])%ord(\\'a\\')]\\n\\t\\t\\t\\n            return count\\n        \\n        dfs(0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743282,
                "title": "python-two-solutions-postorder-bonus-unique-approach",
                "content": "Approach 1:\\nReminding you the post-order-traversal: Visit all the descendants first.(left,right,root if binaryTree)\\n\\n\\tclass Solution:\\n\\t\\tdef countSubTrees(self, n: int, edges: List[List[int]], label: str) -> List[int]:\\n\\t\\t\\tanswer ,seen = {}, {}\\n\\t\\t\\t\\n\\t\\t\\t#post-order traversal-core-logic\\n\\t\\t\\tdef dfs(node):\\n\\t\\t\\t\\tseen[node] = True\\n\\t\\t\\t\\tcount = collections.Counter()\\n\\t\\t\\t\\tfor nei in graph[node]:\\n\\t\\t\\t\\t\\tif nei not in seen:\\n\\t\\t\\t\\t\\t\\tcount += dfs(nei)\\n\\t\\t\\t\\tlb = label[node]\\n\\t\\t\\t\\tcount[lb] += 1\\n\\t\\t\\t\\tanswer[node] = count[lb]\\n\\t\\t\\t\\treturn count    \\n\\t\\t\\t\\t\\n\\t\\t\\t#graph formation - adjacency list of the undirected graph.\\n\\t\\t\\tgraph = collections.defaultdict(list)\\n\\t\\t\\tfor u,v in edges:\\n\\t\\t\\t\\tgraph[u].append(v)\\n\\t\\t\\t\\tgraph[v].append(u)\\n\\t\\t\\t\\n\\t\\t\\t#Return the result\\n\\t\\t\\tdfs(0)\\n\\t\\t\\tres = [answer.get(i,1) for i in range(n)]\\n\\t\\t\\treturn res\\n\\n\\nApproach-2\\n\\n\\nNot the best ,but a different method  :) If you are  beginner then you might consider reading till the end to steal some code/ideas/implementation specifics that you should use frequently in solving many questions based on recursion,dfs,dsu and lot more.\\n\\nDSU : Disjoint Set Union. DFS : Depth First Search Counter: hashmap\\n This is a very long but a unique approach.The idea is to discover all the ways to solve a problem.You\\n can find the short and sweet solutions from other posts.Now into the solution ===>>\\nThe input is an undirected graph and the idea is to convert the undirected graph into a tree and then do the DFS with a counter.\\n```\\nsteps: \\n\\t1)convert into a tree.(directed graph) Note: The  resultant tree need not be a binary tree.\\n\\t\\tuse DSU:\\n\\t\\t\\tfor every edge (u,v)\\n\\t\\t\\t\\tu,v = old node (i.e node in tree) , new node (i.e not a node in tree yet)\\n\\t\\t\\t\\tgraph[u].append(v) \\n\\t\\t\\t\\tunion(u,v)\\n\\t2)perform dfs on the tree, \\n\\t     for each node:\\n\\t\\t\\t\\t\\tobtain counts of all labels from all of its descendants.\\n\\t\\t\\t\\t\\tincrement the count of the node label \\n\\t\\t\\t\\t\\tcollect the answer for the node as descendantCount+1\\n\\t\\t\\t\\t\\treturn the count to the parent of the node.\\n```\\ntypical implementation of the above mentioned approach. \\n```python\\nclass DSU:\\n    def __init__(self,n):\\n        self.par = [i for i in range(n)]\\n\\n    def find(self,x):\\n        if self.par[x] != x:\\n            self.par[x] = self.find(self.par[x])\\n        return self.par[x]\\n        \\n    def union(self,x,y):\\n        px,py = self.find(x),self.find(y)\\n        if px == py:\\n            return False\\n        self.par[px] = py\\n        return True\\n\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], label: str) -> List[int]:\\n        dsu = DSU(n)\\n        answer = {}\\n        def dfs(node):\\n            count = collections.Counter()\\n            lb = label[node]\\n            count[lb] += 1\\n            \\n            for nei in graph[node]:\\n                count += dfs(nei)\\n\\n            answer[node] = count[lb]\\n            return count    \\n        \\n        graph = collections.defaultdict(list)\\n        \\n        for u,v in edges:\\n            root = dsu.find(0)\\n            if dsu.find(v) == root and dsu.find(u) != root:\\n                u,v = v,u\\n            graph[u].append(v)\\n            dsu.union(u,v)\\n          \\n        dfs(0)\\n                \\n        res = []\\n        for i in range(n):\\n            res.append(answer.get(i,1))\\n        return res\\n```\\n\\nThe idea behind looking at solutions for a question is not about solving/understanding this question alone.  It is to enable ourselves to solve any other question that comesup with similar logic/ds/algorithm or learning a mixture of unique techniques. Now,go ahead and see all other possible solutions and do them.Upvote if you found it informative :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nsteps: \\n\\t1)convert into a tree.(directed graph) Note: The  resultant tree need not be a binary tree.\\n\\t\\tuse DSU:\\n\\t\\t\\tfor every edge (u,v)\\n\\t\\t\\t\\tu,v = old node (i.e node in tree) , new node (i.e not a node in tree yet)\\n\\t\\t\\t\\tgraph[u].append(v) \\n\\t\\t\\t\\tunion(u,v)\\n\\t2)perform dfs on the tree, \\n\\t     for each node:\\n\\t\\t\\t\\t\\tobtain counts of all labels from all of its descendants.\\n\\t\\t\\t\\t\\tincrement the count of the node label \\n\\t\\t\\t\\t\\tcollect the answer for the node as descendantCount+1\\n\\t\\t\\t\\t\\treturn the count to the parent of the node.\\n```\n```python\\nclass DSU:\\n    def __init__(self,n):\\n        self.par = [i for i in range(n)]\\n\\n    def find(self,x):\\n        if self.par[x] != x:\\n            self.par[x] = self.find(self.par[x])\\n        return self.par[x]\\n        \\n    def union(self,x,y):\\n        px,py = self.find(x),self.find(y)\\n        if px == py:\\n            return False\\n        self.par[px] = py\\n        return True\\n\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], label: str) -> List[int]:\\n        dsu = DSU(n)\\n        answer = {}\\n        def dfs(node):\\n            count = collections.Counter()\\n            lb = label[node]\\n            count[lb] += 1\\n            \\n            for nei in graph[node]:\\n                count += dfs(nei)\\n\\n            answer[node] = count[lb]\\n            return count    \\n        \\n        graph = collections.defaultdict(list)\\n        \\n        for u,v in edges:\\n            root = dsu.find(0)\\n            if dsu.find(v) == root and dsu.find(u) != root:\\n                u,v = v,u\\n            graph[u].append(v)\\n            dsu.union(u,v)\\n          \\n        dfs(0)\\n                \\n        res = []\\n        for i in range(n):\\n            res.append(answer.get(i,1))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743252,
                "title": "javascript-iterative-solution-bfs-and-then-bottom-up",
                "content": "Very slow solution (7 seconds), but still passed the leetcode judge somehow...\\n\\nI didn\\'t use recursion because I think 10^5 extreme case will exceed JS call stack.\\n\\nAppreciate feedback or improvement suggestions (I am so bad at tree / graphs).\\n```js\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {string} labels\\n * @return {number[]}\\n */\\nvar countSubTrees = function (n, edges, labels) {\\n  // build edge map\\n  let edgeMap = {};\\n  for (let i = 0; i < edges.length; i++) {\\n    const [a, b] = edges[i];\\n    if (edgeMap[a]) {\\n      edgeMap[a].push(b);\\n    } else {\\n      edgeMap[a] = [b];\\n    }\\n    if (edgeMap[b]) {\\n      edgeMap[b].push(a);\\n    } else {\\n      edgeMap[b] = [a];\\n    }\\n  }\\n  // build levels\\n  let level = 0;\\n  let levels = {};\\n  let nodes = {};\\n  let ans = [];\\n  levels[0] = [];\\n  let q = [0];\\n  let newq = [];\\n  while (q.length > 0) {\\n    const i = q.pop();\\n    const node = {\\n      number: i,\\n      children: [],\\n    };\\n    const nei = edgeMap[i];\\n    for (let i = 0; i < nei.length; i++) {\\n      const element = nei[i];\\n      if (nodes[element]) {\\n        nodes[element].children.push(node);\\n      } else {\\n        newq.push(element);\\n      }\\n    }\\n    nodes[i] = node;\\n    levels[level].push(node);\\n    if (q.length === 0) {\\n      level++;\\n      levels[level] = [];\\n      q = newq;\\n      newq = [];\\n    }\\n  }\\n  level--;\\n  // go from bottom level to top level, accumulating label count\\n  for (let i = level; i >= 0; i--) {\\n    const currLevel = levels[i];\\n    for (let j = 0; j < currLevel.length; j++) {\\n      const element = currLevel[j];\\n      if (element.children.length === 0) {\\n        ans[element.number] = 1;\\n        element.labelMap = {\\n          [labels[element.number]]: 1,\\n        };\\n      } else {\\n        element.labelMap = {\\n          [labels[element.number]]: 1,\\n        };\\n        for (let k = 0; k < element.children.length; k++) {\\n          const child = element.children[k];\\n          if (child.labelMap) {\\n            for (const key in child.labelMap) {\\n              if (child.labelMap.hasOwnProperty(key)) {\\n                if (element.labelMap[key]) {\\n                  element.labelMap[key] =\\n                    element.labelMap[key] + child.labelMap[key];\\n                } else {\\n                  element.labelMap[key] = child.labelMap[key];\\n                }\\n              }\\n            }\\n          }\\n        }\\n        ans[element.number] = element.labelMap[labels[element.number]];\\n      }\\n    }\\n  }\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```js\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {string} labels\\n * @return {number[]}\\n */\\nvar countSubTrees = function (n, edges, labels) {\\n  // build edge map\\n  let edgeMap = {};\\n  for (let i = 0; i < edges.length; i++) {\\n    const [a, b] = edges[i];\\n    if (edgeMap[a]) {\\n      edgeMap[a].push(b);\\n    } else {\\n      edgeMap[a] = [b];\\n    }\\n    if (edgeMap[b]) {\\n      edgeMap[b].push(a);\\n    } else {\\n      edgeMap[b] = [a];\\n    }\\n  }\\n  // build levels\\n  let level = 0;\\n  let levels = {};\\n  let nodes = {};\\n  let ans = [];\\n  levels[0] = [];\\n  let q = [0];\\n  let newq = [];\\n  while (q.length > 0) {\\n    const i = q.pop();\\n    const node = {\\n      number: i,\\n      children: [],\\n    };\\n    const nei = edgeMap[i];\\n    for (let i = 0; i < nei.length; i++) {\\n      const element = nei[i];\\n      if (nodes[element]) {\\n        nodes[element].children.push(node);\\n      } else {\\n        newq.push(element);\\n      }\\n    }\\n    nodes[i] = node;\\n    levels[level].push(node);\\n    if (q.length === 0) {\\n      level++;\\n      levels[level] = [];\\n      q = newq;\\n      newq = [];\\n    }\\n  }\\n  level--;\\n  // go from bottom level to top level, accumulating label count\\n  for (let i = level; i >= 0; i--) {\\n    const currLevel = levels[i];\\n    for (let j = 0; j < currLevel.length; j++) {\\n      const element = currLevel[j];\\n      if (element.children.length === 0) {\\n        ans[element.number] = 1;\\n        element.labelMap = {\\n          [labels[element.number]]: 1,\\n        };\\n      } else {\\n        element.labelMap = {\\n          [labels[element.number]]: 1,\\n        };\\n        for (let k = 0; k < element.children.length; k++) {\\n          const child = element.children[k];\\n          if (child.labelMap) {\\n            for (const key in child.labelMap) {\\n              if (child.labelMap.hasOwnProperty(key)) {\\n                if (element.labelMap[key]) {\\n                  element.labelMap[key] =\\n                    element.labelMap[key] + child.labelMap[key];\\n                } else {\\n                  element.labelMap[key] = child.labelMap[key];\\n                }\\n              }\\n            }\\n          }\\n        }\\n        ans[element.number] = element.labelMap[labels[element.number]];\\n      }\\n    }\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 743126,
                "title": "java-solution",
                "content": "\\n    int[] result;\\n    Set<Integer> visited;\\n    Map<Integer, Set<Integer>> graph;\\n    String labels;\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        visited = new HashSet<>();\\n        this.labels = labels;\\n        result = new int[n];\\n        graph = buildGraph(edges);\\n        findLabels(0);\\n        return result;\\n    }\\n\\n    private Map<Integer, Set<Integer>> buildGraph(int[][] edges) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for (int[] e : edges) {\\n            int a = e[0];\\n            int b = e[1];\\n            addEdge(map, a, b);\\n            addEdge(map, b, a);\\n        }\\n        return map;\\n    }\\n\\n    private void addEdge(Map<Integer, Set<Integer>> map, int a, int b) {\\n        if (!map.containsKey(a)) {\\n            map.put(a, new HashSet<>());\\n        }\\n        map.get(a).add(b);\\n    }\\n\\n    private int[] findLabels(int root) {\\n        int[] allLabelsCounter = new int[26];\\n        if (visited.contains(root)) {\\n            return allLabelsCounter;\\n        }\\n        visited.add(root);\\n        Set<Integer> neighbors = graph.get(root);\\n        int labelIndex = labels.charAt(root) - \\'a\\';\\n        allLabelsCounter[labelIndex]++;\\n        if (neighbors == null || neighbors.size() == 0) {\\n            result[root] = allLabelsCounter[labelIndex];\\n            return allLabelsCounter;\\n        }\\n        for (int nbr : neighbors) {\\n            int[] temp = findLabels(nbr);\\n            for (int i = 0; i < temp.length; i++) {\\n                allLabelsCounter[i] += temp[i];\\n            }\\n        }\\n        result[root] = allLabelsCounter[labelIndex];\\n        return allLabelsCounter;\\n    }",
                "solutionTags": [],
                "code": "\\n    int[] result;\\n    Set<Integer> visited;\\n    Map<Integer, Set<Integer>> graph;\\n    String labels;\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        visited = new HashSet<>();\\n        this.labels = labels;\\n        result = new int[n];\\n        graph = buildGraph(edges);\\n        findLabels(0);\\n        return result;\\n    }\\n\\n    private Map<Integer, Set<Integer>> buildGraph(int[][] edges) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for (int[] e : edges) {\\n            int a = e[0];\\n            int b = e[1];\\n            addEdge(map, a, b);\\n            addEdge(map, b, a);\\n        }\\n        return map;\\n    }\\n\\n    private void addEdge(Map<Integer, Set<Integer>> map, int a, int b) {\\n        if (!map.containsKey(a)) {\\n            map.put(a, new HashSet<>());\\n        }\\n        map.get(a).add(b);\\n    }\\n\\n    private int[] findLabels(int root) {\\n        int[] allLabelsCounter = new int[26];\\n        if (visited.contains(root)) {\\n            return allLabelsCounter;\\n        }\\n        visited.add(root);\\n        Set<Integer> neighbors = graph.get(root);\\n        int labelIndex = labels.charAt(root) - \\'a\\';\\n        allLabelsCounter[labelIndex]++;\\n        if (neighbors == null || neighbors.size() == 0) {\\n            result[root] = allLabelsCounter[labelIndex];\\n            return allLabelsCounter;\\n        }\\n        for (int nbr : neighbors) {\\n            int[] temp = findLabels(nbr);\\n            for (int i = 0; i < temp.length; i++) {\\n                allLabelsCounter[i] += temp[i];\\n            }\\n        }\\n        result[root] = allLabelsCounter[labelIndex];\\n        return allLabelsCounter;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3046210,
                "title": "c-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>e;\\n    vector<int>ans;\\n    vector<int>vis;\\n    string l=\"\";\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        e.resize(n);\\n        ans.resize(n);\\n        vis.resize(n);\\n        for(auto i:edges){\\n            e[i[0]].emplace_back(i[1]);\\n            e[i[1]].emplace_back(i[0]);\\n        }\\n        for(auto i:labels){\\n            l+=i;\\n        }\\n        vis[0]=1;\\n        dfs(0);\\n        return ans;\\n\\n    }\\n    vector<int> dfs(int i){\\n        vector<int>mp(26);\\n        mp[l[i]-\\'a\\']++;\\n        for(auto j:e[i]){\\n            if(!vis[j]){\\n            vis[j]=1;\\n            vector<int>m(26);\\n            m=dfs(j);\\n            for(int ii=0;ii<26;ii++){\\n                mp[ii]+=m[ii];\\n            }\\n            }\\n        }\\n        ans[i]=mp[l[i]-\\'a\\'];\\n        return mp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>e;\\n    vector<int>ans;\\n    vector<int>vis;\\n    string l=\"\";\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        e.resize(n);\\n        ans.resize(n);\\n        vis.resize(n);\\n        for(auto i:edges){\\n            e[i[0]].emplace_back(i[1]);\\n            e[i[1]].emplace_back(i[0]);\\n        }\\n        for(auto i:labels){\\n            l+=i;\\n        }\\n        vis[0]=1;\\n        dfs(0);\\n        return ans;\\n\\n    }\\n    vector<int> dfs(int i){\\n        vector<int>mp(26);\\n        mp[l[i]-\\'a\\']++;\\n        for(auto j:e[i]){\\n            if(!vis[j]){\\n            vis[j]=1;\\n            vector<int>m(26);\\n            m=dfs(j);\\n            for(int ii=0;ii<26;ii++){\\n                mp[ii]+=m[ii];\\n            }\\n            }\\n        }\\n        ans[i]=mp[l[i]-\\'a\\'];\\n        return mp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043758,
                "title": "beats-98-57-try-passing-string-by-references",
                "content": "# Code\\n```\\nclass Solution {\\npublic:vector<int> sols;\\n    vector<int> sets(string& sums2, vector<int> graphbethe[],int starts,vector<int> &pp,vector<int>& visit){\\n        visit[starts]++;\\n        int ll=pp[sums2[starts]-\\'a\\'];\\n            vector<int> pp2;\\n            pp[sums2[starts]-\\'a\\']+=1;\\n        for(auto& po:graphbethe[starts]){\\n           if(visit[po]==1){continue;}\\n            vector<int> po2=sets(sums2,graphbethe,po,pp,visit);  \\n        }\\n         sols[starts]=pp[sums2[starts]-\\'a\\']-ll;\\n        return pp2;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n     vector<int> graphbethe[n];\\n     for(auto &p:edges){\\n        graphbethe[p[0]].push_back(p[1]); \\n        graphbethe[p[1]].push_back(p[0]);\\n     }\\n      for(int p=0;p<n;p++){\\n          sols.push_back(0);\\n      }\\n     vector<int> visit(n);\\n     vector<int> pp(26,0);\\n     vector<int> se=sets(labels,graphbethe,0,pp,visit);\\n     return sols;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:vector<int> sols;\\n    vector<int> sets(string& sums2, vector<int> graphbethe[],int starts,vector<int> &pp,vector<int>& visit){\\n        visit[starts]++;\\n        int ll=pp[sums2[starts]-\\'a\\'];\\n            vector<int> pp2;\\n            pp[sums2[starts]-\\'a\\']+=1;\\n        for(auto& po:graphbethe[starts]){\\n           if(visit[po]==1){continue;}\\n            vector<int> po2=sets(sums2,graphbethe,po,pp,visit);  \\n        }\\n         sols[starts]=pp[sums2[starts]-\\'a\\']-ll;\\n        return pp2;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n     vector<int> graphbethe[n];\\n     for(auto &p:edges){\\n        graphbethe[p[0]].push_back(p[1]); \\n        graphbethe[p[1]].push_back(p[0]);\\n     }\\n      for(int p=0;p<n;p++){\\n          sols.push_back(0);\\n      }\\n     vector<int> visit(n);\\n     vector<int> pp(26,0);\\n     vector<int> se=sets(labels,graphbethe,0,pp,visit);\\n     return sols;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043312,
                "title": "c-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    vector<int> solve(vector<vector<int>>&adj, int start, int parent, string &labels)\\n    {\\n        vector<int>cnt(26,0);\\n        vector<int>temp;\\n        for(auto x:adj[start])\\n        {\\n            if(x==parent)\\n            continue;\\n            temp.clear();\\n            temp= solve(adj, x, start, labels);\\n            for(int i=0;i<26;i++)\\n            cnt[i]+=temp[i];\\n        }\\n        cnt[labels[start]-\\'a\\']++;\\n        ans[start]=cnt[labels[start]-\\'a\\'];\\n        return cnt;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>>adj(n);\\n        for(auto x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        ans.resize(n,0);\\n        solve(adj, 0, -1, labels);\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    vector<int> solve(vector<vector<int>>&adj, int start, int parent, string &labels)\\n    {\\n        vector<int>cnt(26,0);\\n        vector<int>temp;\\n        for(auto x:adj[start])\\n        {\\n            if(x==parent)\\n            continue;\\n            temp.clear();\\n            temp= solve(adj, x, start, labels);\\n            for(int i=0;i<26;i++)\\n            cnt[i]+=temp[i];\\n        }\\n        cnt[labels[start]-\\'a\\']++;\\n        ans[start]=cnt[labels[start]-\\'a\\'];\\n        return cnt;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>>adj(n);\\n        for(auto x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        ans.resize(n,0);\\n        solve(adj, 0, -1, labels);\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042949,
                "title": "c-dfs-hashing",
                "content": "```\\nclass Solution\\n{\\npublic:\\n\\tvector<int> dfs(int i, vector<int> adj[], vector<int> &vis, string &str, vector<int> &ans)\\n\\t{\\n\\t\\tvis[i] = 1;\\n\\t\\tvector<int> count(26, 0);\\n\\t\\tfor (auto &it: adj[i])\\n\\t\\t{\\n\\t\\t\\tif (vis[it] == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvector<int> adj_count(26, 0);\\n\\t\\t\\t\\tadj_count = dfs(it, adj, vis, str, ans);\\n\\t\\t\\t\\tfor (int i = 0; i < 26; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount[i] += adj_count[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tcount[str[i] - \\'a\\']++;\\n\\t\\tans[i] = count[str[i] - \\'a\\'];\\n\\t\\treturn count;\\n\\t}\\n\\n\\tvector<int> countSubTrees(int n, vector<vector < int>> &edges, string str)\\n\\t{\\n\\t\\tvector<int> adj[n + 1];\\n\\t\\tfor (int i = 0; i < edges.size(); i++)\\n\\t\\t{\\n\\t\\t\\tint u = edges[i][0], v = edges[i][1];\\n\\t\\t\\tadj[u].push_back(v);\\n\\t\\t\\tadj[v].push_back(u);\\n\\t\\t}\\n\\n\\t\\tvector<int> vis(n, -1);\\n\\t\\tvector<int> cnt(26, 0);\\n\\t\\tvector<int> ans(n);\\n\\t\\tcnt = dfs(0, adj, vis, str, ans);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tvector<int> dfs(int i, vector<int> adj[], vector<int> &vis, string &str, vector<int> &ans)\\n\\t{\\n\\t\\tvis[i] = 1;\\n\\t\\tvector<int> count(26, 0);\\n\\t\\tfor (auto &it: adj[i])\\n\\t\\t{\\n\\t\\t\\tif (vis[it] == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvector<int> adj_count(26, 0);\\n\\t\\t\\t\\tadj_count = dfs(it, adj, vis, str, ans);\\n\\t\\t\\t\\tfor (int i = 0; i < 26; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount[i] += adj_count[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tcount[str[i] - \\'a\\']++;\\n\\t\\tans[i] = count[str[i] - \\'a\\'];\\n\\t\\treturn count;\\n\\t}\\n\\n\\tvector<int> countSubTrees(int n, vector<vector < int>> &edges, string str)\\n\\t{\\n\\t\\tvector<int> adj[n + 1];\\n\\t\\tfor (int i = 0; i < edges.size(); i++)\\n\\t\\t{\\n\\t\\t\\tint u = edges[i][0], v = edges[i][1];\\n\\t\\t\\tadj[u].push_back(v);\\n\\t\\t\\tadj[v].push_back(u);\\n\\t\\t}\\n\\n\\t\\tvector<int> vis(n, -1);\\n\\t\\tvector<int> cnt(26, 0);\\n\\t\\tvector<int> ans(n);\\n\\t\\tcnt = dfs(0, adj, vis, str, ans);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042417,
                "title": "simple-java-code",
                "content": "# simple java code \\n\\n# Code\\n```\\nclass Solution {\\n    int[] array;\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n\\n        array = new int[n]; //output array\\n    \\n       \\n        ArrayList<Integer>[] a = new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            a[i] = new ArrayList<Integer>();\\n        }\\n\\n        for(int[] x:edges){\\n            a[x[0]].add(x[1]);\\n            a[x[1]].add(x[0]);\\n        }\\n\\n        dfs(-1,0,a,labels);\\n        return array;\\n    }\\n\\n    private int[] dfs(int prev,int curr,ArrayList<Integer>[] a,String labels)\\n    {\\n        int[] ans = new int[26];  //freq array \\n        for(int x:a[curr])\\n        {\\n            if(prev!=x)\\n            {\\n              \\n                int[] res = dfs(curr,x,a,labels);  \\n                \\n                for(int i=0;i<res.length;i++)  \\n                    ans[i]+=res[i];\\n            }\\n        }\\n        \\n        array[curr] = ++ans[labels.charAt(curr)-\\'a\\']; \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] array;\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n\\n        array = new int[n]; //output array\\n    \\n       \\n        ArrayList<Integer>[] a = new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            a[i] = new ArrayList<Integer>();\\n        }\\n\\n        for(int[] x:edges){\\n            a[x[0]].add(x[1]);\\n            a[x[1]].add(x[0]);\\n        }\\n\\n        dfs(-1,0,a,labels);\\n        return array;\\n    }\\n\\n    private int[] dfs(int prev,int curr,ArrayList<Integer>[] a,String labels)\\n    {\\n        int[] ans = new int[26];  //freq array \\n        for(int x:a[curr])\\n        {\\n            if(prev!=x)\\n            {\\n              \\n                int[] res = dfs(curr,x,a,labels);  \\n                \\n                for(int i=0;i<res.length;i++)  \\n                    ans[i]+=res[i];\\n            }\\n        }\\n        \\n        array[curr] = ++ans[labels.charAt(curr)-\\'a\\']; \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042326,
                "title": "dart-iterative-dfs",
                "content": "# Approach\\nDepth-first search through the tree, maintaining a hash map mapping label -> node ID for all parent nodes in the tree.\\n\\nBecause the tree isn\\'t guaranteed to be balanced, stack depth for a recursive implementation could grow to $O(n)$, which will cause stack overflow in many environments, including the Leetcode Dart environment. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n\\n## Initial recursive approach (stack overflow on large unbalanced trees)\\n\\n```dart\\nclass Solution {\\n  List<int> countSubTrees(int n, List<List<int>> edges, String labels) {\\n    final result = List<int>.filled(n, 0);\\n    final graph = _buildGraph(edges);\\n    final labelToId = <int, List<int>>{};\\n    void dfs(int id, int parentId) {     \\n      final label = labels.codeUnits[id];\\n      final nodesWithMatchingLabels = labelToId.update(\\n        label, \\n        (nodes) {\\n          nodes.add(cur.id);\\n          return nodes;\\n        },\\n        ifAbsent: () => [cur.id]);\\n      for (final match in nodesWithMatchingLabels) {\\n        result[match]++;\\n      }\\n      for (final childId in graph[id]!) {\\n        if (childId == parentId) {\\n          continue;\\n        }\\n        dfs(childId, id);\\n      }\\n      if (parentsWithMatchingLabels.length > 1) {\\n        parentsWithMatchingLabels.removeLast();\\n      } else {\\n        labelToId.remove(label);\\n      }\\n    }\\n    dfs(0, -1);\\n    return result;\\n  }\\n\\n  Map<int, List<int>> _buildGraph(List<List<int>> edges) {\\n    final g = <int, List<int>>{};\\n    for (final edge in edges) {\\n      g.update(edge[0],\\n        (neighbors) {\\n          neighbors.add(edge[1]);\\n          return neighbors;\\n        },\\n        ifAbsent: () => [edge[1]]);\\n      g.update(edge[1],\\n        (neighbors) {\\n          neighbors.add(edge[0]);\\n          return neighbors;\\n        },\\n        ifAbsent: () => [edge[0]]);\\n    }\\n    return g;\\n  }\\n}\\n```\\n\\n## Iterative DFS (solves stack overflows)\\n\\n```dart\\nclass DFSState {\\n  int id;\\n  int parentId;\\n  bool visited = false;\\n  DFSState(this.id, this.parentId);\\n}\\n\\nclass Solution {\\n  List<int> countSubTrees(int n, List<List<int>> edges, String labels) {\\n    final result = List<int>.filled(n, 0);\\n    final graph = _buildGraph(edges);\\n    final labelToId = <int, List<int>>{};\\n    final stack = [DFSState(0, -1)];\\n    while (stack.isNotEmpty) {\\n      final cur = stack.last;\\n      final label = labels.codeUnits[cur.id];\\n      if (!cur.visited) {\\n        final nodesWithMatchingLabels = labelToId.update(\\n          label, \\n          (nodes) {\\n            nodes.add(cur.id);\\n            return nodes;\\n          },\\n          ifAbsent: () => [cur.id]);\\n        for (final match in nodesWithMatchingLabels) {\\n          result[match]++;\\n        }\\n        for (final childId in graph[cur.id]!) {\\n          if (childId == cur.parentId) {\\n            continue;\\n          }\\n          stack.add(DFSState(childId, cur.id));\\n        }\\n        cur.visited = true;\\n      } else {  // cur.visited\\n        // Already visited this node and all children, just need to clean up.\\n        final nodesWithMatchingLabels = labelToId[label]!;\\n        if (nodesWithMatchingLabels.length > 1) {\\n          nodesWithMatchingLabels.removeLast();\\n        } else {\\n          labelToId.remove(label);\\n        }\\n        stack.removeLast();\\n      }\\n    }\\n    return result;\\n  }\\n\\n  Map<int, List<int>> _buildGraph(List<List<int>> edges) {\\n    final g = <int, List<int>>{};\\n    for (final edge in edges) {\\n      g.update(edge[0],\\n        (neighbors) {\\n          neighbors.add(edge[1]);\\n          return neighbors;\\n        },\\n        ifAbsent: () => [edge[1]]);\\n      g.update(edge[1],\\n        (neighbors) {\\n          neighbors.add(edge[0]);\\n          return neighbors;\\n        },\\n        ifAbsent: () => [edge[0]]);\\n    }\\n    return g;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```dart\\nclass Solution {\\n  List<int> countSubTrees(int n, List<List<int>> edges, String labels) {\\n    final result = List<int>.filled(n, 0);\\n    final graph = _buildGraph(edges);\\n    final labelToId = <int, List<int>>{};\\n    void dfs(int id, int parentId) {     \\n      final label = labels.codeUnits[id];\\n      final nodesWithMatchingLabels = labelToId.update(\\n        label, \\n        (nodes) {\\n          nodes.add(cur.id);\\n          return nodes;\\n        },\\n        ifAbsent: () => [cur.id]);\\n      for (final match in nodesWithMatchingLabels) {\\n        result[match]++;\\n      }\\n      for (final childId in graph[id]!) {\\n        if (childId == parentId) {\\n          continue;\\n        }\\n        dfs(childId, id);\\n      }\\n      if (parentsWithMatchingLabels.length > 1) {\\n        parentsWithMatchingLabels.removeLast();\\n      } else {\\n        labelToId.remove(label);\\n      }\\n    }\\n    dfs(0, -1);\\n    return result;\\n  }\\n\\n  Map<int, List<int>> _buildGraph(List<List<int>> edges) {\\n    final g = <int, List<int>>{};\\n    for (final edge in edges) {\\n      g.update(edge[0],\\n        (neighbors) {\\n          neighbors.add(edge[1]);\\n          return neighbors;\\n        },\\n        ifAbsent: () => [edge[1]]);\\n      g.update(edge[1],\\n        (neighbors) {\\n          neighbors.add(edge[0]);\\n          return neighbors;\\n        },\\n        ifAbsent: () => [edge[0]]);\\n    }\\n    return g;\\n  }\\n}\\n```\n```dart\\nclass DFSState {\\n  int id;\\n  int parentId;\\n  bool visited = false;\\n  DFSState(this.id, this.parentId);\\n}\\n\\nclass Solution {\\n  List<int> countSubTrees(int n, List<List<int>> edges, String labels) {\\n    final result = List<int>.filled(n, 0);\\n    final graph = _buildGraph(edges);\\n    final labelToId = <int, List<int>>{};\\n    final stack = [DFSState(0, -1)];\\n    while (stack.isNotEmpty) {\\n      final cur = stack.last;\\n      final label = labels.codeUnits[cur.id];\\n      if (!cur.visited) {\\n        final nodesWithMatchingLabels = labelToId.update(\\n          label, \\n          (nodes) {\\n            nodes.add(cur.id);\\n            return nodes;\\n          },\\n          ifAbsent: () => [cur.id]);\\n        for (final match in nodesWithMatchingLabels) {\\n          result[match]++;\\n        }\\n        for (final childId in graph[cur.id]!) {\\n          if (childId == cur.parentId) {\\n            continue;\\n          }\\n          stack.add(DFSState(childId, cur.id));\\n        }\\n        cur.visited = true;\\n      } else {  // cur.visited\\n        // Already visited this node and all children, just need to clean up.\\n        final nodesWithMatchingLabels = labelToId[label]!;\\n        if (nodesWithMatchingLabels.length > 1) {\\n          nodesWithMatchingLabels.removeLast();\\n        } else {\\n          labelToId.remove(label);\\n        }\\n        stack.removeLast();\\n      }\\n    }\\n    return result;\\n  }\\n\\n  Map<int, List<int>> _buildGraph(List<List<int>> edges) {\\n    final g = <int, List<int>>{};\\n    for (final edge in edges) {\\n      g.update(edge[0],\\n        (neighbors) {\\n          neighbors.add(edge[1]);\\n          return neighbors;\\n        },\\n        ifAbsent: () => [edge[1]]);\\n      g.update(edge[1],\\n        (neighbors) {\\n          neighbors.add(edge[0]);\\n          return neighbors;\\n        },\\n        ifAbsent: () => [edge[0]]);\\n    }\\n    return g;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042137,
                "title": "easy-to-understand-dfs-o-n-26",
                "content": "**INTUTION :**\\nDo dfs and keep couting the labels along the traversal.Just keep in mind don\\'t use a global container for counting the label of whole tree otherwise answer of siblings will conflict and hence whole answer will be wrong.\\n\\n> **Do upvote, if it helps :)**\\n\\n**C++ :**\\n```\\n\\tvector<vector<int>> g;\\n    vector<int> ans;\\n    \\n     vector<int> dfs( int root , string &labels ){\\n        vector<int> cnt(26,0);\\n        ans[root] = 1 ;\\n        cnt[labels[root]-\\'a\\']++;\\n        for( auto nbr : g[root] ){\\n            if( !ans[nbr] ){\\n                vector<int> freq = dfs( nbr , labels );\\n                for( int i = 0 ; i < 26 ; i++ ) cnt[i] += freq[i] ;\\n            }\\n        }\\n        ans[root] = cnt[labels[root]-\\'a\\'];\\n        return cnt ;\\n    }\\n    \\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        g.resize(n);\\n        ans.resize(n,0);\\n        \\n        for( auto v : edges ){\\n            g[v[0]].push_back(v[1]);\\n            g[v[1]].push_back(v[0]);\\n        }\\n        \\n        dfs( 0 , labels );\\n        return ans ;\\n    }\\n```\\n**Python :**\\n```\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        g , ans = {} , [0]*n\\n        for i in range(n) : g[i] = []\\n        for e in edges : \\n            g[e[0]].append(e[1])    \\n            g[e[1]].append(e[0])\\n            \\n        def dfs( root ):\\n            ans[root] = 1\\n            cnt = {}\\n            s = \"abcdefghijklmnopqrstuvwxyz\"\\n            for i in range(26) : cnt[s[i]] = 0 \\n            cnt[labels[root]] = 1 ;\\n            for nbr in g[root] :\\n                if( ans[nbr] != 1 ) :\\n                    temp = dfs(nbr)\\n                    for key,item in temp.items() : cnt[key] += item\\n            ans[root] = cnt[labels[root]]\\n            return cnt \\n        \\n        dfs(0)\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n\\tvector<vector<int>> g;\\n    vector<int> ans;\\n    \\n     vector<int> dfs( int root , string &labels ){\\n        vector<int> cnt(26,0);\\n        ans[root] = 1 ;\\n        cnt[labels[root]-\\'a\\']++;\\n        for( auto nbr : g[root] ){\\n            if( !ans[nbr] ){\\n                vector<int> freq = dfs( nbr , labels );\\n                for( int i = 0 ; i < 26 ; i++ ) cnt[i] += freq[i] ;\\n            }\\n        }\\n        ans[root] = cnt[labels[root]-\\'a\\'];\\n        return cnt ;\\n    }\\n    \\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        g.resize(n);\\n        ans.resize(n,0);\\n        \\n        for( auto v : edges ){\\n            g[v[0]].push_back(v[1]);\\n            g[v[1]].push_back(v[0]);\\n        }\\n        \\n        dfs( 0 , labels );\\n        return ans ;\\n    }\\n```\n```\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        g , ans = {} , [0]*n\\n        for i in range(n) : g[i] = []\\n        for e in edges : \\n            g[e[0]].append(e[1])    \\n            g[e[1]].append(e[0])\\n            \\n        def dfs( root ):\\n            ans[root] = 1\\n            cnt = {}\\n            s = \"abcdefghijklmnopqrstuvwxyz\"\\n            for i in range(26) : cnt[s[i]] = 0 \\n            cnt[labels[root]] = 1 ;\\n            for nbr in g[root] :\\n                if( ans[nbr] != 1 ) :\\n                    temp = dfs(nbr)\\n                    for key,item in temp.items() : cnt[key] += item\\n            ans[root] = cnt[labels[root]]\\n            return cnt \\n        \\n        dfs(0)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3041955,
                "title": "beats-99-26-in-runtime-beats-100-in-memory-c-dfs",
                "content": "# Intuition\\nSince we have to count nodes with the same label in subtree we can use DFS for it. The idea behind it simple, each node will return the total number of nodes which have equal labels as that of the current node. One thing here is that we have to keep a running count of the labels for the solution to work. Hence we\\'ll use a frequency vector freq.\\n# Approach\\nMake an adjency list. Start traversing the list and keeping a running count of the labels encountered. We\\'ll use prev variable to ensure that the left and right subtrees don\\'t interfere in each other\\'s count. \\n# Complexity\\n- Time complexity:**O(n)**, where $n$ is the number of nodes in the tree.\\n- Space complexity:**O(n)**, where $n$ is the number of nodes in the tree\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int dfs(int node, vector<int> adj[], vector<bool>& vis, char c, string& labels, vector<int>& ans, vector<int>& fre){\\n        vis[node] = true;\\n        int prev = fre[labels[node]-\\'a\\'];\\n        fre[labels[node]-\\'a\\']++;\\n        for(auto it: adj[node]){\\n            if(!vis[it]){\\n                int cnt1 = dfs(it, adj, vis, labels[node], labels, ans, fre);\\n                ans[node] += cnt1;\\n            }\\n        }\\n        ans[node] = fre[labels[node]-\\'a\\'] - prev;\\n        return ans[node];\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> adj[n];\\n        vector<bool> vis(n,false);\\n        vector<int> ans(n,1);\\n        vector<int> fre(26,0);\\n        for(int i=0;i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        int tt = dfs(0, adj, vis, labels[0], labels, ans, fre);\\n        return ans;\\n    }\\n};\\n```\\nP.S: Consider upvoting if you liked my solution! Thank you :)\\n\\n![image.png](https://assets.leetcode.com/users/images/fa1a6f10-41bf-4603-82c3-7fa90a607fd8_1673546409.5141811.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dfs(int node, vector<int> adj[], vector<bool>& vis, char c, string& labels, vector<int>& ans, vector<int>& fre){\\n        vis[node] = true;\\n        int prev = fre[labels[node]-\\'a\\'];\\n        fre[labels[node]-\\'a\\']++;\\n        for(auto it: adj[node]){\\n            if(!vis[it]){\\n                int cnt1 = dfs(it, adj, vis, labels[node], labels, ans, fre);\\n                ans[node] += cnt1;\\n            }\\n        }\\n        ans[node] = fre[labels[node]-\\'a\\'] - prev;\\n        return ans[node];\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> adj[n];\\n        vector<bool> vis(n,false);\\n        vector<int> ans(n,1);\\n        vector<int> fre(26,0);\\n        for(int i=0;i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        int tt = dfs(0, adj, vis, labels[0], labels, ans, fre);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041897,
                "title": "simple-and-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N*26)\\n\\n- Space complexity:\\nO(N*26)\\n\\n# Code\\n```\\nclass Solution {\\n    vector<int>ans;\\n    vector<vector<int>>adj;\\n    vector<bool>vis;\\n\\npublic:\\n    vector<int> solve(string &l,int node,int par)\\n    {\\n       \\n        vector<int>temp(26,0);vis[node]=true;\\n        temp[l[node]-\\'a\\']+=1;\\n        for(auto it:adj[node])\\n        {\\n            if(!vis[it])\\n            {\\n               vector<int>nv= solve(l,it,node);\\n               for(int i=0;i<26;++i)temp[i]+=nv[i];\\n            }\\n        }\\n        \\n        ans[node]=temp[l[node]-\\'a\\'];\\n        return temp;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        ans.resize(n,0);\\n        adj.resize(n);\\n        vis.resize(n,false);\\n        int a,b;\\n        for(auto it:edges)\\n        {\\n            a=it[0];b=it[1];\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n\\n        solve(labels,0,-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    vector<int>ans;\\n    vector<vector<int>>adj;\\n    vector<bool>vis;\\n\\npublic:\\n    vector<int> solve(string &l,int node,int par)\\n    {\\n       \\n        vector<int>temp(26,0);vis[node]=true;\\n        temp[l[node]-\\'a\\']+=1;\\n        for(auto it:adj[node])\\n        {\\n            if(!vis[it])\\n            {\\n               vector<int>nv= solve(l,it,node);\\n               for(int i=0;i<26;++i)temp[i]+=nv[i];\\n            }\\n        }\\n        \\n        ans[node]=temp[l[node]-\\'a\\'];\\n        return temp;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        ans.resize(n,0);\\n        adj.resize(n);\\n        vis.resize(n,false);\\n        int a,b;\\n        for(auto it:edges)\\n        {\\n            a=it[0];b=it[1];\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n\\n        solve(labels,0,-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041755,
                "title": "dfs-java",
                "content": "```\\nclass Solution {\\n    int[] res;\\n    boolean[] seen;\\n    HashMap<Integer, ArrayList<Integer>> graph;\\n    \\n    int[] dfs(int index, String labels){\\n        int[] hash = new int[26];\\n        if(!graph.containsKey(index)) return hash;\\n        seen[index] = true;\\n        \\n        for(int i : graph.get(index)){\\n            if(!seen[i]){\\n                int[] temp = dfs(i, labels);\\n                for(int j = 0; j < 26; j++) hash[j] += temp[j];\\n            }\\n        }\\n        \\n        hash[labels.charAt(index) - \\'a\\']++;\\n        res[index] = hash[labels.charAt(index) - \\'a\\'];\\n        return hash;\\n    }\\n    \\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        res = new int[n];\\n        graph = new HashMap<>();\\n        seen = new boolean[n];\\n        for(int i = 0; i < edges.length; i++){\\n            if(!graph.containsKey(edges[i][0])) graph.put(edges[i][0], new ArrayList<>());\\n            if(!graph.containsKey(edges[i][1])) graph.put(edges[i][1], new ArrayList<>());\\n            graph.get(edges[i][0]).add(edges[i][1]);\\n            graph.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        \\n        dfs(0, labels);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int[] res;\\n    boolean[] seen;\\n    HashMap<Integer, ArrayList<Integer>> graph;\\n    \\n    int[] dfs(int index, String labels){\\n        int[] hash = new int[26];\\n        if(!graph.containsKey(index)) return hash;\\n        seen[index] = true;\\n        \\n        for(int i : graph.get(index)){\\n            if(!seen[i]){\\n                int[] temp = dfs(i, labels);\\n                for(int j = 0; j < 26; j++) hash[j] += temp[j];\\n            }\\n        }\\n        \\n        hash[labels.charAt(index) - \\'a\\']++;\\n        res[index] = hash[labels.charAt(index) - \\'a\\'];\\n        return hash;\\n    }\\n    \\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        res = new int[n];\\n        graph = new HashMap<>();\\n        seen = new boolean[n];\\n        for(int i = 0; i < edges.length; i++){\\n            if(!graph.containsKey(edges[i][0])) graph.put(edges[i][0], new ArrayList<>());\\n            if(!graph.containsKey(edges[i][1])) graph.put(edges[i][1], new ArrayList<>());\\n            graph.get(edges[i][0]).add(edges[i][1]);\\n            graph.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        \\n        dfs(0, labels);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041490,
                "title": "c-using-recursion-and-dp-storing-the-count-of-labels-as-we-do-dfs-in-a-vector-for-each-node",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(26*N)\\n\\n- Space complexity:\\nO(26*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<unordered_set<int>>childs;\\n    string labelofnode;\\n    vector<int>ans;\\n    vector<int>Labelvalues(int x)\\n    {\\n        vector<int>labelvals(26,0);\\n        if(childs[x].size()==0)\\n        {\\n            labelvals[labelofnode[x]-\\'a\\']++;\\n            ans[x]=labelvals[labelofnode[x]-\\'a\\'];\\n            return labelvals;\\n        }\\n        for(auto j:childs[x])\\n        {\\n            childs[j].erase(x);\\n            vector<int>increment=Labelvalues(j);\\n            for(int i=0;i<26;i++)\\n            {\\n                labelvals[i]+=increment[i];\\n            }\\n        }\\n        labelvals[labelofnode[x]-\\'a\\']++;\\n        ans[x]=labelvals[labelofnode[x]-\\'a\\'];\\n        return labelvals;\\n    }\\n    vector<int> countSubTrees(int n,vector<vector<int>>& edges,string labels)\\n    {\\n        childs.assign(n,{});\\n        ans.assign(n,0);\\n        labelofnode=labels;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            childs[edges[i][0]].insert(edges[i][1]);\\n            childs[edges[i][1]].insert(edges[i][0]);\\n        }\\n        vector<int>labelvals(26,0);\\n        for(auto j:childs[0])\\n        {\\n            childs[j].erase(0);\\n            vector<int>increment=Labelvalues(j);\\n            for(int i=0;i<26;i++)\\n            {\\n                labelvals[i]+=increment[i];\\n            }\\n        }\\n        labelvals[labelofnode[0]-\\'a\\']++;\\n        ans[0]=labelvals[labelofnode[0]-\\'a\\'];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<unordered_set<int>>childs;\\n    string labelofnode;\\n    vector<int>ans;\\n    vector<int>Labelvalues(int x)\\n    {\\n        vector<int>labelvals(26,0);\\n        if(childs[x].size()==0)\\n        {\\n            labelvals[labelofnode[x]-\\'a\\']++;\\n            ans[x]=labelvals[labelofnode[x]-\\'a\\'];\\n            return labelvals;\\n        }\\n        for(auto j:childs[x])\\n        {\\n            childs[j].erase(x);\\n            vector<int>increment=Labelvalues(j);\\n            for(int i=0;i<26;i++)\\n            {\\n                labelvals[i]+=increment[i];\\n            }\\n        }\\n        labelvals[labelofnode[x]-\\'a\\']++;\\n        ans[x]=labelvals[labelofnode[x]-\\'a\\'];\\n        return labelvals;\\n    }\\n    vector<int> countSubTrees(int n,vector<vector<int>>& edges,string labels)\\n    {\\n        childs.assign(n,{});\\n        ans.assign(n,0);\\n        labelofnode=labels;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            childs[edges[i][0]].insert(edges[i][1]);\\n            childs[edges[i][1]].insert(edges[i][0]);\\n        }\\n        vector<int>labelvals(26,0);\\n        for(auto j:childs[0])\\n        {\\n            childs[j].erase(0);\\n            vector<int>increment=Labelvalues(j);\\n            for(int i=0;i<26;i++)\\n            {\\n                labelvals[i]+=increment[i];\\n            }\\n        }\\n        labelvals[labelofnode[0]-\\'a\\']++;\\n        ans[0]=labelvals[labelofnode[0]-\\'a\\'];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041339,
                "title": "dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDFS\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>dfs(vector<vector<int>>&adj,int curr,int parent,vector<int>&result,string &labels){\\n        vector<int>my_count(26,0);\\n        int mylabel=labels[curr];\\n        my_count[mylabel- \\'a\\']=1;\\n\\n        for(auto& child:adj[curr]){\\n            if(child==parent) continue;\\n            vector<int>child_count(26,0);\\n            child_count=dfs(adj,child,curr,result,labels);\\n\\n            for(int i=0;i<26;i++){\\n                my_count[i]+=child_count[i];\\n            }\\n        }\\n        result[curr]=my_count[mylabel-\\'a\\'];\\n        return my_count;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adj(n);\\n        for(auto& it: edges){\\n            int u=it[0];\\n            int v=it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n\\n        }\\n        vector<int>result(n,0);\\n\\n        dfs(adj,0,-1,result,labels);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dfs(vector<vector<int>>&adj,int curr,int parent,vector<int>&result,string &labels){\\n        vector<int>my_count(26,0);\\n        int mylabel=labels[curr];\\n        my_count[mylabel- \\'a\\']=1;\\n\\n        for(auto& child:adj[curr]){\\n            if(child==parent) continue;\\n            vector<int>child_count(26,0);\\n            child_count=dfs(adj,child,curr,result,labels);\\n\\n            for(int i=0;i<26;i++){\\n                my_count[i]+=child_count[i];\\n            }\\n        }\\n        result[curr]=my_count[mylabel-\\'a\\'];\\n        return my_count;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adj(n);\\n        for(auto& it: edges){\\n            int u=it[0];\\n            int v=it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n\\n        }\\n        vector<int>result(n,0);\\n\\n        dfs(adj,0,-1,result,labels);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041120,
                "title": "python3-solution-beats-100-in-time-and-memory",
                "content": "# Intuition\\nMy idea was that you need to know only two things when building the final array - the count when the node was first visited and the current count.\\nThe code is higly optimized for memory efficiency and not for readability. I\\'m sorry for that, but I tried to add comments on the parts where weird things are happenning according to me. If you have any questions - feel free to ask.\\n\\n# Approach\\nI\\'m using DFS to traverse the tree. When visiting a node for the first time, store the number of labels like the node\\'s seen so far. Then add all the children of the current node to the DFS stack. When we pop back to the node after visiting the whole subtree, we can calculate how many labels like the current were found by simply substracting the initial count from the running total.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ since we visit each of the $$n$$ nodes exactly twice\\n\\n- Space complexity: $$O(n)$$ since the largest portion of memory we need is an array of `n` integers to store the `first_seen` values, and then we use the same array as the result\\n<!-- Add your space complexity here, e.g.  -->\\n\\n# Code\\n```\\nORD_A = ord(\\'a\\')\\n\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        adj_list = [[] for _ in range(n)]\\n        for a, b in edges:\\n            adj_list[a].append(b)\\n            adj_list[b].append(a)\\n\\n        # storing the total seen characters until the given moment\\n        count = [0] * 26\\n        # first_seen is used to store the number of labels equal to the current node\\'s\\n        # at the moment of the first visit\\n        first_seen = [-1] * n\\n\\n        # iterative DFS\\n        stack = [0]\\n        while stack:\\n            node = stack[-1]\\n\\n            label = ord(labels[node]) - ORD_A\\n            \\n            # each node is visited exactly twice\\n            if first_seen[node] == -1:\\n                first_seen[node] = count[label]\\n                count[label] += 1\\n                \\n                for neigh in adj_list[node]:\\n                    if first_seen[neigh] == -1:\\n                        stack.append(neigh)\\n            else:\\n                stack.pop()\\n                # the number of nodes with the same label in the subtree is\\n                # the total number of labels seen so far minus the number of\\n                # such labels seen at the moment of the first visit\\n                # NOTE: we use first_seen as a result array, because after visiting\\n                # the whole subtree of node, first_seen[node] is no longer needed\\n                first_seen[node] = count[label] - first_seen[node]\\n        \\n        return first_seen\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nORD_A = ord(\\'a\\')\\n\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        adj_list = [[] for _ in range(n)]\\n        for a, b in edges:\\n            adj_list[a].append(b)\\n            adj_list[b].append(a)\\n\\n        # storing the total seen characters until the given moment\\n        count = [0] * 26\\n        # first_seen is used to store the number of labels equal to the current node\\'s\\n        # at the moment of the first visit\\n        first_seen = [-1] * n\\n\\n        # iterative DFS\\n        stack = [0]\\n        while stack:\\n            node = stack[-1]\\n\\n            label = ord(labels[node]) - ORD_A\\n            \\n            # each node is visited exactly twice\\n            if first_seen[node] == -1:\\n                first_seen[node] = count[label]\\n                count[label] += 1\\n                \\n                for neigh in adj_list[node]:\\n                    if first_seen[neigh] == -1:\\n                        stack.append(neigh)\\n            else:\\n                stack.pop()\\n                # the number of nodes with the same label in the subtree is\\n                # the total number of labels seen so far minus the number of\\n                # such labels seen at the moment of the first visit\\n                # NOTE: we use first_seen as a result array, because after visiting\\n                # the whole subtree of node, first_seen[node] is no longer needed\\n                first_seen[node] = count[label] - first_seen[node]\\n        \\n        return first_seen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041109,
                "title": "java-solution-recursion",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] res(int idx,int n,ArrayList<ArrayList<Integer>>arr,String labels, int ans[],int counts[],int vis[]){\\n        vis[idx]=1;\\n        ArrayList<Integer>ele=arr.get(idx);\\n        int c[]=new int[26];\\n        for(int i=0;i<ele.size();i++){\\n            if(vis[ele.get(i)]==0){\\n            int l[]=res(ele.get(i),n,arr,labels,ans,c,vis);\\n                for(int j=0;j<26;j++){\\n                    c[j]+=l[j];\\n                }\\n            }\\n        }\\n        c[labels.charAt(idx)-\\'a\\']++;\\n        ans[idx]=c[labels.charAt(idx)-\\'a\\'];\\n        return c;\\n    }\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        ArrayList<ArrayList<Integer>>arr=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            arr.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            arr.get(edges[i][0]).add(edges[i][1]);\\n            arr.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        int vis[]=new int[n];\\n        int ans[]=new int[n];\\n        int counts[]=new int[26];\\n        int []l=res(0,n,arr,labels,ans,counts,vis);\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] res(int idx,int n,ArrayList<ArrayList<Integer>>arr,String labels, int ans[],int counts[],int vis[]){\\n        vis[idx]=1;\\n        ArrayList<Integer>ele=arr.get(idx);\\n        int c[]=new int[26];\\n        for(int i=0;i<ele.size();i++){\\n            if(vis[ele.get(i)]==0){\\n            int l[]=res(ele.get(i),n,arr,labels,ans,c,vis);\\n                for(int j=0;j<26;j++){\\n                    c[j]+=l[j];\\n                }\\n            }\\n        }\\n        c[labels.charAt(idx)-\\'a\\']++;\\n        ans[idx]=c[labels.charAt(idx)-\\'a\\'];\\n        return c;\\n    }\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        ArrayList<ArrayList<Integer>>arr=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            arr.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            arr.get(edges[i][0]).add(edges[i][1]);\\n            arr.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        int vis[]=new int[n];\\n        int ans[]=new int[n];\\n        int counts[]=new int[26];\\n        int []l=res(0,n,arr,labels,ans,counts,vis);\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040550,
                "title": "c-97-faster-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void findAns(vector<vector<int>> &graph,vector<bool> &visit, vector<int> &alphabetCount,vector<int> &ans,int node,string &labels) {\\n        visit[node]=true;\\n        int temp=alphabetCount[labels[node]-\\'a\\'];\\n        alphabetCount[labels[node]-\\'a\\']=0;\\n        for(int index=0;index<graph[node].size();index++) {\\n            if(!visit[graph[node][index]])\\n                findAns(graph,visit,alphabetCount,ans,graph[node][index],labels);\\n        }\\n        alphabetCount[labels[node]-\\'a\\']++;\\n        ans[node]=alphabetCount[labels[node]-\\'a\\'];\\n        alphabetCount[labels[node]-\\'a\\']+=temp;\\n    }   \\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> ans(n);\\n        vector<vector<int>> graph(n,vector<int>());\\n        vector<int> alphabetCount(26,0);\\n        vector<bool> visit(n,false);\\n\\n        for(int index=0;index<edges.size();index++) {\\n            graph[edges[index][0]].push_back(edges[index][1]);\\n            graph[edges[index][1]].push_back(edges[index][0]);\\n        }\\n\\n        findAns(graph,visit,alphabetCount,ans,0,labels);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void findAns(vector<vector<int>> &graph,vector<bool> &visit, vector<int> &alphabetCount,vector<int> &ans,int node,string &labels) {\\n        visit[node]=true;\\n        int temp=alphabetCount[labels[node]-\\'a\\'];\\n        alphabetCount[labels[node]-\\'a\\']=0;\\n        for(int index=0;index<graph[node].size();index++) {\\n            if(!visit[graph[node][index]])\\n                findAns(graph,visit,alphabetCount,ans,graph[node][index],labels);\\n        }\\n        alphabetCount[labels[node]-\\'a\\']++;\\n        ans[node]=alphabetCount[labels[node]-\\'a\\'];\\n        alphabetCount[labels[node]-\\'a\\']+=temp;\\n    }   \\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> ans(n);\\n        vector<vector<int>> graph(n,vector<int>());\\n        vector<int> alphabetCount(26,0);\\n        vector<bool> visit(n,false);\\n\\n        for(int index=0;index<edges.size();index++) {\\n            graph[edges[index][0]].push_back(edges[index][1]);\\n            graph[edges[index][1]].push_back(edges[index][0]);\\n        }\\n\\n        findAns(graph,visit,alphabetCount,ans,0,labels);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040541,
                "title": "c-solution-using-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    unordered_set<int> vis;\\n    \\n    vector<int> help(int n,vector<vector<int>> &graph,string &label){\\n        vector<int> temp(26,0);\\n        temp[label[n]-\\'a\\']++;\\n        \\n        vis.insert(n);\\n        for(int x:graph[n]){\\n            if(vis.count(x)) continue;\\n            vector<int> temp2= help(x,graph,label);\\n            ans[x]= temp2[label[x]-\\'a\\'];\\n            for(int i=0;i<26;i++) temp[i]+= temp2[i];\\n        }\\n        \\n        return temp;\\n    }\\n    \\n    \\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string label) {\\n        ans.resize(n,0);\\n        \\n        vector<vector<int>> graph(n);\\n        for(auto &x:edges){\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        \\n        vis.insert(0);\\n        vector<int> freq= help(0,graph,label);\\n        ans[0]= freq[label[0]-\\'a\\'];\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    unordered_set<int> vis;\\n    \\n    vector<int> help(int n,vector<vector<int>> &graph,string &label){\\n        vector<int> temp(26,0);\\n        temp[label[n]-\\'a\\']++;\\n        \\n        vis.insert(n);\\n        for(int x:graph[n]){\\n            if(vis.count(x)) continue;\\n            vector<int> temp2= help(x,graph,label);\\n            ans[x]= temp2[label[x]-\\'a\\'];\\n            for(int i=0;i<26;i++) temp[i]+= temp2[i];\\n        }\\n        \\n        return temp;\\n    }\\n    \\n    \\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string label) {\\n        ans.resize(n,0);\\n        \\n        vector<vector<int>> graph(n);\\n        for(auto &x:edges){\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        \\n        vis.insert(0);\\n        vector<int> freq= help(0,graph,label);\\n        ans[0]= freq[label[0]-\\'a\\'];\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040510,
                "title": "java-dfs",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int[] dfs(Map<Integer, List<Integer>> tree, int[] ans, char[] labels, int node, int parent){\\n\\n        int[] count = new int[26];\\n        count[labels[node] - \\'a\\'] = 1;\\n\\n        for(int child : tree.getOrDefault(node, new ArrayList<>()/* Empty List */)){\\n            if(child == parent) continue;\\n            int[] countCount = dfs(tree, ans, labels, child, node);\\n            \\n            for(int i = 0; i < 26; i++){\\n                count[i] += countCount[i];\\n            }\\n        }\\n        \\n        ans[node] = count[labels[node] - \\'a\\'];\\n        return count;\\n    }\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        Map<Integer, List<Integer>> tree = new HashMap<>();\\n        for(int[] edge : edges){\\n            tree.computeIfAbsent(edge[0], s -> new ArrayList<>()).add(edge[1]);\\n            tree.computeIfAbsent(edge[1], s -> new ArrayList<>()).add(edge[0]);\\n        }\\n        int[] ans = new int[n];\\n        \\n        dfs(tree, ans, labels.toCharArray(), 0, -1);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private int[] dfs(Map<Integer, List<Integer>> tree, int[] ans, char[] labels, int node, int parent){\\n\\n        int[] count = new int[26];\\n        count[labels[node] - \\'a\\'] = 1;\\n\\n        for(int child : tree.getOrDefault(node, new ArrayList<>()/* Empty List */)){\\n            if(child == parent) continue;\\n            int[] countCount = dfs(tree, ans, labels, child, node);\\n            \\n            for(int i = 0; i < 26; i++){\\n                count[i] += countCount[i];\\n            }\\n        }\\n        \\n        ans[node] = count[labels[node] - \\'a\\'];\\n        return count;\\n    }\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        Map<Integer, List<Integer>> tree = new HashMap<>();\\n        for(int[] edge : edges){\\n            tree.computeIfAbsent(edge[0], s -> new ArrayList<>()).add(edge[1]);\\n            tree.computeIfAbsent(edge[1], s -> new ArrayList<>()).add(edge[0]);\\n        }\\n        int[] ans = new int[n];\\n        \\n        dfs(tree, ans, labels.toCharArray(), 0, -1);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040346,
                "title": "c-dfs-easy-to-understand",
                "content": "# Approach\\nWith the help of DFS, we **go down to the leaves of the tree**, **calculate the frequency of each label** for them (there is only one label for leaves). After raising to a higher level, we **add to the frequency of labels of the current node the frequency of labels of all child nodes**.\\n\\n**Don\\'t forget to update the result**.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> vertex, freq;\\n\\n    void dfs(int curr, int prev, string& labels, vector<int>& result) {\\n        for (int neigh : vertex[curr]) {\\n            if (neigh != prev) {\\n                dfs(neigh, curr, labels, result);\\n                for (int i = 0; i < 26; i++) { freq[curr][i] += freq[neigh][i]; }\\n            }\\n        }\\n        result[curr] = ++freq[curr][labels[curr]-\\'a\\'];\\n    }\\n    \\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string& labels) {\\n        vertex.resize(n);\\n        for (int i = 0; i < edges.size(); i++) {\\n            int a = edges[i][0], b = edges[i][1];\\n            vertex[a].push_back(b);\\n            vertex[b].push_back(a);\\n        }\\n        freq = vector<vector<int>>(n, vector<int>(26, 0));\\n        vector<int> result(n, 0);\\n        dfs(0, -1, labels, result);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> vertex, freq;\\n\\n    void dfs(int curr, int prev, string& labels, vector<int>& result) {\\n        for (int neigh : vertex[curr]) {\\n            if (neigh != prev) {\\n                dfs(neigh, curr, labels, result);\\n                for (int i = 0; i < 26; i++) { freq[curr][i] += freq[neigh][i]; }\\n            }\\n        }\\n        result[curr] = ++freq[curr][labels[curr]-\\'a\\'];\\n    }\\n    \\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string& labels) {\\n        vertex.resize(n);\\n        for (int i = 0; i < edges.size(); i++) {\\n            int a = edges[i][0], b = edges[i][1];\\n            vertex[a].push_back(b);\\n            vertex[b].push_back(a);\\n        }\\n        freq = vector<vector<int>>(n, vector<int>(26, 0));\\n        vector<int> result(n, 0);\\n        dfs(0, -1, labels, result);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040070,
                "title": "javascript-code-with-comments",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {string} labels\\n * @return {number[]}\\n */\\nconst countSubTrees = (n, edges, labels) => {\\n\\n    const adjList = createAdjacencyList(n, edges);\\n    // Create an array to store the count of each label\\n    const ans = Array(n).fill(0);\\n\\n    dfs(0, -1, adjList, labels, ans);\\n\\n    return ans;\\n};\\n\\nconst dfs = (curNode, prevNode, adjList, labels, ans) => {\\n    // Create an array to keep track of the count of each label\\n    const count = Array(26).fill(0);\\n\\n    // Visit each child of the current node\\n    for(const child of adjList[curNode]){\\n        if(child !== prevNode){\\n            // Recursively visit the child and update the count array\\n            const childCount = dfs(child, curNode, adjList, labels, ans);\\n            for(let i=0; i<26; i++){\\n                count[i] += childCount[i];\\n            }\\n        }\\n    }\\n\\n    // Increment the count of the label for the current node\\n    const labelIndex = labels.charCodeAt(curNode) - \\'a\\'.charCodeAt(0);\\n    ans[curNode] = ++count[labelIndex];\\n\\n    return count; \\n}\\n\\nconst createAdjacencyList = (n, edges) => {\\n    const adjList = Array(n).fill().map(() => []);\\n\\n    for(const edge of edges){\\n        const [node1, node2] = edge;\\n        adjList[node1].push(node2);\\n        adjList[node2].push(node1);\\n    }\\n    return adjList;\\n}\\n\\n```\\n\\n                                    ***Please UpVote***\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {string} labels\\n * @return {number[]}\\n */\\nconst countSubTrees = (n, edges, labels) => {\\n\\n    const adjList = createAdjacencyList(n, edges);\\n    // Create an array to store the count of each label\\n    const ans = Array(n).fill(0);\\n\\n    dfs(0, -1, adjList, labels, ans);\\n\\n    return ans;\\n};\\n\\nconst dfs = (curNode, prevNode, adjList, labels, ans) => {\\n    // Create an array to keep track of the count of each label\\n    const count = Array(26).fill(0);\\n\\n    // Visit each child of the current node\\n    for(const child of adjList[curNode]){\\n        if(child !== prevNode){\\n            // Recursively visit the child and update the count array\\n            const childCount = dfs(child, curNode, adjList, labels, ans);\\n            for(let i=0; i<26; i++){\\n                count[i] += childCount[i];\\n            }\\n        }\\n    }\\n\\n    // Increment the count of the label for the current node\\n    const labelIndex = labels.charCodeAt(curNode) - \\'a\\'.charCodeAt(0);\\n    ans[curNode] = ++count[labelIndex];\\n\\n    return count; \\n}\\n\\nconst createAdjacencyList = (n, edges) => {\\n    const adjList = Array(n).fill().map(() => []);\\n\\n    for(const edge of edges){\\n        const [node1, node2] = edge;\\n        adjList[node1].push(node2);\\n        adjList[node2].push(node1);\\n    }\\n    return adjList;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3039973,
                "title": "c-dfs-explained-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> helper(int s,vector<vector<int>>& adj,vector<bool>& visited,string& labs,vector<int>& ans){\\n    visited[s] = 1;\\n    vector<int>freq(26,0);    //node frequency table\\n    for(auto child:adj[s])\\n    {\\n        if(!visited[child])\\n        {\\n            freq[labs[child]-\\'a\\']++;    //children appearance\\n            vector<int>get;\\n            get = helper(child,adj,visited,labs,ans);   //receive child freq table\\n            for(int i=0;i<26;i++)freq[i]+=get[i];    //combine tables\\n        }\\n    }\\n    \\n    ans[s] = freq[labs[s]-\\'a\\'] + 1;   // +1 for its own appearance\\n    return freq;//return freq table to parent\\n}\\n    \\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) \\n    {\\n        vector<vector<int>> adj(n);\\n        vector<bool> visited(n);\\n        vector<int> ans(n);\\n        for(int i=0; i < n-1; i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        helper(0,adj,visited,labels,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> helper(int s,vector<vector<int>>& adj,vector<bool>& visited,string& labs,vector<int>& ans){\\n    visited[s] = 1;\\n    vector<int>freq(26,0);    //node frequency table\\n    for(auto child:adj[s])\\n    {\\n        if(!visited[child])\\n        {\\n            freq[labs[child]-\\'a\\']++;    //children appearance\\n            vector<int>get;\\n            get = helper(child,adj,visited,labs,ans);   //receive child freq table\\n            for(int i=0;i<26;i++)freq[i]+=get[i];    //combine tables\\n        }\\n    }\\n    \\n    ans[s] = freq[labs[s]-\\'a\\'] + 1;   // +1 for its own appearance\\n    return freq;//return freq table to parent\\n}\\n    \\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) \\n    {\\n        vector<vector<int>> adj(n);\\n        vector<bool> visited(n);\\n        vector<int> ans(n);\\n        for(int i=0; i < n-1; i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        helper(0,adj,visited,labels,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039962,
                "title": "c-dfs-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse tradition dfs algorithm for we are interested in subtrees of any given node.\\n\\nKeep a tab on the frequency of each label.\\n\\nWhile at any given node store frequency of it\\'s label uptill now before incrementing its frequency (because we want to include current value in our answer) then explore the subtrees whilst updating the frequency data structure.\\n\\nOnce you return from your traversal, simply find out the difference of total frequency of that label and the temporary frequency which you had stored earlier.\\n\\nThat\\'s your answer!!!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1: Create answer vector of size n.\\nStep 2: Create visitor vector of size n for dfs.\\nStep 3: Create adjacency list (Our tree).\\nStep 4: Create frequency vector to store the frequencies of each label.\\nStep 5: Populate adjacency list.\\nStep 6: Call DFS with starting at 0th node (It is given)\\nStep 6a: Set current node as visited.\\nStep 6b: Store frequency of current label uptill now.\\nStep 6c: Increment frequency of current character (for the current node).\\nStep 6d: Do a DFS and send everything as reference (Make sure to do this otherwise you will get TLE in some cases).\\nStep 6e: Calculate and store your answer.\\nStep 7: Return answer vector.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n\\n    void dfs(int cNode, vector<vector<int>> &adj, vector<bool> &vis, vector<int> &freq, string &labels, vector<int> &ans)\\n    {\\n        vis[cNode] = true;\\n        int currFreq = freq[labels[cNode] - \\'a\\']; \\n        freq[labels[cNode] - \\'a\\']++;\\n\\n        for(int neighbor : adj[cNode])\\n        {\\n            if(!vis[neighbor])\\n                dfs(neighbor, adj, vis, freq, labels, ans);\\n        }\\n\\n        ans[cNode] = freq[labels[cNode] - \\'a\\'] - currFreq;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels)\\n    {\\n        vector<int> ans(n, 0);\\n        vector<bool> vis(n, false);\\n        vector<vector<int>> adj(n);\\n        vector<int> freq(26, 0);\\n\\n        for(auto edge : edges)\\n        {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n\\n        dfs(0, adj, vis, freq, labels, ans);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n\\n    void dfs(int cNode, vector<vector<int>> &adj, vector<bool> &vis, vector<int> &freq, string &labels, vector<int> &ans)\\n    {\\n        vis[cNode] = true;\\n        int currFreq = freq[labels[cNode] - \\'a\\']; \\n        freq[labels[cNode] - \\'a\\']++;\\n\\n        for(int neighbor : adj[cNode])\\n        {\\n            if(!vis[neighbor])\\n                dfs(neighbor, adj, vis, freq, labels, ans);\\n        }\\n\\n        ans[cNode] = freq[labels[cNode] - \\'a\\'] - currFreq;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels)\\n    {\\n        vector<int> ans(n, 0);\\n        vector<bool> vis(n, false);\\n        vector<vector<int>> adj(n);\\n        vector<int> freq(26, 0);\\n\\n        for(auto edge : edges)\\n        {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n\\n        dfs(0, adj, vis, freq, labels, ans);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039956,
                "title": "dfs-python-solution",
                "content": "\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n\\n        vertex=defaultdict(list)\\n        for e in edges:\\n            vertex[e[0]].append(e[1])\\n            vertex[e[1]].append(e[0])\\n\\n        ans=[0]*n\\n\\n        def bfs(node,x=[0]*26,vis=set()):\\n            if node in vis:\\n                return x\\n            \\n            vis.add(node)\\n\\n            # y is previous count of alphabet at node...\\n            y=x[ord(labels[node])-ord(\"a\")]\\n            # x is count of alphabet \"a\",\"b\"...\\n            x[ord(labels[node])-ord(\"a\")]+=1\\n\\n            for v in vertex[node]:\\n                x=bfs(v,x,vis)\\n\\n            # ans[node]=current count - previous count\\n            ans[node]=x[ord(labels[node])-ord(\"a\")]-y\\n\\n            return x\\n        \\n        bfs(0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n\\n        vertex=defaultdict(list)\\n        for e in edges:\\n            vertex[e[0]].append(e[1])\\n            vertex[e[1]].append(e[0])\\n\\n        ans=[0]*n\\n\\n        def bfs(node,x=[0]*26,vis=set()):\\n            if node in vis:\\n                return x\\n            \\n            vis.add(node)\\n\\n            # y is previous count of alphabet at node...\\n            y=x[ord(labels[node])-ord(\"a\")]\\n            # x is count of alphabet \"a\",\"b\"...\\n            x[ord(labels[node])-ord(\"a\")]+=1\\n\\n            for v in vertex[node]:\\n                x=bfs(v,x,vis)\\n\\n            # ans[node]=current count - previous count\\n            ans[node]=x[ord(labels[node])-ord(\"a\")]-y\\n\\n            return x\\n        \\n        bfs(0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039692,
                "title": "fast-solution-c-hashmap-dfs-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFast solution\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    vector<int>ans;\\npublic:\\nvoid dfs(int y,int yp,vector<vector<int>>&n,string&l,char c,unordered_map<char,int>&m){\\n    int pr=m[l[y]];\\n    m[l[y]]+=1;\\n   \\n    for(int nu:n[y]){\\n        if(yp==nu)continue;\\n      dfs(nu,y,n,l,c,m);\\n       // lp++;\\n    }\\n    \\n    ans[y]=m[l[y]]-pr;\\n}\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>>nodes(n);\\n        for(int y=0;y<edges.size();y++){\\n            nodes[edges[y][0]].push_back(edges[y][1]);\\n            nodes[edges[y][1]].push_back(edges[y][0]);\\n        }\\n        unordered_map<char,int>m;\\n       ans.resize(n,0);\\n          dfs(0,0,nodes,labels,labels[0],m);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\n\\nclass Solution {\\n    vector<int>ans;\\npublic:\\nvoid dfs(int y,int yp,vector<vector<int>>&n,string&l,char c,unordered_map<char,int>&m){\\n    int pr=m[l[y]];\\n    m[l[y]]+=1;\\n   \\n    for(int nu:n[y]){\\n        if(yp==nu)continue;\\n      dfs(nu,y,n,l,c,m);\\n       // lp++;\\n    }\\n    \\n    ans[y]=m[l[y]]-pr;\\n}\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>>nodes(n);\\n        for(int y=0;y<edges.size();y++){\\n            nodes[edges[y][0]].push_back(edges[y][1]);\\n            nodes[edges[y][1]].push_back(edges[y][0]);\\n        }\\n        unordered_map<char,int>m;\\n       ans.resize(n,0);\\n          dfs(0,0,nodes,labels,labels[0],m);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039682,
                "title": "python-beats-100-runtime-and-93-6-memory",
                "content": "# Approach\\nParse the `edges` into a adjacency list representation of the tree.\\nSince an `edge: (u, v)` is undericted. Make sure to add both `u -> v` and `v -> u`\\n\\nDefine a recursive DFS function, called `count_labels` below.\\n- For a given `root`, store the count of `labels[root]` in variable `before`.\\n- Recursively `count_labels` of all it\\'s children.\\n- Increment count for `labels[root]` to count the `root` node.\\n- Store the count of `labels[root]` in variable `after`\\n- Update `ans[root]` to the difference between the two, i.e `after - before`\\n\\nTo avoid double counting the parent, and causing an infinte loop, filter `child` node equal to `parent`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\nAssuming we don\\'t count space used for output `ans` and parsed `tree`.\\n\\n# Code\\n```Python\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: list[list[int]], labels: str) -> list[int]:\\n\\n        def count_sub_trees(n: int, tree: dict[int, list[int]], labels: str) -> list[int]:\\n            ans = list(range(n))\\n            counter = Counter()\\n\\n            def count_labels(root: int, parent: int) -> None:\\n                before = counter[labels[root]]\\n\\n                for child in tree[root]:\\n                    if child != parent: count_labels(child, root) \\n                counter[labels[root]] += 1\\n\\n                after = counter[labels[root]]\\n                ans[root] = after - before\\n\\n            count_labels(0, -1)\\n            return ans\\n\\n        t = defaultdict(list)\\n        for u, v in edges: t[u].append(v); t[v].append(u)\\n\\n        return count_sub_trees(n, t, labels)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```Python\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: list[list[int]], labels: str) -> list[int]:\\n\\n        def count_sub_trees(n: int, tree: dict[int, list[int]], labels: str) -> list[int]:\\n            ans = list(range(n))\\n            counter = Counter()\\n\\n            def count_labels(root: int, parent: int) -> None:\\n                before = counter[labels[root]]\\n\\n                for child in tree[root]:\\n                    if child != parent: count_labels(child, root) \\n                counter[labels[root]] += 1\\n\\n                after = counter[labels[root]]\\n                ans[root] = after - before\\n\\n            count_labels(0, -1)\\n            return ans\\n\\n        t = defaultdict(list)\\n        for u, v in edges: t[u].append(v); t[v].append(u)\\n\\n        return count_sub_trees(n, t, labels)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039623,
                "title": "beats-100-faang-method-ever",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>> adj;\\n    int freq[26] = {};\\n    vector<int> answer;\\n\\n    void dfs(int node, int parent, const string& labels) {\\n        int iChar = labels[node] - \\'a\\';\\n        int prevFreq = freq[iChar];\\n        freq[iChar] = 0;\\n\\n        for (int child : adj[node]) {\\n            if (child == parent)\\n                continue;\\n            dfs(child, node, labels);\\n        }\\n\\n        answer[node] = ++freq[iChar];\\n        freq[iChar] += prevFreq;\\n    }\\n\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        adj.resize(n);\\n        // build adj graph\\n        for (const auto& edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        // get answer\\n        answer.resize(n);\\n        dfs(0, -1, labels);\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> adj;\\n    int freq[26] = {};\\n    vector<int> answer;\\n\\n    void dfs(int node, int parent, const string& labels) {\\n        int iChar = labels[node] - \\'a\\';\\n        int prevFreq = freq[iChar];\\n        freq[iChar] = 0;\\n\\n        for (int child : adj[node]) {\\n            if (child == parent)\\n                continue;\\n            dfs(child, node, labels);\\n        }\\n\\n        answer[node] = ++freq[iChar];\\n        freq[iChar] += prevFreq;\\n    }\\n\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        adj.resize(n);\\n        // build adj graph\\n        for (const auto& edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        // get answer\\n        answer.resize(n);\\n        dfs(0, -1, labels);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039513,
                "title": "clean-code-with-simple-logic-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity:$$O(n*26)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n*26)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int res[];\\n    char[] label;\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        res = new int[n];\\n        label = labels.toCharArray();\\n        List al[] = new List[n];\\n        for(int i = 0; i<n; i++) al[i] = new ArrayList<>();\\n        for(int edge[]: edges) {\\n            al[edge[0]].add(edge[1]);\\n            al[edge[1]].add(edge[0]);\\n        }\\n        recurse(al, -1, 0);\\n        return res;\\n    }\\n\\n    private int[] recurse(List<Integer> al[], int parent, int currNode) {\\n        int[] currMap = new int[26];\\n        currMap[label[currNode]-\\'a\\'] = 1;\\n        for(int child: al[currNode]) {\\n            if(child!=parent) {\\n                int map[] = recurse(al, currNode, child);\\n                for(int i = 0; i<26; i++)\\n                    currMap[i] += map[i];\\n            }\\n        }\\n        res[currNode] = currMap[label[currNode]-\\'a\\'];\\n        return currMap;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int res[];\\n    char[] label;\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        res = new int[n];\\n        label = labels.toCharArray();\\n        List al[] = new List[n];\\n        for(int i = 0; i<n; i++) al[i] = new ArrayList<>();\\n        for(int edge[]: edges) {\\n            al[edge[0]].add(edge[1]);\\n            al[edge[1]].add(edge[0]);\\n        }\\n        recurse(al, -1, 0);\\n        return res;\\n    }\\n\\n    private int[] recurse(List<Integer> al[], int parent, int currNode) {\\n        int[] currMap = new int[26];\\n        currMap[label[currNode]-\\'a\\'] = 1;\\n        for(int child: al[currNode]) {\\n            if(child!=parent) {\\n                int map[] = recurse(al, currNode, child);\\n                for(int i = 0; i<26; i++)\\n                    currMap[i] += map[i];\\n            }\\n        }\\n        res[currNode] = currMap[label[currNode]-\\'a\\'];\\n        return currMap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039495,
                "title": "python-easy-to-understand-well-explained",
                "content": "# Intuition\\nThe intuition behind this solution is to use a depth-first search (dfs) to traverse the tree and keep track of the counts of each label in the subtree of each node.\\n\\n# Approach\\nThe approach is as follows:\\n\\n1. Create an adjacency list representation of the tree using the edges array.\\n2. Initialize an array (ans) to store the number of nodes in the subtree of each node that have the same label as that node.\\n3. Use a dfs function to traverse the tree, starting from the root (node 0).\\n4. For each child of the current node, recursively call the dfs function and update the count of each label using a Counter object.\\n5. Update the ans array for the current node with the count of the label at that node.\\n6. Return the counts of all labels in the subtree rooted at the current node.\\n7. The ans array will now contain the number of nodes in the subtree of each node that have the same label as that node.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        graph = collections.defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        ans = [0] * n\\n        def dfs(node, parent):\\n            counts = collections.Counter()\\n            for child in graph[node]:\\n                if child != parent:\\n                    counts += dfs(child, node)\\n            counts[labels[node]] += 1\\n            ans[node] = counts[labels[node]]\\n            return counts\\n\\n        dfs(0, None)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        graph = collections.defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        ans = [0] * n\\n        def dfs(node, parent):\\n            counts = collections.Counter()\\n            for child in graph[node]:\\n                if child != parent:\\n                    counts += dfs(child, node)\\n            counts[labels[node]] += 1\\n            ans[node] = counts[labels[node]]\\n            return counts\\n\\n        dfs(0, None)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039441,
                "title": "an-ugly-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We have to return an array of size `n` where `ans[i]` is the number of nodes in the subtree of the `i`th node which have the same label as node `i`.\\n- So if we know the frequency of labels for a given subtree we could easily find how many nodes in the subtree have the same label as root.\\n- Now if we keep on dividing our tree into smaller and smaller sub-tree, this task would be pretty easy.\\n- So we design a recursive solution in which each child node returns a frequency array of labels to it\\'s parent. \\n- The parent node updates the `ans` array accordingly.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n\\n        // creating an adjacency list\\n        List<List<Integer>> adjList = new ArrayList<>();\\n        for(int i=0; i<n; i++){\\n            adjList.add(new ArrayList<Integer>());\\n        }\\n        for(int[] edge: edges){\\n            adjList.get(edge[0]).add(edge[1]);\\n            adjList.get(edge[1]).add(edge[0]);\\n        }\\n\\n        // ans array\\n        int[] ans = new int[n];\\n\\n        //calling dfs method\\n        dfs(adjList, labels, -1, 0, ans);\\n\\n        return ans;\\n        \\n    }\\n    public int[] dfs(List<List<Integer>> ls, String labels, int parent, int cur, int[] ans){\\n        // creating a frequency array for storing frequency of labels in a subtree \\n        int[] alpha = new int[26];\\n\\n        for(int i=0; i<ls.get(cur).size(); i++){\\n            if(ls.get(cur).get(i) == parent) continue;\\n            \\n            // temp is the frequency array returned to parent by child\\n            int temp[] = dfs(ls, labels, cur,ls.get(cur).get(i), ans);\\n\\n            // updating current nodes frequency list\\n            for(int j=0; j<26; j++){\\n                alpha[j] += temp[j];\\n            }\\n        }\\n\\n        // We also have to add the frequency of the label of current node i.e. we have to add 1 at that position \\n        alpha[labels.charAt(cur)-97] += 1;\\n\\n        // updating the ans array\\n        ans[cur] += alpha[labels.charAt(cur)-97];\\n        return alpha;\\n\\n    }\\n}\\n```\\n\\n### Sorry to have wasted your time",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n\\n        // creating an adjacency list\\n        List<List<Integer>> adjList = new ArrayList<>();\\n        for(int i=0; i<n; i++){\\n            adjList.add(new ArrayList<Integer>());\\n        }\\n        for(int[] edge: edges){\\n            adjList.get(edge[0]).add(edge[1]);\\n            adjList.get(edge[1]).add(edge[0]);\\n        }\\n\\n        // ans array\\n        int[] ans = new int[n];\\n\\n        //calling dfs method\\n        dfs(adjList, labels, -1, 0, ans);\\n\\n        return ans;\\n        \\n    }\\n    public int[] dfs(List<List<Integer>> ls, String labels, int parent, int cur, int[] ans){\\n        // creating a frequency array for storing frequency of labels in a subtree \\n        int[] alpha = new int[26];\\n\\n        for(int i=0; i<ls.get(cur).size(); i++){\\n            if(ls.get(cur).get(i) == parent) continue;\\n            \\n            // temp is the frequency array returned to parent by child\\n            int temp[] = dfs(ls, labels, cur,ls.get(cur).get(i), ans);\\n\\n            // updating current nodes frequency list\\n            for(int j=0; j<26; j++){\\n                alpha[j] += temp[j];\\n            }\\n        }\\n\\n        // We also have to add the frequency of the label of current node i.e. we have to add 1 at that position \\n        alpha[labels.charAt(cur)-97] += 1;\\n\\n        // updating the ans array\\n        ans[cur] += alpha[labels.charAt(cur)-97];\\n        return alpha;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039402,
                "title": "c-dp-easy-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use dynamic programming to calculate answer\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have 2 dimensional dp array with states - (node, number of nodes in sub tree with following char) and we can update our dp: dp[v][i] += dp[it][i], where i = 0...26 and we have edge v->it\\n\\n# Complexity\\n- Time complexity: O(n + m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * 26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> g;\\n    int dp[100001][26];\\n\\n    void dfs(int v, int prev, string& labels) {\\n        for (auto &it : g[v]) {\\n            if (it != prev) {\\n                dfs(it, v, labels);\\n                for (int i = 0; i < 26; i++) {\\n                    dp[v][i] += dp[it][i];\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        g.resize(n);\\n\\n        for (auto &it : edges) {\\n            g[it[0]].push_back(it[1]);\\n            g[it[1]].push_back(it[0]);\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            dp[i][labels[i] - \\'a\\'] = 1;\\n        }\\n\\n        dfs(0, -1, labels);\\n\\n        vector<int> ans(n);\\n        for (int i = 0; i < n; ++i) {\\n            ans[i] = dp[i][labels[i] - \\'a\\'];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> g;\\n    int dp[100001][26];\\n\\n    void dfs(int v, int prev, string& labels) {\\n        for (auto &it : g[v]) {\\n            if (it != prev) {\\n                dfs(it, v, labels);\\n                for (int i = 0; i < 26; i++) {\\n                    dp[v][i] += dp[it][i];\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        g.resize(n);\\n\\n        for (auto &it : edges) {\\n            g[it[0]].push_back(it[1]);\\n            g[it[1]].push_back(it[0]);\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            dp[i][labels[i] - \\'a\\'] = 1;\\n        }\\n\\n        dfs(0, -1, labels);\\n\\n        vector<int> ans(n);\\n        for (int i = 0; i < n; ++i) {\\n            ans[i] = dp[i][labels[i] - \\'a\\'];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039385,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    public static int[] post(int node, int par, char[] label,\\n        List<List<Integer>> adj,char c,int[] ans){\\n        \\n        int[] child = new int[26];\\n        \\n        for(int it: adj.get(node)){\\n            if(it!=par){\\n                int temp[] = post(it, node, label, adj,label[it],ans);\\n                for(int i = 0;i<26;i++){\\n                    child[i]+=temp[i];\\n                }\\n            }\\n        }\\n        \\n        child[label[node]-\\'a\\']++;    \\n        ans[node] = child[label[node]-\\'a\\'];\\n        return child;\\n    }\\n    \\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        \\n        int i = 0;\\n        for(i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        \\n        for(i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        \\n        int[] ans = new int[n];\\n \\n        char[] label = labels.toCharArray();\\n        post(0,-1,label, adj,label[0],ans);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public static int[] post(int node, int par, char[] label,\\n        List<List<Integer>> adj,char c,int[] ans){\\n        \\n        int[] child = new int[26];\\n        \\n        for(int it: adj.get(node)){\\n            if(it!=par){\\n                int temp[] = post(it, node, label, adj,label[it],ans);\\n                for(int i = 0;i<26;i++){\\n                    child[i]+=temp[i];\\n                }\\n            }\\n        }\\n        \\n        child[label[node]-\\'a\\']++;    \\n        ans[node] = child[label[node]-\\'a\\'];\\n        return child;\\n    }\\n    \\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        \\n        int i = 0;\\n        for(i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        \\n        for(i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        \\n        int[] ans = new int[n];\\n \\n        char[] label = labels.toCharArray();\\n        post(0,-1,label, adj,label[0],ans);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039356,
                "title": "fastest-python-solution",
                "content": "# Approach\\nDFS and every time we return a dictionary with a count of every character in that node\\'s subtree.\\n\\n# Complexity\\n- Time complexity:\\nO(26*n)  , where n -> number of nodes in tree, 26 is a constant for every character\\n\\n- Space complexity:\\nO(26*n)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countSubTrees(self, n, edges, labels):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type labels: str\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        result = [0]*n\\n        graph = collections.defaultdict(list)\\n        for x,y in edges:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n\\n        def dfs(node,parent):\\n            if node not in graph:\\n                return {labels[node] : 1}\\n            \\n            temp = collections.defaultdict(int)\\n            for child in graph[node]:\\n                if child!= parent:\\n                    dct = dfs(child,node)\\n                    for k in dct:\\n                        temp[k] += dct[k]\\n            \\n\\n            result[node] = temp[labels[node]] + 1\\n            temp[labels[node]] += 1\\n            return temp\\n\\n\\n\\n        dfs(0,-1)\\n        for i in range(len(result)):\\n            if result[i] == 0:\\n                result[i] = 1\\n        \\n\\n        return result\\n            \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countSubTrees(self, n, edges, labels):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type labels: str\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        result = [0]*n\\n        graph = collections.defaultdict(list)\\n        for x,y in edges:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n\\n        def dfs(node,parent):\\n            if node not in graph:\\n                return {labels[node] : 1}\\n            \\n            temp = collections.defaultdict(int)\\n            for child in graph[node]:\\n                if child!= parent:\\n                    dct = dfs(child,node)\\n                    for k in dct:\\n                        temp[k] += dct[k]\\n            \\n\\n            result[node] = temp[labels[node]] + 1\\n            temp[labels[node]] += 1\\n            return temp\\n\\n\\n\\n        dfs(0,-1)\\n        for i in range(len(result)):\\n            if result[i] == 0:\\n                result[i] = 1\\n        \\n\\n        return result\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039294,
                "title": "java-dfs-ascii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  LinkedList<Integer>[] g;\\n  int[] vis;\\n  int[] ans;\\n\\n  public int[] countSubTrees(int n, int[][] edges, String labels) {\\n    vis = new int[n];\\n    ans = new int[n];\\n\\n    g = new LinkedList[n];\\n    for(int i = 0; i != n; i++) g[i] = new LinkedList<>();\\n    for(int[] e : edges){\\n      g[e[0]].addLast(e[1]);\\n      g[e[1]].addLast(e[0]);\\n    }\\n\\n    dfs(0, labels);\\n    return ans;\\n  }\\n\\n  private int[] dfs(int node, String labels){\\n    int letters[] = new int[26];\\n    vis[node] = 1;\\n\\n    for(int next : g[node])\\n      if(vis[next] == 0){\\n        int temp[] = dfs(next, labels);\\n        for(int i = 0; i != 26; i++) letters[i] += temp[i];\\n      }\\n\\n    ans[node] = ++letters[labels.charAt(node)-\\'a\\'];\\n    return letters;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  LinkedList<Integer>[] g;\\n  int[] vis;\\n  int[] ans;\\n\\n  public int[] countSubTrees(int n, int[][] edges, String labels) {\\n    vis = new int[n];\\n    ans = new int[n];\\n\\n    g = new LinkedList[n];\\n    for(int i = 0; i != n; i++) g[i] = new LinkedList<>();\\n    for(int[] e : edges){\\n      g[e[0]].addLast(e[1]);\\n      g[e[1]].addLast(e[0]);\\n    }\\n\\n    dfs(0, labels);\\n    return ans;\\n  }\\n\\n  private int[] dfs(int node, String labels){\\n    int letters[] = new int[26];\\n    vis[node] = 1;\\n\\n    for(int next : g[node])\\n      if(vis[next] == 0){\\n        int temp[] = dfs(next, labels);\\n        for(int i = 0; i != 26; i++) letters[i] += temp[i];\\n      }\\n\\n    ans[node] = ++letters[labels.charAt(node)-\\'a\\'];\\n    return letters;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039236,
                "title": "java-my-slow-dfs-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        if (n == 1) return new int[]{1};\\n        NTreeNode[] arr = new NTreeNode[n];\\n        for (int i = 0; i < n; i++) {\\n            arr[i] = new NTreeNode(labels.charAt(i), i);\\n        }\\n        Set<Integer> hasParent = new HashSet<>();\\n        hasParent.add(0);\\n        //I create the graph\\n        for (int i = 0; i < edges.length; i++) {\\n            int a = edges[i][0], b = edges[i][1];\\n            NTreeNode aNode = arr[a], bNode = arr[b];\\n            if (hasParent.contains(a)) {\\n                aNode.children.add(bNode);\\n                hasParent.add(b);\\n            } else {\\n                bNode.children.add(aNode);\\n                hasParent.add(a);\\n            }\\n        }\\n        \\n        Map<Character, List<NTreeNode>> parents = new HashMap<>();\\n        int[] freq = new int[n];\\n        //traversing the graph and incrementing parents\\' frequency\\n        //when I meet a child with the same label\\n        traverseGraphDFS(arr[0], parents);\\n        for (int i = 0; i < arr.length; i++) {\\n            freq[i] = arr[i].freq;\\n        }\\n        return freq;\\n    }\\n\\n    private void traverseGraphDFS(NTreeNode node, Map<Character, List<NTreeNode>> parents) {\\n        if (node == null) return;\\n\\n        node.freq++;\\n        List<NTreeNode> list = parents.get(node.val);\\n        if (list != null) {\\n            for (NTreeNode parent : list) {\\n                parent.freq++;\\n            }\\n            list.add(node);\\n        } else {\\n            list = new ArrayList<>();\\n            list.add(node);\\n            parents.put(node.val, list);\\n        }\\n\\n        for (NTreeNode curr : node.children) {\\n            traverseGraphDFS(curr, parents);\\n        }\\n        list.remove(list.size() - 1);\\n    }\\n\\n    class NTreeNode {\\n        public char val;\\n        public List<NTreeNode> children;\\n        public int freq;\\n        int index;\\n\\n        public NTreeNode() {}\\n\\n        public NTreeNode(char _val, int idx) {\\n            val = _val;\\n            index = idx;\\n            children = new ArrayList<>();\\n        }\\n\\n        public NTreeNode(char _val, List<NTreeNode> _children) {\\n            val = _val;\\n            children = _children;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        if (n == 1) return new int[]{1};\\n        NTreeNode[] arr = new NTreeNode[n];\\n        for (int i = 0; i < n; i++) {\\n            arr[i] = new NTreeNode(labels.charAt(i), i);\\n        }\\n        Set<Integer> hasParent = new HashSet<>();\\n        hasParent.add(0);\\n        //I create the graph\\n        for (int i = 0; i < edges.length; i++) {\\n            int a = edges[i][0], b = edges[i][1];\\n            NTreeNode aNode = arr[a], bNode = arr[b];\\n            if (hasParent.contains(a)) {\\n                aNode.children.add(bNode);\\n                hasParent.add(b);\\n            } else {\\n                bNode.children.add(aNode);\\n                hasParent.add(a);\\n            }\\n        }\\n        \\n        Map<Character, List<NTreeNode>> parents = new HashMap<>();\\n        int[] freq = new int[n];\\n        //traversing the graph and incrementing parents\\' frequency\\n        //when I meet a child with the same label\\n        traverseGraphDFS(arr[0], parents);\\n        for (int i = 0; i < arr.length; i++) {\\n            freq[i] = arr[i].freq;\\n        }\\n        return freq;\\n    }\\n\\n    private void traverseGraphDFS(NTreeNode node, Map<Character, List<NTreeNode>> parents) {\\n        if (node == null) return;\\n\\n        node.freq++;\\n        List<NTreeNode> list = parents.get(node.val);\\n        if (list != null) {\\n            for (NTreeNode parent : list) {\\n                parent.freq++;\\n            }\\n            list.add(node);\\n        } else {\\n            list = new ArrayList<>();\\n            list.add(node);\\n            parents.put(node.val, list);\\n        }\\n\\n        for (NTreeNode curr : node.children) {\\n            traverseGraphDFS(curr, parents);\\n        }\\n        list.remove(list.size() - 1);\\n    }\\n\\n    class NTreeNode {\\n        public char val;\\n        public List<NTreeNode> children;\\n        public int freq;\\n        int index;\\n\\n        public NTreeNode() {}\\n\\n        public NTreeNode(char _val, int idx) {\\n            val = _val;\\n            index = idx;\\n            children = new ArrayList<>();\\n        }\\n\\n        public NTreeNode(char _val, List<NTreeNode> _children) {\\n            val = _val;\\n            children = _children;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039216,
                "title": "simple-python-solution-dfs",
                "content": "# Approach\\n1) Convert edges to adjacency list, so its easier to fetch and traverse\\n2) Run DFS to calculate `labelCount` for all the nodes in the sub-tree\\n\\n    * `labelCount` is a map of the labels and their resp. count\\n\\n        ```\\n        labelCount = {\\'a\\': 2, \\'b\\': 1, \\'e\\': 1}\\n        ```\\n    * Using `Counter` to merge and sum dictionaries\\n        \\n        ```\\n        Example:\\n        dict(dict(Counter({\\'a\\': 1, \\'b\\': 2}) + Counter({\\'a\\': 3, \\'c\\': 1}))\\n        \\n        = {\\'a\\': 4, \\'b\\': 2, \\'c\\': 1}\\n        ```\\n    * `ans` is updated for every node in the recursive function, since `ans` is label count of current node and nodes in its sub-tree\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ -> for adjList, traversed, and labelCount\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        adjList = {i: [] for i in range(n)}\\n        for edge in edges:\\n            adjList[edge[0]].append(edge[1])\\n            adjList[edge[1]].append(edge[0])\\n\\n        ans = [0] * n\\n        traversed = [0] * n\\n\\n        def dfs(node):\\n            if traversed[node]:\\n                return {}\\n            traversed[node] = 1\\n\\n            labelCount = {labels[node]: 1}\\n            for child in adjList[node]:\\n                labelCount = dict(Counter(labelCount) + Counter(dfs(child)))\\n\\n            ans[node] = labelCount[labels[node]]\\n\\n            return labelCount\\n\\n        dfs(0)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Depth-First Search",
                    "Counting"
                ],
                "code": "```\\n        labelCount = {\\'a\\': 2, \\'b\\': 1, \\'e\\': 1}\\n        ```\n```\\n        Example:\\n        dict(dict(Counter({\\'a\\': 1, \\'b\\': 2}) + Counter({\\'a\\': 3, \\'c\\': 1}))\\n        \\n        = {\\'a\\': 4, \\'b\\': 2, \\'c\\': 1}\\n        ```\n```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        adjList = {i: [] for i in range(n)}\\n        for edge in edges:\\n            adjList[edge[0]].append(edge[1])\\n            adjList[edge[1]].append(edge[0])\\n\\n        ans = [0] * n\\n        traversed = [0] * n\\n\\n        def dfs(node):\\n            if traversed[node]:\\n                return {}\\n            traversed[node] = 1\\n\\n            labelCount = {labels[node]: 1}\\n            for child in adjList[node]:\\n                labelCount = dict(Counter(labelCount) + Counter(dfs(child)))\\n\\n            ans[node] = labelCount[labels[node]]\\n\\n            return labelCount\\n\\n        dfs(0)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039196,
                "title": "concise-dfs-c",
                "content": "```\\nclass Solution {\\n    vector<int> dfs(int node, int prnt, vector<int> adj[], string &lb, vector<int> &ans) {\\n        vector<int> v(26);\\n\\n        for(int ad : adj[node]) {\\n            if(ad == prnt) continue;\\n            vector<int> t = dfs(ad, node, adj, lb, ans);\\n            for(int i=0; i<26; i++) v[i] += t[i];\\n        }\\n        ans[node] = ++v[lb[node] - \\'a\\'];\\n        return v;\\n    }\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> adj[n];\\n        for(auto e : edges) adj[e[0]].push_back(e[1]), adj[e[1]].push_back(e[0]);\\n        vector<int> ans(n);\\n\\n        dfs(0, -1, adj, labels, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> dfs(int node, int prnt, vector<int> adj[], string &lb, vector<int> &ans) {\\n        vector<int> v(26);\\n\\n        for(int ad : adj[node]) {\\n            if(ad == prnt) continue;\\n            vector<int> t = dfs(ad, node, adj, lb, ans);\\n            for(int i=0; i<26; i++) v[i] += t[i];\\n        }\\n        ans[node] = ++v[lb[node] - \\'a\\'];\\n        return v;\\n    }\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> adj[n];\\n        for(auto e : edges) adj[e[0]].push_back(e[1]), adj[e[1]].push_back(e[0]);\\n        vector<int> ans(n);\\n\\n        dfs(0, -1, adj, labels, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039174,
                "title": "java-simple-easy-and-fast-solution-with-explaination",
                "content": "Here we are storing the count of labels at each node and for that using HashMap\\nand since the given tree is generic tree using adj list and dfs approach for traversal \\n\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        int [] ans = new int [n];\\n        \\n        // Making adjency list \\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\\n        for(int i =0 ;i<n ;i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        \\n        for(int [] elem : edges){\\n            int src = elem[0];\\n            int dest = elem[1];\\n            \\n            graph.get(src).add(dest);\\n            graph.get(dest).add(src);\\n        }\\n        \\n        boolean [] visited  = new boolean [n];\\n        DFS(0,graph,visited,ans,labels.toCharArray()); // Filling the ans array\\n        return ans;\\n        \\n    }\\n    \\n    public HashMap<Character,Integer> DFS(int root ,ArrayList<ArrayList<Integer>> graph , boolean [] visited,int []ans , char[] labels){\\n        HashMap<Character,Integer> res = new HashMap<>();\\n        visited[root] = true ;\\n        \\n        for(int elem : graph.get(root)){\\n           if(visited[elem]){\\n               continue ;\\n           } \\n           HashMap<Character,Integer> map = DFS(elem,graph,visited,ans,labels);\\n            // Copying all the elements in the res hashmap\\n            for(char ch :map.keySet()){\\n                // Don\\'t forget to restore the answer stored for the same key in previous call hence used ==>res.getOrDefault(ch,0)+map.get(ch)\\n                res.put(ch,res.getOrDefault(ch,0)+map.get(ch));\\n            }\\n        }\\n        \\n        res.put(labels[root],res.getOrDefault(labels[root],0)+1);\\n        ans[root] = res.get(labels[root]);\\n        return res ;\\n    }\\n\\n",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "Here we are storing the count of labels at each node and for that using HashMap\\nand since the given tree is generic tree using adj list and dfs approach for traversal \\n\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        int [] ans = new int [n];\\n        \\n        // Making adjency list \\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\\n        for(int i =0 ;i<n ;i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        \\n        for(int [] elem : edges){\\n            int src = elem[0];\\n            int dest = elem[1];\\n            \\n            graph.get(src).add(dest);\\n            graph.get(dest).add(src);\\n        }\\n        \\n        boolean [] visited  = new boolean [n];\\n        DFS(0,graph,visited,ans,labels.toCharArray()); // Filling the ans array\\n        return ans;\\n        \\n    }\\n    \\n    public HashMap<Character,Integer> DFS(int root ,ArrayList<ArrayList<Integer>> graph , boolean [] visited,int []ans , char[] labels){\\n        HashMap<Character,Integer> res = new HashMap<>();\\n        visited[root] = true ;\\n        \\n        for(int elem : graph.get(root)){\\n           if(visited[elem]){\\n               continue ;\\n           } \\n           HashMap<Character,Integer> map = DFS(elem,graph,visited,ans,labels);\\n            // Copying all the elements in the res hashmap\\n            for(char ch :map.keySet()){\\n                // Don\\'t forget to restore the answer stored for the same key in previous call hence used ==>res.getOrDefault(ch,0)+map.get(ch)\\n                res.put(ch,res.getOrDefault(ch,0)+map.get(ch));\\n            }\\n        }\\n        \\n        res.put(labels[root],res.getOrDefault(labels[root],0)+1);\\n        ans[root] = res.get(labels[root]);\\n        return res ;\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3039133,
                "title": "fastest-solution-explained-0ms-100-o-n-time-complexity-o-n-space-complexity",
                "content": "\\n```\\nclass Solution {\\n    fun countSubTrees(n: Int, edges: Array<IntArray>, labels: String): IntArray {\\n        val graph = ArrayList<ArrayList<Int>>()\\n        for(i in 0 until n) {\\n            graph.add(ArrayList<Int>())\\n        }\\n\\n        for(edge in edges) {\\n            graph[edge[0]].add(edge[1])\\n            graph[edge[1]].add(edge[0])\\n        }\\n\\n        val visited: BooleanArray = BooleanArray(n){false}\\n        val ans: IntArray = IntArray(n){0}\\n        dfs(0, graph, ans, visited, labels)\\n        return ans\\n    }\\n\\n    fun dfs(currNode: Int, graph: ArrayList<ArrayList<Int>>, ans: IntArray, visited: BooleanArray, labels: String): IntArray {\\n        val cnt: IntArray = IntArray(26){0}\\n        if(visited[currNode]) {\\n            return cnt\\n        }\\n\\n        visited[currNode] = true\\n        val currChart: Char = labels[currNode]\\n\\n        for(i in 0 until graph[currNode].size) {\\n            val sub: IntArray = dfs(graph[currNode][i], graph, ans, visited, labels)\\n            for(j in 0 until 26) {\\n                cnt[j] += sub[j]\\n            }\\n        }\\n\\n        cnt[currChart-\\'a\\']++\\n        ans[currNode] = cnt[currChart-\\'a\\']\\n        return cnt\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun countSubTrees(n: Int, edges: Array<IntArray>, labels: String): IntArray {\\n        val graph = ArrayList<ArrayList<Int>>()\\n        for(i in 0 until n) {\\n            graph.add(ArrayList<Int>())\\n        }\\n\\n        for(edge in edges) {\\n            graph[edge[0]].add(edge[1])\\n            graph[edge[1]].add(edge[0])\\n        }\\n\\n        val visited: BooleanArray = BooleanArray(n){false}\\n        val ans: IntArray = IntArray(n){0}\\n        dfs(0, graph, ans, visited, labels)\\n        return ans\\n    }\\n\\n    fun dfs(currNode: Int, graph: ArrayList<ArrayList<Int>>, ans: IntArray, visited: BooleanArray, labels: String): IntArray {\\n        val cnt: IntArray = IntArray(26){0}\\n        if(visited[currNode]) {\\n            return cnt\\n        }\\n\\n        visited[currNode] = true\\n        val currChart: Char = labels[currNode]\\n\\n        for(i in 0 until graph[currNode].size) {\\n            val sub: IntArray = dfs(graph[currNode][i], graph, ans, visited, labels)\\n            for(j in 0 until 26) {\\n                cnt[j] += sub[j]\\n            }\\n        }\\n\\n        cnt[currChart-\\'a\\']++\\n        ans[currNode] = cnt[currChart-\\'a\\']\\n        return cnt\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039107,
                "title": "most-easy-way-to-solve-beat-95-vide-explanation-in-hindi-and-english",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nMy Approach is explained in below video\\n\\nEnglish\\n\\n[https://youtu.be/hX_GQow1r18]()\\n\\nHindi\\n\\n[https://youtu.be/M-MnxJCY3Ok]()\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[] ans;\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n\\n        ans = new int[n]; //output\\n        List<List<Integer>> adj = new ArrayList<>(n);\\n        //null \\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        //child and parent\\n        for(int[] x:edges){\\n            adj.get(x[0]).add(x[1]);//child\\n            adj.get(x[1]).add(x[0]);//parent\\n        }\\n        dfs(-1,0,adj,labels);\\n        return ans;\\n    }\\n\\n    private int[] dfs(int parent,int child,List<List<Integer>> adj,String labels)\\n    {\\n        //len 26\\n        int[] count = new int[26]; \\n        for(int x:adj.get(child)){\\n            if(parent!=x){\\n                int[] res = dfs(child,x,adj,labels);  \\n                for(int i=0;i<res.length;i++)  \\n                    count[i]+=res[i];\\n            }\\n        }\\n        char ch =labels.charAt(child);\\n        count[ch-\\'a\\']++;\\n        ans[child] = count[ch-\\'a\\']; \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] ans;\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n\\n        ans = new int[n]; //output\\n        List<List<Integer>> adj = new ArrayList<>(n);\\n        //null \\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        //child and parent\\n        for(int[] x:edges){\\n            adj.get(x[0]).add(x[1]);//child\\n            adj.get(x[1]).add(x[0]);//parent\\n        }\\n        dfs(-1,0,adj,labels);\\n        return ans;\\n    }\\n\\n    private int[] dfs(int parent,int child,List<List<Integer>> adj,String labels)\\n    {\\n        //len 26\\n        int[] count = new int[26]; \\n        for(int x:adj.get(child)){\\n            if(parent!=x){\\n                int[] res = dfs(child,x,adj,labels);  \\n                for(int i=0;i<res.length;i++)  \\n                    count[i]+=res[i];\\n            }\\n        }\\n        char ch =labels.charAt(child);\\n        count[ch-\\'a\\']++;\\n        ans[child] = count[ch-\\'a\\']; \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039078,
                "title": "kotlin-build-graph-count-by-dfs",
                "content": "# Telegram\\nhttps://t.me/leetcode_daily_unstoppable/83\\n# Intuition\\nFirst, we need to build a graph. Next, just do DFS and count all `\\'a\\'..\\'z\\'` frequencies in the current subtree.\\n\\n# Approach\\nFor building a graph let\\'s use a map, and for DFS let\\'s use a recursion. \\n* use `parent` node instead of the visited set\\n* use in-place counting and subtract `count before`\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity:\\n$$O(n)$$\\n# Code\\n```\\n    fun countSubTrees(n: Int, edges: Array<IntArray>, labels: String): IntArray {\\n        val graph = mutableMapOf<Int, MutableList<Int>>()\\n        edges.forEach { (from, to) ->\\n            graph.getOrPut(from, { mutableListOf() }) += to\\n            graph.getOrPut(to, { mutableListOf() }) += from\\n        }\\n        val answer = IntArray(n) { 0 }\\n        fun dfs(node: Int, parent: Int, counts: IntArray) {\\n            val index = labels[node].toInt() - \\'a\\'.toInt()\\n            val countParents = counts[index]\\n            counts[index]++\\n            graph[node]?.forEach {\\n                if (it != parent) {\\n                    dfs(it, node, counts)\\n                }\\n            }\\n            answer[node] = counts[index] - countParents\\n        }\\n        dfs(0, 0, IntArray(27) { 0 })\\n        return answer\\n    }\\n\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    fun countSubTrees(n: Int, edges: Array<IntArray>, labels: String): IntArray {\\n        val graph = mutableMapOf<Int, MutableList<Int>>()\\n        edges.forEach { (from, to) ->\\n            graph.getOrPut(from, { mutableListOf() }) += to\\n            graph.getOrPut(to, { mutableListOf() }) += from\\n        }\\n        val answer = IntArray(n) { 0 }\\n        fun dfs(node: Int, parent: Int, counts: IntArray) {\\n            val index = labels[node].toInt() - \\'a\\'.toInt()\\n            val countParents = counts[index]\\n            counts[index]++\\n            graph[node]?.forEach {\\n                if (it != parent) {\\n                    dfs(it, node, counts)\\n                }\\n            }\\n            answer[node] = counts[index] - countParents\\n        }\\n        dfs(0, 0, IntArray(27) { 0 })\\n        return answer\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3038982,
                "title": "number-of-nodes-in-the-sub-tree-with-the-same-label",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate an array count of size 26, where count[i] stores the number of nodes with label i in the subtree of the current node.\\nCreate an array result of size n, where result[i] stores the number of nodes in the subtree of the ith node with the same label as node i.\\nPerform a depth-first search (DFS) traversal of the tree, starting at the root node (node 0).\\nFor each node visited during the DFS, update the count array with the number of nodes with the same label as the current node in its subtree.\\nOnce the DFS traversal is complete, copy the count array to the result array for the current node.\\nRepeat steps 4 and 5 for each child of the current node.\\nReturn the result array.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n), where n is the number of nodes in the tree. We need to traverse all n nodes in the tree once\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(n), where n is the number of nodes in the tree.\\nWe need to store the count and result arrays, which have a total size.\\n# Code\\n```\\nclass Solution {\\n  public int[] countSubTrees(int n, int[][] edges, String labels) {\\n    int[] ans = new int[n];\\n    List<Integer>[] graph = new List[n];\\n    for (int i = 0; i < n; ++i)\\n      graph[i] = new ArrayList<>();\\n    for (int[] edge : edges) {\\n      final int u = edge[0];\\n      final int v = edge[1];\\n      graph[u].add(v);\\n      graph[v].add(u);\\n    }\\n    dfs(graph, 0, -1, labels, ans);\\n    return ans;\\n  }\\n  private int[] dfs(List<Integer>[] graph, int u, int parent, final String labels, int[] ans) {\\n    int[] count = new int[26]; \\n    for (final int v : graph[u]) {\\n      if (v == parent)\\n        continue;\\n      int[] childCount = dfs(graph, v, u, labels, ans);\\n      for (int i = 0; i < 26; ++i)\\n        count[i] += childCount[i];\\n    }\\n    ans[u] = ++count[labels.charAt(u) - \\'a\\'];\\n    return count;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n  public int[] countSubTrees(int n, int[][] edges, String labels) {\\n    int[] ans = new int[n];\\n    List<Integer>[] graph = new List[n];\\n    for (int i = 0; i < n; ++i)\\n      graph[i] = new ArrayList<>();\\n    for (int[] edge : edges) {\\n      final int u = edge[0];\\n      final int v = edge[1];\\n      graph[u].add(v);\\n      graph[v].add(u);\\n    }\\n    dfs(graph, 0, -1, labels, ans);\\n    return ans;\\n  }\\n  private int[] dfs(List<Integer>[] graph, int u, int parent, final String labels, int[] ans) {\\n    int[] count = new int[26]; \\n    for (final int v : graph[u]) {\\n      if (v == parent)\\n        continue;\\n      int[] childCount = dfs(graph, v, u, labels, ans);\\n      for (int i = 0; i < 26; ++i)\\n        count[i] += childCount[i];\\n    }\\n    ans[u] = ++count[labels.charAt(u) - \\'a\\'];\\n    return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038976,
                "title": "c-post-order-traversal-counting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to traverse the tree in depth first manner to get counts of labels and backtrack to the parent.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will maintain a count array for the labels of size 26(lower case alphabets). We will keep the initial count of label for each node before traversal of its child nodes. Then we can use Post Order traversal and increment the count of label for a node only after all its child nodes are traversed. To get the required count of labels in sub-trees we can subtract the initial count of label with the current count.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void getCount(int i, vector<vector<int>>& tree, string& labels, vector<int>& counts, vector<int>& res) {\\n        //saving initial count\\n        int count = counts[labels[i] - \\'a\\'];\\n        //marking this 0 to signify the node is visited\\n        res[i] = 0;\\n        for(int node : tree[i]) {\\n            if(res[node] == -1) {//visited check\\n                getCount(node, tree, labels, counts, res);\\n            }\\n        }\\n        //increment label count after child nodes traversal\\n        counts[labels[i] - \\'a\\'] += 1;\\n        //final count is current count - initial count\\n        res[i] = counts[labels[i] - \\'a\\'] - count;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        //to store counts of labels\\n        vector<int> counts(26, 0);\\n        //result vector that will be returned\\n        vector<int> res(n, -1);\\n        //adjacency list for tree\\n        vector<vector<int>> tree(n);\\n        for(auto edge : edges) {\\n            tree[edge[0]].push_back(edge[1]);\\n            tree[edge[1]].push_back(edge[0]);\\n        }\\n        getCount(0, tree, labels, counts, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void getCount(int i, vector<vector<int>>& tree, string& labels, vector<int>& counts, vector<int>& res) {\\n        //saving initial count\\n        int count = counts[labels[i] - \\'a\\'];\\n        //marking this 0 to signify the node is visited\\n        res[i] = 0;\\n        for(int node : tree[i]) {\\n            if(res[node] == -1) {//visited check\\n                getCount(node, tree, labels, counts, res);\\n            }\\n        }\\n        //increment label count after child nodes traversal\\n        counts[labels[i] - \\'a\\'] += 1;\\n        //final count is current count - initial count\\n        res[i] = counts[labels[i] - \\'a\\'] - count;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        //to store counts of labels\\n        vector<int> counts(26, 0);\\n        //result vector that will be returned\\n        vector<int> res(n, -1);\\n        //adjacency list for tree\\n        vector<vector<int>> tree(n);\\n        for(auto edge : edges) {\\n            tree[edge[0]].push_back(edge[1]);\\n            tree[edge[1]].push_back(edge[0]);\\n        }\\n        getCount(0, tree, labels, counts, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038898,
                "title": "74-8-faster-c-dfs-simple-clean-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    vector<ll>temp;\\n\\n    vector<ll> solve(vector<ll>adj[],ll curr,ll prev,string &labels,vector<int>&ans){\\n        vector<ll>container(26,0);\\n        for(auto &x:adj[curr]){\\n            if(x!=prev){\\n                temp=solve(adj,x,curr,labels,ans);\\n                for(ll i=0;i<26;i++){\\n                    container[i]+=temp[i];\\n                }\\n            }\\n        }\\n        ans[curr]=++container[labels[curr]-\\'a\\'];\\n        return container;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<ll>adj[n];\\n        vector<int>ans(n);\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        solve(adj,0,-1,labels,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    vector<ll>temp;\\n\\n    vector<ll> solve(vector<ll>adj[],ll curr,ll prev,string &labels,vector<int>&ans){\\n        vector<ll>container(26,0);\\n        for(auto &x:adj[curr]){\\n            if(x!=prev){\\n                temp=solve(adj,x,curr,labels,ans);\\n                for(ll i=0;i<26;i++){\\n                    container[i]+=temp[i];\\n                }\\n            }\\n        }\\n        ans[curr]=++container[labels[curr]-\\'a\\'];\\n        return container;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<ll>adj[n];\\n        vector<int>ans(n);\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        solve(adj,0,-1,labels,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038833,
                "title": "c-dfs-approach-simple-most-intuitive-code-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- As no proper tree structure is given, we are supposed to construct a tree graph out of the given edges.\\n- Due to strict time constraints, $$O(n)$$ algorithm would suffice which can only be achieved by using DFS in this case.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### Step 1>  Create an Adjacency List using the given edges.\\n##### Step 2>  Declare an answer vector which will store the answer/count corresponding each node.\\n##### Step 3>  Create a DFS function which:\\n- get the count vector from its children\\n- appends the current node label\\n- updates the answer vector\\n- returns the count vector to its parent\\n##### Step 4>  Finally return the updated answer vector.\\n# Complexity\\n- Time complexity: $$O(n)$$ (DFS approach)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ (for construction of adjacency List)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<int> dfs(int node, int parent, vector<vector<int>>& alist, vector<int>& ans, string &label){\\n        // count vector for storing each letter count from sub-tree\\n        vector<int> count(26, 0);\\n\\n        // populating count vector\\n        for(auto nbr : alist[node]){\\n            if(nbr != parent){\\n                vector<int> nbrCount = dfs(nbr, node, alist, ans, label);\\n                for(int i=0 ; i<26 ; i++)\\n                    count[i] += nbrCount[i];\\n            }\\n        }\\n\\n        // updating count vector and answer vector\\n        char currChar = label[node];\\n        count[currChar - \\'a\\']++;\\n        ans[node] = count[currChar - \\'a\\'];\\n\\n        // returning the count vector to its parent\\n        return count;\\n    }\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        //declaring adjacency list and answer vector\\n        vector<vector<int>> alist(n, vector<int>());\\n        vector<int> ans(n, 0);\\n        \\n        // Creating the adjacency list\\n        for(auto edge : edges){\\n            alist[edge[0]].push_back(edge[1]);\\n            alist[edge[1]].push_back(edge[0]);\\n        }\\n\\n        // Calling the DFS function on node 0\\n        // dfs(currNode, parent, adjList, answer, labels);\\n        dfs(0, 0, alist, ans, labels);\\n\\n        //returning the answer vector which stores the actual result\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> dfs(int node, int parent, vector<vector<int>>& alist, vector<int>& ans, string &label){\\n        // count vector for storing each letter count from sub-tree\\n        vector<int> count(26, 0);\\n\\n        // populating count vector\\n        for(auto nbr : alist[node]){\\n            if(nbr != parent){\\n                vector<int> nbrCount = dfs(nbr, node, alist, ans, label);\\n                for(int i=0 ; i<26 ; i++)\\n                    count[i] += nbrCount[i];\\n            }\\n        }\\n\\n        // updating count vector and answer vector\\n        char currChar = label[node];\\n        count[currChar - \\'a\\']++;\\n        ans[node] = count[currChar - \\'a\\'];\\n\\n        // returning the count vector to its parent\\n        return count;\\n    }\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        //declaring adjacency list and answer vector\\n        vector<vector<int>> alist(n, vector<int>());\\n        vector<int> ans(n, 0);\\n        \\n        // Creating the adjacency list\\n        for(auto edge : edges){\\n            alist[edge[0]].push_back(edge[1]);\\n            alist[edge[1]].push_back(edge[0]);\\n        }\\n\\n        // Calling the DFS function on node 0\\n        // dfs(currNode, parent, adjList, answer, labels);\\n        dfs(0, 0, alist, ans, labels);\\n\\n        //returning the answer vector which stores the actual result\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038810,
                "title": "simple-dfs-c",
                "content": "```\\nT.C: O(N)\\nS.C: O(N)\\n\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node,vector<int> &vis,vector<int> G[],vector<int> &res,string &labels){\\n        if(node!=0 && G[node].size()==1){\\n            vector<int> v(26,0);\\n            v[labels[node]-\\'a\\']=1;\\n            return v;\\n        }\\n        vis[node]=1;\\n        vector<int> v(26,0);\\n        v[labels[node]-\\'a\\']=1;\\n        for(auto child:G[node]){\\n            if(!vis[child]){\\n                vector<int> u=dfs(child,vis,G,res,labels);\\n                for(int i=0;i<26;i++){\\n                    v[i]+=u[i];\\n                }\\n            }\\n        }\\n        res[node]=v[labels[node]-\\'a\\'];\\n        return v;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> G[n];\\n        vector<int> res(n,1),vis(n,0);\\n        for(auto e:edges){\\n            G[e[0]].push_back(e[1]);\\n            G[e[1]].push_back(e[0]);\\n        }\\n        dfs(0,vis,G,res,labels);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nT.C: O(N)\\nS.C: O(N)\\n\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node,vector<int> &vis,vector<int> G[],vector<int> &res,string &labels){\\n        if(node!=0 && G[node].size()==1){\\n            vector<int> v(26,0);\\n            v[labels[node]-\\'a\\']=1;\\n            return v;\\n        }\\n        vis[node]=1;\\n        vector<int> v(26,0);\\n        v[labels[node]-\\'a\\']=1;\\n        for(auto child:G[node]){\\n            if(!vis[child]){\\n                vector<int> u=dfs(child,vis,G,res,labels);\\n                for(int i=0;i<26;i++){\\n                    v[i]+=u[i];\\n                }\\n            }\\n        }\\n        res[node]=v[labels[node]-\\'a\\'];\\n        return v;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> G[n];\\n        vector<int> res(n,1),vis(n,0);\\n        for(auto e:edges){\\n            G[e[0]].push_back(e[1]);\\n            G[e[1]].push_back(e[0]);\\n        }\\n        dfs(0,vis,G,res,labels);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038798,
                "title": "c-dfs-runtime-651-ms-beats-77-4-memory-216-4-mb-beats-60-74",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse dfs and for each node return a vector of size 26 representing the freqency of each alphabet in its subtree.\\n\\n# Complexity\\n- Time complexity: O((N+E) + N*26)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N+E)+O(N)+O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> solve(int node, int n, vector<int> adj[], vector<int>&vis, string &labels, vector<int>&ans){\\n        vis[node]=1;\\n\\n        vector<int>mm(26,0);\\n\\n        for(auto it: adj[node]){\\n            if(!vis[it]){\\n                vector<int>m=solve(it,n,adj,vis,labels,ans);\\n                for(int i=0;i<26;i++){\\n                    mm[i]+=m[i];\\n                }\\n            }\\n        }\\n        mm[labels[node]-\\'a\\']++;\\n        \\n        ans[node]=mm[labels[node]-\\'a\\'];\\n        \\n        return mm;\\n\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> adj[n];\\n\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        vector<int>vis(n,0);\\n        vector<int>ans(n,0);\\n\\n        solve(0,n,adj,vis,labels,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> solve(int node, int n, vector<int> adj[], vector<int>&vis, string &labels, vector<int>&ans){\\n        vis[node]=1;\\n\\n        vector<int>mm(26,0);\\n\\n        for(auto it: adj[node]){\\n            if(!vis[it]){\\n                vector<int>m=solve(it,n,adj,vis,labels,ans);\\n                for(int i=0;i<26;i++){\\n                    mm[i]+=m[i];\\n                }\\n            }\\n        }\\n        mm[labels[node]-\\'a\\']++;\\n        \\n        ans[node]=mm[labels[node]-\\'a\\'];\\n        \\n        return mm;\\n\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> adj[n];\\n\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        vector<int>vis(n,0);\\n        vector<int>ans(n,0);\\n\\n        solve(0,n,adj,vis,labels,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038688,
                "title": "python3-1464-ms-faster-than-100-00-of-python3-clean-and-easy-to-understand",
                "content": "```\\ndef countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        response = [0] * n\\n        node2edges = [[] for _ in range(n)]\\n        for edge in edges:\\n            node2edges[edge[0]].append(edge[1])\\n            node2edges[edge[1]].append(edge[0])\\n            \\n        def dfs(nodeId, parentNodeId, labelCounter):\\n            nodeLabelId = ord(labels[nodeId]) - 97\\n            before = labelCounter[nodeLabelId]\\n            labelCounter[nodeLabelId] += 1\\n            for nextNodeId in node2edges[nodeId]:\\n                if nextNodeId == parentNodeId:\\n                    continue\\n                dfs(nextNodeId, nodeId, labelCounter)\\n            response[nodeId] = labelCounter[nodeLabelId] - before\\n        dfs(0, -1, [0] * 26)\\n        return response\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Counting"
                ],
                "code": "```\\ndef countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        response = [0] * n\\n        node2edges = [[] for _ in range(n)]\\n        for edge in edges:\\n            node2edges[edge[0]].append(edge[1])\\n            node2edges[edge[1]].append(edge[0])\\n            \\n        def dfs(nodeId, parentNodeId, labelCounter):\\n            nodeLabelId = ord(labels[nodeId]) - 97\\n            before = labelCounter[nodeLabelId]\\n            labelCounter[nodeLabelId] += 1\\n            for nextNodeId in node2edges[nodeId]:\\n                if nextNodeId == parentNodeId:\\n                    continue\\n                dfs(nextNodeId, nodeId, labelCounter)\\n            response[nodeId] = labelCounter[nodeLabelId] - before\\n        dfs(0, -1, [0] * 26)\\n        return response\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3038627,
                "title": "dfs-c-simple-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(V+E)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(V+E)\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int>dfs(int u,vector<vector<int>>&adj,string &lb,vector<bool>&vis,vector<int>&ans){\\n        vector<int>arr(26,0);\\n        vector<int>count(26,0);\\n        vis[u]=1;\\n        for(auto a:adj[u]){\\n            if(!vis[a]){\\n                arr=dfs(a,adj,lb,vis,ans);\\n                for(int i=0;i<26;i++){\\n                count[i]+=arr[i];\\n                }\\n                \\n            }\\n        }\\n        ans[u]=++count[lb[u]-\\'a\\'];\\n        return count;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>>adj(n);\\n        vector<bool>vis(n,0);\\n        vector<int>ans(n,0);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n         dfs(0,adj,labels,vis,ans);\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int>dfs(int u,vector<vector<int>>&adj,string &lb,vector<bool>&vis,vector<int>&ans){\\n        vector<int>arr(26,0);\\n        vector<int>count(26,0);\\n        vis[u]=1;\\n        for(auto a:adj[u]){\\n            if(!vis[a]){\\n                arr=dfs(a,adj,lb,vis,ans);\\n                for(int i=0;i<26;i++){\\n                count[i]+=arr[i];\\n                }\\n                \\n            }\\n        }\\n        ans[u]=++count[lb[u]-\\'a\\'];\\n        return count;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>>adj(n);\\n        vector<bool>vis(n,0);\\n        vector<int>ans(n,0);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n         dfs(0,adj,labels,vis,ans);\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038576,
                "title": "dfs-dp",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- O(26*N) ~ O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- O(N)\\n\\n# Code\\n```\\nfunc countSubTrees(n int, edges [][]int, labels string) []int {\\n    \\n    if len(edges) == 0 {\\n        return []int{}\\n    }\\n\\n    graph := make(map[int][]int)\\n    for i:=0; i<n; i++ {\\n        graph[i] = make([]int, 0)\\n    }\\n    for _, edge := range edges {\\n        graph[edge[0]] = append(graph[edge[0]], edge[1])\\n        graph[edge[1]] = append(graph[edge[1]], edge[0])\\n    }\\n    ans := make([]int, n)\\n    for i := range ans {\\n        ans[i]++\\n    }\\n    dfs(graph, labels, &ans, 0, -1)\\n    return ans\\n}\\n\\nfunc dfs(graph map[int][]int, labels string, ans *[]int, node, parent int) []int {\\n        \\n        //store the all the labels we can get in any subtree of parent node\\n        nodeCounts := make([]int, 26)\\n        nodeCounts[labels[node]-\\'a\\'] = 1\\n\\n        for _, child := range graph[node] {\\n            if child == parent {\\n                continue\\n            }\\n            childCounts := dfs(graph, labels, ans, child, node)\\n            for i := range childCounts {\\n                nodeCounts[i] += childCounts[i]\\n            }\\n        }\\n\\n        (*ans)[node] = nodeCounts[labels[node]-\\'a\\']\\n        return nodeCounts\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Counting"
                ],
                "code": "```\\nfunc countSubTrees(n int, edges [][]int, labels string) []int {\\n    \\n    if len(edges) == 0 {\\n        return []int{}\\n    }\\n\\n    graph := make(map[int][]int)\\n    for i:=0; i<n; i++ {\\n        graph[i] = make([]int, 0)\\n    }\\n    for _, edge := range edges {\\n        graph[edge[0]] = append(graph[edge[0]], edge[1])\\n        graph[edge[1]] = append(graph[edge[1]], edge[0])\\n    }\\n    ans := make([]int, n)\\n    for i := range ans {\\n        ans[i]++\\n    }\\n    dfs(graph, labels, &ans, 0, -1)\\n    return ans\\n}\\n\\nfunc dfs(graph map[int][]int, labels string, ans *[]int, node, parent int) []int {\\n        \\n        //store the all the labels we can get in any subtree of parent node\\n        nodeCounts := make([]int, 26)\\n        nodeCounts[labels[node]-\\'a\\'] = 1\\n\\n        for _, child := range graph[node] {\\n            if child == parent {\\n                continue\\n            }\\n            childCounts := dfs(graph, labels, ans, child, node)\\n            for i := range childCounts {\\n                nodeCounts[i] += childCounts[i]\\n            }\\n        }\\n\\n        (*ans)[node] = nodeCounts[labels[node]-\\'a\\']\\n        return nodeCounts\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3038574,
                "title": "dfs-dynamic-programming-based-solution-c",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dfs(vector<vector<int>>&adj,int src, int par,vector<int>&ans,string&labels){\\n        vector<int> letter(26,0);\\n        if(src<labels.size())\\n        letter[labels[src]-\\'a\\']=1;\\n        for(auto it: adj[src]){\\n            if(it==par) continue;\\n            auto x=dfs(adj,it,src,ans,labels);\\n            for(int i = 0; i < 26; i++){\\n                letter[i]+=x[i];\\n            }\\n        }\\n        if(src<ans.size())\\n        ans[src]=letter[labels[src]-\\'a\\'];\\n        return letter;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adj(n);\\n        for(int i = 0; i < edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> ans(n,0);\\n        dfs(adj,0,-1,ans,labels);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dfs(vector<vector<int>>&adj,int src, int par,vector<int>&ans,string&labels){\\n        vector<int> letter(26,0);\\n        if(src<labels.size())\\n        letter[labels[src]-\\'a\\']=1;\\n        for(auto it: adj[src]){\\n            if(it==par) continue;\\n            auto x=dfs(adj,it,src,ans,labels);\\n            for(int i = 0; i < 26; i++){\\n                letter[i]+=x[i];\\n            }\\n        }\\n        if(src<ans.size())\\n        ans[src]=letter[labels[src]-\\'a\\'];\\n        return letter;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adj(n);\\n        for(int i = 0; i < edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> ans(n,0);\\n        dfs(adj,0,-1,ans,labels);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038567,
                "title": "easy-and-simple-php-number-of-nodes-in-the-subtree-with-the-same-label",
                "content": "# upvote for PHP \\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @param Integer[][] $edges\\n     * @param String $labels\\n     * @return Integer[]\\n     */\\n    function countSubTrees($n, $edges, $labels) {\\n        $adj = array();\\n        for ($i = 0; $i < $n; $i++) $adj[$i] = array();\\n        \\n        $result = array_fill(0, $n, 0);\\n        for($i = 0; $i < count($edges); $i++) {\\n            array_push($adj[$edges[$i][0]], $edges[$i][1]);\\n            array_push($adj[$edges[$i][1]], $edges[$i][0]);\\n        }\\n        $this->dfs($adj, $labels, 0, $result);\\n        return $result;\\n    }\\n    public function dfs(&$adj, &$labels, $i, &$result) {\\n        $ans = array_fill(0, 26, 0);\\n        $result[$i] = 1;\\n        $ans[ord($labels[$i]) - ord(\\'a\\')] = 1;\\n        \\n        for($j = 0; $j < count($adj[$i]); $j++)\\n            if(!$result[$adj[$i][$j]]) {\\n                $tmp = $this->dfs($adj, $labels, $adj[$i][$j], $result);\\n                for($k = 0; $k < 26; $k++) $ans[$k] += $tmp[$k];\\n            }\\n        $result[$i] = $ans[ord($labels[$i]) - ord(\\'a\\')];\\n        return $ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @param Integer[][] $edges\\n     * @param String $labels\\n     * @return Integer[]\\n     */\\n    function countSubTrees($n, $edges, $labels) {\\n        $adj = array();\\n        for ($i = 0; $i < $n; $i++) $adj[$i] = array();\\n        \\n        $result = array_fill(0, $n, 0);\\n        for($i = 0; $i < count($edges); $i++) {\\n            array_push($adj[$edges[$i][0]], $edges[$i][1]);\\n            array_push($adj[$edges[$i][1]], $edges[$i][0]);\\n        }\\n        $this->dfs($adj, $labels, 0, $result);\\n        return $result;\\n    }\\n    public function dfs(&$adj, &$labels, $i, &$result) {\\n        $ans = array_fill(0, 26, 0);\\n        $result[$i] = 1;\\n        $ans[ord($labels[$i]) - ord(\\'a\\')] = 1;\\n        \\n        for($j = 0; $j < count($adj[$i]); $j++)\\n            if(!$result[$adj[$i][$j]]) {\\n                $tmp = $this->dfs($adj, $labels, $adj[$i][$j], $result);\\n                for($k = 0; $k < 26; $k++) $ans[$k] += $tmp[$k];\\n            }\\n        $result[$i] = $ans[ord($labels[$i]) - ord(\\'a\\')];\\n        return $ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038478,
                "title": "tree-based-solution-dfs-and-hash-map-dynamic-programming-c-explanation",
                "content": "# Explanation\\n    1) Build a generic tree(tree having 0 or more branches) using \\n    hashmap to store the Node value as key and reference as value of \\n    the map.\\n    2) Use dfs function to traverse through the tree with return type \\n    vector:\\n        a) create a vector of letters (size:26)\\n        b) recursively call for the children nodes of the root.\\n        c) calculate sum of letter indices and return array indices\\n           for all 26 letters.\\n        d) Lastly increment the value of current label in the letter\\n           by 1. this would keep track of number of each label from \\n           (a-z) in the present subtree.\\n    3) return letter array for each recursive call.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Tree{\\npublic:\\n    unordered_map<int,Tree*> m;\\n    char label;\\n    int data;\\n    Tree(int data, char label){\\n        m.clear();\\n        this->data=data;\\n        this->label=label;\\n        \\n    }\\n};\\nclass Solution {\\npublic:\\n    Tree* buildTree(vector<vector<int>>&adj,int src, vector<bool>&vis,string&labels){\\n        vis[src]=true;\\n        Tree* root=new Tree(src,labels[src]);\\n        for(auto it: adj[src]){\\n            if(!vis[it]) root->m[it]=buildTree(adj,it,vis,labels);\\n        }\\n        return root;\\n    }\\n    vector<int> dfs(Tree* root, vector<int>&ans){\\n        if(root==NULL) return{};\\n        vector<int> letter(26,0);\\n        for(auto it: root->m){\\n            auto x=dfs(it.second,ans);\\n            for(int i = 0; i < 26; i++){\\n                letter[i]+=x[i];\\n            }\\n        }\\n        ans[root->data]=letter[root->label-\\'a\\']+1;\\n        letter[root->label-\\'a\\']+=1;\\n        return letter;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n,false);\\n        for(int i = 0; i < edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> ans(n,0);\\n        Tree* root=buildTree(adj,0,vis,labels);\\n        auto x=dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Tree{\\npublic:\\n    unordered_map<int,Tree*> m;\\n    char label;\\n    int data;\\n    Tree(int data, char label){\\n        m.clear();\\n        this->data=data;\\n        this->label=label;\\n        \\n    }\\n};\\nclass Solution {\\npublic:\\n    Tree* buildTree(vector<vector<int>>&adj,int src, vector<bool>&vis,string&labels){\\n        vis[src]=true;\\n        Tree* root=new Tree(src,labels[src]);\\n        for(auto it: adj[src]){\\n            if(!vis[it]) root->m[it]=buildTree(adj,it,vis,labels);\\n        }\\n        return root;\\n    }\\n    vector<int> dfs(Tree* root, vector<int>&ans){\\n        if(root==NULL) return{};\\n        vector<int> letter(26,0);\\n        for(auto it: root->m){\\n            auto x=dfs(it.second,ans);\\n            for(int i = 0; i < 26; i++){\\n                letter[i]+=x[i];\\n            }\\n        }\\n        ans[root->data]=letter[root->label-\\'a\\']+1;\\n        letter[root->label-\\'a\\']+=1;\\n        return letter;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n,false);\\n        for(int i = 0; i < edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> ans(n,0);\\n        Tree* root=buildTree(adj,0,vis,labels);\\n        auto x=dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038430,
                "title": "c-building-tree-concise-explanation-depth-first-search",
                "content": "# Intuition\\nUse Postorder traversal to count nodes with same label in subtrees\\n# Approach\\n- Maintain an array which contains count of all labels in subtrees and another array which is our final answer\\n\\n- After traversing subtrees, add current label count and assign answer of current node in answer array\\n\\n# Complexity\\n- Time complexity : $$O(N)$$ \\n- Space complexity : $$O(N)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>solve(int root,vector<vector<int>>& graph,string& labels,vector<int>& vis,vector<int>& ans)\\n    {\\n        vis[root]=1;\\n\\n        vector<int>curr(26,0);\\n        \\n        for(int node : graph[root])\\n        {\\n            if(vis[node]) continue;\\n            vector<int>temp=solve(node,graph,labels,vis,ans);\\n\\n            for(int i=0;i<26;i++) curr[i]+=temp[i];\\n        }\\n        curr[labels[root]-\\'a\\']++;\\n        ans[root]=curr[labels[root]-\\'a\\'];\\n        return curr;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) \\n    {\\n        vector<vector<int>>graph(n,vector<int>());\\n        vector<int>ans(n);\\n        vector<int>vis(n,0);\\n\\n        for(auto edge : edges)\\n        {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }    \\n        vector<int>final=solve(0,graph,labels,vis,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>solve(int root,vector<vector<int>>& graph,string& labels,vector<int>& vis,vector<int>& ans)\\n    {\\n        vis[root]=1;\\n\\n        vector<int>curr(26,0);\\n        \\n        for(int node : graph[root])\\n        {\\n            if(vis[node]) continue;\\n            vector<int>temp=solve(node,graph,labels,vis,ans);\\n\\n            for(int i=0;i<26;i++) curr[i]+=temp[i];\\n        }\\n        curr[labels[root]-\\'a\\']++;\\n        ans[root]=curr[labels[root]-\\'a\\'];\\n        return curr;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) \\n    {\\n        vector<vector<int>>graph(n,vector<int>());\\n        vector<int>ans(n);\\n        vector<int>vis(n,0);\\n\\n        for(auto edge : edges)\\n        {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }    \\n        vector<int>final=solve(0,graph,labels,vis,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038396,
                "title": "simple-dfs-approach-beats-99-python",
                "content": "# Intuition\\nLet us assume that each parent node will have access to dictionary { label1 : freq1, label2 : freq2, ...} returned by its Children nodes that will contain info about lables and corresponding frequencies of all its children\\n\\n# Approach\\nStart from 0 as source node and do a Depth-First-Search. Since we would want to avoid unnecessary loops, do not visited parent again. \\n\\n# Complexity\\n- Time complexity:\\nDFS has O(n) time complexity but since we will also iterate through dictionary returned by children of each node to update parents\\' dictionary, time complexity would be O(n^2) in worst case\\n\\n\\n- Space complexity:\\nspace complexity will be O(N) in worst case as for each parent at most n labels will be present in the dictionary in the stack at any given time\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n\\n        # create the graph\\n        graph = {} \\n        for u,v in edges:\\n            if u in graph:\\n                graph[u].append(v) # last submission failed as i wrote graph[u].append(u) here..LOL\\n            else:\\n                graph[u] = [v]\\n            \\n            if v in graph:\\n                graph[v].append(u)\\n            else:\\n                graph[v] = [u]\\n\\n        \\n        # store the result in res. \\n        # Index i of res will correspond to node i \\n        # and value at index i will represent the number of lables seen with its children\\n        # which are same as lable at index i in \\'lables\\' string\\n        \\n        res = [0]*(n)\\n\\n        def dfs(src, prnt):\\n\\n\\n            # every node will have freq = 1 corresponding to its lable to begin with (trivial)\\n            lableFreq = {labels[src] : 1}\\n\\n            \\n            # handle edge case where there is only 1 node (n==1)\\n            # According to the way we have constructed the graph,\\n            # single node will not be present as key in graph.\\n            \\n\\n            if src not in graph:\\n                res[src] = lableFreq[labels[src]]\\n                return\\n            \\n            # loop over children\\n            for child in graph[src]:\\n                # since it is a tree,\\n                # we just have to avoid going back to parent \\n                # to avoid loop\\n                if child == prnt:\\n                    continue\\n\\n                lableFreqChildren = dfs(child, src)\\n\\n                # lables and freq returned from each children \\n                # will be used to update the parents dictionary \\'lableFreq\\'\\n                for key, val in lableFreqChildren.items():\\n                    if key in lableFreq:\\n                        lableFreq[key] += lableFreqChildren[key]\\n                    else:\\n                        lableFreq[key] =  val\\n                \\n            # in the post order, \\n            # node will update the res array \\n            # as it have accumulated the freq of lables from its chilren\\n            res[src] = lableFreq[labels[src]]\\n            \\n            # return the updated freq of lables upto to this node to its parent\\n            return lableFreq\\n\\n        \\n        # call dfs with src as 0 and its parent as -1.\\n        dfs(0,-1)\\n\\n        # once the dfs function is completed,\\n        # res must have all the answer we need\\n        return res\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n\\n        # create the graph\\n        graph = {} \\n        for u,v in edges:\\n            if u in graph:\\n                graph[u].append(v) # last submission failed as i wrote graph[u].append(u) here..LOL\\n            else:\\n                graph[u] = [v]\\n            \\n            if v in graph:\\n                graph[v].append(u)\\n            else:\\n                graph[v] = [u]\\n\\n        \\n        # store the result in res. \\n        # Index i of res will correspond to node i \\n        # and value at index i will represent the number of lables seen with its children\\n        # which are same as lable at index i in \\'lables\\' string\\n        \\n        res = [0]*(n)\\n\\n        def dfs(src, prnt):\\n\\n\\n            # every node will have freq = 1 corresponding to its lable to begin with (trivial)\\n            lableFreq = {labels[src] : 1}\\n\\n            \\n            # handle edge case where there is only 1 node (n==1)\\n            # According to the way we have constructed the graph,\\n            # single node will not be present as key in graph.\\n            \\n\\n            if src not in graph:\\n                res[src] = lableFreq[labels[src]]\\n                return\\n            \\n            # loop over children\\n            for child in graph[src]:\\n                # since it is a tree,\\n                # we just have to avoid going back to parent \\n                # to avoid loop\\n                if child == prnt:\\n                    continue\\n\\n                lableFreqChildren = dfs(child, src)\\n\\n                # lables and freq returned from each children \\n                # will be used to update the parents dictionary \\'lableFreq\\'\\n                for key, val in lableFreqChildren.items():\\n                    if key in lableFreq:\\n                        lableFreq[key] += lableFreqChildren[key]\\n                    else:\\n                        lableFreq[key] =  val\\n                \\n            # in the post order, \\n            # node will update the res array \\n            # as it have accumulated the freq of lables from its chilren\\n            res[src] = lableFreq[labels[src]]\\n            \\n            # return the updated freq of lables upto to this node to its parent\\n            return lableFreq\\n\\n        \\n        # call dfs with src as 0 and its parent as -1.\\n        dfs(0,-1)\\n\\n        # once the dfs function is completed,\\n        # res must have all the answer we need\\n        return res\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038373,
                "title": "c-hindi-explained-solution",
                "content": "[https://youtu.be/I8T9vQRnlhY]()\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<char,int> fun(vector<vector<int>>& gr,string &labels,vector<bool>&visited,vector<int>&ans,int n){\\n        unordered_map<char,int>my_count;\\n        my_count[labels[n]]++;\\n        visited[n]=true;\\n        unordered_map<char,int> temp;\\n        for(auto &x:gr[n]){\\n            if(visited[x])\\n                continue;\\n            temp=fun(gr,labels,visited,ans,x);\\n            for(auto &y:temp)\\n                my_count[y.first]+=(y.second);\\n        }\\n        ans[n]=my_count[labels[n]];\\n        return my_count;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>>gr(n);\\n        vector<int>ans(n);\\n        vector<bool>visited(n);\\n        int u,v;\\n        for(auto &x: edges){\\n            u=x[0];\\n            v=x[1];\\n            gr[u].push_back(v);\\n            gr[v].push_back(u);\\n        }\\n        fun(gr,labels,visited,ans,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<char,int> fun(vector<vector<int>>& gr,string &labels,vector<bool>&visited,vector<int>&ans,int n){\\n        unordered_map<char,int>my_count;\\n        my_count[labels[n]]++;\\n        visited[n]=true;\\n        unordered_map<char,int> temp;\\n        for(auto &x:gr[n]){\\n            if(visited[x])\\n                continue;\\n            temp=fun(gr,labels,visited,ans,x);\\n            for(auto &y:temp)\\n                my_count[y.first]+=(y.second);\\n        }\\n        ans[n]=my_count[labels[n]];\\n        return my_count;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>>gr(n);\\n        vector<int>ans(n);\\n        vector<bool>visited(n);\\n        int u,v;\\n        for(auto &x: edges){\\n            u=x[0];\\n            v=x[1];\\n            gr[u].push_back(v);\\n            gr[v].push_back(u);\\n        }\\n        fun(gr,labels,visited,ans,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038281,
                "title": "typescript-javascript-solution-using-hashmap",
                "content": "\\n\\n# Code\\n```\\nfunction countSubTrees(n: number, edges: number[][], labels: string): number[] {\\n    const res = new Array(n).fill(1);\\n\\n    const adj = new Map<number,number[]>();\\n    for(const [from,to] of edges)\\n    {\\n        if(adj.has(from))\\n            adj.get(from).push(to)\\n        else\\n            adj.set(from,[to])\\n\\n        if(adj.has(to))\\n            adj.get(to).push(from)\\n        else\\n            adj.set(to,[from])\\n    }\\n\\n    const vis = new Array<boolean>(n).fill(false);\\n\\n    dfs(0,adj,labels,vis,res);\\n\\n    return res;\\n};\\n\\nfunction dfs(node:number,adj:Map<number,number[]>,labels:string,vis:boolean[],res:number[]):Map<string,number>\\n{\\n\\n    vis[node] = true;\\n\\n    const m = new Map<string,number>();\\n    m.set(labels[node],1);\\n\\n    for(const v of adj.get(node))\\n    {\\n        if(!vis[v])\\n        {\\n            const temp = dfs(v,adj,labels,vis,res);\\n\\n            for(const [key,value] of temp)\\n            {\\n                if(m.has(key))\\n                    m.set(key,m.get(key)+value)\\n                else\\n                    m.set(key,value)\\n            }\\n        }\\n    }\\n    \\n    res[node] = m.get(labels[node])\\n\\n    return m;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction countSubTrees(n: number, edges: number[][], labels: string): number[] {\\n    const res = new Array(n).fill(1);\\n\\n    const adj = new Map<number,number[]>();\\n    for(const [from,to] of edges)\\n    {\\n        if(adj.has(from))\\n            adj.get(from).push(to)\\n        else\\n            adj.set(from,[to])\\n\\n        if(adj.has(to))\\n            adj.get(to).push(from)\\n        else\\n            adj.set(to,[from])\\n    }\\n\\n    const vis = new Array<boolean>(n).fill(false);\\n\\n    dfs(0,adj,labels,vis,res);\\n\\n    return res;\\n};\\n\\nfunction dfs(node:number,adj:Map<number,number[]>,labels:string,vis:boolean[],res:number[]):Map<string,number>\\n{\\n\\n    vis[node] = true;\\n\\n    const m = new Map<string,number>();\\n    m.set(labels[node],1);\\n\\n    for(const v of adj.get(node))\\n    {\\n        if(!vis[v])\\n        {\\n            const temp = dfs(v,adj,labels,vis,res);\\n\\n            for(const [key,value] of temp)\\n            {\\n                if(m.has(key))\\n                    m.set(key,m.get(key)+value)\\n                else\\n                    m.set(key,value)\\n            }\\n        }\\n    }\\n    \\n    res[node] = m.get(labels[node])\\n\\n    return m;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1753359,
                "content": [
                    {
                        "username": "kiwijuice56",
                        "content": "`[[0,2],[0,3],[1,2]]` is a valid test case because we are given an UNDIRECTED graph. The edge `[1,2]` does not necessarily mean that node `1` is the parent of `2`, but that there exists an edge between them. So, the tree constructed would look like this:\n\n```\n     0\n   /   \\\n  3     2 \n         \\\n          1\n```"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Well, it\\'s quite tricky, to be honest. When I see tree problem, I\\'m assume that I don\\'t need keep undirected connections. "
                    },
                    {
                        "username": "tedBian",
                        "content": "if problem doesn\\'t use the word \"sub-tree\" then this one could be very clear. It is possible people will consider index-0 is parent of index-1"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "[@alex-oreshkov](/alex-oreshkov) The graph vs sub-tree debate aside, this feels like a cheeky test case meant to unnecessarily make the problem harder. Its no way testing the actual logic behind the solution. Just forces you to incorporate some additional code to handle these edge cases. \\n\\nAlso, though the parent-child relationship is not explicitly mentioned, the presence of a root implies a parent-child relationship. There is one particular test case, \\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\nwhere the very first edge, we are forced to establish 0 as the parent simply because its the root. If we were to treat 0 as the child in this tree, you would get a different tree and the wrong answer. "
                    },
                    {
                        "username": "Saklor",
                        "content": "[@Prabhash123](/Prabhash123) \\n\\n\"node0 can be parent of node1 and vice versa\" only one of these statements is true for any edge, because we know that node 0 is the root. The node closer to the root will be the parent and the one further away the child.\\n[0,1] and [1,0] are the exact same edge because the graph is undirected, and both should return [2,1] in your example because 0 is the root node, and 1 is a leaf."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "[[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1].\\n "
                    },
                    {
                        "username": "happysings",
                        "content": "[@alex-oreshkov](/alex-oreshkov) \\n\\nedges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\\n\\nNowhere in the statement it says that ai is the parent and bi is the child.\\n\\nTheoretically - \\nAs long as the graph is undirected and has no cycles - you can choose any node as the root - its just traversal strategy to remember where the traversal began and not go back to that path - the ancestors.\\n\\nHere the problem sets the root to 0 node and hence you can confirm the paret/child relation only after traversing that edge from root."
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "No, it is not. First of all lets talk not about graph, but about tree, because  we need to determine a sub-tree. Second, yes, edges are undirected but in our case we should not care about that, because we always moving from parent to child (sub-tree, remember). So, [1,2] should be considered as 1 is parent and 2 is child with undirected edge.\\n\\n   0    1\\n /   \\\\ /\\n3    2\\nnot a tree"
                    },
                    {
                        "username": "anand92050",
                        "content": "If anyone is facing TLE problem then if you pass the string as reference then it will work finely.I spent a lot of time and finally get the result as \"Accepted\""
                    },
                    {
                        "username": "SKnew",
                        "content": "I was stuck with this. Thanks a lot man!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@leeten__1500](/leeten__1500) This is a well known reason. Passing by value means whole string is copied in each function call, but in pass by reference, only a reference is copied. The bigger question is WHY DO YOU NEED TO PASS STRING at all. Just copy it into a global string and keep accessing it!!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "thanks. But what\\'s the reason?"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Thanks a lot. Wasted a lot of time trying to optimize but couldn\\'t figure it out."
                    },
                    {
                        "username": "Ayush878",
                        "content": "Thank you brother saved a lot of time"
                    },
                    {
                        "username": "jhamadhav",
                        "content": "Saved me hours, thanks \\uD83D\\uDE4F"
                    },
                    {
                        "username": "KrutinSabnis",
                        "content": "thanks. spent 2 hrs on this"
                    },
                    {
                        "username": "fdshdfhjfds",
                        "content": "thanks i was stuck because of that tle"
                    },
                    {
                        "username": "anoyash",
                        "content": "All hail !!! saved my lot of time !!! , \nbut I still need to optimise my sol. currently beating 5%.  :("
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "bruh literally saved me !! i was stuck on this shit for last 1 hour"
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "thanks bhai,i was stuck for an hour due to that tle\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "This is a hard medium"
                    },
                    {
                        "username": "user7214PZ",
                        "content": "hard hard"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach\\n* Use DFS for Traversal\\n* Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n* Store count for each node label in the output array."
                    },
                    {
                        "username": "hcn1519",
                        "content": "Nice approach! At first, I just returned merged string during recursion and counted after DFS traversal. But it results TLE. So I changed it to return Map(Python Counter) and it passed."
                    },
                    {
                        "username": "xeniawann",
                        "content": "thank you! this gives me a starting point to work on lol"
                    },
                    {
                        "username": "Shounak_ds",
                        "content": "[[0,2],[0,3],[1,2]]"
                    },
                    {
                        "username": "wareag1e",
                        "content": "Similar to yesterday\\'s problem: 1443. \\nThis is indeed a good problem, and it\\'s a litter bit harder than 1443. \\nNot sure why there are so many downvotes. :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "it was a good way of building up on whatever you learned yesterday. this one is harder only when thinking about the 26 letter optimization. Other than that, it was easier than yesterday\\'s problem.  Plus, also reused the fact that you shouldn\\'t assume BT just coz of examples lol."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "disagree yesterday's problem we had to record time and prune on the basis of apples that subtree contains...not a tough problem but way more interesting...today's problem is just brute force... I don't get the downvotes tho, problem description is really clear"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Personally I like the problem, but I do have a problem with the problematic way the problem description is written. If you know what I mean."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Good problem telling people what \"trees\" in graph theory actually means."
                    },
                    {
                        "username": "shubham1992agg",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nroot node is supposed to be 0 but there is no connection with the node 1. Thus, it means there are 2 root nodes in this scenario."
                    },
                    {
                        "username": "vatsalm73",
                        "content": "[@sk03167](/sk03167) Thank you for the hint! Was able to solve it after seeing your comment. Appreciate the help :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "Maybe by now you already know this, but for others looking for a very small hint, think of this as a graph problem, rather than a tree problem"
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "[@Rawnblade](/Rawnblade) [1,2 ] is not about undirection, it  is about parent-child relationship"
                    },
                    {
                        "username": "Rawnblade",
                        "content": "The edges are undirected. Node 1 is a child of node 2."
                    },
                    {
                        "username": "real_code_monkey",
                        "content": "25\\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\n\"hcheiavadwjctaortvpsflssg\"\\n\\nI visualize this \"tree\" on the draft and realize that it is absoutly a directed graph without cycle. For example, larger number may be on the root of the \"tree\". This \"tree\" may contain multiple root.\\nI would say the description and the figure are quite misleading.\\nI hope I won\\'t meet this question in the interview.\\n\\n"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "This test case goes against the description of the problem and some of the other test cases. We are told not to follow a strict parent-child relationship, but in this test case, if we dont set 0 as the parent node initially, we get the wrong answer. Think this test case should be removed. "
                    },
                    {
                        "username": "calm27",
                        "content": "i stuck on the same test case. i don\\'t how how \\'h\\' could be 2, if here is only 1 \\'h\\' in the string. "
                    },
                    {
                        "username": "Satishsss",
                        "content": "Input:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nOutput:\\n[1,0,1,1]\\nExpected:\\n[1,1,2,1]\\n"
                    },
                    {
                        "username": "bhavinraichura28",
                        "content": " \\n\\n\\nif you read the question carefully then you observe that given the edges are undirected so in given edges [1,2] you can also write as [2,1]\\nso if you draw a tree then graph will look like this \\n\\n        0a\\n       /     \\\\\\n     2e      3d\\n    /\\n  1e\\n\\nso the answer is \\nnode :  freq\\n0a         1\\n1e         1\\n2e         2\\n3d         1\\n\\n"
                    },
                    {
                        "username": "abiahuja",
                        "content": "![image](https://assets.leetcode.com/users/images/4183d717-fc0a-404b-b379-f53872e58e7b_1595145225.5625112.png)\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Use $Windows + Shift + S$ to take better screenshot bro."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Smart way to make a screenshot :D "
                    }
                ]
            },
            {
                "id": 1753814,
                "content": [
                    {
                        "username": "kiwijuice56",
                        "content": "`[[0,2],[0,3],[1,2]]` is a valid test case because we are given an UNDIRECTED graph. The edge `[1,2]` does not necessarily mean that node `1` is the parent of `2`, but that there exists an edge between them. So, the tree constructed would look like this:\n\n```\n     0\n   /   \\\n  3     2 \n         \\\n          1\n```"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Well, it\\'s quite tricky, to be honest. When I see tree problem, I\\'m assume that I don\\'t need keep undirected connections. "
                    },
                    {
                        "username": "tedBian",
                        "content": "if problem doesn\\'t use the word \"sub-tree\" then this one could be very clear. It is possible people will consider index-0 is parent of index-1"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "[@alex-oreshkov](/alex-oreshkov) The graph vs sub-tree debate aside, this feels like a cheeky test case meant to unnecessarily make the problem harder. Its no way testing the actual logic behind the solution. Just forces you to incorporate some additional code to handle these edge cases. \\n\\nAlso, though the parent-child relationship is not explicitly mentioned, the presence of a root implies a parent-child relationship. There is one particular test case, \\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\nwhere the very first edge, we are forced to establish 0 as the parent simply because its the root. If we were to treat 0 as the child in this tree, you would get a different tree and the wrong answer. "
                    },
                    {
                        "username": "Saklor",
                        "content": "[@Prabhash123](/Prabhash123) \\n\\n\"node0 can be parent of node1 and vice versa\" only one of these statements is true for any edge, because we know that node 0 is the root. The node closer to the root will be the parent and the one further away the child.\\n[0,1] and [1,0] are the exact same edge because the graph is undirected, and both should return [2,1] in your example because 0 is the root node, and 1 is a leaf."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "[[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1].\\n "
                    },
                    {
                        "username": "happysings",
                        "content": "[@alex-oreshkov](/alex-oreshkov) \\n\\nedges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\\n\\nNowhere in the statement it says that ai is the parent and bi is the child.\\n\\nTheoretically - \\nAs long as the graph is undirected and has no cycles - you can choose any node as the root - its just traversal strategy to remember where the traversal began and not go back to that path - the ancestors.\\n\\nHere the problem sets the root to 0 node and hence you can confirm the paret/child relation only after traversing that edge from root."
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "No, it is not. First of all lets talk not about graph, but about tree, because  we need to determine a sub-tree. Second, yes, edges are undirected but in our case we should not care about that, because we always moving from parent to child (sub-tree, remember). So, [1,2] should be considered as 1 is parent and 2 is child with undirected edge.\\n\\n   0    1\\n /   \\\\ /\\n3    2\\nnot a tree"
                    },
                    {
                        "username": "anand92050",
                        "content": "If anyone is facing TLE problem then if you pass the string as reference then it will work finely.I spent a lot of time and finally get the result as \"Accepted\""
                    },
                    {
                        "username": "SKnew",
                        "content": "I was stuck with this. Thanks a lot man!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@leeten__1500](/leeten__1500) This is a well known reason. Passing by value means whole string is copied in each function call, but in pass by reference, only a reference is copied. The bigger question is WHY DO YOU NEED TO PASS STRING at all. Just copy it into a global string and keep accessing it!!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "thanks. But what\\'s the reason?"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Thanks a lot. Wasted a lot of time trying to optimize but couldn\\'t figure it out."
                    },
                    {
                        "username": "Ayush878",
                        "content": "Thank you brother saved a lot of time"
                    },
                    {
                        "username": "jhamadhav",
                        "content": "Saved me hours, thanks \\uD83D\\uDE4F"
                    },
                    {
                        "username": "KrutinSabnis",
                        "content": "thanks. spent 2 hrs on this"
                    },
                    {
                        "username": "fdshdfhjfds",
                        "content": "thanks i was stuck because of that tle"
                    },
                    {
                        "username": "anoyash",
                        "content": "All hail !!! saved my lot of time !!! , \nbut I still need to optimise my sol. currently beating 5%.  :("
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "bruh literally saved me !! i was stuck on this shit for last 1 hour"
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "thanks bhai,i was stuck for an hour due to that tle\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "This is a hard medium"
                    },
                    {
                        "username": "user7214PZ",
                        "content": "hard hard"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach\\n* Use DFS for Traversal\\n* Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n* Store count for each node label in the output array."
                    },
                    {
                        "username": "hcn1519",
                        "content": "Nice approach! At first, I just returned merged string during recursion and counted after DFS traversal. But it results TLE. So I changed it to return Map(Python Counter) and it passed."
                    },
                    {
                        "username": "xeniawann",
                        "content": "thank you! this gives me a starting point to work on lol"
                    },
                    {
                        "username": "Shounak_ds",
                        "content": "[[0,2],[0,3],[1,2]]"
                    },
                    {
                        "username": "wareag1e",
                        "content": "Similar to yesterday\\'s problem: 1443. \\nThis is indeed a good problem, and it\\'s a litter bit harder than 1443. \\nNot sure why there are so many downvotes. :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "it was a good way of building up on whatever you learned yesterday. this one is harder only when thinking about the 26 letter optimization. Other than that, it was easier than yesterday\\'s problem.  Plus, also reused the fact that you shouldn\\'t assume BT just coz of examples lol."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "disagree yesterday's problem we had to record time and prune on the basis of apples that subtree contains...not a tough problem but way more interesting...today's problem is just brute force... I don't get the downvotes tho, problem description is really clear"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Personally I like the problem, but I do have a problem with the problematic way the problem description is written. If you know what I mean."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Good problem telling people what \"trees\" in graph theory actually means."
                    },
                    {
                        "username": "shubham1992agg",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nroot node is supposed to be 0 but there is no connection with the node 1. Thus, it means there are 2 root nodes in this scenario."
                    },
                    {
                        "username": "vatsalm73",
                        "content": "[@sk03167](/sk03167) Thank you for the hint! Was able to solve it after seeing your comment. Appreciate the help :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "Maybe by now you already know this, but for others looking for a very small hint, think of this as a graph problem, rather than a tree problem"
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "[@Rawnblade](/Rawnblade) [1,2 ] is not about undirection, it  is about parent-child relationship"
                    },
                    {
                        "username": "Rawnblade",
                        "content": "The edges are undirected. Node 1 is a child of node 2."
                    },
                    {
                        "username": "real_code_monkey",
                        "content": "25\\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\n\"hcheiavadwjctaortvpsflssg\"\\n\\nI visualize this \"tree\" on the draft and realize that it is absoutly a directed graph without cycle. For example, larger number may be on the root of the \"tree\". This \"tree\" may contain multiple root.\\nI would say the description and the figure are quite misleading.\\nI hope I won\\'t meet this question in the interview.\\n\\n"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "This test case goes against the description of the problem and some of the other test cases. We are told not to follow a strict parent-child relationship, but in this test case, if we dont set 0 as the parent node initially, we get the wrong answer. Think this test case should be removed. "
                    },
                    {
                        "username": "calm27",
                        "content": "i stuck on the same test case. i don\\'t how how \\'h\\' could be 2, if here is only 1 \\'h\\' in the string. "
                    },
                    {
                        "username": "Satishsss",
                        "content": "Input:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nOutput:\\n[1,0,1,1]\\nExpected:\\n[1,1,2,1]\\n"
                    },
                    {
                        "username": "bhavinraichura28",
                        "content": " \\n\\n\\nif you read the question carefully then you observe that given the edges are undirected so in given edges [1,2] you can also write as [2,1]\\nso if you draw a tree then graph will look like this \\n\\n        0a\\n       /     \\\\\\n     2e      3d\\n    /\\n  1e\\n\\nso the answer is \\nnode :  freq\\n0a         1\\n1e         1\\n2e         2\\n3d         1\\n\\n"
                    },
                    {
                        "username": "abiahuja",
                        "content": "![image](https://assets.leetcode.com/users/images/4183d717-fc0a-404b-b379-f53872e58e7b_1595145225.5625112.png)\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Use $Windows + Shift + S$ to take better screenshot bro."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Smart way to make a screenshot :D "
                    }
                ]
            },
            {
                "id": 1753507,
                "content": [
                    {
                        "username": "kiwijuice56",
                        "content": "`[[0,2],[0,3],[1,2]]` is a valid test case because we are given an UNDIRECTED graph. The edge `[1,2]` does not necessarily mean that node `1` is the parent of `2`, but that there exists an edge between them. So, the tree constructed would look like this:\n\n```\n     0\n   /   \\\n  3     2 \n         \\\n          1\n```"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Well, it\\'s quite tricky, to be honest. When I see tree problem, I\\'m assume that I don\\'t need keep undirected connections. "
                    },
                    {
                        "username": "tedBian",
                        "content": "if problem doesn\\'t use the word \"sub-tree\" then this one could be very clear. It is possible people will consider index-0 is parent of index-1"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "[@alex-oreshkov](/alex-oreshkov) The graph vs sub-tree debate aside, this feels like a cheeky test case meant to unnecessarily make the problem harder. Its no way testing the actual logic behind the solution. Just forces you to incorporate some additional code to handle these edge cases. \\n\\nAlso, though the parent-child relationship is not explicitly mentioned, the presence of a root implies a parent-child relationship. There is one particular test case, \\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\nwhere the very first edge, we are forced to establish 0 as the parent simply because its the root. If we were to treat 0 as the child in this tree, you would get a different tree and the wrong answer. "
                    },
                    {
                        "username": "Saklor",
                        "content": "[@Prabhash123](/Prabhash123) \\n\\n\"node0 can be parent of node1 and vice versa\" only one of these statements is true for any edge, because we know that node 0 is the root. The node closer to the root will be the parent and the one further away the child.\\n[0,1] and [1,0] are the exact same edge because the graph is undirected, and both should return [2,1] in your example because 0 is the root node, and 1 is a leaf."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "[[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1].\\n "
                    },
                    {
                        "username": "happysings",
                        "content": "[@alex-oreshkov](/alex-oreshkov) \\n\\nedges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\\n\\nNowhere in the statement it says that ai is the parent and bi is the child.\\n\\nTheoretically - \\nAs long as the graph is undirected and has no cycles - you can choose any node as the root - its just traversal strategy to remember where the traversal began and not go back to that path - the ancestors.\\n\\nHere the problem sets the root to 0 node and hence you can confirm the paret/child relation only after traversing that edge from root."
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "No, it is not. First of all lets talk not about graph, but about tree, because  we need to determine a sub-tree. Second, yes, edges are undirected but in our case we should not care about that, because we always moving from parent to child (sub-tree, remember). So, [1,2] should be considered as 1 is parent and 2 is child with undirected edge.\\n\\n   0    1\\n /   \\\\ /\\n3    2\\nnot a tree"
                    },
                    {
                        "username": "anand92050",
                        "content": "If anyone is facing TLE problem then if you pass the string as reference then it will work finely.I spent a lot of time and finally get the result as \"Accepted\""
                    },
                    {
                        "username": "SKnew",
                        "content": "I was stuck with this. Thanks a lot man!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@leeten__1500](/leeten__1500) This is a well known reason. Passing by value means whole string is copied in each function call, but in pass by reference, only a reference is copied. The bigger question is WHY DO YOU NEED TO PASS STRING at all. Just copy it into a global string and keep accessing it!!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "thanks. But what\\'s the reason?"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Thanks a lot. Wasted a lot of time trying to optimize but couldn\\'t figure it out."
                    },
                    {
                        "username": "Ayush878",
                        "content": "Thank you brother saved a lot of time"
                    },
                    {
                        "username": "jhamadhav",
                        "content": "Saved me hours, thanks \\uD83D\\uDE4F"
                    },
                    {
                        "username": "KrutinSabnis",
                        "content": "thanks. spent 2 hrs on this"
                    },
                    {
                        "username": "fdshdfhjfds",
                        "content": "thanks i was stuck because of that tle"
                    },
                    {
                        "username": "anoyash",
                        "content": "All hail !!! saved my lot of time !!! , \nbut I still need to optimise my sol. currently beating 5%.  :("
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "bruh literally saved me !! i was stuck on this shit for last 1 hour"
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "thanks bhai,i was stuck for an hour due to that tle\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "This is a hard medium"
                    },
                    {
                        "username": "user7214PZ",
                        "content": "hard hard"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach\\n* Use DFS for Traversal\\n* Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n* Store count for each node label in the output array."
                    },
                    {
                        "username": "hcn1519",
                        "content": "Nice approach! At first, I just returned merged string during recursion and counted after DFS traversal. But it results TLE. So I changed it to return Map(Python Counter) and it passed."
                    },
                    {
                        "username": "xeniawann",
                        "content": "thank you! this gives me a starting point to work on lol"
                    },
                    {
                        "username": "Shounak_ds",
                        "content": "[[0,2],[0,3],[1,2]]"
                    },
                    {
                        "username": "wareag1e",
                        "content": "Similar to yesterday\\'s problem: 1443. \\nThis is indeed a good problem, and it\\'s a litter bit harder than 1443. \\nNot sure why there are so many downvotes. :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "it was a good way of building up on whatever you learned yesterday. this one is harder only when thinking about the 26 letter optimization. Other than that, it was easier than yesterday\\'s problem.  Plus, also reused the fact that you shouldn\\'t assume BT just coz of examples lol."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "disagree yesterday's problem we had to record time and prune on the basis of apples that subtree contains...not a tough problem but way more interesting...today's problem is just brute force... I don't get the downvotes tho, problem description is really clear"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Personally I like the problem, but I do have a problem with the problematic way the problem description is written. If you know what I mean."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Good problem telling people what \"trees\" in graph theory actually means."
                    },
                    {
                        "username": "shubham1992agg",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nroot node is supposed to be 0 but there is no connection with the node 1. Thus, it means there are 2 root nodes in this scenario."
                    },
                    {
                        "username": "vatsalm73",
                        "content": "[@sk03167](/sk03167) Thank you for the hint! Was able to solve it after seeing your comment. Appreciate the help :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "Maybe by now you already know this, but for others looking for a very small hint, think of this as a graph problem, rather than a tree problem"
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "[@Rawnblade](/Rawnblade) [1,2 ] is not about undirection, it  is about parent-child relationship"
                    },
                    {
                        "username": "Rawnblade",
                        "content": "The edges are undirected. Node 1 is a child of node 2."
                    },
                    {
                        "username": "real_code_monkey",
                        "content": "25\\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\n\"hcheiavadwjctaortvpsflssg\"\\n\\nI visualize this \"tree\" on the draft and realize that it is absoutly a directed graph without cycle. For example, larger number may be on the root of the \"tree\". This \"tree\" may contain multiple root.\\nI would say the description and the figure are quite misleading.\\nI hope I won\\'t meet this question in the interview.\\n\\n"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "This test case goes against the description of the problem and some of the other test cases. We are told not to follow a strict parent-child relationship, but in this test case, if we dont set 0 as the parent node initially, we get the wrong answer. Think this test case should be removed. "
                    },
                    {
                        "username": "calm27",
                        "content": "i stuck on the same test case. i don\\'t how how \\'h\\' could be 2, if here is only 1 \\'h\\' in the string. "
                    },
                    {
                        "username": "Satishsss",
                        "content": "Input:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nOutput:\\n[1,0,1,1]\\nExpected:\\n[1,1,2,1]\\n"
                    },
                    {
                        "username": "bhavinraichura28",
                        "content": " \\n\\n\\nif you read the question carefully then you observe that given the edges are undirected so in given edges [1,2] you can also write as [2,1]\\nso if you draw a tree then graph will look like this \\n\\n        0a\\n       /     \\\\\\n     2e      3d\\n    /\\n  1e\\n\\nso the answer is \\nnode :  freq\\n0a         1\\n1e         1\\n2e         2\\n3d         1\\n\\n"
                    },
                    {
                        "username": "abiahuja",
                        "content": "![image](https://assets.leetcode.com/users/images/4183d717-fc0a-404b-b379-f53872e58e7b_1595145225.5625112.png)\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Use $Windows + Shift + S$ to take better screenshot bro."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Smart way to make a screenshot :D "
                    }
                ]
            },
            {
                "id": 1753401,
                "content": [
                    {
                        "username": "kiwijuice56",
                        "content": "`[[0,2],[0,3],[1,2]]` is a valid test case because we are given an UNDIRECTED graph. The edge `[1,2]` does not necessarily mean that node `1` is the parent of `2`, but that there exists an edge between them. So, the tree constructed would look like this:\n\n```\n     0\n   /   \\\n  3     2 \n         \\\n          1\n```"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Well, it\\'s quite tricky, to be honest. When I see tree problem, I\\'m assume that I don\\'t need keep undirected connections. "
                    },
                    {
                        "username": "tedBian",
                        "content": "if problem doesn\\'t use the word \"sub-tree\" then this one could be very clear. It is possible people will consider index-0 is parent of index-1"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "[@alex-oreshkov](/alex-oreshkov) The graph vs sub-tree debate aside, this feels like a cheeky test case meant to unnecessarily make the problem harder. Its no way testing the actual logic behind the solution. Just forces you to incorporate some additional code to handle these edge cases. \\n\\nAlso, though the parent-child relationship is not explicitly mentioned, the presence of a root implies a parent-child relationship. There is one particular test case, \\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\nwhere the very first edge, we are forced to establish 0 as the parent simply because its the root. If we were to treat 0 as the child in this tree, you would get a different tree and the wrong answer. "
                    },
                    {
                        "username": "Saklor",
                        "content": "[@Prabhash123](/Prabhash123) \\n\\n\"node0 can be parent of node1 and vice versa\" only one of these statements is true for any edge, because we know that node 0 is the root. The node closer to the root will be the parent and the one further away the child.\\n[0,1] and [1,0] are the exact same edge because the graph is undirected, and both should return [2,1] in your example because 0 is the root node, and 1 is a leaf."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "[[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1].\\n "
                    },
                    {
                        "username": "happysings",
                        "content": "[@alex-oreshkov](/alex-oreshkov) \\n\\nedges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\\n\\nNowhere in the statement it says that ai is the parent and bi is the child.\\n\\nTheoretically - \\nAs long as the graph is undirected and has no cycles - you can choose any node as the root - its just traversal strategy to remember where the traversal began and not go back to that path - the ancestors.\\n\\nHere the problem sets the root to 0 node and hence you can confirm the paret/child relation only after traversing that edge from root."
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "No, it is not. First of all lets talk not about graph, but about tree, because  we need to determine a sub-tree. Second, yes, edges are undirected but in our case we should not care about that, because we always moving from parent to child (sub-tree, remember). So, [1,2] should be considered as 1 is parent and 2 is child with undirected edge.\\n\\n   0    1\\n /   \\\\ /\\n3    2\\nnot a tree"
                    },
                    {
                        "username": "anand92050",
                        "content": "If anyone is facing TLE problem then if you pass the string as reference then it will work finely.I spent a lot of time and finally get the result as \"Accepted\""
                    },
                    {
                        "username": "SKnew",
                        "content": "I was stuck with this. Thanks a lot man!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@leeten__1500](/leeten__1500) This is a well known reason. Passing by value means whole string is copied in each function call, but in pass by reference, only a reference is copied. The bigger question is WHY DO YOU NEED TO PASS STRING at all. Just copy it into a global string and keep accessing it!!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "thanks. But what\\'s the reason?"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Thanks a lot. Wasted a lot of time trying to optimize but couldn\\'t figure it out."
                    },
                    {
                        "username": "Ayush878",
                        "content": "Thank you brother saved a lot of time"
                    },
                    {
                        "username": "jhamadhav",
                        "content": "Saved me hours, thanks \\uD83D\\uDE4F"
                    },
                    {
                        "username": "KrutinSabnis",
                        "content": "thanks. spent 2 hrs on this"
                    },
                    {
                        "username": "fdshdfhjfds",
                        "content": "thanks i was stuck because of that tle"
                    },
                    {
                        "username": "anoyash",
                        "content": "All hail !!! saved my lot of time !!! , \nbut I still need to optimise my sol. currently beating 5%.  :("
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "bruh literally saved me !! i was stuck on this shit for last 1 hour"
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "thanks bhai,i was stuck for an hour due to that tle\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "This is a hard medium"
                    },
                    {
                        "username": "user7214PZ",
                        "content": "hard hard"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach\\n* Use DFS for Traversal\\n* Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n* Store count for each node label in the output array."
                    },
                    {
                        "username": "hcn1519",
                        "content": "Nice approach! At first, I just returned merged string during recursion and counted after DFS traversal. But it results TLE. So I changed it to return Map(Python Counter) and it passed."
                    },
                    {
                        "username": "xeniawann",
                        "content": "thank you! this gives me a starting point to work on lol"
                    },
                    {
                        "username": "Shounak_ds",
                        "content": "[[0,2],[0,3],[1,2]]"
                    },
                    {
                        "username": "wareag1e",
                        "content": "Similar to yesterday\\'s problem: 1443. \\nThis is indeed a good problem, and it\\'s a litter bit harder than 1443. \\nNot sure why there are so many downvotes. :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "it was a good way of building up on whatever you learned yesterday. this one is harder only when thinking about the 26 letter optimization. Other than that, it was easier than yesterday\\'s problem.  Plus, also reused the fact that you shouldn\\'t assume BT just coz of examples lol."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "disagree yesterday's problem we had to record time and prune on the basis of apples that subtree contains...not a tough problem but way more interesting...today's problem is just brute force... I don't get the downvotes tho, problem description is really clear"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Personally I like the problem, but I do have a problem with the problematic way the problem description is written. If you know what I mean."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Good problem telling people what \"trees\" in graph theory actually means."
                    },
                    {
                        "username": "shubham1992agg",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nroot node is supposed to be 0 but there is no connection with the node 1. Thus, it means there are 2 root nodes in this scenario."
                    },
                    {
                        "username": "vatsalm73",
                        "content": "[@sk03167](/sk03167) Thank you for the hint! Was able to solve it after seeing your comment. Appreciate the help :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "Maybe by now you already know this, but for others looking for a very small hint, think of this as a graph problem, rather than a tree problem"
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "[@Rawnblade](/Rawnblade) [1,2 ] is not about undirection, it  is about parent-child relationship"
                    },
                    {
                        "username": "Rawnblade",
                        "content": "The edges are undirected. Node 1 is a child of node 2."
                    },
                    {
                        "username": "real_code_monkey",
                        "content": "25\\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\n\"hcheiavadwjctaortvpsflssg\"\\n\\nI visualize this \"tree\" on the draft and realize that it is absoutly a directed graph without cycle. For example, larger number may be on the root of the \"tree\". This \"tree\" may contain multiple root.\\nI would say the description and the figure are quite misleading.\\nI hope I won\\'t meet this question in the interview.\\n\\n"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "This test case goes against the description of the problem and some of the other test cases. We are told not to follow a strict parent-child relationship, but in this test case, if we dont set 0 as the parent node initially, we get the wrong answer. Think this test case should be removed. "
                    },
                    {
                        "username": "calm27",
                        "content": "i stuck on the same test case. i don\\'t how how \\'h\\' could be 2, if here is only 1 \\'h\\' in the string. "
                    },
                    {
                        "username": "Satishsss",
                        "content": "Input:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nOutput:\\n[1,0,1,1]\\nExpected:\\n[1,1,2,1]\\n"
                    },
                    {
                        "username": "bhavinraichura28",
                        "content": " \\n\\n\\nif you read the question carefully then you observe that given the edges are undirected so in given edges [1,2] you can also write as [2,1]\\nso if you draw a tree then graph will look like this \\n\\n        0a\\n       /     \\\\\\n     2e      3d\\n    /\\n  1e\\n\\nso the answer is \\nnode :  freq\\n0a         1\\n1e         1\\n2e         2\\n3d         1\\n\\n"
                    },
                    {
                        "username": "abiahuja",
                        "content": "![image](https://assets.leetcode.com/users/images/4183d717-fc0a-404b-b379-f53872e58e7b_1595145225.5625112.png)\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Use $Windows + Shift + S$ to take better screenshot bro."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Smart way to make a screenshot :D "
                    }
                ]
            },
            {
                "id": 1564633,
                "content": [
                    {
                        "username": "kiwijuice56",
                        "content": "`[[0,2],[0,3],[1,2]]` is a valid test case because we are given an UNDIRECTED graph. The edge `[1,2]` does not necessarily mean that node `1` is the parent of `2`, but that there exists an edge between them. So, the tree constructed would look like this:\n\n```\n     0\n   /   \\\n  3     2 \n         \\\n          1\n```"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Well, it\\'s quite tricky, to be honest. When I see tree problem, I\\'m assume that I don\\'t need keep undirected connections. "
                    },
                    {
                        "username": "tedBian",
                        "content": "if problem doesn\\'t use the word \"sub-tree\" then this one could be very clear. It is possible people will consider index-0 is parent of index-1"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "[@alex-oreshkov](/alex-oreshkov) The graph vs sub-tree debate aside, this feels like a cheeky test case meant to unnecessarily make the problem harder. Its no way testing the actual logic behind the solution. Just forces you to incorporate some additional code to handle these edge cases. \\n\\nAlso, though the parent-child relationship is not explicitly mentioned, the presence of a root implies a parent-child relationship. There is one particular test case, \\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\nwhere the very first edge, we are forced to establish 0 as the parent simply because its the root. If we were to treat 0 as the child in this tree, you would get a different tree and the wrong answer. "
                    },
                    {
                        "username": "Saklor",
                        "content": "[@Prabhash123](/Prabhash123) \\n\\n\"node0 can be parent of node1 and vice versa\" only one of these statements is true for any edge, because we know that node 0 is the root. The node closer to the root will be the parent and the one further away the child.\\n[0,1] and [1,0] are the exact same edge because the graph is undirected, and both should return [2,1] in your example because 0 is the root node, and 1 is a leaf."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "[[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1].\\n "
                    },
                    {
                        "username": "happysings",
                        "content": "[@alex-oreshkov](/alex-oreshkov) \\n\\nedges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\\n\\nNowhere in the statement it says that ai is the parent and bi is the child.\\n\\nTheoretically - \\nAs long as the graph is undirected and has no cycles - you can choose any node as the root - its just traversal strategy to remember where the traversal began and not go back to that path - the ancestors.\\n\\nHere the problem sets the root to 0 node and hence you can confirm the paret/child relation only after traversing that edge from root."
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "No, it is not. First of all lets talk not about graph, but about tree, because  we need to determine a sub-tree. Second, yes, edges are undirected but in our case we should not care about that, because we always moving from parent to child (sub-tree, remember). So, [1,2] should be considered as 1 is parent and 2 is child with undirected edge.\\n\\n   0    1\\n /   \\\\ /\\n3    2\\nnot a tree"
                    },
                    {
                        "username": "anand92050",
                        "content": "If anyone is facing TLE problem then if you pass the string as reference then it will work finely.I spent a lot of time and finally get the result as \"Accepted\""
                    },
                    {
                        "username": "SKnew",
                        "content": "I was stuck with this. Thanks a lot man!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@leeten__1500](/leeten__1500) This is a well known reason. Passing by value means whole string is copied in each function call, but in pass by reference, only a reference is copied. The bigger question is WHY DO YOU NEED TO PASS STRING at all. Just copy it into a global string and keep accessing it!!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "thanks. But what\\'s the reason?"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Thanks a lot. Wasted a lot of time trying to optimize but couldn\\'t figure it out."
                    },
                    {
                        "username": "Ayush878",
                        "content": "Thank you brother saved a lot of time"
                    },
                    {
                        "username": "jhamadhav",
                        "content": "Saved me hours, thanks \\uD83D\\uDE4F"
                    },
                    {
                        "username": "KrutinSabnis",
                        "content": "thanks. spent 2 hrs on this"
                    },
                    {
                        "username": "fdshdfhjfds",
                        "content": "thanks i was stuck because of that tle"
                    },
                    {
                        "username": "anoyash",
                        "content": "All hail !!! saved my lot of time !!! , \nbut I still need to optimise my sol. currently beating 5%.  :("
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "bruh literally saved me !! i was stuck on this shit for last 1 hour"
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "thanks bhai,i was stuck for an hour due to that tle\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "This is a hard medium"
                    },
                    {
                        "username": "user7214PZ",
                        "content": "hard hard"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach\\n* Use DFS for Traversal\\n* Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n* Store count for each node label in the output array."
                    },
                    {
                        "username": "hcn1519",
                        "content": "Nice approach! At first, I just returned merged string during recursion and counted after DFS traversal. But it results TLE. So I changed it to return Map(Python Counter) and it passed."
                    },
                    {
                        "username": "xeniawann",
                        "content": "thank you! this gives me a starting point to work on lol"
                    },
                    {
                        "username": "Shounak_ds",
                        "content": "[[0,2],[0,3],[1,2]]"
                    },
                    {
                        "username": "wareag1e",
                        "content": "Similar to yesterday\\'s problem: 1443. \\nThis is indeed a good problem, and it\\'s a litter bit harder than 1443. \\nNot sure why there are so many downvotes. :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "it was a good way of building up on whatever you learned yesterday. this one is harder only when thinking about the 26 letter optimization. Other than that, it was easier than yesterday\\'s problem.  Plus, also reused the fact that you shouldn\\'t assume BT just coz of examples lol."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "disagree yesterday's problem we had to record time and prune on the basis of apples that subtree contains...not a tough problem but way more interesting...today's problem is just brute force... I don't get the downvotes tho, problem description is really clear"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Personally I like the problem, but I do have a problem with the problematic way the problem description is written. If you know what I mean."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Good problem telling people what \"trees\" in graph theory actually means."
                    },
                    {
                        "username": "shubham1992agg",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nroot node is supposed to be 0 but there is no connection with the node 1. Thus, it means there are 2 root nodes in this scenario."
                    },
                    {
                        "username": "vatsalm73",
                        "content": "[@sk03167](/sk03167) Thank you for the hint! Was able to solve it after seeing your comment. Appreciate the help :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "Maybe by now you already know this, but for others looking for a very small hint, think of this as a graph problem, rather than a tree problem"
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "[@Rawnblade](/Rawnblade) [1,2 ] is not about undirection, it  is about parent-child relationship"
                    },
                    {
                        "username": "Rawnblade",
                        "content": "The edges are undirected. Node 1 is a child of node 2."
                    },
                    {
                        "username": "real_code_monkey",
                        "content": "25\\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\n\"hcheiavadwjctaortvpsflssg\"\\n\\nI visualize this \"tree\" on the draft and realize that it is absoutly a directed graph without cycle. For example, larger number may be on the root of the \"tree\". This \"tree\" may contain multiple root.\\nI would say the description and the figure are quite misleading.\\nI hope I won\\'t meet this question in the interview.\\n\\n"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "This test case goes against the description of the problem and some of the other test cases. We are told not to follow a strict parent-child relationship, but in this test case, if we dont set 0 as the parent node initially, we get the wrong answer. Think this test case should be removed. "
                    },
                    {
                        "username": "calm27",
                        "content": "i stuck on the same test case. i don\\'t how how \\'h\\' could be 2, if here is only 1 \\'h\\' in the string. "
                    },
                    {
                        "username": "Satishsss",
                        "content": "Input:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nOutput:\\n[1,0,1,1]\\nExpected:\\n[1,1,2,1]\\n"
                    },
                    {
                        "username": "bhavinraichura28",
                        "content": " \\n\\n\\nif you read the question carefully then you observe that given the edges are undirected so in given edges [1,2] you can also write as [2,1]\\nso if you draw a tree then graph will look like this \\n\\n        0a\\n       /     \\\\\\n     2e      3d\\n    /\\n  1e\\n\\nso the answer is \\nnode :  freq\\n0a         1\\n1e         1\\n2e         2\\n3d         1\\n\\n"
                    },
                    {
                        "username": "abiahuja",
                        "content": "![image](https://assets.leetcode.com/users/images/4183d717-fc0a-404b-b379-f53872e58e7b_1595145225.5625112.png)\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Use $Windows + Shift + S$ to take better screenshot bro."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Smart way to make a screenshot :D "
                    }
                ]
            },
            {
                "id": 1753411,
                "content": [
                    {
                        "username": "kiwijuice56",
                        "content": "`[[0,2],[0,3],[1,2]]` is a valid test case because we are given an UNDIRECTED graph. The edge `[1,2]` does not necessarily mean that node `1` is the parent of `2`, but that there exists an edge between them. So, the tree constructed would look like this:\n\n```\n     0\n   /   \\\n  3     2 \n         \\\n          1\n```"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Well, it\\'s quite tricky, to be honest. When I see tree problem, I\\'m assume that I don\\'t need keep undirected connections. "
                    },
                    {
                        "username": "tedBian",
                        "content": "if problem doesn\\'t use the word \"sub-tree\" then this one could be very clear. It is possible people will consider index-0 is parent of index-1"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "[@alex-oreshkov](/alex-oreshkov) The graph vs sub-tree debate aside, this feels like a cheeky test case meant to unnecessarily make the problem harder. Its no way testing the actual logic behind the solution. Just forces you to incorporate some additional code to handle these edge cases. \\n\\nAlso, though the parent-child relationship is not explicitly mentioned, the presence of a root implies a parent-child relationship. There is one particular test case, \\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\nwhere the very first edge, we are forced to establish 0 as the parent simply because its the root. If we were to treat 0 as the child in this tree, you would get a different tree and the wrong answer. "
                    },
                    {
                        "username": "Saklor",
                        "content": "[@Prabhash123](/Prabhash123) \\n\\n\"node0 can be parent of node1 and vice versa\" only one of these statements is true for any edge, because we know that node 0 is the root. The node closer to the root will be the parent and the one further away the child.\\n[0,1] and [1,0] are the exact same edge because the graph is undirected, and both should return [2,1] in your example because 0 is the root node, and 1 is a leaf."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "[[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1].\\n "
                    },
                    {
                        "username": "happysings",
                        "content": "[@alex-oreshkov](/alex-oreshkov) \\n\\nedges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\\n\\nNowhere in the statement it says that ai is the parent and bi is the child.\\n\\nTheoretically - \\nAs long as the graph is undirected and has no cycles - you can choose any node as the root - its just traversal strategy to remember where the traversal began and not go back to that path - the ancestors.\\n\\nHere the problem sets the root to 0 node and hence you can confirm the paret/child relation only after traversing that edge from root."
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "No, it is not. First of all lets talk not about graph, but about tree, because  we need to determine a sub-tree. Second, yes, edges are undirected but in our case we should not care about that, because we always moving from parent to child (sub-tree, remember). So, [1,2] should be considered as 1 is parent and 2 is child with undirected edge.\\n\\n   0    1\\n /   \\\\ /\\n3    2\\nnot a tree"
                    },
                    {
                        "username": "anand92050",
                        "content": "If anyone is facing TLE problem then if you pass the string as reference then it will work finely.I spent a lot of time and finally get the result as \"Accepted\""
                    },
                    {
                        "username": "SKnew",
                        "content": "I was stuck with this. Thanks a lot man!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@leeten__1500](/leeten__1500) This is a well known reason. Passing by value means whole string is copied in each function call, but in pass by reference, only a reference is copied. The bigger question is WHY DO YOU NEED TO PASS STRING at all. Just copy it into a global string and keep accessing it!!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "thanks. But what\\'s the reason?"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Thanks a lot. Wasted a lot of time trying to optimize but couldn\\'t figure it out."
                    },
                    {
                        "username": "Ayush878",
                        "content": "Thank you brother saved a lot of time"
                    },
                    {
                        "username": "jhamadhav",
                        "content": "Saved me hours, thanks \\uD83D\\uDE4F"
                    },
                    {
                        "username": "KrutinSabnis",
                        "content": "thanks. spent 2 hrs on this"
                    },
                    {
                        "username": "fdshdfhjfds",
                        "content": "thanks i was stuck because of that tle"
                    },
                    {
                        "username": "anoyash",
                        "content": "All hail !!! saved my lot of time !!! , \nbut I still need to optimise my sol. currently beating 5%.  :("
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "bruh literally saved me !! i was stuck on this shit for last 1 hour"
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "thanks bhai,i was stuck for an hour due to that tle\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "This is a hard medium"
                    },
                    {
                        "username": "user7214PZ",
                        "content": "hard hard"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach\\n* Use DFS for Traversal\\n* Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n* Store count for each node label in the output array."
                    },
                    {
                        "username": "hcn1519",
                        "content": "Nice approach! At first, I just returned merged string during recursion and counted after DFS traversal. But it results TLE. So I changed it to return Map(Python Counter) and it passed."
                    },
                    {
                        "username": "xeniawann",
                        "content": "thank you! this gives me a starting point to work on lol"
                    },
                    {
                        "username": "Shounak_ds",
                        "content": "[[0,2],[0,3],[1,2]]"
                    },
                    {
                        "username": "wareag1e",
                        "content": "Similar to yesterday\\'s problem: 1443. \\nThis is indeed a good problem, and it\\'s a litter bit harder than 1443. \\nNot sure why there are so many downvotes. :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "it was a good way of building up on whatever you learned yesterday. this one is harder only when thinking about the 26 letter optimization. Other than that, it was easier than yesterday\\'s problem.  Plus, also reused the fact that you shouldn\\'t assume BT just coz of examples lol."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "disagree yesterday's problem we had to record time and prune on the basis of apples that subtree contains...not a tough problem but way more interesting...today's problem is just brute force... I don't get the downvotes tho, problem description is really clear"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Personally I like the problem, but I do have a problem with the problematic way the problem description is written. If you know what I mean."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Good problem telling people what \"trees\" in graph theory actually means."
                    },
                    {
                        "username": "shubham1992agg",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nroot node is supposed to be 0 but there is no connection with the node 1. Thus, it means there are 2 root nodes in this scenario."
                    },
                    {
                        "username": "vatsalm73",
                        "content": "[@sk03167](/sk03167) Thank you for the hint! Was able to solve it after seeing your comment. Appreciate the help :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "Maybe by now you already know this, but for others looking for a very small hint, think of this as a graph problem, rather than a tree problem"
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "[@Rawnblade](/Rawnblade) [1,2 ] is not about undirection, it  is about parent-child relationship"
                    },
                    {
                        "username": "Rawnblade",
                        "content": "The edges are undirected. Node 1 is a child of node 2."
                    },
                    {
                        "username": "real_code_monkey",
                        "content": "25\\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\n\"hcheiavadwjctaortvpsflssg\"\\n\\nI visualize this \"tree\" on the draft and realize that it is absoutly a directed graph without cycle. For example, larger number may be on the root of the \"tree\". This \"tree\" may contain multiple root.\\nI would say the description and the figure are quite misleading.\\nI hope I won\\'t meet this question in the interview.\\n\\n"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "This test case goes against the description of the problem and some of the other test cases. We are told not to follow a strict parent-child relationship, but in this test case, if we dont set 0 as the parent node initially, we get the wrong answer. Think this test case should be removed. "
                    },
                    {
                        "username": "calm27",
                        "content": "i stuck on the same test case. i don\\'t how how \\'h\\' could be 2, if here is only 1 \\'h\\' in the string. "
                    },
                    {
                        "username": "Satishsss",
                        "content": "Input:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nOutput:\\n[1,0,1,1]\\nExpected:\\n[1,1,2,1]\\n"
                    },
                    {
                        "username": "bhavinraichura28",
                        "content": " \\n\\n\\nif you read the question carefully then you observe that given the edges are undirected so in given edges [1,2] you can also write as [2,1]\\nso if you draw a tree then graph will look like this \\n\\n        0a\\n       /     \\\\\\n     2e      3d\\n    /\\n  1e\\n\\nso the answer is \\nnode :  freq\\n0a         1\\n1e         1\\n2e         2\\n3d         1\\n\\n"
                    },
                    {
                        "username": "abiahuja",
                        "content": "![image](https://assets.leetcode.com/users/images/4183d717-fc0a-404b-b379-f53872e58e7b_1595145225.5625112.png)\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Use $Windows + Shift + S$ to take better screenshot bro."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Smart way to make a screenshot :D "
                    }
                ]
            },
            {
                "id": 1566655,
                "content": [
                    {
                        "username": "kiwijuice56",
                        "content": "`[[0,2],[0,3],[1,2]]` is a valid test case because we are given an UNDIRECTED graph. The edge `[1,2]` does not necessarily mean that node `1` is the parent of `2`, but that there exists an edge between them. So, the tree constructed would look like this:\n\n```\n     0\n   /   \\\n  3     2 \n         \\\n          1\n```"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Well, it\\'s quite tricky, to be honest. When I see tree problem, I\\'m assume that I don\\'t need keep undirected connections. "
                    },
                    {
                        "username": "tedBian",
                        "content": "if problem doesn\\'t use the word \"sub-tree\" then this one could be very clear. It is possible people will consider index-0 is parent of index-1"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "[@alex-oreshkov](/alex-oreshkov) The graph vs sub-tree debate aside, this feels like a cheeky test case meant to unnecessarily make the problem harder. Its no way testing the actual logic behind the solution. Just forces you to incorporate some additional code to handle these edge cases. \\n\\nAlso, though the parent-child relationship is not explicitly mentioned, the presence of a root implies a parent-child relationship. There is one particular test case, \\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\nwhere the very first edge, we are forced to establish 0 as the parent simply because its the root. If we were to treat 0 as the child in this tree, you would get a different tree and the wrong answer. "
                    },
                    {
                        "username": "Saklor",
                        "content": "[@Prabhash123](/Prabhash123) \\n\\n\"node0 can be parent of node1 and vice versa\" only one of these statements is true for any edge, because we know that node 0 is the root. The node closer to the root will be the parent and the one further away the child.\\n[0,1] and [1,0] are the exact same edge because the graph is undirected, and both should return [2,1] in your example because 0 is the root node, and 1 is a leaf."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "[[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1].\\n "
                    },
                    {
                        "username": "happysings",
                        "content": "[@alex-oreshkov](/alex-oreshkov) \\n\\nedges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\\n\\nNowhere in the statement it says that ai is the parent and bi is the child.\\n\\nTheoretically - \\nAs long as the graph is undirected and has no cycles - you can choose any node as the root - its just traversal strategy to remember where the traversal began and not go back to that path - the ancestors.\\n\\nHere the problem sets the root to 0 node and hence you can confirm the paret/child relation only after traversing that edge from root."
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "No, it is not. First of all lets talk not about graph, but about tree, because  we need to determine a sub-tree. Second, yes, edges are undirected but in our case we should not care about that, because we always moving from parent to child (sub-tree, remember). So, [1,2] should be considered as 1 is parent and 2 is child with undirected edge.\\n\\n   0    1\\n /   \\\\ /\\n3    2\\nnot a tree"
                    },
                    {
                        "username": "anand92050",
                        "content": "If anyone is facing TLE problem then if you pass the string as reference then it will work finely.I spent a lot of time and finally get the result as \"Accepted\""
                    },
                    {
                        "username": "SKnew",
                        "content": "I was stuck with this. Thanks a lot man!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@leeten__1500](/leeten__1500) This is a well known reason. Passing by value means whole string is copied in each function call, but in pass by reference, only a reference is copied. The bigger question is WHY DO YOU NEED TO PASS STRING at all. Just copy it into a global string and keep accessing it!!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "thanks. But what\\'s the reason?"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Thanks a lot. Wasted a lot of time trying to optimize but couldn\\'t figure it out."
                    },
                    {
                        "username": "Ayush878",
                        "content": "Thank you brother saved a lot of time"
                    },
                    {
                        "username": "jhamadhav",
                        "content": "Saved me hours, thanks \\uD83D\\uDE4F"
                    },
                    {
                        "username": "KrutinSabnis",
                        "content": "thanks. spent 2 hrs on this"
                    },
                    {
                        "username": "fdshdfhjfds",
                        "content": "thanks i was stuck because of that tle"
                    },
                    {
                        "username": "anoyash",
                        "content": "All hail !!! saved my lot of time !!! , \nbut I still need to optimise my sol. currently beating 5%.  :("
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "bruh literally saved me !! i was stuck on this shit for last 1 hour"
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "thanks bhai,i was stuck for an hour due to that tle\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "This is a hard medium"
                    },
                    {
                        "username": "user7214PZ",
                        "content": "hard hard"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach\\n* Use DFS for Traversal\\n* Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n* Store count for each node label in the output array."
                    },
                    {
                        "username": "hcn1519",
                        "content": "Nice approach! At first, I just returned merged string during recursion and counted after DFS traversal. But it results TLE. So I changed it to return Map(Python Counter) and it passed."
                    },
                    {
                        "username": "xeniawann",
                        "content": "thank you! this gives me a starting point to work on lol"
                    },
                    {
                        "username": "Shounak_ds",
                        "content": "[[0,2],[0,3],[1,2]]"
                    },
                    {
                        "username": "wareag1e",
                        "content": "Similar to yesterday\\'s problem: 1443. \\nThis is indeed a good problem, and it\\'s a litter bit harder than 1443. \\nNot sure why there are so many downvotes. :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "it was a good way of building up on whatever you learned yesterday. this one is harder only when thinking about the 26 letter optimization. Other than that, it was easier than yesterday\\'s problem.  Plus, also reused the fact that you shouldn\\'t assume BT just coz of examples lol."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "disagree yesterday's problem we had to record time and prune on the basis of apples that subtree contains...not a tough problem but way more interesting...today's problem is just brute force... I don't get the downvotes tho, problem description is really clear"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Personally I like the problem, but I do have a problem with the problematic way the problem description is written. If you know what I mean."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Good problem telling people what \"trees\" in graph theory actually means."
                    },
                    {
                        "username": "shubham1992agg",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nroot node is supposed to be 0 but there is no connection with the node 1. Thus, it means there are 2 root nodes in this scenario."
                    },
                    {
                        "username": "vatsalm73",
                        "content": "[@sk03167](/sk03167) Thank you for the hint! Was able to solve it after seeing your comment. Appreciate the help :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "Maybe by now you already know this, but for others looking for a very small hint, think of this as a graph problem, rather than a tree problem"
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "[@Rawnblade](/Rawnblade) [1,2 ] is not about undirection, it  is about parent-child relationship"
                    },
                    {
                        "username": "Rawnblade",
                        "content": "The edges are undirected. Node 1 is a child of node 2."
                    },
                    {
                        "username": "real_code_monkey",
                        "content": "25\\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\n\"hcheiavadwjctaortvpsflssg\"\\n\\nI visualize this \"tree\" on the draft and realize that it is absoutly a directed graph without cycle. For example, larger number may be on the root of the \"tree\". This \"tree\" may contain multiple root.\\nI would say the description and the figure are quite misleading.\\nI hope I won\\'t meet this question in the interview.\\n\\n"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "This test case goes against the description of the problem and some of the other test cases. We are told not to follow a strict parent-child relationship, but in this test case, if we dont set 0 as the parent node initially, we get the wrong answer. Think this test case should be removed. "
                    },
                    {
                        "username": "calm27",
                        "content": "i stuck on the same test case. i don\\'t how how \\'h\\' could be 2, if here is only 1 \\'h\\' in the string. "
                    },
                    {
                        "username": "Satishsss",
                        "content": "Input:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nOutput:\\n[1,0,1,1]\\nExpected:\\n[1,1,2,1]\\n"
                    },
                    {
                        "username": "bhavinraichura28",
                        "content": " \\n\\n\\nif you read the question carefully then you observe that given the edges are undirected so in given edges [1,2] you can also write as [2,1]\\nso if you draw a tree then graph will look like this \\n\\n        0a\\n       /     \\\\\\n     2e      3d\\n    /\\n  1e\\n\\nso the answer is \\nnode :  freq\\n0a         1\\n1e         1\\n2e         2\\n3d         1\\n\\n"
                    },
                    {
                        "username": "abiahuja",
                        "content": "![image](https://assets.leetcode.com/users/images/4183d717-fc0a-404b-b379-f53872e58e7b_1595145225.5625112.png)\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Use $Windows + Shift + S$ to take better screenshot bro."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Smart way to make a screenshot :D "
                    }
                ]
            },
            {
                "id": 1575781,
                "content": [
                    {
                        "username": "kiwijuice56",
                        "content": "`[[0,2],[0,3],[1,2]]` is a valid test case because we are given an UNDIRECTED graph. The edge `[1,2]` does not necessarily mean that node `1` is the parent of `2`, but that there exists an edge between them. So, the tree constructed would look like this:\n\n```\n     0\n   /   \\\n  3     2 \n         \\\n          1\n```"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Well, it\\'s quite tricky, to be honest. When I see tree problem, I\\'m assume that I don\\'t need keep undirected connections. "
                    },
                    {
                        "username": "tedBian",
                        "content": "if problem doesn\\'t use the word \"sub-tree\" then this one could be very clear. It is possible people will consider index-0 is parent of index-1"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "[@alex-oreshkov](/alex-oreshkov) The graph vs sub-tree debate aside, this feels like a cheeky test case meant to unnecessarily make the problem harder. Its no way testing the actual logic behind the solution. Just forces you to incorporate some additional code to handle these edge cases. \\n\\nAlso, though the parent-child relationship is not explicitly mentioned, the presence of a root implies a parent-child relationship. There is one particular test case, \\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\nwhere the very first edge, we are forced to establish 0 as the parent simply because its the root. If we were to treat 0 as the child in this tree, you would get a different tree and the wrong answer. "
                    },
                    {
                        "username": "Saklor",
                        "content": "[@Prabhash123](/Prabhash123) \\n\\n\"node0 can be parent of node1 and vice versa\" only one of these statements is true for any edge, because we know that node 0 is the root. The node closer to the root will be the parent and the one further away the child.\\n[0,1] and [1,0] are the exact same edge because the graph is undirected, and both should return [2,1] in your example because 0 is the root node, and 1 is a leaf."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "[[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1].\\n "
                    },
                    {
                        "username": "happysings",
                        "content": "[@alex-oreshkov](/alex-oreshkov) \\n\\nedges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\\n\\nNowhere in the statement it says that ai is the parent and bi is the child.\\n\\nTheoretically - \\nAs long as the graph is undirected and has no cycles - you can choose any node as the root - its just traversal strategy to remember where the traversal began and not go back to that path - the ancestors.\\n\\nHere the problem sets the root to 0 node and hence you can confirm the paret/child relation only after traversing that edge from root."
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "No, it is not. First of all lets talk not about graph, but about tree, because  we need to determine a sub-tree. Second, yes, edges are undirected but in our case we should not care about that, because we always moving from parent to child (sub-tree, remember). So, [1,2] should be considered as 1 is parent and 2 is child with undirected edge.\\n\\n   0    1\\n /   \\\\ /\\n3    2\\nnot a tree"
                    },
                    {
                        "username": "anand92050",
                        "content": "If anyone is facing TLE problem then if you pass the string as reference then it will work finely.I spent a lot of time and finally get the result as \"Accepted\""
                    },
                    {
                        "username": "SKnew",
                        "content": "I was stuck with this. Thanks a lot man!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@leeten__1500](/leeten__1500) This is a well known reason. Passing by value means whole string is copied in each function call, but in pass by reference, only a reference is copied. The bigger question is WHY DO YOU NEED TO PASS STRING at all. Just copy it into a global string and keep accessing it!!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "thanks. But what\\'s the reason?"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Thanks a lot. Wasted a lot of time trying to optimize but couldn\\'t figure it out."
                    },
                    {
                        "username": "Ayush878",
                        "content": "Thank you brother saved a lot of time"
                    },
                    {
                        "username": "jhamadhav",
                        "content": "Saved me hours, thanks \\uD83D\\uDE4F"
                    },
                    {
                        "username": "KrutinSabnis",
                        "content": "thanks. spent 2 hrs on this"
                    },
                    {
                        "username": "fdshdfhjfds",
                        "content": "thanks i was stuck because of that tle"
                    },
                    {
                        "username": "anoyash",
                        "content": "All hail !!! saved my lot of time !!! , \nbut I still need to optimise my sol. currently beating 5%.  :("
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "bruh literally saved me !! i was stuck on this shit for last 1 hour"
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "thanks bhai,i was stuck for an hour due to that tle\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "This is a hard medium"
                    },
                    {
                        "username": "user7214PZ",
                        "content": "hard hard"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach\\n* Use DFS for Traversal\\n* Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n* Store count for each node label in the output array."
                    },
                    {
                        "username": "hcn1519",
                        "content": "Nice approach! At first, I just returned merged string during recursion and counted after DFS traversal. But it results TLE. So I changed it to return Map(Python Counter) and it passed."
                    },
                    {
                        "username": "xeniawann",
                        "content": "thank you! this gives me a starting point to work on lol"
                    },
                    {
                        "username": "Shounak_ds",
                        "content": "[[0,2],[0,3],[1,2]]"
                    },
                    {
                        "username": "wareag1e",
                        "content": "Similar to yesterday\\'s problem: 1443. \\nThis is indeed a good problem, and it\\'s a litter bit harder than 1443. \\nNot sure why there are so many downvotes. :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "it was a good way of building up on whatever you learned yesterday. this one is harder only when thinking about the 26 letter optimization. Other than that, it was easier than yesterday\\'s problem.  Plus, also reused the fact that you shouldn\\'t assume BT just coz of examples lol."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "disagree yesterday's problem we had to record time and prune on the basis of apples that subtree contains...not a tough problem but way more interesting...today's problem is just brute force... I don't get the downvotes tho, problem description is really clear"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Personally I like the problem, but I do have a problem with the problematic way the problem description is written. If you know what I mean."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Good problem telling people what \"trees\" in graph theory actually means."
                    },
                    {
                        "username": "shubham1992agg",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nroot node is supposed to be 0 but there is no connection with the node 1. Thus, it means there are 2 root nodes in this scenario."
                    },
                    {
                        "username": "vatsalm73",
                        "content": "[@sk03167](/sk03167) Thank you for the hint! Was able to solve it after seeing your comment. Appreciate the help :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "Maybe by now you already know this, but for others looking for a very small hint, think of this as a graph problem, rather than a tree problem"
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "[@Rawnblade](/Rawnblade) [1,2 ] is not about undirection, it  is about parent-child relationship"
                    },
                    {
                        "username": "Rawnblade",
                        "content": "The edges are undirected. Node 1 is a child of node 2."
                    },
                    {
                        "username": "real_code_monkey",
                        "content": "25\\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\n\"hcheiavadwjctaortvpsflssg\"\\n\\nI visualize this \"tree\" on the draft and realize that it is absoutly a directed graph without cycle. For example, larger number may be on the root of the \"tree\". This \"tree\" may contain multiple root.\\nI would say the description and the figure are quite misleading.\\nI hope I won\\'t meet this question in the interview.\\n\\n"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "This test case goes against the description of the problem and some of the other test cases. We are told not to follow a strict parent-child relationship, but in this test case, if we dont set 0 as the parent node initially, we get the wrong answer. Think this test case should be removed. "
                    },
                    {
                        "username": "calm27",
                        "content": "i stuck on the same test case. i don\\'t how how \\'h\\' could be 2, if here is only 1 \\'h\\' in the string. "
                    },
                    {
                        "username": "Satishsss",
                        "content": "Input:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nOutput:\\n[1,0,1,1]\\nExpected:\\n[1,1,2,1]\\n"
                    },
                    {
                        "username": "bhavinraichura28",
                        "content": " \\n\\n\\nif you read the question carefully then you observe that given the edges are undirected so in given edges [1,2] you can also write as [2,1]\\nso if you draw a tree then graph will look like this \\n\\n        0a\\n       /     \\\\\\n     2e      3d\\n    /\\n  1e\\n\\nso the answer is \\nnode :  freq\\n0a         1\\n1e         1\\n2e         2\\n3d         1\\n\\n"
                    },
                    {
                        "username": "abiahuja",
                        "content": "![image](https://assets.leetcode.com/users/images/4183d717-fc0a-404b-b379-f53872e58e7b_1595145225.5625112.png)\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Use $Windows + Shift + S$ to take better screenshot bro."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Smart way to make a screenshot :D "
                    }
                ]
            },
            {
                "id": 1568470,
                "content": [
                    {
                        "username": "kiwijuice56",
                        "content": "`[[0,2],[0,3],[1,2]]` is a valid test case because we are given an UNDIRECTED graph. The edge `[1,2]` does not necessarily mean that node `1` is the parent of `2`, but that there exists an edge between them. So, the tree constructed would look like this:\n\n```\n     0\n   /   \\\n  3     2 \n         \\\n          1\n```"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Well, it\\'s quite tricky, to be honest. When I see tree problem, I\\'m assume that I don\\'t need keep undirected connections. "
                    },
                    {
                        "username": "tedBian",
                        "content": "if problem doesn\\'t use the word \"sub-tree\" then this one could be very clear. It is possible people will consider index-0 is parent of index-1"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "[@alex-oreshkov](/alex-oreshkov) The graph vs sub-tree debate aside, this feels like a cheeky test case meant to unnecessarily make the problem harder. Its no way testing the actual logic behind the solution. Just forces you to incorporate some additional code to handle these edge cases. \\n\\nAlso, though the parent-child relationship is not explicitly mentioned, the presence of a root implies a parent-child relationship. There is one particular test case, \\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\nwhere the very first edge, we are forced to establish 0 as the parent simply because its the root. If we were to treat 0 as the child in this tree, you would get a different tree and the wrong answer. "
                    },
                    {
                        "username": "Saklor",
                        "content": "[@Prabhash123](/Prabhash123) \\n\\n\"node0 can be parent of node1 and vice versa\" only one of these statements is true for any edge, because we know that node 0 is the root. The node closer to the root will be the parent and the one further away the child.\\n[0,1] and [1,0] are the exact same edge because the graph is undirected, and both should return [2,1] in your example because 0 is the root node, and 1 is a leaf."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "[[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1].\\n "
                    },
                    {
                        "username": "happysings",
                        "content": "[@alex-oreshkov](/alex-oreshkov) \\n\\nedges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\\n\\nNowhere in the statement it says that ai is the parent and bi is the child.\\n\\nTheoretically - \\nAs long as the graph is undirected and has no cycles - you can choose any node as the root - its just traversal strategy to remember where the traversal began and not go back to that path - the ancestors.\\n\\nHere the problem sets the root to 0 node and hence you can confirm the paret/child relation only after traversing that edge from root."
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "No, it is not. First of all lets talk not about graph, but about tree, because  we need to determine a sub-tree. Second, yes, edges are undirected but in our case we should not care about that, because we always moving from parent to child (sub-tree, remember). So, [1,2] should be considered as 1 is parent and 2 is child with undirected edge.\\n\\n   0    1\\n /   \\\\ /\\n3    2\\nnot a tree"
                    },
                    {
                        "username": "anand92050",
                        "content": "If anyone is facing TLE problem then if you pass the string as reference then it will work finely.I spent a lot of time and finally get the result as \"Accepted\""
                    },
                    {
                        "username": "SKnew",
                        "content": "I was stuck with this. Thanks a lot man!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@leeten__1500](/leeten__1500) This is a well known reason. Passing by value means whole string is copied in each function call, but in pass by reference, only a reference is copied. The bigger question is WHY DO YOU NEED TO PASS STRING at all. Just copy it into a global string and keep accessing it!!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "thanks. But what\\'s the reason?"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Thanks a lot. Wasted a lot of time trying to optimize but couldn\\'t figure it out."
                    },
                    {
                        "username": "Ayush878",
                        "content": "Thank you brother saved a lot of time"
                    },
                    {
                        "username": "jhamadhav",
                        "content": "Saved me hours, thanks \\uD83D\\uDE4F"
                    },
                    {
                        "username": "KrutinSabnis",
                        "content": "thanks. spent 2 hrs on this"
                    },
                    {
                        "username": "fdshdfhjfds",
                        "content": "thanks i was stuck because of that tle"
                    },
                    {
                        "username": "anoyash",
                        "content": "All hail !!! saved my lot of time !!! , \nbut I still need to optimise my sol. currently beating 5%.  :("
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "bruh literally saved me !! i was stuck on this shit for last 1 hour"
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "thanks bhai,i was stuck for an hour due to that tle\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "This is a hard medium"
                    },
                    {
                        "username": "user7214PZ",
                        "content": "hard hard"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach\\n* Use DFS for Traversal\\n* Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n* Store count for each node label in the output array."
                    },
                    {
                        "username": "hcn1519",
                        "content": "Nice approach! At first, I just returned merged string during recursion and counted after DFS traversal. But it results TLE. So I changed it to return Map(Python Counter) and it passed."
                    },
                    {
                        "username": "xeniawann",
                        "content": "thank you! this gives me a starting point to work on lol"
                    },
                    {
                        "username": "Shounak_ds",
                        "content": "[[0,2],[0,3],[1,2]]"
                    },
                    {
                        "username": "wareag1e",
                        "content": "Similar to yesterday\\'s problem: 1443. \\nThis is indeed a good problem, and it\\'s a litter bit harder than 1443. \\nNot sure why there are so many downvotes. :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "it was a good way of building up on whatever you learned yesterday. this one is harder only when thinking about the 26 letter optimization. Other than that, it was easier than yesterday\\'s problem.  Plus, also reused the fact that you shouldn\\'t assume BT just coz of examples lol."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "disagree yesterday's problem we had to record time and prune on the basis of apples that subtree contains...not a tough problem but way more interesting...today's problem is just brute force... I don't get the downvotes tho, problem description is really clear"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Personally I like the problem, but I do have a problem with the problematic way the problem description is written. If you know what I mean."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Good problem telling people what \"trees\" in graph theory actually means."
                    },
                    {
                        "username": "shubham1992agg",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nroot node is supposed to be 0 but there is no connection with the node 1. Thus, it means there are 2 root nodes in this scenario."
                    },
                    {
                        "username": "vatsalm73",
                        "content": "[@sk03167](/sk03167) Thank you for the hint! Was able to solve it after seeing your comment. Appreciate the help :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "Maybe by now you already know this, but for others looking for a very small hint, think of this as a graph problem, rather than a tree problem"
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "[@Rawnblade](/Rawnblade) [1,2 ] is not about undirection, it  is about parent-child relationship"
                    },
                    {
                        "username": "Rawnblade",
                        "content": "The edges are undirected. Node 1 is a child of node 2."
                    },
                    {
                        "username": "real_code_monkey",
                        "content": "25\\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\n\"hcheiavadwjctaortvpsflssg\"\\n\\nI visualize this \"tree\" on the draft and realize that it is absoutly a directed graph without cycle. For example, larger number may be on the root of the \"tree\". This \"tree\" may contain multiple root.\\nI would say the description and the figure are quite misleading.\\nI hope I won\\'t meet this question in the interview.\\n\\n"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "This test case goes against the description of the problem and some of the other test cases. We are told not to follow a strict parent-child relationship, but in this test case, if we dont set 0 as the parent node initially, we get the wrong answer. Think this test case should be removed. "
                    },
                    {
                        "username": "calm27",
                        "content": "i stuck on the same test case. i don\\'t how how \\'h\\' could be 2, if here is only 1 \\'h\\' in the string. "
                    },
                    {
                        "username": "Satishsss",
                        "content": "Input:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nOutput:\\n[1,0,1,1]\\nExpected:\\n[1,1,2,1]\\n"
                    },
                    {
                        "username": "bhavinraichura28",
                        "content": " \\n\\n\\nif you read the question carefully then you observe that given the edges are undirected so in given edges [1,2] you can also write as [2,1]\\nso if you draw a tree then graph will look like this \\n\\n        0a\\n       /     \\\\\\n     2e      3d\\n    /\\n  1e\\n\\nso the answer is \\nnode :  freq\\n0a         1\\n1e         1\\n2e         2\\n3d         1\\n\\n"
                    },
                    {
                        "username": "abiahuja",
                        "content": "![image](https://assets.leetcode.com/users/images/4183d717-fc0a-404b-b379-f53872e58e7b_1595145225.5625112.png)\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Use $Windows + Shift + S$ to take better screenshot bro."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Smart way to make a screenshot :D "
                    }
                ]
            },
            {
                "id": 1574076,
                "content": [
                    {
                        "username": "kiwijuice56",
                        "content": "`[[0,2],[0,3],[1,2]]` is a valid test case because we are given an UNDIRECTED graph. The edge `[1,2]` does not necessarily mean that node `1` is the parent of `2`, but that there exists an edge between them. So, the tree constructed would look like this:\n\n```\n     0\n   /   \\\n  3     2 \n         \\\n          1\n```"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Well, it\\'s quite tricky, to be honest. When I see tree problem, I\\'m assume that I don\\'t need keep undirected connections. "
                    },
                    {
                        "username": "tedBian",
                        "content": "if problem doesn\\'t use the word \"sub-tree\" then this one could be very clear. It is possible people will consider index-0 is parent of index-1"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "[@alex-oreshkov](/alex-oreshkov) The graph vs sub-tree debate aside, this feels like a cheeky test case meant to unnecessarily make the problem harder. Its no way testing the actual logic behind the solution. Just forces you to incorporate some additional code to handle these edge cases. \\n\\nAlso, though the parent-child relationship is not explicitly mentioned, the presence of a root implies a parent-child relationship. There is one particular test case, \\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\nwhere the very first edge, we are forced to establish 0 as the parent simply because its the root. If we were to treat 0 as the child in this tree, you would get a different tree and the wrong answer. "
                    },
                    {
                        "username": "Saklor",
                        "content": "[@Prabhash123](/Prabhash123) \\n\\n\"node0 can be parent of node1 and vice versa\" only one of these statements is true for any edge, because we know that node 0 is the root. The node closer to the root will be the parent and the one further away the child.\\n[0,1] and [1,0] are the exact same edge because the graph is undirected, and both should return [2,1] in your example because 0 is the root node, and 1 is a leaf."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "[[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1].\\n "
                    },
                    {
                        "username": "happysings",
                        "content": "[@alex-oreshkov](/alex-oreshkov) \\n\\nedges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\\n\\nNowhere in the statement it says that ai is the parent and bi is the child.\\n\\nTheoretically - \\nAs long as the graph is undirected and has no cycles - you can choose any node as the root - its just traversal strategy to remember where the traversal began and not go back to that path - the ancestors.\\n\\nHere the problem sets the root to 0 node and hence you can confirm the paret/child relation only after traversing that edge from root."
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "No, it is not. First of all lets talk not about graph, but about tree, because  we need to determine a sub-tree. Second, yes, edges are undirected but in our case we should not care about that, because we always moving from parent to child (sub-tree, remember). So, [1,2] should be considered as 1 is parent and 2 is child with undirected edge.\\n\\n   0    1\\n /   \\\\ /\\n3    2\\nnot a tree"
                    },
                    {
                        "username": "anand92050",
                        "content": "If anyone is facing TLE problem then if you pass the string as reference then it will work finely.I spent a lot of time and finally get the result as \"Accepted\""
                    },
                    {
                        "username": "SKnew",
                        "content": "I was stuck with this. Thanks a lot man!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@leeten__1500](/leeten__1500) This is a well known reason. Passing by value means whole string is copied in each function call, but in pass by reference, only a reference is copied. The bigger question is WHY DO YOU NEED TO PASS STRING at all. Just copy it into a global string and keep accessing it!!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "thanks. But what\\'s the reason?"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Thanks a lot. Wasted a lot of time trying to optimize but couldn\\'t figure it out."
                    },
                    {
                        "username": "Ayush878",
                        "content": "Thank you brother saved a lot of time"
                    },
                    {
                        "username": "jhamadhav",
                        "content": "Saved me hours, thanks \\uD83D\\uDE4F"
                    },
                    {
                        "username": "KrutinSabnis",
                        "content": "thanks. spent 2 hrs on this"
                    },
                    {
                        "username": "fdshdfhjfds",
                        "content": "thanks i was stuck because of that tle"
                    },
                    {
                        "username": "anoyash",
                        "content": "All hail !!! saved my lot of time !!! , \nbut I still need to optimise my sol. currently beating 5%.  :("
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "bruh literally saved me !! i was stuck on this shit for last 1 hour"
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "thanks bhai,i was stuck for an hour due to that tle\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "This is a hard medium"
                    },
                    {
                        "username": "user7214PZ",
                        "content": "hard hard"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach\\n* Use DFS for Traversal\\n* Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n* Store count for each node label in the output array."
                    },
                    {
                        "username": "hcn1519",
                        "content": "Nice approach! At first, I just returned merged string during recursion and counted after DFS traversal. But it results TLE. So I changed it to return Map(Python Counter) and it passed."
                    },
                    {
                        "username": "xeniawann",
                        "content": "thank you! this gives me a starting point to work on lol"
                    },
                    {
                        "username": "Shounak_ds",
                        "content": "[[0,2],[0,3],[1,2]]"
                    },
                    {
                        "username": "wareag1e",
                        "content": "Similar to yesterday\\'s problem: 1443. \\nThis is indeed a good problem, and it\\'s a litter bit harder than 1443. \\nNot sure why there are so many downvotes. :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "it was a good way of building up on whatever you learned yesterday. this one is harder only when thinking about the 26 letter optimization. Other than that, it was easier than yesterday\\'s problem.  Plus, also reused the fact that you shouldn\\'t assume BT just coz of examples lol."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "disagree yesterday's problem we had to record time and prune on the basis of apples that subtree contains...not a tough problem but way more interesting...today's problem is just brute force... I don't get the downvotes tho, problem description is really clear"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Personally I like the problem, but I do have a problem with the problematic way the problem description is written. If you know what I mean."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Good problem telling people what \"trees\" in graph theory actually means."
                    },
                    {
                        "username": "shubham1992agg",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nroot node is supposed to be 0 but there is no connection with the node 1. Thus, it means there are 2 root nodes in this scenario."
                    },
                    {
                        "username": "vatsalm73",
                        "content": "[@sk03167](/sk03167) Thank you for the hint! Was able to solve it after seeing your comment. Appreciate the help :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "Maybe by now you already know this, but for others looking for a very small hint, think of this as a graph problem, rather than a tree problem"
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "[@Rawnblade](/Rawnblade) [1,2 ] is not about undirection, it  is about parent-child relationship"
                    },
                    {
                        "username": "Rawnblade",
                        "content": "The edges are undirected. Node 1 is a child of node 2."
                    },
                    {
                        "username": "real_code_monkey",
                        "content": "25\\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\n\"hcheiavadwjctaortvpsflssg\"\\n\\nI visualize this \"tree\" on the draft and realize that it is absoutly a directed graph without cycle. For example, larger number may be on the root of the \"tree\". This \"tree\" may contain multiple root.\\nI would say the description and the figure are quite misleading.\\nI hope I won\\'t meet this question in the interview.\\n\\n"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "This test case goes against the description of the problem and some of the other test cases. We are told not to follow a strict parent-child relationship, but in this test case, if we dont set 0 as the parent node initially, we get the wrong answer. Think this test case should be removed. "
                    },
                    {
                        "username": "calm27",
                        "content": "i stuck on the same test case. i don\\'t how how \\'h\\' could be 2, if here is only 1 \\'h\\' in the string. "
                    },
                    {
                        "username": "Satishsss",
                        "content": "Input:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nOutput:\\n[1,0,1,1]\\nExpected:\\n[1,1,2,1]\\n"
                    },
                    {
                        "username": "bhavinraichura28",
                        "content": " \\n\\n\\nif you read the question carefully then you observe that given the edges are undirected so in given edges [1,2] you can also write as [2,1]\\nso if you draw a tree then graph will look like this \\n\\n        0a\\n       /     \\\\\\n     2e      3d\\n    /\\n  1e\\n\\nso the answer is \\nnode :  freq\\n0a         1\\n1e         1\\n2e         2\\n3d         1\\n\\n"
                    },
                    {
                        "username": "abiahuja",
                        "content": "![image](https://assets.leetcode.com/users/images/4183d717-fc0a-404b-b379-f53872e58e7b_1595145225.5625112.png)\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Use $Windows + Shift + S$ to take better screenshot bro."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Smart way to make a screenshot :D "
                    }
                ]
            },
            {
                "id": 1753359,
                "content": [
                    {
                        "username": "kiwijuice56",
                        "content": "`[[0,2],[0,3],[1,2]]` is a valid test case because we are given an UNDIRECTED graph. The edge `[1,2]` does not necessarily mean that node `1` is the parent of `2`, but that there exists an edge between them. So, the tree constructed would look like this:\n\n```\n     0\n   /   \\\n  3     2 \n         \\\n          1\n```"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Well, it\\'s quite tricky, to be honest. When I see tree problem, I\\'m assume that I don\\'t need keep undirected connections. "
                    },
                    {
                        "username": "tedBian",
                        "content": "if problem doesn\\'t use the word \"sub-tree\" then this one could be very clear. It is possible people will consider index-0 is parent of index-1"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "[@alex-oreshkov](/alex-oreshkov) The graph vs sub-tree debate aside, this feels like a cheeky test case meant to unnecessarily make the problem harder. Its no way testing the actual logic behind the solution. Just forces you to incorporate some additional code to handle these edge cases. \\n\\nAlso, though the parent-child relationship is not explicitly mentioned, the presence of a root implies a parent-child relationship. There is one particular test case, \\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\nwhere the very first edge, we are forced to establish 0 as the parent simply because its the root. If we were to treat 0 as the child in this tree, you would get a different tree and the wrong answer. "
                    },
                    {
                        "username": "Saklor",
                        "content": "[@Prabhash123](/Prabhash123) \\n\\n\"node0 can be parent of node1 and vice versa\" only one of these statements is true for any edge, because we know that node 0 is the root. The node closer to the root will be the parent and the one further away the child.\\n[0,1] and [1,0] are the exact same edge because the graph is undirected, and both should return [2,1] in your example because 0 is the root node, and 1 is a leaf."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "[[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1].\\n "
                    },
                    {
                        "username": "happysings",
                        "content": "[@alex-oreshkov](/alex-oreshkov) \\n\\nedges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\\n\\nNowhere in the statement it says that ai is the parent and bi is the child.\\n\\nTheoretically - \\nAs long as the graph is undirected and has no cycles - you can choose any node as the root - its just traversal strategy to remember where the traversal began and not go back to that path - the ancestors.\\n\\nHere the problem sets the root to 0 node and hence you can confirm the paret/child relation only after traversing that edge from root."
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "No, it is not. First of all lets talk not about graph, but about tree, because  we need to determine a sub-tree. Second, yes, edges are undirected but in our case we should not care about that, because we always moving from parent to child (sub-tree, remember). So, [1,2] should be considered as 1 is parent and 2 is child with undirected edge.\\n\\n   0    1\\n /   \\\\ /\\n3    2\\nnot a tree"
                    },
                    {
                        "username": "anand92050",
                        "content": "If anyone is facing TLE problem then if you pass the string as reference then it will work finely.I spent a lot of time and finally get the result as \"Accepted\""
                    },
                    {
                        "username": "SKnew",
                        "content": "I was stuck with this. Thanks a lot man!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@leeten__1500](/leeten__1500) This is a well known reason. Passing by value means whole string is copied in each function call, but in pass by reference, only a reference is copied. The bigger question is WHY DO YOU NEED TO PASS STRING at all. Just copy it into a global string and keep accessing it!!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "thanks. But what\\'s the reason?"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Thanks a lot. Wasted a lot of time trying to optimize but couldn\\'t figure it out."
                    },
                    {
                        "username": "Ayush878",
                        "content": "Thank you brother saved a lot of time"
                    },
                    {
                        "username": "jhamadhav",
                        "content": "Saved me hours, thanks \\uD83D\\uDE4F"
                    },
                    {
                        "username": "KrutinSabnis",
                        "content": "thanks. spent 2 hrs on this"
                    },
                    {
                        "username": "fdshdfhjfds",
                        "content": "thanks i was stuck because of that tle"
                    },
                    {
                        "username": "anoyash",
                        "content": "All hail !!! saved my lot of time !!! , \nbut I still need to optimise my sol. currently beating 5%.  :("
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "bruh literally saved me !! i was stuck on this shit for last 1 hour"
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "thanks bhai,i was stuck for an hour due to that tle\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "This is a hard medium"
                    },
                    {
                        "username": "user7214PZ",
                        "content": "hard hard"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach\\n* Use DFS for Traversal\\n* Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n* Store count for each node label in the output array."
                    },
                    {
                        "username": "hcn1519",
                        "content": "Nice approach! At first, I just returned merged string during recursion and counted after DFS traversal. But it results TLE. So I changed it to return Map(Python Counter) and it passed."
                    },
                    {
                        "username": "xeniawann",
                        "content": "thank you! this gives me a starting point to work on lol"
                    },
                    {
                        "username": "Shounak_ds",
                        "content": "[[0,2],[0,3],[1,2]]"
                    },
                    {
                        "username": "wareag1e",
                        "content": "Similar to yesterday\\'s problem: 1443. \\nThis is indeed a good problem, and it\\'s a litter bit harder than 1443. \\nNot sure why there are so many downvotes. :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "it was a good way of building up on whatever you learned yesterday. this one is harder only when thinking about the 26 letter optimization. Other than that, it was easier than yesterday\\'s problem.  Plus, also reused the fact that you shouldn\\'t assume BT just coz of examples lol."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "disagree yesterday's problem we had to record time and prune on the basis of apples that subtree contains...not a tough problem but way more interesting...today's problem is just brute force... I don't get the downvotes tho, problem description is really clear"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Personally I like the problem, but I do have a problem with the problematic way the problem description is written. If you know what I mean."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Good problem telling people what \"trees\" in graph theory actually means."
                    },
                    {
                        "username": "shubham1992agg",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nroot node is supposed to be 0 but there is no connection with the node 1. Thus, it means there are 2 root nodes in this scenario."
                    },
                    {
                        "username": "vatsalm73",
                        "content": "[@sk03167](/sk03167) Thank you for the hint! Was able to solve it after seeing your comment. Appreciate the help :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "Maybe by now you already know this, but for others looking for a very small hint, think of this as a graph problem, rather than a tree problem"
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "[@Rawnblade](/Rawnblade) [1,2 ] is not about undirection, it  is about parent-child relationship"
                    },
                    {
                        "username": "Rawnblade",
                        "content": "The edges are undirected. Node 1 is a child of node 2."
                    },
                    {
                        "username": "real_code_monkey",
                        "content": "25\\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\n\"hcheiavadwjctaortvpsflssg\"\\n\\nI visualize this \"tree\" on the draft and realize that it is absoutly a directed graph without cycle. For example, larger number may be on the root of the \"tree\". This \"tree\" may contain multiple root.\\nI would say the description and the figure are quite misleading.\\nI hope I won\\'t meet this question in the interview.\\n\\n"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "This test case goes against the description of the problem and some of the other test cases. We are told not to follow a strict parent-child relationship, but in this test case, if we dont set 0 as the parent node initially, we get the wrong answer. Think this test case should be removed. "
                    },
                    {
                        "username": "calm27",
                        "content": "i stuck on the same test case. i don\\'t how how \\'h\\' could be 2, if here is only 1 \\'h\\' in the string. "
                    },
                    {
                        "username": "Satishsss",
                        "content": "Input:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nOutput:\\n[1,0,1,1]\\nExpected:\\n[1,1,2,1]\\n"
                    },
                    {
                        "username": "bhavinraichura28",
                        "content": " \\n\\n\\nif you read the question carefully then you observe that given the edges are undirected so in given edges [1,2] you can also write as [2,1]\\nso if you draw a tree then graph will look like this \\n\\n        0a\\n       /     \\\\\\n     2e      3d\\n    /\\n  1e\\n\\nso the answer is \\nnode :  freq\\n0a         1\\n1e         1\\n2e         2\\n3d         1\\n\\n"
                    },
                    {
                        "username": "abiahuja",
                        "content": "![image](https://assets.leetcode.com/users/images/4183d717-fc0a-404b-b379-f53872e58e7b_1595145225.5625112.png)\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Use $Windows + Shift + S$ to take better screenshot bro."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Smart way to make a screenshot :D "
                    }
                ]
            },
            {
                "id": 1753814,
                "content": [
                    {
                        "username": "kiwijuice56",
                        "content": "`[[0,2],[0,3],[1,2]]` is a valid test case because we are given an UNDIRECTED graph. The edge `[1,2]` does not necessarily mean that node `1` is the parent of `2`, but that there exists an edge between them. So, the tree constructed would look like this:\n\n```\n     0\n   /   \\\n  3     2 \n         \\\n          1\n```"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Well, it\\'s quite tricky, to be honest. When I see tree problem, I\\'m assume that I don\\'t need keep undirected connections. "
                    },
                    {
                        "username": "tedBian",
                        "content": "if problem doesn\\'t use the word \"sub-tree\" then this one could be very clear. It is possible people will consider index-0 is parent of index-1"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "[@alex-oreshkov](/alex-oreshkov) The graph vs sub-tree debate aside, this feels like a cheeky test case meant to unnecessarily make the problem harder. Its no way testing the actual logic behind the solution. Just forces you to incorporate some additional code to handle these edge cases. \\n\\nAlso, though the parent-child relationship is not explicitly mentioned, the presence of a root implies a parent-child relationship. There is one particular test case, \\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\nwhere the very first edge, we are forced to establish 0 as the parent simply because its the root. If we were to treat 0 as the child in this tree, you would get a different tree and the wrong answer. "
                    },
                    {
                        "username": "Saklor",
                        "content": "[@Prabhash123](/Prabhash123) \\n\\n\"node0 can be parent of node1 and vice versa\" only one of these statements is true for any edge, because we know that node 0 is the root. The node closer to the root will be the parent and the one further away the child.\\n[0,1] and [1,0] are the exact same edge because the graph is undirected, and both should return [2,1] in your example because 0 is the root node, and 1 is a leaf."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "[[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1].\\n "
                    },
                    {
                        "username": "happysings",
                        "content": "[@alex-oreshkov](/alex-oreshkov) \\n\\nedges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\\n\\nNowhere in the statement it says that ai is the parent and bi is the child.\\n\\nTheoretically - \\nAs long as the graph is undirected and has no cycles - you can choose any node as the root - its just traversal strategy to remember where the traversal began and not go back to that path - the ancestors.\\n\\nHere the problem sets the root to 0 node and hence you can confirm the paret/child relation only after traversing that edge from root."
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "No, it is not. First of all lets talk not about graph, but about tree, because  we need to determine a sub-tree. Second, yes, edges are undirected but in our case we should not care about that, because we always moving from parent to child (sub-tree, remember). So, [1,2] should be considered as 1 is parent and 2 is child with undirected edge.\\n\\n   0    1\\n /   \\\\ /\\n3    2\\nnot a tree"
                    },
                    {
                        "username": "anand92050",
                        "content": "If anyone is facing TLE problem then if you pass the string as reference then it will work finely.I spent a lot of time and finally get the result as \"Accepted\""
                    },
                    {
                        "username": "SKnew",
                        "content": "I was stuck with this. Thanks a lot man!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@leeten__1500](/leeten__1500) This is a well known reason. Passing by value means whole string is copied in each function call, but in pass by reference, only a reference is copied. The bigger question is WHY DO YOU NEED TO PASS STRING at all. Just copy it into a global string and keep accessing it!!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "thanks. But what\\'s the reason?"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Thanks a lot. Wasted a lot of time trying to optimize but couldn\\'t figure it out."
                    },
                    {
                        "username": "Ayush878",
                        "content": "Thank you brother saved a lot of time"
                    },
                    {
                        "username": "jhamadhav",
                        "content": "Saved me hours, thanks \\uD83D\\uDE4F"
                    },
                    {
                        "username": "KrutinSabnis",
                        "content": "thanks. spent 2 hrs on this"
                    },
                    {
                        "username": "fdshdfhjfds",
                        "content": "thanks i was stuck because of that tle"
                    },
                    {
                        "username": "anoyash",
                        "content": "All hail !!! saved my lot of time !!! , \nbut I still need to optimise my sol. currently beating 5%.  :("
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "bruh literally saved me !! i was stuck on this shit for last 1 hour"
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "thanks bhai,i was stuck for an hour due to that tle\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "This is a hard medium"
                    },
                    {
                        "username": "user7214PZ",
                        "content": "hard hard"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach\\n* Use DFS for Traversal\\n* Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n* Store count for each node label in the output array."
                    },
                    {
                        "username": "hcn1519",
                        "content": "Nice approach! At first, I just returned merged string during recursion and counted after DFS traversal. But it results TLE. So I changed it to return Map(Python Counter) and it passed."
                    },
                    {
                        "username": "xeniawann",
                        "content": "thank you! this gives me a starting point to work on lol"
                    },
                    {
                        "username": "Shounak_ds",
                        "content": "[[0,2],[0,3],[1,2]]"
                    },
                    {
                        "username": "wareag1e",
                        "content": "Similar to yesterday\\'s problem: 1443. \\nThis is indeed a good problem, and it\\'s a litter bit harder than 1443. \\nNot sure why there are so many downvotes. :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "it was a good way of building up on whatever you learned yesterday. this one is harder only when thinking about the 26 letter optimization. Other than that, it was easier than yesterday\\'s problem.  Plus, also reused the fact that you shouldn\\'t assume BT just coz of examples lol."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "disagree yesterday's problem we had to record time and prune on the basis of apples that subtree contains...not a tough problem but way more interesting...today's problem is just brute force... I don't get the downvotes tho, problem description is really clear"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Personally I like the problem, but I do have a problem with the problematic way the problem description is written. If you know what I mean."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Good problem telling people what \"trees\" in graph theory actually means."
                    },
                    {
                        "username": "shubham1992agg",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nroot node is supposed to be 0 but there is no connection with the node 1. Thus, it means there are 2 root nodes in this scenario."
                    },
                    {
                        "username": "vatsalm73",
                        "content": "[@sk03167](/sk03167) Thank you for the hint! Was able to solve it after seeing your comment. Appreciate the help :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "Maybe by now you already know this, but for others looking for a very small hint, think of this as a graph problem, rather than a tree problem"
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "[@Rawnblade](/Rawnblade) [1,2 ] is not about undirection, it  is about parent-child relationship"
                    },
                    {
                        "username": "Rawnblade",
                        "content": "The edges are undirected. Node 1 is a child of node 2."
                    },
                    {
                        "username": "real_code_monkey",
                        "content": "25\\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\n\"hcheiavadwjctaortvpsflssg\"\\n\\nI visualize this \"tree\" on the draft and realize that it is absoutly a directed graph without cycle. For example, larger number may be on the root of the \"tree\". This \"tree\" may contain multiple root.\\nI would say the description and the figure are quite misleading.\\nI hope I won\\'t meet this question in the interview.\\n\\n"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "This test case goes against the description of the problem and some of the other test cases. We are told not to follow a strict parent-child relationship, but in this test case, if we dont set 0 as the parent node initially, we get the wrong answer. Think this test case should be removed. "
                    },
                    {
                        "username": "calm27",
                        "content": "i stuck on the same test case. i don\\'t how how \\'h\\' could be 2, if here is only 1 \\'h\\' in the string. "
                    },
                    {
                        "username": "Satishsss",
                        "content": "Input:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nOutput:\\n[1,0,1,1]\\nExpected:\\n[1,1,2,1]\\n"
                    },
                    {
                        "username": "bhavinraichura28",
                        "content": " \\n\\n\\nif you read the question carefully then you observe that given the edges are undirected so in given edges [1,2] you can also write as [2,1]\\nso if you draw a tree then graph will look like this \\n\\n        0a\\n       /     \\\\\\n     2e      3d\\n    /\\n  1e\\n\\nso the answer is \\nnode :  freq\\n0a         1\\n1e         1\\n2e         2\\n3d         1\\n\\n"
                    },
                    {
                        "username": "abiahuja",
                        "content": "![image](https://assets.leetcode.com/users/images/4183d717-fc0a-404b-b379-f53872e58e7b_1595145225.5625112.png)\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Use $Windows + Shift + S$ to take better screenshot bro."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Smart way to make a screenshot :D "
                    }
                ]
            },
            {
                "id": 1753507,
                "content": [
                    {
                        "username": "kiwijuice56",
                        "content": "`[[0,2],[0,3],[1,2]]` is a valid test case because we are given an UNDIRECTED graph. The edge `[1,2]` does not necessarily mean that node `1` is the parent of `2`, but that there exists an edge between them. So, the tree constructed would look like this:\n\n```\n     0\n   /   \\\n  3     2 \n         \\\n          1\n```"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Well, it\\'s quite tricky, to be honest. When I see tree problem, I\\'m assume that I don\\'t need keep undirected connections. "
                    },
                    {
                        "username": "tedBian",
                        "content": "if problem doesn\\'t use the word \"sub-tree\" then this one could be very clear. It is possible people will consider index-0 is parent of index-1"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "[@alex-oreshkov](/alex-oreshkov) The graph vs sub-tree debate aside, this feels like a cheeky test case meant to unnecessarily make the problem harder. Its no way testing the actual logic behind the solution. Just forces you to incorporate some additional code to handle these edge cases. \\n\\nAlso, though the parent-child relationship is not explicitly mentioned, the presence of a root implies a parent-child relationship. There is one particular test case, \\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\nwhere the very first edge, we are forced to establish 0 as the parent simply because its the root. If we were to treat 0 as the child in this tree, you would get a different tree and the wrong answer. "
                    },
                    {
                        "username": "Saklor",
                        "content": "[@Prabhash123](/Prabhash123) \\n\\n\"node0 can be parent of node1 and vice versa\" only one of these statements is true for any edge, because we know that node 0 is the root. The node closer to the root will be the parent and the one further away the child.\\n[0,1] and [1,0] are the exact same edge because the graph is undirected, and both should return [2,1] in your example because 0 is the root node, and 1 is a leaf."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "[[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1].\\n "
                    },
                    {
                        "username": "happysings",
                        "content": "[@alex-oreshkov](/alex-oreshkov) \\n\\nedges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\\n\\nNowhere in the statement it says that ai is the parent and bi is the child.\\n\\nTheoretically - \\nAs long as the graph is undirected and has no cycles - you can choose any node as the root - its just traversal strategy to remember where the traversal began and not go back to that path - the ancestors.\\n\\nHere the problem sets the root to 0 node and hence you can confirm the paret/child relation only after traversing that edge from root."
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "No, it is not. First of all lets talk not about graph, but about tree, because  we need to determine a sub-tree. Second, yes, edges are undirected but in our case we should not care about that, because we always moving from parent to child (sub-tree, remember). So, [1,2] should be considered as 1 is parent and 2 is child with undirected edge.\\n\\n   0    1\\n /   \\\\ /\\n3    2\\nnot a tree"
                    },
                    {
                        "username": "anand92050",
                        "content": "If anyone is facing TLE problem then if you pass the string as reference then it will work finely.I spent a lot of time and finally get the result as \"Accepted\""
                    },
                    {
                        "username": "SKnew",
                        "content": "I was stuck with this. Thanks a lot man!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@leeten__1500](/leeten__1500) This is a well known reason. Passing by value means whole string is copied in each function call, but in pass by reference, only a reference is copied. The bigger question is WHY DO YOU NEED TO PASS STRING at all. Just copy it into a global string and keep accessing it!!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "thanks. But what\\'s the reason?"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Thanks a lot. Wasted a lot of time trying to optimize but couldn\\'t figure it out."
                    },
                    {
                        "username": "Ayush878",
                        "content": "Thank you brother saved a lot of time"
                    },
                    {
                        "username": "jhamadhav",
                        "content": "Saved me hours, thanks \\uD83D\\uDE4F"
                    },
                    {
                        "username": "KrutinSabnis",
                        "content": "thanks. spent 2 hrs on this"
                    },
                    {
                        "username": "fdshdfhjfds",
                        "content": "thanks i was stuck because of that tle"
                    },
                    {
                        "username": "anoyash",
                        "content": "All hail !!! saved my lot of time !!! , \nbut I still need to optimise my sol. currently beating 5%.  :("
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "bruh literally saved me !! i was stuck on this shit for last 1 hour"
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "thanks bhai,i was stuck for an hour due to that tle\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "This is a hard medium"
                    },
                    {
                        "username": "user7214PZ",
                        "content": "hard hard"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach\\n* Use DFS for Traversal\\n* Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n* Store count for each node label in the output array."
                    },
                    {
                        "username": "hcn1519",
                        "content": "Nice approach! At first, I just returned merged string during recursion and counted after DFS traversal. But it results TLE. So I changed it to return Map(Python Counter) and it passed."
                    },
                    {
                        "username": "xeniawann",
                        "content": "thank you! this gives me a starting point to work on lol"
                    },
                    {
                        "username": "Shounak_ds",
                        "content": "[[0,2],[0,3],[1,2]]"
                    },
                    {
                        "username": "wareag1e",
                        "content": "Similar to yesterday\\'s problem: 1443. \\nThis is indeed a good problem, and it\\'s a litter bit harder than 1443. \\nNot sure why there are so many downvotes. :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "it was a good way of building up on whatever you learned yesterday. this one is harder only when thinking about the 26 letter optimization. Other than that, it was easier than yesterday\\'s problem.  Plus, also reused the fact that you shouldn\\'t assume BT just coz of examples lol."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "disagree yesterday's problem we had to record time and prune on the basis of apples that subtree contains...not a tough problem but way more interesting...today's problem is just brute force... I don't get the downvotes tho, problem description is really clear"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Personally I like the problem, but I do have a problem with the problematic way the problem description is written. If you know what I mean."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Good problem telling people what \"trees\" in graph theory actually means."
                    },
                    {
                        "username": "shubham1992agg",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nroot node is supposed to be 0 but there is no connection with the node 1. Thus, it means there are 2 root nodes in this scenario."
                    },
                    {
                        "username": "vatsalm73",
                        "content": "[@sk03167](/sk03167) Thank you for the hint! Was able to solve it after seeing your comment. Appreciate the help :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "Maybe by now you already know this, but for others looking for a very small hint, think of this as a graph problem, rather than a tree problem"
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "[@Rawnblade](/Rawnblade) [1,2 ] is not about undirection, it  is about parent-child relationship"
                    },
                    {
                        "username": "Rawnblade",
                        "content": "The edges are undirected. Node 1 is a child of node 2."
                    },
                    {
                        "username": "real_code_monkey",
                        "content": "25\\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\n\"hcheiavadwjctaortvpsflssg\"\\n\\nI visualize this \"tree\" on the draft and realize that it is absoutly a directed graph without cycle. For example, larger number may be on the root of the \"tree\". This \"tree\" may contain multiple root.\\nI would say the description and the figure are quite misleading.\\nI hope I won\\'t meet this question in the interview.\\n\\n"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "This test case goes against the description of the problem and some of the other test cases. We are told not to follow a strict parent-child relationship, but in this test case, if we dont set 0 as the parent node initially, we get the wrong answer. Think this test case should be removed. "
                    },
                    {
                        "username": "calm27",
                        "content": "i stuck on the same test case. i don\\'t how how \\'h\\' could be 2, if here is only 1 \\'h\\' in the string. "
                    },
                    {
                        "username": "Satishsss",
                        "content": "Input:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nOutput:\\n[1,0,1,1]\\nExpected:\\n[1,1,2,1]\\n"
                    },
                    {
                        "username": "bhavinraichura28",
                        "content": " \\n\\n\\nif you read the question carefully then you observe that given the edges are undirected so in given edges [1,2] you can also write as [2,1]\\nso if you draw a tree then graph will look like this \\n\\n        0a\\n       /     \\\\\\n     2e      3d\\n    /\\n  1e\\n\\nso the answer is \\nnode :  freq\\n0a         1\\n1e         1\\n2e         2\\n3d         1\\n\\n"
                    },
                    {
                        "username": "abiahuja",
                        "content": "![image](https://assets.leetcode.com/users/images/4183d717-fc0a-404b-b379-f53872e58e7b_1595145225.5625112.png)\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Use $Windows + Shift + S$ to take better screenshot bro."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Smart way to make a screenshot :D "
                    }
                ]
            },
            {
                "id": 1753401,
                "content": [
                    {
                        "username": "kiwijuice56",
                        "content": "`[[0,2],[0,3],[1,2]]` is a valid test case because we are given an UNDIRECTED graph. The edge `[1,2]` does not necessarily mean that node `1` is the parent of `2`, but that there exists an edge between them. So, the tree constructed would look like this:\n\n```\n     0\n   /   \\\n  3     2 \n         \\\n          1\n```"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Well, it\\'s quite tricky, to be honest. When I see tree problem, I\\'m assume that I don\\'t need keep undirected connections. "
                    },
                    {
                        "username": "tedBian",
                        "content": "if problem doesn\\'t use the word \"sub-tree\" then this one could be very clear. It is possible people will consider index-0 is parent of index-1"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "[@alex-oreshkov](/alex-oreshkov) The graph vs sub-tree debate aside, this feels like a cheeky test case meant to unnecessarily make the problem harder. Its no way testing the actual logic behind the solution. Just forces you to incorporate some additional code to handle these edge cases. \\n\\nAlso, though the parent-child relationship is not explicitly mentioned, the presence of a root implies a parent-child relationship. There is one particular test case, \\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\nwhere the very first edge, we are forced to establish 0 as the parent simply because its the root. If we were to treat 0 as the child in this tree, you would get a different tree and the wrong answer. "
                    },
                    {
                        "username": "Saklor",
                        "content": "[@Prabhash123](/Prabhash123) \\n\\n\"node0 can be parent of node1 and vice versa\" only one of these statements is true for any edge, because we know that node 0 is the root. The node closer to the root will be the parent and the one further away the child.\\n[0,1] and [1,0] are the exact same edge because the graph is undirected, and both should return [2,1] in your example because 0 is the root node, and 1 is a leaf."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "[[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1].\\n "
                    },
                    {
                        "username": "happysings",
                        "content": "[@alex-oreshkov](/alex-oreshkov) \\n\\nedges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\\n\\nNowhere in the statement it says that ai is the parent and bi is the child.\\n\\nTheoretically - \\nAs long as the graph is undirected and has no cycles - you can choose any node as the root - its just traversal strategy to remember where the traversal began and not go back to that path - the ancestors.\\n\\nHere the problem sets the root to 0 node and hence you can confirm the paret/child relation only after traversing that edge from root."
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "No, it is not. First of all lets talk not about graph, but about tree, because  we need to determine a sub-tree. Second, yes, edges are undirected but in our case we should not care about that, because we always moving from parent to child (sub-tree, remember). So, [1,2] should be considered as 1 is parent and 2 is child with undirected edge.\\n\\n   0    1\\n /   \\\\ /\\n3    2\\nnot a tree"
                    },
                    {
                        "username": "anand92050",
                        "content": "If anyone is facing TLE problem then if you pass the string as reference then it will work finely.I spent a lot of time and finally get the result as \"Accepted\""
                    },
                    {
                        "username": "SKnew",
                        "content": "I was stuck with this. Thanks a lot man!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@leeten__1500](/leeten__1500) This is a well known reason. Passing by value means whole string is copied in each function call, but in pass by reference, only a reference is copied. The bigger question is WHY DO YOU NEED TO PASS STRING at all. Just copy it into a global string and keep accessing it!!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "thanks. But what\\'s the reason?"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Thanks a lot. Wasted a lot of time trying to optimize but couldn\\'t figure it out."
                    },
                    {
                        "username": "Ayush878",
                        "content": "Thank you brother saved a lot of time"
                    },
                    {
                        "username": "jhamadhav",
                        "content": "Saved me hours, thanks \\uD83D\\uDE4F"
                    },
                    {
                        "username": "KrutinSabnis",
                        "content": "thanks. spent 2 hrs on this"
                    },
                    {
                        "username": "fdshdfhjfds",
                        "content": "thanks i was stuck because of that tle"
                    },
                    {
                        "username": "anoyash",
                        "content": "All hail !!! saved my lot of time !!! , \nbut I still need to optimise my sol. currently beating 5%.  :("
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "bruh literally saved me !! i was stuck on this shit for last 1 hour"
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "thanks bhai,i was stuck for an hour due to that tle\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "This is a hard medium"
                    },
                    {
                        "username": "user7214PZ",
                        "content": "hard hard"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach\\n* Use DFS for Traversal\\n* Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n* Store count for each node label in the output array."
                    },
                    {
                        "username": "hcn1519",
                        "content": "Nice approach! At first, I just returned merged string during recursion and counted after DFS traversal. But it results TLE. So I changed it to return Map(Python Counter) and it passed."
                    },
                    {
                        "username": "xeniawann",
                        "content": "thank you! this gives me a starting point to work on lol"
                    },
                    {
                        "username": "Shounak_ds",
                        "content": "[[0,2],[0,3],[1,2]]"
                    },
                    {
                        "username": "wareag1e",
                        "content": "Similar to yesterday\\'s problem: 1443. \\nThis is indeed a good problem, and it\\'s a litter bit harder than 1443. \\nNot sure why there are so many downvotes. :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "it was a good way of building up on whatever you learned yesterday. this one is harder only when thinking about the 26 letter optimization. Other than that, it was easier than yesterday\\'s problem.  Plus, also reused the fact that you shouldn\\'t assume BT just coz of examples lol."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "disagree yesterday's problem we had to record time and prune on the basis of apples that subtree contains...not a tough problem but way more interesting...today's problem is just brute force... I don't get the downvotes tho, problem description is really clear"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Personally I like the problem, but I do have a problem with the problematic way the problem description is written. If you know what I mean."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Good problem telling people what \"trees\" in graph theory actually means."
                    },
                    {
                        "username": "shubham1992agg",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nroot node is supposed to be 0 but there is no connection with the node 1. Thus, it means there are 2 root nodes in this scenario."
                    },
                    {
                        "username": "vatsalm73",
                        "content": "[@sk03167](/sk03167) Thank you for the hint! Was able to solve it after seeing your comment. Appreciate the help :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "Maybe by now you already know this, but for others looking for a very small hint, think of this as a graph problem, rather than a tree problem"
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "[@Rawnblade](/Rawnblade) [1,2 ] is not about undirection, it  is about parent-child relationship"
                    },
                    {
                        "username": "Rawnblade",
                        "content": "The edges are undirected. Node 1 is a child of node 2."
                    },
                    {
                        "username": "real_code_monkey",
                        "content": "25\\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\n\"hcheiavadwjctaortvpsflssg\"\\n\\nI visualize this \"tree\" on the draft and realize that it is absoutly a directed graph without cycle. For example, larger number may be on the root of the \"tree\". This \"tree\" may contain multiple root.\\nI would say the description and the figure are quite misleading.\\nI hope I won\\'t meet this question in the interview.\\n\\n"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "This test case goes against the description of the problem and some of the other test cases. We are told not to follow a strict parent-child relationship, but in this test case, if we dont set 0 as the parent node initially, we get the wrong answer. Think this test case should be removed. "
                    },
                    {
                        "username": "calm27",
                        "content": "i stuck on the same test case. i don\\'t how how \\'h\\' could be 2, if here is only 1 \\'h\\' in the string. "
                    },
                    {
                        "username": "Satishsss",
                        "content": "Input:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nOutput:\\n[1,0,1,1]\\nExpected:\\n[1,1,2,1]\\n"
                    },
                    {
                        "username": "bhavinraichura28",
                        "content": " \\n\\n\\nif you read the question carefully then you observe that given the edges are undirected so in given edges [1,2] you can also write as [2,1]\\nso if you draw a tree then graph will look like this \\n\\n        0a\\n       /     \\\\\\n     2e      3d\\n    /\\n  1e\\n\\nso the answer is \\nnode :  freq\\n0a         1\\n1e         1\\n2e         2\\n3d         1\\n\\n"
                    },
                    {
                        "username": "abiahuja",
                        "content": "![image](https://assets.leetcode.com/users/images/4183d717-fc0a-404b-b379-f53872e58e7b_1595145225.5625112.png)\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Use $Windows + Shift + S$ to take better screenshot bro."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Smart way to make a screenshot :D "
                    }
                ]
            },
            {
                "id": 1564633,
                "content": [
                    {
                        "username": "kiwijuice56",
                        "content": "`[[0,2],[0,3],[1,2]]` is a valid test case because we are given an UNDIRECTED graph. The edge `[1,2]` does not necessarily mean that node `1` is the parent of `2`, but that there exists an edge between them. So, the tree constructed would look like this:\n\n```\n     0\n   /   \\\n  3     2 \n         \\\n          1\n```"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Well, it\\'s quite tricky, to be honest. When I see tree problem, I\\'m assume that I don\\'t need keep undirected connections. "
                    },
                    {
                        "username": "tedBian",
                        "content": "if problem doesn\\'t use the word \"sub-tree\" then this one could be very clear. It is possible people will consider index-0 is parent of index-1"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "[@alex-oreshkov](/alex-oreshkov) The graph vs sub-tree debate aside, this feels like a cheeky test case meant to unnecessarily make the problem harder. Its no way testing the actual logic behind the solution. Just forces you to incorporate some additional code to handle these edge cases. \\n\\nAlso, though the parent-child relationship is not explicitly mentioned, the presence of a root implies a parent-child relationship. There is one particular test case, \\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\nwhere the very first edge, we are forced to establish 0 as the parent simply because its the root. If we were to treat 0 as the child in this tree, you would get a different tree and the wrong answer. "
                    },
                    {
                        "username": "Saklor",
                        "content": "[@Prabhash123](/Prabhash123) \\n\\n\"node0 can be parent of node1 and vice versa\" only one of these statements is true for any edge, because we know that node 0 is the root. The node closer to the root will be the parent and the one further away the child.\\n[0,1] and [1,0] are the exact same edge because the graph is undirected, and both should return [2,1] in your example because 0 is the root node, and 1 is a leaf."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "[[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1].\\n "
                    },
                    {
                        "username": "happysings",
                        "content": "[@alex-oreshkov](/alex-oreshkov) \\n\\nedges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\\n\\nNowhere in the statement it says that ai is the parent and bi is the child.\\n\\nTheoretically - \\nAs long as the graph is undirected and has no cycles - you can choose any node as the root - its just traversal strategy to remember where the traversal began and not go back to that path - the ancestors.\\n\\nHere the problem sets the root to 0 node and hence you can confirm the paret/child relation only after traversing that edge from root."
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "No, it is not. First of all lets talk not about graph, but about tree, because  we need to determine a sub-tree. Second, yes, edges are undirected but in our case we should not care about that, because we always moving from parent to child (sub-tree, remember). So, [1,2] should be considered as 1 is parent and 2 is child with undirected edge.\\n\\n   0    1\\n /   \\\\ /\\n3    2\\nnot a tree"
                    },
                    {
                        "username": "anand92050",
                        "content": "If anyone is facing TLE problem then if you pass the string as reference then it will work finely.I spent a lot of time and finally get the result as \"Accepted\""
                    },
                    {
                        "username": "SKnew",
                        "content": "I was stuck with this. Thanks a lot man!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@leeten__1500](/leeten__1500) This is a well known reason. Passing by value means whole string is copied in each function call, but in pass by reference, only a reference is copied. The bigger question is WHY DO YOU NEED TO PASS STRING at all. Just copy it into a global string and keep accessing it!!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "thanks. But what\\'s the reason?"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Thanks a lot. Wasted a lot of time trying to optimize but couldn\\'t figure it out."
                    },
                    {
                        "username": "Ayush878",
                        "content": "Thank you brother saved a lot of time"
                    },
                    {
                        "username": "jhamadhav",
                        "content": "Saved me hours, thanks \\uD83D\\uDE4F"
                    },
                    {
                        "username": "KrutinSabnis",
                        "content": "thanks. spent 2 hrs on this"
                    },
                    {
                        "username": "fdshdfhjfds",
                        "content": "thanks i was stuck because of that tle"
                    },
                    {
                        "username": "anoyash",
                        "content": "All hail !!! saved my lot of time !!! , \nbut I still need to optimise my sol. currently beating 5%.  :("
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "bruh literally saved me !! i was stuck on this shit for last 1 hour"
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "thanks bhai,i was stuck for an hour due to that tle\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "This is a hard medium"
                    },
                    {
                        "username": "user7214PZ",
                        "content": "hard hard"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach\\n* Use DFS for Traversal\\n* Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n* Store count for each node label in the output array."
                    },
                    {
                        "username": "hcn1519",
                        "content": "Nice approach! At first, I just returned merged string during recursion and counted after DFS traversal. But it results TLE. So I changed it to return Map(Python Counter) and it passed."
                    },
                    {
                        "username": "xeniawann",
                        "content": "thank you! this gives me a starting point to work on lol"
                    },
                    {
                        "username": "Shounak_ds",
                        "content": "[[0,2],[0,3],[1,2]]"
                    },
                    {
                        "username": "wareag1e",
                        "content": "Similar to yesterday\\'s problem: 1443. \\nThis is indeed a good problem, and it\\'s a litter bit harder than 1443. \\nNot sure why there are so many downvotes. :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "it was a good way of building up on whatever you learned yesterday. this one is harder only when thinking about the 26 letter optimization. Other than that, it was easier than yesterday\\'s problem.  Plus, also reused the fact that you shouldn\\'t assume BT just coz of examples lol."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "disagree yesterday's problem we had to record time and prune on the basis of apples that subtree contains...not a tough problem but way more interesting...today's problem is just brute force... I don't get the downvotes tho, problem description is really clear"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Personally I like the problem, but I do have a problem with the problematic way the problem description is written. If you know what I mean."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Good problem telling people what \"trees\" in graph theory actually means."
                    },
                    {
                        "username": "shubham1992agg",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nroot node is supposed to be 0 but there is no connection with the node 1. Thus, it means there are 2 root nodes in this scenario."
                    },
                    {
                        "username": "vatsalm73",
                        "content": "[@sk03167](/sk03167) Thank you for the hint! Was able to solve it after seeing your comment. Appreciate the help :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "Maybe by now you already know this, but for others looking for a very small hint, think of this as a graph problem, rather than a tree problem"
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "[@Rawnblade](/Rawnblade) [1,2 ] is not about undirection, it  is about parent-child relationship"
                    },
                    {
                        "username": "Rawnblade",
                        "content": "The edges are undirected. Node 1 is a child of node 2."
                    },
                    {
                        "username": "real_code_monkey",
                        "content": "25\\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\n\"hcheiavadwjctaortvpsflssg\"\\n\\nI visualize this \"tree\" on the draft and realize that it is absoutly a directed graph without cycle. For example, larger number may be on the root of the \"tree\". This \"tree\" may contain multiple root.\\nI would say the description and the figure are quite misleading.\\nI hope I won\\'t meet this question in the interview.\\n\\n"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "This test case goes against the description of the problem and some of the other test cases. We are told not to follow a strict parent-child relationship, but in this test case, if we dont set 0 as the parent node initially, we get the wrong answer. Think this test case should be removed. "
                    },
                    {
                        "username": "calm27",
                        "content": "i stuck on the same test case. i don\\'t how how \\'h\\' could be 2, if here is only 1 \\'h\\' in the string. "
                    },
                    {
                        "username": "Satishsss",
                        "content": "Input:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nOutput:\\n[1,0,1,1]\\nExpected:\\n[1,1,2,1]\\n"
                    },
                    {
                        "username": "bhavinraichura28",
                        "content": " \\n\\n\\nif you read the question carefully then you observe that given the edges are undirected so in given edges [1,2] you can also write as [2,1]\\nso if you draw a tree then graph will look like this \\n\\n        0a\\n       /     \\\\\\n     2e      3d\\n    /\\n  1e\\n\\nso the answer is \\nnode :  freq\\n0a         1\\n1e         1\\n2e         2\\n3d         1\\n\\n"
                    },
                    {
                        "username": "abiahuja",
                        "content": "![image](https://assets.leetcode.com/users/images/4183d717-fc0a-404b-b379-f53872e58e7b_1595145225.5625112.png)\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Use $Windows + Shift + S$ to take better screenshot bro."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Smart way to make a screenshot :D "
                    }
                ]
            },
            {
                "id": 1753411,
                "content": [
                    {
                        "username": "kiwijuice56",
                        "content": "`[[0,2],[0,3],[1,2]]` is a valid test case because we are given an UNDIRECTED graph. The edge `[1,2]` does not necessarily mean that node `1` is the parent of `2`, but that there exists an edge between them. So, the tree constructed would look like this:\n\n```\n     0\n   /   \\\n  3     2 \n         \\\n          1\n```"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Well, it\\'s quite tricky, to be honest. When I see tree problem, I\\'m assume that I don\\'t need keep undirected connections. "
                    },
                    {
                        "username": "tedBian",
                        "content": "if problem doesn\\'t use the word \"sub-tree\" then this one could be very clear. It is possible people will consider index-0 is parent of index-1"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "[@alex-oreshkov](/alex-oreshkov) The graph vs sub-tree debate aside, this feels like a cheeky test case meant to unnecessarily make the problem harder. Its no way testing the actual logic behind the solution. Just forces you to incorporate some additional code to handle these edge cases. \\n\\nAlso, though the parent-child relationship is not explicitly mentioned, the presence of a root implies a parent-child relationship. There is one particular test case, \\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\nwhere the very first edge, we are forced to establish 0 as the parent simply because its the root. If we were to treat 0 as the child in this tree, you would get a different tree and the wrong answer. "
                    },
                    {
                        "username": "Saklor",
                        "content": "[@Prabhash123](/Prabhash123) \\n\\n\"node0 can be parent of node1 and vice versa\" only one of these statements is true for any edge, because we know that node 0 is the root. The node closer to the root will be the parent and the one further away the child.\\n[0,1] and [1,0] are the exact same edge because the graph is undirected, and both should return [2,1] in your example because 0 is the root node, and 1 is a leaf."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "[[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1].\\n "
                    },
                    {
                        "username": "happysings",
                        "content": "[@alex-oreshkov](/alex-oreshkov) \\n\\nedges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\\n\\nNowhere in the statement it says that ai is the parent and bi is the child.\\n\\nTheoretically - \\nAs long as the graph is undirected and has no cycles - you can choose any node as the root - its just traversal strategy to remember where the traversal began and not go back to that path - the ancestors.\\n\\nHere the problem sets the root to 0 node and hence you can confirm the paret/child relation only after traversing that edge from root."
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "No, it is not. First of all lets talk not about graph, but about tree, because  we need to determine a sub-tree. Second, yes, edges are undirected but in our case we should not care about that, because we always moving from parent to child (sub-tree, remember). So, [1,2] should be considered as 1 is parent and 2 is child with undirected edge.\\n\\n   0    1\\n /   \\\\ /\\n3    2\\nnot a tree"
                    },
                    {
                        "username": "anand92050",
                        "content": "If anyone is facing TLE problem then if you pass the string as reference then it will work finely.I spent a lot of time and finally get the result as \"Accepted\""
                    },
                    {
                        "username": "SKnew",
                        "content": "I was stuck with this. Thanks a lot man!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@leeten__1500](/leeten__1500) This is a well known reason. Passing by value means whole string is copied in each function call, but in pass by reference, only a reference is copied. The bigger question is WHY DO YOU NEED TO PASS STRING at all. Just copy it into a global string and keep accessing it!!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "thanks. But what\\'s the reason?"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Thanks a lot. Wasted a lot of time trying to optimize but couldn\\'t figure it out."
                    },
                    {
                        "username": "Ayush878",
                        "content": "Thank you brother saved a lot of time"
                    },
                    {
                        "username": "jhamadhav",
                        "content": "Saved me hours, thanks \\uD83D\\uDE4F"
                    },
                    {
                        "username": "KrutinSabnis",
                        "content": "thanks. spent 2 hrs on this"
                    },
                    {
                        "username": "fdshdfhjfds",
                        "content": "thanks i was stuck because of that tle"
                    },
                    {
                        "username": "anoyash",
                        "content": "All hail !!! saved my lot of time !!! , \nbut I still need to optimise my sol. currently beating 5%.  :("
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "bruh literally saved me !! i was stuck on this shit for last 1 hour"
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "thanks bhai,i was stuck for an hour due to that tle\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "This is a hard medium"
                    },
                    {
                        "username": "user7214PZ",
                        "content": "hard hard"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach\\n* Use DFS for Traversal\\n* Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n* Store count for each node label in the output array."
                    },
                    {
                        "username": "hcn1519",
                        "content": "Nice approach! At first, I just returned merged string during recursion and counted after DFS traversal. But it results TLE. So I changed it to return Map(Python Counter) and it passed."
                    },
                    {
                        "username": "xeniawann",
                        "content": "thank you! this gives me a starting point to work on lol"
                    },
                    {
                        "username": "Shounak_ds",
                        "content": "[[0,2],[0,3],[1,2]]"
                    },
                    {
                        "username": "wareag1e",
                        "content": "Similar to yesterday\\'s problem: 1443. \\nThis is indeed a good problem, and it\\'s a litter bit harder than 1443. \\nNot sure why there are so many downvotes. :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "it was a good way of building up on whatever you learned yesterday. this one is harder only when thinking about the 26 letter optimization. Other than that, it was easier than yesterday\\'s problem.  Plus, also reused the fact that you shouldn\\'t assume BT just coz of examples lol."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "disagree yesterday's problem we had to record time and prune on the basis of apples that subtree contains...not a tough problem but way more interesting...today's problem is just brute force... I don't get the downvotes tho, problem description is really clear"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Personally I like the problem, but I do have a problem with the problematic way the problem description is written. If you know what I mean."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Good problem telling people what \"trees\" in graph theory actually means."
                    },
                    {
                        "username": "shubham1992agg",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nroot node is supposed to be 0 but there is no connection with the node 1. Thus, it means there are 2 root nodes in this scenario."
                    },
                    {
                        "username": "vatsalm73",
                        "content": "[@sk03167](/sk03167) Thank you for the hint! Was able to solve it after seeing your comment. Appreciate the help :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "Maybe by now you already know this, but for others looking for a very small hint, think of this as a graph problem, rather than a tree problem"
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "[@Rawnblade](/Rawnblade) [1,2 ] is not about undirection, it  is about parent-child relationship"
                    },
                    {
                        "username": "Rawnblade",
                        "content": "The edges are undirected. Node 1 is a child of node 2."
                    },
                    {
                        "username": "real_code_monkey",
                        "content": "25\\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\n\"hcheiavadwjctaortvpsflssg\"\\n\\nI visualize this \"tree\" on the draft and realize that it is absoutly a directed graph without cycle. For example, larger number may be on the root of the \"tree\". This \"tree\" may contain multiple root.\\nI would say the description and the figure are quite misleading.\\nI hope I won\\'t meet this question in the interview.\\n\\n"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "This test case goes against the description of the problem and some of the other test cases. We are told not to follow a strict parent-child relationship, but in this test case, if we dont set 0 as the parent node initially, we get the wrong answer. Think this test case should be removed. "
                    },
                    {
                        "username": "calm27",
                        "content": "i stuck on the same test case. i don\\'t how how \\'h\\' could be 2, if here is only 1 \\'h\\' in the string. "
                    },
                    {
                        "username": "Satishsss",
                        "content": "Input:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nOutput:\\n[1,0,1,1]\\nExpected:\\n[1,1,2,1]\\n"
                    },
                    {
                        "username": "bhavinraichura28",
                        "content": " \\n\\n\\nif you read the question carefully then you observe that given the edges are undirected so in given edges [1,2] you can also write as [2,1]\\nso if you draw a tree then graph will look like this \\n\\n        0a\\n       /     \\\\\\n     2e      3d\\n    /\\n  1e\\n\\nso the answer is \\nnode :  freq\\n0a         1\\n1e         1\\n2e         2\\n3d         1\\n\\n"
                    },
                    {
                        "username": "abiahuja",
                        "content": "![image](https://assets.leetcode.com/users/images/4183d717-fc0a-404b-b379-f53872e58e7b_1595145225.5625112.png)\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Use $Windows + Shift + S$ to take better screenshot bro."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Smart way to make a screenshot :D "
                    }
                ]
            },
            {
                "id": 1566655,
                "content": [
                    {
                        "username": "kiwijuice56",
                        "content": "`[[0,2],[0,3],[1,2]]` is a valid test case because we are given an UNDIRECTED graph. The edge `[1,2]` does not necessarily mean that node `1` is the parent of `2`, but that there exists an edge between them. So, the tree constructed would look like this:\n\n```\n     0\n   /   \\\n  3     2 \n         \\\n          1\n```"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Well, it\\'s quite tricky, to be honest. When I see tree problem, I\\'m assume that I don\\'t need keep undirected connections. "
                    },
                    {
                        "username": "tedBian",
                        "content": "if problem doesn\\'t use the word \"sub-tree\" then this one could be very clear. It is possible people will consider index-0 is parent of index-1"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "[@alex-oreshkov](/alex-oreshkov) The graph vs sub-tree debate aside, this feels like a cheeky test case meant to unnecessarily make the problem harder. Its no way testing the actual logic behind the solution. Just forces you to incorporate some additional code to handle these edge cases. \\n\\nAlso, though the parent-child relationship is not explicitly mentioned, the presence of a root implies a parent-child relationship. There is one particular test case, \\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\nwhere the very first edge, we are forced to establish 0 as the parent simply because its the root. If we were to treat 0 as the child in this tree, you would get a different tree and the wrong answer. "
                    },
                    {
                        "username": "Saklor",
                        "content": "[@Prabhash123](/Prabhash123) \\n\\n\"node0 can be parent of node1 and vice versa\" only one of these statements is true for any edge, because we know that node 0 is the root. The node closer to the root will be the parent and the one further away the child.\\n[0,1] and [1,0] are the exact same edge because the graph is undirected, and both should return [2,1] in your example because 0 is the root node, and 1 is a leaf."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "[[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1].\\n "
                    },
                    {
                        "username": "happysings",
                        "content": "[@alex-oreshkov](/alex-oreshkov) \\n\\nedges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\\n\\nNowhere in the statement it says that ai is the parent and bi is the child.\\n\\nTheoretically - \\nAs long as the graph is undirected and has no cycles - you can choose any node as the root - its just traversal strategy to remember where the traversal began and not go back to that path - the ancestors.\\n\\nHere the problem sets the root to 0 node and hence you can confirm the paret/child relation only after traversing that edge from root."
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "No, it is not. First of all lets talk not about graph, but about tree, because  we need to determine a sub-tree. Second, yes, edges are undirected but in our case we should not care about that, because we always moving from parent to child (sub-tree, remember). So, [1,2] should be considered as 1 is parent and 2 is child with undirected edge.\\n\\n   0    1\\n /   \\\\ /\\n3    2\\nnot a tree"
                    },
                    {
                        "username": "anand92050",
                        "content": "If anyone is facing TLE problem then if you pass the string as reference then it will work finely.I spent a lot of time and finally get the result as \"Accepted\""
                    },
                    {
                        "username": "SKnew",
                        "content": "I was stuck with this. Thanks a lot man!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@leeten__1500](/leeten__1500) This is a well known reason. Passing by value means whole string is copied in each function call, but in pass by reference, only a reference is copied. The bigger question is WHY DO YOU NEED TO PASS STRING at all. Just copy it into a global string and keep accessing it!!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "thanks. But what\\'s the reason?"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Thanks a lot. Wasted a lot of time trying to optimize but couldn\\'t figure it out."
                    },
                    {
                        "username": "Ayush878",
                        "content": "Thank you brother saved a lot of time"
                    },
                    {
                        "username": "jhamadhav",
                        "content": "Saved me hours, thanks \\uD83D\\uDE4F"
                    },
                    {
                        "username": "KrutinSabnis",
                        "content": "thanks. spent 2 hrs on this"
                    },
                    {
                        "username": "fdshdfhjfds",
                        "content": "thanks i was stuck because of that tle"
                    },
                    {
                        "username": "anoyash",
                        "content": "All hail !!! saved my lot of time !!! , \nbut I still need to optimise my sol. currently beating 5%.  :("
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "bruh literally saved me !! i was stuck on this shit for last 1 hour"
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "thanks bhai,i was stuck for an hour due to that tle\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "This is a hard medium"
                    },
                    {
                        "username": "user7214PZ",
                        "content": "hard hard"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach\\n* Use DFS for Traversal\\n* Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n* Store count for each node label in the output array."
                    },
                    {
                        "username": "hcn1519",
                        "content": "Nice approach! At first, I just returned merged string during recursion and counted after DFS traversal. But it results TLE. So I changed it to return Map(Python Counter) and it passed."
                    },
                    {
                        "username": "xeniawann",
                        "content": "thank you! this gives me a starting point to work on lol"
                    },
                    {
                        "username": "Shounak_ds",
                        "content": "[[0,2],[0,3],[1,2]]"
                    },
                    {
                        "username": "wareag1e",
                        "content": "Similar to yesterday\\'s problem: 1443. \\nThis is indeed a good problem, and it\\'s a litter bit harder than 1443. \\nNot sure why there are so many downvotes. :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "it was a good way of building up on whatever you learned yesterday. this one is harder only when thinking about the 26 letter optimization. Other than that, it was easier than yesterday\\'s problem.  Plus, also reused the fact that you shouldn\\'t assume BT just coz of examples lol."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "disagree yesterday's problem we had to record time and prune on the basis of apples that subtree contains...not a tough problem but way more interesting...today's problem is just brute force... I don't get the downvotes tho, problem description is really clear"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Personally I like the problem, but I do have a problem with the problematic way the problem description is written. If you know what I mean."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Good problem telling people what \"trees\" in graph theory actually means."
                    },
                    {
                        "username": "shubham1992agg",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nroot node is supposed to be 0 but there is no connection with the node 1. Thus, it means there are 2 root nodes in this scenario."
                    },
                    {
                        "username": "vatsalm73",
                        "content": "[@sk03167](/sk03167) Thank you for the hint! Was able to solve it after seeing your comment. Appreciate the help :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "Maybe by now you already know this, but for others looking for a very small hint, think of this as a graph problem, rather than a tree problem"
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "[@Rawnblade](/Rawnblade) [1,2 ] is not about undirection, it  is about parent-child relationship"
                    },
                    {
                        "username": "Rawnblade",
                        "content": "The edges are undirected. Node 1 is a child of node 2."
                    },
                    {
                        "username": "real_code_monkey",
                        "content": "25\\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\n\"hcheiavadwjctaortvpsflssg\"\\n\\nI visualize this \"tree\" on the draft and realize that it is absoutly a directed graph without cycle. For example, larger number may be on the root of the \"tree\". This \"tree\" may contain multiple root.\\nI would say the description and the figure are quite misleading.\\nI hope I won\\'t meet this question in the interview.\\n\\n"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "This test case goes against the description of the problem and some of the other test cases. We are told not to follow a strict parent-child relationship, but in this test case, if we dont set 0 as the parent node initially, we get the wrong answer. Think this test case should be removed. "
                    },
                    {
                        "username": "calm27",
                        "content": "i stuck on the same test case. i don\\'t how how \\'h\\' could be 2, if here is only 1 \\'h\\' in the string. "
                    },
                    {
                        "username": "Satishsss",
                        "content": "Input:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nOutput:\\n[1,0,1,1]\\nExpected:\\n[1,1,2,1]\\n"
                    },
                    {
                        "username": "bhavinraichura28",
                        "content": " \\n\\n\\nif you read the question carefully then you observe that given the edges are undirected so in given edges [1,2] you can also write as [2,1]\\nso if you draw a tree then graph will look like this \\n\\n        0a\\n       /     \\\\\\n     2e      3d\\n    /\\n  1e\\n\\nso the answer is \\nnode :  freq\\n0a         1\\n1e         1\\n2e         2\\n3d         1\\n\\n"
                    },
                    {
                        "username": "abiahuja",
                        "content": "![image](https://assets.leetcode.com/users/images/4183d717-fc0a-404b-b379-f53872e58e7b_1595145225.5625112.png)\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Use $Windows + Shift + S$ to take better screenshot bro."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Smart way to make a screenshot :D "
                    }
                ]
            },
            {
                "id": 1575781,
                "content": [
                    {
                        "username": "kiwijuice56",
                        "content": "`[[0,2],[0,3],[1,2]]` is a valid test case because we are given an UNDIRECTED graph. The edge `[1,2]` does not necessarily mean that node `1` is the parent of `2`, but that there exists an edge between them. So, the tree constructed would look like this:\n\n```\n     0\n   /   \\\n  3     2 \n         \\\n          1\n```"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Well, it\\'s quite tricky, to be honest. When I see tree problem, I\\'m assume that I don\\'t need keep undirected connections. "
                    },
                    {
                        "username": "tedBian",
                        "content": "if problem doesn\\'t use the word \"sub-tree\" then this one could be very clear. It is possible people will consider index-0 is parent of index-1"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "[@alex-oreshkov](/alex-oreshkov) The graph vs sub-tree debate aside, this feels like a cheeky test case meant to unnecessarily make the problem harder. Its no way testing the actual logic behind the solution. Just forces you to incorporate some additional code to handle these edge cases. \\n\\nAlso, though the parent-child relationship is not explicitly mentioned, the presence of a root implies a parent-child relationship. There is one particular test case, \\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\nwhere the very first edge, we are forced to establish 0 as the parent simply because its the root. If we were to treat 0 as the child in this tree, you would get a different tree and the wrong answer. "
                    },
                    {
                        "username": "Saklor",
                        "content": "[@Prabhash123](/Prabhash123) \\n\\n\"node0 can be parent of node1 and vice versa\" only one of these statements is true for any edge, because we know that node 0 is the root. The node closer to the root will be the parent and the one further away the child.\\n[0,1] and [1,0] are the exact same edge because the graph is undirected, and both should return [2,1] in your example because 0 is the root node, and 1 is a leaf."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "[[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1].\\n "
                    },
                    {
                        "username": "happysings",
                        "content": "[@alex-oreshkov](/alex-oreshkov) \\n\\nedges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\\n\\nNowhere in the statement it says that ai is the parent and bi is the child.\\n\\nTheoretically - \\nAs long as the graph is undirected and has no cycles - you can choose any node as the root - its just traversal strategy to remember where the traversal began and not go back to that path - the ancestors.\\n\\nHere the problem sets the root to 0 node and hence you can confirm the paret/child relation only after traversing that edge from root."
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "No, it is not. First of all lets talk not about graph, but about tree, because  we need to determine a sub-tree. Second, yes, edges are undirected but in our case we should not care about that, because we always moving from parent to child (sub-tree, remember). So, [1,2] should be considered as 1 is parent and 2 is child with undirected edge.\\n\\n   0    1\\n /   \\\\ /\\n3    2\\nnot a tree"
                    },
                    {
                        "username": "anand92050",
                        "content": "If anyone is facing TLE problem then if you pass the string as reference then it will work finely.I spent a lot of time and finally get the result as \"Accepted\""
                    },
                    {
                        "username": "SKnew",
                        "content": "I was stuck with this. Thanks a lot man!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@leeten__1500](/leeten__1500) This is a well known reason. Passing by value means whole string is copied in each function call, but in pass by reference, only a reference is copied. The bigger question is WHY DO YOU NEED TO PASS STRING at all. Just copy it into a global string and keep accessing it!!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "thanks. But what\\'s the reason?"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Thanks a lot. Wasted a lot of time trying to optimize but couldn\\'t figure it out."
                    },
                    {
                        "username": "Ayush878",
                        "content": "Thank you brother saved a lot of time"
                    },
                    {
                        "username": "jhamadhav",
                        "content": "Saved me hours, thanks \\uD83D\\uDE4F"
                    },
                    {
                        "username": "KrutinSabnis",
                        "content": "thanks. spent 2 hrs on this"
                    },
                    {
                        "username": "fdshdfhjfds",
                        "content": "thanks i was stuck because of that tle"
                    },
                    {
                        "username": "anoyash",
                        "content": "All hail !!! saved my lot of time !!! , \nbut I still need to optimise my sol. currently beating 5%.  :("
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "bruh literally saved me !! i was stuck on this shit for last 1 hour"
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "thanks bhai,i was stuck for an hour due to that tle\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "This is a hard medium"
                    },
                    {
                        "username": "user7214PZ",
                        "content": "hard hard"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach\\n* Use DFS for Traversal\\n* Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n* Store count for each node label in the output array."
                    },
                    {
                        "username": "hcn1519",
                        "content": "Nice approach! At first, I just returned merged string during recursion and counted after DFS traversal. But it results TLE. So I changed it to return Map(Python Counter) and it passed."
                    },
                    {
                        "username": "xeniawann",
                        "content": "thank you! this gives me a starting point to work on lol"
                    },
                    {
                        "username": "Shounak_ds",
                        "content": "[[0,2],[0,3],[1,2]]"
                    },
                    {
                        "username": "wareag1e",
                        "content": "Similar to yesterday\\'s problem: 1443. \\nThis is indeed a good problem, and it\\'s a litter bit harder than 1443. \\nNot sure why there are so many downvotes. :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "it was a good way of building up on whatever you learned yesterday. this one is harder only when thinking about the 26 letter optimization. Other than that, it was easier than yesterday\\'s problem.  Plus, also reused the fact that you shouldn\\'t assume BT just coz of examples lol."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "disagree yesterday's problem we had to record time and prune on the basis of apples that subtree contains...not a tough problem but way more interesting...today's problem is just brute force... I don't get the downvotes tho, problem description is really clear"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Personally I like the problem, but I do have a problem with the problematic way the problem description is written. If you know what I mean."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Good problem telling people what \"trees\" in graph theory actually means."
                    },
                    {
                        "username": "shubham1992agg",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nroot node is supposed to be 0 but there is no connection with the node 1. Thus, it means there are 2 root nodes in this scenario."
                    },
                    {
                        "username": "vatsalm73",
                        "content": "[@sk03167](/sk03167) Thank you for the hint! Was able to solve it after seeing your comment. Appreciate the help :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "Maybe by now you already know this, but for others looking for a very small hint, think of this as a graph problem, rather than a tree problem"
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "[@Rawnblade](/Rawnblade) [1,2 ] is not about undirection, it  is about parent-child relationship"
                    },
                    {
                        "username": "Rawnblade",
                        "content": "The edges are undirected. Node 1 is a child of node 2."
                    },
                    {
                        "username": "real_code_monkey",
                        "content": "25\\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\n\"hcheiavadwjctaortvpsflssg\"\\n\\nI visualize this \"tree\" on the draft and realize that it is absoutly a directed graph without cycle. For example, larger number may be on the root of the \"tree\". This \"tree\" may contain multiple root.\\nI would say the description and the figure are quite misleading.\\nI hope I won\\'t meet this question in the interview.\\n\\n"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "This test case goes against the description of the problem and some of the other test cases. We are told not to follow a strict parent-child relationship, but in this test case, if we dont set 0 as the parent node initially, we get the wrong answer. Think this test case should be removed. "
                    },
                    {
                        "username": "calm27",
                        "content": "i stuck on the same test case. i don\\'t how how \\'h\\' could be 2, if here is only 1 \\'h\\' in the string. "
                    },
                    {
                        "username": "Satishsss",
                        "content": "Input:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nOutput:\\n[1,0,1,1]\\nExpected:\\n[1,1,2,1]\\n"
                    },
                    {
                        "username": "bhavinraichura28",
                        "content": " \\n\\n\\nif you read the question carefully then you observe that given the edges are undirected so in given edges [1,2] you can also write as [2,1]\\nso if you draw a tree then graph will look like this \\n\\n        0a\\n       /     \\\\\\n     2e      3d\\n    /\\n  1e\\n\\nso the answer is \\nnode :  freq\\n0a         1\\n1e         1\\n2e         2\\n3d         1\\n\\n"
                    },
                    {
                        "username": "abiahuja",
                        "content": "![image](https://assets.leetcode.com/users/images/4183d717-fc0a-404b-b379-f53872e58e7b_1595145225.5625112.png)\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Use $Windows + Shift + S$ to take better screenshot bro."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Smart way to make a screenshot :D "
                    }
                ]
            },
            {
                "id": 1568470,
                "content": [
                    {
                        "username": "kiwijuice56",
                        "content": "`[[0,2],[0,3],[1,2]]` is a valid test case because we are given an UNDIRECTED graph. The edge `[1,2]` does not necessarily mean that node `1` is the parent of `2`, but that there exists an edge between them. So, the tree constructed would look like this:\n\n```\n     0\n   /   \\\n  3     2 \n         \\\n          1\n```"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Well, it\\'s quite tricky, to be honest. When I see tree problem, I\\'m assume that I don\\'t need keep undirected connections. "
                    },
                    {
                        "username": "tedBian",
                        "content": "if problem doesn\\'t use the word \"sub-tree\" then this one could be very clear. It is possible people will consider index-0 is parent of index-1"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "[@alex-oreshkov](/alex-oreshkov) The graph vs sub-tree debate aside, this feels like a cheeky test case meant to unnecessarily make the problem harder. Its no way testing the actual logic behind the solution. Just forces you to incorporate some additional code to handle these edge cases. \\n\\nAlso, though the parent-child relationship is not explicitly mentioned, the presence of a root implies a parent-child relationship. There is one particular test case, \\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\nwhere the very first edge, we are forced to establish 0 as the parent simply because its the root. If we were to treat 0 as the child in this tree, you would get a different tree and the wrong answer. "
                    },
                    {
                        "username": "Saklor",
                        "content": "[@Prabhash123](/Prabhash123) \\n\\n\"node0 can be parent of node1 and vice versa\" only one of these statements is true for any edge, because we know that node 0 is the root. The node closer to the root will be the parent and the one further away the child.\\n[0,1] and [1,0] are the exact same edge because the graph is undirected, and both should return [2,1] in your example because 0 is the root node, and 1 is a leaf."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "[[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1].\\n "
                    },
                    {
                        "username": "happysings",
                        "content": "[@alex-oreshkov](/alex-oreshkov) \\n\\nedges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\\n\\nNowhere in the statement it says that ai is the parent and bi is the child.\\n\\nTheoretically - \\nAs long as the graph is undirected and has no cycles - you can choose any node as the root - its just traversal strategy to remember where the traversal began and not go back to that path - the ancestors.\\n\\nHere the problem sets the root to 0 node and hence you can confirm the paret/child relation only after traversing that edge from root."
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "No, it is not. First of all lets talk not about graph, but about tree, because  we need to determine a sub-tree. Second, yes, edges are undirected but in our case we should not care about that, because we always moving from parent to child (sub-tree, remember). So, [1,2] should be considered as 1 is parent and 2 is child with undirected edge.\\n\\n   0    1\\n /   \\\\ /\\n3    2\\nnot a tree"
                    },
                    {
                        "username": "anand92050",
                        "content": "If anyone is facing TLE problem then if you pass the string as reference then it will work finely.I spent a lot of time and finally get the result as \"Accepted\""
                    },
                    {
                        "username": "SKnew",
                        "content": "I was stuck with this. Thanks a lot man!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@leeten__1500](/leeten__1500) This is a well known reason. Passing by value means whole string is copied in each function call, but in pass by reference, only a reference is copied. The bigger question is WHY DO YOU NEED TO PASS STRING at all. Just copy it into a global string and keep accessing it!!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "thanks. But what\\'s the reason?"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Thanks a lot. Wasted a lot of time trying to optimize but couldn\\'t figure it out."
                    },
                    {
                        "username": "Ayush878",
                        "content": "Thank you brother saved a lot of time"
                    },
                    {
                        "username": "jhamadhav",
                        "content": "Saved me hours, thanks \\uD83D\\uDE4F"
                    },
                    {
                        "username": "KrutinSabnis",
                        "content": "thanks. spent 2 hrs on this"
                    },
                    {
                        "username": "fdshdfhjfds",
                        "content": "thanks i was stuck because of that tle"
                    },
                    {
                        "username": "anoyash",
                        "content": "All hail !!! saved my lot of time !!! , \nbut I still need to optimise my sol. currently beating 5%.  :("
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "bruh literally saved me !! i was stuck on this shit for last 1 hour"
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "thanks bhai,i was stuck for an hour due to that tle\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "This is a hard medium"
                    },
                    {
                        "username": "user7214PZ",
                        "content": "hard hard"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach\\n* Use DFS for Traversal\\n* Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n* Store count for each node label in the output array."
                    },
                    {
                        "username": "hcn1519",
                        "content": "Nice approach! At first, I just returned merged string during recursion and counted after DFS traversal. But it results TLE. So I changed it to return Map(Python Counter) and it passed."
                    },
                    {
                        "username": "xeniawann",
                        "content": "thank you! this gives me a starting point to work on lol"
                    },
                    {
                        "username": "Shounak_ds",
                        "content": "[[0,2],[0,3],[1,2]]"
                    },
                    {
                        "username": "wareag1e",
                        "content": "Similar to yesterday\\'s problem: 1443. \\nThis is indeed a good problem, and it\\'s a litter bit harder than 1443. \\nNot sure why there are so many downvotes. :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "it was a good way of building up on whatever you learned yesterday. this one is harder only when thinking about the 26 letter optimization. Other than that, it was easier than yesterday\\'s problem.  Plus, also reused the fact that you shouldn\\'t assume BT just coz of examples lol."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "disagree yesterday's problem we had to record time and prune on the basis of apples that subtree contains...not a tough problem but way more interesting...today's problem is just brute force... I don't get the downvotes tho, problem description is really clear"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Personally I like the problem, but I do have a problem with the problematic way the problem description is written. If you know what I mean."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Good problem telling people what \"trees\" in graph theory actually means."
                    },
                    {
                        "username": "shubham1992agg",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nroot node is supposed to be 0 but there is no connection with the node 1. Thus, it means there are 2 root nodes in this scenario."
                    },
                    {
                        "username": "vatsalm73",
                        "content": "[@sk03167](/sk03167) Thank you for the hint! Was able to solve it after seeing your comment. Appreciate the help :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "Maybe by now you already know this, but for others looking for a very small hint, think of this as a graph problem, rather than a tree problem"
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "[@Rawnblade](/Rawnblade) [1,2 ] is not about undirection, it  is about parent-child relationship"
                    },
                    {
                        "username": "Rawnblade",
                        "content": "The edges are undirected. Node 1 is a child of node 2."
                    },
                    {
                        "username": "real_code_monkey",
                        "content": "25\\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\n\"hcheiavadwjctaortvpsflssg\"\\n\\nI visualize this \"tree\" on the draft and realize that it is absoutly a directed graph without cycle. For example, larger number may be on the root of the \"tree\". This \"tree\" may contain multiple root.\\nI would say the description and the figure are quite misleading.\\nI hope I won\\'t meet this question in the interview.\\n\\n"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "This test case goes against the description of the problem and some of the other test cases. We are told not to follow a strict parent-child relationship, but in this test case, if we dont set 0 as the parent node initially, we get the wrong answer. Think this test case should be removed. "
                    },
                    {
                        "username": "calm27",
                        "content": "i stuck on the same test case. i don\\'t how how \\'h\\' could be 2, if here is only 1 \\'h\\' in the string. "
                    },
                    {
                        "username": "Satishsss",
                        "content": "Input:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nOutput:\\n[1,0,1,1]\\nExpected:\\n[1,1,2,1]\\n"
                    },
                    {
                        "username": "bhavinraichura28",
                        "content": " \\n\\n\\nif you read the question carefully then you observe that given the edges are undirected so in given edges [1,2] you can also write as [2,1]\\nso if you draw a tree then graph will look like this \\n\\n        0a\\n       /     \\\\\\n     2e      3d\\n    /\\n  1e\\n\\nso the answer is \\nnode :  freq\\n0a         1\\n1e         1\\n2e         2\\n3d         1\\n\\n"
                    },
                    {
                        "username": "abiahuja",
                        "content": "![image](https://assets.leetcode.com/users/images/4183d717-fc0a-404b-b379-f53872e58e7b_1595145225.5625112.png)\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Use $Windows + Shift + S$ to take better screenshot bro."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Smart way to make a screenshot :D "
                    }
                ]
            },
            {
                "id": 1574076,
                "content": [
                    {
                        "username": "kiwijuice56",
                        "content": "`[[0,2],[0,3],[1,2]]` is a valid test case because we are given an UNDIRECTED graph. The edge `[1,2]` does not necessarily mean that node `1` is the parent of `2`, but that there exists an edge between them. So, the tree constructed would look like this:\n\n```\n     0\n   /   \\\n  3     2 \n         \\\n          1\n```"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Well, it\\'s quite tricky, to be honest. When I see tree problem, I\\'m assume that I don\\'t need keep undirected connections. "
                    },
                    {
                        "username": "tedBian",
                        "content": "if problem doesn\\'t use the word \"sub-tree\" then this one could be very clear. It is possible people will consider index-0 is parent of index-1"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "[@alex-oreshkov](/alex-oreshkov) The graph vs sub-tree debate aside, this feels like a cheeky test case meant to unnecessarily make the problem harder. Its no way testing the actual logic behind the solution. Just forces you to incorporate some additional code to handle these edge cases. \\n\\nAlso, though the parent-child relationship is not explicitly mentioned, the presence of a root implies a parent-child relationship. There is one particular test case, \\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\nwhere the very first edge, we are forced to establish 0 as the parent simply because its the root. If we were to treat 0 as the child in this tree, you would get a different tree and the wrong answer. "
                    },
                    {
                        "username": "Saklor",
                        "content": "[@Prabhash123](/Prabhash123) \\n\\n\"node0 can be parent of node1 and vice versa\" only one of these statements is true for any edge, because we know that node 0 is the root. The node closer to the root will be the parent and the one further away the child.\\n[0,1] and [1,0] are the exact same edge because the graph is undirected, and both should return [2,1] in your example because 0 is the root node, and 1 is a leaf."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "[[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1].\\n "
                    },
                    {
                        "username": "happysings",
                        "content": "[@alex-oreshkov](/alex-oreshkov) \\n\\nedges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\\n\\nNowhere in the statement it says that ai is the parent and bi is the child.\\n\\nTheoretically - \\nAs long as the graph is undirected and has no cycles - you can choose any node as the root - its just traversal strategy to remember where the traversal began and not go back to that path - the ancestors.\\n\\nHere the problem sets the root to 0 node and hence you can confirm the paret/child relation only after traversing that edge from root."
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "No, it is not. First of all lets talk not about graph, but about tree, because  we need to determine a sub-tree. Second, yes, edges are undirected but in our case we should not care about that, because we always moving from parent to child (sub-tree, remember). So, [1,2] should be considered as 1 is parent and 2 is child with undirected edge.\\n\\n   0    1\\n /   \\\\ /\\n3    2\\nnot a tree"
                    },
                    {
                        "username": "anand92050",
                        "content": "If anyone is facing TLE problem then if you pass the string as reference then it will work finely.I spent a lot of time and finally get the result as \"Accepted\""
                    },
                    {
                        "username": "SKnew",
                        "content": "I was stuck with this. Thanks a lot man!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@leeten__1500](/leeten__1500) This is a well known reason. Passing by value means whole string is copied in each function call, but in pass by reference, only a reference is copied. The bigger question is WHY DO YOU NEED TO PASS STRING at all. Just copy it into a global string and keep accessing it!!"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "thanks. But what\\'s the reason?"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Thanks a lot. Wasted a lot of time trying to optimize but couldn\\'t figure it out."
                    },
                    {
                        "username": "Ayush878",
                        "content": "Thank you brother saved a lot of time"
                    },
                    {
                        "username": "jhamadhav",
                        "content": "Saved me hours, thanks \\uD83D\\uDE4F"
                    },
                    {
                        "username": "KrutinSabnis",
                        "content": "thanks. spent 2 hrs on this"
                    },
                    {
                        "username": "fdshdfhjfds",
                        "content": "thanks i was stuck because of that tle"
                    },
                    {
                        "username": "anoyash",
                        "content": "All hail !!! saved my lot of time !!! , \nbut I still need to optimise my sol. currently beating 5%.  :("
                    },
                    {
                        "username": "Keshav_1707",
                        "content": "bruh literally saved me !! i was stuck on this shit for last 1 hour"
                    },
                    {
                        "username": "vaibhav14112002",
                        "content": "thanks bhai,i was stuck for an hour due to that tle\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "This is a hard medium"
                    },
                    {
                        "username": "user7214PZ",
                        "content": "hard hard"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach\\n* Use DFS for Traversal\\n* Each node should return an array of size 26 to the parent, containing count of all labels in the subtree of that node.\\n* Store count for each node label in the output array."
                    },
                    {
                        "username": "hcn1519",
                        "content": "Nice approach! At first, I just returned merged string during recursion and counted after DFS traversal. But it results TLE. So I changed it to return Map(Python Counter) and it passed."
                    },
                    {
                        "username": "xeniawann",
                        "content": "thank you! this gives me a starting point to work on lol"
                    },
                    {
                        "username": "Shounak_ds",
                        "content": "[[0,2],[0,3],[1,2]]"
                    },
                    {
                        "username": "wareag1e",
                        "content": "Similar to yesterday\\'s problem: 1443. \\nThis is indeed a good problem, and it\\'s a litter bit harder than 1443. \\nNot sure why there are so many downvotes. :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "it was a good way of building up on whatever you learned yesterday. this one is harder only when thinking about the 26 letter optimization. Other than that, it was easier than yesterday\\'s problem.  Plus, also reused the fact that you shouldn\\'t assume BT just coz of examples lol."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "disagree yesterday's problem we had to record time and prune on the basis of apples that subtree contains...not a tough problem but way more interesting...today's problem is just brute force... I don't get the downvotes tho, problem description is really clear"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Personally I like the problem, but I do have a problem with the problematic way the problem description is written. If you know what I mean."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Good problem telling people what \"trees\" in graph theory actually means."
                    },
                    {
                        "username": "shubham1992agg",
                        "content": "4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nroot node is supposed to be 0 but there is no connection with the node 1. Thus, it means there are 2 root nodes in this scenario."
                    },
                    {
                        "username": "vatsalm73",
                        "content": "[@sk03167](/sk03167) Thank you for the hint! Was able to solve it after seeing your comment. Appreciate the help :)"
                    },
                    {
                        "username": "sk03167",
                        "content": "Maybe by now you already know this, but for others looking for a very small hint, think of this as a graph problem, rather than a tree problem"
                    },
                    {
                        "username": "alex-oreshkov",
                        "content": "[@Rawnblade](/Rawnblade) [1,2 ] is not about undirection, it  is about parent-child relationship"
                    },
                    {
                        "username": "Rawnblade",
                        "content": "The edges are undirected. Node 1 is a child of node 2."
                    },
                    {
                        "username": "real_code_monkey",
                        "content": "25\\n[[4,0],[5,4],[12,5],[3,12],[18,3],[10,18],[8,5],[16,8],[14,16],[13,16],[9,13],[22,9],[2,5],[6,2],[1,6],[11,1],[15,11],[20,11],[7,20],[19,1],[17,19],[23,19],[24,2],[21,24]]\\n\"hcheiavadwjctaortvpsflssg\"\\n\\nI visualize this \"tree\" on the draft and realize that it is absoutly a directed graph without cycle. For example, larger number may be on the root of the \"tree\". This \"tree\" may contain multiple root.\\nI would say the description and the figure are quite misleading.\\nI hope I won\\'t meet this question in the interview.\\n\\n"
                    },
                    {
                        "username": "overfitModel2305",
                        "content": "This test case goes against the description of the problem and some of the other test cases. We are told not to follow a strict parent-child relationship, but in this test case, if we dont set 0 as the parent node initially, we get the wrong answer. Think this test case should be removed. "
                    },
                    {
                        "username": "calm27",
                        "content": "i stuck on the same test case. i don\\'t how how \\'h\\' could be 2, if here is only 1 \\'h\\' in the string. "
                    },
                    {
                        "username": "Satishsss",
                        "content": "Input:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nOutput:\\n[1,0,1,1]\\nExpected:\\n[1,1,2,1]\\n"
                    },
                    {
                        "username": "bhavinraichura28",
                        "content": " \\n\\n\\nif you read the question carefully then you observe that given the edges are undirected so in given edges [1,2] you can also write as [2,1]\\nso if you draw a tree then graph will look like this \\n\\n        0a\\n       /     \\\\\\n     2e      3d\\n    /\\n  1e\\n\\nso the answer is \\nnode :  freq\\n0a         1\\n1e         1\\n2e         2\\n3d         1\\n\\n"
                    },
                    {
                        "username": "abiahuja",
                        "content": "![image](https://assets.leetcode.com/users/images/4183d717-fc0a-404b-b379-f53872e58e7b_1595145225.5625112.png)\\n"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Use $Windows + Shift + S$ to take better screenshot bro."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Smart way to make a screenshot :D "
                    }
                ]
            },
            {
                "id": 1568612,
                "content": [
                    {
                        "username": "amadeus84",
                        "content": "I just submitted my solution and the submission fails on this input:\\n\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nHow is this even valid input? What\\'s the parent of 1? Also 2 has 2 parents. Two parents in a tree? That\\'s crazy.\\n"
                    },
                    {
                        "username": "DeadShot08112001AnshumanSINGH",
                        "content": "Edges are bidirectional . So,(1,2) and (2,1) both are valid edges.\\nIn sample testcases ,if you change [ai, bi] to [bi, ai],then answer still remains the same."
                    },
                    {
                        "username": "simulatte",
                        "content": "Yes it is weird but works if you consider [1, 2] as [2, 1]"
                    },
                    {
                        "username": "oxke",
                        "content": "I have a fundamental question about this problem.\nThis is, like yesterday's one, about an undirected tree, meaning a \"connected, undirected graph that has no cycles\". The definition the problem gives of 'subtree', essential for the solution of the problem, is \"A subtree of a tree T is the tree consisting of a node in T and all of its descendant nodes.\"\nNow, since the tree is undirected, what does it mean for a node to have a descendant? It means all the nodes I can get to with a path on the graph, but then this means all the nodes are reachable. Instead, if some nodes are descendants and one, just one is a parent, then the tree cannot be called undirected, there is a clear direction in the connection between two nodes."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Although informally we programmers like to think of trees as directed graphs with parents and children, in graph theory a \"tree\" is equivalent to a \"connected acyclic undirected graph\".  \nIn the context of this exercise \"subtree\" the node with index `0` is the root, and \"subtree\" can be inferred from that: All sub-nodes that can be reached from some \"node\" without going \"up\" to the parent."
                    },
                    {
                        "username": "space_invader",
                        "content": "![1519. Number of nodes in the sub tree with the same label.jpg](https://assets.leetcode.com/users/images/30547bf5-b00b-46df-a2be-823b1cb2f827_1673501984.7368417.jpeg)\\n"
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/9CbzRhXOql8\\n\\nA detailed video explanation with code.\\nApproach to optimized solution from a brute force solution is also discussed.\\n\\nThank You."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone please explain why is this TLE\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node,string labels,vector<vector<int>> &adjl,vector<int>& ans){\\n        ans[node] = 1;\\n        vector<int> count(26,0);\\n        count[labels[node]-\\'a\\'] = 1;\\n        for(auto child:adjl[node]){\\n            if(!ans[child]){\\n                vector<int> countadj = dfs(child,labels,adjl,ans);\\n            for(int i=0;i<26;i++){\\n                count[i] += countadj[i];\\n            }\\n            }\\n        }\\n        ans[node] = count[labels[node]-\\'a\\'];\\n        return count;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adjl(n);\\n        for(auto edge:edges){\\n            adjl[edge[0]].push_back(edge[1]);\\n            adjl[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> ans(n,0);\\n        dfs(0,labels,adjl,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its argument `labels` by value which means `labels` gets copied many many times. Instead the function could take it by reference (`string& labels`) to avoid those unnecessary copies."
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "pass string labels with reference.\\n\\nlike -> string &labels"
                    },
                    {
                        "username": "patrickbies",
                        "content": "EDIT:  I solved the problem by passing a reference of the string in my dfs function instead of copying the string. \n\nHi, I am receiving a TLE on my code. I am just wondering where I can optimize it. believe it is O(N) traversal using O(1) operations. Maybe I could prune my search somewhere and not check every node. Idk suggestions are appreciated. Thanks\n\n<details>\n  <summary>Spoiler warning</summary>\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> adj;\n    vector<int> res;\n    \n    void dfs(int n, string l, int p, int* r) {\n        int pt = r[l[n] - 'a'];\n        r[l[n] - 'a']++;\n        \n        for (auto& a : adj[n]) {\n            if (a != p) {\n                dfs(a, l, n, r);\n            }\n        }\n\n        res[n] = r[l[n] - 'a'] - pt;\n    }\n\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        adj.resize(n);\n        res.resize(n);\n\n        for (auto& a : edges)\n            adj[a[0]].push_back(a[1]), adj[a[1]].push_back(a[0]);\n\n        int k[26] = {0};\n        dfs(0, labels, -1, k);\n        return res;\n    }\n};\n```\n</details>"
                    },
                    {
                        "username": "Narendra_027",
                        "content": "was doing same mistake"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Java Tip\\nBe careful with `map` `computeIfAbsent()` method\\nI used `graph.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);` during graph creation.\\nIt\\'s wrong because the second argument of `computeIfAbsent()` is a function which receives a map key as an argument. So, it uses `ArrayList(int initialCapacity)` constructor which waste huge amount of memory in case we have a lot of vertexes.\\nTo sum up, method reference does not always work obviously, to fix my issue I just changed above code to `graph.computeIfAbsent(edge[0], key -> new ArrayList<>()).add(edge[1])`;"
                    },
                    {
                        "username": "zebra-f",
                        "content": "`... and exactly n - 1 edges` is that information important? Can someone show me a tree that doesn't have n - 1 edges?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[deleted. sorry I responded to the wrong comment]"
                    },
                    {
                        "username": "harisriram2002",
                        "content": "Maybe just to troll us :p, so we will waste some time rethinking what we learnt about trees"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I think this question is little tough or maybe it\\'s just me who feels it"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "I think it is hard as well. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "yes it should be a hard problem, as the brute force solutions give tle "
                    },
                    {
                        "username": "Brut_all",
                        "content": "Hey can  anyone help me why my solution is producing TLE\\nEven chatGPT failed to correctly identify it.\\nI am using a  single vector of size 26 to store the occurances of the characters of the string and using dfs traversal to traverse the entire tree\\n\\n[Here\\'s my problem ](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876515427/)"
                    },
                    {
                        "username": "_ankit101",
                        "content": "[@Scresat](/Scresat) thanks!! it works"
                    },
                    {
                        "username": "kzo",
                        "content": "You are passing the string as a value, instead pass by reference, or make it global."
                    }
                ]
            },
            {
                "id": 1753964,
                "content": [
                    {
                        "username": "amadeus84",
                        "content": "I just submitted my solution and the submission fails on this input:\\n\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nHow is this even valid input? What\\'s the parent of 1? Also 2 has 2 parents. Two parents in a tree? That\\'s crazy.\\n"
                    },
                    {
                        "username": "DeadShot08112001AnshumanSINGH",
                        "content": "Edges are bidirectional . So,(1,2) and (2,1) both are valid edges.\\nIn sample testcases ,if you change [ai, bi] to [bi, ai],then answer still remains the same."
                    },
                    {
                        "username": "simulatte",
                        "content": "Yes it is weird but works if you consider [1, 2] as [2, 1]"
                    },
                    {
                        "username": "oxke",
                        "content": "I have a fundamental question about this problem.\nThis is, like yesterday's one, about an undirected tree, meaning a \"connected, undirected graph that has no cycles\". The definition the problem gives of 'subtree', essential for the solution of the problem, is \"A subtree of a tree T is the tree consisting of a node in T and all of its descendant nodes.\"\nNow, since the tree is undirected, what does it mean for a node to have a descendant? It means all the nodes I can get to with a path on the graph, but then this means all the nodes are reachable. Instead, if some nodes are descendants and one, just one is a parent, then the tree cannot be called undirected, there is a clear direction in the connection between two nodes."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Although informally we programmers like to think of trees as directed graphs with parents and children, in graph theory a \"tree\" is equivalent to a \"connected acyclic undirected graph\".  \nIn the context of this exercise \"subtree\" the node with index `0` is the root, and \"subtree\" can be inferred from that: All sub-nodes that can be reached from some \"node\" without going \"up\" to the parent."
                    },
                    {
                        "username": "space_invader",
                        "content": "![1519. Number of nodes in the sub tree with the same label.jpg](https://assets.leetcode.com/users/images/30547bf5-b00b-46df-a2be-823b1cb2f827_1673501984.7368417.jpeg)\\n"
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/9CbzRhXOql8\\n\\nA detailed video explanation with code.\\nApproach to optimized solution from a brute force solution is also discussed.\\n\\nThank You."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone please explain why is this TLE\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node,string labels,vector<vector<int>> &adjl,vector<int>& ans){\\n        ans[node] = 1;\\n        vector<int> count(26,0);\\n        count[labels[node]-\\'a\\'] = 1;\\n        for(auto child:adjl[node]){\\n            if(!ans[child]){\\n                vector<int> countadj = dfs(child,labels,adjl,ans);\\n            for(int i=0;i<26;i++){\\n                count[i] += countadj[i];\\n            }\\n            }\\n        }\\n        ans[node] = count[labels[node]-\\'a\\'];\\n        return count;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adjl(n);\\n        for(auto edge:edges){\\n            adjl[edge[0]].push_back(edge[1]);\\n            adjl[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> ans(n,0);\\n        dfs(0,labels,adjl,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its argument `labels` by value which means `labels` gets copied many many times. Instead the function could take it by reference (`string& labels`) to avoid those unnecessary copies."
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "pass string labels with reference.\\n\\nlike -> string &labels"
                    },
                    {
                        "username": "patrickbies",
                        "content": "EDIT:  I solved the problem by passing a reference of the string in my dfs function instead of copying the string. \n\nHi, I am receiving a TLE on my code. I am just wondering where I can optimize it. believe it is O(N) traversal using O(1) operations. Maybe I could prune my search somewhere and not check every node. Idk suggestions are appreciated. Thanks\n\n<details>\n  <summary>Spoiler warning</summary>\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> adj;\n    vector<int> res;\n    \n    void dfs(int n, string l, int p, int* r) {\n        int pt = r[l[n] - 'a'];\n        r[l[n] - 'a']++;\n        \n        for (auto& a : adj[n]) {\n            if (a != p) {\n                dfs(a, l, n, r);\n            }\n        }\n\n        res[n] = r[l[n] - 'a'] - pt;\n    }\n\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        adj.resize(n);\n        res.resize(n);\n\n        for (auto& a : edges)\n            adj[a[0]].push_back(a[1]), adj[a[1]].push_back(a[0]);\n\n        int k[26] = {0};\n        dfs(0, labels, -1, k);\n        return res;\n    }\n};\n```\n</details>"
                    },
                    {
                        "username": "Narendra_027",
                        "content": "was doing same mistake"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Java Tip\\nBe careful with `map` `computeIfAbsent()` method\\nI used `graph.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);` during graph creation.\\nIt\\'s wrong because the second argument of `computeIfAbsent()` is a function which receives a map key as an argument. So, it uses `ArrayList(int initialCapacity)` constructor which waste huge amount of memory in case we have a lot of vertexes.\\nTo sum up, method reference does not always work obviously, to fix my issue I just changed above code to `graph.computeIfAbsent(edge[0], key -> new ArrayList<>()).add(edge[1])`;"
                    },
                    {
                        "username": "zebra-f",
                        "content": "`... and exactly n - 1 edges` is that information important? Can someone show me a tree that doesn't have n - 1 edges?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[deleted. sorry I responded to the wrong comment]"
                    },
                    {
                        "username": "harisriram2002",
                        "content": "Maybe just to troll us :p, so we will waste some time rethinking what we learnt about trees"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I think this question is little tough or maybe it\\'s just me who feels it"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "I think it is hard as well. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "yes it should be a hard problem, as the brute force solutions give tle "
                    },
                    {
                        "username": "Brut_all",
                        "content": "Hey can  anyone help me why my solution is producing TLE\\nEven chatGPT failed to correctly identify it.\\nI am using a  single vector of size 26 to store the occurances of the characters of the string and using dfs traversal to traverse the entire tree\\n\\n[Here\\'s my problem ](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876515427/)"
                    },
                    {
                        "username": "_ankit101",
                        "content": "[@Scresat](/Scresat) thanks!! it works"
                    },
                    {
                        "username": "kzo",
                        "content": "You are passing the string as a value, instead pass by reference, or make it global."
                    }
                ]
            },
            {
                "id": 1753627,
                "content": [
                    {
                        "username": "amadeus84",
                        "content": "I just submitted my solution and the submission fails on this input:\\n\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nHow is this even valid input? What\\'s the parent of 1? Also 2 has 2 parents. Two parents in a tree? That\\'s crazy.\\n"
                    },
                    {
                        "username": "DeadShot08112001AnshumanSINGH",
                        "content": "Edges are bidirectional . So,(1,2) and (2,1) both are valid edges.\\nIn sample testcases ,if you change [ai, bi] to [bi, ai],then answer still remains the same."
                    },
                    {
                        "username": "simulatte",
                        "content": "Yes it is weird but works if you consider [1, 2] as [2, 1]"
                    },
                    {
                        "username": "oxke",
                        "content": "I have a fundamental question about this problem.\nThis is, like yesterday's one, about an undirected tree, meaning a \"connected, undirected graph that has no cycles\". The definition the problem gives of 'subtree', essential for the solution of the problem, is \"A subtree of a tree T is the tree consisting of a node in T and all of its descendant nodes.\"\nNow, since the tree is undirected, what does it mean for a node to have a descendant? It means all the nodes I can get to with a path on the graph, but then this means all the nodes are reachable. Instead, if some nodes are descendants and one, just one is a parent, then the tree cannot be called undirected, there is a clear direction in the connection between two nodes."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Although informally we programmers like to think of trees as directed graphs with parents and children, in graph theory a \"tree\" is equivalent to a \"connected acyclic undirected graph\".  \nIn the context of this exercise \"subtree\" the node with index `0` is the root, and \"subtree\" can be inferred from that: All sub-nodes that can be reached from some \"node\" without going \"up\" to the parent."
                    },
                    {
                        "username": "space_invader",
                        "content": "![1519. Number of nodes in the sub tree with the same label.jpg](https://assets.leetcode.com/users/images/30547bf5-b00b-46df-a2be-823b1cb2f827_1673501984.7368417.jpeg)\\n"
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/9CbzRhXOql8\\n\\nA detailed video explanation with code.\\nApproach to optimized solution from a brute force solution is also discussed.\\n\\nThank You."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone please explain why is this TLE\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node,string labels,vector<vector<int>> &adjl,vector<int>& ans){\\n        ans[node] = 1;\\n        vector<int> count(26,0);\\n        count[labels[node]-\\'a\\'] = 1;\\n        for(auto child:adjl[node]){\\n            if(!ans[child]){\\n                vector<int> countadj = dfs(child,labels,adjl,ans);\\n            for(int i=0;i<26;i++){\\n                count[i] += countadj[i];\\n            }\\n            }\\n        }\\n        ans[node] = count[labels[node]-\\'a\\'];\\n        return count;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adjl(n);\\n        for(auto edge:edges){\\n            adjl[edge[0]].push_back(edge[1]);\\n            adjl[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> ans(n,0);\\n        dfs(0,labels,adjl,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its argument `labels` by value which means `labels` gets copied many many times. Instead the function could take it by reference (`string& labels`) to avoid those unnecessary copies."
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "pass string labels with reference.\\n\\nlike -> string &labels"
                    },
                    {
                        "username": "patrickbies",
                        "content": "EDIT:  I solved the problem by passing a reference of the string in my dfs function instead of copying the string. \n\nHi, I am receiving a TLE on my code. I am just wondering where I can optimize it. believe it is O(N) traversal using O(1) operations. Maybe I could prune my search somewhere and not check every node. Idk suggestions are appreciated. Thanks\n\n<details>\n  <summary>Spoiler warning</summary>\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> adj;\n    vector<int> res;\n    \n    void dfs(int n, string l, int p, int* r) {\n        int pt = r[l[n] - 'a'];\n        r[l[n] - 'a']++;\n        \n        for (auto& a : adj[n]) {\n            if (a != p) {\n                dfs(a, l, n, r);\n            }\n        }\n\n        res[n] = r[l[n] - 'a'] - pt;\n    }\n\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        adj.resize(n);\n        res.resize(n);\n\n        for (auto& a : edges)\n            adj[a[0]].push_back(a[1]), adj[a[1]].push_back(a[0]);\n\n        int k[26] = {0};\n        dfs(0, labels, -1, k);\n        return res;\n    }\n};\n```\n</details>"
                    },
                    {
                        "username": "Narendra_027",
                        "content": "was doing same mistake"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Java Tip\\nBe careful with `map` `computeIfAbsent()` method\\nI used `graph.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);` during graph creation.\\nIt\\'s wrong because the second argument of `computeIfAbsent()` is a function which receives a map key as an argument. So, it uses `ArrayList(int initialCapacity)` constructor which waste huge amount of memory in case we have a lot of vertexes.\\nTo sum up, method reference does not always work obviously, to fix my issue I just changed above code to `graph.computeIfAbsent(edge[0], key -> new ArrayList<>()).add(edge[1])`;"
                    },
                    {
                        "username": "zebra-f",
                        "content": "`... and exactly n - 1 edges` is that information important? Can someone show me a tree that doesn't have n - 1 edges?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[deleted. sorry I responded to the wrong comment]"
                    },
                    {
                        "username": "harisriram2002",
                        "content": "Maybe just to troll us :p, so we will waste some time rethinking what we learnt about trees"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I think this question is little tough or maybe it\\'s just me who feels it"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "I think it is hard as well. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "yes it should be a hard problem, as the brute force solutions give tle "
                    },
                    {
                        "username": "Brut_all",
                        "content": "Hey can  anyone help me why my solution is producing TLE\\nEven chatGPT failed to correctly identify it.\\nI am using a  single vector of size 26 to store the occurances of the characters of the string and using dfs traversal to traverse the entire tree\\n\\n[Here\\'s my problem ](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876515427/)"
                    },
                    {
                        "username": "_ankit101",
                        "content": "[@Scresat](/Scresat) thanks!! it works"
                    },
                    {
                        "username": "kzo",
                        "content": "You are passing the string as a value, instead pass by reference, or make it global."
                    }
                ]
            },
            {
                "id": 1570080,
                "content": [
                    {
                        "username": "amadeus84",
                        "content": "I just submitted my solution and the submission fails on this input:\\n\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nHow is this even valid input? What\\'s the parent of 1? Also 2 has 2 parents. Two parents in a tree? That\\'s crazy.\\n"
                    },
                    {
                        "username": "DeadShot08112001AnshumanSINGH",
                        "content": "Edges are bidirectional . So,(1,2) and (2,1) both are valid edges.\\nIn sample testcases ,if you change [ai, bi] to [bi, ai],then answer still remains the same."
                    },
                    {
                        "username": "simulatte",
                        "content": "Yes it is weird but works if you consider [1, 2] as [2, 1]"
                    },
                    {
                        "username": "oxke",
                        "content": "I have a fundamental question about this problem.\nThis is, like yesterday's one, about an undirected tree, meaning a \"connected, undirected graph that has no cycles\". The definition the problem gives of 'subtree', essential for the solution of the problem, is \"A subtree of a tree T is the tree consisting of a node in T and all of its descendant nodes.\"\nNow, since the tree is undirected, what does it mean for a node to have a descendant? It means all the nodes I can get to with a path on the graph, but then this means all the nodes are reachable. Instead, if some nodes are descendants and one, just one is a parent, then the tree cannot be called undirected, there is a clear direction in the connection between two nodes."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Although informally we programmers like to think of trees as directed graphs with parents and children, in graph theory a \"tree\" is equivalent to a \"connected acyclic undirected graph\".  \nIn the context of this exercise \"subtree\" the node with index `0` is the root, and \"subtree\" can be inferred from that: All sub-nodes that can be reached from some \"node\" without going \"up\" to the parent."
                    },
                    {
                        "username": "space_invader",
                        "content": "![1519. Number of nodes in the sub tree with the same label.jpg](https://assets.leetcode.com/users/images/30547bf5-b00b-46df-a2be-823b1cb2f827_1673501984.7368417.jpeg)\\n"
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/9CbzRhXOql8\\n\\nA detailed video explanation with code.\\nApproach to optimized solution from a brute force solution is also discussed.\\n\\nThank You."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone please explain why is this TLE\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node,string labels,vector<vector<int>> &adjl,vector<int>& ans){\\n        ans[node] = 1;\\n        vector<int> count(26,0);\\n        count[labels[node]-\\'a\\'] = 1;\\n        for(auto child:adjl[node]){\\n            if(!ans[child]){\\n                vector<int> countadj = dfs(child,labels,adjl,ans);\\n            for(int i=0;i<26;i++){\\n                count[i] += countadj[i];\\n            }\\n            }\\n        }\\n        ans[node] = count[labels[node]-\\'a\\'];\\n        return count;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adjl(n);\\n        for(auto edge:edges){\\n            adjl[edge[0]].push_back(edge[1]);\\n            adjl[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> ans(n,0);\\n        dfs(0,labels,adjl,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its argument `labels` by value which means `labels` gets copied many many times. Instead the function could take it by reference (`string& labels`) to avoid those unnecessary copies."
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "pass string labels with reference.\\n\\nlike -> string &labels"
                    },
                    {
                        "username": "patrickbies",
                        "content": "EDIT:  I solved the problem by passing a reference of the string in my dfs function instead of copying the string. \n\nHi, I am receiving a TLE on my code. I am just wondering where I can optimize it. believe it is O(N) traversal using O(1) operations. Maybe I could prune my search somewhere and not check every node. Idk suggestions are appreciated. Thanks\n\n<details>\n  <summary>Spoiler warning</summary>\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> adj;\n    vector<int> res;\n    \n    void dfs(int n, string l, int p, int* r) {\n        int pt = r[l[n] - 'a'];\n        r[l[n] - 'a']++;\n        \n        for (auto& a : adj[n]) {\n            if (a != p) {\n                dfs(a, l, n, r);\n            }\n        }\n\n        res[n] = r[l[n] - 'a'] - pt;\n    }\n\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        adj.resize(n);\n        res.resize(n);\n\n        for (auto& a : edges)\n            adj[a[0]].push_back(a[1]), adj[a[1]].push_back(a[0]);\n\n        int k[26] = {0};\n        dfs(0, labels, -1, k);\n        return res;\n    }\n};\n```\n</details>"
                    },
                    {
                        "username": "Narendra_027",
                        "content": "was doing same mistake"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Java Tip\\nBe careful with `map` `computeIfAbsent()` method\\nI used `graph.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);` during graph creation.\\nIt\\'s wrong because the second argument of `computeIfAbsent()` is a function which receives a map key as an argument. So, it uses `ArrayList(int initialCapacity)` constructor which waste huge amount of memory in case we have a lot of vertexes.\\nTo sum up, method reference does not always work obviously, to fix my issue I just changed above code to `graph.computeIfAbsent(edge[0], key -> new ArrayList<>()).add(edge[1])`;"
                    },
                    {
                        "username": "zebra-f",
                        "content": "`... and exactly n - 1 edges` is that information important? Can someone show me a tree that doesn't have n - 1 edges?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[deleted. sorry I responded to the wrong comment]"
                    },
                    {
                        "username": "harisriram2002",
                        "content": "Maybe just to troll us :p, so we will waste some time rethinking what we learnt about trees"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I think this question is little tough or maybe it\\'s just me who feels it"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "I think it is hard as well. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "yes it should be a hard problem, as the brute force solutions give tle "
                    },
                    {
                        "username": "Brut_all",
                        "content": "Hey can  anyone help me why my solution is producing TLE\\nEven chatGPT failed to correctly identify it.\\nI am using a  single vector of size 26 to store the occurances of the characters of the string and using dfs traversal to traverse the entire tree\\n\\n[Here\\'s my problem ](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876515427/)"
                    },
                    {
                        "username": "_ankit101",
                        "content": "[@Scresat](/Scresat) thanks!! it works"
                    },
                    {
                        "username": "kzo",
                        "content": "You are passing the string as a value, instead pass by reference, or make it global."
                    }
                ]
            },
            {
                "id": 1754361,
                "content": [
                    {
                        "username": "amadeus84",
                        "content": "I just submitted my solution and the submission fails on this input:\\n\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nHow is this even valid input? What\\'s the parent of 1? Also 2 has 2 parents. Two parents in a tree? That\\'s crazy.\\n"
                    },
                    {
                        "username": "DeadShot08112001AnshumanSINGH",
                        "content": "Edges are bidirectional . So,(1,2) and (2,1) both are valid edges.\\nIn sample testcases ,if you change [ai, bi] to [bi, ai],then answer still remains the same."
                    },
                    {
                        "username": "simulatte",
                        "content": "Yes it is weird but works if you consider [1, 2] as [2, 1]"
                    },
                    {
                        "username": "oxke",
                        "content": "I have a fundamental question about this problem.\nThis is, like yesterday's one, about an undirected tree, meaning a \"connected, undirected graph that has no cycles\". The definition the problem gives of 'subtree', essential for the solution of the problem, is \"A subtree of a tree T is the tree consisting of a node in T and all of its descendant nodes.\"\nNow, since the tree is undirected, what does it mean for a node to have a descendant? It means all the nodes I can get to with a path on the graph, but then this means all the nodes are reachable. Instead, if some nodes are descendants and one, just one is a parent, then the tree cannot be called undirected, there is a clear direction in the connection between two nodes."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Although informally we programmers like to think of trees as directed graphs with parents and children, in graph theory a \"tree\" is equivalent to a \"connected acyclic undirected graph\".  \nIn the context of this exercise \"subtree\" the node with index `0` is the root, and \"subtree\" can be inferred from that: All sub-nodes that can be reached from some \"node\" without going \"up\" to the parent."
                    },
                    {
                        "username": "space_invader",
                        "content": "![1519. Number of nodes in the sub tree with the same label.jpg](https://assets.leetcode.com/users/images/30547bf5-b00b-46df-a2be-823b1cb2f827_1673501984.7368417.jpeg)\\n"
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/9CbzRhXOql8\\n\\nA detailed video explanation with code.\\nApproach to optimized solution from a brute force solution is also discussed.\\n\\nThank You."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone please explain why is this TLE\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node,string labels,vector<vector<int>> &adjl,vector<int>& ans){\\n        ans[node] = 1;\\n        vector<int> count(26,0);\\n        count[labels[node]-\\'a\\'] = 1;\\n        for(auto child:adjl[node]){\\n            if(!ans[child]){\\n                vector<int> countadj = dfs(child,labels,adjl,ans);\\n            for(int i=0;i<26;i++){\\n                count[i] += countadj[i];\\n            }\\n            }\\n        }\\n        ans[node] = count[labels[node]-\\'a\\'];\\n        return count;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adjl(n);\\n        for(auto edge:edges){\\n            adjl[edge[0]].push_back(edge[1]);\\n            adjl[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> ans(n,0);\\n        dfs(0,labels,adjl,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its argument `labels` by value which means `labels` gets copied many many times. Instead the function could take it by reference (`string& labels`) to avoid those unnecessary copies."
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "pass string labels with reference.\\n\\nlike -> string &labels"
                    },
                    {
                        "username": "patrickbies",
                        "content": "EDIT:  I solved the problem by passing a reference of the string in my dfs function instead of copying the string. \n\nHi, I am receiving a TLE on my code. I am just wondering where I can optimize it. believe it is O(N) traversal using O(1) operations. Maybe I could prune my search somewhere and not check every node. Idk suggestions are appreciated. Thanks\n\n<details>\n  <summary>Spoiler warning</summary>\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> adj;\n    vector<int> res;\n    \n    void dfs(int n, string l, int p, int* r) {\n        int pt = r[l[n] - 'a'];\n        r[l[n] - 'a']++;\n        \n        for (auto& a : adj[n]) {\n            if (a != p) {\n                dfs(a, l, n, r);\n            }\n        }\n\n        res[n] = r[l[n] - 'a'] - pt;\n    }\n\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        adj.resize(n);\n        res.resize(n);\n\n        for (auto& a : edges)\n            adj[a[0]].push_back(a[1]), adj[a[1]].push_back(a[0]);\n\n        int k[26] = {0};\n        dfs(0, labels, -1, k);\n        return res;\n    }\n};\n```\n</details>"
                    },
                    {
                        "username": "Narendra_027",
                        "content": "was doing same mistake"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Java Tip\\nBe careful with `map` `computeIfAbsent()` method\\nI used `graph.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);` during graph creation.\\nIt\\'s wrong because the second argument of `computeIfAbsent()` is a function which receives a map key as an argument. So, it uses `ArrayList(int initialCapacity)` constructor which waste huge amount of memory in case we have a lot of vertexes.\\nTo sum up, method reference does not always work obviously, to fix my issue I just changed above code to `graph.computeIfAbsent(edge[0], key -> new ArrayList<>()).add(edge[1])`;"
                    },
                    {
                        "username": "zebra-f",
                        "content": "`... and exactly n - 1 edges` is that information important? Can someone show me a tree that doesn't have n - 1 edges?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[deleted. sorry I responded to the wrong comment]"
                    },
                    {
                        "username": "harisriram2002",
                        "content": "Maybe just to troll us :p, so we will waste some time rethinking what we learnt about trees"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I think this question is little tough or maybe it\\'s just me who feels it"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "I think it is hard as well. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "yes it should be a hard problem, as the brute force solutions give tle "
                    },
                    {
                        "username": "Brut_all",
                        "content": "Hey can  anyone help me why my solution is producing TLE\\nEven chatGPT failed to correctly identify it.\\nI am using a  single vector of size 26 to store the occurances of the characters of the string and using dfs traversal to traverse the entire tree\\n\\n[Here\\'s my problem ](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876515427/)"
                    },
                    {
                        "username": "_ankit101",
                        "content": "[@Scresat](/Scresat) thanks!! it works"
                    },
                    {
                        "username": "kzo",
                        "content": "You are passing the string as a value, instead pass by reference, or make it global."
                    }
                ]
            },
            {
                "id": 1754228,
                "content": [
                    {
                        "username": "amadeus84",
                        "content": "I just submitted my solution and the submission fails on this input:\\n\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nHow is this even valid input? What\\'s the parent of 1? Also 2 has 2 parents. Two parents in a tree? That\\'s crazy.\\n"
                    },
                    {
                        "username": "DeadShot08112001AnshumanSINGH",
                        "content": "Edges are bidirectional . So,(1,2) and (2,1) both are valid edges.\\nIn sample testcases ,if you change [ai, bi] to [bi, ai],then answer still remains the same."
                    },
                    {
                        "username": "simulatte",
                        "content": "Yes it is weird but works if you consider [1, 2] as [2, 1]"
                    },
                    {
                        "username": "oxke",
                        "content": "I have a fundamental question about this problem.\nThis is, like yesterday's one, about an undirected tree, meaning a \"connected, undirected graph that has no cycles\". The definition the problem gives of 'subtree', essential for the solution of the problem, is \"A subtree of a tree T is the tree consisting of a node in T and all of its descendant nodes.\"\nNow, since the tree is undirected, what does it mean for a node to have a descendant? It means all the nodes I can get to with a path on the graph, but then this means all the nodes are reachable. Instead, if some nodes are descendants and one, just one is a parent, then the tree cannot be called undirected, there is a clear direction in the connection between two nodes."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Although informally we programmers like to think of trees as directed graphs with parents and children, in graph theory a \"tree\" is equivalent to a \"connected acyclic undirected graph\".  \nIn the context of this exercise \"subtree\" the node with index `0` is the root, and \"subtree\" can be inferred from that: All sub-nodes that can be reached from some \"node\" without going \"up\" to the parent."
                    },
                    {
                        "username": "space_invader",
                        "content": "![1519. Number of nodes in the sub tree with the same label.jpg](https://assets.leetcode.com/users/images/30547bf5-b00b-46df-a2be-823b1cb2f827_1673501984.7368417.jpeg)\\n"
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/9CbzRhXOql8\\n\\nA detailed video explanation with code.\\nApproach to optimized solution from a brute force solution is also discussed.\\n\\nThank You."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone please explain why is this TLE\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node,string labels,vector<vector<int>> &adjl,vector<int>& ans){\\n        ans[node] = 1;\\n        vector<int> count(26,0);\\n        count[labels[node]-\\'a\\'] = 1;\\n        for(auto child:adjl[node]){\\n            if(!ans[child]){\\n                vector<int> countadj = dfs(child,labels,adjl,ans);\\n            for(int i=0;i<26;i++){\\n                count[i] += countadj[i];\\n            }\\n            }\\n        }\\n        ans[node] = count[labels[node]-\\'a\\'];\\n        return count;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adjl(n);\\n        for(auto edge:edges){\\n            adjl[edge[0]].push_back(edge[1]);\\n            adjl[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> ans(n,0);\\n        dfs(0,labels,adjl,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its argument `labels` by value which means `labels` gets copied many many times. Instead the function could take it by reference (`string& labels`) to avoid those unnecessary copies."
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "pass string labels with reference.\\n\\nlike -> string &labels"
                    },
                    {
                        "username": "patrickbies",
                        "content": "EDIT:  I solved the problem by passing a reference of the string in my dfs function instead of copying the string. \n\nHi, I am receiving a TLE on my code. I am just wondering where I can optimize it. believe it is O(N) traversal using O(1) operations. Maybe I could prune my search somewhere and not check every node. Idk suggestions are appreciated. Thanks\n\n<details>\n  <summary>Spoiler warning</summary>\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> adj;\n    vector<int> res;\n    \n    void dfs(int n, string l, int p, int* r) {\n        int pt = r[l[n] - 'a'];\n        r[l[n] - 'a']++;\n        \n        for (auto& a : adj[n]) {\n            if (a != p) {\n                dfs(a, l, n, r);\n            }\n        }\n\n        res[n] = r[l[n] - 'a'] - pt;\n    }\n\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        adj.resize(n);\n        res.resize(n);\n\n        for (auto& a : edges)\n            adj[a[0]].push_back(a[1]), adj[a[1]].push_back(a[0]);\n\n        int k[26] = {0};\n        dfs(0, labels, -1, k);\n        return res;\n    }\n};\n```\n</details>"
                    },
                    {
                        "username": "Narendra_027",
                        "content": "was doing same mistake"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Java Tip\\nBe careful with `map` `computeIfAbsent()` method\\nI used `graph.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);` during graph creation.\\nIt\\'s wrong because the second argument of `computeIfAbsent()` is a function which receives a map key as an argument. So, it uses `ArrayList(int initialCapacity)` constructor which waste huge amount of memory in case we have a lot of vertexes.\\nTo sum up, method reference does not always work obviously, to fix my issue I just changed above code to `graph.computeIfAbsent(edge[0], key -> new ArrayList<>()).add(edge[1])`;"
                    },
                    {
                        "username": "zebra-f",
                        "content": "`... and exactly n - 1 edges` is that information important? Can someone show me a tree that doesn't have n - 1 edges?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[deleted. sorry I responded to the wrong comment]"
                    },
                    {
                        "username": "harisriram2002",
                        "content": "Maybe just to troll us :p, so we will waste some time rethinking what we learnt about trees"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I think this question is little tough or maybe it\\'s just me who feels it"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "I think it is hard as well. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "yes it should be a hard problem, as the brute force solutions give tle "
                    },
                    {
                        "username": "Brut_all",
                        "content": "Hey can  anyone help me why my solution is producing TLE\\nEven chatGPT failed to correctly identify it.\\nI am using a  single vector of size 26 to store the occurances of the characters of the string and using dfs traversal to traverse the entire tree\\n\\n[Here\\'s my problem ](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876515427/)"
                    },
                    {
                        "username": "_ankit101",
                        "content": "[@Scresat](/Scresat) thanks!! it works"
                    },
                    {
                        "username": "kzo",
                        "content": "You are passing the string as a value, instead pass by reference, or make it global."
                    }
                ]
            },
            {
                "id": 1754200,
                "content": [
                    {
                        "username": "amadeus84",
                        "content": "I just submitted my solution and the submission fails on this input:\\n\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nHow is this even valid input? What\\'s the parent of 1? Also 2 has 2 parents. Two parents in a tree? That\\'s crazy.\\n"
                    },
                    {
                        "username": "DeadShot08112001AnshumanSINGH",
                        "content": "Edges are bidirectional . So,(1,2) and (2,1) both are valid edges.\\nIn sample testcases ,if you change [ai, bi] to [bi, ai],then answer still remains the same."
                    },
                    {
                        "username": "simulatte",
                        "content": "Yes it is weird but works if you consider [1, 2] as [2, 1]"
                    },
                    {
                        "username": "oxke",
                        "content": "I have a fundamental question about this problem.\nThis is, like yesterday's one, about an undirected tree, meaning a \"connected, undirected graph that has no cycles\". The definition the problem gives of 'subtree', essential for the solution of the problem, is \"A subtree of a tree T is the tree consisting of a node in T and all of its descendant nodes.\"\nNow, since the tree is undirected, what does it mean for a node to have a descendant? It means all the nodes I can get to with a path on the graph, but then this means all the nodes are reachable. Instead, if some nodes are descendants and one, just one is a parent, then the tree cannot be called undirected, there is a clear direction in the connection between two nodes."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Although informally we programmers like to think of trees as directed graphs with parents and children, in graph theory a \"tree\" is equivalent to a \"connected acyclic undirected graph\".  \nIn the context of this exercise \"subtree\" the node with index `0` is the root, and \"subtree\" can be inferred from that: All sub-nodes that can be reached from some \"node\" without going \"up\" to the parent."
                    },
                    {
                        "username": "space_invader",
                        "content": "![1519. Number of nodes in the sub tree with the same label.jpg](https://assets.leetcode.com/users/images/30547bf5-b00b-46df-a2be-823b1cb2f827_1673501984.7368417.jpeg)\\n"
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/9CbzRhXOql8\\n\\nA detailed video explanation with code.\\nApproach to optimized solution from a brute force solution is also discussed.\\n\\nThank You."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone please explain why is this TLE\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node,string labels,vector<vector<int>> &adjl,vector<int>& ans){\\n        ans[node] = 1;\\n        vector<int> count(26,0);\\n        count[labels[node]-\\'a\\'] = 1;\\n        for(auto child:adjl[node]){\\n            if(!ans[child]){\\n                vector<int> countadj = dfs(child,labels,adjl,ans);\\n            for(int i=0;i<26;i++){\\n                count[i] += countadj[i];\\n            }\\n            }\\n        }\\n        ans[node] = count[labels[node]-\\'a\\'];\\n        return count;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adjl(n);\\n        for(auto edge:edges){\\n            adjl[edge[0]].push_back(edge[1]);\\n            adjl[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> ans(n,0);\\n        dfs(0,labels,adjl,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its argument `labels` by value which means `labels` gets copied many many times. Instead the function could take it by reference (`string& labels`) to avoid those unnecessary copies."
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "pass string labels with reference.\\n\\nlike -> string &labels"
                    },
                    {
                        "username": "patrickbies",
                        "content": "EDIT:  I solved the problem by passing a reference of the string in my dfs function instead of copying the string. \n\nHi, I am receiving a TLE on my code. I am just wondering where I can optimize it. believe it is O(N) traversal using O(1) operations. Maybe I could prune my search somewhere and not check every node. Idk suggestions are appreciated. Thanks\n\n<details>\n  <summary>Spoiler warning</summary>\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> adj;\n    vector<int> res;\n    \n    void dfs(int n, string l, int p, int* r) {\n        int pt = r[l[n] - 'a'];\n        r[l[n] - 'a']++;\n        \n        for (auto& a : adj[n]) {\n            if (a != p) {\n                dfs(a, l, n, r);\n            }\n        }\n\n        res[n] = r[l[n] - 'a'] - pt;\n    }\n\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        adj.resize(n);\n        res.resize(n);\n\n        for (auto& a : edges)\n            adj[a[0]].push_back(a[1]), adj[a[1]].push_back(a[0]);\n\n        int k[26] = {0};\n        dfs(0, labels, -1, k);\n        return res;\n    }\n};\n```\n</details>"
                    },
                    {
                        "username": "Narendra_027",
                        "content": "was doing same mistake"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Java Tip\\nBe careful with `map` `computeIfAbsent()` method\\nI used `graph.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);` during graph creation.\\nIt\\'s wrong because the second argument of `computeIfAbsent()` is a function which receives a map key as an argument. So, it uses `ArrayList(int initialCapacity)` constructor which waste huge amount of memory in case we have a lot of vertexes.\\nTo sum up, method reference does not always work obviously, to fix my issue I just changed above code to `graph.computeIfAbsent(edge[0], key -> new ArrayList<>()).add(edge[1])`;"
                    },
                    {
                        "username": "zebra-f",
                        "content": "`... and exactly n - 1 edges` is that information important? Can someone show me a tree that doesn't have n - 1 edges?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[deleted. sorry I responded to the wrong comment]"
                    },
                    {
                        "username": "harisriram2002",
                        "content": "Maybe just to troll us :p, so we will waste some time rethinking what we learnt about trees"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I think this question is little tough or maybe it\\'s just me who feels it"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "I think it is hard as well. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "yes it should be a hard problem, as the brute force solutions give tle "
                    },
                    {
                        "username": "Brut_all",
                        "content": "Hey can  anyone help me why my solution is producing TLE\\nEven chatGPT failed to correctly identify it.\\nI am using a  single vector of size 26 to store the occurances of the characters of the string and using dfs traversal to traverse the entire tree\\n\\n[Here\\'s my problem ](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876515427/)"
                    },
                    {
                        "username": "_ankit101",
                        "content": "[@Scresat](/Scresat) thanks!! it works"
                    },
                    {
                        "username": "kzo",
                        "content": "You are passing the string as a value, instead pass by reference, or make it global."
                    }
                ]
            },
            {
                "id": 1753923,
                "content": [
                    {
                        "username": "amadeus84",
                        "content": "I just submitted my solution and the submission fails on this input:\\n\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nHow is this even valid input? What\\'s the parent of 1? Also 2 has 2 parents. Two parents in a tree? That\\'s crazy.\\n"
                    },
                    {
                        "username": "DeadShot08112001AnshumanSINGH",
                        "content": "Edges are bidirectional . So,(1,2) and (2,1) both are valid edges.\\nIn sample testcases ,if you change [ai, bi] to [bi, ai],then answer still remains the same."
                    },
                    {
                        "username": "simulatte",
                        "content": "Yes it is weird but works if you consider [1, 2] as [2, 1]"
                    },
                    {
                        "username": "oxke",
                        "content": "I have a fundamental question about this problem.\nThis is, like yesterday's one, about an undirected tree, meaning a \"connected, undirected graph that has no cycles\". The definition the problem gives of 'subtree', essential for the solution of the problem, is \"A subtree of a tree T is the tree consisting of a node in T and all of its descendant nodes.\"\nNow, since the tree is undirected, what does it mean for a node to have a descendant? It means all the nodes I can get to with a path on the graph, but then this means all the nodes are reachable. Instead, if some nodes are descendants and one, just one is a parent, then the tree cannot be called undirected, there is a clear direction in the connection between two nodes."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Although informally we programmers like to think of trees as directed graphs with parents and children, in graph theory a \"tree\" is equivalent to a \"connected acyclic undirected graph\".  \nIn the context of this exercise \"subtree\" the node with index `0` is the root, and \"subtree\" can be inferred from that: All sub-nodes that can be reached from some \"node\" without going \"up\" to the parent."
                    },
                    {
                        "username": "space_invader",
                        "content": "![1519. Number of nodes in the sub tree with the same label.jpg](https://assets.leetcode.com/users/images/30547bf5-b00b-46df-a2be-823b1cb2f827_1673501984.7368417.jpeg)\\n"
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/9CbzRhXOql8\\n\\nA detailed video explanation with code.\\nApproach to optimized solution from a brute force solution is also discussed.\\n\\nThank You."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone please explain why is this TLE\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node,string labels,vector<vector<int>> &adjl,vector<int>& ans){\\n        ans[node] = 1;\\n        vector<int> count(26,0);\\n        count[labels[node]-\\'a\\'] = 1;\\n        for(auto child:adjl[node]){\\n            if(!ans[child]){\\n                vector<int> countadj = dfs(child,labels,adjl,ans);\\n            for(int i=0;i<26;i++){\\n                count[i] += countadj[i];\\n            }\\n            }\\n        }\\n        ans[node] = count[labels[node]-\\'a\\'];\\n        return count;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adjl(n);\\n        for(auto edge:edges){\\n            adjl[edge[0]].push_back(edge[1]);\\n            adjl[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> ans(n,0);\\n        dfs(0,labels,adjl,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its argument `labels` by value which means `labels` gets copied many many times. Instead the function could take it by reference (`string& labels`) to avoid those unnecessary copies."
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "pass string labels with reference.\\n\\nlike -> string &labels"
                    },
                    {
                        "username": "patrickbies",
                        "content": "EDIT:  I solved the problem by passing a reference of the string in my dfs function instead of copying the string. \n\nHi, I am receiving a TLE on my code. I am just wondering where I can optimize it. believe it is O(N) traversal using O(1) operations. Maybe I could prune my search somewhere and not check every node. Idk suggestions are appreciated. Thanks\n\n<details>\n  <summary>Spoiler warning</summary>\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> adj;\n    vector<int> res;\n    \n    void dfs(int n, string l, int p, int* r) {\n        int pt = r[l[n] - 'a'];\n        r[l[n] - 'a']++;\n        \n        for (auto& a : adj[n]) {\n            if (a != p) {\n                dfs(a, l, n, r);\n            }\n        }\n\n        res[n] = r[l[n] - 'a'] - pt;\n    }\n\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        adj.resize(n);\n        res.resize(n);\n\n        for (auto& a : edges)\n            adj[a[0]].push_back(a[1]), adj[a[1]].push_back(a[0]);\n\n        int k[26] = {0};\n        dfs(0, labels, -1, k);\n        return res;\n    }\n};\n```\n</details>"
                    },
                    {
                        "username": "Narendra_027",
                        "content": "was doing same mistake"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Java Tip\\nBe careful with `map` `computeIfAbsent()` method\\nI used `graph.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);` during graph creation.\\nIt\\'s wrong because the second argument of `computeIfAbsent()` is a function which receives a map key as an argument. So, it uses `ArrayList(int initialCapacity)` constructor which waste huge amount of memory in case we have a lot of vertexes.\\nTo sum up, method reference does not always work obviously, to fix my issue I just changed above code to `graph.computeIfAbsent(edge[0], key -> new ArrayList<>()).add(edge[1])`;"
                    },
                    {
                        "username": "zebra-f",
                        "content": "`... and exactly n - 1 edges` is that information important? Can someone show me a tree that doesn't have n - 1 edges?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[deleted. sorry I responded to the wrong comment]"
                    },
                    {
                        "username": "harisriram2002",
                        "content": "Maybe just to troll us :p, so we will waste some time rethinking what we learnt about trees"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I think this question is little tough or maybe it\\'s just me who feels it"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "I think it is hard as well. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "yes it should be a hard problem, as the brute force solutions give tle "
                    },
                    {
                        "username": "Brut_all",
                        "content": "Hey can  anyone help me why my solution is producing TLE\\nEven chatGPT failed to correctly identify it.\\nI am using a  single vector of size 26 to store the occurances of the characters of the string and using dfs traversal to traverse the entire tree\\n\\n[Here\\'s my problem ](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876515427/)"
                    },
                    {
                        "username": "_ankit101",
                        "content": "[@Scresat](/Scresat) thanks!! it works"
                    },
                    {
                        "username": "kzo",
                        "content": "You are passing the string as a value, instead pass by reference, or make it global."
                    }
                ]
            },
            {
                "id": 1753530,
                "content": [
                    {
                        "username": "amadeus84",
                        "content": "I just submitted my solution and the submission fails on this input:\\n\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nHow is this even valid input? What\\'s the parent of 1? Also 2 has 2 parents. Two parents in a tree? That\\'s crazy.\\n"
                    },
                    {
                        "username": "DeadShot08112001AnshumanSINGH",
                        "content": "Edges are bidirectional . So,(1,2) and (2,1) both are valid edges.\\nIn sample testcases ,if you change [ai, bi] to [bi, ai],then answer still remains the same."
                    },
                    {
                        "username": "simulatte",
                        "content": "Yes it is weird but works if you consider [1, 2] as [2, 1]"
                    },
                    {
                        "username": "oxke",
                        "content": "I have a fundamental question about this problem.\nThis is, like yesterday's one, about an undirected tree, meaning a \"connected, undirected graph that has no cycles\". The definition the problem gives of 'subtree', essential for the solution of the problem, is \"A subtree of a tree T is the tree consisting of a node in T and all of its descendant nodes.\"\nNow, since the tree is undirected, what does it mean for a node to have a descendant? It means all the nodes I can get to with a path on the graph, but then this means all the nodes are reachable. Instead, if some nodes are descendants and one, just one is a parent, then the tree cannot be called undirected, there is a clear direction in the connection between two nodes."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Although informally we programmers like to think of trees as directed graphs with parents and children, in graph theory a \"tree\" is equivalent to a \"connected acyclic undirected graph\".  \nIn the context of this exercise \"subtree\" the node with index `0` is the root, and \"subtree\" can be inferred from that: All sub-nodes that can be reached from some \"node\" without going \"up\" to the parent."
                    },
                    {
                        "username": "space_invader",
                        "content": "![1519. Number of nodes in the sub tree with the same label.jpg](https://assets.leetcode.com/users/images/30547bf5-b00b-46df-a2be-823b1cb2f827_1673501984.7368417.jpeg)\\n"
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/9CbzRhXOql8\\n\\nA detailed video explanation with code.\\nApproach to optimized solution from a brute force solution is also discussed.\\n\\nThank You."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone please explain why is this TLE\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node,string labels,vector<vector<int>> &adjl,vector<int>& ans){\\n        ans[node] = 1;\\n        vector<int> count(26,0);\\n        count[labels[node]-\\'a\\'] = 1;\\n        for(auto child:adjl[node]){\\n            if(!ans[child]){\\n                vector<int> countadj = dfs(child,labels,adjl,ans);\\n            for(int i=0;i<26;i++){\\n                count[i] += countadj[i];\\n            }\\n            }\\n        }\\n        ans[node] = count[labels[node]-\\'a\\'];\\n        return count;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adjl(n);\\n        for(auto edge:edges){\\n            adjl[edge[0]].push_back(edge[1]);\\n            adjl[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> ans(n,0);\\n        dfs(0,labels,adjl,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its argument `labels` by value which means `labels` gets copied many many times. Instead the function could take it by reference (`string& labels`) to avoid those unnecessary copies."
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "pass string labels with reference.\\n\\nlike -> string &labels"
                    },
                    {
                        "username": "patrickbies",
                        "content": "EDIT:  I solved the problem by passing a reference of the string in my dfs function instead of copying the string. \n\nHi, I am receiving a TLE on my code. I am just wondering where I can optimize it. believe it is O(N) traversal using O(1) operations. Maybe I could prune my search somewhere and not check every node. Idk suggestions are appreciated. Thanks\n\n<details>\n  <summary>Spoiler warning</summary>\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> adj;\n    vector<int> res;\n    \n    void dfs(int n, string l, int p, int* r) {\n        int pt = r[l[n] - 'a'];\n        r[l[n] - 'a']++;\n        \n        for (auto& a : adj[n]) {\n            if (a != p) {\n                dfs(a, l, n, r);\n            }\n        }\n\n        res[n] = r[l[n] - 'a'] - pt;\n    }\n\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        adj.resize(n);\n        res.resize(n);\n\n        for (auto& a : edges)\n            adj[a[0]].push_back(a[1]), adj[a[1]].push_back(a[0]);\n\n        int k[26] = {0};\n        dfs(0, labels, -1, k);\n        return res;\n    }\n};\n```\n</details>"
                    },
                    {
                        "username": "Narendra_027",
                        "content": "was doing same mistake"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Java Tip\\nBe careful with `map` `computeIfAbsent()` method\\nI used `graph.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);` during graph creation.\\nIt\\'s wrong because the second argument of `computeIfAbsent()` is a function which receives a map key as an argument. So, it uses `ArrayList(int initialCapacity)` constructor which waste huge amount of memory in case we have a lot of vertexes.\\nTo sum up, method reference does not always work obviously, to fix my issue I just changed above code to `graph.computeIfAbsent(edge[0], key -> new ArrayList<>()).add(edge[1])`;"
                    },
                    {
                        "username": "zebra-f",
                        "content": "`... and exactly n - 1 edges` is that information important? Can someone show me a tree that doesn't have n - 1 edges?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[deleted. sorry I responded to the wrong comment]"
                    },
                    {
                        "username": "harisriram2002",
                        "content": "Maybe just to troll us :p, so we will waste some time rethinking what we learnt about trees"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I think this question is little tough or maybe it\\'s just me who feels it"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "I think it is hard as well. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "yes it should be a hard problem, as the brute force solutions give tle "
                    },
                    {
                        "username": "Brut_all",
                        "content": "Hey can  anyone help me why my solution is producing TLE\\nEven chatGPT failed to correctly identify it.\\nI am using a  single vector of size 26 to store the occurances of the characters of the string and using dfs traversal to traverse the entire tree\\n\\n[Here\\'s my problem ](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876515427/)"
                    },
                    {
                        "username": "_ankit101",
                        "content": "[@Scresat](/Scresat) thanks!! it works"
                    },
                    {
                        "username": "kzo",
                        "content": "You are passing the string as a value, instead pass by reference, or make it global."
                    }
                ]
            },
            {
                "id": 1753523,
                "content": [
                    {
                        "username": "amadeus84",
                        "content": "I just submitted my solution and the submission fails on this input:\\n\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\n\\nHow is this even valid input? What\\'s the parent of 1? Also 2 has 2 parents. Two parents in a tree? That\\'s crazy.\\n"
                    },
                    {
                        "username": "DeadShot08112001AnshumanSINGH",
                        "content": "Edges are bidirectional . So,(1,2) and (2,1) both are valid edges.\\nIn sample testcases ,if you change [ai, bi] to [bi, ai],then answer still remains the same."
                    },
                    {
                        "username": "simulatte",
                        "content": "Yes it is weird but works if you consider [1, 2] as [2, 1]"
                    },
                    {
                        "username": "oxke",
                        "content": "I have a fundamental question about this problem.\nThis is, like yesterday's one, about an undirected tree, meaning a \"connected, undirected graph that has no cycles\". The definition the problem gives of 'subtree', essential for the solution of the problem, is \"A subtree of a tree T is the tree consisting of a node in T and all of its descendant nodes.\"\nNow, since the tree is undirected, what does it mean for a node to have a descendant? It means all the nodes I can get to with a path on the graph, but then this means all the nodes are reachable. Instead, if some nodes are descendants and one, just one is a parent, then the tree cannot be called undirected, there is a clear direction in the connection between two nodes."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Although informally we programmers like to think of trees as directed graphs with parents and children, in graph theory a \"tree\" is equivalent to a \"connected acyclic undirected graph\".  \nIn the context of this exercise \"subtree\" the node with index `0` is the root, and \"subtree\" can be inferred from that: All sub-nodes that can be reached from some \"node\" without going \"up\" to the parent."
                    },
                    {
                        "username": "space_invader",
                        "content": "![1519. Number of nodes in the sub tree with the same label.jpg](https://assets.leetcode.com/users/images/30547bf5-b00b-46df-a2be-823b1cb2f827_1673501984.7368417.jpeg)\\n"
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/9CbzRhXOql8\\n\\nA detailed video explanation with code.\\nApproach to optimized solution from a brute force solution is also discussed.\\n\\nThank You."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone please explain why is this TLE\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node,string labels,vector<vector<int>> &adjl,vector<int>& ans){\\n        ans[node] = 1;\\n        vector<int> count(26,0);\\n        count[labels[node]-\\'a\\'] = 1;\\n        for(auto child:adjl[node]){\\n            if(!ans[child]){\\n                vector<int> countadj = dfs(child,labels,adjl,ans);\\n            for(int i=0;i<26;i++){\\n                count[i] += countadj[i];\\n            }\\n            }\\n        }\\n        ans[node] = count[labels[node]-\\'a\\'];\\n        return count;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<vector<int>> adjl(n);\\n        for(auto edge:edges){\\n            adjl[edge[0]].push_back(edge[1]);\\n            adjl[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> ans(n,0);\\n        dfs(0,labels,adjl,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its argument `labels` by value which means `labels` gets copied many many times. Instead the function could take it by reference (`string& labels`) to avoid those unnecessary copies."
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "pass string labels with reference.\\n\\nlike -> string &labels"
                    },
                    {
                        "username": "patrickbies",
                        "content": "EDIT:  I solved the problem by passing a reference of the string in my dfs function instead of copying the string. \n\nHi, I am receiving a TLE on my code. I am just wondering where I can optimize it. believe it is O(N) traversal using O(1) operations. Maybe I could prune my search somewhere and not check every node. Idk suggestions are appreciated. Thanks\n\n<details>\n  <summary>Spoiler warning</summary>\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> adj;\n    vector<int> res;\n    \n    void dfs(int n, string l, int p, int* r) {\n        int pt = r[l[n] - 'a'];\n        r[l[n] - 'a']++;\n        \n        for (auto& a : adj[n]) {\n            if (a != p) {\n                dfs(a, l, n, r);\n            }\n        }\n\n        res[n] = r[l[n] - 'a'] - pt;\n    }\n\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        adj.resize(n);\n        res.resize(n);\n\n        for (auto& a : edges)\n            adj[a[0]].push_back(a[1]), adj[a[1]].push_back(a[0]);\n\n        int k[26] = {0};\n        dfs(0, labels, -1, k);\n        return res;\n    }\n};\n```\n</details>"
                    },
                    {
                        "username": "Narendra_027",
                        "content": "was doing same mistake"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Java Tip\\nBe careful with `map` `computeIfAbsent()` method\\nI used `graph.computeIfAbsent(edge[0], ArrayList::new).add(edge[1]);` during graph creation.\\nIt\\'s wrong because the second argument of `computeIfAbsent()` is a function which receives a map key as an argument. So, it uses `ArrayList(int initialCapacity)` constructor which waste huge amount of memory in case we have a lot of vertexes.\\nTo sum up, method reference does not always work obviously, to fix my issue I just changed above code to `graph.computeIfAbsent(edge[0], key -> new ArrayList<>()).add(edge[1])`;"
                    },
                    {
                        "username": "zebra-f",
                        "content": "`... and exactly n - 1 edges` is that information important? Can someone show me a tree that doesn't have n - 1 edges?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[deleted. sorry I responded to the wrong comment]"
                    },
                    {
                        "username": "harisriram2002",
                        "content": "Maybe just to troll us :p, so we will waste some time rethinking what we learnt about trees"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I think this question is little tough or maybe it\\'s just me who feels it"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "I think it is hard as well. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "yes it should be a hard problem, as the brute force solutions give tle "
                    },
                    {
                        "username": "Brut_all",
                        "content": "Hey can  anyone help me why my solution is producing TLE\\nEven chatGPT failed to correctly identify it.\\nI am using a  single vector of size 26 to store the occurances of the characters of the string and using dfs traversal to traverse the entire tree\\n\\n[Here\\'s my problem ](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876515427/)"
                    },
                    {
                        "username": "_ankit101",
                        "content": "[@Scresat](/Scresat) thanks!! it works"
                    },
                    {
                        "username": "kzo",
                        "content": "You are passing the string as a value, instead pass by reference, or make it global."
                    }
                ]
            },
            {
                "id": 1753511,
                "content": [
                    {
                        "username": "devilsadv",
                        "content": "Why TLE on test case 57?\\nMy solution is almost the same as the official solution\\'s dfs method, in fact i go one step further and eliminate returning vector in the dfs function....\\nit\\'s an O(n) solution and not even O(26*n)"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Seems like LeetCode\\'s machine being slow & the time limit being too strict?"
                    },
                    {
                        "username": "Brut_all",
                        "content": "can you share your solution .Also I am facing the same error"
                    },
                    {
                        "username": "ganesh-utla",
                        "content": "For the test cases such as [[0,2],[0,3][1,2]], you really don\\'t need any visited list to check whether the current node is already visited or not. Instead, check that the parent and child of the current node are not the same."
                    },
                    {
                        "username": "BristolJ",
                        "content": "More trees?! "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Whoever wrote the problem description needs to work on the writing. This seems to be the same person who wrote yesterday\\'s problem for picking apples from a tree.  Each sentence is so dense, and the use of notations is quite loose. I had a hard time trying to understand what the problem was asking until I looked at the examples. ChatGPT can write something 1000x more human readable than this."
                    },
                    {
                        "username": "user8228j",
                        "content": "It is a bit confusing, but it does make sense when you look at the examples as you said. In a real interview setting its your responsibility to make all the constraints clear so I don\\'t think asking for someone to look at all the examples is too much."
                    },
                    {
                        "username": "quan_mai",
                        "content": "Yeah he/she instead just asks ChatGPT to do the write up"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@aleckerrigan](/aleckerrigan) Exactly! That makes more sense."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I asked ChatGPT to do just that, heres what I got\\n\\nYou are given a tree with n nodes, labeled with lowercase letters, and n-1 edges connecting the nodes. The tree has a root node labeled \\'0\\'. You have to return an array of size n, where the ith element of the array is the number of nodes in the subtree of node i that have the same label as node i."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "solve the problem\\nafter a month came back to re-submit to get my daily -> TLE 58/60"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Moral of the day: Do not use sets when the no. of possible values is limited instead use boolean[] it is way faster. P.S. I used set for keeping track of visited nodes, took me days to detect my mistake"
                    },
                    {
                        "username": "Nickqw",
                        "content": "If the label is a number of [1,n] instead\\uFF0Cthen we should how to do it."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video : https://youtu.be/1-lsewXAu1k"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This definitely feels like a harder DFS type problem just because of the multiple children sub counts you need to track. Not a straight forward bottom up DFS."
                    },
                    {
                        "username": "santoshusa2016",
                        "content": "this is definitely not a medium complexity problem. It should be hard."
                    }
                ]
            },
            {
                "id": 1753461,
                "content": [
                    {
                        "username": "devilsadv",
                        "content": "Why TLE on test case 57?\\nMy solution is almost the same as the official solution\\'s dfs method, in fact i go one step further and eliminate returning vector in the dfs function....\\nit\\'s an O(n) solution and not even O(26*n)"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Seems like LeetCode\\'s machine being slow & the time limit being too strict?"
                    },
                    {
                        "username": "Brut_all",
                        "content": "can you share your solution .Also I am facing the same error"
                    },
                    {
                        "username": "ganesh-utla",
                        "content": "For the test cases such as [[0,2],[0,3][1,2]], you really don\\'t need any visited list to check whether the current node is already visited or not. Instead, check that the parent and child of the current node are not the same."
                    },
                    {
                        "username": "BristolJ",
                        "content": "More trees?! "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Whoever wrote the problem description needs to work on the writing. This seems to be the same person who wrote yesterday\\'s problem for picking apples from a tree.  Each sentence is so dense, and the use of notations is quite loose. I had a hard time trying to understand what the problem was asking until I looked at the examples. ChatGPT can write something 1000x more human readable than this."
                    },
                    {
                        "username": "user8228j",
                        "content": "It is a bit confusing, but it does make sense when you look at the examples as you said. In a real interview setting its your responsibility to make all the constraints clear so I don\\'t think asking for someone to look at all the examples is too much."
                    },
                    {
                        "username": "quan_mai",
                        "content": "Yeah he/she instead just asks ChatGPT to do the write up"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@aleckerrigan](/aleckerrigan) Exactly! That makes more sense."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I asked ChatGPT to do just that, heres what I got\\n\\nYou are given a tree with n nodes, labeled with lowercase letters, and n-1 edges connecting the nodes. The tree has a root node labeled \\'0\\'. You have to return an array of size n, where the ith element of the array is the number of nodes in the subtree of node i that have the same label as node i."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "solve the problem\\nafter a month came back to re-submit to get my daily -> TLE 58/60"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Moral of the day: Do not use sets when the no. of possible values is limited instead use boolean[] it is way faster. P.S. I used set for keeping track of visited nodes, took me days to detect my mistake"
                    },
                    {
                        "username": "Nickqw",
                        "content": "If the label is a number of [1,n] instead\\uFF0Cthen we should how to do it."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video : https://youtu.be/1-lsewXAu1k"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This definitely feels like a harder DFS type problem just because of the multiple children sub counts you need to track. Not a straight forward bottom up DFS."
                    },
                    {
                        "username": "santoshusa2016",
                        "content": "this is definitely not a medium complexity problem. It should be hard."
                    }
                ]
            },
            {
                "id": 1753348,
                "content": [
                    {
                        "username": "devilsadv",
                        "content": "Why TLE on test case 57?\\nMy solution is almost the same as the official solution\\'s dfs method, in fact i go one step further and eliminate returning vector in the dfs function....\\nit\\'s an O(n) solution and not even O(26*n)"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Seems like LeetCode\\'s machine being slow & the time limit being too strict?"
                    },
                    {
                        "username": "Brut_all",
                        "content": "can you share your solution .Also I am facing the same error"
                    },
                    {
                        "username": "ganesh-utla",
                        "content": "For the test cases such as [[0,2],[0,3][1,2]], you really don\\'t need any visited list to check whether the current node is already visited or not. Instead, check that the parent and child of the current node are not the same."
                    },
                    {
                        "username": "BristolJ",
                        "content": "More trees?! "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Whoever wrote the problem description needs to work on the writing. This seems to be the same person who wrote yesterday\\'s problem for picking apples from a tree.  Each sentence is so dense, and the use of notations is quite loose. I had a hard time trying to understand what the problem was asking until I looked at the examples. ChatGPT can write something 1000x more human readable than this."
                    },
                    {
                        "username": "user8228j",
                        "content": "It is a bit confusing, but it does make sense when you look at the examples as you said. In a real interview setting its your responsibility to make all the constraints clear so I don\\'t think asking for someone to look at all the examples is too much."
                    },
                    {
                        "username": "quan_mai",
                        "content": "Yeah he/she instead just asks ChatGPT to do the write up"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@aleckerrigan](/aleckerrigan) Exactly! That makes more sense."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I asked ChatGPT to do just that, heres what I got\\n\\nYou are given a tree with n nodes, labeled with lowercase letters, and n-1 edges connecting the nodes. The tree has a root node labeled \\'0\\'. You have to return an array of size n, where the ith element of the array is the number of nodes in the subtree of node i that have the same label as node i."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "solve the problem\\nafter a month came back to re-submit to get my daily -> TLE 58/60"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Moral of the day: Do not use sets when the no. of possible values is limited instead use boolean[] it is way faster. P.S. I used set for keeping track of visited nodes, took me days to detect my mistake"
                    },
                    {
                        "username": "Nickqw",
                        "content": "If the label is a number of [1,n] instead\\uFF0Cthen we should how to do it."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video : https://youtu.be/1-lsewXAu1k"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This definitely feels like a harder DFS type problem just because of the multiple children sub counts you need to track. Not a straight forward bottom up DFS."
                    },
                    {
                        "username": "santoshusa2016",
                        "content": "this is definitely not a medium complexity problem. It should be hard."
                    }
                ]
            },
            {
                "id": 1753387,
                "content": [
                    {
                        "username": "devilsadv",
                        "content": "Why TLE on test case 57?\\nMy solution is almost the same as the official solution\\'s dfs method, in fact i go one step further and eliminate returning vector in the dfs function....\\nit\\'s an O(n) solution and not even O(26*n)"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Seems like LeetCode\\'s machine being slow & the time limit being too strict?"
                    },
                    {
                        "username": "Brut_all",
                        "content": "can you share your solution .Also I am facing the same error"
                    },
                    {
                        "username": "ganesh-utla",
                        "content": "For the test cases such as [[0,2],[0,3][1,2]], you really don\\'t need any visited list to check whether the current node is already visited or not. Instead, check that the parent and child of the current node are not the same."
                    },
                    {
                        "username": "BristolJ",
                        "content": "More trees?! "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Whoever wrote the problem description needs to work on the writing. This seems to be the same person who wrote yesterday\\'s problem for picking apples from a tree.  Each sentence is so dense, and the use of notations is quite loose. I had a hard time trying to understand what the problem was asking until I looked at the examples. ChatGPT can write something 1000x more human readable than this."
                    },
                    {
                        "username": "user8228j",
                        "content": "It is a bit confusing, but it does make sense when you look at the examples as you said. In a real interview setting its your responsibility to make all the constraints clear so I don\\'t think asking for someone to look at all the examples is too much."
                    },
                    {
                        "username": "quan_mai",
                        "content": "Yeah he/she instead just asks ChatGPT to do the write up"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@aleckerrigan](/aleckerrigan) Exactly! That makes more sense."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I asked ChatGPT to do just that, heres what I got\\n\\nYou are given a tree with n nodes, labeled with lowercase letters, and n-1 edges connecting the nodes. The tree has a root node labeled \\'0\\'. You have to return an array of size n, where the ith element of the array is the number of nodes in the subtree of node i that have the same label as node i."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "solve the problem\\nafter a month came back to re-submit to get my daily -> TLE 58/60"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Moral of the day: Do not use sets when the no. of possible values is limited instead use boolean[] it is way faster. P.S. I used set for keeping track of visited nodes, took me days to detect my mistake"
                    },
                    {
                        "username": "Nickqw",
                        "content": "If the label is a number of [1,n] instead\\uFF0Cthen we should how to do it."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video : https://youtu.be/1-lsewXAu1k"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This definitely feels like a harder DFS type problem just because of the multiple children sub counts you need to track. Not a straight forward bottom up DFS."
                    },
                    {
                        "username": "santoshusa2016",
                        "content": "this is definitely not a medium complexity problem. It should be hard."
                    }
                ]
            },
            {
                "id": 1879515,
                "content": [
                    {
                        "username": "devilsadv",
                        "content": "Why TLE on test case 57?\\nMy solution is almost the same as the official solution\\'s dfs method, in fact i go one step further and eliminate returning vector in the dfs function....\\nit\\'s an O(n) solution and not even O(26*n)"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Seems like LeetCode\\'s machine being slow & the time limit being too strict?"
                    },
                    {
                        "username": "Brut_all",
                        "content": "can you share your solution .Also I am facing the same error"
                    },
                    {
                        "username": "ganesh-utla",
                        "content": "For the test cases such as [[0,2],[0,3][1,2]], you really don\\'t need any visited list to check whether the current node is already visited or not. Instead, check that the parent and child of the current node are not the same."
                    },
                    {
                        "username": "BristolJ",
                        "content": "More trees?! "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Whoever wrote the problem description needs to work on the writing. This seems to be the same person who wrote yesterday\\'s problem for picking apples from a tree.  Each sentence is so dense, and the use of notations is quite loose. I had a hard time trying to understand what the problem was asking until I looked at the examples. ChatGPT can write something 1000x more human readable than this."
                    },
                    {
                        "username": "user8228j",
                        "content": "It is a bit confusing, but it does make sense when you look at the examples as you said. In a real interview setting its your responsibility to make all the constraints clear so I don\\'t think asking for someone to look at all the examples is too much."
                    },
                    {
                        "username": "quan_mai",
                        "content": "Yeah he/she instead just asks ChatGPT to do the write up"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@aleckerrigan](/aleckerrigan) Exactly! That makes more sense."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I asked ChatGPT to do just that, heres what I got\\n\\nYou are given a tree with n nodes, labeled with lowercase letters, and n-1 edges connecting the nodes. The tree has a root node labeled \\'0\\'. You have to return an array of size n, where the ith element of the array is the number of nodes in the subtree of node i that have the same label as node i."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "solve the problem\\nafter a month came back to re-submit to get my daily -> TLE 58/60"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Moral of the day: Do not use sets when the no. of possible values is limited instead use boolean[] it is way faster. P.S. I used set for keeping track of visited nodes, took me days to detect my mistake"
                    },
                    {
                        "username": "Nickqw",
                        "content": "If the label is a number of [1,n] instead\\uFF0Cthen we should how to do it."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video : https://youtu.be/1-lsewXAu1k"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This definitely feels like a harder DFS type problem just because of the multiple children sub counts you need to track. Not a straight forward bottom up DFS."
                    },
                    {
                        "username": "santoshusa2016",
                        "content": "this is definitely not a medium complexity problem. It should be hard."
                    }
                ]
            },
            {
                "id": 1828363,
                "content": [
                    {
                        "username": "devilsadv",
                        "content": "Why TLE on test case 57?\\nMy solution is almost the same as the official solution\\'s dfs method, in fact i go one step further and eliminate returning vector in the dfs function....\\nit\\'s an O(n) solution and not even O(26*n)"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Seems like LeetCode\\'s machine being slow & the time limit being too strict?"
                    },
                    {
                        "username": "Brut_all",
                        "content": "can you share your solution .Also I am facing the same error"
                    },
                    {
                        "username": "ganesh-utla",
                        "content": "For the test cases such as [[0,2],[0,3][1,2]], you really don\\'t need any visited list to check whether the current node is already visited or not. Instead, check that the parent and child of the current node are not the same."
                    },
                    {
                        "username": "BristolJ",
                        "content": "More trees?! "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Whoever wrote the problem description needs to work on the writing. This seems to be the same person who wrote yesterday\\'s problem for picking apples from a tree.  Each sentence is so dense, and the use of notations is quite loose. I had a hard time trying to understand what the problem was asking until I looked at the examples. ChatGPT can write something 1000x more human readable than this."
                    },
                    {
                        "username": "user8228j",
                        "content": "It is a bit confusing, but it does make sense when you look at the examples as you said. In a real interview setting its your responsibility to make all the constraints clear so I don\\'t think asking for someone to look at all the examples is too much."
                    },
                    {
                        "username": "quan_mai",
                        "content": "Yeah he/she instead just asks ChatGPT to do the write up"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@aleckerrigan](/aleckerrigan) Exactly! That makes more sense."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I asked ChatGPT to do just that, heres what I got\\n\\nYou are given a tree with n nodes, labeled with lowercase letters, and n-1 edges connecting the nodes. The tree has a root node labeled \\'0\\'. You have to return an array of size n, where the ith element of the array is the number of nodes in the subtree of node i that have the same label as node i."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "solve the problem\\nafter a month came back to re-submit to get my daily -> TLE 58/60"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Moral of the day: Do not use sets when the no. of possible values is limited instead use boolean[] it is way faster. P.S. I used set for keeping track of visited nodes, took me days to detect my mistake"
                    },
                    {
                        "username": "Nickqw",
                        "content": "If the label is a number of [1,n] instead\\uFF0Cthen we should how to do it."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video : https://youtu.be/1-lsewXAu1k"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This definitely feels like a harder DFS type problem just because of the multiple children sub counts you need to track. Not a straight forward bottom up DFS."
                    },
                    {
                        "username": "santoshusa2016",
                        "content": "this is definitely not a medium complexity problem. It should be hard."
                    }
                ]
            },
            {
                "id": 1785237,
                "content": [
                    {
                        "username": "devilsadv",
                        "content": "Why TLE on test case 57?\\nMy solution is almost the same as the official solution\\'s dfs method, in fact i go one step further and eliminate returning vector in the dfs function....\\nit\\'s an O(n) solution and not even O(26*n)"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Seems like LeetCode\\'s machine being slow & the time limit being too strict?"
                    },
                    {
                        "username": "Brut_all",
                        "content": "can you share your solution .Also I am facing the same error"
                    },
                    {
                        "username": "ganesh-utla",
                        "content": "For the test cases such as [[0,2],[0,3][1,2]], you really don\\'t need any visited list to check whether the current node is already visited or not. Instead, check that the parent and child of the current node are not the same."
                    },
                    {
                        "username": "BristolJ",
                        "content": "More trees?! "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Whoever wrote the problem description needs to work on the writing. This seems to be the same person who wrote yesterday\\'s problem for picking apples from a tree.  Each sentence is so dense, and the use of notations is quite loose. I had a hard time trying to understand what the problem was asking until I looked at the examples. ChatGPT can write something 1000x more human readable than this."
                    },
                    {
                        "username": "user8228j",
                        "content": "It is a bit confusing, but it does make sense when you look at the examples as you said. In a real interview setting its your responsibility to make all the constraints clear so I don\\'t think asking for someone to look at all the examples is too much."
                    },
                    {
                        "username": "quan_mai",
                        "content": "Yeah he/she instead just asks ChatGPT to do the write up"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@aleckerrigan](/aleckerrigan) Exactly! That makes more sense."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I asked ChatGPT to do just that, heres what I got\\n\\nYou are given a tree with n nodes, labeled with lowercase letters, and n-1 edges connecting the nodes. The tree has a root node labeled \\'0\\'. You have to return an array of size n, where the ith element of the array is the number of nodes in the subtree of node i that have the same label as node i."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "solve the problem\\nafter a month came back to re-submit to get my daily -> TLE 58/60"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Moral of the day: Do not use sets when the no. of possible values is limited instead use boolean[] it is way faster. P.S. I used set for keeping track of visited nodes, took me days to detect my mistake"
                    },
                    {
                        "username": "Nickqw",
                        "content": "If the label is a number of [1,n] instead\\uFF0Cthen we should how to do it."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video : https://youtu.be/1-lsewXAu1k"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This definitely feels like a harder DFS type problem just because of the multiple children sub counts you need to track. Not a straight forward bottom up DFS."
                    },
                    {
                        "username": "santoshusa2016",
                        "content": "this is definitely not a medium complexity problem. It should be hard."
                    }
                ]
            },
            {
                "id": 1766917,
                "content": [
                    {
                        "username": "devilsadv",
                        "content": "Why TLE on test case 57?\\nMy solution is almost the same as the official solution\\'s dfs method, in fact i go one step further and eliminate returning vector in the dfs function....\\nit\\'s an O(n) solution and not even O(26*n)"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Seems like LeetCode\\'s machine being slow & the time limit being too strict?"
                    },
                    {
                        "username": "Brut_all",
                        "content": "can you share your solution .Also I am facing the same error"
                    },
                    {
                        "username": "ganesh-utla",
                        "content": "For the test cases such as [[0,2],[0,3][1,2]], you really don\\'t need any visited list to check whether the current node is already visited or not. Instead, check that the parent and child of the current node are not the same."
                    },
                    {
                        "username": "BristolJ",
                        "content": "More trees?! "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Whoever wrote the problem description needs to work on the writing. This seems to be the same person who wrote yesterday\\'s problem for picking apples from a tree.  Each sentence is so dense, and the use of notations is quite loose. I had a hard time trying to understand what the problem was asking until I looked at the examples. ChatGPT can write something 1000x more human readable than this."
                    },
                    {
                        "username": "user8228j",
                        "content": "It is a bit confusing, but it does make sense when you look at the examples as you said. In a real interview setting its your responsibility to make all the constraints clear so I don\\'t think asking for someone to look at all the examples is too much."
                    },
                    {
                        "username": "quan_mai",
                        "content": "Yeah he/she instead just asks ChatGPT to do the write up"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@aleckerrigan](/aleckerrigan) Exactly! That makes more sense."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I asked ChatGPT to do just that, heres what I got\\n\\nYou are given a tree with n nodes, labeled with lowercase letters, and n-1 edges connecting the nodes. The tree has a root node labeled \\'0\\'. You have to return an array of size n, where the ith element of the array is the number of nodes in the subtree of node i that have the same label as node i."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "solve the problem\\nafter a month came back to re-submit to get my daily -> TLE 58/60"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Moral of the day: Do not use sets when the no. of possible values is limited instead use boolean[] it is way faster. P.S. I used set for keeping track of visited nodes, took me days to detect my mistake"
                    },
                    {
                        "username": "Nickqw",
                        "content": "If the label is a number of [1,n] instead\\uFF0Cthen we should how to do it."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video : https://youtu.be/1-lsewXAu1k"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This definitely feels like a harder DFS type problem just because of the multiple children sub counts you need to track. Not a straight forward bottom up DFS."
                    },
                    {
                        "username": "santoshusa2016",
                        "content": "this is definitely not a medium complexity problem. It should be hard."
                    }
                ]
            },
            {
                "id": 1765350,
                "content": [
                    {
                        "username": "devilsadv",
                        "content": "Why TLE on test case 57?\\nMy solution is almost the same as the official solution\\'s dfs method, in fact i go one step further and eliminate returning vector in the dfs function....\\nit\\'s an O(n) solution and not even O(26*n)"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Seems like LeetCode\\'s machine being slow & the time limit being too strict?"
                    },
                    {
                        "username": "Brut_all",
                        "content": "can you share your solution .Also I am facing the same error"
                    },
                    {
                        "username": "ganesh-utla",
                        "content": "For the test cases such as [[0,2],[0,3][1,2]], you really don\\'t need any visited list to check whether the current node is already visited or not. Instead, check that the parent and child of the current node are not the same."
                    },
                    {
                        "username": "BristolJ",
                        "content": "More trees?! "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Whoever wrote the problem description needs to work on the writing. This seems to be the same person who wrote yesterday\\'s problem for picking apples from a tree.  Each sentence is so dense, and the use of notations is quite loose. I had a hard time trying to understand what the problem was asking until I looked at the examples. ChatGPT can write something 1000x more human readable than this."
                    },
                    {
                        "username": "user8228j",
                        "content": "It is a bit confusing, but it does make sense when you look at the examples as you said. In a real interview setting its your responsibility to make all the constraints clear so I don\\'t think asking for someone to look at all the examples is too much."
                    },
                    {
                        "username": "quan_mai",
                        "content": "Yeah he/she instead just asks ChatGPT to do the write up"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@aleckerrigan](/aleckerrigan) Exactly! That makes more sense."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I asked ChatGPT to do just that, heres what I got\\n\\nYou are given a tree with n nodes, labeled with lowercase letters, and n-1 edges connecting the nodes. The tree has a root node labeled \\'0\\'. You have to return an array of size n, where the ith element of the array is the number of nodes in the subtree of node i that have the same label as node i."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "solve the problem\\nafter a month came back to re-submit to get my daily -> TLE 58/60"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Moral of the day: Do not use sets when the no. of possible values is limited instead use boolean[] it is way faster. P.S. I used set for keeping track of visited nodes, took me days to detect my mistake"
                    },
                    {
                        "username": "Nickqw",
                        "content": "If the label is a number of [1,n] instead\\uFF0Cthen we should how to do it."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video : https://youtu.be/1-lsewXAu1k"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This definitely feels like a harder DFS type problem just because of the multiple children sub counts you need to track. Not a straight forward bottom up DFS."
                    },
                    {
                        "username": "santoshusa2016",
                        "content": "this is definitely not a medium complexity problem. It should be hard."
                    }
                ]
            },
            {
                "id": 1759438,
                "content": [
                    {
                        "username": "devilsadv",
                        "content": "Why TLE on test case 57?\\nMy solution is almost the same as the official solution\\'s dfs method, in fact i go one step further and eliminate returning vector in the dfs function....\\nit\\'s an O(n) solution and not even O(26*n)"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Seems like LeetCode\\'s machine being slow & the time limit being too strict?"
                    },
                    {
                        "username": "Brut_all",
                        "content": "can you share your solution .Also I am facing the same error"
                    },
                    {
                        "username": "ganesh-utla",
                        "content": "For the test cases such as [[0,2],[0,3][1,2]], you really don\\'t need any visited list to check whether the current node is already visited or not. Instead, check that the parent and child of the current node are not the same."
                    },
                    {
                        "username": "BristolJ",
                        "content": "More trees?! "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Whoever wrote the problem description needs to work on the writing. This seems to be the same person who wrote yesterday\\'s problem for picking apples from a tree.  Each sentence is so dense, and the use of notations is quite loose. I had a hard time trying to understand what the problem was asking until I looked at the examples. ChatGPT can write something 1000x more human readable than this."
                    },
                    {
                        "username": "user8228j",
                        "content": "It is a bit confusing, but it does make sense when you look at the examples as you said. In a real interview setting its your responsibility to make all the constraints clear so I don\\'t think asking for someone to look at all the examples is too much."
                    },
                    {
                        "username": "quan_mai",
                        "content": "Yeah he/she instead just asks ChatGPT to do the write up"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@aleckerrigan](/aleckerrigan) Exactly! That makes more sense."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I asked ChatGPT to do just that, heres what I got\\n\\nYou are given a tree with n nodes, labeled with lowercase letters, and n-1 edges connecting the nodes. The tree has a root node labeled \\'0\\'. You have to return an array of size n, where the ith element of the array is the number of nodes in the subtree of node i that have the same label as node i."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "solve the problem\\nafter a month came back to re-submit to get my daily -> TLE 58/60"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Moral of the day: Do not use sets when the no. of possible values is limited instead use boolean[] it is way faster. P.S. I used set for keeping track of visited nodes, took me days to detect my mistake"
                    },
                    {
                        "username": "Nickqw",
                        "content": "If the label is a number of [1,n] instead\\uFF0Cthen we should how to do it."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video : https://youtu.be/1-lsewXAu1k"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This definitely feels like a harder DFS type problem just because of the multiple children sub counts you need to track. Not a straight forward bottom up DFS."
                    },
                    {
                        "username": "santoshusa2016",
                        "content": "this is definitely not a medium complexity problem. It should be hard."
                    }
                ]
            },
            {
                "id": 1756328,
                "content": [
                    {
                        "username": "h3ct0r",
                        "content": "This should be a hard problem! A simple BFS will give timeout!"
                    },
                    {
                        "username": "prajapatkartik1",
                        "content": "Can anyone help me about why this solution is giving TLE. [Link to solution](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876692070/)\\nclass Solution {\\npublic:\\n    void sameLabel(int n,vector<vector<int>>& graph, vector<int>& ans, string labels, int source,vector<bool> parent,int pred){\\n        parent[source]=true;\\n        for(int i=0;i<graph[source].size();i++){\\n            if(graph[source][i]!=pred){\\n                sameLabel(n,graph,ans,labels,graph[source][i],parent,source);\\n            }\\n        }\\n        for(int i=0;i<parent.size();i++){\\n            if(parent[i]==true && labels[i]==labels[source]){\\n                ans[i]++;\\n            }\\n        }\\n        parent[source]=false;\\n        return;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        if(edges.size()==0){\\n            return {1};\\n        }\\n        vector<vector<int>> graph(n);\\n        vector<int> ans(n);\\n        vector<bool> parent(n,false);\\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        sameLabel(n,graph,ans,labels,0,parent,-1);\\n        return ans;\\n    }\\n};\\nTHe complecity is O(v+e) right ?"
                    },
                    {
                        "username": "yiwc63",
                        "content": "Hi, I'm now facing the TLE at testcase 59, and here's my solution below:\n\n\n```cpp=\nclass Solution {\npublic:\n    unordered_map<int, vector<int>> umap;\n    vector<int> ans;\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        for(int i=0; i<n; i++){\n            ans.push_back(0);\n        }\n        unordered_set<int> vertices;\n        vertices.insert(0);\n        for(auto edge:edges){\n            if(vertices.count(edge[0])==1){\n                umap[edge[0]].push_back(edge[1]);\n                vertices.insert(edge[1]);\n            }\n            else{\n                umap[edge[1]].push_back(edge[0]);\n                vertices.insert(edge[0]);\n            }  \n        }\n        vector<int> parents;\n        helper(parents, 0, labels);\n        return ans;\n    }\n    void helper(vector<int>& parents, int current, string& labels){\n        ans[current]++;\n        for(auto parent:parents){\n            if(labels[parent]==labels[current])\n                ans[parent]++;\n        }\n        if(umap.count(current)==0)\n            return;\n        parents.push_back(current);\n        for(auto child:umap[current]){\n            helper(parents, child, labels);\n        }\n        parents.pop_back();\n        return;\n    }\n};\n```\nI'm guessing it has something to do with the repeated record of parents, but im not quite so sure.\nAlso not sure if posting a not AC solution violates the rule, if so, ill take off the post ASAP, thks!"
                    },
                    {
                        "username": "Hazardouz",
                        "content": "Incase you are getting a tle, just make sure the necessary arguments you have passed is by reference and not by value. I was accidentally passing a vector by value causing tle. Good luck :)"
                    },
                    {
                        "username": "TuringJest",
                        "content": "Follow up:\\nNow solve it in linear time! "
                    },
                    {
                        "username": "user3197I",
                        "content": "Guys I am going crazy. Can someone please describe to me what is wrong with my solution? I debug and see the Integer count getting updated, but once the method returns back to main, the count resets to 0. Please help me out... I cannot anymore with this.\\n\\n```class Solution {\\n    private void dfs(int node, HashMap<Integer, ArrayList<Integer>> T, Integer count, char[] labels, char label) {\\n        if (labels[node] == label) {\\n            count += 1;\\n        }\\n\\n        ArrayList<Integer> children = T.getOrDefault(node, new ArrayList<>());\\n\\n        for (Integer child : children) {\\n            dfs(child, T, count, labels, label);\\n        }\\n    }\\n\\n\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        HashMap<Integer, ArrayList<Integer>> tree = new HashMap<>();\\n        for (int i = 0; i < edges.length; i++) { //making adjacency list\\n            ArrayList<Integer> children = tree.getOrDefault(edges[i][0], new ArrayList<>());\\n            children.add(edges[i][1]);\\n            tree.put(edges[i][0], children);\\n        }\\n\\n        int[] freq = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            Integer count = new Integer(0);\\n            dfs(i, tree, count, labels.toCharArray(), labels.charAt(i));\\n            freq[i] = count;\\n        }\\n\\n        return freq;\\n    }\\n}"
                    },
                    {
                        "username": "user8296H",
                        "content": "Great problem to practice recursion, DP and graphs!\\nI liked the idea of passing maps between sub trees and collecting them in the parent node.\\n\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "Sigh, why does Leetcode have to throw in cheap complexity by messing up the edge inputs. I feel like half of the difficulty is on properly parsing the edges and building a tree (and I am pretty sure I will trip on that in an actual interview)."
                    },
                    {
                        "username": "Michellead",
                        "content": "This is definitely not entirely a medium question, but it a great one.\\n\\nUse DFS for Traversal."
                    },
                    {
                        "username": "fortnighter",
                        "content": " I tried solving this problem by iterative method but still I am getting TLE in 58th test case. Can anyone help me how can I further optimize my code.\\n\\n class Solution {\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        int size = edges.size()+1;\\n        vector<vector<int>>vn(size);\\n\\n        for(auto a : edges){\\n            vn[a[0]].push_back(a[1]);\\n            vn[a[1]].push_back(a[0]);\\n        }\\n\\n        vector<int>ans(size, 0);\\n        vector<int>vis(size, 0);\\n\\n        vector<int>arr;\\n\\n        queue<int>qe;\\n        qe.push(0);\\n\\n        while(!qe.empty()){\\n            int y = qe.front();\\n            vis[y] = 1;\\n            arr.push_back(y);\\n            qe.pop();\\n            for(int a:vn[y]){\\n                if(!vis[a])qe.push(a);\\n            }\\n        }\\n\\n        vector<int>vis2(size, 0);\\n        unordered_map<char, int>mlp;\\n\\n        for(char i : labels){\\n            mlp[i]++;\\n            \\n        }\\n\\n        \\n\\n        int sz = arr.size();\\n\\n        unordered_map<int, unordered_map<char, int>>mp;\\n\\n        for(int i = arr.size()-1; i >= 0; i--){\\n            int rewq = arr[i];\\n            if(vn[rewq].size() == 1 & rewq != 0){\\n                unordered_map<char, int>mp1;\\n                mp1[labels[rewq]] = 1;\\n                mp[rewq] = mp1;\\n                ans[rewq] = 1;\\n                vis2[rewq] = 1;\\n            }else{\\n                int cnt = 1;\\n                char ch = labels[rewq];\\n                unordered_map<char, int>mpIn;\\n                mpIn[ch] = 1;\\n                for(int uyt : vn[rewq]){\\n                        if(vis2[uyt]){\\n                        unordered_map<char, int>mp1 = mp[uyt];\\n                        if(mp1.find(ch) != mp1.end())cnt += mp1[ch];\\n                        if(rewq != 0)\\n                        for(auto it = mlp.begin(); it != mlp.end(); it++){\\n                            char ch1 = it->first;\\n                            if(mp1.find(ch1) != mp1.end())mpIn[ch1] += mp1[ch1];\\n                        }\\n\\n                    }\\n                }\\n                mpIn[ch] = cnt;\\n                mp[rewq] = mpIn;\\n                ans[rewq] = mpIn[ch];\\n                vis2[rewq] = 1;\\n                \\n            }\\n            \\n            mlp[labels[rewq]] += -1;\\n            if(mlp[labels[rewq]] <= 0)mlp.erase(labels[rewq]);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1756237,
                "content": [
                    {
                        "username": "h3ct0r",
                        "content": "This should be a hard problem! A simple BFS will give timeout!"
                    },
                    {
                        "username": "prajapatkartik1",
                        "content": "Can anyone help me about why this solution is giving TLE. [Link to solution](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876692070/)\\nclass Solution {\\npublic:\\n    void sameLabel(int n,vector<vector<int>>& graph, vector<int>& ans, string labels, int source,vector<bool> parent,int pred){\\n        parent[source]=true;\\n        for(int i=0;i<graph[source].size();i++){\\n            if(graph[source][i]!=pred){\\n                sameLabel(n,graph,ans,labels,graph[source][i],parent,source);\\n            }\\n        }\\n        for(int i=0;i<parent.size();i++){\\n            if(parent[i]==true && labels[i]==labels[source]){\\n                ans[i]++;\\n            }\\n        }\\n        parent[source]=false;\\n        return;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        if(edges.size()==0){\\n            return {1};\\n        }\\n        vector<vector<int>> graph(n);\\n        vector<int> ans(n);\\n        vector<bool> parent(n,false);\\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        sameLabel(n,graph,ans,labels,0,parent,-1);\\n        return ans;\\n    }\\n};\\nTHe complecity is O(v+e) right ?"
                    },
                    {
                        "username": "yiwc63",
                        "content": "Hi, I'm now facing the TLE at testcase 59, and here's my solution below:\n\n\n```cpp=\nclass Solution {\npublic:\n    unordered_map<int, vector<int>> umap;\n    vector<int> ans;\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        for(int i=0; i<n; i++){\n            ans.push_back(0);\n        }\n        unordered_set<int> vertices;\n        vertices.insert(0);\n        for(auto edge:edges){\n            if(vertices.count(edge[0])==1){\n                umap[edge[0]].push_back(edge[1]);\n                vertices.insert(edge[1]);\n            }\n            else{\n                umap[edge[1]].push_back(edge[0]);\n                vertices.insert(edge[0]);\n            }  \n        }\n        vector<int> parents;\n        helper(parents, 0, labels);\n        return ans;\n    }\n    void helper(vector<int>& parents, int current, string& labels){\n        ans[current]++;\n        for(auto parent:parents){\n            if(labels[parent]==labels[current])\n                ans[parent]++;\n        }\n        if(umap.count(current)==0)\n            return;\n        parents.push_back(current);\n        for(auto child:umap[current]){\n            helper(parents, child, labels);\n        }\n        parents.pop_back();\n        return;\n    }\n};\n```\nI'm guessing it has something to do with the repeated record of parents, but im not quite so sure.\nAlso not sure if posting a not AC solution violates the rule, if so, ill take off the post ASAP, thks!"
                    },
                    {
                        "username": "Hazardouz",
                        "content": "Incase you are getting a tle, just make sure the necessary arguments you have passed is by reference and not by value. I was accidentally passing a vector by value causing tle. Good luck :)"
                    },
                    {
                        "username": "TuringJest",
                        "content": "Follow up:\\nNow solve it in linear time! "
                    },
                    {
                        "username": "user3197I",
                        "content": "Guys I am going crazy. Can someone please describe to me what is wrong with my solution? I debug and see the Integer count getting updated, but once the method returns back to main, the count resets to 0. Please help me out... I cannot anymore with this.\\n\\n```class Solution {\\n    private void dfs(int node, HashMap<Integer, ArrayList<Integer>> T, Integer count, char[] labels, char label) {\\n        if (labels[node] == label) {\\n            count += 1;\\n        }\\n\\n        ArrayList<Integer> children = T.getOrDefault(node, new ArrayList<>());\\n\\n        for (Integer child : children) {\\n            dfs(child, T, count, labels, label);\\n        }\\n    }\\n\\n\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        HashMap<Integer, ArrayList<Integer>> tree = new HashMap<>();\\n        for (int i = 0; i < edges.length; i++) { //making adjacency list\\n            ArrayList<Integer> children = tree.getOrDefault(edges[i][0], new ArrayList<>());\\n            children.add(edges[i][1]);\\n            tree.put(edges[i][0], children);\\n        }\\n\\n        int[] freq = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            Integer count = new Integer(0);\\n            dfs(i, tree, count, labels.toCharArray(), labels.charAt(i));\\n            freq[i] = count;\\n        }\\n\\n        return freq;\\n    }\\n}"
                    },
                    {
                        "username": "user8296H",
                        "content": "Great problem to practice recursion, DP and graphs!\\nI liked the idea of passing maps between sub trees and collecting them in the parent node.\\n\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "Sigh, why does Leetcode have to throw in cheap complexity by messing up the edge inputs. I feel like half of the difficulty is on properly parsing the edges and building a tree (and I am pretty sure I will trip on that in an actual interview)."
                    },
                    {
                        "username": "Michellead",
                        "content": "This is definitely not entirely a medium question, but it a great one.\\n\\nUse DFS for Traversal."
                    },
                    {
                        "username": "fortnighter",
                        "content": " I tried solving this problem by iterative method but still I am getting TLE in 58th test case. Can anyone help me how can I further optimize my code.\\n\\n class Solution {\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        int size = edges.size()+1;\\n        vector<vector<int>>vn(size);\\n\\n        for(auto a : edges){\\n            vn[a[0]].push_back(a[1]);\\n            vn[a[1]].push_back(a[0]);\\n        }\\n\\n        vector<int>ans(size, 0);\\n        vector<int>vis(size, 0);\\n\\n        vector<int>arr;\\n\\n        queue<int>qe;\\n        qe.push(0);\\n\\n        while(!qe.empty()){\\n            int y = qe.front();\\n            vis[y] = 1;\\n            arr.push_back(y);\\n            qe.pop();\\n            for(int a:vn[y]){\\n                if(!vis[a])qe.push(a);\\n            }\\n        }\\n\\n        vector<int>vis2(size, 0);\\n        unordered_map<char, int>mlp;\\n\\n        for(char i : labels){\\n            mlp[i]++;\\n            \\n        }\\n\\n        \\n\\n        int sz = arr.size();\\n\\n        unordered_map<int, unordered_map<char, int>>mp;\\n\\n        for(int i = arr.size()-1; i >= 0; i--){\\n            int rewq = arr[i];\\n            if(vn[rewq].size() == 1 & rewq != 0){\\n                unordered_map<char, int>mp1;\\n                mp1[labels[rewq]] = 1;\\n                mp[rewq] = mp1;\\n                ans[rewq] = 1;\\n                vis2[rewq] = 1;\\n            }else{\\n                int cnt = 1;\\n                char ch = labels[rewq];\\n                unordered_map<char, int>mpIn;\\n                mpIn[ch] = 1;\\n                for(int uyt : vn[rewq]){\\n                        if(vis2[uyt]){\\n                        unordered_map<char, int>mp1 = mp[uyt];\\n                        if(mp1.find(ch) != mp1.end())cnt += mp1[ch];\\n                        if(rewq != 0)\\n                        for(auto it = mlp.begin(); it != mlp.end(); it++){\\n                            char ch1 = it->first;\\n                            if(mp1.find(ch1) != mp1.end())mpIn[ch1] += mp1[ch1];\\n                        }\\n\\n                    }\\n                }\\n                mpIn[ch] = cnt;\\n                mp[rewq] = mpIn;\\n                ans[rewq] = mpIn[ch];\\n                vis2[rewq] = 1;\\n                \\n            }\\n            \\n            mlp[labels[rewq]] += -1;\\n            if(mlp[labels[rewq]] <= 0)mlp.erase(labels[rewq]);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1755552,
                "content": [
                    {
                        "username": "h3ct0r",
                        "content": "This should be a hard problem! A simple BFS will give timeout!"
                    },
                    {
                        "username": "prajapatkartik1",
                        "content": "Can anyone help me about why this solution is giving TLE. [Link to solution](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876692070/)\\nclass Solution {\\npublic:\\n    void sameLabel(int n,vector<vector<int>>& graph, vector<int>& ans, string labels, int source,vector<bool> parent,int pred){\\n        parent[source]=true;\\n        for(int i=0;i<graph[source].size();i++){\\n            if(graph[source][i]!=pred){\\n                sameLabel(n,graph,ans,labels,graph[source][i],parent,source);\\n            }\\n        }\\n        for(int i=0;i<parent.size();i++){\\n            if(parent[i]==true && labels[i]==labels[source]){\\n                ans[i]++;\\n            }\\n        }\\n        parent[source]=false;\\n        return;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        if(edges.size()==0){\\n            return {1};\\n        }\\n        vector<vector<int>> graph(n);\\n        vector<int> ans(n);\\n        vector<bool> parent(n,false);\\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        sameLabel(n,graph,ans,labels,0,parent,-1);\\n        return ans;\\n    }\\n};\\nTHe complecity is O(v+e) right ?"
                    },
                    {
                        "username": "yiwc63",
                        "content": "Hi, I'm now facing the TLE at testcase 59, and here's my solution below:\n\n\n```cpp=\nclass Solution {\npublic:\n    unordered_map<int, vector<int>> umap;\n    vector<int> ans;\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        for(int i=0; i<n; i++){\n            ans.push_back(0);\n        }\n        unordered_set<int> vertices;\n        vertices.insert(0);\n        for(auto edge:edges){\n            if(vertices.count(edge[0])==1){\n                umap[edge[0]].push_back(edge[1]);\n                vertices.insert(edge[1]);\n            }\n            else{\n                umap[edge[1]].push_back(edge[0]);\n                vertices.insert(edge[0]);\n            }  \n        }\n        vector<int> parents;\n        helper(parents, 0, labels);\n        return ans;\n    }\n    void helper(vector<int>& parents, int current, string& labels){\n        ans[current]++;\n        for(auto parent:parents){\n            if(labels[parent]==labels[current])\n                ans[parent]++;\n        }\n        if(umap.count(current)==0)\n            return;\n        parents.push_back(current);\n        for(auto child:umap[current]){\n            helper(parents, child, labels);\n        }\n        parents.pop_back();\n        return;\n    }\n};\n```\nI'm guessing it has something to do with the repeated record of parents, but im not quite so sure.\nAlso not sure if posting a not AC solution violates the rule, if so, ill take off the post ASAP, thks!"
                    },
                    {
                        "username": "Hazardouz",
                        "content": "Incase you are getting a tle, just make sure the necessary arguments you have passed is by reference and not by value. I was accidentally passing a vector by value causing tle. Good luck :)"
                    },
                    {
                        "username": "TuringJest",
                        "content": "Follow up:\\nNow solve it in linear time! "
                    },
                    {
                        "username": "user3197I",
                        "content": "Guys I am going crazy. Can someone please describe to me what is wrong with my solution? I debug and see the Integer count getting updated, but once the method returns back to main, the count resets to 0. Please help me out... I cannot anymore with this.\\n\\n```class Solution {\\n    private void dfs(int node, HashMap<Integer, ArrayList<Integer>> T, Integer count, char[] labels, char label) {\\n        if (labels[node] == label) {\\n            count += 1;\\n        }\\n\\n        ArrayList<Integer> children = T.getOrDefault(node, new ArrayList<>());\\n\\n        for (Integer child : children) {\\n            dfs(child, T, count, labels, label);\\n        }\\n    }\\n\\n\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        HashMap<Integer, ArrayList<Integer>> tree = new HashMap<>();\\n        for (int i = 0; i < edges.length; i++) { //making adjacency list\\n            ArrayList<Integer> children = tree.getOrDefault(edges[i][0], new ArrayList<>());\\n            children.add(edges[i][1]);\\n            tree.put(edges[i][0], children);\\n        }\\n\\n        int[] freq = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            Integer count = new Integer(0);\\n            dfs(i, tree, count, labels.toCharArray(), labels.charAt(i));\\n            freq[i] = count;\\n        }\\n\\n        return freq;\\n    }\\n}"
                    },
                    {
                        "username": "user8296H",
                        "content": "Great problem to practice recursion, DP and graphs!\\nI liked the idea of passing maps between sub trees and collecting them in the parent node.\\n\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "Sigh, why does Leetcode have to throw in cheap complexity by messing up the edge inputs. I feel like half of the difficulty is on properly parsing the edges and building a tree (and I am pretty sure I will trip on that in an actual interview)."
                    },
                    {
                        "username": "Michellead",
                        "content": "This is definitely not entirely a medium question, but it a great one.\\n\\nUse DFS for Traversal."
                    },
                    {
                        "username": "fortnighter",
                        "content": " I tried solving this problem by iterative method but still I am getting TLE in 58th test case. Can anyone help me how can I further optimize my code.\\n\\n class Solution {\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        int size = edges.size()+1;\\n        vector<vector<int>>vn(size);\\n\\n        for(auto a : edges){\\n            vn[a[0]].push_back(a[1]);\\n            vn[a[1]].push_back(a[0]);\\n        }\\n\\n        vector<int>ans(size, 0);\\n        vector<int>vis(size, 0);\\n\\n        vector<int>arr;\\n\\n        queue<int>qe;\\n        qe.push(0);\\n\\n        while(!qe.empty()){\\n            int y = qe.front();\\n            vis[y] = 1;\\n            arr.push_back(y);\\n            qe.pop();\\n            for(int a:vn[y]){\\n                if(!vis[a])qe.push(a);\\n            }\\n        }\\n\\n        vector<int>vis2(size, 0);\\n        unordered_map<char, int>mlp;\\n\\n        for(char i : labels){\\n            mlp[i]++;\\n            \\n        }\\n\\n        \\n\\n        int sz = arr.size();\\n\\n        unordered_map<int, unordered_map<char, int>>mp;\\n\\n        for(int i = arr.size()-1; i >= 0; i--){\\n            int rewq = arr[i];\\n            if(vn[rewq].size() == 1 & rewq != 0){\\n                unordered_map<char, int>mp1;\\n                mp1[labels[rewq]] = 1;\\n                mp[rewq] = mp1;\\n                ans[rewq] = 1;\\n                vis2[rewq] = 1;\\n            }else{\\n                int cnt = 1;\\n                char ch = labels[rewq];\\n                unordered_map<char, int>mpIn;\\n                mpIn[ch] = 1;\\n                for(int uyt : vn[rewq]){\\n                        if(vis2[uyt]){\\n                        unordered_map<char, int>mp1 = mp[uyt];\\n                        if(mp1.find(ch) != mp1.end())cnt += mp1[ch];\\n                        if(rewq != 0)\\n                        for(auto it = mlp.begin(); it != mlp.end(); it++){\\n                            char ch1 = it->first;\\n                            if(mp1.find(ch1) != mp1.end())mpIn[ch1] += mp1[ch1];\\n                        }\\n\\n                    }\\n                }\\n                mpIn[ch] = cnt;\\n                mp[rewq] = mpIn;\\n                ans[rewq] = mpIn[ch];\\n                vis2[rewq] = 1;\\n                \\n            }\\n            \\n            mlp[labels[rewq]] += -1;\\n            if(mlp[labels[rewq]] <= 0)mlp.erase(labels[rewq]);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1755438,
                "content": [
                    {
                        "username": "h3ct0r",
                        "content": "This should be a hard problem! A simple BFS will give timeout!"
                    },
                    {
                        "username": "prajapatkartik1",
                        "content": "Can anyone help me about why this solution is giving TLE. [Link to solution](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876692070/)\\nclass Solution {\\npublic:\\n    void sameLabel(int n,vector<vector<int>>& graph, vector<int>& ans, string labels, int source,vector<bool> parent,int pred){\\n        parent[source]=true;\\n        for(int i=0;i<graph[source].size();i++){\\n            if(graph[source][i]!=pred){\\n                sameLabel(n,graph,ans,labels,graph[source][i],parent,source);\\n            }\\n        }\\n        for(int i=0;i<parent.size();i++){\\n            if(parent[i]==true && labels[i]==labels[source]){\\n                ans[i]++;\\n            }\\n        }\\n        parent[source]=false;\\n        return;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        if(edges.size()==0){\\n            return {1};\\n        }\\n        vector<vector<int>> graph(n);\\n        vector<int> ans(n);\\n        vector<bool> parent(n,false);\\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        sameLabel(n,graph,ans,labels,0,parent,-1);\\n        return ans;\\n    }\\n};\\nTHe complecity is O(v+e) right ?"
                    },
                    {
                        "username": "yiwc63",
                        "content": "Hi, I'm now facing the TLE at testcase 59, and here's my solution below:\n\n\n```cpp=\nclass Solution {\npublic:\n    unordered_map<int, vector<int>> umap;\n    vector<int> ans;\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        for(int i=0; i<n; i++){\n            ans.push_back(0);\n        }\n        unordered_set<int> vertices;\n        vertices.insert(0);\n        for(auto edge:edges){\n            if(vertices.count(edge[0])==1){\n                umap[edge[0]].push_back(edge[1]);\n                vertices.insert(edge[1]);\n            }\n            else{\n                umap[edge[1]].push_back(edge[0]);\n                vertices.insert(edge[0]);\n            }  \n        }\n        vector<int> parents;\n        helper(parents, 0, labels);\n        return ans;\n    }\n    void helper(vector<int>& parents, int current, string& labels){\n        ans[current]++;\n        for(auto parent:parents){\n            if(labels[parent]==labels[current])\n                ans[parent]++;\n        }\n        if(umap.count(current)==0)\n            return;\n        parents.push_back(current);\n        for(auto child:umap[current]){\n            helper(parents, child, labels);\n        }\n        parents.pop_back();\n        return;\n    }\n};\n```\nI'm guessing it has something to do with the repeated record of parents, but im not quite so sure.\nAlso not sure if posting a not AC solution violates the rule, if so, ill take off the post ASAP, thks!"
                    },
                    {
                        "username": "Hazardouz",
                        "content": "Incase you are getting a tle, just make sure the necessary arguments you have passed is by reference and not by value. I was accidentally passing a vector by value causing tle. Good luck :)"
                    },
                    {
                        "username": "TuringJest",
                        "content": "Follow up:\\nNow solve it in linear time! "
                    },
                    {
                        "username": "user3197I",
                        "content": "Guys I am going crazy. Can someone please describe to me what is wrong with my solution? I debug and see the Integer count getting updated, but once the method returns back to main, the count resets to 0. Please help me out... I cannot anymore with this.\\n\\n```class Solution {\\n    private void dfs(int node, HashMap<Integer, ArrayList<Integer>> T, Integer count, char[] labels, char label) {\\n        if (labels[node] == label) {\\n            count += 1;\\n        }\\n\\n        ArrayList<Integer> children = T.getOrDefault(node, new ArrayList<>());\\n\\n        for (Integer child : children) {\\n            dfs(child, T, count, labels, label);\\n        }\\n    }\\n\\n\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        HashMap<Integer, ArrayList<Integer>> tree = new HashMap<>();\\n        for (int i = 0; i < edges.length; i++) { //making adjacency list\\n            ArrayList<Integer> children = tree.getOrDefault(edges[i][0], new ArrayList<>());\\n            children.add(edges[i][1]);\\n            tree.put(edges[i][0], children);\\n        }\\n\\n        int[] freq = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            Integer count = new Integer(0);\\n            dfs(i, tree, count, labels.toCharArray(), labels.charAt(i));\\n            freq[i] = count;\\n        }\\n\\n        return freq;\\n    }\\n}"
                    },
                    {
                        "username": "user8296H",
                        "content": "Great problem to practice recursion, DP and graphs!\\nI liked the idea of passing maps between sub trees and collecting them in the parent node.\\n\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "Sigh, why does Leetcode have to throw in cheap complexity by messing up the edge inputs. I feel like half of the difficulty is on properly parsing the edges and building a tree (and I am pretty sure I will trip on that in an actual interview)."
                    },
                    {
                        "username": "Michellead",
                        "content": "This is definitely not entirely a medium question, but it a great one.\\n\\nUse DFS for Traversal."
                    },
                    {
                        "username": "fortnighter",
                        "content": " I tried solving this problem by iterative method but still I am getting TLE in 58th test case. Can anyone help me how can I further optimize my code.\\n\\n class Solution {\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        int size = edges.size()+1;\\n        vector<vector<int>>vn(size);\\n\\n        for(auto a : edges){\\n            vn[a[0]].push_back(a[1]);\\n            vn[a[1]].push_back(a[0]);\\n        }\\n\\n        vector<int>ans(size, 0);\\n        vector<int>vis(size, 0);\\n\\n        vector<int>arr;\\n\\n        queue<int>qe;\\n        qe.push(0);\\n\\n        while(!qe.empty()){\\n            int y = qe.front();\\n            vis[y] = 1;\\n            arr.push_back(y);\\n            qe.pop();\\n            for(int a:vn[y]){\\n                if(!vis[a])qe.push(a);\\n            }\\n        }\\n\\n        vector<int>vis2(size, 0);\\n        unordered_map<char, int>mlp;\\n\\n        for(char i : labels){\\n            mlp[i]++;\\n            \\n        }\\n\\n        \\n\\n        int sz = arr.size();\\n\\n        unordered_map<int, unordered_map<char, int>>mp;\\n\\n        for(int i = arr.size()-1; i >= 0; i--){\\n            int rewq = arr[i];\\n            if(vn[rewq].size() == 1 & rewq != 0){\\n                unordered_map<char, int>mp1;\\n                mp1[labels[rewq]] = 1;\\n                mp[rewq] = mp1;\\n                ans[rewq] = 1;\\n                vis2[rewq] = 1;\\n            }else{\\n                int cnt = 1;\\n                char ch = labels[rewq];\\n                unordered_map<char, int>mpIn;\\n                mpIn[ch] = 1;\\n                for(int uyt : vn[rewq]){\\n                        if(vis2[uyt]){\\n                        unordered_map<char, int>mp1 = mp[uyt];\\n                        if(mp1.find(ch) != mp1.end())cnt += mp1[ch];\\n                        if(rewq != 0)\\n                        for(auto it = mlp.begin(); it != mlp.end(); it++){\\n                            char ch1 = it->first;\\n                            if(mp1.find(ch1) != mp1.end())mpIn[ch1] += mp1[ch1];\\n                        }\\n\\n                    }\\n                }\\n                mpIn[ch] = cnt;\\n                mp[rewq] = mpIn;\\n                ans[rewq] = mpIn[ch];\\n                vis2[rewq] = 1;\\n                \\n            }\\n            \\n            mlp[labels[rewq]] += -1;\\n            if(mlp[labels[rewq]] <= 0)mlp.erase(labels[rewq]);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1755316,
                "content": [
                    {
                        "username": "h3ct0r",
                        "content": "This should be a hard problem! A simple BFS will give timeout!"
                    },
                    {
                        "username": "prajapatkartik1",
                        "content": "Can anyone help me about why this solution is giving TLE. [Link to solution](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876692070/)\\nclass Solution {\\npublic:\\n    void sameLabel(int n,vector<vector<int>>& graph, vector<int>& ans, string labels, int source,vector<bool> parent,int pred){\\n        parent[source]=true;\\n        for(int i=0;i<graph[source].size();i++){\\n            if(graph[source][i]!=pred){\\n                sameLabel(n,graph,ans,labels,graph[source][i],parent,source);\\n            }\\n        }\\n        for(int i=0;i<parent.size();i++){\\n            if(parent[i]==true && labels[i]==labels[source]){\\n                ans[i]++;\\n            }\\n        }\\n        parent[source]=false;\\n        return;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        if(edges.size()==0){\\n            return {1};\\n        }\\n        vector<vector<int>> graph(n);\\n        vector<int> ans(n);\\n        vector<bool> parent(n,false);\\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        sameLabel(n,graph,ans,labels,0,parent,-1);\\n        return ans;\\n    }\\n};\\nTHe complecity is O(v+e) right ?"
                    },
                    {
                        "username": "yiwc63",
                        "content": "Hi, I'm now facing the TLE at testcase 59, and here's my solution below:\n\n\n```cpp=\nclass Solution {\npublic:\n    unordered_map<int, vector<int>> umap;\n    vector<int> ans;\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        for(int i=0; i<n; i++){\n            ans.push_back(0);\n        }\n        unordered_set<int> vertices;\n        vertices.insert(0);\n        for(auto edge:edges){\n            if(vertices.count(edge[0])==1){\n                umap[edge[0]].push_back(edge[1]);\n                vertices.insert(edge[1]);\n            }\n            else{\n                umap[edge[1]].push_back(edge[0]);\n                vertices.insert(edge[0]);\n            }  \n        }\n        vector<int> parents;\n        helper(parents, 0, labels);\n        return ans;\n    }\n    void helper(vector<int>& parents, int current, string& labels){\n        ans[current]++;\n        for(auto parent:parents){\n            if(labels[parent]==labels[current])\n                ans[parent]++;\n        }\n        if(umap.count(current)==0)\n            return;\n        parents.push_back(current);\n        for(auto child:umap[current]){\n            helper(parents, child, labels);\n        }\n        parents.pop_back();\n        return;\n    }\n};\n```\nI'm guessing it has something to do with the repeated record of parents, but im not quite so sure.\nAlso not sure if posting a not AC solution violates the rule, if so, ill take off the post ASAP, thks!"
                    },
                    {
                        "username": "Hazardouz",
                        "content": "Incase you are getting a tle, just make sure the necessary arguments you have passed is by reference and not by value. I was accidentally passing a vector by value causing tle. Good luck :)"
                    },
                    {
                        "username": "TuringJest",
                        "content": "Follow up:\\nNow solve it in linear time! "
                    },
                    {
                        "username": "user3197I",
                        "content": "Guys I am going crazy. Can someone please describe to me what is wrong with my solution? I debug and see the Integer count getting updated, but once the method returns back to main, the count resets to 0. Please help me out... I cannot anymore with this.\\n\\n```class Solution {\\n    private void dfs(int node, HashMap<Integer, ArrayList<Integer>> T, Integer count, char[] labels, char label) {\\n        if (labels[node] == label) {\\n            count += 1;\\n        }\\n\\n        ArrayList<Integer> children = T.getOrDefault(node, new ArrayList<>());\\n\\n        for (Integer child : children) {\\n            dfs(child, T, count, labels, label);\\n        }\\n    }\\n\\n\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        HashMap<Integer, ArrayList<Integer>> tree = new HashMap<>();\\n        for (int i = 0; i < edges.length; i++) { //making adjacency list\\n            ArrayList<Integer> children = tree.getOrDefault(edges[i][0], new ArrayList<>());\\n            children.add(edges[i][1]);\\n            tree.put(edges[i][0], children);\\n        }\\n\\n        int[] freq = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            Integer count = new Integer(0);\\n            dfs(i, tree, count, labels.toCharArray(), labels.charAt(i));\\n            freq[i] = count;\\n        }\\n\\n        return freq;\\n    }\\n}"
                    },
                    {
                        "username": "user8296H",
                        "content": "Great problem to practice recursion, DP and graphs!\\nI liked the idea of passing maps between sub trees and collecting them in the parent node.\\n\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "Sigh, why does Leetcode have to throw in cheap complexity by messing up the edge inputs. I feel like half of the difficulty is on properly parsing the edges and building a tree (and I am pretty sure I will trip on that in an actual interview)."
                    },
                    {
                        "username": "Michellead",
                        "content": "This is definitely not entirely a medium question, but it a great one.\\n\\nUse DFS for Traversal."
                    },
                    {
                        "username": "fortnighter",
                        "content": " I tried solving this problem by iterative method but still I am getting TLE in 58th test case. Can anyone help me how can I further optimize my code.\\n\\n class Solution {\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        int size = edges.size()+1;\\n        vector<vector<int>>vn(size);\\n\\n        for(auto a : edges){\\n            vn[a[0]].push_back(a[1]);\\n            vn[a[1]].push_back(a[0]);\\n        }\\n\\n        vector<int>ans(size, 0);\\n        vector<int>vis(size, 0);\\n\\n        vector<int>arr;\\n\\n        queue<int>qe;\\n        qe.push(0);\\n\\n        while(!qe.empty()){\\n            int y = qe.front();\\n            vis[y] = 1;\\n            arr.push_back(y);\\n            qe.pop();\\n            for(int a:vn[y]){\\n                if(!vis[a])qe.push(a);\\n            }\\n        }\\n\\n        vector<int>vis2(size, 0);\\n        unordered_map<char, int>mlp;\\n\\n        for(char i : labels){\\n            mlp[i]++;\\n            \\n        }\\n\\n        \\n\\n        int sz = arr.size();\\n\\n        unordered_map<int, unordered_map<char, int>>mp;\\n\\n        for(int i = arr.size()-1; i >= 0; i--){\\n            int rewq = arr[i];\\n            if(vn[rewq].size() == 1 & rewq != 0){\\n                unordered_map<char, int>mp1;\\n                mp1[labels[rewq]] = 1;\\n                mp[rewq] = mp1;\\n                ans[rewq] = 1;\\n                vis2[rewq] = 1;\\n            }else{\\n                int cnt = 1;\\n                char ch = labels[rewq];\\n                unordered_map<char, int>mpIn;\\n                mpIn[ch] = 1;\\n                for(int uyt : vn[rewq]){\\n                        if(vis2[uyt]){\\n                        unordered_map<char, int>mp1 = mp[uyt];\\n                        if(mp1.find(ch) != mp1.end())cnt += mp1[ch];\\n                        if(rewq != 0)\\n                        for(auto it = mlp.begin(); it != mlp.end(); it++){\\n                            char ch1 = it->first;\\n                            if(mp1.find(ch1) != mp1.end())mpIn[ch1] += mp1[ch1];\\n                        }\\n\\n                    }\\n                }\\n                mpIn[ch] = cnt;\\n                mp[rewq] = mpIn;\\n                ans[rewq] = mpIn[ch];\\n                vis2[rewq] = 1;\\n                \\n            }\\n            \\n            mlp[labels[rewq]] += -1;\\n            if(mlp[labels[rewq]] <= 0)mlp.erase(labels[rewq]);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1755102,
                "content": [
                    {
                        "username": "h3ct0r",
                        "content": "This should be a hard problem! A simple BFS will give timeout!"
                    },
                    {
                        "username": "prajapatkartik1",
                        "content": "Can anyone help me about why this solution is giving TLE. [Link to solution](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876692070/)\\nclass Solution {\\npublic:\\n    void sameLabel(int n,vector<vector<int>>& graph, vector<int>& ans, string labels, int source,vector<bool> parent,int pred){\\n        parent[source]=true;\\n        for(int i=0;i<graph[source].size();i++){\\n            if(graph[source][i]!=pred){\\n                sameLabel(n,graph,ans,labels,graph[source][i],parent,source);\\n            }\\n        }\\n        for(int i=0;i<parent.size();i++){\\n            if(parent[i]==true && labels[i]==labels[source]){\\n                ans[i]++;\\n            }\\n        }\\n        parent[source]=false;\\n        return;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        if(edges.size()==0){\\n            return {1};\\n        }\\n        vector<vector<int>> graph(n);\\n        vector<int> ans(n);\\n        vector<bool> parent(n,false);\\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        sameLabel(n,graph,ans,labels,0,parent,-1);\\n        return ans;\\n    }\\n};\\nTHe complecity is O(v+e) right ?"
                    },
                    {
                        "username": "yiwc63",
                        "content": "Hi, I'm now facing the TLE at testcase 59, and here's my solution below:\n\n\n```cpp=\nclass Solution {\npublic:\n    unordered_map<int, vector<int>> umap;\n    vector<int> ans;\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        for(int i=0; i<n; i++){\n            ans.push_back(0);\n        }\n        unordered_set<int> vertices;\n        vertices.insert(0);\n        for(auto edge:edges){\n            if(vertices.count(edge[0])==1){\n                umap[edge[0]].push_back(edge[1]);\n                vertices.insert(edge[1]);\n            }\n            else{\n                umap[edge[1]].push_back(edge[0]);\n                vertices.insert(edge[0]);\n            }  \n        }\n        vector<int> parents;\n        helper(parents, 0, labels);\n        return ans;\n    }\n    void helper(vector<int>& parents, int current, string& labels){\n        ans[current]++;\n        for(auto parent:parents){\n            if(labels[parent]==labels[current])\n                ans[parent]++;\n        }\n        if(umap.count(current)==0)\n            return;\n        parents.push_back(current);\n        for(auto child:umap[current]){\n            helper(parents, child, labels);\n        }\n        parents.pop_back();\n        return;\n    }\n};\n```\nI'm guessing it has something to do with the repeated record of parents, but im not quite so sure.\nAlso not sure if posting a not AC solution violates the rule, if so, ill take off the post ASAP, thks!"
                    },
                    {
                        "username": "Hazardouz",
                        "content": "Incase you are getting a tle, just make sure the necessary arguments you have passed is by reference and not by value. I was accidentally passing a vector by value causing tle. Good luck :)"
                    },
                    {
                        "username": "TuringJest",
                        "content": "Follow up:\\nNow solve it in linear time! "
                    },
                    {
                        "username": "user3197I",
                        "content": "Guys I am going crazy. Can someone please describe to me what is wrong with my solution? I debug and see the Integer count getting updated, but once the method returns back to main, the count resets to 0. Please help me out... I cannot anymore with this.\\n\\n```class Solution {\\n    private void dfs(int node, HashMap<Integer, ArrayList<Integer>> T, Integer count, char[] labels, char label) {\\n        if (labels[node] == label) {\\n            count += 1;\\n        }\\n\\n        ArrayList<Integer> children = T.getOrDefault(node, new ArrayList<>());\\n\\n        for (Integer child : children) {\\n            dfs(child, T, count, labels, label);\\n        }\\n    }\\n\\n\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        HashMap<Integer, ArrayList<Integer>> tree = new HashMap<>();\\n        for (int i = 0; i < edges.length; i++) { //making adjacency list\\n            ArrayList<Integer> children = tree.getOrDefault(edges[i][0], new ArrayList<>());\\n            children.add(edges[i][1]);\\n            tree.put(edges[i][0], children);\\n        }\\n\\n        int[] freq = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            Integer count = new Integer(0);\\n            dfs(i, tree, count, labels.toCharArray(), labels.charAt(i));\\n            freq[i] = count;\\n        }\\n\\n        return freq;\\n    }\\n}"
                    },
                    {
                        "username": "user8296H",
                        "content": "Great problem to practice recursion, DP and graphs!\\nI liked the idea of passing maps between sub trees and collecting them in the parent node.\\n\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "Sigh, why does Leetcode have to throw in cheap complexity by messing up the edge inputs. I feel like half of the difficulty is on properly parsing the edges and building a tree (and I am pretty sure I will trip on that in an actual interview)."
                    },
                    {
                        "username": "Michellead",
                        "content": "This is definitely not entirely a medium question, but it a great one.\\n\\nUse DFS for Traversal."
                    },
                    {
                        "username": "fortnighter",
                        "content": " I tried solving this problem by iterative method but still I am getting TLE in 58th test case. Can anyone help me how can I further optimize my code.\\n\\n class Solution {\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        int size = edges.size()+1;\\n        vector<vector<int>>vn(size);\\n\\n        for(auto a : edges){\\n            vn[a[0]].push_back(a[1]);\\n            vn[a[1]].push_back(a[0]);\\n        }\\n\\n        vector<int>ans(size, 0);\\n        vector<int>vis(size, 0);\\n\\n        vector<int>arr;\\n\\n        queue<int>qe;\\n        qe.push(0);\\n\\n        while(!qe.empty()){\\n            int y = qe.front();\\n            vis[y] = 1;\\n            arr.push_back(y);\\n            qe.pop();\\n            for(int a:vn[y]){\\n                if(!vis[a])qe.push(a);\\n            }\\n        }\\n\\n        vector<int>vis2(size, 0);\\n        unordered_map<char, int>mlp;\\n\\n        for(char i : labels){\\n            mlp[i]++;\\n            \\n        }\\n\\n        \\n\\n        int sz = arr.size();\\n\\n        unordered_map<int, unordered_map<char, int>>mp;\\n\\n        for(int i = arr.size()-1; i >= 0; i--){\\n            int rewq = arr[i];\\n            if(vn[rewq].size() == 1 & rewq != 0){\\n                unordered_map<char, int>mp1;\\n                mp1[labels[rewq]] = 1;\\n                mp[rewq] = mp1;\\n                ans[rewq] = 1;\\n                vis2[rewq] = 1;\\n            }else{\\n                int cnt = 1;\\n                char ch = labels[rewq];\\n                unordered_map<char, int>mpIn;\\n                mpIn[ch] = 1;\\n                for(int uyt : vn[rewq]){\\n                        if(vis2[uyt]){\\n                        unordered_map<char, int>mp1 = mp[uyt];\\n                        if(mp1.find(ch) != mp1.end())cnt += mp1[ch];\\n                        if(rewq != 0)\\n                        for(auto it = mlp.begin(); it != mlp.end(); it++){\\n                            char ch1 = it->first;\\n                            if(mp1.find(ch1) != mp1.end())mpIn[ch1] += mp1[ch1];\\n                        }\\n\\n                    }\\n                }\\n                mpIn[ch] = cnt;\\n                mp[rewq] = mpIn;\\n                ans[rewq] = mpIn[ch];\\n                vis2[rewq] = 1;\\n                \\n            }\\n            \\n            mlp[labels[rewq]] += -1;\\n            if(mlp[labels[rewq]] <= 0)mlp.erase(labels[rewq]);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1754951,
                "content": [
                    {
                        "username": "h3ct0r",
                        "content": "This should be a hard problem! A simple BFS will give timeout!"
                    },
                    {
                        "username": "prajapatkartik1",
                        "content": "Can anyone help me about why this solution is giving TLE. [Link to solution](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876692070/)\\nclass Solution {\\npublic:\\n    void sameLabel(int n,vector<vector<int>>& graph, vector<int>& ans, string labels, int source,vector<bool> parent,int pred){\\n        parent[source]=true;\\n        for(int i=0;i<graph[source].size();i++){\\n            if(graph[source][i]!=pred){\\n                sameLabel(n,graph,ans,labels,graph[source][i],parent,source);\\n            }\\n        }\\n        for(int i=0;i<parent.size();i++){\\n            if(parent[i]==true && labels[i]==labels[source]){\\n                ans[i]++;\\n            }\\n        }\\n        parent[source]=false;\\n        return;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        if(edges.size()==0){\\n            return {1};\\n        }\\n        vector<vector<int>> graph(n);\\n        vector<int> ans(n);\\n        vector<bool> parent(n,false);\\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        sameLabel(n,graph,ans,labels,0,parent,-1);\\n        return ans;\\n    }\\n};\\nTHe complecity is O(v+e) right ?"
                    },
                    {
                        "username": "yiwc63",
                        "content": "Hi, I'm now facing the TLE at testcase 59, and here's my solution below:\n\n\n```cpp=\nclass Solution {\npublic:\n    unordered_map<int, vector<int>> umap;\n    vector<int> ans;\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        for(int i=0; i<n; i++){\n            ans.push_back(0);\n        }\n        unordered_set<int> vertices;\n        vertices.insert(0);\n        for(auto edge:edges){\n            if(vertices.count(edge[0])==1){\n                umap[edge[0]].push_back(edge[1]);\n                vertices.insert(edge[1]);\n            }\n            else{\n                umap[edge[1]].push_back(edge[0]);\n                vertices.insert(edge[0]);\n            }  \n        }\n        vector<int> parents;\n        helper(parents, 0, labels);\n        return ans;\n    }\n    void helper(vector<int>& parents, int current, string& labels){\n        ans[current]++;\n        for(auto parent:parents){\n            if(labels[parent]==labels[current])\n                ans[parent]++;\n        }\n        if(umap.count(current)==0)\n            return;\n        parents.push_back(current);\n        for(auto child:umap[current]){\n            helper(parents, child, labels);\n        }\n        parents.pop_back();\n        return;\n    }\n};\n```\nI'm guessing it has something to do with the repeated record of parents, but im not quite so sure.\nAlso not sure if posting a not AC solution violates the rule, if so, ill take off the post ASAP, thks!"
                    },
                    {
                        "username": "Hazardouz",
                        "content": "Incase you are getting a tle, just make sure the necessary arguments you have passed is by reference and not by value. I was accidentally passing a vector by value causing tle. Good luck :)"
                    },
                    {
                        "username": "TuringJest",
                        "content": "Follow up:\\nNow solve it in linear time! "
                    },
                    {
                        "username": "user3197I",
                        "content": "Guys I am going crazy. Can someone please describe to me what is wrong with my solution? I debug and see the Integer count getting updated, but once the method returns back to main, the count resets to 0. Please help me out... I cannot anymore with this.\\n\\n```class Solution {\\n    private void dfs(int node, HashMap<Integer, ArrayList<Integer>> T, Integer count, char[] labels, char label) {\\n        if (labels[node] == label) {\\n            count += 1;\\n        }\\n\\n        ArrayList<Integer> children = T.getOrDefault(node, new ArrayList<>());\\n\\n        for (Integer child : children) {\\n            dfs(child, T, count, labels, label);\\n        }\\n    }\\n\\n\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        HashMap<Integer, ArrayList<Integer>> tree = new HashMap<>();\\n        for (int i = 0; i < edges.length; i++) { //making adjacency list\\n            ArrayList<Integer> children = tree.getOrDefault(edges[i][0], new ArrayList<>());\\n            children.add(edges[i][1]);\\n            tree.put(edges[i][0], children);\\n        }\\n\\n        int[] freq = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            Integer count = new Integer(0);\\n            dfs(i, tree, count, labels.toCharArray(), labels.charAt(i));\\n            freq[i] = count;\\n        }\\n\\n        return freq;\\n    }\\n}"
                    },
                    {
                        "username": "user8296H",
                        "content": "Great problem to practice recursion, DP and graphs!\\nI liked the idea of passing maps between sub trees and collecting them in the parent node.\\n\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "Sigh, why does Leetcode have to throw in cheap complexity by messing up the edge inputs. I feel like half of the difficulty is on properly parsing the edges and building a tree (and I am pretty sure I will trip on that in an actual interview)."
                    },
                    {
                        "username": "Michellead",
                        "content": "This is definitely not entirely a medium question, but it a great one.\\n\\nUse DFS for Traversal."
                    },
                    {
                        "username": "fortnighter",
                        "content": " I tried solving this problem by iterative method but still I am getting TLE in 58th test case. Can anyone help me how can I further optimize my code.\\n\\n class Solution {\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        int size = edges.size()+1;\\n        vector<vector<int>>vn(size);\\n\\n        for(auto a : edges){\\n            vn[a[0]].push_back(a[1]);\\n            vn[a[1]].push_back(a[0]);\\n        }\\n\\n        vector<int>ans(size, 0);\\n        vector<int>vis(size, 0);\\n\\n        vector<int>arr;\\n\\n        queue<int>qe;\\n        qe.push(0);\\n\\n        while(!qe.empty()){\\n            int y = qe.front();\\n            vis[y] = 1;\\n            arr.push_back(y);\\n            qe.pop();\\n            for(int a:vn[y]){\\n                if(!vis[a])qe.push(a);\\n            }\\n        }\\n\\n        vector<int>vis2(size, 0);\\n        unordered_map<char, int>mlp;\\n\\n        for(char i : labels){\\n            mlp[i]++;\\n            \\n        }\\n\\n        \\n\\n        int sz = arr.size();\\n\\n        unordered_map<int, unordered_map<char, int>>mp;\\n\\n        for(int i = arr.size()-1; i >= 0; i--){\\n            int rewq = arr[i];\\n            if(vn[rewq].size() == 1 & rewq != 0){\\n                unordered_map<char, int>mp1;\\n                mp1[labels[rewq]] = 1;\\n                mp[rewq] = mp1;\\n                ans[rewq] = 1;\\n                vis2[rewq] = 1;\\n            }else{\\n                int cnt = 1;\\n                char ch = labels[rewq];\\n                unordered_map<char, int>mpIn;\\n                mpIn[ch] = 1;\\n                for(int uyt : vn[rewq]){\\n                        if(vis2[uyt]){\\n                        unordered_map<char, int>mp1 = mp[uyt];\\n                        if(mp1.find(ch) != mp1.end())cnt += mp1[ch];\\n                        if(rewq != 0)\\n                        for(auto it = mlp.begin(); it != mlp.end(); it++){\\n                            char ch1 = it->first;\\n                            if(mp1.find(ch1) != mp1.end())mpIn[ch1] += mp1[ch1];\\n                        }\\n\\n                    }\\n                }\\n                mpIn[ch] = cnt;\\n                mp[rewq] = mpIn;\\n                ans[rewq] = mpIn[ch];\\n                vis2[rewq] = 1;\\n                \\n            }\\n            \\n            mlp[labels[rewq]] += -1;\\n            if(mlp[labels[rewq]] <= 0)mlp.erase(labels[rewq]);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1754936,
                "content": [
                    {
                        "username": "h3ct0r",
                        "content": "This should be a hard problem! A simple BFS will give timeout!"
                    },
                    {
                        "username": "prajapatkartik1",
                        "content": "Can anyone help me about why this solution is giving TLE. [Link to solution](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876692070/)\\nclass Solution {\\npublic:\\n    void sameLabel(int n,vector<vector<int>>& graph, vector<int>& ans, string labels, int source,vector<bool> parent,int pred){\\n        parent[source]=true;\\n        for(int i=0;i<graph[source].size();i++){\\n            if(graph[source][i]!=pred){\\n                sameLabel(n,graph,ans,labels,graph[source][i],parent,source);\\n            }\\n        }\\n        for(int i=0;i<parent.size();i++){\\n            if(parent[i]==true && labels[i]==labels[source]){\\n                ans[i]++;\\n            }\\n        }\\n        parent[source]=false;\\n        return;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        if(edges.size()==0){\\n            return {1};\\n        }\\n        vector<vector<int>> graph(n);\\n        vector<int> ans(n);\\n        vector<bool> parent(n,false);\\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        sameLabel(n,graph,ans,labels,0,parent,-1);\\n        return ans;\\n    }\\n};\\nTHe complecity is O(v+e) right ?"
                    },
                    {
                        "username": "yiwc63",
                        "content": "Hi, I'm now facing the TLE at testcase 59, and here's my solution below:\n\n\n```cpp=\nclass Solution {\npublic:\n    unordered_map<int, vector<int>> umap;\n    vector<int> ans;\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        for(int i=0; i<n; i++){\n            ans.push_back(0);\n        }\n        unordered_set<int> vertices;\n        vertices.insert(0);\n        for(auto edge:edges){\n            if(vertices.count(edge[0])==1){\n                umap[edge[0]].push_back(edge[1]);\n                vertices.insert(edge[1]);\n            }\n            else{\n                umap[edge[1]].push_back(edge[0]);\n                vertices.insert(edge[0]);\n            }  \n        }\n        vector<int> parents;\n        helper(parents, 0, labels);\n        return ans;\n    }\n    void helper(vector<int>& parents, int current, string& labels){\n        ans[current]++;\n        for(auto parent:parents){\n            if(labels[parent]==labels[current])\n                ans[parent]++;\n        }\n        if(umap.count(current)==0)\n            return;\n        parents.push_back(current);\n        for(auto child:umap[current]){\n            helper(parents, child, labels);\n        }\n        parents.pop_back();\n        return;\n    }\n};\n```\nI'm guessing it has something to do with the repeated record of parents, but im not quite so sure.\nAlso not sure if posting a not AC solution violates the rule, if so, ill take off the post ASAP, thks!"
                    },
                    {
                        "username": "Hazardouz",
                        "content": "Incase you are getting a tle, just make sure the necessary arguments you have passed is by reference and not by value. I was accidentally passing a vector by value causing tle. Good luck :)"
                    },
                    {
                        "username": "TuringJest",
                        "content": "Follow up:\\nNow solve it in linear time! "
                    },
                    {
                        "username": "user3197I",
                        "content": "Guys I am going crazy. Can someone please describe to me what is wrong with my solution? I debug and see the Integer count getting updated, but once the method returns back to main, the count resets to 0. Please help me out... I cannot anymore with this.\\n\\n```class Solution {\\n    private void dfs(int node, HashMap<Integer, ArrayList<Integer>> T, Integer count, char[] labels, char label) {\\n        if (labels[node] == label) {\\n            count += 1;\\n        }\\n\\n        ArrayList<Integer> children = T.getOrDefault(node, new ArrayList<>());\\n\\n        for (Integer child : children) {\\n            dfs(child, T, count, labels, label);\\n        }\\n    }\\n\\n\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        HashMap<Integer, ArrayList<Integer>> tree = new HashMap<>();\\n        for (int i = 0; i < edges.length; i++) { //making adjacency list\\n            ArrayList<Integer> children = tree.getOrDefault(edges[i][0], new ArrayList<>());\\n            children.add(edges[i][1]);\\n            tree.put(edges[i][0], children);\\n        }\\n\\n        int[] freq = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            Integer count = new Integer(0);\\n            dfs(i, tree, count, labels.toCharArray(), labels.charAt(i));\\n            freq[i] = count;\\n        }\\n\\n        return freq;\\n    }\\n}"
                    },
                    {
                        "username": "user8296H",
                        "content": "Great problem to practice recursion, DP and graphs!\\nI liked the idea of passing maps between sub trees and collecting them in the parent node.\\n\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "Sigh, why does Leetcode have to throw in cheap complexity by messing up the edge inputs. I feel like half of the difficulty is on properly parsing the edges and building a tree (and I am pretty sure I will trip on that in an actual interview)."
                    },
                    {
                        "username": "Michellead",
                        "content": "This is definitely not entirely a medium question, but it a great one.\\n\\nUse DFS for Traversal."
                    },
                    {
                        "username": "fortnighter",
                        "content": " I tried solving this problem by iterative method but still I am getting TLE in 58th test case. Can anyone help me how can I further optimize my code.\\n\\n class Solution {\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        int size = edges.size()+1;\\n        vector<vector<int>>vn(size);\\n\\n        for(auto a : edges){\\n            vn[a[0]].push_back(a[1]);\\n            vn[a[1]].push_back(a[0]);\\n        }\\n\\n        vector<int>ans(size, 0);\\n        vector<int>vis(size, 0);\\n\\n        vector<int>arr;\\n\\n        queue<int>qe;\\n        qe.push(0);\\n\\n        while(!qe.empty()){\\n            int y = qe.front();\\n            vis[y] = 1;\\n            arr.push_back(y);\\n            qe.pop();\\n            for(int a:vn[y]){\\n                if(!vis[a])qe.push(a);\\n            }\\n        }\\n\\n        vector<int>vis2(size, 0);\\n        unordered_map<char, int>mlp;\\n\\n        for(char i : labels){\\n            mlp[i]++;\\n            \\n        }\\n\\n        \\n\\n        int sz = arr.size();\\n\\n        unordered_map<int, unordered_map<char, int>>mp;\\n\\n        for(int i = arr.size()-1; i >= 0; i--){\\n            int rewq = arr[i];\\n            if(vn[rewq].size() == 1 & rewq != 0){\\n                unordered_map<char, int>mp1;\\n                mp1[labels[rewq]] = 1;\\n                mp[rewq] = mp1;\\n                ans[rewq] = 1;\\n                vis2[rewq] = 1;\\n            }else{\\n                int cnt = 1;\\n                char ch = labels[rewq];\\n                unordered_map<char, int>mpIn;\\n                mpIn[ch] = 1;\\n                for(int uyt : vn[rewq]){\\n                        if(vis2[uyt]){\\n                        unordered_map<char, int>mp1 = mp[uyt];\\n                        if(mp1.find(ch) != mp1.end())cnt += mp1[ch];\\n                        if(rewq != 0)\\n                        for(auto it = mlp.begin(); it != mlp.end(); it++){\\n                            char ch1 = it->first;\\n                            if(mp1.find(ch1) != mp1.end())mpIn[ch1] += mp1[ch1];\\n                        }\\n\\n                    }\\n                }\\n                mpIn[ch] = cnt;\\n                mp[rewq] = mpIn;\\n                ans[rewq] = mpIn[ch];\\n                vis2[rewq] = 1;\\n                \\n            }\\n            \\n            mlp[labels[rewq]] += -1;\\n            if(mlp[labels[rewq]] <= 0)mlp.erase(labels[rewq]);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1754915,
                "content": [
                    {
                        "username": "h3ct0r",
                        "content": "This should be a hard problem! A simple BFS will give timeout!"
                    },
                    {
                        "username": "prajapatkartik1",
                        "content": "Can anyone help me about why this solution is giving TLE. [Link to solution](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876692070/)\\nclass Solution {\\npublic:\\n    void sameLabel(int n,vector<vector<int>>& graph, vector<int>& ans, string labels, int source,vector<bool> parent,int pred){\\n        parent[source]=true;\\n        for(int i=0;i<graph[source].size();i++){\\n            if(graph[source][i]!=pred){\\n                sameLabel(n,graph,ans,labels,graph[source][i],parent,source);\\n            }\\n        }\\n        for(int i=0;i<parent.size();i++){\\n            if(parent[i]==true && labels[i]==labels[source]){\\n                ans[i]++;\\n            }\\n        }\\n        parent[source]=false;\\n        return;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        if(edges.size()==0){\\n            return {1};\\n        }\\n        vector<vector<int>> graph(n);\\n        vector<int> ans(n);\\n        vector<bool> parent(n,false);\\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        sameLabel(n,graph,ans,labels,0,parent,-1);\\n        return ans;\\n    }\\n};\\nTHe complecity is O(v+e) right ?"
                    },
                    {
                        "username": "yiwc63",
                        "content": "Hi, I'm now facing the TLE at testcase 59, and here's my solution below:\n\n\n```cpp=\nclass Solution {\npublic:\n    unordered_map<int, vector<int>> umap;\n    vector<int> ans;\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        for(int i=0; i<n; i++){\n            ans.push_back(0);\n        }\n        unordered_set<int> vertices;\n        vertices.insert(0);\n        for(auto edge:edges){\n            if(vertices.count(edge[0])==1){\n                umap[edge[0]].push_back(edge[1]);\n                vertices.insert(edge[1]);\n            }\n            else{\n                umap[edge[1]].push_back(edge[0]);\n                vertices.insert(edge[0]);\n            }  \n        }\n        vector<int> parents;\n        helper(parents, 0, labels);\n        return ans;\n    }\n    void helper(vector<int>& parents, int current, string& labels){\n        ans[current]++;\n        for(auto parent:parents){\n            if(labels[parent]==labels[current])\n                ans[parent]++;\n        }\n        if(umap.count(current)==0)\n            return;\n        parents.push_back(current);\n        for(auto child:umap[current]){\n            helper(parents, child, labels);\n        }\n        parents.pop_back();\n        return;\n    }\n};\n```\nI'm guessing it has something to do with the repeated record of parents, but im not quite so sure.\nAlso not sure if posting a not AC solution violates the rule, if so, ill take off the post ASAP, thks!"
                    },
                    {
                        "username": "Hazardouz",
                        "content": "Incase you are getting a tle, just make sure the necessary arguments you have passed is by reference and not by value. I was accidentally passing a vector by value causing tle. Good luck :)"
                    },
                    {
                        "username": "TuringJest",
                        "content": "Follow up:\\nNow solve it in linear time! "
                    },
                    {
                        "username": "user3197I",
                        "content": "Guys I am going crazy. Can someone please describe to me what is wrong with my solution? I debug and see the Integer count getting updated, but once the method returns back to main, the count resets to 0. Please help me out... I cannot anymore with this.\\n\\n```class Solution {\\n    private void dfs(int node, HashMap<Integer, ArrayList<Integer>> T, Integer count, char[] labels, char label) {\\n        if (labels[node] == label) {\\n            count += 1;\\n        }\\n\\n        ArrayList<Integer> children = T.getOrDefault(node, new ArrayList<>());\\n\\n        for (Integer child : children) {\\n            dfs(child, T, count, labels, label);\\n        }\\n    }\\n\\n\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        HashMap<Integer, ArrayList<Integer>> tree = new HashMap<>();\\n        for (int i = 0; i < edges.length; i++) { //making adjacency list\\n            ArrayList<Integer> children = tree.getOrDefault(edges[i][0], new ArrayList<>());\\n            children.add(edges[i][1]);\\n            tree.put(edges[i][0], children);\\n        }\\n\\n        int[] freq = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            Integer count = new Integer(0);\\n            dfs(i, tree, count, labels.toCharArray(), labels.charAt(i));\\n            freq[i] = count;\\n        }\\n\\n        return freq;\\n    }\\n}"
                    },
                    {
                        "username": "user8296H",
                        "content": "Great problem to practice recursion, DP and graphs!\\nI liked the idea of passing maps between sub trees and collecting them in the parent node.\\n\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "Sigh, why does Leetcode have to throw in cheap complexity by messing up the edge inputs. I feel like half of the difficulty is on properly parsing the edges and building a tree (and I am pretty sure I will trip on that in an actual interview)."
                    },
                    {
                        "username": "Michellead",
                        "content": "This is definitely not entirely a medium question, but it a great one.\\n\\nUse DFS for Traversal."
                    },
                    {
                        "username": "fortnighter",
                        "content": " I tried solving this problem by iterative method but still I am getting TLE in 58th test case. Can anyone help me how can I further optimize my code.\\n\\n class Solution {\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        int size = edges.size()+1;\\n        vector<vector<int>>vn(size);\\n\\n        for(auto a : edges){\\n            vn[a[0]].push_back(a[1]);\\n            vn[a[1]].push_back(a[0]);\\n        }\\n\\n        vector<int>ans(size, 0);\\n        vector<int>vis(size, 0);\\n\\n        vector<int>arr;\\n\\n        queue<int>qe;\\n        qe.push(0);\\n\\n        while(!qe.empty()){\\n            int y = qe.front();\\n            vis[y] = 1;\\n            arr.push_back(y);\\n            qe.pop();\\n            for(int a:vn[y]){\\n                if(!vis[a])qe.push(a);\\n            }\\n        }\\n\\n        vector<int>vis2(size, 0);\\n        unordered_map<char, int>mlp;\\n\\n        for(char i : labels){\\n            mlp[i]++;\\n            \\n        }\\n\\n        \\n\\n        int sz = arr.size();\\n\\n        unordered_map<int, unordered_map<char, int>>mp;\\n\\n        for(int i = arr.size()-1; i >= 0; i--){\\n            int rewq = arr[i];\\n            if(vn[rewq].size() == 1 & rewq != 0){\\n                unordered_map<char, int>mp1;\\n                mp1[labels[rewq]] = 1;\\n                mp[rewq] = mp1;\\n                ans[rewq] = 1;\\n                vis2[rewq] = 1;\\n            }else{\\n                int cnt = 1;\\n                char ch = labels[rewq];\\n                unordered_map<char, int>mpIn;\\n                mpIn[ch] = 1;\\n                for(int uyt : vn[rewq]){\\n                        if(vis2[uyt]){\\n                        unordered_map<char, int>mp1 = mp[uyt];\\n                        if(mp1.find(ch) != mp1.end())cnt += mp1[ch];\\n                        if(rewq != 0)\\n                        for(auto it = mlp.begin(); it != mlp.end(); it++){\\n                            char ch1 = it->first;\\n                            if(mp1.find(ch1) != mp1.end())mpIn[ch1] += mp1[ch1];\\n                        }\\n\\n                    }\\n                }\\n                mpIn[ch] = cnt;\\n                mp[rewq] = mpIn;\\n                ans[rewq] = mpIn[ch];\\n                vis2[rewq] = 1;\\n                \\n            }\\n            \\n            mlp[labels[rewq]] += -1;\\n            if(mlp[labels[rewq]] <= 0)mlp.erase(labels[rewq]);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1754881,
                "content": [
                    {
                        "username": "h3ct0r",
                        "content": "This should be a hard problem! A simple BFS will give timeout!"
                    },
                    {
                        "username": "prajapatkartik1",
                        "content": "Can anyone help me about why this solution is giving TLE. [Link to solution](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/submissions/876692070/)\\nclass Solution {\\npublic:\\n    void sameLabel(int n,vector<vector<int>>& graph, vector<int>& ans, string labels, int source,vector<bool> parent,int pred){\\n        parent[source]=true;\\n        for(int i=0;i<graph[source].size();i++){\\n            if(graph[source][i]!=pred){\\n                sameLabel(n,graph,ans,labels,graph[source][i],parent,source);\\n            }\\n        }\\n        for(int i=0;i<parent.size();i++){\\n            if(parent[i]==true && labels[i]==labels[source]){\\n                ans[i]++;\\n            }\\n        }\\n        parent[source]=false;\\n        return;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        if(edges.size()==0){\\n            return {1};\\n        }\\n        vector<vector<int>> graph(n);\\n        vector<int> ans(n);\\n        vector<bool> parent(n,false);\\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        sameLabel(n,graph,ans,labels,0,parent,-1);\\n        return ans;\\n    }\\n};\\nTHe complecity is O(v+e) right ?"
                    },
                    {
                        "username": "yiwc63",
                        "content": "Hi, I'm now facing the TLE at testcase 59, and here's my solution below:\n\n\n```cpp=\nclass Solution {\npublic:\n    unordered_map<int, vector<int>> umap;\n    vector<int> ans;\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        for(int i=0; i<n; i++){\n            ans.push_back(0);\n        }\n        unordered_set<int> vertices;\n        vertices.insert(0);\n        for(auto edge:edges){\n            if(vertices.count(edge[0])==1){\n                umap[edge[0]].push_back(edge[1]);\n                vertices.insert(edge[1]);\n            }\n            else{\n                umap[edge[1]].push_back(edge[0]);\n                vertices.insert(edge[0]);\n            }  \n        }\n        vector<int> parents;\n        helper(parents, 0, labels);\n        return ans;\n    }\n    void helper(vector<int>& parents, int current, string& labels){\n        ans[current]++;\n        for(auto parent:parents){\n            if(labels[parent]==labels[current])\n                ans[parent]++;\n        }\n        if(umap.count(current)==0)\n            return;\n        parents.push_back(current);\n        for(auto child:umap[current]){\n            helper(parents, child, labels);\n        }\n        parents.pop_back();\n        return;\n    }\n};\n```\nI'm guessing it has something to do with the repeated record of parents, but im not quite so sure.\nAlso not sure if posting a not AC solution violates the rule, if so, ill take off the post ASAP, thks!"
                    },
                    {
                        "username": "Hazardouz",
                        "content": "Incase you are getting a tle, just make sure the necessary arguments you have passed is by reference and not by value. I was accidentally passing a vector by value causing tle. Good luck :)"
                    },
                    {
                        "username": "TuringJest",
                        "content": "Follow up:\\nNow solve it in linear time! "
                    },
                    {
                        "username": "user3197I",
                        "content": "Guys I am going crazy. Can someone please describe to me what is wrong with my solution? I debug and see the Integer count getting updated, but once the method returns back to main, the count resets to 0. Please help me out... I cannot anymore with this.\\n\\n```class Solution {\\n    private void dfs(int node, HashMap<Integer, ArrayList<Integer>> T, Integer count, char[] labels, char label) {\\n        if (labels[node] == label) {\\n            count += 1;\\n        }\\n\\n        ArrayList<Integer> children = T.getOrDefault(node, new ArrayList<>());\\n\\n        for (Integer child : children) {\\n            dfs(child, T, count, labels, label);\\n        }\\n    }\\n\\n\\n    public int[] countSubTrees(int n, int[][] edges, String labels) {\\n        HashMap<Integer, ArrayList<Integer>> tree = new HashMap<>();\\n        for (int i = 0; i < edges.length; i++) { //making adjacency list\\n            ArrayList<Integer> children = tree.getOrDefault(edges[i][0], new ArrayList<>());\\n            children.add(edges[i][1]);\\n            tree.put(edges[i][0], children);\\n        }\\n\\n        int[] freq = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            Integer count = new Integer(0);\\n            dfs(i, tree, count, labels.toCharArray(), labels.charAt(i));\\n            freq[i] = count;\\n        }\\n\\n        return freq;\\n    }\\n}"
                    },
                    {
                        "username": "user8296H",
                        "content": "Great problem to practice recursion, DP and graphs!\\nI liked the idea of passing maps between sub trees and collecting them in the parent node.\\n\\n"
                    },
                    {
                        "username": "Furies",
                        "content": "Sigh, why does Leetcode have to throw in cheap complexity by messing up the edge inputs. I feel like half of the difficulty is on properly parsing the edges and building a tree (and I am pretty sure I will trip on that in an actual interview)."
                    },
                    {
                        "username": "Michellead",
                        "content": "This is definitely not entirely a medium question, but it a great one.\\n\\nUse DFS for Traversal."
                    },
                    {
                        "username": "fortnighter",
                        "content": " I tried solving this problem by iterative method but still I am getting TLE in 58th test case. Can anyone help me how can I further optimize my code.\\n\\n class Solution {\\npublic:\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        int size = edges.size()+1;\\n        vector<vector<int>>vn(size);\\n\\n        for(auto a : edges){\\n            vn[a[0]].push_back(a[1]);\\n            vn[a[1]].push_back(a[0]);\\n        }\\n\\n        vector<int>ans(size, 0);\\n        vector<int>vis(size, 0);\\n\\n        vector<int>arr;\\n\\n        queue<int>qe;\\n        qe.push(0);\\n\\n        while(!qe.empty()){\\n            int y = qe.front();\\n            vis[y] = 1;\\n            arr.push_back(y);\\n            qe.pop();\\n            for(int a:vn[y]){\\n                if(!vis[a])qe.push(a);\\n            }\\n        }\\n\\n        vector<int>vis2(size, 0);\\n        unordered_map<char, int>mlp;\\n\\n        for(char i : labels){\\n            mlp[i]++;\\n            \\n        }\\n\\n        \\n\\n        int sz = arr.size();\\n\\n        unordered_map<int, unordered_map<char, int>>mp;\\n\\n        for(int i = arr.size()-1; i >= 0; i--){\\n            int rewq = arr[i];\\n            if(vn[rewq].size() == 1 & rewq != 0){\\n                unordered_map<char, int>mp1;\\n                mp1[labels[rewq]] = 1;\\n                mp[rewq] = mp1;\\n                ans[rewq] = 1;\\n                vis2[rewq] = 1;\\n            }else{\\n                int cnt = 1;\\n                char ch = labels[rewq];\\n                unordered_map<char, int>mpIn;\\n                mpIn[ch] = 1;\\n                for(int uyt : vn[rewq]){\\n                        if(vis2[uyt]){\\n                        unordered_map<char, int>mp1 = mp[uyt];\\n                        if(mp1.find(ch) != mp1.end())cnt += mp1[ch];\\n                        if(rewq != 0)\\n                        for(auto it = mlp.begin(); it != mlp.end(); it++){\\n                            char ch1 = it->first;\\n                            if(mp1.find(ch1) != mp1.end())mpIn[ch1] += mp1[ch1];\\n                        }\\n\\n                    }\\n                }\\n                mpIn[ch] = cnt;\\n                mp[rewq] = mpIn;\\n                ans[rewq] = mpIn[ch];\\n                vis2[rewq] = 1;\\n                \\n            }\\n            \\n            mlp[labels[rewq]] += -1;\\n            if(mlp[labels[rewq]] <= 0)mlp.erase(labels[rewq]);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1754871,
                "content": [
                    {
                        "username": "djslim",
                        "content": "Very similar to yesterday\\'s daily: https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/ and https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/ , postorder dfs"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "Administrators noticed discission from previous day challenge and add the word undirected for graph! Thank guys for your work"
                    },
                    {
                        "username": "tamyte",
                        "content": " class Solution {\\npublic:\\n    vector<int> dfs(int node, int par, vector<int>& ans, vector<vector<int>>& adj, string lab) {\\n        vector<int> cnt(26);\\n        cnt[lab[node] - \\'a\\'] = 1;\\n        for (auto& u : adj[node]) {\\n            if (u == par) continue;\\n            vector<int> child = dfs(u, node, ans, adj, lab);\\n            for (int i = 0; i < 26; ++i) {\\n                cnt[i] += child[i];\\n            }\\n        }\\n        ans[node] = cnt[lab[node] - \\'a\\'];\\n        return cnt;\\n    }\\n\\n   vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> ans(n);\\n        vector<vector<int>> adj(n);\\n        for (auto& u : edges) {\\n            adj[u[0]].push_back(u[1]);\\n            adj[u[1]].push_back(u[0]);\\n        }\\n        dfs(0, -1, ans, adj, labels);\\n        return ans;\\n    }\\n};\\nwhy is this code gives me TLE, but when I put string& lab it gives me AC?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `lab` by value, so the `labels` get copied many many times. Make that a reference instead."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The key point is to use a DFS to traverse the entire graph. Because you need to return *multiple values* to the parent, returning a dictionary/hashmap with the count of each word could be a good approach `{a: 1, b: 5, c:3}`, so the parent can then do something with that information\\n\\nAlso, if you are trying to solve this using PHP don\\'t forget to add the `&` operator if you try to implement a `DFS` function, because the RAM will explode if you try to mutate an array inside a function \\uD83D\\uDE05"
                    },
                    {
                        "username": "fader891108",
                        "content": "I used python and I used copy() function to copy my dictionary. I tried to find nodes on different subtree. Each time I just pick one subtree and move on. When I pick the subtree I gave it my current dictionary. However my dictionary changes as I run my code. Does anyone know how to avoid this? Thanks\\n\\n        res = [1]*n\\n        net = collections.defaultdict(list)#tree\\n        visit = [0]*n\\n        visit[0] = 1\\n        for e in edges:\\n            net[e[0]].append(e[1])\\n            net[e[1]].append(e[0])\\n        def findres(cur,cnt):\\n            c = labels[cur]\\n            print(cur,cnt)\\n            if cnt[c]:\\n                for node in cnt[c]:\\n                    res[node] += 1\\n            cnt[c].append(cur)\\n            for nex in net[cur]:\\n                if visit[nex] == 0:\\n                    new = cnt.copy()\\n                    visit[nex] = 1\\n                    findres(nex,new)\\n\\n        cnt = collections.defaultdict(list)\\n        findres(0,cnt)\\n        return res"
                    },
                    {
                        "username": "abhijeetsinhaa",
                        "content": "If someone is stuck because of TLE then try passing labels(given string) by reference.It worked for me.Passing string directly would create copies of string in each function call."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Number of discussions were awkward, so here is the 70th one."
                    },
                    {
                        "username": "tanujtvs2552",
                        "content": "If you are doing BFS all testcases are not passing due to TLE, try doing DFS. \\nDont know why BFS is failing in the last test case."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "It is really funny that people are first passing string by value in recursive function call, then getting a TLE, and then optimizing by passing by reference. But the thing is that there is NO NEED TO PASS THE STRING at all!!. Just copy it in a global variable and keep accessing it. 😉😉"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "If you are getting `TLE` after writing correct solution, then check you have passed string `labels` with reference."
                    }
                ]
            },
            {
                "id": 1754865,
                "content": [
                    {
                        "username": "djslim",
                        "content": "Very similar to yesterday\\'s daily: https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/ and https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/ , postorder dfs"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "Administrators noticed discission from previous day challenge and add the word undirected for graph! Thank guys for your work"
                    },
                    {
                        "username": "tamyte",
                        "content": " class Solution {\\npublic:\\n    vector<int> dfs(int node, int par, vector<int>& ans, vector<vector<int>>& adj, string lab) {\\n        vector<int> cnt(26);\\n        cnt[lab[node] - \\'a\\'] = 1;\\n        for (auto& u : adj[node]) {\\n            if (u == par) continue;\\n            vector<int> child = dfs(u, node, ans, adj, lab);\\n            for (int i = 0; i < 26; ++i) {\\n                cnt[i] += child[i];\\n            }\\n        }\\n        ans[node] = cnt[lab[node] - \\'a\\'];\\n        return cnt;\\n    }\\n\\n   vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> ans(n);\\n        vector<vector<int>> adj(n);\\n        for (auto& u : edges) {\\n            adj[u[0]].push_back(u[1]);\\n            adj[u[1]].push_back(u[0]);\\n        }\\n        dfs(0, -1, ans, adj, labels);\\n        return ans;\\n    }\\n};\\nwhy is this code gives me TLE, but when I put string& lab it gives me AC?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `lab` by value, so the `labels` get copied many many times. Make that a reference instead."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The key point is to use a DFS to traverse the entire graph. Because you need to return *multiple values* to the parent, returning a dictionary/hashmap with the count of each word could be a good approach `{a: 1, b: 5, c:3}`, so the parent can then do something with that information\\n\\nAlso, if you are trying to solve this using PHP don\\'t forget to add the `&` operator if you try to implement a `DFS` function, because the RAM will explode if you try to mutate an array inside a function \\uD83D\\uDE05"
                    },
                    {
                        "username": "fader891108",
                        "content": "I used python and I used copy() function to copy my dictionary. I tried to find nodes on different subtree. Each time I just pick one subtree and move on. When I pick the subtree I gave it my current dictionary. However my dictionary changes as I run my code. Does anyone know how to avoid this? Thanks\\n\\n        res = [1]*n\\n        net = collections.defaultdict(list)#tree\\n        visit = [0]*n\\n        visit[0] = 1\\n        for e in edges:\\n            net[e[0]].append(e[1])\\n            net[e[1]].append(e[0])\\n        def findres(cur,cnt):\\n            c = labels[cur]\\n            print(cur,cnt)\\n            if cnt[c]:\\n                for node in cnt[c]:\\n                    res[node] += 1\\n            cnt[c].append(cur)\\n            for nex in net[cur]:\\n                if visit[nex] == 0:\\n                    new = cnt.copy()\\n                    visit[nex] = 1\\n                    findres(nex,new)\\n\\n        cnt = collections.defaultdict(list)\\n        findres(0,cnt)\\n        return res"
                    },
                    {
                        "username": "abhijeetsinhaa",
                        "content": "If someone is stuck because of TLE then try passing labels(given string) by reference.It worked for me.Passing string directly would create copies of string in each function call."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Number of discussions were awkward, so here is the 70th one."
                    },
                    {
                        "username": "tanujtvs2552",
                        "content": "If you are doing BFS all testcases are not passing due to TLE, try doing DFS. \\nDont know why BFS is failing in the last test case."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "It is really funny that people are first passing string by value in recursive function call, then getting a TLE, and then optimizing by passing by reference. But the thing is that there is NO NEED TO PASS THE STRING at all!!. Just copy it in a global variable and keep accessing it. 😉😉"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "If you are getting `TLE` after writing correct solution, then check you have passed string `labels` with reference."
                    }
                ]
            },
            {
                "id": 1754848,
                "content": [
                    {
                        "username": "djslim",
                        "content": "Very similar to yesterday\\'s daily: https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/ and https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/ , postorder dfs"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "Administrators noticed discission from previous day challenge and add the word undirected for graph! Thank guys for your work"
                    },
                    {
                        "username": "tamyte",
                        "content": " class Solution {\\npublic:\\n    vector<int> dfs(int node, int par, vector<int>& ans, vector<vector<int>>& adj, string lab) {\\n        vector<int> cnt(26);\\n        cnt[lab[node] - \\'a\\'] = 1;\\n        for (auto& u : adj[node]) {\\n            if (u == par) continue;\\n            vector<int> child = dfs(u, node, ans, adj, lab);\\n            for (int i = 0; i < 26; ++i) {\\n                cnt[i] += child[i];\\n            }\\n        }\\n        ans[node] = cnt[lab[node] - \\'a\\'];\\n        return cnt;\\n    }\\n\\n   vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> ans(n);\\n        vector<vector<int>> adj(n);\\n        for (auto& u : edges) {\\n            adj[u[0]].push_back(u[1]);\\n            adj[u[1]].push_back(u[0]);\\n        }\\n        dfs(0, -1, ans, adj, labels);\\n        return ans;\\n    }\\n};\\nwhy is this code gives me TLE, but when I put string& lab it gives me AC?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `lab` by value, so the `labels` get copied many many times. Make that a reference instead."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The key point is to use a DFS to traverse the entire graph. Because you need to return *multiple values* to the parent, returning a dictionary/hashmap with the count of each word could be a good approach `{a: 1, b: 5, c:3}`, so the parent can then do something with that information\\n\\nAlso, if you are trying to solve this using PHP don\\'t forget to add the `&` operator if you try to implement a `DFS` function, because the RAM will explode if you try to mutate an array inside a function \\uD83D\\uDE05"
                    },
                    {
                        "username": "fader891108",
                        "content": "I used python and I used copy() function to copy my dictionary. I tried to find nodes on different subtree. Each time I just pick one subtree and move on. When I pick the subtree I gave it my current dictionary. However my dictionary changes as I run my code. Does anyone know how to avoid this? Thanks\\n\\n        res = [1]*n\\n        net = collections.defaultdict(list)#tree\\n        visit = [0]*n\\n        visit[0] = 1\\n        for e in edges:\\n            net[e[0]].append(e[1])\\n            net[e[1]].append(e[0])\\n        def findres(cur,cnt):\\n            c = labels[cur]\\n            print(cur,cnt)\\n            if cnt[c]:\\n                for node in cnt[c]:\\n                    res[node] += 1\\n            cnt[c].append(cur)\\n            for nex in net[cur]:\\n                if visit[nex] == 0:\\n                    new = cnt.copy()\\n                    visit[nex] = 1\\n                    findres(nex,new)\\n\\n        cnt = collections.defaultdict(list)\\n        findres(0,cnt)\\n        return res"
                    },
                    {
                        "username": "abhijeetsinhaa",
                        "content": "If someone is stuck because of TLE then try passing labels(given string) by reference.It worked for me.Passing string directly would create copies of string in each function call."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Number of discussions were awkward, so here is the 70th one."
                    },
                    {
                        "username": "tanujtvs2552",
                        "content": "If you are doing BFS all testcases are not passing due to TLE, try doing DFS. \\nDont know why BFS is failing in the last test case."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "It is really funny that people are first passing string by value in recursive function call, then getting a TLE, and then optimizing by passing by reference. But the thing is that there is NO NEED TO PASS THE STRING at all!!. Just copy it in a global variable and keep accessing it. 😉😉"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "If you are getting `TLE` after writing correct solution, then check you have passed string `labels` with reference."
                    }
                ]
            },
            {
                "id": 1754832,
                "content": [
                    {
                        "username": "djslim",
                        "content": "Very similar to yesterday\\'s daily: https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/ and https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/ , postorder dfs"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "Administrators noticed discission from previous day challenge and add the word undirected for graph! Thank guys for your work"
                    },
                    {
                        "username": "tamyte",
                        "content": " class Solution {\\npublic:\\n    vector<int> dfs(int node, int par, vector<int>& ans, vector<vector<int>>& adj, string lab) {\\n        vector<int> cnt(26);\\n        cnt[lab[node] - \\'a\\'] = 1;\\n        for (auto& u : adj[node]) {\\n            if (u == par) continue;\\n            vector<int> child = dfs(u, node, ans, adj, lab);\\n            for (int i = 0; i < 26; ++i) {\\n                cnt[i] += child[i];\\n            }\\n        }\\n        ans[node] = cnt[lab[node] - \\'a\\'];\\n        return cnt;\\n    }\\n\\n   vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> ans(n);\\n        vector<vector<int>> adj(n);\\n        for (auto& u : edges) {\\n            adj[u[0]].push_back(u[1]);\\n            adj[u[1]].push_back(u[0]);\\n        }\\n        dfs(0, -1, ans, adj, labels);\\n        return ans;\\n    }\\n};\\nwhy is this code gives me TLE, but when I put string& lab it gives me AC?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `lab` by value, so the `labels` get copied many many times. Make that a reference instead."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The key point is to use a DFS to traverse the entire graph. Because you need to return *multiple values* to the parent, returning a dictionary/hashmap with the count of each word could be a good approach `{a: 1, b: 5, c:3}`, so the parent can then do something with that information\\n\\nAlso, if you are trying to solve this using PHP don\\'t forget to add the `&` operator if you try to implement a `DFS` function, because the RAM will explode if you try to mutate an array inside a function \\uD83D\\uDE05"
                    },
                    {
                        "username": "fader891108",
                        "content": "I used python and I used copy() function to copy my dictionary. I tried to find nodes on different subtree. Each time I just pick one subtree and move on. When I pick the subtree I gave it my current dictionary. However my dictionary changes as I run my code. Does anyone know how to avoid this? Thanks\\n\\n        res = [1]*n\\n        net = collections.defaultdict(list)#tree\\n        visit = [0]*n\\n        visit[0] = 1\\n        for e in edges:\\n            net[e[0]].append(e[1])\\n            net[e[1]].append(e[0])\\n        def findres(cur,cnt):\\n            c = labels[cur]\\n            print(cur,cnt)\\n            if cnt[c]:\\n                for node in cnt[c]:\\n                    res[node] += 1\\n            cnt[c].append(cur)\\n            for nex in net[cur]:\\n                if visit[nex] == 0:\\n                    new = cnt.copy()\\n                    visit[nex] = 1\\n                    findres(nex,new)\\n\\n        cnt = collections.defaultdict(list)\\n        findres(0,cnt)\\n        return res"
                    },
                    {
                        "username": "abhijeetsinhaa",
                        "content": "If someone is stuck because of TLE then try passing labels(given string) by reference.It worked for me.Passing string directly would create copies of string in each function call."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Number of discussions were awkward, so here is the 70th one."
                    },
                    {
                        "username": "tanujtvs2552",
                        "content": "If you are doing BFS all testcases are not passing due to TLE, try doing DFS. \\nDont know why BFS is failing in the last test case."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "It is really funny that people are first passing string by value in recursive function call, then getting a TLE, and then optimizing by passing by reference. But the thing is that there is NO NEED TO PASS THE STRING at all!!. Just copy it in a global variable and keep accessing it. 😉😉"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "If you are getting `TLE` after writing correct solution, then check you have passed string `labels` with reference."
                    }
                ]
            },
            {
                "id": 1754813,
                "content": [
                    {
                        "username": "djslim",
                        "content": "Very similar to yesterday\\'s daily: https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/ and https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/ , postorder dfs"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "Administrators noticed discission from previous day challenge and add the word undirected for graph! Thank guys for your work"
                    },
                    {
                        "username": "tamyte",
                        "content": " class Solution {\\npublic:\\n    vector<int> dfs(int node, int par, vector<int>& ans, vector<vector<int>>& adj, string lab) {\\n        vector<int> cnt(26);\\n        cnt[lab[node] - \\'a\\'] = 1;\\n        for (auto& u : adj[node]) {\\n            if (u == par) continue;\\n            vector<int> child = dfs(u, node, ans, adj, lab);\\n            for (int i = 0; i < 26; ++i) {\\n                cnt[i] += child[i];\\n            }\\n        }\\n        ans[node] = cnt[lab[node] - \\'a\\'];\\n        return cnt;\\n    }\\n\\n   vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> ans(n);\\n        vector<vector<int>> adj(n);\\n        for (auto& u : edges) {\\n            adj[u[0]].push_back(u[1]);\\n            adj[u[1]].push_back(u[0]);\\n        }\\n        dfs(0, -1, ans, adj, labels);\\n        return ans;\\n    }\\n};\\nwhy is this code gives me TLE, but when I put string& lab it gives me AC?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `lab` by value, so the `labels` get copied many many times. Make that a reference instead."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The key point is to use a DFS to traverse the entire graph. Because you need to return *multiple values* to the parent, returning a dictionary/hashmap with the count of each word could be a good approach `{a: 1, b: 5, c:3}`, so the parent can then do something with that information\\n\\nAlso, if you are trying to solve this using PHP don\\'t forget to add the `&` operator if you try to implement a `DFS` function, because the RAM will explode if you try to mutate an array inside a function \\uD83D\\uDE05"
                    },
                    {
                        "username": "fader891108",
                        "content": "I used python and I used copy() function to copy my dictionary. I tried to find nodes on different subtree. Each time I just pick one subtree and move on. When I pick the subtree I gave it my current dictionary. However my dictionary changes as I run my code. Does anyone know how to avoid this? Thanks\\n\\n        res = [1]*n\\n        net = collections.defaultdict(list)#tree\\n        visit = [0]*n\\n        visit[0] = 1\\n        for e in edges:\\n            net[e[0]].append(e[1])\\n            net[e[1]].append(e[0])\\n        def findres(cur,cnt):\\n            c = labels[cur]\\n            print(cur,cnt)\\n            if cnt[c]:\\n                for node in cnt[c]:\\n                    res[node] += 1\\n            cnt[c].append(cur)\\n            for nex in net[cur]:\\n                if visit[nex] == 0:\\n                    new = cnt.copy()\\n                    visit[nex] = 1\\n                    findres(nex,new)\\n\\n        cnt = collections.defaultdict(list)\\n        findres(0,cnt)\\n        return res"
                    },
                    {
                        "username": "abhijeetsinhaa",
                        "content": "If someone is stuck because of TLE then try passing labels(given string) by reference.It worked for me.Passing string directly would create copies of string in each function call."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Number of discussions were awkward, so here is the 70th one."
                    },
                    {
                        "username": "tanujtvs2552",
                        "content": "If you are doing BFS all testcases are not passing due to TLE, try doing DFS. \\nDont know why BFS is failing in the last test case."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "It is really funny that people are first passing string by value in recursive function call, then getting a TLE, and then optimizing by passing by reference. But the thing is that there is NO NEED TO PASS THE STRING at all!!. Just copy it in a global variable and keep accessing it. 😉😉"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "If you are getting `TLE` after writing correct solution, then check you have passed string `labels` with reference."
                    }
                ]
            },
            {
                "id": 1754811,
                "content": [
                    {
                        "username": "djslim",
                        "content": "Very similar to yesterday\\'s daily: https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/ and https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/ , postorder dfs"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "Administrators noticed discission from previous day challenge and add the word undirected for graph! Thank guys for your work"
                    },
                    {
                        "username": "tamyte",
                        "content": " class Solution {\\npublic:\\n    vector<int> dfs(int node, int par, vector<int>& ans, vector<vector<int>>& adj, string lab) {\\n        vector<int> cnt(26);\\n        cnt[lab[node] - \\'a\\'] = 1;\\n        for (auto& u : adj[node]) {\\n            if (u == par) continue;\\n            vector<int> child = dfs(u, node, ans, adj, lab);\\n            for (int i = 0; i < 26; ++i) {\\n                cnt[i] += child[i];\\n            }\\n        }\\n        ans[node] = cnt[lab[node] - \\'a\\'];\\n        return cnt;\\n    }\\n\\n   vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> ans(n);\\n        vector<vector<int>> adj(n);\\n        for (auto& u : edges) {\\n            adj[u[0]].push_back(u[1]);\\n            adj[u[1]].push_back(u[0]);\\n        }\\n        dfs(0, -1, ans, adj, labels);\\n        return ans;\\n    }\\n};\\nwhy is this code gives me TLE, but when I put string& lab it gives me AC?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `lab` by value, so the `labels` get copied many many times. Make that a reference instead."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The key point is to use a DFS to traverse the entire graph. Because you need to return *multiple values* to the parent, returning a dictionary/hashmap with the count of each word could be a good approach `{a: 1, b: 5, c:3}`, so the parent can then do something with that information\\n\\nAlso, if you are trying to solve this using PHP don\\'t forget to add the `&` operator if you try to implement a `DFS` function, because the RAM will explode if you try to mutate an array inside a function \\uD83D\\uDE05"
                    },
                    {
                        "username": "fader891108",
                        "content": "I used python and I used copy() function to copy my dictionary. I tried to find nodes on different subtree. Each time I just pick one subtree and move on. When I pick the subtree I gave it my current dictionary. However my dictionary changes as I run my code. Does anyone know how to avoid this? Thanks\\n\\n        res = [1]*n\\n        net = collections.defaultdict(list)#tree\\n        visit = [0]*n\\n        visit[0] = 1\\n        for e in edges:\\n            net[e[0]].append(e[1])\\n            net[e[1]].append(e[0])\\n        def findres(cur,cnt):\\n            c = labels[cur]\\n            print(cur,cnt)\\n            if cnt[c]:\\n                for node in cnt[c]:\\n                    res[node] += 1\\n            cnt[c].append(cur)\\n            for nex in net[cur]:\\n                if visit[nex] == 0:\\n                    new = cnt.copy()\\n                    visit[nex] = 1\\n                    findres(nex,new)\\n\\n        cnt = collections.defaultdict(list)\\n        findres(0,cnt)\\n        return res"
                    },
                    {
                        "username": "abhijeetsinhaa",
                        "content": "If someone is stuck because of TLE then try passing labels(given string) by reference.It worked for me.Passing string directly would create copies of string in each function call."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Number of discussions were awkward, so here is the 70th one."
                    },
                    {
                        "username": "tanujtvs2552",
                        "content": "If you are doing BFS all testcases are not passing due to TLE, try doing DFS. \\nDont know why BFS is failing in the last test case."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "It is really funny that people are first passing string by value in recursive function call, then getting a TLE, and then optimizing by passing by reference. But the thing is that there is NO NEED TO PASS THE STRING at all!!. Just copy it in a global variable and keep accessing it. 😉😉"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "If you are getting `TLE` after writing correct solution, then check you have passed string `labels` with reference."
                    }
                ]
            },
            {
                "id": 1754806,
                "content": [
                    {
                        "username": "djslim",
                        "content": "Very similar to yesterday\\'s daily: https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/ and https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/ , postorder dfs"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "Administrators noticed discission from previous day challenge and add the word undirected for graph! Thank guys for your work"
                    },
                    {
                        "username": "tamyte",
                        "content": " class Solution {\\npublic:\\n    vector<int> dfs(int node, int par, vector<int>& ans, vector<vector<int>>& adj, string lab) {\\n        vector<int> cnt(26);\\n        cnt[lab[node] - \\'a\\'] = 1;\\n        for (auto& u : adj[node]) {\\n            if (u == par) continue;\\n            vector<int> child = dfs(u, node, ans, adj, lab);\\n            for (int i = 0; i < 26; ++i) {\\n                cnt[i] += child[i];\\n            }\\n        }\\n        ans[node] = cnt[lab[node] - \\'a\\'];\\n        return cnt;\\n    }\\n\\n   vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> ans(n);\\n        vector<vector<int>> adj(n);\\n        for (auto& u : edges) {\\n            adj[u[0]].push_back(u[1]);\\n            adj[u[1]].push_back(u[0]);\\n        }\\n        dfs(0, -1, ans, adj, labels);\\n        return ans;\\n    }\\n};\\nwhy is this code gives me TLE, but when I put string& lab it gives me AC?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `lab` by value, so the `labels` get copied many many times. Make that a reference instead."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The key point is to use a DFS to traverse the entire graph. Because you need to return *multiple values* to the parent, returning a dictionary/hashmap with the count of each word could be a good approach `{a: 1, b: 5, c:3}`, so the parent can then do something with that information\\n\\nAlso, if you are trying to solve this using PHP don\\'t forget to add the `&` operator if you try to implement a `DFS` function, because the RAM will explode if you try to mutate an array inside a function \\uD83D\\uDE05"
                    },
                    {
                        "username": "fader891108",
                        "content": "I used python and I used copy() function to copy my dictionary. I tried to find nodes on different subtree. Each time I just pick one subtree and move on. When I pick the subtree I gave it my current dictionary. However my dictionary changes as I run my code. Does anyone know how to avoid this? Thanks\\n\\n        res = [1]*n\\n        net = collections.defaultdict(list)#tree\\n        visit = [0]*n\\n        visit[0] = 1\\n        for e in edges:\\n            net[e[0]].append(e[1])\\n            net[e[1]].append(e[0])\\n        def findres(cur,cnt):\\n            c = labels[cur]\\n            print(cur,cnt)\\n            if cnt[c]:\\n                for node in cnt[c]:\\n                    res[node] += 1\\n            cnt[c].append(cur)\\n            for nex in net[cur]:\\n                if visit[nex] == 0:\\n                    new = cnt.copy()\\n                    visit[nex] = 1\\n                    findres(nex,new)\\n\\n        cnt = collections.defaultdict(list)\\n        findres(0,cnt)\\n        return res"
                    },
                    {
                        "username": "abhijeetsinhaa",
                        "content": "If someone is stuck because of TLE then try passing labels(given string) by reference.It worked for me.Passing string directly would create copies of string in each function call."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Number of discussions were awkward, so here is the 70th one."
                    },
                    {
                        "username": "tanujtvs2552",
                        "content": "If you are doing BFS all testcases are not passing due to TLE, try doing DFS. \\nDont know why BFS is failing in the last test case."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "It is really funny that people are first passing string by value in recursive function call, then getting a TLE, and then optimizing by passing by reference. But the thing is that there is NO NEED TO PASS THE STRING at all!!. Just copy it in a global variable and keep accessing it. 😉😉"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "If you are getting `TLE` after writing correct solution, then check you have passed string `labels` with reference."
                    }
                ]
            },
            {
                "id": 1754685,
                "content": [
                    {
                        "username": "djslim",
                        "content": "Very similar to yesterday\\'s daily: https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/ and https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/ , postorder dfs"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "Administrators noticed discission from previous day challenge and add the word undirected for graph! Thank guys for your work"
                    },
                    {
                        "username": "tamyte",
                        "content": " class Solution {\\npublic:\\n    vector<int> dfs(int node, int par, vector<int>& ans, vector<vector<int>>& adj, string lab) {\\n        vector<int> cnt(26);\\n        cnt[lab[node] - \\'a\\'] = 1;\\n        for (auto& u : adj[node]) {\\n            if (u == par) continue;\\n            vector<int> child = dfs(u, node, ans, adj, lab);\\n            for (int i = 0; i < 26; ++i) {\\n                cnt[i] += child[i];\\n            }\\n        }\\n        ans[node] = cnt[lab[node] - \\'a\\'];\\n        return cnt;\\n    }\\n\\n   vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> ans(n);\\n        vector<vector<int>> adj(n);\\n        for (auto& u : edges) {\\n            adj[u[0]].push_back(u[1]);\\n            adj[u[1]].push_back(u[0]);\\n        }\\n        dfs(0, -1, ans, adj, labels);\\n        return ans;\\n    }\\n};\\nwhy is this code gives me TLE, but when I put string& lab it gives me AC?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `lab` by value, so the `labels` get copied many many times. Make that a reference instead."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The key point is to use a DFS to traverse the entire graph. Because you need to return *multiple values* to the parent, returning a dictionary/hashmap with the count of each word could be a good approach `{a: 1, b: 5, c:3}`, so the parent can then do something with that information\\n\\nAlso, if you are trying to solve this using PHP don\\'t forget to add the `&` operator if you try to implement a `DFS` function, because the RAM will explode if you try to mutate an array inside a function \\uD83D\\uDE05"
                    },
                    {
                        "username": "fader891108",
                        "content": "I used python and I used copy() function to copy my dictionary. I tried to find nodes on different subtree. Each time I just pick one subtree and move on. When I pick the subtree I gave it my current dictionary. However my dictionary changes as I run my code. Does anyone know how to avoid this? Thanks\\n\\n        res = [1]*n\\n        net = collections.defaultdict(list)#tree\\n        visit = [0]*n\\n        visit[0] = 1\\n        for e in edges:\\n            net[e[0]].append(e[1])\\n            net[e[1]].append(e[0])\\n        def findres(cur,cnt):\\n            c = labels[cur]\\n            print(cur,cnt)\\n            if cnt[c]:\\n                for node in cnt[c]:\\n                    res[node] += 1\\n            cnt[c].append(cur)\\n            for nex in net[cur]:\\n                if visit[nex] == 0:\\n                    new = cnt.copy()\\n                    visit[nex] = 1\\n                    findres(nex,new)\\n\\n        cnt = collections.defaultdict(list)\\n        findres(0,cnt)\\n        return res"
                    },
                    {
                        "username": "abhijeetsinhaa",
                        "content": "If someone is stuck because of TLE then try passing labels(given string) by reference.It worked for me.Passing string directly would create copies of string in each function call."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Number of discussions were awkward, so here is the 70th one."
                    },
                    {
                        "username": "tanujtvs2552",
                        "content": "If you are doing BFS all testcases are not passing due to TLE, try doing DFS. \\nDont know why BFS is failing in the last test case."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "It is really funny that people are first passing string by value in recursive function call, then getting a TLE, and then optimizing by passing by reference. But the thing is that there is NO NEED TO PASS THE STRING at all!!. Just copy it in a global variable and keep accessing it. 😉😉"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "If you are getting `TLE` after writing correct solution, then check you have passed string `labels` with reference."
                    }
                ]
            },
            {
                "id": 1754659,
                "content": [
                    {
                        "username": "djslim",
                        "content": "Very similar to yesterday\\'s daily: https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/ and https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/ , postorder dfs"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "Administrators noticed discission from previous day challenge and add the word undirected for graph! Thank guys for your work"
                    },
                    {
                        "username": "tamyte",
                        "content": " class Solution {\\npublic:\\n    vector<int> dfs(int node, int par, vector<int>& ans, vector<vector<int>>& adj, string lab) {\\n        vector<int> cnt(26);\\n        cnt[lab[node] - \\'a\\'] = 1;\\n        for (auto& u : adj[node]) {\\n            if (u == par) continue;\\n            vector<int> child = dfs(u, node, ans, adj, lab);\\n            for (int i = 0; i < 26; ++i) {\\n                cnt[i] += child[i];\\n            }\\n        }\\n        ans[node] = cnt[lab[node] - \\'a\\'];\\n        return cnt;\\n    }\\n\\n   vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> ans(n);\\n        vector<vector<int>> adj(n);\\n        for (auto& u : edges) {\\n            adj[u[0]].push_back(u[1]);\\n            adj[u[1]].push_back(u[0]);\\n        }\\n        dfs(0, -1, ans, adj, labels);\\n        return ans;\\n    }\\n};\\nwhy is this code gives me TLE, but when I put string& lab it gives me AC?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `lab` by value, so the `labels` get copied many many times. Make that a reference instead."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The key point is to use a DFS to traverse the entire graph. Because you need to return *multiple values* to the parent, returning a dictionary/hashmap with the count of each word could be a good approach `{a: 1, b: 5, c:3}`, so the parent can then do something with that information\\n\\nAlso, if you are trying to solve this using PHP don\\'t forget to add the `&` operator if you try to implement a `DFS` function, because the RAM will explode if you try to mutate an array inside a function \\uD83D\\uDE05"
                    },
                    {
                        "username": "fader891108",
                        "content": "I used python and I used copy() function to copy my dictionary. I tried to find nodes on different subtree. Each time I just pick one subtree and move on. When I pick the subtree I gave it my current dictionary. However my dictionary changes as I run my code. Does anyone know how to avoid this? Thanks\\n\\n        res = [1]*n\\n        net = collections.defaultdict(list)#tree\\n        visit = [0]*n\\n        visit[0] = 1\\n        for e in edges:\\n            net[e[0]].append(e[1])\\n            net[e[1]].append(e[0])\\n        def findres(cur,cnt):\\n            c = labels[cur]\\n            print(cur,cnt)\\n            if cnt[c]:\\n                for node in cnt[c]:\\n                    res[node] += 1\\n            cnt[c].append(cur)\\n            for nex in net[cur]:\\n                if visit[nex] == 0:\\n                    new = cnt.copy()\\n                    visit[nex] = 1\\n                    findres(nex,new)\\n\\n        cnt = collections.defaultdict(list)\\n        findres(0,cnt)\\n        return res"
                    },
                    {
                        "username": "abhijeetsinhaa",
                        "content": "If someone is stuck because of TLE then try passing labels(given string) by reference.It worked for me.Passing string directly would create copies of string in each function call."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Number of discussions were awkward, so here is the 70th one."
                    },
                    {
                        "username": "tanujtvs2552",
                        "content": "If you are doing BFS all testcases are not passing due to TLE, try doing DFS. \\nDont know why BFS is failing in the last test case."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "It is really funny that people are first passing string by value in recursive function call, then getting a TLE, and then optimizing by passing by reference. But the thing is that there is NO NEED TO PASS THE STRING at all!!. Just copy it in a global variable and keep accessing it. 😉😉"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "If you are getting `TLE` after writing correct solution, then check you have passed string `labels` with reference."
                    }
                ]
            },
            {
                "id": 1754590,
                "content": [
                    {
                        "username": "djslim",
                        "content": "Very similar to yesterday\\'s daily: https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/ and https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/ , postorder dfs"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "Administrators noticed discission from previous day challenge and add the word undirected for graph! Thank guys for your work"
                    },
                    {
                        "username": "tamyte",
                        "content": " class Solution {\\npublic:\\n    vector<int> dfs(int node, int par, vector<int>& ans, vector<vector<int>>& adj, string lab) {\\n        vector<int> cnt(26);\\n        cnt[lab[node] - \\'a\\'] = 1;\\n        for (auto& u : adj[node]) {\\n            if (u == par) continue;\\n            vector<int> child = dfs(u, node, ans, adj, lab);\\n            for (int i = 0; i < 26; ++i) {\\n                cnt[i] += child[i];\\n            }\\n        }\\n        ans[node] = cnt[lab[node] - \\'a\\'];\\n        return cnt;\\n    }\\n\\n   vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        vector<int> ans(n);\\n        vector<vector<int>> adj(n);\\n        for (auto& u : edges) {\\n            adj[u[0]].push_back(u[1]);\\n            adj[u[1]].push_back(u[0]);\\n        }\\n        dfs(0, -1, ans, adj, labels);\\n        return ans;\\n    }\\n};\\nwhy is this code gives me TLE, but when I put string& lab it gives me AC?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`dfs()` takes its parameter `lab` by value, so the `labels` get copied many many times. Make that a reference instead."
                    },
                    {
                        "username": "JuanQP",
                        "content": "The key point is to use a DFS to traverse the entire graph. Because you need to return *multiple values* to the parent, returning a dictionary/hashmap with the count of each word could be a good approach `{a: 1, b: 5, c:3}`, so the parent can then do something with that information\\n\\nAlso, if you are trying to solve this using PHP don\\'t forget to add the `&` operator if you try to implement a `DFS` function, because the RAM will explode if you try to mutate an array inside a function \\uD83D\\uDE05"
                    },
                    {
                        "username": "fader891108",
                        "content": "I used python and I used copy() function to copy my dictionary. I tried to find nodes on different subtree. Each time I just pick one subtree and move on. When I pick the subtree I gave it my current dictionary. However my dictionary changes as I run my code. Does anyone know how to avoid this? Thanks\\n\\n        res = [1]*n\\n        net = collections.defaultdict(list)#tree\\n        visit = [0]*n\\n        visit[0] = 1\\n        for e in edges:\\n            net[e[0]].append(e[1])\\n            net[e[1]].append(e[0])\\n        def findres(cur,cnt):\\n            c = labels[cur]\\n            print(cur,cnt)\\n            if cnt[c]:\\n                for node in cnt[c]:\\n                    res[node] += 1\\n            cnt[c].append(cur)\\n            for nex in net[cur]:\\n                if visit[nex] == 0:\\n                    new = cnt.copy()\\n                    visit[nex] = 1\\n                    findres(nex,new)\\n\\n        cnt = collections.defaultdict(list)\\n        findres(0,cnt)\\n        return res"
                    },
                    {
                        "username": "abhijeetsinhaa",
                        "content": "If someone is stuck because of TLE then try passing labels(given string) by reference.It worked for me.Passing string directly would create copies of string in each function call."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Number of discussions were awkward, so here is the 70th one."
                    },
                    {
                        "username": "tanujtvs2552",
                        "content": "If you are doing BFS all testcases are not passing due to TLE, try doing DFS. \\nDont know why BFS is failing in the last test case."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "It is really funny that people are first passing string by value in recursive function call, then getting a TLE, and then optimizing by passing by reference. But the thing is that there is NO NEED TO PASS THE STRING at all!!. Just copy it in a global variable and keep accessing it. 😉😉"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "If you are getting `TLE` after writing correct solution, then check you have passed string `labels` with reference."
                    }
                ]
            },
            {
                "id": 1754588,
                "content": [
                    {
                        "username": "mgeetha",
                        "content": "i hate you Tree\\uD83D\\uDE21"
                    },
                    {
                        "username": "marjan945",
                        "content": "**Can you help optimizing my solution?**\n\n```class Solution {\n\npublic:\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        for (int i = 0; i < n; i++) Ans.push_back(1);\n        unordered_map<int,vector<int>> connections(n);\n        for(auto edge : edges)\n        {\n            connections[edge[0]].push_back(edge[1]);\n            connections[edge[1]].push_back(edge[0]);\n        }\n        _labels = labels;\n        _connections = connections;\n        dfsChalao(0);\n        return Ans;\n    }\n\n    private:\n    bool visited[100001];\n    vector<int> Ans;\n    unordered_map<int,vector<int>> _connections;\n    string _labels;\n\n    unordered_map<char,int> dfsChalao(int i)\n    {\n        unordered_map<char,int> x;\n        //if (visited[i]) return x;\n        x[_labels[i]-'a']++;\n        visited[i] = true;\n\n        for (auto conn : _connections[i])\n        {\n            if(visited[conn]) continue;\n            unordered_map<char,int> cx = dfsChalao(conn);\n            for (auto co : cx)\n                x[co.first] += co.second;\n        }\n\n        Ans[i] = x[_labels[i]-'a'];\n        return x;\n    }\n};```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- There\\'s an issue: `visited` is a C-style array that does get initialized anywhere. It\\'s elements have *indeterminate values*, reading them before you assign a value to them invokes undefined behavior. The fix is simple, define it like this: `bool visited[100001] = {};` Or even better, see further down below.\\n- At the beginning of `countSubTrees()` instead of repeatedly appending `1`, you could just call `Ans.resize(n, 1)`\\n- The loop variable `conn` in the range-based `for` loop is a value. That means in each iteration it gets constructed (i.e. copied) from the current member of `_connections[i]`. That copy can be avoided by defining `conn` as a reference: `for (auto& conn: _connections[i])`\\n- This solution uses `std::unordered_map` for `_connections`. A `std::unordered_map` is implemented with a hash table and separate chaining, memory for each element gets allocated separately. Accessing an element by its key involves calculating the hash value, mapping that to a bucket, and then potentially locating the element in a linked list. That\\'s not too bad but since the keys (the IDs of the nodes) are integers in the range `[0, n - 1]` you could consider using `std::vector` instead. That is often much faster because accessing an element by its key involves just a multiplication to get the address.\\n- Similarly, this solution uses `std::unordered_map` for the many counters. If you consider that memory for each element gets allocated separately that\\'s a lot of allocations. But we know that the label is one of 26 letters. You could use a `std::array<int, 26>` instead. That would avoid any dynamic memory allocations, those `std::array` instances are comparatively fast to copy around. (But don\\'t forget to *initialize* the `std::array`.)\\n- This solution uses an array `visited` to remember which nodes have already been visited. That works (if you fix the aforementioned issue.) But do you really need it? Alternatively you could pass the ID of the parent as an additional argument to `dfsChalao()`. The `for` loop in that function would then just `continue` if `conn` is equal to the `parent`, and `countSubTrees()` would call `dfsChalao()` with `-1` for the parent."
                    },
                    {
                        "username": "haris_rashid",
                        "content": "same solutution ans solution but gave tle, although i used visited array which i passed by refrence so practically my code should have passed."
                    },
                    {
                        "username": "haris_rashid",
                        "content": "why it is giving tle although i used dfs and in each dfs call i used for loop of 26 .so time \\n0(n+e)*26."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Hard to tell without seeing the code. (Assuming C++) Maybe the recursive function takes one of its parameters by value and therefore creates too many copies?"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Check if you have passed String labels with reference."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "man, I hate TLE. Removed 1 variable and it works perfectly :\\\\"
                    },
                    {
                        "username": "raghupalash",
                        "content": "If using python, I highly using Counter instead of a normal dictionary - updating the counts would become really easy."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is a hard medium problem\\n"
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "<h1>Can anyone put in couple of mins? </h1>\n\n<h3>Why is this code giving TLE?</h3>\n\n<h6>Time Complexity => O(n) [Graph Construction] + O(26 * n) [DFS] + O(n) [Building Result] = O(n + 26 * n + n) = O(28 * n)</h6>\n\n<h6>Space Complexity => O(n) [label_count / ans array] + O(26 * n) [all_freq array] + O(26 * n) [Graph Array - Worst Case] = O(n + 26 * n + 26 * n) = O(53 * n)</h6>\n\n<h6>Approach - Created a frequency array for each node. \nApplying DFS, and updating frequency of characters for nodes while backtracking....\nAt the end assigning label_count i.e., ans to each node.</h6>\n\n`class Solution {\npublic:\n\n    int all_freq[100005][26];\n\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n      \n        vector<int> label_count(n, 0);\n\n        vector<int> graph[n];\n\n        for(auto e : edges)\n        {\n            graph[e[0]].push_back(e[1]);\n            graph[e[1]].push_back(e[0]);\n        }\n        \n        dfs(0, -1, graph, labels);\n\n        for(int i = 0; i < n; i++)\n        {\n            label_count[i] = all_freq[i][labels[i] - 'a']; \n        }\n        \n        return label_count;\n\n    }\n\n    void dfs(int curr, int par, vector<int> graph[], string labels)\n    {\n\n        for(auto nbr : graph[curr])\n        {\n            if (nbr != par)\n            {\n               dfs(nbr, curr, graph, labels);\n\n               for(int i = 0; i < 26; i++)\n                    all_freq[curr][i] += all_freq[nbr][i];\n               \n            }\n        }   \n\n        all_freq[curr][labels[curr] - 'a']++;   \n    }\n};`"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "pass string labels with reference.\\n\\nlike -> string &labels"
                    },
                    {
                        "username": "patrickbies",
                        "content": "Hey, I think I had a similar problem. Since the labels string is of size n and you are recursively calling dfs, try passing the labels string as a reference."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Not able to solve almost any questions \\nJust another day of suffering, 8-5 college than coding than development fucked up \\nNot able to look at any approach for the approach."
                    },
                    {
                        "username": "eostling",
                        "content": "Can someone explain the output for me. The explanation didn\\'t make any sense to me."
                    },
                    {
                        "username": "eostling",
                        "content": "Oh wait, I think I got it. The output, is in the arrangement of the first element `i` = The total number of all nodes with the same label & the rest of the positions are just 1 for the length of how many arrays are in the list. "
                    }
                ]
            },
            {
                "id": 1754522,
                "content": [
                    {
                        "username": "mgeetha",
                        "content": "i hate you Tree\\uD83D\\uDE21"
                    },
                    {
                        "username": "marjan945",
                        "content": "**Can you help optimizing my solution?**\n\n```class Solution {\n\npublic:\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        for (int i = 0; i < n; i++) Ans.push_back(1);\n        unordered_map<int,vector<int>> connections(n);\n        for(auto edge : edges)\n        {\n            connections[edge[0]].push_back(edge[1]);\n            connections[edge[1]].push_back(edge[0]);\n        }\n        _labels = labels;\n        _connections = connections;\n        dfsChalao(0);\n        return Ans;\n    }\n\n    private:\n    bool visited[100001];\n    vector<int> Ans;\n    unordered_map<int,vector<int>> _connections;\n    string _labels;\n\n    unordered_map<char,int> dfsChalao(int i)\n    {\n        unordered_map<char,int> x;\n        //if (visited[i]) return x;\n        x[_labels[i]-'a']++;\n        visited[i] = true;\n\n        for (auto conn : _connections[i])\n        {\n            if(visited[conn]) continue;\n            unordered_map<char,int> cx = dfsChalao(conn);\n            for (auto co : cx)\n                x[co.first] += co.second;\n        }\n\n        Ans[i] = x[_labels[i]-'a'];\n        return x;\n    }\n};```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- There\\'s an issue: `visited` is a C-style array that does get initialized anywhere. It\\'s elements have *indeterminate values*, reading them before you assign a value to them invokes undefined behavior. The fix is simple, define it like this: `bool visited[100001] = {};` Or even better, see further down below.\\n- At the beginning of `countSubTrees()` instead of repeatedly appending `1`, you could just call `Ans.resize(n, 1)`\\n- The loop variable `conn` in the range-based `for` loop is a value. That means in each iteration it gets constructed (i.e. copied) from the current member of `_connections[i]`. That copy can be avoided by defining `conn` as a reference: `for (auto& conn: _connections[i])`\\n- This solution uses `std::unordered_map` for `_connections`. A `std::unordered_map` is implemented with a hash table and separate chaining, memory for each element gets allocated separately. Accessing an element by its key involves calculating the hash value, mapping that to a bucket, and then potentially locating the element in a linked list. That\\'s not too bad but since the keys (the IDs of the nodes) are integers in the range `[0, n - 1]` you could consider using `std::vector` instead. That is often much faster because accessing an element by its key involves just a multiplication to get the address.\\n- Similarly, this solution uses `std::unordered_map` for the many counters. If you consider that memory for each element gets allocated separately that\\'s a lot of allocations. But we know that the label is one of 26 letters. You could use a `std::array<int, 26>` instead. That would avoid any dynamic memory allocations, those `std::array` instances are comparatively fast to copy around. (But don\\'t forget to *initialize* the `std::array`.)\\n- This solution uses an array `visited` to remember which nodes have already been visited. That works (if you fix the aforementioned issue.) But do you really need it? Alternatively you could pass the ID of the parent as an additional argument to `dfsChalao()`. The `for` loop in that function would then just `continue` if `conn` is equal to the `parent`, and `countSubTrees()` would call `dfsChalao()` with `-1` for the parent."
                    },
                    {
                        "username": "haris_rashid",
                        "content": "same solutution ans solution but gave tle, although i used visited array which i passed by refrence so practically my code should have passed."
                    },
                    {
                        "username": "haris_rashid",
                        "content": "why it is giving tle although i used dfs and in each dfs call i used for loop of 26 .so time \\n0(n+e)*26."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Hard to tell without seeing the code. (Assuming C++) Maybe the recursive function takes one of its parameters by value and therefore creates too many copies?"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Check if you have passed String labels with reference."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "man, I hate TLE. Removed 1 variable and it works perfectly :\\\\"
                    },
                    {
                        "username": "raghupalash",
                        "content": "If using python, I highly using Counter instead of a normal dictionary - updating the counts would become really easy."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is a hard medium problem\\n"
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "<h1>Can anyone put in couple of mins? </h1>\n\n<h3>Why is this code giving TLE?</h3>\n\n<h6>Time Complexity => O(n) [Graph Construction] + O(26 * n) [DFS] + O(n) [Building Result] = O(n + 26 * n + n) = O(28 * n)</h6>\n\n<h6>Space Complexity => O(n) [label_count / ans array] + O(26 * n) [all_freq array] + O(26 * n) [Graph Array - Worst Case] = O(n + 26 * n + 26 * n) = O(53 * n)</h6>\n\n<h6>Approach - Created a frequency array for each node. \nApplying DFS, and updating frequency of characters for nodes while backtracking....\nAt the end assigning label_count i.e., ans to each node.</h6>\n\n`class Solution {\npublic:\n\n    int all_freq[100005][26];\n\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n      \n        vector<int> label_count(n, 0);\n\n        vector<int> graph[n];\n\n        for(auto e : edges)\n        {\n            graph[e[0]].push_back(e[1]);\n            graph[e[1]].push_back(e[0]);\n        }\n        \n        dfs(0, -1, graph, labels);\n\n        for(int i = 0; i < n; i++)\n        {\n            label_count[i] = all_freq[i][labels[i] - 'a']; \n        }\n        \n        return label_count;\n\n    }\n\n    void dfs(int curr, int par, vector<int> graph[], string labels)\n    {\n\n        for(auto nbr : graph[curr])\n        {\n            if (nbr != par)\n            {\n               dfs(nbr, curr, graph, labels);\n\n               for(int i = 0; i < 26; i++)\n                    all_freq[curr][i] += all_freq[nbr][i];\n               \n            }\n        }   \n\n        all_freq[curr][labels[curr] - 'a']++;   \n    }\n};`"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "pass string labels with reference.\\n\\nlike -> string &labels"
                    },
                    {
                        "username": "patrickbies",
                        "content": "Hey, I think I had a similar problem. Since the labels string is of size n and you are recursively calling dfs, try passing the labels string as a reference."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Not able to solve almost any questions \\nJust another day of suffering, 8-5 college than coding than development fucked up \\nNot able to look at any approach for the approach."
                    },
                    {
                        "username": "eostling",
                        "content": "Can someone explain the output for me. The explanation didn\\'t make any sense to me."
                    },
                    {
                        "username": "eostling",
                        "content": "Oh wait, I think I got it. The output, is in the arrangement of the first element `i` = The total number of all nodes with the same label & the rest of the positions are just 1 for the length of how many arrays are in the list. "
                    }
                ]
            },
            {
                "id": 1754507,
                "content": [
                    {
                        "username": "mgeetha",
                        "content": "i hate you Tree\\uD83D\\uDE21"
                    },
                    {
                        "username": "marjan945",
                        "content": "**Can you help optimizing my solution?**\n\n```class Solution {\n\npublic:\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        for (int i = 0; i < n; i++) Ans.push_back(1);\n        unordered_map<int,vector<int>> connections(n);\n        for(auto edge : edges)\n        {\n            connections[edge[0]].push_back(edge[1]);\n            connections[edge[1]].push_back(edge[0]);\n        }\n        _labels = labels;\n        _connections = connections;\n        dfsChalao(0);\n        return Ans;\n    }\n\n    private:\n    bool visited[100001];\n    vector<int> Ans;\n    unordered_map<int,vector<int>> _connections;\n    string _labels;\n\n    unordered_map<char,int> dfsChalao(int i)\n    {\n        unordered_map<char,int> x;\n        //if (visited[i]) return x;\n        x[_labels[i]-'a']++;\n        visited[i] = true;\n\n        for (auto conn : _connections[i])\n        {\n            if(visited[conn]) continue;\n            unordered_map<char,int> cx = dfsChalao(conn);\n            for (auto co : cx)\n                x[co.first] += co.second;\n        }\n\n        Ans[i] = x[_labels[i]-'a'];\n        return x;\n    }\n};```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- There\\'s an issue: `visited` is a C-style array that does get initialized anywhere. It\\'s elements have *indeterminate values*, reading them before you assign a value to them invokes undefined behavior. The fix is simple, define it like this: `bool visited[100001] = {};` Or even better, see further down below.\\n- At the beginning of `countSubTrees()` instead of repeatedly appending `1`, you could just call `Ans.resize(n, 1)`\\n- The loop variable `conn` in the range-based `for` loop is a value. That means in each iteration it gets constructed (i.e. copied) from the current member of `_connections[i]`. That copy can be avoided by defining `conn` as a reference: `for (auto& conn: _connections[i])`\\n- This solution uses `std::unordered_map` for `_connections`. A `std::unordered_map` is implemented with a hash table and separate chaining, memory for each element gets allocated separately. Accessing an element by its key involves calculating the hash value, mapping that to a bucket, and then potentially locating the element in a linked list. That\\'s not too bad but since the keys (the IDs of the nodes) are integers in the range `[0, n - 1]` you could consider using `std::vector` instead. That is often much faster because accessing an element by its key involves just a multiplication to get the address.\\n- Similarly, this solution uses `std::unordered_map` for the many counters. If you consider that memory for each element gets allocated separately that\\'s a lot of allocations. But we know that the label is one of 26 letters. You could use a `std::array<int, 26>` instead. That would avoid any dynamic memory allocations, those `std::array` instances are comparatively fast to copy around. (But don\\'t forget to *initialize* the `std::array`.)\\n- This solution uses an array `visited` to remember which nodes have already been visited. That works (if you fix the aforementioned issue.) But do you really need it? Alternatively you could pass the ID of the parent as an additional argument to `dfsChalao()`. The `for` loop in that function would then just `continue` if `conn` is equal to the `parent`, and `countSubTrees()` would call `dfsChalao()` with `-1` for the parent."
                    },
                    {
                        "username": "haris_rashid",
                        "content": "same solutution ans solution but gave tle, although i used visited array which i passed by refrence so practically my code should have passed."
                    },
                    {
                        "username": "haris_rashid",
                        "content": "why it is giving tle although i used dfs and in each dfs call i used for loop of 26 .so time \\n0(n+e)*26."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Hard to tell without seeing the code. (Assuming C++) Maybe the recursive function takes one of its parameters by value and therefore creates too many copies?"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Check if you have passed String labels with reference."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "man, I hate TLE. Removed 1 variable and it works perfectly :\\\\"
                    },
                    {
                        "username": "raghupalash",
                        "content": "If using python, I highly using Counter instead of a normal dictionary - updating the counts would become really easy."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is a hard medium problem\\n"
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "<h1>Can anyone put in couple of mins? </h1>\n\n<h3>Why is this code giving TLE?</h3>\n\n<h6>Time Complexity => O(n) [Graph Construction] + O(26 * n) [DFS] + O(n) [Building Result] = O(n + 26 * n + n) = O(28 * n)</h6>\n\n<h6>Space Complexity => O(n) [label_count / ans array] + O(26 * n) [all_freq array] + O(26 * n) [Graph Array - Worst Case] = O(n + 26 * n + 26 * n) = O(53 * n)</h6>\n\n<h6>Approach - Created a frequency array for each node. \nApplying DFS, and updating frequency of characters for nodes while backtracking....\nAt the end assigning label_count i.e., ans to each node.</h6>\n\n`class Solution {\npublic:\n\n    int all_freq[100005][26];\n\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n      \n        vector<int> label_count(n, 0);\n\n        vector<int> graph[n];\n\n        for(auto e : edges)\n        {\n            graph[e[0]].push_back(e[1]);\n            graph[e[1]].push_back(e[0]);\n        }\n        \n        dfs(0, -1, graph, labels);\n\n        for(int i = 0; i < n; i++)\n        {\n            label_count[i] = all_freq[i][labels[i] - 'a']; \n        }\n        \n        return label_count;\n\n    }\n\n    void dfs(int curr, int par, vector<int> graph[], string labels)\n    {\n\n        for(auto nbr : graph[curr])\n        {\n            if (nbr != par)\n            {\n               dfs(nbr, curr, graph, labels);\n\n               for(int i = 0; i < 26; i++)\n                    all_freq[curr][i] += all_freq[nbr][i];\n               \n            }\n        }   \n\n        all_freq[curr][labels[curr] - 'a']++;   \n    }\n};`"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "pass string labels with reference.\\n\\nlike -> string &labels"
                    },
                    {
                        "username": "patrickbies",
                        "content": "Hey, I think I had a similar problem. Since the labels string is of size n and you are recursively calling dfs, try passing the labels string as a reference."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Not able to solve almost any questions \\nJust another day of suffering, 8-5 college than coding than development fucked up \\nNot able to look at any approach for the approach."
                    },
                    {
                        "username": "eostling",
                        "content": "Can someone explain the output for me. The explanation didn\\'t make any sense to me."
                    },
                    {
                        "username": "eostling",
                        "content": "Oh wait, I think I got it. The output, is in the arrangement of the first element `i` = The total number of all nodes with the same label & the rest of the positions are just 1 for the length of how many arrays are in the list. "
                    }
                ]
            },
            {
                "id": 1754491,
                "content": [
                    {
                        "username": "mgeetha",
                        "content": "i hate you Tree\\uD83D\\uDE21"
                    },
                    {
                        "username": "marjan945",
                        "content": "**Can you help optimizing my solution?**\n\n```class Solution {\n\npublic:\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        for (int i = 0; i < n; i++) Ans.push_back(1);\n        unordered_map<int,vector<int>> connections(n);\n        for(auto edge : edges)\n        {\n            connections[edge[0]].push_back(edge[1]);\n            connections[edge[1]].push_back(edge[0]);\n        }\n        _labels = labels;\n        _connections = connections;\n        dfsChalao(0);\n        return Ans;\n    }\n\n    private:\n    bool visited[100001];\n    vector<int> Ans;\n    unordered_map<int,vector<int>> _connections;\n    string _labels;\n\n    unordered_map<char,int> dfsChalao(int i)\n    {\n        unordered_map<char,int> x;\n        //if (visited[i]) return x;\n        x[_labels[i]-'a']++;\n        visited[i] = true;\n\n        for (auto conn : _connections[i])\n        {\n            if(visited[conn]) continue;\n            unordered_map<char,int> cx = dfsChalao(conn);\n            for (auto co : cx)\n                x[co.first] += co.second;\n        }\n\n        Ans[i] = x[_labels[i]-'a'];\n        return x;\n    }\n};```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- There\\'s an issue: `visited` is a C-style array that does get initialized anywhere. It\\'s elements have *indeterminate values*, reading them before you assign a value to them invokes undefined behavior. The fix is simple, define it like this: `bool visited[100001] = {};` Or even better, see further down below.\\n- At the beginning of `countSubTrees()` instead of repeatedly appending `1`, you could just call `Ans.resize(n, 1)`\\n- The loop variable `conn` in the range-based `for` loop is a value. That means in each iteration it gets constructed (i.e. copied) from the current member of `_connections[i]`. That copy can be avoided by defining `conn` as a reference: `for (auto& conn: _connections[i])`\\n- This solution uses `std::unordered_map` for `_connections`. A `std::unordered_map` is implemented with a hash table and separate chaining, memory for each element gets allocated separately. Accessing an element by its key involves calculating the hash value, mapping that to a bucket, and then potentially locating the element in a linked list. That\\'s not too bad but since the keys (the IDs of the nodes) are integers in the range `[0, n - 1]` you could consider using `std::vector` instead. That is often much faster because accessing an element by its key involves just a multiplication to get the address.\\n- Similarly, this solution uses `std::unordered_map` for the many counters. If you consider that memory for each element gets allocated separately that\\'s a lot of allocations. But we know that the label is one of 26 letters. You could use a `std::array<int, 26>` instead. That would avoid any dynamic memory allocations, those `std::array` instances are comparatively fast to copy around. (But don\\'t forget to *initialize* the `std::array`.)\\n- This solution uses an array `visited` to remember which nodes have already been visited. That works (if you fix the aforementioned issue.) But do you really need it? Alternatively you could pass the ID of the parent as an additional argument to `dfsChalao()`. The `for` loop in that function would then just `continue` if `conn` is equal to the `parent`, and `countSubTrees()` would call `dfsChalao()` with `-1` for the parent."
                    },
                    {
                        "username": "haris_rashid",
                        "content": "same solutution ans solution but gave tle, although i used visited array which i passed by refrence so practically my code should have passed."
                    },
                    {
                        "username": "haris_rashid",
                        "content": "why it is giving tle although i used dfs and in each dfs call i used for loop of 26 .so time \\n0(n+e)*26."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Hard to tell without seeing the code. (Assuming C++) Maybe the recursive function takes one of its parameters by value and therefore creates too many copies?"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Check if you have passed String labels with reference."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "man, I hate TLE. Removed 1 variable and it works perfectly :\\\\"
                    },
                    {
                        "username": "raghupalash",
                        "content": "If using python, I highly using Counter instead of a normal dictionary - updating the counts would become really easy."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is a hard medium problem\\n"
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "<h1>Can anyone put in couple of mins? </h1>\n\n<h3>Why is this code giving TLE?</h3>\n\n<h6>Time Complexity => O(n) [Graph Construction] + O(26 * n) [DFS] + O(n) [Building Result] = O(n + 26 * n + n) = O(28 * n)</h6>\n\n<h6>Space Complexity => O(n) [label_count / ans array] + O(26 * n) [all_freq array] + O(26 * n) [Graph Array - Worst Case] = O(n + 26 * n + 26 * n) = O(53 * n)</h6>\n\n<h6>Approach - Created a frequency array for each node. \nApplying DFS, and updating frequency of characters for nodes while backtracking....\nAt the end assigning label_count i.e., ans to each node.</h6>\n\n`class Solution {\npublic:\n\n    int all_freq[100005][26];\n\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n      \n        vector<int> label_count(n, 0);\n\n        vector<int> graph[n];\n\n        for(auto e : edges)\n        {\n            graph[e[0]].push_back(e[1]);\n            graph[e[1]].push_back(e[0]);\n        }\n        \n        dfs(0, -1, graph, labels);\n\n        for(int i = 0; i < n; i++)\n        {\n            label_count[i] = all_freq[i][labels[i] - 'a']; \n        }\n        \n        return label_count;\n\n    }\n\n    void dfs(int curr, int par, vector<int> graph[], string labels)\n    {\n\n        for(auto nbr : graph[curr])\n        {\n            if (nbr != par)\n            {\n               dfs(nbr, curr, graph, labels);\n\n               for(int i = 0; i < 26; i++)\n                    all_freq[curr][i] += all_freq[nbr][i];\n               \n            }\n        }   \n\n        all_freq[curr][labels[curr] - 'a']++;   \n    }\n};`"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "pass string labels with reference.\\n\\nlike -> string &labels"
                    },
                    {
                        "username": "patrickbies",
                        "content": "Hey, I think I had a similar problem. Since the labels string is of size n and you are recursively calling dfs, try passing the labels string as a reference."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Not able to solve almost any questions \\nJust another day of suffering, 8-5 college than coding than development fucked up \\nNot able to look at any approach for the approach."
                    },
                    {
                        "username": "eostling",
                        "content": "Can someone explain the output for me. The explanation didn\\'t make any sense to me."
                    },
                    {
                        "username": "eostling",
                        "content": "Oh wait, I think I got it. The output, is in the arrangement of the first element `i` = The total number of all nodes with the same label & the rest of the positions are just 1 for the length of how many arrays are in the list. "
                    }
                ]
            },
            {
                "id": 1754463,
                "content": [
                    {
                        "username": "mgeetha",
                        "content": "i hate you Tree\\uD83D\\uDE21"
                    },
                    {
                        "username": "marjan945",
                        "content": "**Can you help optimizing my solution?**\n\n```class Solution {\n\npublic:\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        for (int i = 0; i < n; i++) Ans.push_back(1);\n        unordered_map<int,vector<int>> connections(n);\n        for(auto edge : edges)\n        {\n            connections[edge[0]].push_back(edge[1]);\n            connections[edge[1]].push_back(edge[0]);\n        }\n        _labels = labels;\n        _connections = connections;\n        dfsChalao(0);\n        return Ans;\n    }\n\n    private:\n    bool visited[100001];\n    vector<int> Ans;\n    unordered_map<int,vector<int>> _connections;\n    string _labels;\n\n    unordered_map<char,int> dfsChalao(int i)\n    {\n        unordered_map<char,int> x;\n        //if (visited[i]) return x;\n        x[_labels[i]-'a']++;\n        visited[i] = true;\n\n        for (auto conn : _connections[i])\n        {\n            if(visited[conn]) continue;\n            unordered_map<char,int> cx = dfsChalao(conn);\n            for (auto co : cx)\n                x[co.first] += co.second;\n        }\n\n        Ans[i] = x[_labels[i]-'a'];\n        return x;\n    }\n};```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- There\\'s an issue: `visited` is a C-style array that does get initialized anywhere. It\\'s elements have *indeterminate values*, reading them before you assign a value to them invokes undefined behavior. The fix is simple, define it like this: `bool visited[100001] = {};` Or even better, see further down below.\\n- At the beginning of `countSubTrees()` instead of repeatedly appending `1`, you could just call `Ans.resize(n, 1)`\\n- The loop variable `conn` in the range-based `for` loop is a value. That means in each iteration it gets constructed (i.e. copied) from the current member of `_connections[i]`. That copy can be avoided by defining `conn` as a reference: `for (auto& conn: _connections[i])`\\n- This solution uses `std::unordered_map` for `_connections`. A `std::unordered_map` is implemented with a hash table and separate chaining, memory for each element gets allocated separately. Accessing an element by its key involves calculating the hash value, mapping that to a bucket, and then potentially locating the element in a linked list. That\\'s not too bad but since the keys (the IDs of the nodes) are integers in the range `[0, n - 1]` you could consider using `std::vector` instead. That is often much faster because accessing an element by its key involves just a multiplication to get the address.\\n- Similarly, this solution uses `std::unordered_map` for the many counters. If you consider that memory for each element gets allocated separately that\\'s a lot of allocations. But we know that the label is one of 26 letters. You could use a `std::array<int, 26>` instead. That would avoid any dynamic memory allocations, those `std::array` instances are comparatively fast to copy around. (But don\\'t forget to *initialize* the `std::array`.)\\n- This solution uses an array `visited` to remember which nodes have already been visited. That works (if you fix the aforementioned issue.) But do you really need it? Alternatively you could pass the ID of the parent as an additional argument to `dfsChalao()`. The `for` loop in that function would then just `continue` if `conn` is equal to the `parent`, and `countSubTrees()` would call `dfsChalao()` with `-1` for the parent."
                    },
                    {
                        "username": "haris_rashid",
                        "content": "same solutution ans solution but gave tle, although i used visited array which i passed by refrence so practically my code should have passed."
                    },
                    {
                        "username": "haris_rashid",
                        "content": "why it is giving tle although i used dfs and in each dfs call i used for loop of 26 .so time \\n0(n+e)*26."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Hard to tell without seeing the code. (Assuming C++) Maybe the recursive function takes one of its parameters by value and therefore creates too many copies?"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Check if you have passed String labels with reference."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "man, I hate TLE. Removed 1 variable and it works perfectly :\\\\"
                    },
                    {
                        "username": "raghupalash",
                        "content": "If using python, I highly using Counter instead of a normal dictionary - updating the counts would become really easy."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is a hard medium problem\\n"
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "<h1>Can anyone put in couple of mins? </h1>\n\n<h3>Why is this code giving TLE?</h3>\n\n<h6>Time Complexity => O(n) [Graph Construction] + O(26 * n) [DFS] + O(n) [Building Result] = O(n + 26 * n + n) = O(28 * n)</h6>\n\n<h6>Space Complexity => O(n) [label_count / ans array] + O(26 * n) [all_freq array] + O(26 * n) [Graph Array - Worst Case] = O(n + 26 * n + 26 * n) = O(53 * n)</h6>\n\n<h6>Approach - Created a frequency array for each node. \nApplying DFS, and updating frequency of characters for nodes while backtracking....\nAt the end assigning label_count i.e., ans to each node.</h6>\n\n`class Solution {\npublic:\n\n    int all_freq[100005][26];\n\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n      \n        vector<int> label_count(n, 0);\n\n        vector<int> graph[n];\n\n        for(auto e : edges)\n        {\n            graph[e[0]].push_back(e[1]);\n            graph[e[1]].push_back(e[0]);\n        }\n        \n        dfs(0, -1, graph, labels);\n\n        for(int i = 0; i < n; i++)\n        {\n            label_count[i] = all_freq[i][labels[i] - 'a']; \n        }\n        \n        return label_count;\n\n    }\n\n    void dfs(int curr, int par, vector<int> graph[], string labels)\n    {\n\n        for(auto nbr : graph[curr])\n        {\n            if (nbr != par)\n            {\n               dfs(nbr, curr, graph, labels);\n\n               for(int i = 0; i < 26; i++)\n                    all_freq[curr][i] += all_freq[nbr][i];\n               \n            }\n        }   \n\n        all_freq[curr][labels[curr] - 'a']++;   \n    }\n};`"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "pass string labels with reference.\\n\\nlike -> string &labels"
                    },
                    {
                        "username": "patrickbies",
                        "content": "Hey, I think I had a similar problem. Since the labels string is of size n and you are recursively calling dfs, try passing the labels string as a reference."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Not able to solve almost any questions \\nJust another day of suffering, 8-5 college than coding than development fucked up \\nNot able to look at any approach for the approach."
                    },
                    {
                        "username": "eostling",
                        "content": "Can someone explain the output for me. The explanation didn\\'t make any sense to me."
                    },
                    {
                        "username": "eostling",
                        "content": "Oh wait, I think I got it. The output, is in the arrangement of the first element `i` = The total number of all nodes with the same label & the rest of the positions are just 1 for the length of how many arrays are in the list. "
                    }
                ]
            },
            {
                "id": 1754444,
                "content": [
                    {
                        "username": "mgeetha",
                        "content": "i hate you Tree\\uD83D\\uDE21"
                    },
                    {
                        "username": "marjan945",
                        "content": "**Can you help optimizing my solution?**\n\n```class Solution {\n\npublic:\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        for (int i = 0; i < n; i++) Ans.push_back(1);\n        unordered_map<int,vector<int>> connections(n);\n        for(auto edge : edges)\n        {\n            connections[edge[0]].push_back(edge[1]);\n            connections[edge[1]].push_back(edge[0]);\n        }\n        _labels = labels;\n        _connections = connections;\n        dfsChalao(0);\n        return Ans;\n    }\n\n    private:\n    bool visited[100001];\n    vector<int> Ans;\n    unordered_map<int,vector<int>> _connections;\n    string _labels;\n\n    unordered_map<char,int> dfsChalao(int i)\n    {\n        unordered_map<char,int> x;\n        //if (visited[i]) return x;\n        x[_labels[i]-'a']++;\n        visited[i] = true;\n\n        for (auto conn : _connections[i])\n        {\n            if(visited[conn]) continue;\n            unordered_map<char,int> cx = dfsChalao(conn);\n            for (auto co : cx)\n                x[co.first] += co.second;\n        }\n\n        Ans[i] = x[_labels[i]-'a'];\n        return x;\n    }\n};```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- There\\'s an issue: `visited` is a C-style array that does get initialized anywhere. It\\'s elements have *indeterminate values*, reading them before you assign a value to them invokes undefined behavior. The fix is simple, define it like this: `bool visited[100001] = {};` Or even better, see further down below.\\n- At the beginning of `countSubTrees()` instead of repeatedly appending `1`, you could just call `Ans.resize(n, 1)`\\n- The loop variable `conn` in the range-based `for` loop is a value. That means in each iteration it gets constructed (i.e. copied) from the current member of `_connections[i]`. That copy can be avoided by defining `conn` as a reference: `for (auto& conn: _connections[i])`\\n- This solution uses `std::unordered_map` for `_connections`. A `std::unordered_map` is implemented with a hash table and separate chaining, memory for each element gets allocated separately. Accessing an element by its key involves calculating the hash value, mapping that to a bucket, and then potentially locating the element in a linked list. That\\'s not too bad but since the keys (the IDs of the nodes) are integers in the range `[0, n - 1]` you could consider using `std::vector` instead. That is often much faster because accessing an element by its key involves just a multiplication to get the address.\\n- Similarly, this solution uses `std::unordered_map` for the many counters. If you consider that memory for each element gets allocated separately that\\'s a lot of allocations. But we know that the label is one of 26 letters. You could use a `std::array<int, 26>` instead. That would avoid any dynamic memory allocations, those `std::array` instances are comparatively fast to copy around. (But don\\'t forget to *initialize* the `std::array`.)\\n- This solution uses an array `visited` to remember which nodes have already been visited. That works (if you fix the aforementioned issue.) But do you really need it? Alternatively you could pass the ID of the parent as an additional argument to `dfsChalao()`. The `for` loop in that function would then just `continue` if `conn` is equal to the `parent`, and `countSubTrees()` would call `dfsChalao()` with `-1` for the parent."
                    },
                    {
                        "username": "haris_rashid",
                        "content": "same solutution ans solution but gave tle, although i used visited array which i passed by refrence so practically my code should have passed."
                    },
                    {
                        "username": "haris_rashid",
                        "content": "why it is giving tle although i used dfs and in each dfs call i used for loop of 26 .so time \\n0(n+e)*26."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Hard to tell without seeing the code. (Assuming C++) Maybe the recursive function takes one of its parameters by value and therefore creates too many copies?"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Check if you have passed String labels with reference."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "man, I hate TLE. Removed 1 variable and it works perfectly :\\\\"
                    },
                    {
                        "username": "raghupalash",
                        "content": "If using python, I highly using Counter instead of a normal dictionary - updating the counts would become really easy."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is a hard medium problem\\n"
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "<h1>Can anyone put in couple of mins? </h1>\n\n<h3>Why is this code giving TLE?</h3>\n\n<h6>Time Complexity => O(n) [Graph Construction] + O(26 * n) [DFS] + O(n) [Building Result] = O(n + 26 * n + n) = O(28 * n)</h6>\n\n<h6>Space Complexity => O(n) [label_count / ans array] + O(26 * n) [all_freq array] + O(26 * n) [Graph Array - Worst Case] = O(n + 26 * n + 26 * n) = O(53 * n)</h6>\n\n<h6>Approach - Created a frequency array for each node. \nApplying DFS, and updating frequency of characters for nodes while backtracking....\nAt the end assigning label_count i.e., ans to each node.</h6>\n\n`class Solution {\npublic:\n\n    int all_freq[100005][26];\n\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n      \n        vector<int> label_count(n, 0);\n\n        vector<int> graph[n];\n\n        for(auto e : edges)\n        {\n            graph[e[0]].push_back(e[1]);\n            graph[e[1]].push_back(e[0]);\n        }\n        \n        dfs(0, -1, graph, labels);\n\n        for(int i = 0; i < n; i++)\n        {\n            label_count[i] = all_freq[i][labels[i] - 'a']; \n        }\n        \n        return label_count;\n\n    }\n\n    void dfs(int curr, int par, vector<int> graph[], string labels)\n    {\n\n        for(auto nbr : graph[curr])\n        {\n            if (nbr != par)\n            {\n               dfs(nbr, curr, graph, labels);\n\n               for(int i = 0; i < 26; i++)\n                    all_freq[curr][i] += all_freq[nbr][i];\n               \n            }\n        }   \n\n        all_freq[curr][labels[curr] - 'a']++;   \n    }\n};`"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "pass string labels with reference.\\n\\nlike -> string &labels"
                    },
                    {
                        "username": "patrickbies",
                        "content": "Hey, I think I had a similar problem. Since the labels string is of size n and you are recursively calling dfs, try passing the labels string as a reference."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Not able to solve almost any questions \\nJust another day of suffering, 8-5 college than coding than development fucked up \\nNot able to look at any approach for the approach."
                    },
                    {
                        "username": "eostling",
                        "content": "Can someone explain the output for me. The explanation didn\\'t make any sense to me."
                    },
                    {
                        "username": "eostling",
                        "content": "Oh wait, I think I got it. The output, is in the arrangement of the first element `i` = The total number of all nodes with the same label & the rest of the positions are just 1 for the length of how many arrays are in the list. "
                    }
                ]
            },
            {
                "id": 1754323,
                "content": [
                    {
                        "username": "mgeetha",
                        "content": "i hate you Tree\\uD83D\\uDE21"
                    },
                    {
                        "username": "marjan945",
                        "content": "**Can you help optimizing my solution?**\n\n```class Solution {\n\npublic:\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        for (int i = 0; i < n; i++) Ans.push_back(1);\n        unordered_map<int,vector<int>> connections(n);\n        for(auto edge : edges)\n        {\n            connections[edge[0]].push_back(edge[1]);\n            connections[edge[1]].push_back(edge[0]);\n        }\n        _labels = labels;\n        _connections = connections;\n        dfsChalao(0);\n        return Ans;\n    }\n\n    private:\n    bool visited[100001];\n    vector<int> Ans;\n    unordered_map<int,vector<int>> _connections;\n    string _labels;\n\n    unordered_map<char,int> dfsChalao(int i)\n    {\n        unordered_map<char,int> x;\n        //if (visited[i]) return x;\n        x[_labels[i]-'a']++;\n        visited[i] = true;\n\n        for (auto conn : _connections[i])\n        {\n            if(visited[conn]) continue;\n            unordered_map<char,int> cx = dfsChalao(conn);\n            for (auto co : cx)\n                x[co.first] += co.second;\n        }\n\n        Ans[i] = x[_labels[i]-'a'];\n        return x;\n    }\n};```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- There\\'s an issue: `visited` is a C-style array that does get initialized anywhere. It\\'s elements have *indeterminate values*, reading them before you assign a value to them invokes undefined behavior. The fix is simple, define it like this: `bool visited[100001] = {};` Or even better, see further down below.\\n- At the beginning of `countSubTrees()` instead of repeatedly appending `1`, you could just call `Ans.resize(n, 1)`\\n- The loop variable `conn` in the range-based `for` loop is a value. That means in each iteration it gets constructed (i.e. copied) from the current member of `_connections[i]`. That copy can be avoided by defining `conn` as a reference: `for (auto& conn: _connections[i])`\\n- This solution uses `std::unordered_map` for `_connections`. A `std::unordered_map` is implemented with a hash table and separate chaining, memory for each element gets allocated separately. Accessing an element by its key involves calculating the hash value, mapping that to a bucket, and then potentially locating the element in a linked list. That\\'s not too bad but since the keys (the IDs of the nodes) are integers in the range `[0, n - 1]` you could consider using `std::vector` instead. That is often much faster because accessing an element by its key involves just a multiplication to get the address.\\n- Similarly, this solution uses `std::unordered_map` for the many counters. If you consider that memory for each element gets allocated separately that\\'s a lot of allocations. But we know that the label is one of 26 letters. You could use a `std::array<int, 26>` instead. That would avoid any dynamic memory allocations, those `std::array` instances are comparatively fast to copy around. (But don\\'t forget to *initialize* the `std::array`.)\\n- This solution uses an array `visited` to remember which nodes have already been visited. That works (if you fix the aforementioned issue.) But do you really need it? Alternatively you could pass the ID of the parent as an additional argument to `dfsChalao()`. The `for` loop in that function would then just `continue` if `conn` is equal to the `parent`, and `countSubTrees()` would call `dfsChalao()` with `-1` for the parent."
                    },
                    {
                        "username": "haris_rashid",
                        "content": "same solutution ans solution but gave tle, although i used visited array which i passed by refrence so practically my code should have passed."
                    },
                    {
                        "username": "haris_rashid",
                        "content": "why it is giving tle although i used dfs and in each dfs call i used for loop of 26 .so time \\n0(n+e)*26."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Hard to tell without seeing the code. (Assuming C++) Maybe the recursive function takes one of its parameters by value and therefore creates too many copies?"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Check if you have passed String labels with reference."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "man, I hate TLE. Removed 1 variable and it works perfectly :\\\\"
                    },
                    {
                        "username": "raghupalash",
                        "content": "If using python, I highly using Counter instead of a normal dictionary - updating the counts would become really easy."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is a hard medium problem\\n"
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "<h1>Can anyone put in couple of mins? </h1>\n\n<h3>Why is this code giving TLE?</h3>\n\n<h6>Time Complexity => O(n) [Graph Construction] + O(26 * n) [DFS] + O(n) [Building Result] = O(n + 26 * n + n) = O(28 * n)</h6>\n\n<h6>Space Complexity => O(n) [label_count / ans array] + O(26 * n) [all_freq array] + O(26 * n) [Graph Array - Worst Case] = O(n + 26 * n + 26 * n) = O(53 * n)</h6>\n\n<h6>Approach - Created a frequency array for each node. \nApplying DFS, and updating frequency of characters for nodes while backtracking....\nAt the end assigning label_count i.e., ans to each node.</h6>\n\n`class Solution {\npublic:\n\n    int all_freq[100005][26];\n\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n      \n        vector<int> label_count(n, 0);\n\n        vector<int> graph[n];\n\n        for(auto e : edges)\n        {\n            graph[e[0]].push_back(e[1]);\n            graph[e[1]].push_back(e[0]);\n        }\n        \n        dfs(0, -1, graph, labels);\n\n        for(int i = 0; i < n; i++)\n        {\n            label_count[i] = all_freq[i][labels[i] - 'a']; \n        }\n        \n        return label_count;\n\n    }\n\n    void dfs(int curr, int par, vector<int> graph[], string labels)\n    {\n\n        for(auto nbr : graph[curr])\n        {\n            if (nbr != par)\n            {\n               dfs(nbr, curr, graph, labels);\n\n               for(int i = 0; i < 26; i++)\n                    all_freq[curr][i] += all_freq[nbr][i];\n               \n            }\n        }   \n\n        all_freq[curr][labels[curr] - 'a']++;   \n    }\n};`"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "pass string labels with reference.\\n\\nlike -> string &labels"
                    },
                    {
                        "username": "patrickbies",
                        "content": "Hey, I think I had a similar problem. Since the labels string is of size n and you are recursively calling dfs, try passing the labels string as a reference."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Not able to solve almost any questions \\nJust another day of suffering, 8-5 college than coding than development fucked up \\nNot able to look at any approach for the approach."
                    },
                    {
                        "username": "eostling",
                        "content": "Can someone explain the output for me. The explanation didn\\'t make any sense to me."
                    },
                    {
                        "username": "eostling",
                        "content": "Oh wait, I think I got it. The output, is in the arrangement of the first element `i` = The total number of all nodes with the same label & the rest of the positions are just 1 for the length of how many arrays are in the list. "
                    }
                ]
            },
            {
                "id": 1754296,
                "content": [
                    {
                        "username": "mgeetha",
                        "content": "i hate you Tree\\uD83D\\uDE21"
                    },
                    {
                        "username": "marjan945",
                        "content": "**Can you help optimizing my solution?**\n\n```class Solution {\n\npublic:\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        for (int i = 0; i < n; i++) Ans.push_back(1);\n        unordered_map<int,vector<int>> connections(n);\n        for(auto edge : edges)\n        {\n            connections[edge[0]].push_back(edge[1]);\n            connections[edge[1]].push_back(edge[0]);\n        }\n        _labels = labels;\n        _connections = connections;\n        dfsChalao(0);\n        return Ans;\n    }\n\n    private:\n    bool visited[100001];\n    vector<int> Ans;\n    unordered_map<int,vector<int>> _connections;\n    string _labels;\n\n    unordered_map<char,int> dfsChalao(int i)\n    {\n        unordered_map<char,int> x;\n        //if (visited[i]) return x;\n        x[_labels[i]-'a']++;\n        visited[i] = true;\n\n        for (auto conn : _connections[i])\n        {\n            if(visited[conn]) continue;\n            unordered_map<char,int> cx = dfsChalao(conn);\n            for (auto co : cx)\n                x[co.first] += co.second;\n        }\n\n        Ans[i] = x[_labels[i]-'a'];\n        return x;\n    }\n};```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- There\\'s an issue: `visited` is a C-style array that does get initialized anywhere. It\\'s elements have *indeterminate values*, reading them before you assign a value to them invokes undefined behavior. The fix is simple, define it like this: `bool visited[100001] = {};` Or even better, see further down below.\\n- At the beginning of `countSubTrees()` instead of repeatedly appending `1`, you could just call `Ans.resize(n, 1)`\\n- The loop variable `conn` in the range-based `for` loop is a value. That means in each iteration it gets constructed (i.e. copied) from the current member of `_connections[i]`. That copy can be avoided by defining `conn` as a reference: `for (auto& conn: _connections[i])`\\n- This solution uses `std::unordered_map` for `_connections`. A `std::unordered_map` is implemented with a hash table and separate chaining, memory for each element gets allocated separately. Accessing an element by its key involves calculating the hash value, mapping that to a bucket, and then potentially locating the element in a linked list. That\\'s not too bad but since the keys (the IDs of the nodes) are integers in the range `[0, n - 1]` you could consider using `std::vector` instead. That is often much faster because accessing an element by its key involves just a multiplication to get the address.\\n- Similarly, this solution uses `std::unordered_map` for the many counters. If you consider that memory for each element gets allocated separately that\\'s a lot of allocations. But we know that the label is one of 26 letters. You could use a `std::array<int, 26>` instead. That would avoid any dynamic memory allocations, those `std::array` instances are comparatively fast to copy around. (But don\\'t forget to *initialize* the `std::array`.)\\n- This solution uses an array `visited` to remember which nodes have already been visited. That works (if you fix the aforementioned issue.) But do you really need it? Alternatively you could pass the ID of the parent as an additional argument to `dfsChalao()`. The `for` loop in that function would then just `continue` if `conn` is equal to the `parent`, and `countSubTrees()` would call `dfsChalao()` with `-1` for the parent."
                    },
                    {
                        "username": "haris_rashid",
                        "content": "same solutution ans solution but gave tle, although i used visited array which i passed by refrence so practically my code should have passed."
                    },
                    {
                        "username": "haris_rashid",
                        "content": "why it is giving tle although i used dfs and in each dfs call i used for loop of 26 .so time \\n0(n+e)*26."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Hard to tell without seeing the code. (Assuming C++) Maybe the recursive function takes one of its parameters by value and therefore creates too many copies?"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Check if you have passed String labels with reference."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "man, I hate TLE. Removed 1 variable and it works perfectly :\\\\"
                    },
                    {
                        "username": "raghupalash",
                        "content": "If using python, I highly using Counter instead of a normal dictionary - updating the counts would become really easy."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is a hard medium problem\\n"
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "<h1>Can anyone put in couple of mins? </h1>\n\n<h3>Why is this code giving TLE?</h3>\n\n<h6>Time Complexity => O(n) [Graph Construction] + O(26 * n) [DFS] + O(n) [Building Result] = O(n + 26 * n + n) = O(28 * n)</h6>\n\n<h6>Space Complexity => O(n) [label_count / ans array] + O(26 * n) [all_freq array] + O(26 * n) [Graph Array - Worst Case] = O(n + 26 * n + 26 * n) = O(53 * n)</h6>\n\n<h6>Approach - Created a frequency array for each node. \nApplying DFS, and updating frequency of characters for nodes while backtracking....\nAt the end assigning label_count i.e., ans to each node.</h6>\n\n`class Solution {\npublic:\n\n    int all_freq[100005][26];\n\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n      \n        vector<int> label_count(n, 0);\n\n        vector<int> graph[n];\n\n        for(auto e : edges)\n        {\n            graph[e[0]].push_back(e[1]);\n            graph[e[1]].push_back(e[0]);\n        }\n        \n        dfs(0, -1, graph, labels);\n\n        for(int i = 0; i < n; i++)\n        {\n            label_count[i] = all_freq[i][labels[i] - 'a']; \n        }\n        \n        return label_count;\n\n    }\n\n    void dfs(int curr, int par, vector<int> graph[], string labels)\n    {\n\n        for(auto nbr : graph[curr])\n        {\n            if (nbr != par)\n            {\n               dfs(nbr, curr, graph, labels);\n\n               for(int i = 0; i < 26; i++)\n                    all_freq[curr][i] += all_freq[nbr][i];\n               \n            }\n        }   \n\n        all_freq[curr][labels[curr] - 'a']++;   \n    }\n};`"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "pass string labels with reference.\\n\\nlike -> string &labels"
                    },
                    {
                        "username": "patrickbies",
                        "content": "Hey, I think I had a similar problem. Since the labels string is of size n and you are recursively calling dfs, try passing the labels string as a reference."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Not able to solve almost any questions \\nJust another day of suffering, 8-5 college than coding than development fucked up \\nNot able to look at any approach for the approach."
                    },
                    {
                        "username": "eostling",
                        "content": "Can someone explain the output for me. The explanation didn\\'t make any sense to me."
                    },
                    {
                        "username": "eostling",
                        "content": "Oh wait, I think I got it. The output, is in the arrangement of the first element `i` = The total number of all nodes with the same label & the rest of the positions are just 1 for the length of how many arrays are in the list. "
                    }
                ]
            },
            {
                "id": 1754276,
                "content": [
                    {
                        "username": "mgeetha",
                        "content": "i hate you Tree\\uD83D\\uDE21"
                    },
                    {
                        "username": "marjan945",
                        "content": "**Can you help optimizing my solution?**\n\n```class Solution {\n\npublic:\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        for (int i = 0; i < n; i++) Ans.push_back(1);\n        unordered_map<int,vector<int>> connections(n);\n        for(auto edge : edges)\n        {\n            connections[edge[0]].push_back(edge[1]);\n            connections[edge[1]].push_back(edge[0]);\n        }\n        _labels = labels;\n        _connections = connections;\n        dfsChalao(0);\n        return Ans;\n    }\n\n    private:\n    bool visited[100001];\n    vector<int> Ans;\n    unordered_map<int,vector<int>> _connections;\n    string _labels;\n\n    unordered_map<char,int> dfsChalao(int i)\n    {\n        unordered_map<char,int> x;\n        //if (visited[i]) return x;\n        x[_labels[i]-'a']++;\n        visited[i] = true;\n\n        for (auto conn : _connections[i])\n        {\n            if(visited[conn]) continue;\n            unordered_map<char,int> cx = dfsChalao(conn);\n            for (auto co : cx)\n                x[co.first] += co.second;\n        }\n\n        Ans[i] = x[_labels[i]-'a'];\n        return x;\n    }\n};```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- There\\'s an issue: `visited` is a C-style array that does get initialized anywhere. It\\'s elements have *indeterminate values*, reading them before you assign a value to them invokes undefined behavior. The fix is simple, define it like this: `bool visited[100001] = {};` Or even better, see further down below.\\n- At the beginning of `countSubTrees()` instead of repeatedly appending `1`, you could just call `Ans.resize(n, 1)`\\n- The loop variable `conn` in the range-based `for` loop is a value. That means in each iteration it gets constructed (i.e. copied) from the current member of `_connections[i]`. That copy can be avoided by defining `conn` as a reference: `for (auto& conn: _connections[i])`\\n- This solution uses `std::unordered_map` for `_connections`. A `std::unordered_map` is implemented with a hash table and separate chaining, memory for each element gets allocated separately. Accessing an element by its key involves calculating the hash value, mapping that to a bucket, and then potentially locating the element in a linked list. That\\'s not too bad but since the keys (the IDs of the nodes) are integers in the range `[0, n - 1]` you could consider using `std::vector` instead. That is often much faster because accessing an element by its key involves just a multiplication to get the address.\\n- Similarly, this solution uses `std::unordered_map` for the many counters. If you consider that memory for each element gets allocated separately that\\'s a lot of allocations. But we know that the label is one of 26 letters. You could use a `std::array<int, 26>` instead. That would avoid any dynamic memory allocations, those `std::array` instances are comparatively fast to copy around. (But don\\'t forget to *initialize* the `std::array`.)\\n- This solution uses an array `visited` to remember which nodes have already been visited. That works (if you fix the aforementioned issue.) But do you really need it? Alternatively you could pass the ID of the parent as an additional argument to `dfsChalao()`. The `for` loop in that function would then just `continue` if `conn` is equal to the `parent`, and `countSubTrees()` would call `dfsChalao()` with `-1` for the parent."
                    },
                    {
                        "username": "haris_rashid",
                        "content": "same solutution ans solution but gave tle, although i used visited array which i passed by refrence so practically my code should have passed."
                    },
                    {
                        "username": "haris_rashid",
                        "content": "why it is giving tle although i used dfs and in each dfs call i used for loop of 26 .so time \\n0(n+e)*26."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Hard to tell without seeing the code. (Assuming C++) Maybe the recursive function takes one of its parameters by value and therefore creates too many copies?"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Check if you have passed String labels with reference."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "man, I hate TLE. Removed 1 variable and it works perfectly :\\\\"
                    },
                    {
                        "username": "raghupalash",
                        "content": "If using python, I highly using Counter instead of a normal dictionary - updating the counts would become really easy."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is a hard medium problem\\n"
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "<h1>Can anyone put in couple of mins? </h1>\n\n<h3>Why is this code giving TLE?</h3>\n\n<h6>Time Complexity => O(n) [Graph Construction] + O(26 * n) [DFS] + O(n) [Building Result] = O(n + 26 * n + n) = O(28 * n)</h6>\n\n<h6>Space Complexity => O(n) [label_count / ans array] + O(26 * n) [all_freq array] + O(26 * n) [Graph Array - Worst Case] = O(n + 26 * n + 26 * n) = O(53 * n)</h6>\n\n<h6>Approach - Created a frequency array for each node. \nApplying DFS, and updating frequency of characters for nodes while backtracking....\nAt the end assigning label_count i.e., ans to each node.</h6>\n\n`class Solution {\npublic:\n\n    int all_freq[100005][26];\n\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n      \n        vector<int> label_count(n, 0);\n\n        vector<int> graph[n];\n\n        for(auto e : edges)\n        {\n            graph[e[0]].push_back(e[1]);\n            graph[e[1]].push_back(e[0]);\n        }\n        \n        dfs(0, -1, graph, labels);\n\n        for(int i = 0; i < n; i++)\n        {\n            label_count[i] = all_freq[i][labels[i] - 'a']; \n        }\n        \n        return label_count;\n\n    }\n\n    void dfs(int curr, int par, vector<int> graph[], string labels)\n    {\n\n        for(auto nbr : graph[curr])\n        {\n            if (nbr != par)\n            {\n               dfs(nbr, curr, graph, labels);\n\n               for(int i = 0; i < 26; i++)\n                    all_freq[curr][i] += all_freq[nbr][i];\n               \n            }\n        }   \n\n        all_freq[curr][labels[curr] - 'a']++;   \n    }\n};`"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "pass string labels with reference.\\n\\nlike -> string &labels"
                    },
                    {
                        "username": "patrickbies",
                        "content": "Hey, I think I had a similar problem. Since the labels string is of size n and you are recursively calling dfs, try passing the labels string as a reference."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Not able to solve almost any questions \\nJust another day of suffering, 8-5 college than coding than development fucked up \\nNot able to look at any approach for the approach."
                    },
                    {
                        "username": "eostling",
                        "content": "Can someone explain the output for me. The explanation didn\\'t make any sense to me."
                    },
                    {
                        "username": "eostling",
                        "content": "Oh wait, I think I got it. The output, is in the arrangement of the first element `i` = The total number of all nodes with the same label & the rest of the positions are just 1 for the length of how many arrays are in the list. "
                    }
                ]
            },
            {
                "id": 1754246,
                "content": [
                    {
                        "username": "mgeetha",
                        "content": "i hate you Tree\\uD83D\\uDE21"
                    },
                    {
                        "username": "marjan945",
                        "content": "**Can you help optimizing my solution?**\n\n```class Solution {\n\npublic:\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n        for (int i = 0; i < n; i++) Ans.push_back(1);\n        unordered_map<int,vector<int>> connections(n);\n        for(auto edge : edges)\n        {\n            connections[edge[0]].push_back(edge[1]);\n            connections[edge[1]].push_back(edge[0]);\n        }\n        _labels = labels;\n        _connections = connections;\n        dfsChalao(0);\n        return Ans;\n    }\n\n    private:\n    bool visited[100001];\n    vector<int> Ans;\n    unordered_map<int,vector<int>> _connections;\n    string _labels;\n\n    unordered_map<char,int> dfsChalao(int i)\n    {\n        unordered_map<char,int> x;\n        //if (visited[i]) return x;\n        x[_labels[i]-'a']++;\n        visited[i] = true;\n\n        for (auto conn : _connections[i])\n        {\n            if(visited[conn]) continue;\n            unordered_map<char,int> cx = dfsChalao(conn);\n            for (auto co : cx)\n                x[co.first] += co.second;\n        }\n\n        Ans[i] = x[_labels[i]-'a'];\n        return x;\n    }\n};```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- There\\'s an issue: `visited` is a C-style array that does get initialized anywhere. It\\'s elements have *indeterminate values*, reading them before you assign a value to them invokes undefined behavior. The fix is simple, define it like this: `bool visited[100001] = {};` Or even better, see further down below.\\n- At the beginning of `countSubTrees()` instead of repeatedly appending `1`, you could just call `Ans.resize(n, 1)`\\n- The loop variable `conn` in the range-based `for` loop is a value. That means in each iteration it gets constructed (i.e. copied) from the current member of `_connections[i]`. That copy can be avoided by defining `conn` as a reference: `for (auto& conn: _connections[i])`\\n- This solution uses `std::unordered_map` for `_connections`. A `std::unordered_map` is implemented with a hash table and separate chaining, memory for each element gets allocated separately. Accessing an element by its key involves calculating the hash value, mapping that to a bucket, and then potentially locating the element in a linked list. That\\'s not too bad but since the keys (the IDs of the nodes) are integers in the range `[0, n - 1]` you could consider using `std::vector` instead. That is often much faster because accessing an element by its key involves just a multiplication to get the address.\\n- Similarly, this solution uses `std::unordered_map` for the many counters. If you consider that memory for each element gets allocated separately that\\'s a lot of allocations. But we know that the label is one of 26 letters. You could use a `std::array<int, 26>` instead. That would avoid any dynamic memory allocations, those `std::array` instances are comparatively fast to copy around. (But don\\'t forget to *initialize* the `std::array`.)\\n- This solution uses an array `visited` to remember which nodes have already been visited. That works (if you fix the aforementioned issue.) But do you really need it? Alternatively you could pass the ID of the parent as an additional argument to `dfsChalao()`. The `for` loop in that function would then just `continue` if `conn` is equal to the `parent`, and `countSubTrees()` would call `dfsChalao()` with `-1` for the parent."
                    },
                    {
                        "username": "haris_rashid",
                        "content": "same solutution ans solution but gave tle, although i used visited array which i passed by refrence so practically my code should have passed."
                    },
                    {
                        "username": "haris_rashid",
                        "content": "why it is giving tle although i used dfs and in each dfs call i used for loop of 26 .so time \\n0(n+e)*26."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Hard to tell without seeing the code. (Assuming C++) Maybe the recursive function takes one of its parameters by value and therefore creates too many copies?"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Check if you have passed String labels with reference."
                    },
                    {
                        "username": "charlieanthony",
                        "content": "man, I hate TLE. Removed 1 variable and it works perfectly :\\\\"
                    },
                    {
                        "username": "raghupalash",
                        "content": "If using python, I highly using Counter instead of a normal dictionary - updating the counts would become really easy."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is a hard medium problem\\n"
                    },
                    {
                        "username": "try_solving_hard",
                        "content": "<h1>Can anyone put in couple of mins? </h1>\n\n<h3>Why is this code giving TLE?</h3>\n\n<h6>Time Complexity => O(n) [Graph Construction] + O(26 * n) [DFS] + O(n) [Building Result] = O(n + 26 * n + n) = O(28 * n)</h6>\n\n<h6>Space Complexity => O(n) [label_count / ans array] + O(26 * n) [all_freq array] + O(26 * n) [Graph Array - Worst Case] = O(n + 26 * n + 26 * n) = O(53 * n)</h6>\n\n<h6>Approach - Created a frequency array for each node. \nApplying DFS, and updating frequency of characters for nodes while backtracking....\nAt the end assigning label_count i.e., ans to each node.</h6>\n\n`class Solution {\npublic:\n\n    int all_freq[100005][26];\n\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n      \n        vector<int> label_count(n, 0);\n\n        vector<int> graph[n];\n\n        for(auto e : edges)\n        {\n            graph[e[0]].push_back(e[1]);\n            graph[e[1]].push_back(e[0]);\n        }\n        \n        dfs(0, -1, graph, labels);\n\n        for(int i = 0; i < n; i++)\n        {\n            label_count[i] = all_freq[i][labels[i] - 'a']; \n        }\n        \n        return label_count;\n\n    }\n\n    void dfs(int curr, int par, vector<int> graph[], string labels)\n    {\n\n        for(auto nbr : graph[curr])\n        {\n            if (nbr != par)\n            {\n               dfs(nbr, curr, graph, labels);\n\n               for(int i = 0; i < 26; i++)\n                    all_freq[curr][i] += all_freq[nbr][i];\n               \n            }\n        }   \n\n        all_freq[curr][labels[curr] - 'a']++;   \n    }\n};`"
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "pass string labels with reference.\\n\\nlike -> string &labels"
                    },
                    {
                        "username": "patrickbies",
                        "content": "Hey, I think I had a similar problem. Since the labels string is of size n and you are recursively calling dfs, try passing the labels string as a reference."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Not able to solve almost any questions \\nJust another day of suffering, 8-5 college than coding than development fucked up \\nNot able to look at any approach for the approach."
                    },
                    {
                        "username": "eostling",
                        "content": "Can someone explain the output for me. The explanation didn\\'t make any sense to me."
                    },
                    {
                        "username": "eostling",
                        "content": "Oh wait, I think I got it. The output, is in the arrangement of the first element `i` = The total number of all nodes with the same label & the rest of the positions are just 1 for the length of how many arrays are in the list. "
                    }
                ]
            },
            {
                "id": 1754238,
                "content": [
                    {
                        "username": "shubhanshu_jha",
                        "content": "I found the fastest and simpler solution to this problem in Java here: https://youtu.be/UlIjl42eUvQ"
                    },
                    {
                        "username": "Narendra_027",
                        "content": "I have written the same code as given in official solution, just one difference-I have defined `adj` and `ans` array globally. Just because of that it is giving TLE. Why?"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "I love that Leetcode is giving questions of same concept and just making them harder. It\\'s great for practice.\\n\\nThanks Leetcode <3"
                    },
                    {
                        "username": "h_kasaudhan",
                        "content": "there is  TLE in my solution, can any one help me::\nsolution ::\n\nclass Solution {\npublic:\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n         unordered_map<char,int>m;\n        vector<int>adj[n];\n        for(auto it:edges){\n            adj[it[0]].push_back(it[1]);\n            adj[it[1]].push_back(it[0]);\n\n        }\n        vector<int>vis(n,0);\n        vector<int>ans(n,0);\n        //m[labels[0]]++;\n\n        solve(adj,labels,vis,ans,0,m);\n        return ans;\n    }\n    void solve(vector<int>adj[],string s,vector<int>&vis,vector<int>&ans,int node, unordered_map<char,int> &m){\n        vis[node]=1;\n        m[s[node]]++;\n        unordered_map<char,int>m1;\n        \n        for(auto it:adj[node]){\n            if(!vis[it]){\n                 \n                \n                \n                solve(adj,s,vis,ans,it,m1);\n                for(auto it:m1)m[it.first]+=it.second;\n\n            }\n            \n        }\n       \n        ans[node]=m[s[node]];\n       \n\n\n    }\n};\n @\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- `vector<int> adj[n];` is not valid C++ because the size of the C-style array is not known at compile time.  Use `std::vector<std::vector<int>> adj(n);` instead.\\n- `solve()` takes its argument `s` by value causing the `labels` to be copied many many times. Make that a reference instead.\\n"
                    },
                    {
                        "username": "ankitbelieve07",
                        "content": "DFS :)"
                    },
                    {
                        "username": "achieveordie",
                        "content": "A great follow-up question from yesterday\\'s daily question."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "Yeah I reused some code from there."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "  @LeetCode [[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1]."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Because the edges are undirected there is no implicit notion of a \"parent\" or \"child\" for those edges.  \\n`[1,2]` just means that there is an edge between `1` and `2`, either of them can be the parent."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " Input\\nn =\\n4\\nedges =\\n[[0,2],[0,3],[1,2]]\\nlabels =\\n\"aeed\"\\nOutput\\n[1,2,1,1]\\nExpected\\n[1,1,2,1]\\nwhy wrong ?  i thought that root 1 has 2\\'e\\' and root 2 has 1\\'e\\'???"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thanks bro\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This is a visualization of the tree:\\n\\n                      [0, \\'a\\']\\n                         |\\n                +--------+--------+\\n                |                 |\\n             [2, \\'e\\']          [3, \\'d\\']\\n                |\\n       +--------+\\n       |\\n    [1, \\'e\\']\\n\\nThe node `1` has no children, its subtree contains the label `\\'e\\'` once.  \\nThe node `2` has one child, its subtree contains the label `\\'e\\'` twice."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "For each node, return vector[26] containing freq of all children labels.\\nEasy explained approach here: https://youtu.be/F65Ig6pG8Bo"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "why these outputs different. I can\\'t find my mistake. Anybody can help me?\\nI ran my code in my computer:\\nMy computer\\'s output:\\n [1,1,1,1,1,2,3,1,1,1,1,1,1,1,2,1,1,1,1,1,1,4,1,1,1,1,1,3]\\nLeetcode output:\\n[1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,1,0,0]\\n\\n\\nTest Case:\\nn = 28 \\n\\nedges = [[18,0],[20,0],[25,20],[4,25],[21,0],[11,21],[23,11],[7,23],[10,23],[17,10],[24,11],[3,24],[22,11],[6,22],[9,6],[27,6],[12,27],[5,27],[8,5],[14,5],[16,14],[13,16],[19,5],[1,5],[26,1],[15,26],[2,15]]\\n\\nlabels =\"alkielvkfrkbmovzvomfzftmeyjf\"\\nMy code:\\n ```class Solution {\\npublic:\\n    vector<vector<int> > g;\\n    vector<vector<int> > hash;\\n    vector<bool> used;\\n    vector<int> hashMap(int n, vector<vector<int>>& edges, string labels,int root){\\n        vector<int> ans(26,0);\\n        used[root] = true;\\n        ans[labels[root] - \\'a\\'] = 1;\\n        for(auto x:g[root]){\\n            if(!used[x]){\\n                auto y = hashMap(n,edges,labels,x);\\n                for(int i = 0; i < 26;i++){\\n                    ans[i] += y[i];\\n                }\\n            }\\n        }\\n        hash[root] = ans;\\n        return ans;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        g.assign(n,vector<int>());\\n        used.assign(26,false);\\n        for (auto a:edges){\\n            int x = a[0];\\n            int y = a[1];\\n            g[x].push_back(y);\\n            g[y].push_back(x);\\n        }\\n        hash.assign(n,vector<int>(26,0));\\n        auto _ = hashMap(n,edges,labels,0);\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++){\\n            ans[i] = hash[i][labels[i] -\\'a\\'];\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1754232,
                "content": [
                    {
                        "username": "shubhanshu_jha",
                        "content": "I found the fastest and simpler solution to this problem in Java here: https://youtu.be/UlIjl42eUvQ"
                    },
                    {
                        "username": "Narendra_027",
                        "content": "I have written the same code as given in official solution, just one difference-I have defined `adj` and `ans` array globally. Just because of that it is giving TLE. Why?"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "I love that Leetcode is giving questions of same concept and just making them harder. It\\'s great for practice.\\n\\nThanks Leetcode <3"
                    },
                    {
                        "username": "h_kasaudhan",
                        "content": "there is  TLE in my solution, can any one help me::\nsolution ::\n\nclass Solution {\npublic:\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n         unordered_map<char,int>m;\n        vector<int>adj[n];\n        for(auto it:edges){\n            adj[it[0]].push_back(it[1]);\n            adj[it[1]].push_back(it[0]);\n\n        }\n        vector<int>vis(n,0);\n        vector<int>ans(n,0);\n        //m[labels[0]]++;\n\n        solve(adj,labels,vis,ans,0,m);\n        return ans;\n    }\n    void solve(vector<int>adj[],string s,vector<int>&vis,vector<int>&ans,int node, unordered_map<char,int> &m){\n        vis[node]=1;\n        m[s[node]]++;\n        unordered_map<char,int>m1;\n        \n        for(auto it:adj[node]){\n            if(!vis[it]){\n                 \n                \n                \n                solve(adj,s,vis,ans,it,m1);\n                for(auto it:m1)m[it.first]+=it.second;\n\n            }\n            \n        }\n       \n        ans[node]=m[s[node]];\n       \n\n\n    }\n};\n @\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- `vector<int> adj[n];` is not valid C++ because the size of the C-style array is not known at compile time.  Use `std::vector<std::vector<int>> adj(n);` instead.\\n- `solve()` takes its argument `s` by value causing the `labels` to be copied many many times. Make that a reference instead.\\n"
                    },
                    {
                        "username": "ankitbelieve07",
                        "content": "DFS :)"
                    },
                    {
                        "username": "achieveordie",
                        "content": "A great follow-up question from yesterday\\'s daily question."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "Yeah I reused some code from there."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "  @LeetCode [[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1]."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Because the edges are undirected there is no implicit notion of a \"parent\" or \"child\" for those edges.  \\n`[1,2]` just means that there is an edge between `1` and `2`, either of them can be the parent."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " Input\\nn =\\n4\\nedges =\\n[[0,2],[0,3],[1,2]]\\nlabels =\\n\"aeed\"\\nOutput\\n[1,2,1,1]\\nExpected\\n[1,1,2,1]\\nwhy wrong ?  i thought that root 1 has 2\\'e\\' and root 2 has 1\\'e\\'???"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thanks bro\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This is a visualization of the tree:\\n\\n                      [0, \\'a\\']\\n                         |\\n                +--------+--------+\\n                |                 |\\n             [2, \\'e\\']          [3, \\'d\\']\\n                |\\n       +--------+\\n       |\\n    [1, \\'e\\']\\n\\nThe node `1` has no children, its subtree contains the label `\\'e\\'` once.  \\nThe node `2` has one child, its subtree contains the label `\\'e\\'` twice."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "For each node, return vector[26] containing freq of all children labels.\\nEasy explained approach here: https://youtu.be/F65Ig6pG8Bo"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "why these outputs different. I can\\'t find my mistake. Anybody can help me?\\nI ran my code in my computer:\\nMy computer\\'s output:\\n [1,1,1,1,1,2,3,1,1,1,1,1,1,1,2,1,1,1,1,1,1,4,1,1,1,1,1,3]\\nLeetcode output:\\n[1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,1,0,0]\\n\\n\\nTest Case:\\nn = 28 \\n\\nedges = [[18,0],[20,0],[25,20],[4,25],[21,0],[11,21],[23,11],[7,23],[10,23],[17,10],[24,11],[3,24],[22,11],[6,22],[9,6],[27,6],[12,27],[5,27],[8,5],[14,5],[16,14],[13,16],[19,5],[1,5],[26,1],[15,26],[2,15]]\\n\\nlabels =\"alkielvkfrkbmovzvomfzftmeyjf\"\\nMy code:\\n ```class Solution {\\npublic:\\n    vector<vector<int> > g;\\n    vector<vector<int> > hash;\\n    vector<bool> used;\\n    vector<int> hashMap(int n, vector<vector<int>>& edges, string labels,int root){\\n        vector<int> ans(26,0);\\n        used[root] = true;\\n        ans[labels[root] - \\'a\\'] = 1;\\n        for(auto x:g[root]){\\n            if(!used[x]){\\n                auto y = hashMap(n,edges,labels,x);\\n                for(int i = 0; i < 26;i++){\\n                    ans[i] += y[i];\\n                }\\n            }\\n        }\\n        hash[root] = ans;\\n        return ans;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        g.assign(n,vector<int>());\\n        used.assign(26,false);\\n        for (auto a:edges){\\n            int x = a[0];\\n            int y = a[1];\\n            g[x].push_back(y);\\n            g[y].push_back(x);\\n        }\\n        hash.assign(n,vector<int>(26,0));\\n        auto _ = hashMap(n,edges,labels,0);\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++){\\n            ans[i] = hash[i][labels[i] -\\'a\\'];\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1754218,
                "content": [
                    {
                        "username": "shubhanshu_jha",
                        "content": "I found the fastest and simpler solution to this problem in Java here: https://youtu.be/UlIjl42eUvQ"
                    },
                    {
                        "username": "Narendra_027",
                        "content": "I have written the same code as given in official solution, just one difference-I have defined `adj` and `ans` array globally. Just because of that it is giving TLE. Why?"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "I love that Leetcode is giving questions of same concept and just making them harder. It\\'s great for practice.\\n\\nThanks Leetcode <3"
                    },
                    {
                        "username": "h_kasaudhan",
                        "content": "there is  TLE in my solution, can any one help me::\nsolution ::\n\nclass Solution {\npublic:\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n         unordered_map<char,int>m;\n        vector<int>adj[n];\n        for(auto it:edges){\n            adj[it[0]].push_back(it[1]);\n            adj[it[1]].push_back(it[0]);\n\n        }\n        vector<int>vis(n,0);\n        vector<int>ans(n,0);\n        //m[labels[0]]++;\n\n        solve(adj,labels,vis,ans,0,m);\n        return ans;\n    }\n    void solve(vector<int>adj[],string s,vector<int>&vis,vector<int>&ans,int node, unordered_map<char,int> &m){\n        vis[node]=1;\n        m[s[node]]++;\n        unordered_map<char,int>m1;\n        \n        for(auto it:adj[node]){\n            if(!vis[it]){\n                 \n                \n                \n                solve(adj,s,vis,ans,it,m1);\n                for(auto it:m1)m[it.first]+=it.second;\n\n            }\n            \n        }\n       \n        ans[node]=m[s[node]];\n       \n\n\n    }\n};\n @\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- `vector<int> adj[n];` is not valid C++ because the size of the C-style array is not known at compile time.  Use `std::vector<std::vector<int>> adj(n);` instead.\\n- `solve()` takes its argument `s` by value causing the `labels` to be copied many many times. Make that a reference instead.\\n"
                    },
                    {
                        "username": "ankitbelieve07",
                        "content": "DFS :)"
                    },
                    {
                        "username": "achieveordie",
                        "content": "A great follow-up question from yesterday\\'s daily question."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "Yeah I reused some code from there."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "  @LeetCode [[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1]."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Because the edges are undirected there is no implicit notion of a \"parent\" or \"child\" for those edges.  \\n`[1,2]` just means that there is an edge between `1` and `2`, either of them can be the parent."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " Input\\nn =\\n4\\nedges =\\n[[0,2],[0,3],[1,2]]\\nlabels =\\n\"aeed\"\\nOutput\\n[1,2,1,1]\\nExpected\\n[1,1,2,1]\\nwhy wrong ?  i thought that root 1 has 2\\'e\\' and root 2 has 1\\'e\\'???"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thanks bro\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This is a visualization of the tree:\\n\\n                      [0, \\'a\\']\\n                         |\\n                +--------+--------+\\n                |                 |\\n             [2, \\'e\\']          [3, \\'d\\']\\n                |\\n       +--------+\\n       |\\n    [1, \\'e\\']\\n\\nThe node `1` has no children, its subtree contains the label `\\'e\\'` once.  \\nThe node `2` has one child, its subtree contains the label `\\'e\\'` twice."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "For each node, return vector[26] containing freq of all children labels.\\nEasy explained approach here: https://youtu.be/F65Ig6pG8Bo"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "why these outputs different. I can\\'t find my mistake. Anybody can help me?\\nI ran my code in my computer:\\nMy computer\\'s output:\\n [1,1,1,1,1,2,3,1,1,1,1,1,1,1,2,1,1,1,1,1,1,4,1,1,1,1,1,3]\\nLeetcode output:\\n[1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,1,0,0]\\n\\n\\nTest Case:\\nn = 28 \\n\\nedges = [[18,0],[20,0],[25,20],[4,25],[21,0],[11,21],[23,11],[7,23],[10,23],[17,10],[24,11],[3,24],[22,11],[6,22],[9,6],[27,6],[12,27],[5,27],[8,5],[14,5],[16,14],[13,16],[19,5],[1,5],[26,1],[15,26],[2,15]]\\n\\nlabels =\"alkielvkfrkbmovzvomfzftmeyjf\"\\nMy code:\\n ```class Solution {\\npublic:\\n    vector<vector<int> > g;\\n    vector<vector<int> > hash;\\n    vector<bool> used;\\n    vector<int> hashMap(int n, vector<vector<int>>& edges, string labels,int root){\\n        vector<int> ans(26,0);\\n        used[root] = true;\\n        ans[labels[root] - \\'a\\'] = 1;\\n        for(auto x:g[root]){\\n            if(!used[x]){\\n                auto y = hashMap(n,edges,labels,x);\\n                for(int i = 0; i < 26;i++){\\n                    ans[i] += y[i];\\n                }\\n            }\\n        }\\n        hash[root] = ans;\\n        return ans;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        g.assign(n,vector<int>());\\n        used.assign(26,false);\\n        for (auto a:edges){\\n            int x = a[0];\\n            int y = a[1];\\n            g[x].push_back(y);\\n            g[y].push_back(x);\\n        }\\n        hash.assign(n,vector<int>(26,0));\\n        auto _ = hashMap(n,edges,labels,0);\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++){\\n            ans[i] = hash[i][labels[i] -\\'a\\'];\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1754188,
                "content": [
                    {
                        "username": "shubhanshu_jha",
                        "content": "I found the fastest and simpler solution to this problem in Java here: https://youtu.be/UlIjl42eUvQ"
                    },
                    {
                        "username": "Narendra_027",
                        "content": "I have written the same code as given in official solution, just one difference-I have defined `adj` and `ans` array globally. Just because of that it is giving TLE. Why?"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "I love that Leetcode is giving questions of same concept and just making them harder. It\\'s great for practice.\\n\\nThanks Leetcode <3"
                    },
                    {
                        "username": "h_kasaudhan",
                        "content": "there is  TLE in my solution, can any one help me::\nsolution ::\n\nclass Solution {\npublic:\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n         unordered_map<char,int>m;\n        vector<int>adj[n];\n        for(auto it:edges){\n            adj[it[0]].push_back(it[1]);\n            adj[it[1]].push_back(it[0]);\n\n        }\n        vector<int>vis(n,0);\n        vector<int>ans(n,0);\n        //m[labels[0]]++;\n\n        solve(adj,labels,vis,ans,0,m);\n        return ans;\n    }\n    void solve(vector<int>adj[],string s,vector<int>&vis,vector<int>&ans,int node, unordered_map<char,int> &m){\n        vis[node]=1;\n        m[s[node]]++;\n        unordered_map<char,int>m1;\n        \n        for(auto it:adj[node]){\n            if(!vis[it]){\n                 \n                \n                \n                solve(adj,s,vis,ans,it,m1);\n                for(auto it:m1)m[it.first]+=it.second;\n\n            }\n            \n        }\n       \n        ans[node]=m[s[node]];\n       \n\n\n    }\n};\n @\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- `vector<int> adj[n];` is not valid C++ because the size of the C-style array is not known at compile time.  Use `std::vector<std::vector<int>> adj(n);` instead.\\n- `solve()` takes its argument `s` by value causing the `labels` to be copied many many times. Make that a reference instead.\\n"
                    },
                    {
                        "username": "ankitbelieve07",
                        "content": "DFS :)"
                    },
                    {
                        "username": "achieveordie",
                        "content": "A great follow-up question from yesterday\\'s daily question."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "Yeah I reused some code from there."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "  @LeetCode [[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1]."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Because the edges are undirected there is no implicit notion of a \"parent\" or \"child\" for those edges.  \\n`[1,2]` just means that there is an edge between `1` and `2`, either of them can be the parent."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " Input\\nn =\\n4\\nedges =\\n[[0,2],[0,3],[1,2]]\\nlabels =\\n\"aeed\"\\nOutput\\n[1,2,1,1]\\nExpected\\n[1,1,2,1]\\nwhy wrong ?  i thought that root 1 has 2\\'e\\' and root 2 has 1\\'e\\'???"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thanks bro\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This is a visualization of the tree:\\n\\n                      [0, \\'a\\']\\n                         |\\n                +--------+--------+\\n                |                 |\\n             [2, \\'e\\']          [3, \\'d\\']\\n                |\\n       +--------+\\n       |\\n    [1, \\'e\\']\\n\\nThe node `1` has no children, its subtree contains the label `\\'e\\'` once.  \\nThe node `2` has one child, its subtree contains the label `\\'e\\'` twice."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "For each node, return vector[26] containing freq of all children labels.\\nEasy explained approach here: https://youtu.be/F65Ig6pG8Bo"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "why these outputs different. I can\\'t find my mistake. Anybody can help me?\\nI ran my code in my computer:\\nMy computer\\'s output:\\n [1,1,1,1,1,2,3,1,1,1,1,1,1,1,2,1,1,1,1,1,1,4,1,1,1,1,1,3]\\nLeetcode output:\\n[1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,1,0,0]\\n\\n\\nTest Case:\\nn = 28 \\n\\nedges = [[18,0],[20,0],[25,20],[4,25],[21,0],[11,21],[23,11],[7,23],[10,23],[17,10],[24,11],[3,24],[22,11],[6,22],[9,6],[27,6],[12,27],[5,27],[8,5],[14,5],[16,14],[13,16],[19,5],[1,5],[26,1],[15,26],[2,15]]\\n\\nlabels =\"alkielvkfrkbmovzvomfzftmeyjf\"\\nMy code:\\n ```class Solution {\\npublic:\\n    vector<vector<int> > g;\\n    vector<vector<int> > hash;\\n    vector<bool> used;\\n    vector<int> hashMap(int n, vector<vector<int>>& edges, string labels,int root){\\n        vector<int> ans(26,0);\\n        used[root] = true;\\n        ans[labels[root] - \\'a\\'] = 1;\\n        for(auto x:g[root]){\\n            if(!used[x]){\\n                auto y = hashMap(n,edges,labels,x);\\n                for(int i = 0; i < 26;i++){\\n                    ans[i] += y[i];\\n                }\\n            }\\n        }\\n        hash[root] = ans;\\n        return ans;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        g.assign(n,vector<int>());\\n        used.assign(26,false);\\n        for (auto a:edges){\\n            int x = a[0];\\n            int y = a[1];\\n            g[x].push_back(y);\\n            g[y].push_back(x);\\n        }\\n        hash.assign(n,vector<int>(26,0));\\n        auto _ = hashMap(n,edges,labels,0);\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++){\\n            ans[i] = hash[i][labels[i] -\\'a\\'];\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1754156,
                "content": [
                    {
                        "username": "shubhanshu_jha",
                        "content": "I found the fastest and simpler solution to this problem in Java here: https://youtu.be/UlIjl42eUvQ"
                    },
                    {
                        "username": "Narendra_027",
                        "content": "I have written the same code as given in official solution, just one difference-I have defined `adj` and `ans` array globally. Just because of that it is giving TLE. Why?"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "I love that Leetcode is giving questions of same concept and just making them harder. It\\'s great for practice.\\n\\nThanks Leetcode <3"
                    },
                    {
                        "username": "h_kasaudhan",
                        "content": "there is  TLE in my solution, can any one help me::\nsolution ::\n\nclass Solution {\npublic:\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n         unordered_map<char,int>m;\n        vector<int>adj[n];\n        for(auto it:edges){\n            adj[it[0]].push_back(it[1]);\n            adj[it[1]].push_back(it[0]);\n\n        }\n        vector<int>vis(n,0);\n        vector<int>ans(n,0);\n        //m[labels[0]]++;\n\n        solve(adj,labels,vis,ans,0,m);\n        return ans;\n    }\n    void solve(vector<int>adj[],string s,vector<int>&vis,vector<int>&ans,int node, unordered_map<char,int> &m){\n        vis[node]=1;\n        m[s[node]]++;\n        unordered_map<char,int>m1;\n        \n        for(auto it:adj[node]){\n            if(!vis[it]){\n                 \n                \n                \n                solve(adj,s,vis,ans,it,m1);\n                for(auto it:m1)m[it.first]+=it.second;\n\n            }\n            \n        }\n       \n        ans[node]=m[s[node]];\n       \n\n\n    }\n};\n @\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- `vector<int> adj[n];` is not valid C++ because the size of the C-style array is not known at compile time.  Use `std::vector<std::vector<int>> adj(n);` instead.\\n- `solve()` takes its argument `s` by value causing the `labels` to be copied many many times. Make that a reference instead.\\n"
                    },
                    {
                        "username": "ankitbelieve07",
                        "content": "DFS :)"
                    },
                    {
                        "username": "achieveordie",
                        "content": "A great follow-up question from yesterday\\'s daily question."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "Yeah I reused some code from there."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "  @LeetCode [[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1]."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Because the edges are undirected there is no implicit notion of a \"parent\" or \"child\" for those edges.  \\n`[1,2]` just means that there is an edge between `1` and `2`, either of them can be the parent."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " Input\\nn =\\n4\\nedges =\\n[[0,2],[0,3],[1,2]]\\nlabels =\\n\"aeed\"\\nOutput\\n[1,2,1,1]\\nExpected\\n[1,1,2,1]\\nwhy wrong ?  i thought that root 1 has 2\\'e\\' and root 2 has 1\\'e\\'???"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thanks bro\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This is a visualization of the tree:\\n\\n                      [0, \\'a\\']\\n                         |\\n                +--------+--------+\\n                |                 |\\n             [2, \\'e\\']          [3, \\'d\\']\\n                |\\n       +--------+\\n       |\\n    [1, \\'e\\']\\n\\nThe node `1` has no children, its subtree contains the label `\\'e\\'` once.  \\nThe node `2` has one child, its subtree contains the label `\\'e\\'` twice."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "For each node, return vector[26] containing freq of all children labels.\\nEasy explained approach here: https://youtu.be/F65Ig6pG8Bo"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "why these outputs different. I can\\'t find my mistake. Anybody can help me?\\nI ran my code in my computer:\\nMy computer\\'s output:\\n [1,1,1,1,1,2,3,1,1,1,1,1,1,1,2,1,1,1,1,1,1,4,1,1,1,1,1,3]\\nLeetcode output:\\n[1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,1,0,0]\\n\\n\\nTest Case:\\nn = 28 \\n\\nedges = [[18,0],[20,0],[25,20],[4,25],[21,0],[11,21],[23,11],[7,23],[10,23],[17,10],[24,11],[3,24],[22,11],[6,22],[9,6],[27,6],[12,27],[5,27],[8,5],[14,5],[16,14],[13,16],[19,5],[1,5],[26,1],[15,26],[2,15]]\\n\\nlabels =\"alkielvkfrkbmovzvomfzftmeyjf\"\\nMy code:\\n ```class Solution {\\npublic:\\n    vector<vector<int> > g;\\n    vector<vector<int> > hash;\\n    vector<bool> used;\\n    vector<int> hashMap(int n, vector<vector<int>>& edges, string labels,int root){\\n        vector<int> ans(26,0);\\n        used[root] = true;\\n        ans[labels[root] - \\'a\\'] = 1;\\n        for(auto x:g[root]){\\n            if(!used[x]){\\n                auto y = hashMap(n,edges,labels,x);\\n                for(int i = 0; i < 26;i++){\\n                    ans[i] += y[i];\\n                }\\n            }\\n        }\\n        hash[root] = ans;\\n        return ans;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        g.assign(n,vector<int>());\\n        used.assign(26,false);\\n        for (auto a:edges){\\n            int x = a[0];\\n            int y = a[1];\\n            g[x].push_back(y);\\n            g[y].push_back(x);\\n        }\\n        hash.assign(n,vector<int>(26,0));\\n        auto _ = hashMap(n,edges,labels,0);\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++){\\n            ans[i] = hash[i][labels[i] -\\'a\\'];\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1754088,
                "content": [
                    {
                        "username": "shubhanshu_jha",
                        "content": "I found the fastest and simpler solution to this problem in Java here: https://youtu.be/UlIjl42eUvQ"
                    },
                    {
                        "username": "Narendra_027",
                        "content": "I have written the same code as given in official solution, just one difference-I have defined `adj` and `ans` array globally. Just because of that it is giving TLE. Why?"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "I love that Leetcode is giving questions of same concept and just making them harder. It\\'s great for practice.\\n\\nThanks Leetcode <3"
                    },
                    {
                        "username": "h_kasaudhan",
                        "content": "there is  TLE in my solution, can any one help me::\nsolution ::\n\nclass Solution {\npublic:\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n         unordered_map<char,int>m;\n        vector<int>adj[n];\n        for(auto it:edges){\n            adj[it[0]].push_back(it[1]);\n            adj[it[1]].push_back(it[0]);\n\n        }\n        vector<int>vis(n,0);\n        vector<int>ans(n,0);\n        //m[labels[0]]++;\n\n        solve(adj,labels,vis,ans,0,m);\n        return ans;\n    }\n    void solve(vector<int>adj[],string s,vector<int>&vis,vector<int>&ans,int node, unordered_map<char,int> &m){\n        vis[node]=1;\n        m[s[node]]++;\n        unordered_map<char,int>m1;\n        \n        for(auto it:adj[node]){\n            if(!vis[it]){\n                 \n                \n                \n                solve(adj,s,vis,ans,it,m1);\n                for(auto it:m1)m[it.first]+=it.second;\n\n            }\n            \n        }\n       \n        ans[node]=m[s[node]];\n       \n\n\n    }\n};\n @\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- `vector<int> adj[n];` is not valid C++ because the size of the C-style array is not known at compile time.  Use `std::vector<std::vector<int>> adj(n);` instead.\\n- `solve()` takes its argument `s` by value causing the `labels` to be copied many many times. Make that a reference instead.\\n"
                    },
                    {
                        "username": "ankitbelieve07",
                        "content": "DFS :)"
                    },
                    {
                        "username": "achieveordie",
                        "content": "A great follow-up question from yesterday\\'s daily question."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "Yeah I reused some code from there."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "  @LeetCode [[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1]."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Because the edges are undirected there is no implicit notion of a \"parent\" or \"child\" for those edges.  \\n`[1,2]` just means that there is an edge between `1` and `2`, either of them can be the parent."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " Input\\nn =\\n4\\nedges =\\n[[0,2],[0,3],[1,2]]\\nlabels =\\n\"aeed\"\\nOutput\\n[1,2,1,1]\\nExpected\\n[1,1,2,1]\\nwhy wrong ?  i thought that root 1 has 2\\'e\\' and root 2 has 1\\'e\\'???"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thanks bro\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This is a visualization of the tree:\\n\\n                      [0, \\'a\\']\\n                         |\\n                +--------+--------+\\n                |                 |\\n             [2, \\'e\\']          [3, \\'d\\']\\n                |\\n       +--------+\\n       |\\n    [1, \\'e\\']\\n\\nThe node `1` has no children, its subtree contains the label `\\'e\\'` once.  \\nThe node `2` has one child, its subtree contains the label `\\'e\\'` twice."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "For each node, return vector[26] containing freq of all children labels.\\nEasy explained approach here: https://youtu.be/F65Ig6pG8Bo"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "why these outputs different. I can\\'t find my mistake. Anybody can help me?\\nI ran my code in my computer:\\nMy computer\\'s output:\\n [1,1,1,1,1,2,3,1,1,1,1,1,1,1,2,1,1,1,1,1,1,4,1,1,1,1,1,3]\\nLeetcode output:\\n[1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,1,0,0]\\n\\n\\nTest Case:\\nn = 28 \\n\\nedges = [[18,0],[20,0],[25,20],[4,25],[21,0],[11,21],[23,11],[7,23],[10,23],[17,10],[24,11],[3,24],[22,11],[6,22],[9,6],[27,6],[12,27],[5,27],[8,5],[14,5],[16,14],[13,16],[19,5],[1,5],[26,1],[15,26],[2,15]]\\n\\nlabels =\"alkielvkfrkbmovzvomfzftmeyjf\"\\nMy code:\\n ```class Solution {\\npublic:\\n    vector<vector<int> > g;\\n    vector<vector<int> > hash;\\n    vector<bool> used;\\n    vector<int> hashMap(int n, vector<vector<int>>& edges, string labels,int root){\\n        vector<int> ans(26,0);\\n        used[root] = true;\\n        ans[labels[root] - \\'a\\'] = 1;\\n        for(auto x:g[root]){\\n            if(!used[x]){\\n                auto y = hashMap(n,edges,labels,x);\\n                for(int i = 0; i < 26;i++){\\n                    ans[i] += y[i];\\n                }\\n            }\\n        }\\n        hash[root] = ans;\\n        return ans;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        g.assign(n,vector<int>());\\n        used.assign(26,false);\\n        for (auto a:edges){\\n            int x = a[0];\\n            int y = a[1];\\n            g[x].push_back(y);\\n            g[y].push_back(x);\\n        }\\n        hash.assign(n,vector<int>(26,0));\\n        auto _ = hashMap(n,edges,labels,0);\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++){\\n            ans[i] = hash[i][labels[i] -\\'a\\'];\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1753990,
                "content": [
                    {
                        "username": "shubhanshu_jha",
                        "content": "I found the fastest and simpler solution to this problem in Java here: https://youtu.be/UlIjl42eUvQ"
                    },
                    {
                        "username": "Narendra_027",
                        "content": "I have written the same code as given in official solution, just one difference-I have defined `adj` and `ans` array globally. Just because of that it is giving TLE. Why?"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "I love that Leetcode is giving questions of same concept and just making them harder. It\\'s great for practice.\\n\\nThanks Leetcode <3"
                    },
                    {
                        "username": "h_kasaudhan",
                        "content": "there is  TLE in my solution, can any one help me::\nsolution ::\n\nclass Solution {\npublic:\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n         unordered_map<char,int>m;\n        vector<int>adj[n];\n        for(auto it:edges){\n            adj[it[0]].push_back(it[1]);\n            adj[it[1]].push_back(it[0]);\n\n        }\n        vector<int>vis(n,0);\n        vector<int>ans(n,0);\n        //m[labels[0]]++;\n\n        solve(adj,labels,vis,ans,0,m);\n        return ans;\n    }\n    void solve(vector<int>adj[],string s,vector<int>&vis,vector<int>&ans,int node, unordered_map<char,int> &m){\n        vis[node]=1;\n        m[s[node]]++;\n        unordered_map<char,int>m1;\n        \n        for(auto it:adj[node]){\n            if(!vis[it]){\n                 \n                \n                \n                solve(adj,s,vis,ans,it,m1);\n                for(auto it:m1)m[it.first]+=it.second;\n\n            }\n            \n        }\n       \n        ans[node]=m[s[node]];\n       \n\n\n    }\n};\n @\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- `vector<int> adj[n];` is not valid C++ because the size of the C-style array is not known at compile time.  Use `std::vector<std::vector<int>> adj(n);` instead.\\n- `solve()` takes its argument `s` by value causing the `labels` to be copied many many times. Make that a reference instead.\\n"
                    },
                    {
                        "username": "ankitbelieve07",
                        "content": "DFS :)"
                    },
                    {
                        "username": "achieveordie",
                        "content": "A great follow-up question from yesterday\\'s daily question."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "Yeah I reused some code from there."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "  @LeetCode [[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1]."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Because the edges are undirected there is no implicit notion of a \"parent\" or \"child\" for those edges.  \\n`[1,2]` just means that there is an edge between `1` and `2`, either of them can be the parent."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " Input\\nn =\\n4\\nedges =\\n[[0,2],[0,3],[1,2]]\\nlabels =\\n\"aeed\"\\nOutput\\n[1,2,1,1]\\nExpected\\n[1,1,2,1]\\nwhy wrong ?  i thought that root 1 has 2\\'e\\' and root 2 has 1\\'e\\'???"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thanks bro\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This is a visualization of the tree:\\n\\n                      [0, \\'a\\']\\n                         |\\n                +--------+--------+\\n                |                 |\\n             [2, \\'e\\']          [3, \\'d\\']\\n                |\\n       +--------+\\n       |\\n    [1, \\'e\\']\\n\\nThe node `1` has no children, its subtree contains the label `\\'e\\'` once.  \\nThe node `2` has one child, its subtree contains the label `\\'e\\'` twice."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "For each node, return vector[26] containing freq of all children labels.\\nEasy explained approach here: https://youtu.be/F65Ig6pG8Bo"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "why these outputs different. I can\\'t find my mistake. Anybody can help me?\\nI ran my code in my computer:\\nMy computer\\'s output:\\n [1,1,1,1,1,2,3,1,1,1,1,1,1,1,2,1,1,1,1,1,1,4,1,1,1,1,1,3]\\nLeetcode output:\\n[1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,1,0,0]\\n\\n\\nTest Case:\\nn = 28 \\n\\nedges = [[18,0],[20,0],[25,20],[4,25],[21,0],[11,21],[23,11],[7,23],[10,23],[17,10],[24,11],[3,24],[22,11],[6,22],[9,6],[27,6],[12,27],[5,27],[8,5],[14,5],[16,14],[13,16],[19,5],[1,5],[26,1],[15,26],[2,15]]\\n\\nlabels =\"alkielvkfrkbmovzvomfzftmeyjf\"\\nMy code:\\n ```class Solution {\\npublic:\\n    vector<vector<int> > g;\\n    vector<vector<int> > hash;\\n    vector<bool> used;\\n    vector<int> hashMap(int n, vector<vector<int>>& edges, string labels,int root){\\n        vector<int> ans(26,0);\\n        used[root] = true;\\n        ans[labels[root] - \\'a\\'] = 1;\\n        for(auto x:g[root]){\\n            if(!used[x]){\\n                auto y = hashMap(n,edges,labels,x);\\n                for(int i = 0; i < 26;i++){\\n                    ans[i] += y[i];\\n                }\\n            }\\n        }\\n        hash[root] = ans;\\n        return ans;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        g.assign(n,vector<int>());\\n        used.assign(26,false);\\n        for (auto a:edges){\\n            int x = a[0];\\n            int y = a[1];\\n            g[x].push_back(y);\\n            g[y].push_back(x);\\n        }\\n        hash.assign(n,vector<int>(26,0));\\n        auto _ = hashMap(n,edges,labels,0);\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++){\\n            ans[i] = hash[i][labels[i] -\\'a\\'];\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1753941,
                "content": [
                    {
                        "username": "shubhanshu_jha",
                        "content": "I found the fastest and simpler solution to this problem in Java here: https://youtu.be/UlIjl42eUvQ"
                    },
                    {
                        "username": "Narendra_027",
                        "content": "I have written the same code as given in official solution, just one difference-I have defined `adj` and `ans` array globally. Just because of that it is giving TLE. Why?"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "I love that Leetcode is giving questions of same concept and just making them harder. It\\'s great for practice.\\n\\nThanks Leetcode <3"
                    },
                    {
                        "username": "h_kasaudhan",
                        "content": "there is  TLE in my solution, can any one help me::\nsolution ::\n\nclass Solution {\npublic:\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n         unordered_map<char,int>m;\n        vector<int>adj[n];\n        for(auto it:edges){\n            adj[it[0]].push_back(it[1]);\n            adj[it[1]].push_back(it[0]);\n\n        }\n        vector<int>vis(n,0);\n        vector<int>ans(n,0);\n        //m[labels[0]]++;\n\n        solve(adj,labels,vis,ans,0,m);\n        return ans;\n    }\n    void solve(vector<int>adj[],string s,vector<int>&vis,vector<int>&ans,int node, unordered_map<char,int> &m){\n        vis[node]=1;\n        m[s[node]]++;\n        unordered_map<char,int>m1;\n        \n        for(auto it:adj[node]){\n            if(!vis[it]){\n                 \n                \n                \n                solve(adj,s,vis,ans,it,m1);\n                for(auto it:m1)m[it.first]+=it.second;\n\n            }\n            \n        }\n       \n        ans[node]=m[s[node]];\n       \n\n\n    }\n};\n @\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- `vector<int> adj[n];` is not valid C++ because the size of the C-style array is not known at compile time.  Use `std::vector<std::vector<int>> adj(n);` instead.\\n- `solve()` takes its argument `s` by value causing the `labels` to be copied many many times. Make that a reference instead.\\n"
                    },
                    {
                        "username": "ankitbelieve07",
                        "content": "DFS :)"
                    },
                    {
                        "username": "achieveordie",
                        "content": "A great follow-up question from yesterday\\'s daily question."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "Yeah I reused some code from there."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "  @LeetCode [[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1]."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Because the edges are undirected there is no implicit notion of a \"parent\" or \"child\" for those edges.  \\n`[1,2]` just means that there is an edge between `1` and `2`, either of them can be the parent."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " Input\\nn =\\n4\\nedges =\\n[[0,2],[0,3],[1,2]]\\nlabels =\\n\"aeed\"\\nOutput\\n[1,2,1,1]\\nExpected\\n[1,1,2,1]\\nwhy wrong ?  i thought that root 1 has 2\\'e\\' and root 2 has 1\\'e\\'???"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thanks bro\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This is a visualization of the tree:\\n\\n                      [0, \\'a\\']\\n                         |\\n                +--------+--------+\\n                |                 |\\n             [2, \\'e\\']          [3, \\'d\\']\\n                |\\n       +--------+\\n       |\\n    [1, \\'e\\']\\n\\nThe node `1` has no children, its subtree contains the label `\\'e\\'` once.  \\nThe node `2` has one child, its subtree contains the label `\\'e\\'` twice."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "For each node, return vector[26] containing freq of all children labels.\\nEasy explained approach here: https://youtu.be/F65Ig6pG8Bo"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "why these outputs different. I can\\'t find my mistake. Anybody can help me?\\nI ran my code in my computer:\\nMy computer\\'s output:\\n [1,1,1,1,1,2,3,1,1,1,1,1,1,1,2,1,1,1,1,1,1,4,1,1,1,1,1,3]\\nLeetcode output:\\n[1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,1,0,0]\\n\\n\\nTest Case:\\nn = 28 \\n\\nedges = [[18,0],[20,0],[25,20],[4,25],[21,0],[11,21],[23,11],[7,23],[10,23],[17,10],[24,11],[3,24],[22,11],[6,22],[9,6],[27,6],[12,27],[5,27],[8,5],[14,5],[16,14],[13,16],[19,5],[1,5],[26,1],[15,26],[2,15]]\\n\\nlabels =\"alkielvkfrkbmovzvomfzftmeyjf\"\\nMy code:\\n ```class Solution {\\npublic:\\n    vector<vector<int> > g;\\n    vector<vector<int> > hash;\\n    vector<bool> used;\\n    vector<int> hashMap(int n, vector<vector<int>>& edges, string labels,int root){\\n        vector<int> ans(26,0);\\n        used[root] = true;\\n        ans[labels[root] - \\'a\\'] = 1;\\n        for(auto x:g[root]){\\n            if(!used[x]){\\n                auto y = hashMap(n,edges,labels,x);\\n                for(int i = 0; i < 26;i++){\\n                    ans[i] += y[i];\\n                }\\n            }\\n        }\\n        hash[root] = ans;\\n        return ans;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        g.assign(n,vector<int>());\\n        used.assign(26,false);\\n        for (auto a:edges){\\n            int x = a[0];\\n            int y = a[1];\\n            g[x].push_back(y);\\n            g[y].push_back(x);\\n        }\\n        hash.assign(n,vector<int>(26,0));\\n        auto _ = hashMap(n,edges,labels,0);\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++){\\n            ans[i] = hash[i][labels[i] -\\'a\\'];\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1753908,
                "content": [
                    {
                        "username": "shubhanshu_jha",
                        "content": "I found the fastest and simpler solution to this problem in Java here: https://youtu.be/UlIjl42eUvQ"
                    },
                    {
                        "username": "Narendra_027",
                        "content": "I have written the same code as given in official solution, just one difference-I have defined `adj` and `ans` array globally. Just because of that it is giving TLE. Why?"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "I love that Leetcode is giving questions of same concept and just making them harder. It\\'s great for practice.\\n\\nThanks Leetcode <3"
                    },
                    {
                        "username": "h_kasaudhan",
                        "content": "there is  TLE in my solution, can any one help me::\nsolution ::\n\nclass Solution {\npublic:\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n         unordered_map<char,int>m;\n        vector<int>adj[n];\n        for(auto it:edges){\n            adj[it[0]].push_back(it[1]);\n            adj[it[1]].push_back(it[0]);\n\n        }\n        vector<int>vis(n,0);\n        vector<int>ans(n,0);\n        //m[labels[0]]++;\n\n        solve(adj,labels,vis,ans,0,m);\n        return ans;\n    }\n    void solve(vector<int>adj[],string s,vector<int>&vis,vector<int>&ans,int node, unordered_map<char,int> &m){\n        vis[node]=1;\n        m[s[node]]++;\n        unordered_map<char,int>m1;\n        \n        for(auto it:adj[node]){\n            if(!vis[it]){\n                 \n                \n                \n                solve(adj,s,vis,ans,it,m1);\n                for(auto it:m1)m[it.first]+=it.second;\n\n            }\n            \n        }\n       \n        ans[node]=m[s[node]];\n       \n\n\n    }\n};\n @\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- `vector<int> adj[n];` is not valid C++ because the size of the C-style array is not known at compile time.  Use `std::vector<std::vector<int>> adj(n);` instead.\\n- `solve()` takes its argument `s` by value causing the `labels` to be copied many many times. Make that a reference instead.\\n"
                    },
                    {
                        "username": "ankitbelieve07",
                        "content": "DFS :)"
                    },
                    {
                        "username": "achieveordie",
                        "content": "A great follow-up question from yesterday\\'s daily question."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "Yeah I reused some code from there."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "  @LeetCode [[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1]."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Because the edges are undirected there is no implicit notion of a \"parent\" or \"child\" for those edges.  \\n`[1,2]` just means that there is an edge between `1` and `2`, either of them can be the parent."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " Input\\nn =\\n4\\nedges =\\n[[0,2],[0,3],[1,2]]\\nlabels =\\n\"aeed\"\\nOutput\\n[1,2,1,1]\\nExpected\\n[1,1,2,1]\\nwhy wrong ?  i thought that root 1 has 2\\'e\\' and root 2 has 1\\'e\\'???"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thanks bro\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This is a visualization of the tree:\\n\\n                      [0, \\'a\\']\\n                         |\\n                +--------+--------+\\n                |                 |\\n             [2, \\'e\\']          [3, \\'d\\']\\n                |\\n       +--------+\\n       |\\n    [1, \\'e\\']\\n\\nThe node `1` has no children, its subtree contains the label `\\'e\\'` once.  \\nThe node `2` has one child, its subtree contains the label `\\'e\\'` twice."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "For each node, return vector[26] containing freq of all children labels.\\nEasy explained approach here: https://youtu.be/F65Ig6pG8Bo"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "why these outputs different. I can\\'t find my mistake. Anybody can help me?\\nI ran my code in my computer:\\nMy computer\\'s output:\\n [1,1,1,1,1,2,3,1,1,1,1,1,1,1,2,1,1,1,1,1,1,4,1,1,1,1,1,3]\\nLeetcode output:\\n[1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,1,0,0]\\n\\n\\nTest Case:\\nn = 28 \\n\\nedges = [[18,0],[20,0],[25,20],[4,25],[21,0],[11,21],[23,11],[7,23],[10,23],[17,10],[24,11],[3,24],[22,11],[6,22],[9,6],[27,6],[12,27],[5,27],[8,5],[14,5],[16,14],[13,16],[19,5],[1,5],[26,1],[15,26],[2,15]]\\n\\nlabels =\"alkielvkfrkbmovzvomfzftmeyjf\"\\nMy code:\\n ```class Solution {\\npublic:\\n    vector<vector<int> > g;\\n    vector<vector<int> > hash;\\n    vector<bool> used;\\n    vector<int> hashMap(int n, vector<vector<int>>& edges, string labels,int root){\\n        vector<int> ans(26,0);\\n        used[root] = true;\\n        ans[labels[root] - \\'a\\'] = 1;\\n        for(auto x:g[root]){\\n            if(!used[x]){\\n                auto y = hashMap(n,edges,labels,x);\\n                for(int i = 0; i < 26;i++){\\n                    ans[i] += y[i];\\n                }\\n            }\\n        }\\n        hash[root] = ans;\\n        return ans;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        g.assign(n,vector<int>());\\n        used.assign(26,false);\\n        for (auto a:edges){\\n            int x = a[0];\\n            int y = a[1];\\n            g[x].push_back(y);\\n            g[y].push_back(x);\\n        }\\n        hash.assign(n,vector<int>(26,0));\\n        auto _ = hashMap(n,edges,labels,0);\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++){\\n            ans[i] = hash[i][labels[i] -\\'a\\'];\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1753836,
                "content": [
                    {
                        "username": "shubhanshu_jha",
                        "content": "I found the fastest and simpler solution to this problem in Java here: https://youtu.be/UlIjl42eUvQ"
                    },
                    {
                        "username": "Narendra_027",
                        "content": "I have written the same code as given in official solution, just one difference-I have defined `adj` and `ans` array globally. Just because of that it is giving TLE. Why?"
                    },
                    {
                        "username": "namanpokhriyal",
                        "content": "I love that Leetcode is giving questions of same concept and just making them harder. It\\'s great for practice.\\n\\nThanks Leetcode <3"
                    },
                    {
                        "username": "h_kasaudhan",
                        "content": "there is  TLE in my solution, can any one help me::\nsolution ::\n\nclass Solution {\npublic:\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\n         unordered_map<char,int>m;\n        vector<int>adj[n];\n        for(auto it:edges){\n            adj[it[0]].push_back(it[1]);\n            adj[it[1]].push_back(it[0]);\n\n        }\n        vector<int>vis(n,0);\n        vector<int>ans(n,0);\n        //m[labels[0]]++;\n\n        solve(adj,labels,vis,ans,0,m);\n        return ans;\n    }\n    void solve(vector<int>adj[],string s,vector<int>&vis,vector<int>&ans,int node, unordered_map<char,int> &m){\n        vis[node]=1;\n        m[s[node]]++;\n        unordered_map<char,int>m1;\n        \n        for(auto it:adj[node]){\n            if(!vis[it]){\n                 \n                \n                \n                solve(adj,s,vis,ans,it,m1);\n                for(auto it:m1)m[it.first]+=it.second;\n\n            }\n            \n        }\n       \n        ans[node]=m[s[node]];\n       \n\n\n    }\n};\n @\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- `vector<int> adj[n];` is not valid C++ because the size of the C-style array is not known at compile time.  Use `std::vector<std::vector<int>> adj(n);` instead.\\n- `solve()` takes its argument `s` by value causing the `labels` to be copied many many times. Make that a reference instead.\\n"
                    },
                    {
                        "username": "ankitbelieve07",
                        "content": "DFS :)"
                    },
                    {
                        "username": "achieveordie",
                        "content": "A great follow-up question from yesterday\\'s daily question."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "Yeah I reused some code from there."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "  @LeetCode [[0,2],[0,3],[1,2]] is NOT a valid test case because though it is mentioned undirected graph, here the edges [1,2] means 1 is the parent of 2 I believe. \\n\\nConsidering below example. \\n          0,a\\n         /\\n      1,a\\n\\nTest case formed:\\nn = 2\\nedges = [[0,1]]\\nlabels = \"aa\"\\nExpected = [2,1]\\n\\nSo if we consider node0 can be parent of node1 and vice versa then correct output should be [2,2] but expected output given is [2,1]."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Because the edges are undirected there is no implicit notion of a \"parent\" or \"child\" for those edges.  \\n`[1,2]` just means that there is an edge between `1` and `2`, either of them can be the parent."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " Input\\nn =\\n4\\nedges =\\n[[0,2],[0,3],[1,2]]\\nlabels =\\n\"aeed\"\\nOutput\\n[1,2,1,1]\\nExpected\\n[1,1,2,1]\\nwhy wrong ?  i thought that root 1 has 2\\'e\\' and root 2 has 1\\'e\\'???"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thanks bro\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This is a visualization of the tree:\\n\\n                      [0, \\'a\\']\\n                         |\\n                +--------+--------+\\n                |                 |\\n             [2, \\'e\\']          [3, \\'d\\']\\n                |\\n       +--------+\\n       |\\n    [1, \\'e\\']\\n\\nThe node `1` has no children, its subtree contains the label `\\'e\\'` once.  \\nThe node `2` has one child, its subtree contains the label `\\'e\\'` twice."
                    },
                    {
                        "username": "deep_patel23",
                        "content": "For each node, return vector[26] containing freq of all children labels.\\nEasy explained approach here: https://youtu.be/F65Ig6pG8Bo"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "why these outputs different. I can\\'t find my mistake. Anybody can help me?\\nI ran my code in my computer:\\nMy computer\\'s output:\\n [1,1,1,1,1,2,3,1,1,1,1,1,1,1,2,1,1,1,1,1,1,4,1,1,1,1,1,3]\\nLeetcode output:\\n[1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,1,0,0]\\n\\n\\nTest Case:\\nn = 28 \\n\\nedges = [[18,0],[20,0],[25,20],[4,25],[21,0],[11,21],[23,11],[7,23],[10,23],[17,10],[24,11],[3,24],[22,11],[6,22],[9,6],[27,6],[12,27],[5,27],[8,5],[14,5],[16,14],[13,16],[19,5],[1,5],[26,1],[15,26],[2,15]]\\n\\nlabels =\"alkielvkfrkbmovzvomfzftmeyjf\"\\nMy code:\\n ```class Solution {\\npublic:\\n    vector<vector<int> > g;\\n    vector<vector<int> > hash;\\n    vector<bool> used;\\n    vector<int> hashMap(int n, vector<vector<int>>& edges, string labels,int root){\\n        vector<int> ans(26,0);\\n        used[root] = true;\\n        ans[labels[root] - \\'a\\'] = 1;\\n        for(auto x:g[root]){\\n            if(!used[x]){\\n                auto y = hashMap(n,edges,labels,x);\\n                for(int i = 0; i < 26;i++){\\n                    ans[i] += y[i];\\n                }\\n            }\\n        }\\n        hash[root] = ans;\\n        return ans;\\n    }\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        g.assign(n,vector<int>());\\n        used.assign(26,false);\\n        for (auto a:edges){\\n            int x = a[0];\\n            int y = a[1];\\n            g[x].push_back(y);\\n            g[y].push_back(x);\\n        }\\n        hash.assign(n,vector<int>(26,0));\\n        auto _ = hashMap(n,edges,labels,0);\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++){\\n            ans[i] = hash[i][labels[i] -\\'a\\'];\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1753821,
                "content": [
                    {
                        "username": "lordoz",
                        "content": "I think the good approach is use 2 dimensional dynamic programming with states - (node, nodes  in sub tree with following char symbol) and after easy update our dp with next equation dp[v][i]+=dv[it][i], where i = 0\\u202626"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        E = defaultdict(set)\\n        for f,t in edges:\\n            E[f].add(t)\\n            E[t].add(f)\\n        N = {i:e for i,e in enumerate(labels)}\\n        R = [0]*n\\n        def r(ni):\\n            C = Counter()\\n            for e in E[ni]:\\n                E[e].remove(ni)\\n                C.update(r(e))\\n            C.update((N[ni]))\\n            R[ni] = C[N[ni]]\\n            return C\\n        r(0)\\n        return R"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "tip: you can consider using a stack to store the parent node with same label, then increment them by one (if you are not using dp)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Beware of testcase 57 with n = 100000. Avoid making too many copies of arrays/vectors/strings during DFS, else the solution would have tough time passing this testcase."
                    },
                    {
                        "username": "ivorobioff",
                        "content": "You could just say that we need to count all nodes in the sub-tree which have the same label as the root node of the subtree. \\n\\nAlso, in the description there\\'s no example of cases when node with the same label is not directly connected to the root node with the same label but rather indirectly via few other nodes with different letters. "
                    },
                    {
                        "username": "TomXue",
                        "content": "nodejs, puzzled in TLE until I changed for-in loop to Object.keys().forEach when I got counts from child nodes. I tried 2 times, it seems that foreach is always faster than for-in loop.\\n\\n"
                    },
                    {
                        "username": "deborshi1988",
                        "content": "```\\n     void countSubTreesUtils(int src,int prevNode, vector<vector<int>> &graph, string labels , vector<int> &ans, vector<int> &maps ) {\\n        int prevCount = maps[labels[src] - \\'a\\'];\\n        for( int j:graph[src]) {\\n            if( prevNode == j) continue;\\n                countSubTreesUtils(j,src,graph, labels, ans, maps);\\n        \\n        }\\n        maps[labels[src] - \\'a\\']++;\\n        ans[src] =  maps[labels[src] - \\'a\\'] - prevCount;\\n        \\n    }\\n```\\nif i pass the labels as a reference it beats 95 % , if not it is throwing TLE"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "weirdly my solution is pretty similar to the 2nd most upvoted solution here..my solution was using unordered_map and got 5% time,went to discussion after submitting it,inspired by him..used vector and BOOM time went up from 5% to 75%"
                    },
                    {
                        "username": "runitranjankumar",
                        "content": "Hint : \\n `\\ndp = defaultdict(list)\\nfor i , j in edges:\\n       dp[i].append(j)\\n       dp[j].append(i)\\n`\\nYou need to use the concept of visited nodes , to not look into the parent . \\nDid this due to the testcase:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nAns = 1121"
                    },
                    {
                        "username": "chiragchauhan5411",
                        "content": "C++\\n\\n\\nclass Solution {\\npublic:\\n  vector<int> fun(vector<vector<int>> &adj, string &labels, int i,vector<int>&result){\\n    vector<int> ans(26, 0);\\n    result[i] = 1;\\n    ans[labels[i] - \\'a\\'] = 1;\\n    \\n    for(int j = 0; j != adj[i].size(); j++)\\n      if(!result[adj[i][j]]){\\n        vector<int> tmp = fun(adj, labels,adj[i][j],result);\\n        for(int k = 0; k != 26; k++) ans[k] += tmp[k];\\n      }\\n    \\n    result[i] = ans[labels[i] - \\'a\\'];\\n    \\n    return ans;\\n  }\\n  \\n  vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n    vector<vector<int>> adj(n);\\n    vector<int> result(n,0);\\n    for(int i = 0; i != edges.size(); i++)\\n     {adj[edges[i][0]].push_back(edges[i][1]);\\n      adj[edges[i][1]].push_back(edges[i][0]);\\n     }\\n    \\n    fun(adj, labels, 0,result);\\n    return result;\\n  }\\n};"
                    }
                ]
            },
            {
                "id": 1753781,
                "content": [
                    {
                        "username": "lordoz",
                        "content": "I think the good approach is use 2 dimensional dynamic programming with states - (node, nodes  in sub tree with following char symbol) and after easy update our dp with next equation dp[v][i]+=dv[it][i], where i = 0\\u202626"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        E = defaultdict(set)\\n        for f,t in edges:\\n            E[f].add(t)\\n            E[t].add(f)\\n        N = {i:e for i,e in enumerate(labels)}\\n        R = [0]*n\\n        def r(ni):\\n            C = Counter()\\n            for e in E[ni]:\\n                E[e].remove(ni)\\n                C.update(r(e))\\n            C.update((N[ni]))\\n            R[ni] = C[N[ni]]\\n            return C\\n        r(0)\\n        return R"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "tip: you can consider using a stack to store the parent node with same label, then increment them by one (if you are not using dp)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Beware of testcase 57 with n = 100000. Avoid making too many copies of arrays/vectors/strings during DFS, else the solution would have tough time passing this testcase."
                    },
                    {
                        "username": "ivorobioff",
                        "content": "You could just say that we need to count all nodes in the sub-tree which have the same label as the root node of the subtree. \\n\\nAlso, in the description there\\'s no example of cases when node with the same label is not directly connected to the root node with the same label but rather indirectly via few other nodes with different letters. "
                    },
                    {
                        "username": "TomXue",
                        "content": "nodejs, puzzled in TLE until I changed for-in loop to Object.keys().forEach when I got counts from child nodes. I tried 2 times, it seems that foreach is always faster than for-in loop.\\n\\n"
                    },
                    {
                        "username": "deborshi1988",
                        "content": "```\\n     void countSubTreesUtils(int src,int prevNode, vector<vector<int>> &graph, string labels , vector<int> &ans, vector<int> &maps ) {\\n        int prevCount = maps[labels[src] - \\'a\\'];\\n        for( int j:graph[src]) {\\n            if( prevNode == j) continue;\\n                countSubTreesUtils(j,src,graph, labels, ans, maps);\\n        \\n        }\\n        maps[labels[src] - \\'a\\']++;\\n        ans[src] =  maps[labels[src] - \\'a\\'] - prevCount;\\n        \\n    }\\n```\\nif i pass the labels as a reference it beats 95 % , if not it is throwing TLE"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "weirdly my solution is pretty similar to the 2nd most upvoted solution here..my solution was using unordered_map and got 5% time,went to discussion after submitting it,inspired by him..used vector and BOOM time went up from 5% to 75%"
                    },
                    {
                        "username": "runitranjankumar",
                        "content": "Hint : \\n `\\ndp = defaultdict(list)\\nfor i , j in edges:\\n       dp[i].append(j)\\n       dp[j].append(i)\\n`\\nYou need to use the concept of visited nodes , to not look into the parent . \\nDid this due to the testcase:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nAns = 1121"
                    },
                    {
                        "username": "chiragchauhan5411",
                        "content": "C++\\n\\n\\nclass Solution {\\npublic:\\n  vector<int> fun(vector<vector<int>> &adj, string &labels, int i,vector<int>&result){\\n    vector<int> ans(26, 0);\\n    result[i] = 1;\\n    ans[labels[i] - \\'a\\'] = 1;\\n    \\n    for(int j = 0; j != adj[i].size(); j++)\\n      if(!result[adj[i][j]]){\\n        vector<int> tmp = fun(adj, labels,adj[i][j],result);\\n        for(int k = 0; k != 26; k++) ans[k] += tmp[k];\\n      }\\n    \\n    result[i] = ans[labels[i] - \\'a\\'];\\n    \\n    return ans;\\n  }\\n  \\n  vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n    vector<vector<int>> adj(n);\\n    vector<int> result(n,0);\\n    for(int i = 0; i != edges.size(); i++)\\n     {adj[edges[i][0]].push_back(edges[i][1]);\\n      adj[edges[i][1]].push_back(edges[i][0]);\\n     }\\n    \\n    fun(adj, labels, 0,result);\\n    return result;\\n  }\\n};"
                    }
                ]
            },
            {
                "id": 1753769,
                "content": [
                    {
                        "username": "lordoz",
                        "content": "I think the good approach is use 2 dimensional dynamic programming with states - (node, nodes  in sub tree with following char symbol) and after easy update our dp with next equation dp[v][i]+=dv[it][i], where i = 0\\u202626"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        E = defaultdict(set)\\n        for f,t in edges:\\n            E[f].add(t)\\n            E[t].add(f)\\n        N = {i:e for i,e in enumerate(labels)}\\n        R = [0]*n\\n        def r(ni):\\n            C = Counter()\\n            for e in E[ni]:\\n                E[e].remove(ni)\\n                C.update(r(e))\\n            C.update((N[ni]))\\n            R[ni] = C[N[ni]]\\n            return C\\n        r(0)\\n        return R"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "tip: you can consider using a stack to store the parent node with same label, then increment them by one (if you are not using dp)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Beware of testcase 57 with n = 100000. Avoid making too many copies of arrays/vectors/strings during DFS, else the solution would have tough time passing this testcase."
                    },
                    {
                        "username": "ivorobioff",
                        "content": "You could just say that we need to count all nodes in the sub-tree which have the same label as the root node of the subtree. \\n\\nAlso, in the description there\\'s no example of cases when node with the same label is not directly connected to the root node with the same label but rather indirectly via few other nodes with different letters. "
                    },
                    {
                        "username": "TomXue",
                        "content": "nodejs, puzzled in TLE until I changed for-in loop to Object.keys().forEach when I got counts from child nodes. I tried 2 times, it seems that foreach is always faster than for-in loop.\\n\\n"
                    },
                    {
                        "username": "deborshi1988",
                        "content": "```\\n     void countSubTreesUtils(int src,int prevNode, vector<vector<int>> &graph, string labels , vector<int> &ans, vector<int> &maps ) {\\n        int prevCount = maps[labels[src] - \\'a\\'];\\n        for( int j:graph[src]) {\\n            if( prevNode == j) continue;\\n                countSubTreesUtils(j,src,graph, labels, ans, maps);\\n        \\n        }\\n        maps[labels[src] - \\'a\\']++;\\n        ans[src] =  maps[labels[src] - \\'a\\'] - prevCount;\\n        \\n    }\\n```\\nif i pass the labels as a reference it beats 95 % , if not it is throwing TLE"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "weirdly my solution is pretty similar to the 2nd most upvoted solution here..my solution was using unordered_map and got 5% time,went to discussion after submitting it,inspired by him..used vector and BOOM time went up from 5% to 75%"
                    },
                    {
                        "username": "runitranjankumar",
                        "content": "Hint : \\n `\\ndp = defaultdict(list)\\nfor i , j in edges:\\n       dp[i].append(j)\\n       dp[j].append(i)\\n`\\nYou need to use the concept of visited nodes , to not look into the parent . \\nDid this due to the testcase:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nAns = 1121"
                    },
                    {
                        "username": "chiragchauhan5411",
                        "content": "C++\\n\\n\\nclass Solution {\\npublic:\\n  vector<int> fun(vector<vector<int>> &adj, string &labels, int i,vector<int>&result){\\n    vector<int> ans(26, 0);\\n    result[i] = 1;\\n    ans[labels[i] - \\'a\\'] = 1;\\n    \\n    for(int j = 0; j != adj[i].size(); j++)\\n      if(!result[adj[i][j]]){\\n        vector<int> tmp = fun(adj, labels,adj[i][j],result);\\n        for(int k = 0; k != 26; k++) ans[k] += tmp[k];\\n      }\\n    \\n    result[i] = ans[labels[i] - \\'a\\'];\\n    \\n    return ans;\\n  }\\n  \\n  vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n    vector<vector<int>> adj(n);\\n    vector<int> result(n,0);\\n    for(int i = 0; i != edges.size(); i++)\\n     {adj[edges[i][0]].push_back(edges[i][1]);\\n      adj[edges[i][1]].push_back(edges[i][0]);\\n     }\\n    \\n    fun(adj, labels, 0,result);\\n    return result;\\n  }\\n};"
                    }
                ]
            },
            {
                "id": 1753739,
                "content": [
                    {
                        "username": "lordoz",
                        "content": "I think the good approach is use 2 dimensional dynamic programming with states - (node, nodes  in sub tree with following char symbol) and after easy update our dp with next equation dp[v][i]+=dv[it][i], where i = 0\\u202626"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        E = defaultdict(set)\\n        for f,t in edges:\\n            E[f].add(t)\\n            E[t].add(f)\\n        N = {i:e for i,e in enumerate(labels)}\\n        R = [0]*n\\n        def r(ni):\\n            C = Counter()\\n            for e in E[ni]:\\n                E[e].remove(ni)\\n                C.update(r(e))\\n            C.update((N[ni]))\\n            R[ni] = C[N[ni]]\\n            return C\\n        r(0)\\n        return R"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "tip: you can consider using a stack to store the parent node with same label, then increment them by one (if you are not using dp)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Beware of testcase 57 with n = 100000. Avoid making too many copies of arrays/vectors/strings during DFS, else the solution would have tough time passing this testcase."
                    },
                    {
                        "username": "ivorobioff",
                        "content": "You could just say that we need to count all nodes in the sub-tree which have the same label as the root node of the subtree. \\n\\nAlso, in the description there\\'s no example of cases when node with the same label is not directly connected to the root node with the same label but rather indirectly via few other nodes with different letters. "
                    },
                    {
                        "username": "TomXue",
                        "content": "nodejs, puzzled in TLE until I changed for-in loop to Object.keys().forEach when I got counts from child nodes. I tried 2 times, it seems that foreach is always faster than for-in loop.\\n\\n"
                    },
                    {
                        "username": "deborshi1988",
                        "content": "```\\n     void countSubTreesUtils(int src,int prevNode, vector<vector<int>> &graph, string labels , vector<int> &ans, vector<int> &maps ) {\\n        int prevCount = maps[labels[src] - \\'a\\'];\\n        for( int j:graph[src]) {\\n            if( prevNode == j) continue;\\n                countSubTreesUtils(j,src,graph, labels, ans, maps);\\n        \\n        }\\n        maps[labels[src] - \\'a\\']++;\\n        ans[src] =  maps[labels[src] - \\'a\\'] - prevCount;\\n        \\n    }\\n```\\nif i pass the labels as a reference it beats 95 % , if not it is throwing TLE"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "weirdly my solution is pretty similar to the 2nd most upvoted solution here..my solution was using unordered_map and got 5% time,went to discussion after submitting it,inspired by him..used vector and BOOM time went up from 5% to 75%"
                    },
                    {
                        "username": "runitranjankumar",
                        "content": "Hint : \\n `\\ndp = defaultdict(list)\\nfor i , j in edges:\\n       dp[i].append(j)\\n       dp[j].append(i)\\n`\\nYou need to use the concept of visited nodes , to not look into the parent . \\nDid this due to the testcase:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nAns = 1121"
                    },
                    {
                        "username": "chiragchauhan5411",
                        "content": "C++\\n\\n\\nclass Solution {\\npublic:\\n  vector<int> fun(vector<vector<int>> &adj, string &labels, int i,vector<int>&result){\\n    vector<int> ans(26, 0);\\n    result[i] = 1;\\n    ans[labels[i] - \\'a\\'] = 1;\\n    \\n    for(int j = 0; j != adj[i].size(); j++)\\n      if(!result[adj[i][j]]){\\n        vector<int> tmp = fun(adj, labels,adj[i][j],result);\\n        for(int k = 0; k != 26; k++) ans[k] += tmp[k];\\n      }\\n    \\n    result[i] = ans[labels[i] - \\'a\\'];\\n    \\n    return ans;\\n  }\\n  \\n  vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n    vector<vector<int>> adj(n);\\n    vector<int> result(n,0);\\n    for(int i = 0; i != edges.size(); i++)\\n     {adj[edges[i][0]].push_back(edges[i][1]);\\n      adj[edges[i][1]].push_back(edges[i][0]);\\n     }\\n    \\n    fun(adj, labels, 0,result);\\n    return result;\\n  }\\n};"
                    }
                ]
            },
            {
                "id": 1753738,
                "content": [
                    {
                        "username": "lordoz",
                        "content": "I think the good approach is use 2 dimensional dynamic programming with states - (node, nodes  in sub tree with following char symbol) and after easy update our dp with next equation dp[v][i]+=dv[it][i], where i = 0\\u202626"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        E = defaultdict(set)\\n        for f,t in edges:\\n            E[f].add(t)\\n            E[t].add(f)\\n        N = {i:e for i,e in enumerate(labels)}\\n        R = [0]*n\\n        def r(ni):\\n            C = Counter()\\n            for e in E[ni]:\\n                E[e].remove(ni)\\n                C.update(r(e))\\n            C.update((N[ni]))\\n            R[ni] = C[N[ni]]\\n            return C\\n        r(0)\\n        return R"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "tip: you can consider using a stack to store the parent node with same label, then increment them by one (if you are not using dp)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Beware of testcase 57 with n = 100000. Avoid making too many copies of arrays/vectors/strings during DFS, else the solution would have tough time passing this testcase."
                    },
                    {
                        "username": "ivorobioff",
                        "content": "You could just say that we need to count all nodes in the sub-tree which have the same label as the root node of the subtree. \\n\\nAlso, in the description there\\'s no example of cases when node with the same label is not directly connected to the root node with the same label but rather indirectly via few other nodes with different letters. "
                    },
                    {
                        "username": "TomXue",
                        "content": "nodejs, puzzled in TLE until I changed for-in loop to Object.keys().forEach when I got counts from child nodes. I tried 2 times, it seems that foreach is always faster than for-in loop.\\n\\n"
                    },
                    {
                        "username": "deborshi1988",
                        "content": "```\\n     void countSubTreesUtils(int src,int prevNode, vector<vector<int>> &graph, string labels , vector<int> &ans, vector<int> &maps ) {\\n        int prevCount = maps[labels[src] - \\'a\\'];\\n        for( int j:graph[src]) {\\n            if( prevNode == j) continue;\\n                countSubTreesUtils(j,src,graph, labels, ans, maps);\\n        \\n        }\\n        maps[labels[src] - \\'a\\']++;\\n        ans[src] =  maps[labels[src] - \\'a\\'] - prevCount;\\n        \\n    }\\n```\\nif i pass the labels as a reference it beats 95 % , if not it is throwing TLE"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "weirdly my solution is pretty similar to the 2nd most upvoted solution here..my solution was using unordered_map and got 5% time,went to discussion after submitting it,inspired by him..used vector and BOOM time went up from 5% to 75%"
                    },
                    {
                        "username": "runitranjankumar",
                        "content": "Hint : \\n `\\ndp = defaultdict(list)\\nfor i , j in edges:\\n       dp[i].append(j)\\n       dp[j].append(i)\\n`\\nYou need to use the concept of visited nodes , to not look into the parent . \\nDid this due to the testcase:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nAns = 1121"
                    },
                    {
                        "username": "chiragchauhan5411",
                        "content": "C++\\n\\n\\nclass Solution {\\npublic:\\n  vector<int> fun(vector<vector<int>> &adj, string &labels, int i,vector<int>&result){\\n    vector<int> ans(26, 0);\\n    result[i] = 1;\\n    ans[labels[i] - \\'a\\'] = 1;\\n    \\n    for(int j = 0; j != adj[i].size(); j++)\\n      if(!result[adj[i][j]]){\\n        vector<int> tmp = fun(adj, labels,adj[i][j],result);\\n        for(int k = 0; k != 26; k++) ans[k] += tmp[k];\\n      }\\n    \\n    result[i] = ans[labels[i] - \\'a\\'];\\n    \\n    return ans;\\n  }\\n  \\n  vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n    vector<vector<int>> adj(n);\\n    vector<int> result(n,0);\\n    for(int i = 0; i != edges.size(); i++)\\n     {adj[edges[i][0]].push_back(edges[i][1]);\\n      adj[edges[i][1]].push_back(edges[i][0]);\\n     }\\n    \\n    fun(adj, labels, 0,result);\\n    return result;\\n  }\\n};"
                    }
                ]
            },
            {
                "id": 1753685,
                "content": [
                    {
                        "username": "lordoz",
                        "content": "I think the good approach is use 2 dimensional dynamic programming with states - (node, nodes  in sub tree with following char symbol) and after easy update our dp with next equation dp[v][i]+=dv[it][i], where i = 0\\u202626"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        E = defaultdict(set)\\n        for f,t in edges:\\n            E[f].add(t)\\n            E[t].add(f)\\n        N = {i:e for i,e in enumerate(labels)}\\n        R = [0]*n\\n        def r(ni):\\n            C = Counter()\\n            for e in E[ni]:\\n                E[e].remove(ni)\\n                C.update(r(e))\\n            C.update((N[ni]))\\n            R[ni] = C[N[ni]]\\n            return C\\n        r(0)\\n        return R"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "tip: you can consider using a stack to store the parent node with same label, then increment them by one (if you are not using dp)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Beware of testcase 57 with n = 100000. Avoid making too many copies of arrays/vectors/strings during DFS, else the solution would have tough time passing this testcase."
                    },
                    {
                        "username": "ivorobioff",
                        "content": "You could just say that we need to count all nodes in the sub-tree which have the same label as the root node of the subtree. \\n\\nAlso, in the description there\\'s no example of cases when node with the same label is not directly connected to the root node with the same label but rather indirectly via few other nodes with different letters. "
                    },
                    {
                        "username": "TomXue",
                        "content": "nodejs, puzzled in TLE until I changed for-in loop to Object.keys().forEach when I got counts from child nodes. I tried 2 times, it seems that foreach is always faster than for-in loop.\\n\\n"
                    },
                    {
                        "username": "deborshi1988",
                        "content": "```\\n     void countSubTreesUtils(int src,int prevNode, vector<vector<int>> &graph, string labels , vector<int> &ans, vector<int> &maps ) {\\n        int prevCount = maps[labels[src] - \\'a\\'];\\n        for( int j:graph[src]) {\\n            if( prevNode == j) continue;\\n                countSubTreesUtils(j,src,graph, labels, ans, maps);\\n        \\n        }\\n        maps[labels[src] - \\'a\\']++;\\n        ans[src] =  maps[labels[src] - \\'a\\'] - prevCount;\\n        \\n    }\\n```\\nif i pass the labels as a reference it beats 95 % , if not it is throwing TLE"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "weirdly my solution is pretty similar to the 2nd most upvoted solution here..my solution was using unordered_map and got 5% time,went to discussion after submitting it,inspired by him..used vector and BOOM time went up from 5% to 75%"
                    },
                    {
                        "username": "runitranjankumar",
                        "content": "Hint : \\n `\\ndp = defaultdict(list)\\nfor i , j in edges:\\n       dp[i].append(j)\\n       dp[j].append(i)\\n`\\nYou need to use the concept of visited nodes , to not look into the parent . \\nDid this due to the testcase:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nAns = 1121"
                    },
                    {
                        "username": "chiragchauhan5411",
                        "content": "C++\\n\\n\\nclass Solution {\\npublic:\\n  vector<int> fun(vector<vector<int>> &adj, string &labels, int i,vector<int>&result){\\n    vector<int> ans(26, 0);\\n    result[i] = 1;\\n    ans[labels[i] - \\'a\\'] = 1;\\n    \\n    for(int j = 0; j != adj[i].size(); j++)\\n      if(!result[adj[i][j]]){\\n        vector<int> tmp = fun(adj, labels,adj[i][j],result);\\n        for(int k = 0; k != 26; k++) ans[k] += tmp[k];\\n      }\\n    \\n    result[i] = ans[labels[i] - \\'a\\'];\\n    \\n    return ans;\\n  }\\n  \\n  vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n    vector<vector<int>> adj(n);\\n    vector<int> result(n,0);\\n    for(int i = 0; i != edges.size(); i++)\\n     {adj[edges[i][0]].push_back(edges[i][1]);\\n      adj[edges[i][1]].push_back(edges[i][0]);\\n     }\\n    \\n    fun(adj, labels, 0,result);\\n    return result;\\n  }\\n};"
                    }
                ]
            },
            {
                "id": 1753661,
                "content": [
                    {
                        "username": "lordoz",
                        "content": "I think the good approach is use 2 dimensional dynamic programming with states - (node, nodes  in sub tree with following char symbol) and after easy update our dp with next equation dp[v][i]+=dv[it][i], where i = 0\\u202626"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        E = defaultdict(set)\\n        for f,t in edges:\\n            E[f].add(t)\\n            E[t].add(f)\\n        N = {i:e for i,e in enumerate(labels)}\\n        R = [0]*n\\n        def r(ni):\\n            C = Counter()\\n            for e in E[ni]:\\n                E[e].remove(ni)\\n                C.update(r(e))\\n            C.update((N[ni]))\\n            R[ni] = C[N[ni]]\\n            return C\\n        r(0)\\n        return R"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "tip: you can consider using a stack to store the parent node with same label, then increment them by one (if you are not using dp)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Beware of testcase 57 with n = 100000. Avoid making too many copies of arrays/vectors/strings during DFS, else the solution would have tough time passing this testcase."
                    },
                    {
                        "username": "ivorobioff",
                        "content": "You could just say that we need to count all nodes in the sub-tree which have the same label as the root node of the subtree. \\n\\nAlso, in the description there\\'s no example of cases when node with the same label is not directly connected to the root node with the same label but rather indirectly via few other nodes with different letters. "
                    },
                    {
                        "username": "TomXue",
                        "content": "nodejs, puzzled in TLE until I changed for-in loop to Object.keys().forEach when I got counts from child nodes. I tried 2 times, it seems that foreach is always faster than for-in loop.\\n\\n"
                    },
                    {
                        "username": "deborshi1988",
                        "content": "```\\n     void countSubTreesUtils(int src,int prevNode, vector<vector<int>> &graph, string labels , vector<int> &ans, vector<int> &maps ) {\\n        int prevCount = maps[labels[src] - \\'a\\'];\\n        for( int j:graph[src]) {\\n            if( prevNode == j) continue;\\n                countSubTreesUtils(j,src,graph, labels, ans, maps);\\n        \\n        }\\n        maps[labels[src] - \\'a\\']++;\\n        ans[src] =  maps[labels[src] - \\'a\\'] - prevCount;\\n        \\n    }\\n```\\nif i pass the labels as a reference it beats 95 % , if not it is throwing TLE"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "weirdly my solution is pretty similar to the 2nd most upvoted solution here..my solution was using unordered_map and got 5% time,went to discussion after submitting it,inspired by him..used vector and BOOM time went up from 5% to 75%"
                    },
                    {
                        "username": "runitranjankumar",
                        "content": "Hint : \\n `\\ndp = defaultdict(list)\\nfor i , j in edges:\\n       dp[i].append(j)\\n       dp[j].append(i)\\n`\\nYou need to use the concept of visited nodes , to not look into the parent . \\nDid this due to the testcase:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nAns = 1121"
                    },
                    {
                        "username": "chiragchauhan5411",
                        "content": "C++\\n\\n\\nclass Solution {\\npublic:\\n  vector<int> fun(vector<vector<int>> &adj, string &labels, int i,vector<int>&result){\\n    vector<int> ans(26, 0);\\n    result[i] = 1;\\n    ans[labels[i] - \\'a\\'] = 1;\\n    \\n    for(int j = 0; j != adj[i].size(); j++)\\n      if(!result[adj[i][j]]){\\n        vector<int> tmp = fun(adj, labels,adj[i][j],result);\\n        for(int k = 0; k != 26; k++) ans[k] += tmp[k];\\n      }\\n    \\n    result[i] = ans[labels[i] - \\'a\\'];\\n    \\n    return ans;\\n  }\\n  \\n  vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n    vector<vector<int>> adj(n);\\n    vector<int> result(n,0);\\n    for(int i = 0; i != edges.size(); i++)\\n     {adj[edges[i][0]].push_back(edges[i][1]);\\n      adj[edges[i][1]].push_back(edges[i][0]);\\n     }\\n    \\n    fun(adj, labels, 0,result);\\n    return result;\\n  }\\n};"
                    }
                ]
            },
            {
                "id": 1753583,
                "content": [
                    {
                        "username": "lordoz",
                        "content": "I think the good approach is use 2 dimensional dynamic programming with states - (node, nodes  in sub tree with following char symbol) and after easy update our dp with next equation dp[v][i]+=dv[it][i], where i = 0\\u202626"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        E = defaultdict(set)\\n        for f,t in edges:\\n            E[f].add(t)\\n            E[t].add(f)\\n        N = {i:e for i,e in enumerate(labels)}\\n        R = [0]*n\\n        def r(ni):\\n            C = Counter()\\n            for e in E[ni]:\\n                E[e].remove(ni)\\n                C.update(r(e))\\n            C.update((N[ni]))\\n            R[ni] = C[N[ni]]\\n            return C\\n        r(0)\\n        return R"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "tip: you can consider using a stack to store the parent node with same label, then increment them by one (if you are not using dp)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Beware of testcase 57 with n = 100000. Avoid making too many copies of arrays/vectors/strings during DFS, else the solution would have tough time passing this testcase."
                    },
                    {
                        "username": "ivorobioff",
                        "content": "You could just say that we need to count all nodes in the sub-tree which have the same label as the root node of the subtree. \\n\\nAlso, in the description there\\'s no example of cases when node with the same label is not directly connected to the root node with the same label but rather indirectly via few other nodes with different letters. "
                    },
                    {
                        "username": "TomXue",
                        "content": "nodejs, puzzled in TLE until I changed for-in loop to Object.keys().forEach when I got counts from child nodes. I tried 2 times, it seems that foreach is always faster than for-in loop.\\n\\n"
                    },
                    {
                        "username": "deborshi1988",
                        "content": "```\\n     void countSubTreesUtils(int src,int prevNode, vector<vector<int>> &graph, string labels , vector<int> &ans, vector<int> &maps ) {\\n        int prevCount = maps[labels[src] - \\'a\\'];\\n        for( int j:graph[src]) {\\n            if( prevNode == j) continue;\\n                countSubTreesUtils(j,src,graph, labels, ans, maps);\\n        \\n        }\\n        maps[labels[src] - \\'a\\']++;\\n        ans[src] =  maps[labels[src] - \\'a\\'] - prevCount;\\n        \\n    }\\n```\\nif i pass the labels as a reference it beats 95 % , if not it is throwing TLE"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "weirdly my solution is pretty similar to the 2nd most upvoted solution here..my solution was using unordered_map and got 5% time,went to discussion after submitting it,inspired by him..used vector and BOOM time went up from 5% to 75%"
                    },
                    {
                        "username": "runitranjankumar",
                        "content": "Hint : \\n `\\ndp = defaultdict(list)\\nfor i , j in edges:\\n       dp[i].append(j)\\n       dp[j].append(i)\\n`\\nYou need to use the concept of visited nodes , to not look into the parent . \\nDid this due to the testcase:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nAns = 1121"
                    },
                    {
                        "username": "chiragchauhan5411",
                        "content": "C++\\n\\n\\nclass Solution {\\npublic:\\n  vector<int> fun(vector<vector<int>> &adj, string &labels, int i,vector<int>&result){\\n    vector<int> ans(26, 0);\\n    result[i] = 1;\\n    ans[labels[i] - \\'a\\'] = 1;\\n    \\n    for(int j = 0; j != adj[i].size(); j++)\\n      if(!result[adj[i][j]]){\\n        vector<int> tmp = fun(adj, labels,adj[i][j],result);\\n        for(int k = 0; k != 26; k++) ans[k] += tmp[k];\\n      }\\n    \\n    result[i] = ans[labels[i] - \\'a\\'];\\n    \\n    return ans;\\n  }\\n  \\n  vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n    vector<vector<int>> adj(n);\\n    vector<int> result(n,0);\\n    for(int i = 0; i != edges.size(); i++)\\n     {adj[edges[i][0]].push_back(edges[i][1]);\\n      adj[edges[i][1]].push_back(edges[i][0]);\\n     }\\n    \\n    fun(adj, labels, 0,result);\\n    return result;\\n  }\\n};"
                    }
                ]
            },
            {
                "id": 1753578,
                "content": [
                    {
                        "username": "lordoz",
                        "content": "I think the good approach is use 2 dimensional dynamic programming with states - (node, nodes  in sub tree with following char symbol) and after easy update our dp with next equation dp[v][i]+=dv[it][i], where i = 0\\u202626"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        E = defaultdict(set)\\n        for f,t in edges:\\n            E[f].add(t)\\n            E[t].add(f)\\n        N = {i:e for i,e in enumerate(labels)}\\n        R = [0]*n\\n        def r(ni):\\n            C = Counter()\\n            for e in E[ni]:\\n                E[e].remove(ni)\\n                C.update(r(e))\\n            C.update((N[ni]))\\n            R[ni] = C[N[ni]]\\n            return C\\n        r(0)\\n        return R"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "tip: you can consider using a stack to store the parent node with same label, then increment them by one (if you are not using dp)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Beware of testcase 57 with n = 100000. Avoid making too many copies of arrays/vectors/strings during DFS, else the solution would have tough time passing this testcase."
                    },
                    {
                        "username": "ivorobioff",
                        "content": "You could just say that we need to count all nodes in the sub-tree which have the same label as the root node of the subtree. \\n\\nAlso, in the description there\\'s no example of cases when node with the same label is not directly connected to the root node with the same label but rather indirectly via few other nodes with different letters. "
                    },
                    {
                        "username": "TomXue",
                        "content": "nodejs, puzzled in TLE until I changed for-in loop to Object.keys().forEach when I got counts from child nodes. I tried 2 times, it seems that foreach is always faster than for-in loop.\\n\\n"
                    },
                    {
                        "username": "deborshi1988",
                        "content": "```\\n     void countSubTreesUtils(int src,int prevNode, vector<vector<int>> &graph, string labels , vector<int> &ans, vector<int> &maps ) {\\n        int prevCount = maps[labels[src] - \\'a\\'];\\n        for( int j:graph[src]) {\\n            if( prevNode == j) continue;\\n                countSubTreesUtils(j,src,graph, labels, ans, maps);\\n        \\n        }\\n        maps[labels[src] - \\'a\\']++;\\n        ans[src] =  maps[labels[src] - \\'a\\'] - prevCount;\\n        \\n    }\\n```\\nif i pass the labels as a reference it beats 95 % , if not it is throwing TLE"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "weirdly my solution is pretty similar to the 2nd most upvoted solution here..my solution was using unordered_map and got 5% time,went to discussion after submitting it,inspired by him..used vector and BOOM time went up from 5% to 75%"
                    },
                    {
                        "username": "runitranjankumar",
                        "content": "Hint : \\n `\\ndp = defaultdict(list)\\nfor i , j in edges:\\n       dp[i].append(j)\\n       dp[j].append(i)\\n`\\nYou need to use the concept of visited nodes , to not look into the parent . \\nDid this due to the testcase:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nAns = 1121"
                    },
                    {
                        "username": "chiragchauhan5411",
                        "content": "C++\\n\\n\\nclass Solution {\\npublic:\\n  vector<int> fun(vector<vector<int>> &adj, string &labels, int i,vector<int>&result){\\n    vector<int> ans(26, 0);\\n    result[i] = 1;\\n    ans[labels[i] - \\'a\\'] = 1;\\n    \\n    for(int j = 0; j != adj[i].size(); j++)\\n      if(!result[adj[i][j]]){\\n        vector<int> tmp = fun(adj, labels,adj[i][j],result);\\n        for(int k = 0; k != 26; k++) ans[k] += tmp[k];\\n      }\\n    \\n    result[i] = ans[labels[i] - \\'a\\'];\\n    \\n    return ans;\\n  }\\n  \\n  vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n    vector<vector<int>> adj(n);\\n    vector<int> result(n,0);\\n    for(int i = 0; i != edges.size(); i++)\\n     {adj[edges[i][0]].push_back(edges[i][1]);\\n      adj[edges[i][1]].push_back(edges[i][0]);\\n     }\\n    \\n    fun(adj, labels, 0,result);\\n    return result;\\n  }\\n};"
                    }
                ]
            },
            {
                "id": 1753571,
                "content": [
                    {
                        "username": "lordoz",
                        "content": "I think the good approach is use 2 dimensional dynamic programming with states - (node, nodes  in sub tree with following char symbol) and after easy update our dp with next equation dp[v][i]+=dv[it][i], where i = 0\\u202626"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\\n        E = defaultdict(set)\\n        for f,t in edges:\\n            E[f].add(t)\\n            E[t].add(f)\\n        N = {i:e for i,e in enumerate(labels)}\\n        R = [0]*n\\n        def r(ni):\\n            C = Counter()\\n            for e in E[ni]:\\n                E[e].remove(ni)\\n                C.update(r(e))\\n            C.update((N[ni]))\\n            R[ni] = C[N[ni]]\\n            return C\\n        r(0)\\n        return R"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "tip: you can consider using a stack to store the parent node with same label, then increment them by one (if you are not using dp)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Beware of testcase 57 with n = 100000. Avoid making too many copies of arrays/vectors/strings during DFS, else the solution would have tough time passing this testcase."
                    },
                    {
                        "username": "ivorobioff",
                        "content": "You could just say that we need to count all nodes in the sub-tree which have the same label as the root node of the subtree. \\n\\nAlso, in the description there\\'s no example of cases when node with the same label is not directly connected to the root node with the same label but rather indirectly via few other nodes with different letters. "
                    },
                    {
                        "username": "TomXue",
                        "content": "nodejs, puzzled in TLE until I changed for-in loop to Object.keys().forEach when I got counts from child nodes. I tried 2 times, it seems that foreach is always faster than for-in loop.\\n\\n"
                    },
                    {
                        "username": "deborshi1988",
                        "content": "```\\n     void countSubTreesUtils(int src,int prevNode, vector<vector<int>> &graph, string labels , vector<int> &ans, vector<int> &maps ) {\\n        int prevCount = maps[labels[src] - \\'a\\'];\\n        for( int j:graph[src]) {\\n            if( prevNode == j) continue;\\n                countSubTreesUtils(j,src,graph, labels, ans, maps);\\n        \\n        }\\n        maps[labels[src] - \\'a\\']++;\\n        ans[src] =  maps[labels[src] - \\'a\\'] - prevCount;\\n        \\n    }\\n```\\nif i pass the labels as a reference it beats 95 % , if not it is throwing TLE"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "weirdly my solution is pretty similar to the 2nd most upvoted solution here..my solution was using unordered_map and got 5% time,went to discussion after submitting it,inspired by him..used vector and BOOM time went up from 5% to 75%"
                    },
                    {
                        "username": "runitranjankumar",
                        "content": "Hint : \\n `\\ndp = defaultdict(list)\\nfor i , j in edges:\\n       dp[i].append(j)\\n       dp[j].append(i)\\n`\\nYou need to use the concept of visited nodes , to not look into the parent . \\nDid this due to the testcase:\\n4\\n[[0,2],[0,3],[1,2]]\\n\"aeed\"\\nAns = 1121"
                    },
                    {
                        "username": "chiragchauhan5411",
                        "content": "C++\\n\\n\\nclass Solution {\\npublic:\\n  vector<int> fun(vector<vector<int>> &adj, string &labels, int i,vector<int>&result){\\n    vector<int> ans(26, 0);\\n    result[i] = 1;\\n    ans[labels[i] - \\'a\\'] = 1;\\n    \\n    for(int j = 0; j != adj[i].size(); j++)\\n      if(!result[adj[i][j]]){\\n        vector<int> tmp = fun(adj, labels,adj[i][j],result);\\n        for(int k = 0; k != 26; k++) ans[k] += tmp[k];\\n      }\\n    \\n    result[i] = ans[labels[i] - \\'a\\'];\\n    \\n    return ans;\\n  }\\n  \\n  vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n    vector<vector<int>> adj(n);\\n    vector<int> result(n,0);\\n    for(int i = 0; i != edges.size(); i++)\\n     {adj[edges[i][0]].push_back(edges[i][1]);\\n      adj[edges[i][1]].push_back(edges[i][0]);\\n     }\\n    \\n    fun(adj, labels, 0,result);\\n    return result;\\n  }\\n};"
                    }
                ]
            },
            {
                "id": 1753564,
                "content": [
                    {
                        "username": "crazzypanther",
                        "content": "Why is the dislikes to likes ratio so high? This is a great problem! I learned a new way of solving."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be a hard problem, yesterdays problem was already very difficult, this one was even harder still. I brute forced it which I was already pretty happy with, but it gave me TLE (O(N^2)). If it was labeled as hard I would have looked at more hints/solutions sooner. It\\'s a brilliant problem (or at least the solutions are) but the labeling is ridiculus if you compare it to other \\'medium\\' problems, especially last weeks."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "probably because they found it difficult to solve"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "I thought passing arrays to parent from each node would exceed the memory...but i got shocked to see the official solution does the same :/"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "passing the array just passes the reference to it, so no worries there"
                    },
                    {
                        "username": "flyinghawkabove56",
                        "content": "Because of test case: [[0,2],[0,3],[1,2]] and in the description, it mentions \"a connected, undirected graph that has no cycles\", it\\'s kind of misleading. If it\\'s a tree, we should only traverse from parent to children nodes, but if it\\'s treated as an undirected graph, then it does have cycles in nature (parent to children, children to parent)\\nTo pass all the test cases, I would say we treat this tree as an undirected graph and maintain a visited[] array to deal with cycles. Luckily, it\\'s connected."
                    },
                    {
                        "username": "garv_luthra_19",
                        "content": "getting TLE at test cast 59 but leetcode not showing the wrong testcase. The test case is not showing any value of  n. Please cross check my code what Im missing\\n\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(map<int , list<int>>& graph , map<int,map<char,int>>& dp ,  string& s , vector<bool>& visited ,  int ptr  ){\\n        visited[ptr] = true;\\n\\n        for(auto& i : graph[ptr]){\\n            if(!visited[i]){\\n                dfs(graph, dp, s, visited , i);\\n                for(auto& j : dp[i]){\\n                    dp[ptr][j.first] += j.second;\\n                }\\n            }\\n                \\n        }\\n\\n        dp[ptr][s[ptr]]++;\\n\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        map<int , list<int>> graph;\\n\\n        if(n == 1)\\n            return {1};\\n        \\n        for(auto& i : edges){\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n        }\\n        map<int , map<char,int>> dp;\\n\\n        vector<bool> visited(n , false);\\n\\n        dfs(graph, dp , labels , visited, 0);\\n\\n       \\n\\n        vector<int> ans(n);\\n\\n        for(int i = 0 ; i < n ; i++){\\n           ans[i] = dp[i][labels[i]]; \\n        //    cout << ans[i] << \" \"; \\n        }\\n\\n     return ans;\\n\\n        \\n\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "Quickly looking at the code I\\'m guessing that it is the overhead added by the maps (since they are red black trees and random access is logN). So I would guess your algorithm is NlogN \\n\\nI got a TLE because I was passing one of the vector parameters as value instead of reference in the recursion with each call and that was expensive enough to matter. "
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Getting TLE at 58/59 :(\nApplying DFS with backtracking. What should I do?"
                    },
                    {
                        "username": "enrique11",
                        "content": "No need to check all previously visited nodes at every node. At least was the issue for me."
                    },
                    {
                        "username": "enrique11",
                        "content": "Oh come on testcase 59..."
                    },
                    {
                        "username": "quan_mai",
                        "content": "When the explanation of examples are too long, you know you failed on the description section."
                    },
                    {
                        "username": "rnascunha",
                        "content": "testcase 22: 4 | [[0,2],[0,3],[1,2]] | \"aeed\"\\n\\nAs others have already mentioned, isn\\'t this wrong? This doesn\\'t form a undirect tree... \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "sepac",
                        "content": "Yes it does. It\\'s an undirected graph, so 0 is the root, the next level is 2 and 3, and the next level is 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to the one on **day 11**"
                    },
                    {
                        "username": "the_deadly",
                        "content": "Can some help me to find out where I am doing it wrong? I am getting TLE for this code.\\n\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node, int par, vector<int> adj[], string labels, vector<int> &ans){\\n        vector<int> labelsCount(26,0);\\n        labelsCount[labels[node]-\\'a\\']++;\\n        for(auto& child : adj[node]){\\n            if(child == par) continue;\\n            vector<int> childCounts = dfs(child,node,adj,labels,ans);\\n            for(int i = 0;i<26;i++){\\n                //cntOfLabels[node][i] += cntOfLabels[child][i];\\n                labelsCount[i] += childCounts[i];\\n            }\\n        }\\n        ans[node] = labelsCount[labels[node]-\\'a\\'];\\n        //cntOfLabels[node][labels[node]-\\'a\\'] += 1;\\n        return labelsCount;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        //vector<vector<int> > cntOfLabels(n, vector<int> (26,0));\\n        vector<int> adj[n];\\n        //vector<int> vis(n);\\n        for(auto& edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> ans(n);\\n        dfs(0,-1,adj,labels,ans);\\n\\n        // vector<int> ans(n);\\n        // for(int i = 0;i<n;i++){\\n        //     ans[i] = cntOfLabels[i][labels[i]-\\'a\\'];\\n        // }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "olchik",
                        "content": "You might want to send labels as `string&` to dfs"
                    }
                ]
            },
            {
                "id": 1753540,
                "content": [
                    {
                        "username": "crazzypanther",
                        "content": "Why is the dislikes to likes ratio so high? This is a great problem! I learned a new way of solving."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be a hard problem, yesterdays problem was already very difficult, this one was even harder still. I brute forced it which I was already pretty happy with, but it gave me TLE (O(N^2)). If it was labeled as hard I would have looked at more hints/solutions sooner. It\\'s a brilliant problem (or at least the solutions are) but the labeling is ridiculus if you compare it to other \\'medium\\' problems, especially last weeks."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "probably because they found it difficult to solve"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "I thought passing arrays to parent from each node would exceed the memory...but i got shocked to see the official solution does the same :/"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "passing the array just passes the reference to it, so no worries there"
                    },
                    {
                        "username": "flyinghawkabove56",
                        "content": "Because of test case: [[0,2],[0,3],[1,2]] and in the description, it mentions \"a connected, undirected graph that has no cycles\", it\\'s kind of misleading. If it\\'s a tree, we should only traverse from parent to children nodes, but if it\\'s treated as an undirected graph, then it does have cycles in nature (parent to children, children to parent)\\nTo pass all the test cases, I would say we treat this tree as an undirected graph and maintain a visited[] array to deal with cycles. Luckily, it\\'s connected."
                    },
                    {
                        "username": "garv_luthra_19",
                        "content": "getting TLE at test cast 59 but leetcode not showing the wrong testcase. The test case is not showing any value of  n. Please cross check my code what Im missing\\n\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(map<int , list<int>>& graph , map<int,map<char,int>>& dp ,  string& s , vector<bool>& visited ,  int ptr  ){\\n        visited[ptr] = true;\\n\\n        for(auto& i : graph[ptr]){\\n            if(!visited[i]){\\n                dfs(graph, dp, s, visited , i);\\n                for(auto& j : dp[i]){\\n                    dp[ptr][j.first] += j.second;\\n                }\\n            }\\n                \\n        }\\n\\n        dp[ptr][s[ptr]]++;\\n\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        map<int , list<int>> graph;\\n\\n        if(n == 1)\\n            return {1};\\n        \\n        for(auto& i : edges){\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n        }\\n        map<int , map<char,int>> dp;\\n\\n        vector<bool> visited(n , false);\\n\\n        dfs(graph, dp , labels , visited, 0);\\n\\n       \\n\\n        vector<int> ans(n);\\n\\n        for(int i = 0 ; i < n ; i++){\\n           ans[i] = dp[i][labels[i]]; \\n        //    cout << ans[i] << \" \"; \\n        }\\n\\n     return ans;\\n\\n        \\n\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "Quickly looking at the code I\\'m guessing that it is the overhead added by the maps (since they are red black trees and random access is logN). So I would guess your algorithm is NlogN \\n\\nI got a TLE because I was passing one of the vector parameters as value instead of reference in the recursion with each call and that was expensive enough to matter. "
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Getting TLE at 58/59 :(\nApplying DFS with backtracking. What should I do?"
                    },
                    {
                        "username": "enrique11",
                        "content": "No need to check all previously visited nodes at every node. At least was the issue for me."
                    },
                    {
                        "username": "enrique11",
                        "content": "Oh come on testcase 59..."
                    },
                    {
                        "username": "quan_mai",
                        "content": "When the explanation of examples are too long, you know you failed on the description section."
                    },
                    {
                        "username": "rnascunha",
                        "content": "testcase 22: 4 | [[0,2],[0,3],[1,2]] | \"aeed\"\\n\\nAs others have already mentioned, isn\\'t this wrong? This doesn\\'t form a undirect tree... \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "sepac",
                        "content": "Yes it does. It\\'s an undirected graph, so 0 is the root, the next level is 2 and 3, and the next level is 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to the one on **day 11**"
                    },
                    {
                        "username": "the_deadly",
                        "content": "Can some help me to find out where I am doing it wrong? I am getting TLE for this code.\\n\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node, int par, vector<int> adj[], string labels, vector<int> &ans){\\n        vector<int> labelsCount(26,0);\\n        labelsCount[labels[node]-\\'a\\']++;\\n        for(auto& child : adj[node]){\\n            if(child == par) continue;\\n            vector<int> childCounts = dfs(child,node,adj,labels,ans);\\n            for(int i = 0;i<26;i++){\\n                //cntOfLabels[node][i] += cntOfLabels[child][i];\\n                labelsCount[i] += childCounts[i];\\n            }\\n        }\\n        ans[node] = labelsCount[labels[node]-\\'a\\'];\\n        //cntOfLabels[node][labels[node]-\\'a\\'] += 1;\\n        return labelsCount;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        //vector<vector<int> > cntOfLabels(n, vector<int> (26,0));\\n        vector<int> adj[n];\\n        //vector<int> vis(n);\\n        for(auto& edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> ans(n);\\n        dfs(0,-1,adj,labels,ans);\\n\\n        // vector<int> ans(n);\\n        // for(int i = 0;i<n;i++){\\n        //     ans[i] = cntOfLabels[i][labels[i]-\\'a\\'];\\n        // }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "olchik",
                        "content": "You might want to send labels as `string&` to dfs"
                    }
                ]
            },
            {
                "id": 1753502,
                "content": [
                    {
                        "username": "crazzypanther",
                        "content": "Why is the dislikes to likes ratio so high? This is a great problem! I learned a new way of solving."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be a hard problem, yesterdays problem was already very difficult, this one was even harder still. I brute forced it which I was already pretty happy with, but it gave me TLE (O(N^2)). If it was labeled as hard I would have looked at more hints/solutions sooner. It\\'s a brilliant problem (or at least the solutions are) but the labeling is ridiculus if you compare it to other \\'medium\\' problems, especially last weeks."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "probably because they found it difficult to solve"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "I thought passing arrays to parent from each node would exceed the memory...but i got shocked to see the official solution does the same :/"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "passing the array just passes the reference to it, so no worries there"
                    },
                    {
                        "username": "flyinghawkabove56",
                        "content": "Because of test case: [[0,2],[0,3],[1,2]] and in the description, it mentions \"a connected, undirected graph that has no cycles\", it\\'s kind of misleading. If it\\'s a tree, we should only traverse from parent to children nodes, but if it\\'s treated as an undirected graph, then it does have cycles in nature (parent to children, children to parent)\\nTo pass all the test cases, I would say we treat this tree as an undirected graph and maintain a visited[] array to deal with cycles. Luckily, it\\'s connected."
                    },
                    {
                        "username": "garv_luthra_19",
                        "content": "getting TLE at test cast 59 but leetcode not showing the wrong testcase. The test case is not showing any value of  n. Please cross check my code what Im missing\\n\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(map<int , list<int>>& graph , map<int,map<char,int>>& dp ,  string& s , vector<bool>& visited ,  int ptr  ){\\n        visited[ptr] = true;\\n\\n        for(auto& i : graph[ptr]){\\n            if(!visited[i]){\\n                dfs(graph, dp, s, visited , i);\\n                for(auto& j : dp[i]){\\n                    dp[ptr][j.first] += j.second;\\n                }\\n            }\\n                \\n        }\\n\\n        dp[ptr][s[ptr]]++;\\n\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        map<int , list<int>> graph;\\n\\n        if(n == 1)\\n            return {1};\\n        \\n        for(auto& i : edges){\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n        }\\n        map<int , map<char,int>> dp;\\n\\n        vector<bool> visited(n , false);\\n\\n        dfs(graph, dp , labels , visited, 0);\\n\\n       \\n\\n        vector<int> ans(n);\\n\\n        for(int i = 0 ; i < n ; i++){\\n           ans[i] = dp[i][labels[i]]; \\n        //    cout << ans[i] << \" \"; \\n        }\\n\\n     return ans;\\n\\n        \\n\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "Quickly looking at the code I\\'m guessing that it is the overhead added by the maps (since they are red black trees and random access is logN). So I would guess your algorithm is NlogN \\n\\nI got a TLE because I was passing one of the vector parameters as value instead of reference in the recursion with each call and that was expensive enough to matter. "
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Getting TLE at 58/59 :(\nApplying DFS with backtracking. What should I do?"
                    },
                    {
                        "username": "enrique11",
                        "content": "No need to check all previously visited nodes at every node. At least was the issue for me."
                    },
                    {
                        "username": "enrique11",
                        "content": "Oh come on testcase 59..."
                    },
                    {
                        "username": "quan_mai",
                        "content": "When the explanation of examples are too long, you know you failed on the description section."
                    },
                    {
                        "username": "rnascunha",
                        "content": "testcase 22: 4 | [[0,2],[0,3],[1,2]] | \"aeed\"\\n\\nAs others have already mentioned, isn\\'t this wrong? This doesn\\'t form a undirect tree... \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "sepac",
                        "content": "Yes it does. It\\'s an undirected graph, so 0 is the root, the next level is 2 and 3, and the next level is 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to the one on **day 11**"
                    },
                    {
                        "username": "the_deadly",
                        "content": "Can some help me to find out where I am doing it wrong? I am getting TLE for this code.\\n\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node, int par, vector<int> adj[], string labels, vector<int> &ans){\\n        vector<int> labelsCount(26,0);\\n        labelsCount[labels[node]-\\'a\\']++;\\n        for(auto& child : adj[node]){\\n            if(child == par) continue;\\n            vector<int> childCounts = dfs(child,node,adj,labels,ans);\\n            for(int i = 0;i<26;i++){\\n                //cntOfLabels[node][i] += cntOfLabels[child][i];\\n                labelsCount[i] += childCounts[i];\\n            }\\n        }\\n        ans[node] = labelsCount[labels[node]-\\'a\\'];\\n        //cntOfLabels[node][labels[node]-\\'a\\'] += 1;\\n        return labelsCount;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        //vector<vector<int> > cntOfLabels(n, vector<int> (26,0));\\n        vector<int> adj[n];\\n        //vector<int> vis(n);\\n        for(auto& edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> ans(n);\\n        dfs(0,-1,adj,labels,ans);\\n\\n        // vector<int> ans(n);\\n        // for(int i = 0;i<n;i++){\\n        //     ans[i] = cntOfLabels[i][labels[i]-\\'a\\'];\\n        // }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "olchik",
                        "content": "You might want to send labels as `string&` to dfs"
                    }
                ]
            },
            {
                "id": 1753485,
                "content": [
                    {
                        "username": "crazzypanther",
                        "content": "Why is the dislikes to likes ratio so high? This is a great problem! I learned a new way of solving."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be a hard problem, yesterdays problem was already very difficult, this one was even harder still. I brute forced it which I was already pretty happy with, but it gave me TLE (O(N^2)). If it was labeled as hard I would have looked at more hints/solutions sooner. It\\'s a brilliant problem (or at least the solutions are) but the labeling is ridiculus if you compare it to other \\'medium\\' problems, especially last weeks."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "probably because they found it difficult to solve"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "I thought passing arrays to parent from each node would exceed the memory...but i got shocked to see the official solution does the same :/"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "passing the array just passes the reference to it, so no worries there"
                    },
                    {
                        "username": "flyinghawkabove56",
                        "content": "Because of test case: [[0,2],[0,3],[1,2]] and in the description, it mentions \"a connected, undirected graph that has no cycles\", it\\'s kind of misleading. If it\\'s a tree, we should only traverse from parent to children nodes, but if it\\'s treated as an undirected graph, then it does have cycles in nature (parent to children, children to parent)\\nTo pass all the test cases, I would say we treat this tree as an undirected graph and maintain a visited[] array to deal with cycles. Luckily, it\\'s connected."
                    },
                    {
                        "username": "garv_luthra_19",
                        "content": "getting TLE at test cast 59 but leetcode not showing the wrong testcase. The test case is not showing any value of  n. Please cross check my code what Im missing\\n\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(map<int , list<int>>& graph , map<int,map<char,int>>& dp ,  string& s , vector<bool>& visited ,  int ptr  ){\\n        visited[ptr] = true;\\n\\n        for(auto& i : graph[ptr]){\\n            if(!visited[i]){\\n                dfs(graph, dp, s, visited , i);\\n                for(auto& j : dp[i]){\\n                    dp[ptr][j.first] += j.second;\\n                }\\n            }\\n                \\n        }\\n\\n        dp[ptr][s[ptr]]++;\\n\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        map<int , list<int>> graph;\\n\\n        if(n == 1)\\n            return {1};\\n        \\n        for(auto& i : edges){\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n        }\\n        map<int , map<char,int>> dp;\\n\\n        vector<bool> visited(n , false);\\n\\n        dfs(graph, dp , labels , visited, 0);\\n\\n       \\n\\n        vector<int> ans(n);\\n\\n        for(int i = 0 ; i < n ; i++){\\n           ans[i] = dp[i][labels[i]]; \\n        //    cout << ans[i] << \" \"; \\n        }\\n\\n     return ans;\\n\\n        \\n\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "Quickly looking at the code I\\'m guessing that it is the overhead added by the maps (since they are red black trees and random access is logN). So I would guess your algorithm is NlogN \\n\\nI got a TLE because I was passing one of the vector parameters as value instead of reference in the recursion with each call and that was expensive enough to matter. "
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Getting TLE at 58/59 :(\nApplying DFS with backtracking. What should I do?"
                    },
                    {
                        "username": "enrique11",
                        "content": "No need to check all previously visited nodes at every node. At least was the issue for me."
                    },
                    {
                        "username": "enrique11",
                        "content": "Oh come on testcase 59..."
                    },
                    {
                        "username": "quan_mai",
                        "content": "When the explanation of examples are too long, you know you failed on the description section."
                    },
                    {
                        "username": "rnascunha",
                        "content": "testcase 22: 4 | [[0,2],[0,3],[1,2]] | \"aeed\"\\n\\nAs others have already mentioned, isn\\'t this wrong? This doesn\\'t form a undirect tree... \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "sepac",
                        "content": "Yes it does. It\\'s an undirected graph, so 0 is the root, the next level is 2 and 3, and the next level is 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to the one on **day 11**"
                    },
                    {
                        "username": "the_deadly",
                        "content": "Can some help me to find out where I am doing it wrong? I am getting TLE for this code.\\n\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node, int par, vector<int> adj[], string labels, vector<int> &ans){\\n        vector<int> labelsCount(26,0);\\n        labelsCount[labels[node]-\\'a\\']++;\\n        for(auto& child : adj[node]){\\n            if(child == par) continue;\\n            vector<int> childCounts = dfs(child,node,adj,labels,ans);\\n            for(int i = 0;i<26;i++){\\n                //cntOfLabels[node][i] += cntOfLabels[child][i];\\n                labelsCount[i] += childCounts[i];\\n            }\\n        }\\n        ans[node] = labelsCount[labels[node]-\\'a\\'];\\n        //cntOfLabels[node][labels[node]-\\'a\\'] += 1;\\n        return labelsCount;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        //vector<vector<int> > cntOfLabels(n, vector<int> (26,0));\\n        vector<int> adj[n];\\n        //vector<int> vis(n);\\n        for(auto& edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> ans(n);\\n        dfs(0,-1,adj,labels,ans);\\n\\n        // vector<int> ans(n);\\n        // for(int i = 0;i<n;i++){\\n        //     ans[i] = cntOfLabels[i][labels[i]-\\'a\\'];\\n        // }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "olchik",
                        "content": "You might want to send labels as `string&` to dfs"
                    }
                ]
            },
            {
                "id": 1753467,
                "content": [
                    {
                        "username": "crazzypanther",
                        "content": "Why is the dislikes to likes ratio so high? This is a great problem! I learned a new way of solving."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be a hard problem, yesterdays problem was already very difficult, this one was even harder still. I brute forced it which I was already pretty happy with, but it gave me TLE (O(N^2)). If it was labeled as hard I would have looked at more hints/solutions sooner. It\\'s a brilliant problem (or at least the solutions are) but the labeling is ridiculus if you compare it to other \\'medium\\' problems, especially last weeks."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "probably because they found it difficult to solve"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "I thought passing arrays to parent from each node would exceed the memory...but i got shocked to see the official solution does the same :/"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "passing the array just passes the reference to it, so no worries there"
                    },
                    {
                        "username": "flyinghawkabove56",
                        "content": "Because of test case: [[0,2],[0,3],[1,2]] and in the description, it mentions \"a connected, undirected graph that has no cycles\", it\\'s kind of misleading. If it\\'s a tree, we should only traverse from parent to children nodes, but if it\\'s treated as an undirected graph, then it does have cycles in nature (parent to children, children to parent)\\nTo pass all the test cases, I would say we treat this tree as an undirected graph and maintain a visited[] array to deal with cycles. Luckily, it\\'s connected."
                    },
                    {
                        "username": "garv_luthra_19",
                        "content": "getting TLE at test cast 59 but leetcode not showing the wrong testcase. The test case is not showing any value of  n. Please cross check my code what Im missing\\n\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(map<int , list<int>>& graph , map<int,map<char,int>>& dp ,  string& s , vector<bool>& visited ,  int ptr  ){\\n        visited[ptr] = true;\\n\\n        for(auto& i : graph[ptr]){\\n            if(!visited[i]){\\n                dfs(graph, dp, s, visited , i);\\n                for(auto& j : dp[i]){\\n                    dp[ptr][j.first] += j.second;\\n                }\\n            }\\n                \\n        }\\n\\n        dp[ptr][s[ptr]]++;\\n\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        map<int , list<int>> graph;\\n\\n        if(n == 1)\\n            return {1};\\n        \\n        for(auto& i : edges){\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n        }\\n        map<int , map<char,int>> dp;\\n\\n        vector<bool> visited(n , false);\\n\\n        dfs(graph, dp , labels , visited, 0);\\n\\n       \\n\\n        vector<int> ans(n);\\n\\n        for(int i = 0 ; i < n ; i++){\\n           ans[i] = dp[i][labels[i]]; \\n        //    cout << ans[i] << \" \"; \\n        }\\n\\n     return ans;\\n\\n        \\n\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "Quickly looking at the code I\\'m guessing that it is the overhead added by the maps (since they are red black trees and random access is logN). So I would guess your algorithm is NlogN \\n\\nI got a TLE because I was passing one of the vector parameters as value instead of reference in the recursion with each call and that was expensive enough to matter. "
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Getting TLE at 58/59 :(\nApplying DFS with backtracking. What should I do?"
                    },
                    {
                        "username": "enrique11",
                        "content": "No need to check all previously visited nodes at every node. At least was the issue for me."
                    },
                    {
                        "username": "enrique11",
                        "content": "Oh come on testcase 59..."
                    },
                    {
                        "username": "quan_mai",
                        "content": "When the explanation of examples are too long, you know you failed on the description section."
                    },
                    {
                        "username": "rnascunha",
                        "content": "testcase 22: 4 | [[0,2],[0,3],[1,2]] | \"aeed\"\\n\\nAs others have already mentioned, isn\\'t this wrong? This doesn\\'t form a undirect tree... \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "sepac",
                        "content": "Yes it does. It\\'s an undirected graph, so 0 is the root, the next level is 2 and 3, and the next level is 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to the one on **day 11**"
                    },
                    {
                        "username": "the_deadly",
                        "content": "Can some help me to find out where I am doing it wrong? I am getting TLE for this code.\\n\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node, int par, vector<int> adj[], string labels, vector<int> &ans){\\n        vector<int> labelsCount(26,0);\\n        labelsCount[labels[node]-\\'a\\']++;\\n        for(auto& child : adj[node]){\\n            if(child == par) continue;\\n            vector<int> childCounts = dfs(child,node,adj,labels,ans);\\n            for(int i = 0;i<26;i++){\\n                //cntOfLabels[node][i] += cntOfLabels[child][i];\\n                labelsCount[i] += childCounts[i];\\n            }\\n        }\\n        ans[node] = labelsCount[labels[node]-\\'a\\'];\\n        //cntOfLabels[node][labels[node]-\\'a\\'] += 1;\\n        return labelsCount;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        //vector<vector<int> > cntOfLabels(n, vector<int> (26,0));\\n        vector<int> adj[n];\\n        //vector<int> vis(n);\\n        for(auto& edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> ans(n);\\n        dfs(0,-1,adj,labels,ans);\\n\\n        // vector<int> ans(n);\\n        // for(int i = 0;i<n;i++){\\n        //     ans[i] = cntOfLabels[i][labels[i]-\\'a\\'];\\n        // }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "olchik",
                        "content": "You might want to send labels as `string&` to dfs"
                    }
                ]
            },
            {
                "id": 1753465,
                "content": [
                    {
                        "username": "crazzypanther",
                        "content": "Why is the dislikes to likes ratio so high? This is a great problem! I learned a new way of solving."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be a hard problem, yesterdays problem was already very difficult, this one was even harder still. I brute forced it which I was already pretty happy with, but it gave me TLE (O(N^2)). If it was labeled as hard I would have looked at more hints/solutions sooner. It\\'s a brilliant problem (or at least the solutions are) but the labeling is ridiculus if you compare it to other \\'medium\\' problems, especially last weeks."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "probably because they found it difficult to solve"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "I thought passing arrays to parent from each node would exceed the memory...but i got shocked to see the official solution does the same :/"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "passing the array just passes the reference to it, so no worries there"
                    },
                    {
                        "username": "flyinghawkabove56",
                        "content": "Because of test case: [[0,2],[0,3],[1,2]] and in the description, it mentions \"a connected, undirected graph that has no cycles\", it\\'s kind of misleading. If it\\'s a tree, we should only traverse from parent to children nodes, but if it\\'s treated as an undirected graph, then it does have cycles in nature (parent to children, children to parent)\\nTo pass all the test cases, I would say we treat this tree as an undirected graph and maintain a visited[] array to deal with cycles. Luckily, it\\'s connected."
                    },
                    {
                        "username": "garv_luthra_19",
                        "content": "getting TLE at test cast 59 but leetcode not showing the wrong testcase. The test case is not showing any value of  n. Please cross check my code what Im missing\\n\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(map<int , list<int>>& graph , map<int,map<char,int>>& dp ,  string& s , vector<bool>& visited ,  int ptr  ){\\n        visited[ptr] = true;\\n\\n        for(auto& i : graph[ptr]){\\n            if(!visited[i]){\\n                dfs(graph, dp, s, visited , i);\\n                for(auto& j : dp[i]){\\n                    dp[ptr][j.first] += j.second;\\n                }\\n            }\\n                \\n        }\\n\\n        dp[ptr][s[ptr]]++;\\n\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        map<int , list<int>> graph;\\n\\n        if(n == 1)\\n            return {1};\\n        \\n        for(auto& i : edges){\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n        }\\n        map<int , map<char,int>> dp;\\n\\n        vector<bool> visited(n , false);\\n\\n        dfs(graph, dp , labels , visited, 0);\\n\\n       \\n\\n        vector<int> ans(n);\\n\\n        for(int i = 0 ; i < n ; i++){\\n           ans[i] = dp[i][labels[i]]; \\n        //    cout << ans[i] << \" \"; \\n        }\\n\\n     return ans;\\n\\n        \\n\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "Quickly looking at the code I\\'m guessing that it is the overhead added by the maps (since they are red black trees and random access is logN). So I would guess your algorithm is NlogN \\n\\nI got a TLE because I was passing one of the vector parameters as value instead of reference in the recursion with each call and that was expensive enough to matter. "
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Getting TLE at 58/59 :(\nApplying DFS with backtracking. What should I do?"
                    },
                    {
                        "username": "enrique11",
                        "content": "No need to check all previously visited nodes at every node. At least was the issue for me."
                    },
                    {
                        "username": "enrique11",
                        "content": "Oh come on testcase 59..."
                    },
                    {
                        "username": "quan_mai",
                        "content": "When the explanation of examples are too long, you know you failed on the description section."
                    },
                    {
                        "username": "rnascunha",
                        "content": "testcase 22: 4 | [[0,2],[0,3],[1,2]] | \"aeed\"\\n\\nAs others have already mentioned, isn\\'t this wrong? This doesn\\'t form a undirect tree... \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "sepac",
                        "content": "Yes it does. It\\'s an undirected graph, so 0 is the root, the next level is 2 and 3, and the next level is 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to the one on **day 11**"
                    },
                    {
                        "username": "the_deadly",
                        "content": "Can some help me to find out where I am doing it wrong? I am getting TLE for this code.\\n\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node, int par, vector<int> adj[], string labels, vector<int> &ans){\\n        vector<int> labelsCount(26,0);\\n        labelsCount[labels[node]-\\'a\\']++;\\n        for(auto& child : adj[node]){\\n            if(child == par) continue;\\n            vector<int> childCounts = dfs(child,node,adj,labels,ans);\\n            for(int i = 0;i<26;i++){\\n                //cntOfLabels[node][i] += cntOfLabels[child][i];\\n                labelsCount[i] += childCounts[i];\\n            }\\n        }\\n        ans[node] = labelsCount[labels[node]-\\'a\\'];\\n        //cntOfLabels[node][labels[node]-\\'a\\'] += 1;\\n        return labelsCount;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        //vector<vector<int> > cntOfLabels(n, vector<int> (26,0));\\n        vector<int> adj[n];\\n        //vector<int> vis(n);\\n        for(auto& edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> ans(n);\\n        dfs(0,-1,adj,labels,ans);\\n\\n        // vector<int> ans(n);\\n        // for(int i = 0;i<n;i++){\\n        //     ans[i] = cntOfLabels[i][labels[i]-\\'a\\'];\\n        // }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "olchik",
                        "content": "You might want to send labels as `string&` to dfs"
                    }
                ]
            },
            {
                "id": 1753448,
                "content": [
                    {
                        "username": "crazzypanther",
                        "content": "Why is the dislikes to likes ratio so high? This is a great problem! I learned a new way of solving."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be a hard problem, yesterdays problem was already very difficult, this one was even harder still. I brute forced it which I was already pretty happy with, but it gave me TLE (O(N^2)). If it was labeled as hard I would have looked at more hints/solutions sooner. It\\'s a brilliant problem (or at least the solutions are) but the labeling is ridiculus if you compare it to other \\'medium\\' problems, especially last weeks."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "probably because they found it difficult to solve"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "I thought passing arrays to parent from each node would exceed the memory...but i got shocked to see the official solution does the same :/"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "passing the array just passes the reference to it, so no worries there"
                    },
                    {
                        "username": "flyinghawkabove56",
                        "content": "Because of test case: [[0,2],[0,3],[1,2]] and in the description, it mentions \"a connected, undirected graph that has no cycles\", it\\'s kind of misleading. If it\\'s a tree, we should only traverse from parent to children nodes, but if it\\'s treated as an undirected graph, then it does have cycles in nature (parent to children, children to parent)\\nTo pass all the test cases, I would say we treat this tree as an undirected graph and maintain a visited[] array to deal with cycles. Luckily, it\\'s connected."
                    },
                    {
                        "username": "garv_luthra_19",
                        "content": "getting TLE at test cast 59 but leetcode not showing the wrong testcase. The test case is not showing any value of  n. Please cross check my code what Im missing\\n\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(map<int , list<int>>& graph , map<int,map<char,int>>& dp ,  string& s , vector<bool>& visited ,  int ptr  ){\\n        visited[ptr] = true;\\n\\n        for(auto& i : graph[ptr]){\\n            if(!visited[i]){\\n                dfs(graph, dp, s, visited , i);\\n                for(auto& j : dp[i]){\\n                    dp[ptr][j.first] += j.second;\\n                }\\n            }\\n                \\n        }\\n\\n        dp[ptr][s[ptr]]++;\\n\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        map<int , list<int>> graph;\\n\\n        if(n == 1)\\n            return {1};\\n        \\n        for(auto& i : edges){\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n        }\\n        map<int , map<char,int>> dp;\\n\\n        vector<bool> visited(n , false);\\n\\n        dfs(graph, dp , labels , visited, 0);\\n\\n       \\n\\n        vector<int> ans(n);\\n\\n        for(int i = 0 ; i < n ; i++){\\n           ans[i] = dp[i][labels[i]]; \\n        //    cout << ans[i] << \" \"; \\n        }\\n\\n     return ans;\\n\\n        \\n\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "Quickly looking at the code I\\'m guessing that it is the overhead added by the maps (since they are red black trees and random access is logN). So I would guess your algorithm is NlogN \\n\\nI got a TLE because I was passing one of the vector parameters as value instead of reference in the recursion with each call and that was expensive enough to matter. "
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Getting TLE at 58/59 :(\nApplying DFS with backtracking. What should I do?"
                    },
                    {
                        "username": "enrique11",
                        "content": "No need to check all previously visited nodes at every node. At least was the issue for me."
                    },
                    {
                        "username": "enrique11",
                        "content": "Oh come on testcase 59..."
                    },
                    {
                        "username": "quan_mai",
                        "content": "When the explanation of examples are too long, you know you failed on the description section."
                    },
                    {
                        "username": "rnascunha",
                        "content": "testcase 22: 4 | [[0,2],[0,3],[1,2]] | \"aeed\"\\n\\nAs others have already mentioned, isn\\'t this wrong? This doesn\\'t form a undirect tree... \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "sepac",
                        "content": "Yes it does. It\\'s an undirected graph, so 0 is the root, the next level is 2 and 3, and the next level is 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to the one on **day 11**"
                    },
                    {
                        "username": "the_deadly",
                        "content": "Can some help me to find out where I am doing it wrong? I am getting TLE for this code.\\n\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node, int par, vector<int> adj[], string labels, vector<int> &ans){\\n        vector<int> labelsCount(26,0);\\n        labelsCount[labels[node]-\\'a\\']++;\\n        for(auto& child : adj[node]){\\n            if(child == par) continue;\\n            vector<int> childCounts = dfs(child,node,adj,labels,ans);\\n            for(int i = 0;i<26;i++){\\n                //cntOfLabels[node][i] += cntOfLabels[child][i];\\n                labelsCount[i] += childCounts[i];\\n            }\\n        }\\n        ans[node] = labelsCount[labels[node]-\\'a\\'];\\n        //cntOfLabels[node][labels[node]-\\'a\\'] += 1;\\n        return labelsCount;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        //vector<vector<int> > cntOfLabels(n, vector<int> (26,0));\\n        vector<int> adj[n];\\n        //vector<int> vis(n);\\n        for(auto& edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> ans(n);\\n        dfs(0,-1,adj,labels,ans);\\n\\n        // vector<int> ans(n);\\n        // for(int i = 0;i<n;i++){\\n        //     ans[i] = cntOfLabels[i][labels[i]-\\'a\\'];\\n        // }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "olchik",
                        "content": "You might want to send labels as `string&` to dfs"
                    }
                ]
            },
            {
                "id": 1753351,
                "content": [
                    {
                        "username": "crazzypanther",
                        "content": "Why is the dislikes to likes ratio so high? This is a great problem! I learned a new way of solving."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be a hard problem, yesterdays problem was already very difficult, this one was even harder still. I brute forced it which I was already pretty happy with, but it gave me TLE (O(N^2)). If it was labeled as hard I would have looked at more hints/solutions sooner. It\\'s a brilliant problem (or at least the solutions are) but the labeling is ridiculus if you compare it to other \\'medium\\' problems, especially last weeks."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "probably because they found it difficult to solve"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "I thought passing arrays to parent from each node would exceed the memory...but i got shocked to see the official solution does the same :/"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "passing the array just passes the reference to it, so no worries there"
                    },
                    {
                        "username": "flyinghawkabove56",
                        "content": "Because of test case: [[0,2],[0,3],[1,2]] and in the description, it mentions \"a connected, undirected graph that has no cycles\", it\\'s kind of misleading. If it\\'s a tree, we should only traverse from parent to children nodes, but if it\\'s treated as an undirected graph, then it does have cycles in nature (parent to children, children to parent)\\nTo pass all the test cases, I would say we treat this tree as an undirected graph and maintain a visited[] array to deal with cycles. Luckily, it\\'s connected."
                    },
                    {
                        "username": "garv_luthra_19",
                        "content": "getting TLE at test cast 59 but leetcode not showing the wrong testcase. The test case is not showing any value of  n. Please cross check my code what Im missing\\n\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(map<int , list<int>>& graph , map<int,map<char,int>>& dp ,  string& s , vector<bool>& visited ,  int ptr  ){\\n        visited[ptr] = true;\\n\\n        for(auto& i : graph[ptr]){\\n            if(!visited[i]){\\n                dfs(graph, dp, s, visited , i);\\n                for(auto& j : dp[i]){\\n                    dp[ptr][j.first] += j.second;\\n                }\\n            }\\n                \\n        }\\n\\n        dp[ptr][s[ptr]]++;\\n\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        map<int , list<int>> graph;\\n\\n        if(n == 1)\\n            return {1};\\n        \\n        for(auto& i : edges){\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n        }\\n        map<int , map<char,int>> dp;\\n\\n        vector<bool> visited(n , false);\\n\\n        dfs(graph, dp , labels , visited, 0);\\n\\n       \\n\\n        vector<int> ans(n);\\n\\n        for(int i = 0 ; i < n ; i++){\\n           ans[i] = dp[i][labels[i]]; \\n        //    cout << ans[i] << \" \"; \\n        }\\n\\n     return ans;\\n\\n        \\n\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "Quickly looking at the code I\\'m guessing that it is the overhead added by the maps (since they are red black trees and random access is logN). So I would guess your algorithm is NlogN \\n\\nI got a TLE because I was passing one of the vector parameters as value instead of reference in the recursion with each call and that was expensive enough to matter. "
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Getting TLE at 58/59 :(\nApplying DFS with backtracking. What should I do?"
                    },
                    {
                        "username": "enrique11",
                        "content": "No need to check all previously visited nodes at every node. At least was the issue for me."
                    },
                    {
                        "username": "enrique11",
                        "content": "Oh come on testcase 59..."
                    },
                    {
                        "username": "quan_mai",
                        "content": "When the explanation of examples are too long, you know you failed on the description section."
                    },
                    {
                        "username": "rnascunha",
                        "content": "testcase 22: 4 | [[0,2],[0,3],[1,2]] | \"aeed\"\\n\\nAs others have already mentioned, isn\\'t this wrong? This doesn\\'t form a undirect tree... \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "sepac",
                        "content": "Yes it does. It\\'s an undirected graph, so 0 is the root, the next level is 2 and 3, and the next level is 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to the one on **day 11**"
                    },
                    {
                        "username": "the_deadly",
                        "content": "Can some help me to find out where I am doing it wrong? I am getting TLE for this code.\\n\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node, int par, vector<int> adj[], string labels, vector<int> &ans){\\n        vector<int> labelsCount(26,0);\\n        labelsCount[labels[node]-\\'a\\']++;\\n        for(auto& child : adj[node]){\\n            if(child == par) continue;\\n            vector<int> childCounts = dfs(child,node,adj,labels,ans);\\n            for(int i = 0;i<26;i++){\\n                //cntOfLabels[node][i] += cntOfLabels[child][i];\\n                labelsCount[i] += childCounts[i];\\n            }\\n        }\\n        ans[node] = labelsCount[labels[node]-\\'a\\'];\\n        //cntOfLabels[node][labels[node]-\\'a\\'] += 1;\\n        return labelsCount;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        //vector<vector<int> > cntOfLabels(n, vector<int> (26,0));\\n        vector<int> adj[n];\\n        //vector<int> vis(n);\\n        for(auto& edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> ans(n);\\n        dfs(0,-1,adj,labels,ans);\\n\\n        // vector<int> ans(n);\\n        // for(int i = 0;i<n;i++){\\n        //     ans[i] = cntOfLabels[i][labels[i]-\\'a\\'];\\n        // }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "olchik",
                        "content": "You might want to send labels as `string&` to dfs"
                    }
                ]
            },
            {
                "id": 1753344,
                "content": [
                    {
                        "username": "crazzypanther",
                        "content": "Why is the dislikes to likes ratio so high? This is a great problem! I learned a new way of solving."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be a hard problem, yesterdays problem was already very difficult, this one was even harder still. I brute forced it which I was already pretty happy with, but it gave me TLE (O(N^2)). If it was labeled as hard I would have looked at more hints/solutions sooner. It\\'s a brilliant problem (or at least the solutions are) but the labeling is ridiculus if you compare it to other \\'medium\\' problems, especially last weeks."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "probably because they found it difficult to solve"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "I thought passing arrays to parent from each node would exceed the memory...but i got shocked to see the official solution does the same :/"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "passing the array just passes the reference to it, so no worries there"
                    },
                    {
                        "username": "flyinghawkabove56",
                        "content": "Because of test case: [[0,2],[0,3],[1,2]] and in the description, it mentions \"a connected, undirected graph that has no cycles\", it\\'s kind of misleading. If it\\'s a tree, we should only traverse from parent to children nodes, but if it\\'s treated as an undirected graph, then it does have cycles in nature (parent to children, children to parent)\\nTo pass all the test cases, I would say we treat this tree as an undirected graph and maintain a visited[] array to deal with cycles. Luckily, it\\'s connected."
                    },
                    {
                        "username": "garv_luthra_19",
                        "content": "getting TLE at test cast 59 but leetcode not showing the wrong testcase. The test case is not showing any value of  n. Please cross check my code what Im missing\\n\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(map<int , list<int>>& graph , map<int,map<char,int>>& dp ,  string& s , vector<bool>& visited ,  int ptr  ){\\n        visited[ptr] = true;\\n\\n        for(auto& i : graph[ptr]){\\n            if(!visited[i]){\\n                dfs(graph, dp, s, visited , i);\\n                for(auto& j : dp[i]){\\n                    dp[ptr][j.first] += j.second;\\n                }\\n            }\\n                \\n        }\\n\\n        dp[ptr][s[ptr]]++;\\n\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        map<int , list<int>> graph;\\n\\n        if(n == 1)\\n            return {1};\\n        \\n        for(auto& i : edges){\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n        }\\n        map<int , map<char,int>> dp;\\n\\n        vector<bool> visited(n , false);\\n\\n        dfs(graph, dp , labels , visited, 0);\\n\\n       \\n\\n        vector<int> ans(n);\\n\\n        for(int i = 0 ; i < n ; i++){\\n           ans[i] = dp[i][labels[i]]; \\n        //    cout << ans[i] << \" \"; \\n        }\\n\\n     return ans;\\n\\n        \\n\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "Quickly looking at the code I\\'m guessing that it is the overhead added by the maps (since they are red black trees and random access is logN). So I would guess your algorithm is NlogN \\n\\nI got a TLE because I was passing one of the vector parameters as value instead of reference in the recursion with each call and that was expensive enough to matter. "
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Getting TLE at 58/59 :(\nApplying DFS with backtracking. What should I do?"
                    },
                    {
                        "username": "enrique11",
                        "content": "No need to check all previously visited nodes at every node. At least was the issue for me."
                    },
                    {
                        "username": "enrique11",
                        "content": "Oh come on testcase 59..."
                    },
                    {
                        "username": "quan_mai",
                        "content": "When the explanation of examples are too long, you know you failed on the description section."
                    },
                    {
                        "username": "rnascunha",
                        "content": "testcase 22: 4 | [[0,2],[0,3],[1,2]] | \"aeed\"\\n\\nAs others have already mentioned, isn\\'t this wrong? This doesn\\'t form a undirect tree... \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "sepac",
                        "content": "Yes it does. It\\'s an undirected graph, so 0 is the root, the next level is 2 and 3, and the next level is 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to the one on **day 11**"
                    },
                    {
                        "username": "the_deadly",
                        "content": "Can some help me to find out where I am doing it wrong? I am getting TLE for this code.\\n\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node, int par, vector<int> adj[], string labels, vector<int> &ans){\\n        vector<int> labelsCount(26,0);\\n        labelsCount[labels[node]-\\'a\\']++;\\n        for(auto& child : adj[node]){\\n            if(child == par) continue;\\n            vector<int> childCounts = dfs(child,node,adj,labels,ans);\\n            for(int i = 0;i<26;i++){\\n                //cntOfLabels[node][i] += cntOfLabels[child][i];\\n                labelsCount[i] += childCounts[i];\\n            }\\n        }\\n        ans[node] = labelsCount[labels[node]-\\'a\\'];\\n        //cntOfLabels[node][labels[node]-\\'a\\'] += 1;\\n        return labelsCount;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        //vector<vector<int> > cntOfLabels(n, vector<int> (26,0));\\n        vector<int> adj[n];\\n        //vector<int> vis(n);\\n        for(auto& edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> ans(n);\\n        dfs(0,-1,adj,labels,ans);\\n\\n        // vector<int> ans(n);\\n        // for(int i = 0;i<n;i++){\\n        //     ans[i] = cntOfLabels[i][labels[i]-\\'a\\'];\\n        // }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "olchik",
                        "content": "You might want to send labels as `string&` to dfs"
                    }
                ]
            },
            {
                "id": 1735718,
                "content": [
                    {
                        "username": "crazzypanther",
                        "content": "Why is the dislikes to likes ratio so high? This is a great problem! I learned a new way of solving."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be a hard problem, yesterdays problem was already very difficult, this one was even harder still. I brute forced it which I was already pretty happy with, but it gave me TLE (O(N^2)). If it was labeled as hard I would have looked at more hints/solutions sooner. It\\'s a brilliant problem (or at least the solutions are) but the labeling is ridiculus if you compare it to other \\'medium\\' problems, especially last weeks."
                    },
                    {
                        "username": "dan_kerna",
                        "content": "probably because they found it difficult to solve"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "I thought passing arrays to parent from each node would exceed the memory...but i got shocked to see the official solution does the same :/"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "passing the array just passes the reference to it, so no worries there"
                    },
                    {
                        "username": "flyinghawkabove56",
                        "content": "Because of test case: [[0,2],[0,3],[1,2]] and in the description, it mentions \"a connected, undirected graph that has no cycles\", it\\'s kind of misleading. If it\\'s a tree, we should only traverse from parent to children nodes, but if it\\'s treated as an undirected graph, then it does have cycles in nature (parent to children, children to parent)\\nTo pass all the test cases, I would say we treat this tree as an undirected graph and maintain a visited[] array to deal with cycles. Luckily, it\\'s connected."
                    },
                    {
                        "username": "garv_luthra_19",
                        "content": "getting TLE at test cast 59 but leetcode not showing the wrong testcase. The test case is not showing any value of  n. Please cross check my code what Im missing\\n\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(map<int , list<int>>& graph , map<int,map<char,int>>& dp ,  string& s , vector<bool>& visited ,  int ptr  ){\\n        visited[ptr] = true;\\n\\n        for(auto& i : graph[ptr]){\\n            if(!visited[i]){\\n                dfs(graph, dp, s, visited , i);\\n                for(auto& j : dp[i]){\\n                    dp[ptr][j.first] += j.second;\\n                }\\n            }\\n                \\n        }\\n\\n        dp[ptr][s[ptr]]++;\\n\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        map<int , list<int>> graph;\\n\\n        if(n == 1)\\n            return {1};\\n        \\n        for(auto& i : edges){\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n        }\\n        map<int , map<char,int>> dp;\\n\\n        vector<bool> visited(n , false);\\n\\n        dfs(graph, dp , labels , visited, 0);\\n\\n       \\n\\n        vector<int> ans(n);\\n\\n        for(int i = 0 ; i < n ; i++){\\n           ans[i] = dp[i][labels[i]]; \\n        //    cout << ans[i] << \" \"; \\n        }\\n\\n     return ans;\\n\\n        \\n\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "Quickly looking at the code I\\'m guessing that it is the overhead added by the maps (since they are red black trees and random access is logN). So I would guess your algorithm is NlogN \\n\\nI got a TLE because I was passing one of the vector parameters as value instead of reference in the recursion with each call and that was expensive enough to matter. "
                    },
                    {
                        "username": "MaNan-3",
                        "content": "Getting TLE at 58/59 :(\nApplying DFS with backtracking. What should I do?"
                    },
                    {
                        "username": "enrique11",
                        "content": "No need to check all previously visited nodes at every node. At least was the issue for me."
                    },
                    {
                        "username": "enrique11",
                        "content": "Oh come on testcase 59..."
                    },
                    {
                        "username": "quan_mai",
                        "content": "When the explanation of examples are too long, you know you failed on the description section."
                    },
                    {
                        "username": "rnascunha",
                        "content": "testcase 22: 4 | [[0,2],[0,3],[1,2]] | \"aeed\"\\n\\nAs others have already mentioned, isn\\'t this wrong? This doesn\\'t form a undirect tree... \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "sepac",
                        "content": "Yes it does. It\\'s an undirected graph, so 0 is the root, the next level is 2 and 3, and the next level is 1."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to the one on **day 11**"
                    },
                    {
                        "username": "the_deadly",
                        "content": "Can some help me to find out where I am doing it wrong? I am getting TLE for this code.\\n\\nclass Solution {\\npublic:\\n    vector<int> dfs(int node, int par, vector<int> adj[], string labels, vector<int> &ans){\\n        vector<int> labelsCount(26,0);\\n        labelsCount[labels[node]-\\'a\\']++;\\n        for(auto& child : adj[node]){\\n            if(child == par) continue;\\n            vector<int> childCounts = dfs(child,node,adj,labels,ans);\\n            for(int i = 0;i<26;i++){\\n                //cntOfLabels[node][i] += cntOfLabels[child][i];\\n                labelsCount[i] += childCounts[i];\\n            }\\n        }\\n        ans[node] = labelsCount[labels[node]-\\'a\\'];\\n        //cntOfLabels[node][labels[node]-\\'a\\'] += 1;\\n        return labelsCount;\\n    }\\n\\n    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {\\n        //vector<vector<int> > cntOfLabels(n, vector<int> (26,0));\\n        vector<int> adj[n];\\n        //vector<int> vis(n);\\n        for(auto& edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> ans(n);\\n        dfs(0,-1,adj,labels,ans);\\n\\n        // vector<int> ans(n);\\n        // for(int i = 0;i<n;i++){\\n        //     ans[i] = cntOfLabels[i][labels[i]-\\'a\\'];\\n        // }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "olchik",
                        "content": "You might want to send labels as `string&` to dfs"
                    }
                ]
            }
        ]
    }
]