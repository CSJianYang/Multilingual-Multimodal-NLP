[
    {
        "title": "Check Knight Tour Configuration",
        "question_content": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.\n&nbsp;\nExample 1:\n\nInput: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.\n\nExample 2:\n\nInput: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move.\n\n&nbsp;\nConstraints:\n\n\tn == grid.length == grid[i].length\n\t3 <= n <= 7\n\t0 <= grid[row][col] < n * n\n\tAll integers in grid are unique.",
        "solutions": [
            {
                "id": 3314019,
                "title": "collect-coordinates",
                "content": "We can do brute-force by checking all possible moves from the current point, but we will need to do 8 checks for every cell. Imagine if we have to deal with Queen instead of Knight.\\n    \\nFirst, we record coordinates for each step.\\n    \\nThen, we go step-by-step and check if coordinate change represents a valid move.\\n    \\n> Beware of a silly edge case when the knight does not start at the top-left cell.\\n\\n**C++**\\n```cpp    \\nbool checkValidGrid(vector<vector<int>>& g) {\\n    if (g[0][0] != 0) // this is silly ;p\\n        return false;\\n    array<int, 2> m[7 * 7] = {};\\n    for (int x = 0; x < g.size(); ++x)\\n        for (int y = 0; y < g.size(); ++y)\\n            m[g[x][y]] = {x, y};\\n    for (int i = 1; i < g.size() * g.size(); ++i)\\n        if (abs((m[i][0] - m[i - 1][0]) * (m[i][1] - m[i - 1][1])) != 2)\\n            return false;\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp    \\nbool checkValidGrid(vector<vector<int>>& g) {\\n    if (g[0][0] != 0) // this is silly ;p\\n        return false;\\n    array<int, 2> m[7 * 7] = {};\\n    for (int x = 0; x < g.size(); ++x)\\n        for (int y = 0; y < g.size(); ++y)\\n            m[g[x][y]] = {x, y};\\n    for (int i = 1; i < g.size() * g.size(); ++i)\\n        if (abs((m[i][0] - m[i - 1][0]) * (m[i][1] - m[i - 1][1])) != 2)\\n            return false;\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3314113,
                "title": "bruteforce-very-simple-easy-to-understand-solution",
                "content": "# Approach\\nDefine a possible direction array and keep on checking each possible cell to see if we can move or not.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int dir[8][2] = {{1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}};\\n        int count = 0, maxCount = grid.size() * grid.size()-1;\\n        int x = 0, y = 0, i, j;\\n        if(grid[x][y] != count) return false;\\n        while(count < maxCount){\\n            count++;\\n            int flag = 1;\\n            for(auto d: dir){\\n                i = x + d[0]; j = y + d[1];\\n                if(i >= 0 && j >= 0  && i < grid.size() && j < grid.size() && grid[i][j] == count){ //cout<<i<< \" \"<<j <<\" \"<<count<<endl;\\n                    x = i; y = j; flag = 0; break;\\n                    \\n                }\\n            } \\n            if(flag) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int dir[8][2] = {{1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}};\\n        int count = 0, maxCount = grid.size() * grid.size()-1;\\n        int x = 0, y = 0, i, j;\\n        if(grid[x][y] != count) return false;\\n        while(count < maxCount){\\n            count++;\\n            int flag = 1;\\n            for(auto d: dir){\\n                i = x + d[0]; j = y + d[1];\\n                if(i >= 0 && j >= 0  && i < grid.size() && j < grid.size() && grid[i][j] == count){ //cout<<i<< \" \"<<j <<\" \"<<count<<endl;\\n                    x = i; y = j; flag = 0; break;\\n                    \\n                }\\n            } \\n            if(flag) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3314147,
                "title": "clean-short-recursion-java",
                "content": "```java []\\nclass Solution {\\n    boolean dest = false;\\n    public boolean checkValidGrid(int[][] grid) {\\n        check(grid, 0, 0, -1);\\n        return dest;\\n    }\\n    void check(int[][] grid, int i, int j, int prev){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid.length || grid[i][j] != prev+1)   return;\\n        if(grid[i][j] == grid.length*grid.length-1) dest = true;\\n        check(grid,i+2,j+1,grid[i][j]);\\n        check(grid,i+2,j-1,grid[i][j]);\\n        check(grid,i+1,j+2,grid[i][j]);\\n        check(grid,i+1,j-2,grid[i][j]);\\n        check(grid,i-2,j+1,grid[i][j]);\\n        check(grid,i-2,j-1,grid[i][j]);\\n        check(grid,i-1,j+2,grid[i][j]);\\n        check(grid,i-1,j-2,grid[i][j]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    boolean dest = false;\\n    public boolean checkValidGrid(int[][] grid) {\\n        check(grid, 0, 0, -1);\\n        return dest;\\n    }\\n    void check(int[][] grid, int i, int j, int prev){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid.length || grid[i][j] != prev+1)   return;\\n        if(grid[i][j] == grid.length*grid.length-1) dest = true;\\n        check(grid,i+2,j+1,grid[i][j]);\\n        check(grid,i+2,j-1,grid[i][j]);\\n        check(grid,i+1,j+2,grid[i][j]);\\n        check(grid,i+1,j-2,grid[i][j]);\\n        check(grid,i-2,j+1,grid[i][j]);\\n        check(grid,i-2,j-1,grid[i][j]);\\n        check(grid,i-1,j+2,grid[i][j]);\\n        check(grid,i-1,j-2,grid[i][j]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314200,
                "title": "easy-peasy-knight-tour",
                "content": "Follow the pattern in the grid \\ni. first the knight is on the 0 th number in grid[0][0].\\nii. then it\\'ll try to reach 1(grid[2][1] in the below image), 2... so on using all 8 moves of 2 vertical or horizontal and 1 horizontal or vertical moves.\\niii. return true if it can reach n * n-1 number(or visit all cells).\\n![image](https://assets.leetcode.com/users/images/1283b5b9-49e8-4a34-80e7-f39876c4eaba_1679200999.7088232.png)\\n\\n```\\nclass Solution {\\n\\t// all the directions using the combo of dirx and diry\\n    int[] dirx = {1,2,-1,-2,1,2,-1,-2};\\n    int[] diry = {2,1,2,1,-2,-1,-2,-1};\\n    \\n    private boolean solve(int i, int j, int n, int move, int[][] grid){\\n        if(i < 0 || j < 0 || i >= n || j >= n || move != grid[i][j]){\\n            return false;\\n        }\\n        \\n        if(move == n*n-1)\\n            return true;\\n        \\n        for(int k = 0; k < 8; k++){\\n            int ni = i+dirx[k];\\n            int nj = j+diry[k];\\n            if(solve(ni, nj, n, move+1, grid))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean checkValidGrid(int[][] grid) {\\n        int n = grid.length;\\n        return solve(0, 0, n, 0, grid);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\t// all the directions using the combo of dirx and diry\\n    int[] dirx = {1,2,-1,-2,1,2,-1,-2};\\n    int[] diry = {2,1,2,1,-2,-1,-2,-1};\\n    \\n    private boolean solve(int i, int j, int n, int move, int[][] grid){\\n        if(i < 0 || j < 0 || i >= n || j >= n || move != grid[i][j]){\\n            return false;\\n        }\\n        \\n        if(move == n*n-1)\\n            return true;\\n        \\n        for(int k = 0; k < 8; k++){\\n            int ni = i+dirx[k];\\n            int nj = j+diry[k];\\n            if(solve(ni, nj, n, move+1, grid))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean checkValidGrid(int[][] grid) {\\n        int n = grid.length;\\n        return solve(0, 0, n, 0, grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314612,
                "title": "easy-recursion-cpp-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    bool solve(vector<vector<int>>& grid, int i, int j, int& n, int t)\\n    {\\n        if(i < 0 || i >= n || j < 0 || j >= n) return false;\\n        if(grid[i][j] != t) return false;\\n        if(grid[i][j] == n*n-1 && t == n*n-1) return true;\\n        return solve(grid, i+2, j+1, n, t+1) || solve(grid, i+2, j-1, n, t+1) ||\\n                solve(grid, i-2, j+1, n, t+1) || solve(grid, i-2, j-1, n, t+1) ||\\n                solve(grid, i+1, j+2, n, t+1) || solve(grid, i+1, j-2, n, t+1) ||\\n                solve(grid, i-1, j+2, n, t+1) || solve(grid, i-1, j-2, n, t+1);\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        return solve(grid, 0, 0, n, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool solve(vector<vector<int>>& grid, int i, int j, int& n, int t)\\n    {\\n        if(i < 0 || i >= n || j < 0 || j >= n) return false;\\n        if(grid[i][j] != t) return false;\\n        if(grid[i][j] == n*n-1 && t == n*n-1) return true;\\n        return solve(grid, i+2, j+1, n, t+1) || solve(grid, i+2, j-1, n, t+1) ||\\n                solve(grid, i-2, j+1, n, t+1) || solve(grid, i-2, j-1, n, t+1) ||\\n                solve(grid, i+1, j+2, n, t+1) || solve(grid, i+1, j-2, n, t+1) ||\\n                solve(grid, i-1, j+2, n, t+1) || solve(grid, i-1, j-2, n, t+1);\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        return solve(grid, 0, 0, n, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314063,
                "title": "c-solution-simple-to-understand-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int counter = 0;\\n    void dfs(int i, int j, int n, vector<vector<int>>& grid, int parent) {\\n        if(i < 0 || i >= n || j < 0 || j >= n || grid[i][j] != parent+1) return;\\n        \\n        int parentValue = grid[i][j];\\n        grid[i][j] = 0;\\n        counter++;\\n        dfs(i-2, j+1, n, grid, parentValue);\\n        dfs(i-1, j+2, n, grid, parentValue);\\n        dfs(i+1, j+2, n, grid, parentValue);\\n        dfs(i+2, j+1, n, grid, parentValue);\\n        dfs(i+2, j-1, n, grid, parentValue);\\n        dfs(i+1, j-2, n, grid, parentValue);\\n        dfs(i-1, j-2, n, grid, parentValue);\\n        dfs(i-2, j-1, n, grid, parentValue);\\n         \\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        dfs(0, 0, n, grid, -1);\\n        return counter == n*n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int counter = 0;\\n    void dfs(int i, int j, int n, vector<vector<int>>& grid, int parent) {\\n        if(i < 0 || i >= n || j < 0 || j >= n || grid[i][j] != parent+1) return;\\n        \\n        int parentValue = grid[i][j];\\n        grid[i][j] = 0;\\n        counter++;\\n        dfs(i-2, j+1, n, grid, parentValue);\\n        dfs(i-1, j+2, n, grid, parentValue);\\n        dfs(i+1, j+2, n, grid, parentValue);\\n        dfs(i+2, j+1, n, grid, parentValue);\\n        dfs(i+2, j-1, n, grid, parentValue);\\n        dfs(i+1, j-2, n, grid, parentValue);\\n        dfs(i-1, j-2, n, grid, parentValue);\\n        dfs(i-2, j-1, n, grid, parentValue);\\n         \\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        dfs(0, 0, n, grid, -1);\\n        return counter == n*n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315611,
                "title": "easy-brute-force-approach",
                "content": "# Intuition\\nChecking all the possible condition or movements one by one using else if conditions.\\n\\n# Approach\\nBrute Force. C++.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int r=0,c=0;\\n        for(int i=0;i<n*n;i++)\\n        {\\n            if( r+2<n && c+1<n && grid[r+2][c+1]==i+1)\\n            {\\n                r=r+2;\\n                c=c+1;   \\n            }\\n            else if(r+2<n && c-1>=0 && grid[r+2][c-1]==i+1)\\n            {\\n                c=c-1;\\n                r=r+2;\\n            }\\n            else if(r+1<n && c+2<n && grid[r+1][c+2]==i+1)\\n            {\\n                r=r+1;\\n                c=c+2;\\n            }\\n            else if(r+1<n && c-2>=0 && grid[r+1][c-2]==i+1)\\n            {\\n                r=r+1;\\n                c=c-2;\\n            }\\n            else if(r-1>=0 && c-2>=0 && grid[r-1][c-2]==i+1)\\n            {\\n                r=r-1;\\n                c=c-2;\\n                \\n            }\\n            else if(r-2>=0 && c+1<n && grid[r-2][c+1]==i+1)\\n            {\\n                c=c+1;\\n                r=r-2;\\n            }\\n            else if(r-2>=0 && c-1>=0 && grid[r-2][c-1]==i+1)\\n            {\\n                r=r-2;\\n                c=c-1;\\n            }\\n            else if(r-1>=0 && c+2<n && grid[r-1][c+2]==i+1 )\\n            {\\n                r=r-1;\\n                c=c+2;\\n            }\\n            else if(i==(n*n-1))\\n            {\\n                break;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int r=0,c=0;\\n        for(int i=0;i<n*n;i++)\\n        {\\n            if( r+2<n && c+1<n && grid[r+2][c+1]==i+1)\\n            {\\n                r=r+2;\\n                c=c+1;   \\n            }\\n            else if(r+2<n && c-1>=0 && grid[r+2][c-1]==i+1)\\n            {\\n                c=c-1;\\n                r=r+2;\\n            }\\n            else if(r+1<n && c+2<n && grid[r+1][c+2]==i+1)\\n            {\\n                r=r+1;\\n                c=c+2;\\n            }\\n            else if(r+1<n && c-2>=0 && grid[r+1][c-2]==i+1)\\n            {\\n                r=r+1;\\n                c=c-2;\\n            }\\n            else if(r-1>=0 && c-2>=0 && grid[r-1][c-2]==i+1)\\n            {\\n                r=r-1;\\n                c=c-2;\\n                \\n            }\\n            else if(r-2>=0 && c+1<n && grid[r-2][c+1]==i+1)\\n            {\\n                c=c+1;\\n                r=r-2;\\n            }\\n            else if(r-2>=0 && c-1>=0 && grid[r-2][c-1]==i+1)\\n            {\\n                r=r-2;\\n                c=c-1;\\n            }\\n            else if(r-1>=0 && c+2<n && grid[r-1][c+2]==i+1 )\\n            {\\n                r=r-1;\\n                c=c+2;\\n            }\\n            else if(i==(n*n-1))\\n            {\\n                break;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314254,
                "title": "bfs-detailed-explaination-easy",
                "content": "# Please upvote this post if it helped you.\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n## How to check if a grid is valid for a knight\\'s tour problem\\n\\nHello, fellow coders! In this post, I will explain how to write a function that checks if a given grid is valid for a knight\\'s tour problem. A knight\\'s tour problem is a classic puzzle where you have to move a knight on an n x n chessboard such that it visits every square exactly once. The knight can only move in L-shaped patterns, as shown below:\\n\\n![knight moves](https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Knight%27s_tour_anim_2.gif/220px-Knight%27s_tour_anim_2.gif)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\nThe function we will write is called `checkValidGrid` and it takes one parameter: `grid`, which is a vector of vectors of integers. The grid represents the chessboard where each square has a number from 0 to n^2 - 1 indicating the order in which the knight visited that square. For example, this is a valid grid for n = 5:\\n\\n```\\n0 59 38 33 30\\n37 34 31 60 9\\n32 49 36 29 44\\n35 48 41 10 43\\n50 45 28 39 42\\n```\\n\\nThe function returns true if the grid is valid and false otherwise. Here is how the function works:\\n\\n- First, we get the size of the grid by calling `grid.size()`. We store this value in an integer variable called `n`.\\n- Next, we create a vector of pairs of integers called `dir` that stores all the possible directions that the knight can move in. Each pair represents an offset in x and y coordinates. For example, (-2,-1) means moving two squares up and one square left.\\n- Then, we create another vector of vectors of booleans called `vis` that keeps track of which squares have been visited by the knight. We initialize this vector with false values for all squares.\\n- We also create two integer variables called `x` and `y` that store the current position of the knight on the grid. We initialize them with zero, meaning that we start from the top-left corner.\\n- Now, we enter a for loop that iterates from zero to n^2 -1 times. This loop represents each step of the knight\\'s tour.\\n- Inside the loop, we first check if the value at `grid[x][y]` matches with our loop counter `i`. If not, then we return false because it means that either there is a duplicate or missing number on the grid or that the order of visiting does not match with our expectation.\\n- Next, we mark the current square as visited by setting `vis[x][y]` to true.\\n- Then, we loop through all possible directions stored in `dir` and try to find the next square to move to. For each direction pair `(dx, dy)`, we calculate new coordinates `(X,Y)` by adding them to our current coordinates `(x,y)`. We also check if these new coordinates are within bounds and not already visited and if they have value equal to i+1 on the grid. If all these conditions are met, then we update our current coordinates `(x,y)` with `(X,Y)`.\\n- After exiting from both loops, we return true because it means that we have successfully completed a valid knight\\'s tour.\\n\\nThat\\'s it! That\\'s how you can write a simple function to check if a given grid is valid for a knight\\'s tour problem. I hope you enjoyed this post and learned something new. Happy coding!\\n\\n\\n# Complexity\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        vector<pair<int, int>> dir = {{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};\\n        vector<vector<bool>> vis(n,vector<bool>(n,false));\\n        int x = 0;\\n        int y = 0;\\n        \\n        for(int i = 0; i<n*n; i++){\\n            if(grid[x][y] != i)\\n                return false;\\n            vis[x][y] = true;\\n            for(auto [dx, dy] : dir){\\n                int X = x+dx;\\n                int Y = y+dy;\\n                if(X >=0 && X < n && Y >= 0 && Y < n && !vis[X][Y] && grid[X][Y] == i+1){\\n                    x = X;\\n                    y = Y;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n0 59 38 33 30\\n37 34 31 60 9\\n32 49 36 29 44\\n35 48 41 10 43\\n50 45 28 39 42\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        vector<pair<int, int>> dir = {{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};\\n        vector<vector<bool>> vis(n,vector<bool>(n,false));\\n        int x = 0;\\n        int y = 0;\\n        \\n        for(int i = 0; i<n*n; i++){\\n            if(grid[x][y] != i)\\n                return false;\\n            vis[x][y] = true;\\n            for(auto [dx, dy] : dir){\\n                int X = x+dx;\\n                int Y = y+dy;\\n                if(X >=0 && X < n && Y >= 0 && Y < n && !vis[X][Y] && grid[X][Y] == i+1){\\n                    x = X;\\n                    y = Y;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314068,
                "title": "simple-traversal-easy-to-understand-no-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(int n, int i, int j)\\n    {\\n        if (i < 0 || j < 0 || i >= n || j >= n) return false;\\n        return true;\\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid)\\n    {\\n        int n = grid.size();\\n        int currRow = 0, currCol = 0;\\n        \\n        int currStepIdx = 0;\\n        vector<int>rows = {-2, -2, +2, +2, -1, +1, -1, +1};\\n        vector<int>cols = {-1, +1, -1, +1, -2, -2, +2, +2};\\n        while(currStepIdx < ((n * n) - 1))\\n        {\\n            bool found = false;\\n            //=============================================================================\\n            for (int dirIdx = 0; dirIdx < 8; dirIdx++)\\n            {\\n                int newRow = currRow + rows[dirIdx];\\n                int newCol = currCol + cols[dirIdx];\\n\\n                if (isValid(n, newRow, newCol) && grid[newRow][newCol] == currStepIdx + 1) \\n                {\\n                    currStepIdx++;\\n                    currRow = newRow;\\n                    currCol = newCol;\\n                    found = true; break;\\n                }\\n            }\\n            //=================================================================================\\n            if (!found) return false;\\n        }\\n        return true;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int n, int i, int j)\\n    {\\n        if (i < 0 || j < 0 || i >= n || j >= n) return false;\\n        return true;\\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid)\\n    {\\n        int n = grid.size();\\n        int currRow = 0, currCol = 0;\\n        \\n        int currStepIdx = 0;\\n        vector<int>rows = {-2, -2, +2, +2, -1, +1, -1, +1};\\n        vector<int>cols = {-1, +1, -1, +1, -2, -2, +2, +2};\\n        while(currStepIdx < ((n * n) - 1))\\n        {\\n            bool found = false;\\n            //=============================================================================\\n            for (int dirIdx = 0; dirIdx < 8; dirIdx++)\\n            {\\n                int newRow = currRow + rows[dirIdx];\\n                int newCol = currCol + cols[dirIdx];\\n\\n                if (isValid(n, newRow, newCol) && grid[newRow][newCol] == currStepIdx + 1) \\n                {\\n                    currStepIdx++;\\n                    currRow = newRow;\\n                    currCol = newCol;\\n                    found = true; break;\\n                }\\n            }\\n            //=================================================================================\\n            if (!found) return false;\\n        }\\n        return true;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387788,
                "title": "pure-dfs",
                "content": "# Java\\n```\\n\\nprivate final int[][] directions = new int[][]{{1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};\\n\\n  public boolean checkValidGrid(int[][] grid) {\\n    int start = 0, finish = grid.length * grid[0].length - 1;\\n    return dfs(grid, 0, 0, start - 1, finish);\\n  }\\n\\n  private boolean dfs(int[][] grid, int row, int column, int previous, int finish) {\\n    boolean outside = row < 0 || row >= grid.length || column < 0 || column >= grid[0].length;\\n    if (outside || previous + 1 != grid[row][column])\\n      return false;\\n\\n    if (grid[row][column] == finish)\\n      return true;\\n\\n    for (int[] direction : directions) {\\n      if (dfs(grid, row + direction[0], column + direction[1], grid[row][column], finish))\\n        return true;\\n    }\\n    return false;\\n  }\\n```\\n\\n# C++\\n```\\n\\nprivate: vector<vector<int>> directions = {{1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};\\n    \\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int start = 0, finish = grid.size() * grid[0].size() - 1;\\n        return dfs(grid, 0, 0, start - 1, finish);\\n    }\\n    \\nprivate:\\n    bool dfs(vector<vector<int>>& grid, int row, int column, int previous, int finish) {\\n        bool outside = row < 0 || row >= grid.size() || column < 0 || column >= grid[0].size();\\n        if (outside || previous + 1 != grid[row][column])\\n            return false;\\n        \\n        if (grid[row][column] == finish)\\n            return true;\\n\\n        for (auto &direction: directions) {\\n            if (dfs(grid, row + direction[0], column + direction[1], grid[row][column], finish))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\n\\nprivate final int[][] directions = new int[][]{{1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};\\n\\n  public boolean checkValidGrid(int[][] grid) {\\n    int start = 0, finish = grid.length * grid[0].length - 1;\\n    return dfs(grid, 0, 0, start - 1, finish);\\n  }\\n\\n  private boolean dfs(int[][] grid, int row, int column, int previous, int finish) {\\n    boolean outside = row < 0 || row >= grid.length || column < 0 || column >= grid[0].length;\\n    if (outside || previous + 1 != grid[row][column])\\n      return false;\\n\\n    if (grid[row][column] == finish)\\n      return true;\\n\\n    for (int[] direction : directions) {\\n      if (dfs(grid, row + direction[0], column + direction[1], grid[row][column], finish))\\n        return true;\\n    }\\n    return false;\\n  }\\n```\n```\\n\\nprivate: vector<vector<int>> directions = {{1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};\\n    \\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int start = 0, finish = grid.size() * grid[0].size() - 1;\\n        return dfs(grid, 0, 0, start - 1, finish);\\n    }\\n    \\nprivate:\\n    bool dfs(vector<vector<int>>& grid, int row, int column, int previous, int finish) {\\n        bool outside = row < 0 || row >= grid.size() || column < 0 || column >= grid[0].size();\\n        if (outside || previous + 1 != grid[row][column])\\n            return false;\\n        \\n        if (grid[row][column] == finish)\\n            return true;\\n\\n        for (auto &direction: directions) {\\n            if (dfs(grid, row + direction[0], column + direction[1], grid[row][column], finish))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3318060,
                "title": "python-3-12-lines-iteration-and-dict-t-m-100-89",
                "content": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n\\n        n, d = len(grid), defaultdict(tuple)\\n        if n < 5: return n == 1\\n\\n        notLegal = lambda x, y : {abs(x[0]-y[0]),\\n                                  abs(x[1]-y[1])} != {1,2}\\n\\n        for row, col in product(range(n),range(n)):\\n            d[grid[row][col]] = (row,col)\\n        \\n        prev, cnt = (0,0), 1\\n\\n        while cnt < n*n:\\n            curr = d[cnt]\\n\\n            if notLegal(prev,curr):  return False\\n\\n            cnt+=1\\n            prev = curr\\n\\n        return True\\n```\\n[https://leetcode.com/problems/check-knight-tour-configuration/submissions/1006491076/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*^2).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n\\n        n, d = len(grid), defaultdict(tuple)\\n        if n < 5: return n == 1\\n\\n        notLegal = lambda x, y : {abs(x[0]-y[0]),\\n                                  abs(x[1]-y[1])} != {1,2}\\n\\n        for row, col in product(range(n),range(n)):\\n            d[grid[row][col]] = (row,col)\\n        \\n        prev, cnt = (0,0), 1\\n\\n        while cnt < n*n:\\n            curr = d[cnt]\\n\\n            if notLegal(prev,curr):  return False\\n\\n            cnt+=1\\n            prev = curr\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316745,
                "title": "dfs-c-solution-with-detailed-explanation",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\nSo, basically this question can be solved using both BFS and DFS. I have solved this using DFS/recursion.\\nFirstly, I have declared a visited vector with all indices marked 0. As given in question we will start it right from top-left corner of grid that is (0, 0). So, for 1st recursion call the i & j are 0. Declared c to keep the count of steps. In the reursion function first marked the vis[i][j]=1 and incremented the value of c. Now, we have 8 ways in which the knight can move, so declared two arrays dr and dc with all 8 conditions/ways in which a knight can move. After that checked for the validity of indices and comapared the value of grid and c. If value of grid and c is equal and that indices are not visited then again a recursion call is made.\\nIn this way this will mark all the visited indices as 1 and if the grid is not valid it won\\'t. So in main function traveresed through the grid and if any 0 is found return false, else true.\\nThank You and hope u understand my solution. Open for quries.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    void rec(int i, int j, int n, int m, vector<vector<int>>&grid, vector<vector<int>>&vis, int c){\\n        vis[i][j]=1;\\n        c++;\\n        \\n        int dr[8]={2, 2,-2, -2,-1, 1, -1, 1};\\n        int dc[8]={1, -1, 1, -1, 2, -2, -2, 2};\\n        \\n        for(int l=0; l<8; l++){\\n            int nr= i+ dr[l];\\n            int nc=j+ dc[l];\\n            if(nr>=0 && nr<n && nc>=0 && nc<m && grid[nr][nc]==c && vis[nr][nc]!=1){\\n                rec(nr, nc, n, m, grid, vis, c);\\n            }\\n        }\\n    }\\n    \\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int c=0;\\n        vector<vector<int>>vis(n, vector<int>(m, 0));\\n        rec(0, 0, n, m, grid, vis, c);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(vis[i][j]==0){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void rec(int i, int j, int n, int m, vector<vector<int>>&grid, vector<vector<int>>&vis, int c){\\n        vis[i][j]=1;\\n        c++;\\n        \\n        int dr[8]={2, 2,-2, -2,-1, 1, -1, 1};\\n        int dc[8]={1, -1, 1, -1, 2, -2, -2, 2};\\n        \\n        for(int l=0; l<8; l++){\\n            int nr= i+ dr[l];\\n            int nc=j+ dc[l];\\n            if(nr>=0 && nr<n && nc>=0 && nc<m && grid[nr][nc]==c && vis[nr][nc]!=1){\\n                rec(nr, nc, n, m, grid, vis, c);\\n            }\\n        }\\n    }\\n    \\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int c=0;\\n        vector<vector<int>>vis(n, vector<int>(m, 0));\\n        rec(0, 0, n, m, grid, vis, c);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(vis[i][j]==0){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315504,
                "title": "python-easy-dfs-using-set",
                "content": "\\n\\t\\tdef checkValidGrid(self, grid: List[List[int]]) -> bool:\\n\\t\\t\\tn = len(grid)\\n\\t\\t\\tdirns = [(-2,-1),(-1,-2),(1,-2),(2,-1),(2,1),(1,2),(-1,2),(-2,1)]\\n\\t\\t\\tvisited = set()\\n\\t\\t\\tdef dfs(r,c,move):\\n\\t\\t\\t\\tif r<0 or r>=n or c<0 or c>=n or (r,c) in visited or grid[r][c] != move:\\n\\t\\t\\t\\t\\treturn \\n\\t\\t\\t\\tvisited.add((r,c))\\n\\t\\t\\t\\tfor dr,dc in dirns:\\n\\t\\t\\t\\t\\tnewR,newC = r+dr,c+dc                \\n\\t\\t\\t\\t\\tdfs(newR,newC,move+1)\\n\\n\\t\\t\\tdfs(0,0,0)\\n\\t\\t\\treturn len(visited) == n*n",
                "solutionTags": [],
                "code": "\\n\\t\\tdef checkValidGrid(self, grid: List[List[int]]) -> bool:\\n\\t\\t\\tn = len(grid)\\n\\t\\t\\tdirns = [(-2,-1),(-1,-2),(1,-2),(2,-1),(2,1),(1,2),(-1,2),(-2,1)]\\n\\t\\t\\tvisited = set()\\n\\t\\t\\tdef dfs(r,c,move):\\n\\t\\t\\t\\tif r<0 or r>=n or c<0 or c>=n or (r,c) in visited or grid[r][c] != move:\\n\\t\\t\\t\\t\\treturn \\n\\t\\t\\t\\tvisited.add((r,c))\\n\\t\\t\\t\\tfor dr,dc in dirns:\\n\\t\\t\\t\\t\\tnewR,newC = r+dr,c+dc                \\n\\t\\t\\t\\t\\tdfs(newR,newC,move+1)\\n\\n\\t\\t\\tdfs(0,0,0)\\n\\t\\t\\treturn len(visited) == n*n",
                "codeTag": "Python3"
            },
            {
                "id": 3315040,
                "title": "simple-o-n-n-solution-without-any-bfs-or-dfs",
                "content": "\\n**Approach :**  First store the number of moves in which knight visits each of the cells.Then start from the cell (0,0) and check whether it is possible to go the next cell which knight visited from the current cell.If it is a valid move then check for other cells until we reach the end or we find a invalid move.\\n\\n**Time Complexity:** O(N^2)\\n\\n**Space Complexity:** O(N^2)\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        map<int,pair<int,int>> m;\\n        int n = grid.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                m[grid[i][j]] = {i,j};\\n            }\\n        }\\n        int i=1;\\n        int x = 0,y=0;\\n        while(i<n*n)\\n        {\\n           int x1 = m[i].first;\\n            int y1 = m[i].second;\\n            if(abs(x-x1)==2)\\n            {\\n                if(abs(y-y1)!=1)\\n                    return false;\\n                x = x1;\\n                y=y1;\\n            }\\n            else if(abs(y-y1)==2)\\n            {\\n                if(abs(x-x1)!=1)\\n                    return false;\\n                x = x1;\\n                y=y1;\\n            }\\n            else\\n                return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        map<int,pair<int,int>> m;\\n        int n = grid.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                m[grid[i][j]] = {i,j};\\n            }\\n        }\\n        int i=1;\\n        int x = 0,y=0;\\n        while(i<n*n)\\n        {\\n           int x1 = m[i].first;\\n            int y1 = m[i].second;\\n            if(abs(x-x1)==2)\\n            {\\n                if(abs(y-y1)!=1)\\n                    return false;\\n                x = x1;\\n                y=y1;\\n            }\\n            else if(abs(y-y1)==2)\\n            {\\n                if(abs(x-x1)!=1)\\n                    return false;\\n                x = x1;\\n                y=y1;\\n            }\\n            else\\n                return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314297,
                "title": "simple-traversal-and-easy-to-understand",
                "content": "# Intuition\\nGiven the grid matrix just traverse it. If the next position is a valid position of Knight, move forward. Else return false.\\nSince it is given in question that 0 <= grid[i][j] <=n*n-1, we can use it as an iterator to traverse the grid, until itr==n * n.\\n\\nYOU JUST HAVE TO TAKE CARE OF ALL 8 POSSIBLE MOVES OF KNIGHT FROM A GIVEN POINT.\\n\\nWe can also use the direction array:\\nint xMove[8] = { 2, 1, -1, -2, -2, -1, 1, 2 };\\nint yMove[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    \\n    bool validMove(int r, int c, int nr, int nc)\\n    {\\n        if((r+2)==nr && (c+1)==nc)return true;\\n        if((r+2)==nr && (c-1)==nc) return true;\\n        if((r+1)==nr && (c+2)==nc)  return true;\\n        if((r-1)==nr && (c+2)==nc) return true;\\n        if((r-2)==nr && (c+1)==nc)return true;\\n        if((r-2)==nr && (c-1)==nc) return true;\\n        if((r+1)==nr && (c-2)==nc)  return true;\\n        if((r-1)==nr && (c-2)==nc) return true;\\n        return false;\\n    }\\n    \\n    \\n    bool checkValidGrid(vector<vector<int>>& grid)\\n    {\\n        if(grid[0][0]!=0)return false;\\n        map<int, pair<int,int>> mp;\\n        int n = grid.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                mp[grid[i][j]] = {i, j};\\n            }\\n        }\\n        int m = 1;\\n        int l = n*n;\\n        int r = 0, c = 0;\\n        while(m<l)\\n        {\\n            int nr = mp[m].first, nc = mp[m].second;\\n            r = mp[m-1].first, c = mp[m-1].second;\\n            if(validMove(r, c, nr, nc))\\n            {\\n                m++;\\n            }else return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    \\n    boolean validMove(int r, int c, int nr, int nc) {\\n        if ((r + 2) == nr && (c + 1) == nc) return true;\\n        if ((r + 2) == nr && (c - 1) == nc) return true;\\n        if ((r + 1) == nr && (c + 2) == nc) return true;\\n        if ((r - 1) == nr && (c + 2) == nc) return true;\\n        if ((r - 2) == nr && (c + 1) == nc) return true;\\n        if ((r - 2) == nr && (c - 1) == nc) return true;\\n        if ((r + 1) == nr && (c - 2) == nc) return true;\\n        if ((r - 1) == nr && (c - 2) == nc) return true;\\n        return false;\\n    }\\n    \\n    boolean checkValidGrid(int[][] grid) {\\n        if (grid[0][0] != 0) return false;\\n        Map<Integer, int[]> mp = new HashMap<>();\\n        int n = grid.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                mp.put(grid[i][j], new int[] {i, j});\\n            }\\n        }\\n        int m = 1;\\n        int l = n * n;\\n        int r = 0, c = 0;\\n        while (m < l) {\\n            int[] next = mp.get(m);\\n            int nr = next[0], nc = next[1];\\n            int[] curr = mp.get(m - 1);\\n            r = curr[0];\\n            c = curr[1];\\n            if (validMove(r, c, nr, nc)) {\\n                m++;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n``` python3 []\\nclass Solution:\\n    \\n    def validMove(self, r, c, nr, nc):\\n        if (r + 2 == nr and c + 1 == nc) or \\\\\\n           (r + 2 == nr and c - 1 == nc) or \\\\\\n           (r + 1 == nr and c + 2 == nc) or \\\\\\n           (r - 1 == nr and c + 2 == nc) or \\\\\\n           (r - 2 == nr and c + 1 == nc) or \\\\\\n           (r - 2 == nr and c - 1 == nc) or \\\\\\n           (r + 1 == nr and c - 2 == nc) or \\\\\\n           (r - 1 == nr and c - 2 == nc):\\n            return True\\n        return False\\n    \\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        if grid[0][0] != 0:\\n            return False\\n        mp = {}\\n        n = len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                mp[grid[i][j]] = (i, j)\\n        m = 1\\n        l = n * n\\n        r = c = 0\\n        while m < l:\\n            nr, nc = mp[m]\\n            r, c = mp[m - 1]\\n            if self.validMove(r, c, nr, nc):\\n                m += 1\\n            else:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    \\n    bool validMove(int r, int c, int nr, int nc)\\n    {\\n        if((r+2)==nr && (c+1)==nc)return true;\\n        if((r+2)==nr && (c-1)==nc) return true;\\n        if((r+1)==nr && (c+2)==nc)  return true;\\n        if((r-1)==nr && (c+2)==nc) return true;\\n        if((r-2)==nr && (c+1)==nc)return true;\\n        if((r-2)==nr && (c-1)==nc) return true;\\n        if((r+1)==nr && (c-2)==nc)  return true;\\n        if((r-1)==nr && (c-2)==nc) return true;\\n        return false;\\n    }\\n    \\n    \\n    bool checkValidGrid(vector<vector<int>>& grid)\\n    {\\n        if(grid[0][0]!=0)return false;\\n        map<int, pair<int,int>> mp;\\n        int n = grid.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                mp[grid[i][j]] = {i, j};\\n            }\\n        }\\n        int m = 1;\\n        int l = n*n;\\n        int r = 0, c = 0;\\n        while(m<l)\\n        {\\n            int nr = mp[m].first, nc = mp[m].second;\\n            r = mp[m-1].first, c = mp[m-1].second;\\n            if(validMove(r, c, nr, nc))\\n            {\\n                m++;\\n            }else return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    \\n    boolean validMove(int r, int c, int nr, int nc) {\\n        if ((r + 2) == nr && (c + 1) == nc) return true;\\n        if ((r + 2) == nr && (c - 1) == nc) return true;\\n        if ((r + 1) == nr && (c + 2) == nc) return true;\\n        if ((r - 1) == nr && (c + 2) == nc) return true;\\n        if ((r - 2) == nr && (c + 1) == nc) return true;\\n        if ((r - 2) == nr && (c - 1) == nc) return true;\\n        if ((r + 1) == nr && (c - 2) == nc) return true;\\n        if ((r - 1) == nr && (c - 2) == nc) return true;\\n        return false;\\n    }\\n    \\n    boolean checkValidGrid(int[][] grid) {\\n        if (grid[0][0] != 0) return false;\\n        Map<Integer, int[]> mp = new HashMap<>();\\n        int n = grid.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                mp.put(grid[i][j], new int[] {i, j});\\n            }\\n        }\\n        int m = 1;\\n        int l = n * n;\\n        int r = 0, c = 0;\\n        while (m < l) {\\n            int[] next = mp.get(m);\\n            int nr = next[0], nc = next[1];\\n            int[] curr = mp.get(m - 1);\\n            r = curr[0];\\n            c = curr[1];\\n            if (validMove(r, c, nr, nc)) {\\n                m++;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n``` python3 []\\nclass Solution:\\n    \\n    def validMove(self, r, c, nr, nc):\\n        if (r + 2 == nr and c + 1 == nc) or \\\\\\n           (r + 2 == nr and c - 1 == nc) or \\\\\\n           (r + 1 == nr and c + 2 == nc) or \\\\\\n           (r - 1 == nr and c + 2 == nc) or \\\\\\n           (r - 2 == nr and c + 1 == nc) or \\\\\\n           (r - 2 == nr and c - 1 == nc) or \\\\\\n           (r + 1 == nr and c - 2 == nc) or \\\\\\n           (r - 1 == nr and c - 2 == nc):\\n            return True\\n        return False\\n    \\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        if grid[0][0] != 0:\\n            return False\\n        mp = {}\\n        n = len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                mp[grid[i][j]] = (i, j)\\n        m = 1\\n        l = n * n\\n        r = c = 0\\n        while m < l:\\n            nr, nc = mp[m]\\n            r, c = mp[m - 1]\\n            if self.validMove(r, c, nr, nc):\\n                m += 1\\n            else:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314083,
                "title": "python-3-bfs-iterative",
                "content": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        \\n        q = deque( [(0, 0)] )\\n        res = 0\\n        \\n        while q:\\n            res += 1\\n            x, y = q.popleft()\\n\\n            for i, j in [ (x + 1, y + 2), (x + 1, y - 2), (x - 1, y + 2), (x - 1, y - 2), (x + 2, y + 1), (x + 2, y - 1), (x - 2, y + 1), (x - 2, y - 1) ]:\\n                if 0 <= i < n and 0 <= j < n and grid[i][j] == grid[x][y] + 1:\\n                    q.append( (i, j) )\\n\\n        return res == pow(n, 2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        \\n        q = deque( [(0, 0)] )\\n        res = 0\\n        \\n        while q:\\n            res += 1\\n            x, y = q.popleft()\\n\\n            for i, j in [ (x + 1, y + 2), (x + 1, y - 2), (x - 1, y + 2), (x - 1, y - 2), (x + 2, y + 1), (x + 2, y - 1), (x - 2, y + 1), (x - 2, y - 1) ]:\\n                if 0 <= i < n and 0 <= j < n and grid[i][j] == grid[x][y] + 1:\\n                    q.append( (i, j) )\\n\\n        return res == pow(n, 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810599,
                "title": "c-easy-short-and-simple",
                "content": "# Intuition\\nJust check a path from 0 to n*n-1 exits, with condition move how knight moves.\\n\\n# Approach\\nFor valid configuration:\\n- top left cell (0,0) should have value 0. If not return false.\\n- start from curr=0, (i,j)=(0,0), check for all 8 possible knight move, if in the board and grid contains curr+1 (i.e., 1), set curr=1, (i,j)=(new postion) and repeat till curr = n*n; else return false;\\n- return true (means all visited from 0 to n*n-1)\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool chk(int i, int j, int n) {\\n        if (min(i,j)<0 || max(i,j)>=n) return false;\\n        return true; \\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int curr = 1, n = grid.size(),i=0,j=0;\\n        // if (0 not at top left (0,0))\\n        if (grid[i][j]) return false;\\n        int di[] = {-2,-2,-1,-1,1,1,2,2};\\n        int dj[] = {-1,1,-2,2,-2,2,-1,1};\\n        while (curr!= n*n) {\\n            bool currAns = false;\\n            for (int k=0;k<8;k++) {\\n                if (chk(i+di[k], j+dj[k], n)) {\\n                    if (grid[i+di[k]][j+dj[k]]==curr) {\\n                        i += di[k];\\n                        j += dj[k];\\n                        currAns = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!currAns) return false;\\n            curr++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool chk(int i, int j, int n) {\\n        if (min(i,j)<0 || max(i,j)>=n) return false;\\n        return true; \\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int curr = 1, n = grid.size(),i=0,j=0;\\n        // if (0 not at top left (0,0))\\n        if (grid[i][j]) return false;\\n        int di[] = {-2,-2,-1,-1,1,1,2,2};\\n        int dj[] = {-1,1,-2,2,-2,2,-1,1};\\n        while (curr!= n*n) {\\n            bool currAns = false;\\n            for (int k=0;k<8;k++) {\\n                if (chk(i+di[k], j+dj[k], n)) {\\n                    if (grid[i+di[k]][j+dj[k]]==curr) {\\n                        i += di[k];\\n                        j += dj[k];\\n                        currAns = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!currAns) return false;\\n            curr++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503308,
                "title": "c-easy-to-understand-brute-force",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int i,int j,int k,int &m,int &n,vector<vector<int>> &g){\\n        if(i<0||j<0||i>=m||j>=n||g[i][j] != k)return false;\\n        if(k==m*n-1)return true;\\n        return solve(i+2,j-1,k+1,m,n,g)||solve(i+2,j+1,k+1,m,n,g)||solve(i-2,j-1,k+1,m,n,g)||solve(i-2,j+1,k+1,m,n,g)||solve(i-1,j-2,k+1,m,n,g)||solve(i-1,j+2,k+1,m,n,g)||solve(i+1,j+2,k+1,m,n,g)||solve(i+1,j-2,k+1,m,n,g);\\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int x = 0,m=grid.size(),n=grid[0].size();\\n        return solve(0,0,0,m,n,grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int i,int j,int k,int &m,int &n,vector<vector<int>> &g){\\n        if(i<0||j<0||i>=m||j>=n||g[i][j] != k)return false;\\n        if(k==m*n-1)return true;\\n        return solve(i+2,j-1,k+1,m,n,g)||solve(i+2,j+1,k+1,m,n,g)||solve(i-2,j-1,k+1,m,n,g)||solve(i-2,j+1,k+1,m,n,g)||solve(i-1,j-2,k+1,m,n,g)||solve(i-1,j+2,k+1,m,n,g)||solve(i+1,j+2,k+1,m,n,g)||solve(i+1,j-2,k+1,m,n,g);\\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int x = 0,m=grid.size(),n=grid[0].size();\\n        return solve(0,0,0,m,n,grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315360,
                "title": "c-c-c-python-rust-go-ruby-java-kotlin-scala-js-ts-dart-and-php-solution-recursive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a very easy graph path finding problem, all you need to do is treat the matrix like a graph, where each node is connected to eight nodes, the position of nodes in the matrix is 2 forward/backward and one over(Knight movement pattern), making an \\'L\\' shape. Once you realise this, you can calculate the next possible nodes easily by adding or subtracting 2 or 1 to the x and y indicies on the board, quite easily. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use recursive DFS to traverse and check wether we can find a possible way to traverse the matrix such that the value of node is the step, on which knight lands on the tile.\\n\\nTo do so, you can very easily, just keep the track of the step you\\'re on, and try and equate it to the value of tile, if it matches then the tile you\\'re on is the next tile in path , otherwise it isn\\'t. If it is then you can repeat the same process for it\\'s neighbors and check if any of the neighbors can form a next tile, till you reach the last tile, where the expected value will be r*c - 1. If some tile exists such that none of the neighbor tiles(in the graph representation) can be next tile, we return false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$, where $$N$$ is the number of tiles in the matrix, or, \\n$$O(R\\xD7C)$$, where $$R$$ is  the number of rows in the matrix and $$C$$ is the number of columns\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$, where $$N$$ is the number of tiles in the matrix, or, \\n$$O(R\\xD7C)$$, where $$R$$ is  the number of rows in the matrix and $$C$$ is the number of columns,\\nor, if you ignore the recursive stack $$O(1)$$\\n\\n\\n# Code\\n```C [C]\\nconst size_t VALID_MOVES[8][2] = {\\n        {-1, -2},                   {1, -2},\\n    {-2, -1},                           {2, -1},\\n    \\n    {-2, 1},                            {2, 1},\\n        {-1, 2},                    {1, 2}\\n};\\nconst size_t MOVE_COUNT = 8;\\n\\nbool is_valid(\\n    const int** grid, \\n    const size_t x,\\n    const size_t row_count,\\n    const size_t y,\\n    const size_t col_count,\\n    const int expected_pos\\n) {\\n    if(x >= row_count || y >= col_count || grid[x][y] != expected_pos) {\\n        return false;\\n    }\\n\\n    if(expected_pos == row_count * col_count - 1) {\\n        return true;\\n    }\\n\\n    for(size_t i = 0; i < MOVE_COUNT; ++i) {\\n        if(is_valid(grid, x + VALID_MOVES[i][0], row_count, y + VALID_MOVES[i][1], col_count, expected_pos + 1)) {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n}\\nbool checkValidGrid(\\n    const int** grid, \\n    const size_t row_count, \\n    const int* col_counts\\n) {\\n    bool ret_val = is_valid(grid, 0, row_count, 0, col_counts[0], 0);\\n\\n    for(size_t i = 0; i < row_count; ++i) {\\n        free(grid[i]);\\n    }\\n    free(grid);\\n    free(col_counts);\\n\\n    return ret_val;\\n}\\n```\\n```C++ [C]\\nstatic const vector<pair<size_t, size_t>> VALID_MOVES = {\\n        {-1, -2},                   {1, -2},\\n    {-2, -1},                           {2, -1},\\n    \\n    {-2, 1},                            {2, 1},\\n        {-1, 2},                    {1, 2}\\n};\\nclass Solution {\\nprivate:\\n\\n    static bool is_valid(\\n        const vector<vector<int>> &grid, \\n        const size_t x, \\n        const size_t y, \\n        const int expected_pos\\n    ) {\\n        if(x >= grid.size() || y >= grid[0].size() || grid[x][y] != expected_pos) {\\n            return false;\\n        }\\n\\n        if(expected_pos == grid.size() * grid[0].size() - 1) {\\n            return true;\\n        }\\n\\n        for(const pair<size_t, size_t> &deltas: VALID_MOVES) {\\n            if(is_valid(grid, x + deltas.first, y + deltas.second, expected_pos + 1)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(const vector<vector<int>> &grid) {\\n        return is_valid(grid, 0, 0, 0);\\n    }\\n};\\n```\\n```C# [C]\\npublic class Solution {\\n    private static readonly int[,] VALID_MOVES = {\\n            {-1, -2},                   {1, -2},\\n        {-2, -1},                           {2, -1},\\n\\n        {-2, 1},                            {2, 1},\\n            {-1, 2},                    {1, 2}\\n    };\\n    private static readonly int MOVE_COUNT = 8;\\n\\n    private static bool IsValid(int[][] grid, int x, int y, int expectedPos) {\\n        if(x >= grid.Length || x < 0 || y >= grid[0].Length || y < 0 || grid[x][y] != expectedPos) {\\n            return false;\\n        }\\n\\n        if(expectedPos == grid.Length * grid[0].Length - 1) {\\n            return true;\\n        }\\n\\n        for(int i = 0; i < MOVE_COUNT; ++i) {\\n            if(Solution.IsValid(grid, x + VALID_MOVES[i, 0], y + VALID_MOVES[i, 1], expectedPos + 1)) { \\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    public bool CheckValidGrid(int[][] grid) {\\n        return Solution.IsValid(grid, 0, 0, 0);\\n    }\\n}\\n```\\n```Python [Py]\\n_VALID_MOVES = [\\n        (-1, -2),                     (1, -2),\\n    (-2, -1),                             (2, -1),\\n    \\n    (-2, 1),                                (2, 1),\\n        (-1, 2),                        (1, 2)\\n]\\n\\nclass Solution(object):\\n    def is_valid(self, grid, x, y, expected_pos):\\n        if x >= len(grid) or y >= len(grid[0]) or x < 0 or y < 0 or grid[x][y] != expected_pos:\\n            return False\\n        \\n        if expected_pos == len(grid) * len(grid[0]) - 1:\\n            return True\\n        \\n        return any(self.is_valid(grid, x + dx, y + dy, expected_pos + 1) for dx, dy in _VALID_MOVES)\\n    \\n    def checkValidGrid(self, grid):\\n        return self.is_valid(grid, 0, 0, 0)\\n```\\n```Python3 [Py]\\n_VALID_MOVES: List[Tuple[int, int]] = [\\n        (-1, -2),                     (1, -2),\\n    (-2, -1),                             (2, -1),\\n    \\n    (-2, 1),                                (2, 1),\\n        (-1, 2),                        (1, 2)\\n]\\n\\nclass Solution:    \\n    def is_valid(self, grid: List[List[int]], x: int, y: int, expected_pos: int) -> bool:\\n        if x >= len(grid) or y >= len(grid[0]) or x < 0 or y < 0 or grid[x][y] != expected_pos:\\n            return False\\n        \\n        if expected_pos == len(grid) * len(grid[0]) - 1:\\n            return True\\n        \\n        return any(self.is_valid(grid, x + dx, y + dy, expected_pos + 1) for dx, dy in _VALID_MOVES)\\n\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        return self.is_valid(grid, 0, 0, 0)\\n```\\n```Rust [Rust]\\n//usize::MAX == -1 or one back\\n//usize::MAX - 1 == -2 or two back\\n\\nconst VALID_MOVES: [(usize, usize); 8] = [\\n        (usize::MAX, usize::MAX - 1),                     (1, usize::MAX - 1),\\n    (usize::MAX - 1, usize::MAX),                             (2, usize::MAX),\\n    \\n    (usize::MAX - 1, 1),                                      (2, 1),\\n        (usize::MAX, 2),                                   (1, 2)\\n];\\n\\nimpl Solution {\\n    pub fn is_valid(grid: &[Vec<i32>], x: usize, y: usize, expected_pos: i32) -> bool {\\n        if x >= grid.len() || y >= grid[0].len() || grid[x][y] != expected_pos {\\n            return false;\\n        }\\n        \\n        if expected_pos as usize == grid.len() * grid[0].len() - 1 {\\n            return true;\\n        }\\n        \\n        VALID_MOVES\\n            .iter()\\n            .any(|&(dx, dy)| Self::is_valid(grid, x + dx, y + dy, expected_pos + 1))\\n    }\\n    pub fn check_valid_grid(grid: Vec<Vec<i32>>) -> bool {\\n        Self::is_valid(&grid, 0, 0, 0)\\n    }\\n}\\n```\\n```Go [Go]\\n//const arrays are not a thing in Go, otherwise would\\'ve used them :(\\nvar VALID_MOVES [8][2]int = [8][2]int{\\n        {-1, -2},                   {1, -2},\\n    {-2, -1},                           {2, -1},\\n    \\n    {-2, 1},                            {2, 1},\\n        {-1, 2},                    {1, 2},\\n}\\n\\nfunc isValid(grid [][]int, x int, y int, expectedPos int) bool {\\n    if x >= len(grid) || y >= len(grid) || x < 0 || y < 0 || grid[x][y] != expectedPos {\\n        return false\\n    }\\n\\n    if expectedPos == len(grid) * len(grid[0]) - 1 {\\n        return true\\n    }\\n\\n    for _, delta := range VALID_MOVES {\\n        if isValid(grid, x + delta[0], y + delta[1], expectedPos + 1) {\\n            return true\\n        }\\n    }\\n\\n    return false\\n}\\n\\nfunc checkValidGrid(grid [][]int) bool {\\n    return isValid(grid, 0, 0, 0)\\n}\\n```\\n```Ruby [Ruby]\\nVALID_MOVES = [\\n        [-1, -2],                     [1, -2],\\n    [-2, -1],                             [2, -1],\\n    \\n    [-2, 1],                                [2, 1],\\n        [-1, 2],                        [1, 2]\\n]\\n\\n# @param {Integer[][]} grid\\n# @return {Boolean}\\ndef check_valid_grid(grid)\\n   return is_valid(grid, 0, 0, 0) \\nend\\n\\ndef is_valid(grid, x, y, expectedPos)\\n    if x >= grid.length || y >= grid[0].length || x < 0 || y < 0 || grid[x][y] != expectedPos \\n        return false\\n    end\\n\\n    if expectedPos == grid.length * grid[0].length - 1\\n        return true\\n    end\\n\\n    return VALID_MOVES\\n            .map {|delta| is_valid(grid, x + delta[0], y + delta[1], expectedPos + 1)}.any?\\n\\nend\\n```\\n```Java [Java]\\nclass Solution {\\n    private static final int[][] VALID_MOVES = {\\n            {-1, -2},                   {1, -2},\\n        {-2, -1},                           {2, -1},\\n        \\n        {-2, 1},                            {2, 1},\\n            {-1, 2},                    {1, 2}\\n    };\\n\\n    private static boolean isValid(\\n        final int[][] grid, \\n        final int x, \\n        final int y, \\n        final int expectedPos\\n    ) {\\n        if(x >= grid.length || x < 0 || y >= grid[0].length || y < 0 || grid[x][y] != expectedPos) {\\n            return false;\\n        }\\n\\n        if(expectedPos == grid.length * grid[0].length - 1) {\\n            return true;\\n        }\\n\\n        return Arrays\\n                .stream(VALID_MOVES)\\n                .anyMatch(deltas -> Solution.isValid(grid, x + deltas[0], y + deltas[1], expectedPos + 1));\\n    }\\n\\n    public static boolean checkValidGrid(final int[][] grid) {\\n        return Solution.isValid(grid, 0, 0, 0);\\n    }\\n}\\n```\\n```Kotlin [Java]\\nclass Solution {\\n    private val VALID_MOVES: Array<IntArray> = arrayOf(\\n            intArrayOf(-1, -2),                 intArrayOf(1, -2),\\n        intArrayOf(-2, -1),                           intArrayOf(2, -1),\\n        \\n        intArrayOf(-2, 1),                            intArrayOf(2, 1),\\n            intArrayOf(-1, 2),                    intArrayOf(1, 2)\\n    );\\n    private fun isValid(grid: Array<IntArray>, x: Int, y: Int, expectedPos: Int): Boolean {\\n        if (x >= grid.size || y >= grid[0].size || x < 0 || y < 0 || grid[x][y] != expectedPos) {\\n            return false;\\n        }\\n\\n        if (expectedPos == grid.size * grid[0].size - 1) {\\n            return true;\\n        }\\n\\n        return VALID_MOVES.filter {delta -> this.isValid(grid, x + delta[0], y + delta[1], expectedPos + 1)}.any();\\n    }\\n    public fun checkValidGrid(grid: Array<IntArray>): Boolean {\\n        return this.isValid(grid, 0, 0, 0);\\n    }\\n}\\n```\\n```Scala [Java]\\nobject Solution {\\n    private final val VALID_MOVES: Seq[Seq[Int]] = Seq(\\n            Seq(-1, -2),                 Seq(1, -2),\\n        Seq(-2, -1),                           Seq(2, -1),\\n        \\n        Seq(-2, 1),                            Seq(2, 1),\\n            Seq(-1, 2),                    Seq(1, 2)\\n    );\\n    def isValid(\\n        grid: Array[Array[Int]], \\n        x: Int, y: Int, \\n        expectedPos: Int\\n    ): Boolean = {\\n        if (x >= grid.length || y >= grid(0).length || x < 0 || y < 0 || grid(x)(y) != expectedPos) {\\n            return false;\\n        }\\n\\n        if (expectedPos == grid.length * grid(0).length - 1) {\\n            return true;\\n        }\\n\\n        VALID_MOVES.exists(delta => isValid(grid, x + delta(0), y + delta(1), expectedPos + 1));\\n\\n    }\\n    def checkValidGrid(grid: Array[Array[Int]]): Boolean = {\\n        return isValid(grid, 0, 0, 0);\\n    }\\n}\\n```\\n```JS [JS]\\nconst VALID_MOVES = [\\n        [-1, -2],                     [1, -2],\\n    [-2, -1],                             [2, -1],\\n    \\n    [-2, 1],                                [2, 1],\\n        [-1, 2],                        [1, 2]\\n]\\nconst isValid = (grid, x, y, expectedPos) => {\\n    if (x >= grid.length || y >= grid[0].length || x < 0 || y < 0 || grid[x][y] !== expectedPos) {\\n        return false;\\n    }\\n\\n    if(expectedPos == grid.length * grid[0].length - 1) {\\n        return true;\\n    }\\n\\n    return VALID_MOVES.some(delta => isValid(grid, x + delta[0], y + delta[1], expectedPos + 1));\\n}\\n\\nconst checkValidGrid = grid => isValid(grid, 0, 0, 0)\\n```\\n```TS [JS]\\nconst VALID_MOVES: readonly number[][] = [\\n        [-1, -2],                     [1, -2],\\n    [-2, -1],                             [2, -1],\\n    \\n    [-2, 1],                                [2, 1],\\n        [-1, 2],                        [1, 2]\\n]\\nconst isValid = (\\n    grid: readonly number[][], \\n    x: number, \\n    y: number, \\n    expectedPos: number\\n) => {\\n    if (x >= grid.length || y >= grid[0].length || x < 0 || y < 0 || grid[x][y] !== expectedPos) {\\n        return false;\\n    }\\n\\n    if(expectedPos == grid.length * grid[0].length - 1) {\\n        return true;\\n    }\\n\\n    return VALID_MOVES.some(delta => isValid(grid, x + delta[0], y + delta[1], expectedPos + 1));\\n}\\n\\nconst checkValidGrid = (grid : readonly number[][]) => isValid(grid, 0, 0, 0)\\n```\\n```Dart [JS]\\nclass Solution {\\n    static const List<List<int>> VALID_MOVES = [\\n            [-1, -2],                     [1, -2],\\n        [-2, -1],                             [2, -1],\\n        \\n        [-2, 1],                                [2, 1],\\n            [-1, 2],                        [1, 2]\\n    ];\\n    static bool isValid(\\n        final List<List<int>> grid, \\n        final int x, final int y, \\n        final int expectedPos\\n    ) {\\n        if(x >= grid.length || y >= grid[0].length || x < 0 || y < 0 || grid[x][y] != expectedPos) {\\n            return false;\\n        }\\n\\n        if(expectedPos == grid.length * grid[0].length - 1) {\\n            return true;\\n        }\\n\\n        return VALID_MOVES\\n                .any((delta) => Solution.isValid(grid, x + delta[0], y + delta[1], expectedPos + 1));\\n    }\\n    bool checkValidGrid(final List<List<int>> grid) {\\n        return Solution.isValid(grid, 0, 0, 0);\\n    }\\n}\\n```\\n```PHP [PHP]\\nclass Solution {\\n    const VALID_MOVES = [\\n            [-1, -2],                   [1, -2],\\n        [-2, -1],                           [2, -1],\\n        \\n        [-2, 1],                            [2, 1],\\n            [-1, 2],                    [1, 2]\\n    ];\\n    function isValid($grid, $x, $y, $expectedPos) {\\n        if($x >= count($grid) || $y >= count($grid[0]) || $x < 0 || $y < 0 || $grid[$x][$y] != $expectedPos) {\\n            return false;\\n        }\\n\\n        if($expectedPos == count($grid) * count($grid[0]) - 1) {\\n            return true;\\n        }\\n\\n        foreach(self::VALID_MOVES as $delta) {\\n            if($this->isValid($grid, $x + $delta[0], $y + $delta[1], $expectedPos + 1)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n    function checkValidGrid($grid) {\\n        return $this->isValid($grid, 0, 0, 0);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "Rust"
                ],
                "code": "```C [C]\\nconst size_t VALID_MOVES[8][2] = {\\n        {-1, -2},                   {1, -2},\\n    {-2, -1},                           {2, -1},\\n    \\n    {-2, 1},                            {2, 1},\\n        {-1, 2},                    {1, 2}\\n};\\nconst size_t MOVE_COUNT = 8;\\n\\nbool is_valid(\\n    const int** grid, \\n    const size_t x,\\n    const size_t row_count,\\n    const size_t y,\\n    const size_t col_count,\\n    const int expected_pos\\n) {\\n    if(x >= row_count || y >= col_count || grid[x][y] != expected_pos) {\\n        return false;\\n    }\\n\\n    if(expected_pos == row_count * col_count - 1) {\\n        return true;\\n    }\\n\\n    for(size_t i = 0; i < MOVE_COUNT; ++i) {\\n        if(is_valid(grid, x + VALID_MOVES[i][0], row_count, y + VALID_MOVES[i][1], col_count, expected_pos + 1)) {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n}\\nbool checkValidGrid(\\n    const int** grid, \\n    const size_t row_count, \\n    const int* col_counts\\n) {\\n    bool ret_val = is_valid(grid, 0, row_count, 0, col_counts[0], 0);\\n\\n    for(size_t i = 0; i < row_count; ++i) {\\n        free(grid[i]);\\n    }\\n    free(grid);\\n    free(col_counts);\\n\\n    return ret_val;\\n}\\n```\n```C++ [C]\\nstatic const vector<pair<size_t, size_t>> VALID_MOVES = {\\n        {-1, -2},                   {1, -2},\\n    {-2, -1},                           {2, -1},\\n    \\n    {-2, 1},                            {2, 1},\\n        {-1, 2},                    {1, 2}\\n};\\nclass Solution {\\nprivate:\\n\\n    static bool is_valid(\\n        const vector<vector<int>> &grid, \\n        const size_t x, \\n        const size_t y, \\n        const int expected_pos\\n    ) {\\n        if(x >= grid.size() || y >= grid[0].size() || grid[x][y] != expected_pos) {\\n            return false;\\n        }\\n\\n        if(expected_pos == grid.size() * grid[0].size() - 1) {\\n            return true;\\n        }\\n\\n        for(const pair<size_t, size_t> &deltas: VALID_MOVES) {\\n            if(is_valid(grid, x + deltas.first, y + deltas.second, expected_pos + 1)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(const vector<vector<int>> &grid) {\\n        return is_valid(grid, 0, 0, 0);\\n    }\\n};\\n```\n```C# [C]\\npublic class Solution {\\n    private static readonly int[,] VALID_MOVES = {\\n            {-1, -2},                   {1, -2},\\n        {-2, -1},                           {2, -1},\\n\\n        {-2, 1},                            {2, 1},\\n            {-1, 2},                    {1, 2}\\n    };\\n    private static readonly int MOVE_COUNT = 8;\\n\\n    private static bool IsValid(int[][] grid, int x, int y, int expectedPos) {\\n        if(x >= grid.Length || x < 0 || y >= grid[0].Length || y < 0 || grid[x][y] != expectedPos) {\\n            return false;\\n        }\\n\\n        if(expectedPos == grid.Length * grid[0].Length - 1) {\\n            return true;\\n        }\\n\\n        for(int i = 0; i < MOVE_COUNT; ++i) {\\n            if(Solution.IsValid(grid, x + VALID_MOVES[i, 0], y + VALID_MOVES[i, 1], expectedPos + 1)) { \\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    public bool CheckValidGrid(int[][] grid) {\\n        return Solution.IsValid(grid, 0, 0, 0);\\n    }\\n}\\n```\n```Python [Py]\\n_VALID_MOVES = [\\n        (-1, -2),                     (1, -2),\\n    (-2, -1),                             (2, -1),\\n    \\n    (-2, 1),                                (2, 1),\\n        (-1, 2),                        (1, 2)\\n]\\n\\nclass Solution(object):\\n    def is_valid(self, grid, x, y, expected_pos):\\n        if x >= len(grid) or y >= len(grid[0]) or x < 0 or y < 0 or grid[x][y] != expected_pos:\\n            return False\\n        \\n        if expected_pos == len(grid) * len(grid[0]) - 1:\\n            return True\\n        \\n        return any(self.is_valid(grid, x + dx, y + dy, expected_pos + 1) for dx, dy in _VALID_MOVES)\\n    \\n    def checkValidGrid(self, grid):\\n        return self.is_valid(grid, 0, 0, 0)\\n```\n```Python3 [Py]\\n_VALID_MOVES: List[Tuple[int, int]] = [\\n        (-1, -2),                     (1, -2),\\n    (-2, -1),                             (2, -1),\\n    \\n    (-2, 1),                                (2, 1),\\n        (-1, 2),                        (1, 2)\\n]\\n\\nclass Solution:    \\n    def is_valid(self, grid: List[List[int]], x: int, y: int, expected_pos: int) -> bool:\\n        if x >= len(grid) or y >= len(grid[0]) or x < 0 or y < 0 or grid[x][y] != expected_pos:\\n            return False\\n        \\n        if expected_pos == len(grid) * len(grid[0]) - 1:\\n            return True\\n        \\n        return any(self.is_valid(grid, x + dx, y + dy, expected_pos + 1) for dx, dy in _VALID_MOVES)\\n\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        return self.is_valid(grid, 0, 0, 0)\\n```\n```Rust [Rust]\\n//usize::MAX == -1 or one back\\n//usize::MAX - 1 == -2 or two back\\n\\nconst VALID_MOVES: [(usize, usize); 8] = [\\n        (usize::MAX, usize::MAX - 1),                     (1, usize::MAX - 1),\\n    (usize::MAX - 1, usize::MAX),                             (2, usize::MAX),\\n    \\n    (usize::MAX - 1, 1),                                      (2, 1),\\n        (usize::MAX, 2),                                   (1, 2)\\n];\\n\\nimpl Solution {\\n    pub fn is_valid(grid: &[Vec<i32>], x: usize, y: usize, expected_pos: i32) -> bool {\\n        if x >= grid.len() || y >= grid[0].len() || grid[x][y] != expected_pos {\\n            return false;\\n        }\\n        \\n        if expected_pos as usize == grid.len() * grid[0].len() - 1 {\\n            return true;\\n        }\\n        \\n        VALID_MOVES\\n            .iter()\\n            .any(|&(dx, dy)| Self::is_valid(grid, x + dx, y + dy, expected_pos + 1))\\n    }\\n    pub fn check_valid_grid(grid: Vec<Vec<i32>>) -> bool {\\n        Self::is_valid(&grid, 0, 0, 0)\\n    }\\n}\\n```\n```Go [Go]\\n//const arrays are not a thing in Go, otherwise would\\'ve used them :(\\nvar VALID_MOVES [8][2]int = [8][2]int{\\n        {-1, -2},                   {1, -2},\\n    {-2, -1},                           {2, -1},\\n    \\n    {-2, 1},                            {2, 1},\\n        {-1, 2},                    {1, 2},\\n}\\n\\nfunc isValid(grid [][]int, x int, y int, expectedPos int) bool {\\n    if x >= len(grid) || y >= len(grid) || x < 0 || y < 0 || grid[x][y] != expectedPos {\\n        return false\\n    }\\n\\n    if expectedPos == len(grid) * len(grid[0]) - 1 {\\n        return true\\n    }\\n\\n    for _, delta := range VALID_MOVES {\\n        if isValid(grid, x + delta[0], y + delta[1], expectedPos + 1) {\\n            return true\\n        }\\n    }\\n\\n    return false\\n}\\n\\nfunc checkValidGrid(grid [][]int) bool {\\n    return isValid(grid, 0, 0, 0)\\n}\\n```\n```Ruby [Ruby]\\nVALID_MOVES = [\\n        [-1, -2],                     [1, -2],\\n    [-2, -1],                             [2, -1],\\n    \\n    [-2, 1],                                [2, 1],\\n        [-1, 2],                        [1, 2]\\n]\\n\\n# @param {Integer[][]} grid\\n# @return {Boolean}\\ndef check_valid_grid(grid)\\n   return is_valid(grid, 0, 0, 0) \\nend\\n\\ndef is_valid(grid, x, y, expectedPos)\\n    if x >= grid.length || y >= grid[0].length || x < 0 || y < 0 || grid[x][y] != expectedPos \\n        return false\\n    end\\n\\n    if expectedPos == grid.length * grid[0].length - 1\\n        return true\\n    end\\n\\n    return VALID_MOVES\\n            .map {|delta| is_valid(grid, x + delta[0], y + delta[1], expectedPos + 1)}.any?\\n\\nend\\n```\n```Java [Java]\\nclass Solution {\\n    private static final int[][] VALID_MOVES = {\\n            {-1, -2},                   {1, -2},\\n        {-2, -1},                           {2, -1},\\n        \\n        {-2, 1},                            {2, 1},\\n            {-1, 2},                    {1, 2}\\n    };\\n\\n    private static boolean isValid(\\n        final int[][] grid, \\n        final int x, \\n        final int y, \\n        final int expectedPos\\n    ) {\\n        if(x >= grid.length || x < 0 || y >= grid[0].length || y < 0 || grid[x][y] != expectedPos) {\\n            return false;\\n        }\\n\\n        if(expectedPos == grid.length * grid[0].length - 1) {\\n            return true;\\n        }\\n\\n        return Arrays\\n                .stream(VALID_MOVES)\\n                .anyMatch(deltas -> Solution.isValid(grid, x + deltas[0], y + deltas[1], expectedPos + 1));\\n    }\\n\\n    public static boolean checkValidGrid(final int[][] grid) {\\n        return Solution.isValid(grid, 0, 0, 0);\\n    }\\n}\\n```\n```Kotlin [Java]\\nclass Solution {\\n    private val VALID_MOVES: Array<IntArray> = arrayOf(\\n            intArrayOf(-1, -2),                 intArrayOf(1, -2),\\n        intArrayOf(-2, -1),                           intArrayOf(2, -1),\\n        \\n        intArrayOf(-2, 1),                            intArrayOf(2, 1),\\n            intArrayOf(-1, 2),                    intArrayOf(1, 2)\\n    );\\n    private fun isValid(grid: Array<IntArray>, x: Int, y: Int, expectedPos: Int): Boolean {\\n        if (x >= grid.size || y >= grid[0].size || x < 0 || y < 0 || grid[x][y] != expectedPos) {\\n            return false;\\n        }\\n\\n        if (expectedPos == grid.size * grid[0].size - 1) {\\n            return true;\\n        }\\n\\n        return VALID_MOVES.filter {delta -> this.isValid(grid, x + delta[0], y + delta[1], expectedPos + 1)}.any();\\n    }\\n    public fun checkValidGrid(grid: Array<IntArray>): Boolean {\\n        return this.isValid(grid, 0, 0, 0);\\n    }\\n}\\n```\n```Scala [Java]\\nobject Solution {\\n    private final val VALID_MOVES: Seq[Seq[Int]] = Seq(\\n            Seq(-1, -2),                 Seq(1, -2),\\n        Seq(-2, -1),                           Seq(2, -1),\\n        \\n        Seq(-2, 1),                            Seq(2, 1),\\n            Seq(-1, 2),                    Seq(1, 2)\\n    );\\n    def isValid(\\n        grid: Array[Array[Int]], \\n        x: Int, y: Int, \\n        expectedPos: Int\\n    ): Boolean = {\\n        if (x >= grid.length || y >= grid(0).length || x < 0 || y < 0 || grid(x)(y) != expectedPos) {\\n            return false;\\n        }\\n\\n        if (expectedPos == grid.length * grid(0).length - 1) {\\n            return true;\\n        }\\n\\n        VALID_MOVES.exists(delta => isValid(grid, x + delta(0), y + delta(1), expectedPos + 1));\\n\\n    }\\n    def checkValidGrid(grid: Array[Array[Int]]): Boolean = {\\n        return isValid(grid, 0, 0, 0);\\n    }\\n}\\n```\n```JS [JS]\\nconst VALID_MOVES = [\\n        [-1, -2],                     [1, -2],\\n    [-2, -1],                             [2, -1],\\n    \\n    [-2, 1],                                [2, 1],\\n        [-1, 2],                        [1, 2]\\n]\\nconst isValid = (grid, x, y, expectedPos) => {\\n    if (x >= grid.length || y >= grid[0].length || x < 0 || y < 0 || grid[x][y] !== expectedPos) {\\n        return false;\\n    }\\n\\n    if(expectedPos == grid.length * grid[0].length - 1) {\\n        return true;\\n    }\\n\\n    return VALID_MOVES.some(delta => isValid(grid, x + delta[0], y + delta[1], expectedPos + 1));\\n}\\n\\nconst checkValidGrid = grid => isValid(grid, 0, 0, 0)\\n```\n```TS [JS]\\nconst VALID_MOVES: readonly number[][] = [\\n        [-1, -2],                     [1, -2],\\n    [-2, -1],                             [2, -1],\\n    \\n    [-2, 1],                                [2, 1],\\n        [-1, 2],                        [1, 2]\\n]\\nconst isValid = (\\n    grid: readonly number[][], \\n    x: number, \\n    y: number, \\n    expectedPos: number\\n) => {\\n    if (x >= grid.length || y >= grid[0].length || x < 0 || y < 0 || grid[x][y] !== expectedPos) {\\n        return false;\\n    }\\n\\n    if(expectedPos == grid.length * grid[0].length - 1) {\\n        return true;\\n    }\\n\\n    return VALID_MOVES.some(delta => isValid(grid, x + delta[0], y + delta[1], expectedPos + 1));\\n}\\n\\nconst checkValidGrid = (grid : readonly number[][]) => isValid(grid, 0, 0, 0)\\n```\n```Dart [JS]\\nclass Solution {\\n    static const List<List<int>> VALID_MOVES = [\\n            [-1, -2],                     [1, -2],\\n        [-2, -1],                             [2, -1],\\n        \\n        [-2, 1],                                [2, 1],\\n            [-1, 2],                        [1, 2]\\n    ];\\n    static bool isValid(\\n        final List<List<int>> grid, \\n        final int x, final int y, \\n        final int expectedPos\\n    ) {\\n        if(x >= grid.length || y >= grid[0].length || x < 0 || y < 0 || grid[x][y] != expectedPos) {\\n            return false;\\n        }\\n\\n        if(expectedPos == grid.length * grid[0].length - 1) {\\n            return true;\\n        }\\n\\n        return VALID_MOVES\\n                .any((delta) => Solution.isValid(grid, x + delta[0], y + delta[1], expectedPos + 1));\\n    }\\n    bool checkValidGrid(final List<List<int>> grid) {\\n        return Solution.isValid(grid, 0, 0, 0);\\n    }\\n}\\n```\n```PHP [PHP]\\nclass Solution {\\n    const VALID_MOVES = [\\n            [-1, -2],                   [1, -2],\\n        [-2, -1],                           [2, -1],\\n        \\n        [-2, 1],                            [2, 1],\\n            [-1, 2],                    [1, 2]\\n    ];\\n    function isValid($grid, $x, $y, $expectedPos) {\\n        if($x >= count($grid) || $y >= count($grid[0]) || $x < 0 || $y < 0 || $grid[$x][$y] != $expectedPos) {\\n            return false;\\n        }\\n\\n        if($expectedPos == count($grid) * count($grid[0]) - 1) {\\n            return true;\\n        }\\n\\n        foreach(self::VALID_MOVES as $delta) {\\n            if($this->isValid($grid, $x + $delta[0], $y + $delta[1], $expectedPos + 1)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n    function checkValidGrid($grid) {\\n        return $this->isValid($grid, 0, 0, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314793,
                "title": "brute-force-easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        \\n        int ct=0 ,n=grid.size() ,i=0, j=0;\\n        while(ct!=(n*n)){\\n                //cout<<grid[i][j]<<endl;\\n                ct++;\\n                if(i-1>=0 and j-2>=0){\\n                if(grid[i-1][j-2]==ct){\\n                    i=i-1,j=j-2;\\n                    continue;}}\\n                if(i-1>=0 and j+2<n){\\n                if(grid[i-1][j+2]==ct){\\n                    i=i-1,j=j+2;\\n                    continue;}}\\n                if(i+1<n and j-2>=0){\\n                if(grid[i+1][j-2]==ct){\\n                    i=i+1,j=j-2;\\n                    continue;}}\\n                if(i+1<n and j+2<n){\\n                if(grid[i+1][j+2]==ct){\\n                    i=i+1,j=j+2;\\n                    continue;}}\\n                if(i+2<n and j-1>=0){\\n                if(grid[i+2][j-1]==ct){\\n                    i=i+2,j=j-1;\\n                    continue;}}\\n                if(i+2<n and j+1<n){\\n                if(grid[i+2][j+1]==ct){\\n                    i=i+2,j=j+1;\\n                    continue;}}\\n                if(i-2>=0 and j+1<n){\\n                if(grid[i-2][j+1]==ct){\\n                    i=i-2,j=j+1;\\n                    continue;}}\\n                if(i-2>=0 and j-1>=0){\\n                if(grid[i-2][j-1]==ct){\\n                    i=i-2,j=j-1;\\n                    continue;}}\\n                 cout<<ct<<endl;\\n            if(ct!=(n*n))return false;\\n                \\n            \\n                \\n                  \\n            \\n        }\\n       \\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        \\n        int ct=0 ,n=grid.size() ,i=0, j=0;\\n        while(ct!=(n*n)){\\n                //cout<<grid[i][j]<<endl;\\n                ct++;\\n                if(i-1>=0 and j-2>=0){\\n                if(grid[i-1][j-2]==ct){\\n                    i=i-1,j=j-2;\\n                    continue;}}\\n                if(i-1>=0 and j+2<n){\\n                if(grid[i-1][j+2]==ct){\\n                    i=i-1,j=j+2;\\n                    continue;}}\\n                if(i+1<n and j-2>=0){\\n                if(grid[i+1][j-2]==ct){\\n                    i=i+1,j=j-2;\\n                    continue;}}\\n                if(i+1<n and j+2<n){\\n                if(grid[i+1][j+2]==ct){\\n                    i=i+1,j=j+2;\\n                    continue;}}\\n                if(i+2<n and j-1>=0){\\n                if(grid[i+2][j-1]==ct){\\n                    i=i+2,j=j-1;\\n                    continue;}}\\n                if(i+2<n and j+1<n){\\n                if(grid[i+2][j+1]==ct){\\n                    i=i+2,j=j+1;\\n                    continue;}}\\n                if(i-2>=0 and j+1<n){\\n                if(grid[i-2][j+1]==ct){\\n                    i=i-2,j=j+1;\\n                    continue;}}\\n                if(i-2>=0 and j-1>=0){\\n                if(grid[i-2][j-1]==ct){\\n                    i=i-2,j=j-1;\\n                    continue;}}\\n                 cout<<ct<<endl;\\n            if(ct!=(n*n))return false;\\n                \\n            \\n                \\n                  \\n            \\n        }\\n       \\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3314325,
                "title": "dfs-dp-simple-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int &n,int k,vector<vector<int>> &g,vector<vector<int>> &dp){\\n        if(i<0||j<0||i>=n||j>=n||g[i][j]!=k){\\n            return 0;\\n        }\\n        if(k==(n*n-1)){dp[i][j]= 1;return 1;}\\n        if(dp[i][j] != -1)return dp[i][j];\\n        return dp[i][j] =  (solve(i+2,j+1,n,k+1,g,dp) || solve(i+2,j-1,n,k+1,g,dp) || solve(i+1,j-2,n,k+1,g,dp) || solve(i+1,j+2,n,k+1,g,dp) || solve(i-1,j+2,n,k+1,g,dp) || solve(i-1,j-2,n,k+1,g,dp) || solve(i-2,j+1,n,k+1,g,dp) || solve(i-2,j-1,n,k+1,g,dp));\\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(n==1){\\n            return true;\\n            \\n        }\\n        else if(n==2||n==3){\\n            return false;\\n        }\\n        // if(grid[0][0]==false)return false;\\n        for(int i= 0; i < n; i++){};\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return solve(0,0,n,0,grid,dp);\\n        for(auto &i: dp){\\n            for(auto &j: i)cout<<j<<\" \";\\n            cout<<endl;\\n        }\\n        return dp[0][0];\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int &n,int k,vector<vector<int>> &g,vector<vector<int>> &dp){\\n        if(i<0||j<0||i>=n||j>=n||g[i][j]!=k){\\n            return 0;\\n        }\\n        if(k==(n*n-1)){dp[i][j]= 1;return 1;}\\n        if(dp[i][j] != -1)return dp[i][j];\\n        return dp[i][j] =  (solve(i+2,j+1,n,k+1,g,dp) || solve(i+2,j-1,n,k+1,g,dp) || solve(i+1,j-2,n,k+1,g,dp) || solve(i+1,j+2,n,k+1,g,dp) || solve(i-1,j+2,n,k+1,g,dp) || solve(i-1,j-2,n,k+1,g,dp) || solve(i-2,j+1,n,k+1,g,dp) || solve(i-2,j-1,n,k+1,g,dp));\\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(n==1){\\n            return true;\\n            \\n        }\\n        else if(n==2||n==3){\\n            return false;\\n        }\\n        // if(grid[0][0]==false)return false;\\n        for(int i= 0; i < n; i++){};\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return solve(0,0,n,0,grid,dp);\\n        for(auto &i: dp){\\n            for(auto &j: i)cout<<j<<\" \";\\n            cout<<endl;\\n        }\\n        return dp[0][0];\\n    }\\n};```",
                "codeTag": "C++"
            },
            {
                "id": 3314283,
                "title": "easy-c-o-n-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere Constraints are low so we can just check knight moves from 0 to n*n-1.\\nKnight can move in 8 direction so here i define 8 conditions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.If grid[0][0] is not equal to zero then it is impossible to reach at n*n-1 so return false.\\n2. Initialise current coordinates at x=0,y=0;\\n3. Traverse from 0 till n*n-1 and check all 8 condition where knight can move within boundries of grid. if it found i+1 value then it change coordinate of x and y to that point. else if it does not able to find the i+1 then it will return false\\n4. At the end if  it reach n*n-1 value then return true.\\n\\n\\n# Complexity\\n- Time complexity:O(N*N) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(grid[0][0]!=0) return false;\\n        bool fl=true;\\n        int x=0,y=0;\\n        for(int i=0;i<n*n;i++)\\n        {\\n            if( x+2<n && y+1<n && grid[x+2][y+1]==i+1 )\\n            {\\n                x=x+2;\\n                y=y+1;\\n                \\n                \\n            }\\n            else if(x+1<n && y+2<n && grid[x+1][y+2]==i+1  )\\n            {\\n                x=x+1;\\n                y=y+2;\\n                \\n            }\\n            else if(x+2<n && y-1>=0 && grid[x+2][y-1]==i+1 )\\n            {\\n                y=y-1;\\n                x=x+2;\\n            }\\n            else if(x+1<n && y-2>=0 && grid[x+1][y-2]==i+1)\\n            {\\n                x=x+1;\\n                y=y-2;\\n            }\\n            else if(x-2>=0 && y-1>=0 && grid[x-2][y-1]==i+1 )\\n            {\\n                x=x-2;\\n                y=y-1;\\n            }\\n            else if(x-2>=0 && y+1<n && grid[x-2][y+1]==i +1)\\n            {\\n                y=y+1;\\n                x=x-2;\\n            }\\n            else if(x-1>=0 && y-2>=0 && grid[x-1][y-2]==i+1 )\\n            {\\n                x=x-1;\\n                y=y-2;\\n                \\n            }\\n            else if(x-1>=0 && y+2<n && grid[x-1][y+2]==i +1 )\\n            {\\n                x=x-1;\\n                y=y+2;\\n                \\n                \\n            }\\n            else if(i==(n*n-1))\\n            {\\n                break;\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(grid[0][0]!=0) return false;\\n        bool fl=true;\\n        int x=0,y=0;\\n        for(int i=0;i<n*n;i++)\\n        {\\n            if( x+2<n && y+1<n && grid[x+2][y+1]==i+1 )\\n            {\\n                x=x+2;\\n                y=y+1;\\n                \\n                \\n            }\\n            else if(x+1<n && y+2<n && grid[x+1][y+2]==i+1  )\\n            {\\n                x=x+1;\\n                y=y+2;\\n                \\n            }\\n            else if(x+2<n && y-1>=0 && grid[x+2][y-1]==i+1 )\\n            {\\n                y=y-1;\\n                x=x+2;\\n            }\\n            else if(x+1<n && y-2>=0 && grid[x+1][y-2]==i+1)\\n            {\\n                x=x+1;\\n                y=y-2;\\n            }\\n            else if(x-2>=0 && y-1>=0 && grid[x-2][y-1]==i+1 )\\n            {\\n                x=x-2;\\n                y=y-1;\\n            }\\n            else if(x-2>=0 && y+1<n && grid[x-2][y+1]==i +1)\\n            {\\n                y=y+1;\\n                x=x-2;\\n            }\\n            else if(x-1>=0 && y-2>=0 && grid[x-1][y-2]==i+1 )\\n            {\\n                x=x-1;\\n                y=y-2;\\n                \\n            }\\n            else if(x-1>=0 && y+2<n && grid[x-1][y+2]==i +1 )\\n            {\\n                x=x-1;\\n                y=y+2;\\n                \\n                \\n            }\\n            else if(i==(n*n-1))\\n            {\\n                break;\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314119,
                "title": "java-no-recursion-o-n-2-time-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStarting from (0,0) try all valid moves for the knight and validate whether the next position number can be found on the grid using any of the moves. Keep progressing through each position number until you reach the $$n^2 - 1$$ position or can\\'t find  the next position through any valid move.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean checkValidGrid(int[][] grid) {\\n    if (grid[0][0] != 0) return false;\\n    \\n    var n = grid.length;\\n    var last = n*n - 1;\\n    \\n    var moves = new int[][] {{2,1}, {2,-1}, {-2,1}, {-2,-1}, {1,2}, {1,-2}, {-1,2}, {-1,-2}};\\n    \\n    var x = 0;\\n    var y = 0;\\n    var cnt = 0;\\n    \\n    while (cnt < last) {\\n      var valid = false;\\n      \\n      for (var move : moves) {\\n        var i = x + move[0];\\n        var j = y + move[1];\\n        \\n        if (i < 0 || i >= n || j < 0 || j >= n || grid[i][j] != cnt + 1)\\n          continue;\\n        \\n        x = i;\\n        y = j;\\n        cnt++;\\n        valid = true;\\n        break;\\n      }\\n      if (!valid) return false;\\n    }\\n    return true;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public boolean checkValidGrid(int[][] grid) {\\n    if (grid[0][0] != 0) return false;\\n    \\n    var n = grid.length;\\n    var last = n*n - 1;\\n    \\n    var moves = new int[][] {{2,1}, {2,-1}, {-2,1}, {-2,-1}, {1,2}, {1,-2}, {-1,2}, {-1,-2}};\\n    \\n    var x = 0;\\n    var y = 0;\\n    var cnt = 0;\\n    \\n    while (cnt < last) {\\n      var valid = false;\\n      \\n      for (var move : moves) {\\n        var i = x + move[0];\\n        var j = y + move[1];\\n        \\n        if (i < 0 || i >= n || j < 0 || j >= n || grid[i][j] != cnt + 1)\\n          continue;\\n        \\n        x = i;\\n        y = j;\\n        cnt++;\\n        valid = true;\\n        break;\\n      }\\n      if (!valid) return false;\\n    }\\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321454,
                "title": "dfs-c-solution",
                "content": "//The main base case is grid[i][j]!=cnt why i got return->\\nbecause suppose initially we at position (0,0) with value [0] now we need to go at [1] if all recursive call  return grid[i][j]!=cnt mean we never found any 1 at it\\'s adjacent move:\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool solve(int i,int j,vector<vector<int>> &grid,int cnt){\\n        \\n        if(i<0 || j<0 || i>=grid.size() || j>=grid.size() || grid[i][j]!=cnt){\\n            return false;\\n        }\\n   \\n       if(cnt==grid.size()*grid.size()-1){\\n           return true;\\n       }     \\n        \\n       bool check1 = solve(i-2,j+1,grid,cnt+1);\\n       bool check2 = solve(i-2,j-1,grid,cnt+1);\\n       bool check3 =  solve(i+2,j-1,grid,cnt+1);\\n       bool check4 = solve(i+2,j+1,grid,cnt+1);\\n        \\n      bool check5 =   solve(i+1,j-2,grid,cnt+1);\\n      bool check6 =  solve(i-1,j-2,grid,cnt+1);\\n      bool check7 = solve(i-1,j+2,grid,cnt+1);\\n      bool check8 =  solve(i+1,j+2,grid,cnt+1);\\n        \\n      return check1 || check2 ||check3 || check4 || check5 || check6 || check7 || check8;\\n    }\\n    \\n    \\n    \\n    bool checkValidGrid(vector<vector<int>>& grid){\\n        int k=0;    //start from 0 to 63 for 8*8 grid:\\n        return solve(0,0,grid,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool solve(int i,int j,vector<vector<int>> &grid,int cnt){\\n        \\n        if(i<0 || j<0 || i>=grid.size() || j>=grid.size() || grid[i][j]!=cnt){\\n            return false;\\n        }\\n   \\n       if(cnt==grid.size()*grid.size()-1){\\n           return true;\\n       }     \\n        \\n       bool check1 = solve(i-2,j+1,grid,cnt+1);\\n       bool check2 = solve(i-2,j-1,grid,cnt+1);\\n       bool check3 =  solve(i+2,j-1,grid,cnt+1);\\n       bool check4 = solve(i+2,j+1,grid,cnt+1);\\n        \\n      bool check5 =   solve(i+1,j-2,grid,cnt+1);\\n      bool check6 =  solve(i-1,j-2,grid,cnt+1);\\n      bool check7 = solve(i-1,j+2,grid,cnt+1);\\n      bool check8 =  solve(i+1,j+2,grid,cnt+1);\\n        \\n      return check1 || check2 ||check3 || check4 || check5 || check6 || check7 || check8;\\n    }\\n    \\n    \\n    \\n    bool checkValidGrid(vector<vector<int>>& grid){\\n        int k=0;    //start from 0 to 63 for 8*8 grid:\\n        return solve(0,0,grid,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318305,
                "title": "c-iterative-faster-easy-to-understand",
                "content": "* ***Iterative***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        // co-ordinates of the moves of knight\\n        \\n        vector<int> dx = {-2, -2, -1, 1, 2, 2, 1, -1};\\n        \\n        vector<int> dy = {-1, 1, 2, 2, 1, -1, -2, -2};\\n        \\n        // traverse over the grid\\n        \\n        int move = 1;\\n        \\n        int i = 0, j = 0;\\n        \\n        while(move < n * n)\\n        {\\n            int row = -1, col = -1;\\n            \\n            // visit all the directions\\n            \\n            for(int k = 0; k < 8; k++)\\n            {\\n                int new_i = i + dx[k];\\n                \\n                int new_j = j + dy[k];\\n                \\n                if(new_i >= 0 && new_i < n && new_j >= 0 && new_j < n && grid[new_i][new_j] == move)\\n                {\\n                    row = new_i;\\n                    \\n                    col = new_j;\\n                    \\n                    break;\\n                }\\n            }\\n            \\n            // if the curr move is not found\\n            \\n            if(row == -1 && col == -1)\\n            {\\n                return false;\\n            }\\n            \\n            // update the cell no.\\n            \\n            i = row;\\n            \\n            j = col;\\n            \\n            move++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        // co-ordinates of the moves of knight\\n        \\n        vector<int> dx = {-2, -2, -1, 1, 2, 2, 1, -1};\\n        \\n        vector<int> dy = {-1, 1, 2, 2, 1, -1, -2, -2};\\n        \\n        // traverse over the grid\\n        \\n        int move = 1;\\n        \\n        int i = 0, j = 0;\\n        \\n        while(move < n * n)\\n        {\\n            int row = -1, col = -1;\\n            \\n            // visit all the directions\\n            \\n            for(int k = 0; k < 8; k++)\\n            {\\n                int new_i = i + dx[k];\\n                \\n                int new_j = j + dy[k];\\n                \\n                if(new_i >= 0 && new_i < n && new_j >= 0 && new_j < n && grid[new_i][new_j] == move)\\n                {\\n                    row = new_i;\\n                    \\n                    col = new_j;\\n                    \\n                    break;\\n                }\\n            }\\n            \\n            // if the curr move is not found\\n            \\n            if(row == -1 && col == -1)\\n            {\\n                return false;\\n            }\\n            \\n            // update the cell no.\\n            \\n            i = row;\\n            \\n            j = col;\\n            \\n            move++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316402,
                "title": "c-easy-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck for every possible move of knight at the position one by one.\\n\\n# Complexity\\n- Time complexity: O(row*col)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int row=(int)grid.size();\\n        int col=(int)grid[0].size();\\n        int tot=row*col-1;\\n        if(grid[0][0]!=0){\\n            return false;\\n        }\\n        int now_r=0,now_c=0;\\n        for(int i=1;i<=tot;i++){\\n            int a=now_r,b=now_c;\\n            bool ok=false;\\n            \\n            a=now_r-1,b=now_c-2;\\n            if(a>=0 and a<row and b>=0 and b<col and grid[a][b]==i){\\n                now_r=a,now_c=b;\\n                ok=true;\\n                continue;\\n            }\\n            \\n            a=now_r+1,b=now_c-2;\\n            if(a>=0 and a<row and b>=0 and b<col and grid[a][b]==i){\\n                now_r=a,now_c=b;\\n                ok=true;\\n                continue;\\n            }\\n            \\n            a=now_r-2,b=now_c-1;\\n            if(a>=0 and a<row and b>=0 and b<col and grid[a][b]==i){\\n                now_r=a,now_c=b;\\n                ok=true;\\n                continue;\\n            }\\n            \\n            a=now_r+2,b=now_c-1;\\n            if(a>=0 and a<row and b>=0 and b<col and grid[a][b]==i){\\n                now_r=a,now_c=b;\\n                ok=true;\\n                continue;\\n            }\\n            \\n            a=now_r-2,b=now_c+1;\\n            if(a>=0 and a<row and b>=0 and b<col and grid[a][b]==i){\\n                now_r=a,now_c=b;\\n                ok=true;\\n                continue;\\n            }\\n            \\n            a=now_r+2,b=now_c+1;\\n            if(a>=0 and a<row and b>=0 and b<col and grid[a][b]==i){\\n                now_r=a,now_c=b;\\n                ok=true;\\n                continue;\\n            }\\n            \\n            a=now_r-1,b=now_c+2;\\n            if(a>=0 and a<row and b>=0 and b<col and grid[a][b]==i){\\n                now_r=a,now_c=b;\\n                ok=true;\\n                continue;\\n            }\\n            \\n            a=now_r+1,b=now_c+2;\\n            if(a>=0 and a<row and b>=0 and b<col and grid[a][b]==i){\\n                now_r=a,now_c=b;\\n                ok=true;\\n                continue;\\n            }\\n            if(!ok){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int row=(int)grid.size();\\n        int col=(int)grid[0].size();\\n        int tot=row*col-1;\\n        if(grid[0][0]!=0){\\n            return false;\\n        }\\n        int now_r=0,now_c=0;\\n        for(int i=1;i<=tot;i++){\\n            int a=now_r,b=now_c;\\n            bool ok=false;\\n            \\n            a=now_r-1,b=now_c-2;\\n            if(a>=0 and a<row and b>=0 and b<col and grid[a][b]==i){\\n                now_r=a,now_c=b;\\n                ok=true;\\n                continue;\\n            }\\n            \\n            a=now_r+1,b=now_c-2;\\n            if(a>=0 and a<row and b>=0 and b<col and grid[a][b]==i){\\n                now_r=a,now_c=b;\\n                ok=true;\\n                continue;\\n            }\\n            \\n            a=now_r-2,b=now_c-1;\\n            if(a>=0 and a<row and b>=0 and b<col and grid[a][b]==i){\\n                now_r=a,now_c=b;\\n                ok=true;\\n                continue;\\n            }\\n            \\n            a=now_r+2,b=now_c-1;\\n            if(a>=0 and a<row and b>=0 and b<col and grid[a][b]==i){\\n                now_r=a,now_c=b;\\n                ok=true;\\n                continue;\\n            }\\n            \\n            a=now_r-2,b=now_c+1;\\n            if(a>=0 and a<row and b>=0 and b<col and grid[a][b]==i){\\n                now_r=a,now_c=b;\\n                ok=true;\\n                continue;\\n            }\\n            \\n            a=now_r+2,b=now_c+1;\\n            if(a>=0 and a<row and b>=0 and b<col and grid[a][b]==i){\\n                now_r=a,now_c=b;\\n                ok=true;\\n                continue;\\n            }\\n            \\n            a=now_r-1,b=now_c+2;\\n            if(a>=0 and a<row and b>=0 and b<col and grid[a][b]==i){\\n                now_r=a,now_c=b;\\n                ok=true;\\n                continue;\\n            }\\n            \\n            a=now_r+1,b=now_c+2;\\n            if(a>=0 and a<row and b>=0 and b<col and grid[a][b]==i){\\n                now_r=a,now_c=b;\\n                ok=true;\\n                continue;\\n            }\\n            if(!ok){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316007,
                "title": "compact-and-fast-solution-with-explanation",
                "content": "# Intuition\\nDepth first Search\\n\\n# Approach\\n\\nHere we will make a varibale count so that we can keep record of number of jumps. we will also use grid itself to check if we have visited the cell before or not. And we will design dfs function to travrel. explanation below.\\n\\n1. We  will make function dfs which will consist of i, j, grid and count. here i and j will be used to get cell value in grid.\\n2. In function dfs there will be an conditional statement which will be used to return control to the previous function in case of any error such as knight is going out of bound or that cell is already visited or if the cell value does not match with count value.\\n3. if we are visiting cell for the first time then we will change its value to -1 so that we can use grid with changed value to see if all the cell is visited or not.\\n4. We will add or subtract value from i and j as required so that it could mimic the jump of knight.\\n5. In CheckVliadGrid() we will traverse all the cell in grid if any value is not -1 then we will return \"false\" or if it reaches the end of function it will return \"true\".\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        int count=0;\\n        dfs(0,0,grid,count); \\n        for(int[] a:grid)\\n            for(int i:a)\\n                if(i!=-1) return false;\\n        return true;\\n    }\\n    void dfs(int i, int j, int[][] grid,int count){\\n        if(i<0 || j<0 || i>=grid[0].length || j>=grid.length || grid[i][j]!=count) return ;\\n        grid[i][j]=-1;\\n        dfs(i-2,j-1,grid,count+1);\\n        dfs(i-1,j-2,grid,count+1);\\n        dfs(i-2,j+1,grid,count+1);\\n        dfs(i-1,j+2,grid,count+1);\\n        dfs(i+2,j+1,grid,count+1);\\n        dfs(i+1,j+2,grid,count+1);\\n        dfs(i+2,j-1,grid,count+1);\\n        dfs(i+1,j-2,grid,count+1);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        int count=0;\\n        dfs(0,0,grid,count); \\n        for(int[] a:grid)\\n            for(int i:a)\\n                if(i!=-1) return false;\\n        return true;\\n    }\\n    void dfs(int i, int j, int[][] grid,int count){\\n        if(i<0 || j<0 || i>=grid[0].length || j>=grid.length || grid[i][j]!=count) return ;\\n        grid[i][j]=-1;\\n        dfs(i-2,j-1,grid,count+1);\\n        dfs(i-1,j-2,grid,count+1);\\n        dfs(i-2,j+1,grid,count+1);\\n        dfs(i-1,j+2,grid,count+1);\\n        dfs(i+2,j+1,grid,count+1);\\n        dfs(i+1,j+2,grid,count+1);\\n        dfs(i+2,j-1,grid,count+1);\\n        dfs(i+1,j-2,grid,count+1);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314944,
                "title": "java-easy-knight-tour",
                "content": "# Approach\\nLook for 8 valid possible cell from the current cell, if a valid move does not exist, return false, otherwise move and look for the next step.\\n\\n> `Note:` Need to handle the silly edge case when the knight does not start at the top-left cell\\n\\n# Complexity\\n- Time complexity: $$O(8 * n^2)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] g) {\\n        if(g[0][0] != 0)\\n            return false;\\n        \\n        int dir[][] = {{-2, -1}, {-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}};\\n        \\n        int n = g.length;\\n        int row = 0, col = 0;\\n        \\n        int step = 1;\\n        while (step < n * n) {\\n            \\n            boolean found = false;\\n            for(int nd[] : dir) {\\n                int nrow = row + nd[0];\\n                int ncol = col + nd[1];\\n                \\n                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n && g[nrow][ncol] == step) {\\n                    row = nrow;\\n                    col = ncol;\\n                    step++;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if(!found)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] g) {\\n        if(g[0][0] != 0)\\n            return false;\\n        \\n        int dir[][] = {{-2, -1}, {-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}};\\n        \\n        int n = g.length;\\n        int row = 0, col = 0;\\n        \\n        int step = 1;\\n        while (step < n * n) {\\n            \\n            boolean found = false;\\n            for(int nd[] : dir) {\\n                int nrow = row + nd[0];\\n                int ncol = col + nd[1];\\n                \\n                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n && g[nrow][ncol] == step) {\\n                    row = nrow;\\n                    col = ncol;\\n                    step++;\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if(!found)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314502,
                "title": "c-java-dfs-bfs-solutions",
                "content": "## Explanation\\nFrom the description, it is evident that the solution will be a simple BFS/DFS traversal from top-left cell. At each step there are 8 options (cells) to move (typical knight moves in chess).\\n\\nMove to the cell that has a value equal to `currCellValue+1`. If no cell has such value of out those 8 available options, return false.\\n\\nIf the cell reached has a value $$n^2-1$$ (since the grid contains values from 0 to $$n^2-1$$ where `n=grid.size()`) , it is the final cell. So return true. \\n\\n## Code\\n\\n### DFS\\n\\n```Java []\\nclass Solution {\\n\\n    int[][] dirs={{-1,-2},{1,2},{-1,2},{1,-2},{2,1},{-2,-1},{2,-1},{-2,1}};\\n\\n    public boolean dfs(int[][] grid,int i,int j,int curr,int n){\\n        if(curr==n*n-1) return true;\\n        curr++;\\n        for(int k=0;k<8;k++){\\n            int nr=i+dirs[k][0],nc=j+dirs[k][1];\\n            if(nr<0||nc<0||nr>=n||nc>=n) continue;\\n            if(grid[nr][nc]==curr) return dfs(grid,nr,nc,curr,n);\\n        }\\n        return false;\\n    }\\n\\n    public boolean checkValidGrid(int[][] grid) {\\n        int n=grid.length;\\n        return dfs(grid,0,0,0,n);\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>dirs{{-1,-2},{1,2},{-1,2},{1,-2},{2,1},{-2,-1},{2,-1},{-2,1}};\\n    \\n    bool dfs(vector<vector<int>>& grid,int i,int j,int curr,int n){\\n        if(curr==n*n-1) return true;\\n        curr++;\\n        for(auto dir:dirs){\\n            int nr=i+dir[0],nc=j+dir[1];\\n            if(nr<0||nc<0||nr>=n||nc>=n) continue;\\n            if(grid[nr][nc]==curr) {                \\n                return dfs(grid,nr,nc,curr,n);\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        return dfs(grid,0,0,0,n);\\n    }\\n};\\n```\\n\\n### BFS\\n```C++ []\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        queue<tuple<int,int,int>>q;\\n        q.push({0,0,0});\\n\\n        vector<vector<int>>dirs{{-1,-2},{1,2},{-1,2},{1,-2},{2,1},{-2,-1},{2,-1},{-2,1}};\\n    \\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n            int i=get<0>(p),j=get<1>(p),curr=get<2>(p);\\n            curr++;\\n            for(auto dir:dirs){\\n                int nr=i+dir[0],nc=j+dir[1];\\n                if(nr<0||nc<0||nr>=n||nc>=n) continue;\\n                if(grid[nr][nc]==curr) {       \\n                    if(curr==n*n-1) return true;         \\n                    q.push({nr,nc,curr});\\n                    break;\\n                }\\n            }          \\n        }\\n        return false;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        int n = grid.length;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,0,0});\\n        int[][] dirs = {{-2, -1}, {-2, 1}, {2, -1}, {2, 1},{-1, -2}, {1, -2}, {1, 2}, {-1, 2}};\\n\\n        while(!q.isEmpty()) {\\n            int[] curr = q.poll();\\n            int next= curr[2]+1;\\n            for(int[] dir : dirs) {\\n                int i = curr[0] + dir[0], j = curr[1] + dir[1];\\n                if(i < 0 || j < 0 || i >= n || j >= n) continue;\\n                if(grid[i][j] == next) {\\n                    if(next==n*n-1) return true;\\n                    q.add(new int[]{i, j, next});\\n                    break;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n## Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$ (Recursion stack space - DFS && Queue - BFS)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```Java []\\nclass Solution {\\n\\n    int[][] dirs={{-1,-2},{1,2},{-1,2},{1,-2},{2,1},{-2,-1},{2,-1},{-2,1}};\\n\\n    public boolean dfs(int[][] grid,int i,int j,int curr,int n){\\n        if(curr==n*n-1) return true;\\n        curr++;\\n        for(int k=0;k<8;k++){\\n            int nr=i+dirs[k][0],nc=j+dirs[k][1];\\n            if(nr<0||nc<0||nr>=n||nc>=n) continue;\\n            if(grid[nr][nc]==curr) return dfs(grid,nr,nc,curr,n);\\n        }\\n        return false;\\n    }\\n\\n    public boolean checkValidGrid(int[][] grid) {\\n        int n=grid.length;\\n        return dfs(grid,0,0,0,n);\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>dirs{{-1,-2},{1,2},{-1,2},{1,-2},{2,1},{-2,-1},{2,-1},{-2,1}};\\n    \\n    bool dfs(vector<vector<int>>& grid,int i,int j,int curr,int n){\\n        if(curr==n*n-1) return true;\\n        curr++;\\n        for(auto dir:dirs){\\n            int nr=i+dir[0],nc=j+dir[1];\\n            if(nr<0||nc<0||nr>=n||nc>=n) continue;\\n            if(grid[nr][nc]==curr) {                \\n                return dfs(grid,nr,nc,curr,n);\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        return dfs(grid,0,0,0,n);\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        queue<tuple<int,int,int>>q;\\n        q.push({0,0,0});\\n\\n        vector<vector<int>>dirs{{-1,-2},{1,2},{-1,2},{1,-2},{2,1},{-2,-1},{2,-1},{-2,1}};\\n    \\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n            int i=get<0>(p),j=get<1>(p),curr=get<2>(p);\\n            curr++;\\n            for(auto dir:dirs){\\n                int nr=i+dir[0],nc=j+dir[1];\\n                if(nr<0||nc<0||nr>=n||nc>=n) continue;\\n                if(grid[nr][nc]==curr) {       \\n                    if(curr==n*n-1) return true;         \\n                    q.push({nr,nc,curr});\\n                    break;\\n                }\\n            }          \\n        }\\n        return false;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        int n = grid.length;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,0,0});\\n        int[][] dirs = {{-2, -1}, {-2, 1}, {2, -1}, {2, 1},{-1, -2}, {1, -2}, {1, 2}, {-1, 2}};\\n\\n        while(!q.isEmpty()) {\\n            int[] curr = q.poll();\\n            int next= curr[2]+1;\\n            for(int[] dir : dirs) {\\n                int i = curr[0] + dir[0], j = curr[1] + dir[1];\\n                if(i < 0 || j < 0 || i >= n || j >= n) continue;\\n                if(grid[i][j] == next) {\\n                    if(next==n*n-1) return true;\\n                    q.add(new int[]{i, j, next});\\n                    break;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314402,
                "title": "simple-c-solution-o-n-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrutforce method\\n# Complexity\\n- Time complexity:O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        if(grid[0][0]!=0)\\n        return 0;\\n        int i=0,j=0,n=grid.size(),k=0,p=0,n2=n*n;\\n        while(k<n2-1)\\n        {\\n            if((i+2<n && j+1<n) && grid[i+2][j+1]==k+1)\\n            {\\n                i=i+2;j=j+1;\\n                k++;\\n            }\\n            else if((i+2<n && j-1>=0) && grid[i+2][j-1]==k+1)\\n            {\\n                i=i+2;j--;k++;\\n            }\\n            else if((i-2>=0 && j-1>=0) && grid[i-2][j-1]==k+1)\\n            {\\n                i=i-2;j--;k++;\\n            }\\n            else if((i-2>=0 && j+1<n) && grid[i-2][j+1]==k+1)\\n            {\\n                i=i-2;j++;k++;\\n            }\\n            else if((i+1<n && j-2>=0) &&grid[i+1][j-2]==k+1)\\n            {\\n                i++;j=j-2;k++;\\n            }\\n            else if((i-1>=0 && j-2>=0) &&grid[i-1][j-2]==k+1)\\n            {\\n                i--;j=j-2;k++;\\n            }\\n            else if((i-1>=0 && j+2<n) &&grid[i-1][j+2]==k+1)\\n            {\\n                i--;j=j+2;k++;\\n            }\\n            else if((i+1<n && j+2<n) &&grid[i+1][j+2]==k+1)\\n            {\\n                i++;j=j+2;k++;\\n            }\\n            else\\n            {\\n               // cout<<k<<endl;\\n                return false;\\n            }      \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        if(grid[0][0]!=0)\\n        return 0;\\n        int i=0,j=0,n=grid.size(),k=0,p=0,n2=n*n;\\n        while(k<n2-1)\\n        {\\n            if((i+2<n && j+1<n) && grid[i+2][j+1]==k+1)\\n            {\\n                i=i+2;j=j+1;\\n                k++;\\n            }\\n            else if((i+2<n && j-1>=0) && grid[i+2][j-1]==k+1)\\n            {\\n                i=i+2;j--;k++;\\n            }\\n            else if((i-2>=0 && j-1>=0) && grid[i-2][j-1]==k+1)\\n            {\\n                i=i-2;j--;k++;\\n            }\\n            else if((i-2>=0 && j+1<n) && grid[i-2][j+1]==k+1)\\n            {\\n                i=i-2;j++;k++;\\n            }\\n            else if((i+1<n && j-2>=0) &&grid[i+1][j-2]==k+1)\\n            {\\n                i++;j=j-2;k++;\\n            }\\n            else if((i-1>=0 && j-2>=0) &&grid[i-1][j-2]==k+1)\\n            {\\n                i--;j=j-2;k++;\\n            }\\n            else if((i-1>=0 && j+2<n) &&grid[i-1][j+2]==k+1)\\n            {\\n                i--;j=j+2;k++;\\n            }\\n            else if((i+1<n && j+2<n) &&grid[i+1][j+2]==k+1)\\n            {\\n                i++;j=j+2;k++;\\n            }\\n            else\\n            {\\n               // cout<<k<<endl;\\n                return false;\\n            }      \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3314205,
                "title": "c-simplest-solution-store-cordinates-and-validate",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        map<int,pair<int,int>>mp;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0 && j==0)continue;\\n                mp[grid[i][j]]={i,j};\\n            }\\n        }\\n       \\n        int r=0,c=0;\\n        for(auto it:mp)\\n        {\\n            int rtemp=it.second.first;\\n            int ctemp=it.second.second;\\n            int X[8] = { 2, 1, -1, -2, -2, -1, 1, 2 };\\n            int Y[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n            bool flag=0;\\n            for (int i = 0; i < 8; i++) {\\n \\n            // Position of knight after move\\n            int x = r + X[i];\\n            int y = c + Y[i];\\n        \\n            if(x==rtemp && y==ctemp)\\n            {\\n                //cout<<x<<\" \"<<y<<\" continued\"<<endl;\\n                r=x;\\n                c=y;\\n                flag=true;\\n                break;\\n               // continue;\\n            }\\n            \\n            }\\n            \\n            if(!flag)return false;\\n            else continue;\\n           \\n             \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        map<int,pair<int,int>>mp;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0 && j==0)continue;\\n                mp[grid[i][j]]={i,j};\\n            }\\n        }\\n       \\n        int r=0,c=0;\\n        for(auto it:mp)\\n        {\\n            int rtemp=it.second.first;\\n            int ctemp=it.second.second;\\n            int X[8] = { 2, 1, -1, -2, -2, -1, 1, 2 };\\n            int Y[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n            bool flag=0;\\n            for (int i = 0; i < 8; i++) {\\n \\n            // Position of knight after move\\n            int x = r + X[i];\\n            int y = c + Y[i];\\n        \\n            if(x==rtemp && y==ctemp)\\n            {\\n                //cout<<x<<\" \"<<y<<\" continued\"<<endl;\\n                r=x;\\n                c=y;\\n                flag=true;\\n                break;\\n               // continue;\\n            }\\n            \\n            }\\n            \\n            if(!flag)return false;\\n            else continue;\\n           \\n             \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3314121,
                "title": "very-easy-brute-force-c-solution",
                "content": "approach:\\n\\tstart from [0,0] and try to go in all 8 directions also check if you go in any direction you do not go out of the chess board itself and check if any direction contain the required value.\\n\\tInitialize a variable step=0 and run while loop until step!=n*(n)-1 if the conditions are not meet in while step<n*n-1 return false.\\n```\\nbool checkValidGrid(vector<vector<int>>& grid) {\\n        int step=0;\\n        int n=grid.size();\\n        int i=0;\\n        int j=0;\\n        while(step<n*n-1){\\n            if(j+2<n && i+1<n && j+2>=0 && i+1>=0 && grid[i+1][j+2]==step+1){\\n                i=i+1;\\n                j=j+2;\\n                step++;\\n            }\\n            else if(j+1<n && i+2<n && j+1>=0 && i+2>=0 && grid[i+2][j+1]==step+1){\\n                i=i+2;\\n                j=j+1;\\n                step++;\\n            }\\n            else if(j-1<n && i+2<n && j-1>=0 && i+2>=0 && grid[i+2][j-1]==step+1){\\n                i=i+2;\\n                j=j-1;\\n                step++;\\n            }\\n            else if(j-2<n && i+1<n && j-2>=0 && i+1>=0 && grid[i+1][j-2]==step+1){\\n                i=i+1;\\n                j=j-2;\\n                step++;\\n            }\\n            else if(j-2<n && i-1<n && j-2>=0 && i-1>=0 && grid[i-1][j-2]==step+1){\\n                i=i-1;\\n                j=j-2;\\n                step++;\\n            }\\n            else if(j-1<n && i-2<n && j-1>=0 && i-2>=0 && grid[i-2][j-1]==step+1){\\n                i=i-2;\\n                j=j-1;\\n                step++;\\n            }\\n            else if(j+1<n && i-2<n && j+1>=0 && i-2>=0 && grid[i-2][j+1]==step+1){\\n                i=i-2;\\n                j=j+1;\\n                step++;\\n            }\\n            else if(j+2<n && i-1<n && j+2>=0 && i-1>=0 && grid[i-1][j+2]==step+1){\\n                i=i-1;\\n                j=j+2;\\n                step++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\t\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "approach:\\n\\tstart from [0,0] and try to go in all 8 directions also check if you go in any direction you do not go out of the chess board itself and check if any direction contain the required value.\\n\\tInitialize a variable step=0 and run while loop until step!=n*(n)-1 if the conditions are not meet in while step<n*n-1 return false.\\n```\\nbool checkValidGrid(vector<vector<int>>& grid) {\\n        int step=0;\\n        int n=grid.size();\\n        int i=0;\\n        int j=0;\\n        while(step<n*n-1){\\n            if(j+2<n && i+1<n && j+2>=0 && i+1>=0 && grid[i+1][j+2]==step+1){\\n                i=i+1;\\n                j=j+2;\\n                step++;\\n            }\\n            else if(j+1<n && i+2<n && j+1>=0 && i+2>=0 && grid[i+2][j+1]==step+1){\\n                i=i+2;\\n                j=j+1;\\n                step++;\\n            }\\n            else if(j-1<n && i+2<n && j-1>=0 && i+2>=0 && grid[i+2][j-1]==step+1){\\n                i=i+2;\\n                j=j-1;\\n                step++;\\n            }\\n            else if(j-2<n && i+1<n && j-2>=0 && i+1>=0 && grid[i+1][j-2]==step+1){\\n                i=i+1;\\n                j=j-2;\\n                step++;\\n            }\\n            else if(j-2<n && i-1<n && j-2>=0 && i-1>=0 && grid[i-1][j-2]==step+1){\\n                i=i-1;\\n                j=j-2;\\n                step++;\\n            }\\n            else if(j-1<n && i-2<n && j-1>=0 && i-2>=0 && grid[i-2][j-1]==step+1){\\n                i=i-2;\\n                j=j-1;\\n                step++;\\n            }\\n            else if(j+1<n && i-2<n && j+1>=0 && i-2>=0 && grid[i-2][j+1]==step+1){\\n                i=i-2;\\n                j=j+1;\\n                step++;\\n            }\\n            else if(j+2<n && i-1<n && j+2>=0 && i-1>=0 && grid[i-1][j+2]==step+1){\\n                i=i-1;\\n                j=j+2;\\n                step++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 3313985,
                "title": "python-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        size = n*n\\n        directions = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\\n\\n        def dfs(i, j, curr_size):\\n            if curr_size == size-1:\\n                return True\\n            \\n            next_position = grid[i][j]+1\\n\\n            for d in directions:\\n                x, y = d\\n                r = x + i\\n                c = y + j\\n                if r < 0 or r >= n or c < 0 or c >= n or grid[r][c] != next_position:\\n                    continue\\n\\n                ans = dfs(r, c, curr_size + 1)\\n                if ans:\\n                    return ans\\n            return False\\n        return dfs(0, 0, 0)\\n                    \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        size = n*n\\n        directions = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\\n\\n        def dfs(i, j, curr_size):\\n            if curr_size == size-1:\\n                return True\\n            \\n            next_position = grid[i][j]+1\\n\\n            for d in directions:\\n                x, y = d\\n                r = x + i\\n                c = y + j\\n                if r < 0 or r >= n or c < 0 or c >= n or grid[r][c] != next_position:\\n                    continue\\n\\n                ans = dfs(r, c, curr_size + 1)\\n                if ans:\\n                    return ans\\n            return False\\n        return dfs(0, 0, 0)\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618306,
                "title": "easy-solution-in-java",
                "content": "# Code\\n```\\nclass Solution {\\n    \\n    public static boolean checkValidGrid(int[][] grid) {\\n        int n= grid.length;\\n\\n        HashSet<Integer> v = new HashSet<>();\\n        if(grid[0][0]==1)   return false;\\n        isKnightTour(grid, v,0,0,0);\\n        return v.size()==(n*n);\\n\\n    }\\n    public static void isKnightTour(int[][] grid,HashSet<Integer> v,int row ,int col,int currInt){\\n        if(row < 0 || col<0 || row >= grid.length || col>= grid.length){\\n            return;\\n        }\\n        if(grid[row][col] != currInt){\\n            return ;\\n        }\\n        v.add(grid[row][col]);\\n        currInt+=1;\\n        //These row+1 and col+2 is the expeceted move for the knight, it\\'s is used to move the knight accordingly\\n        isKnightTour(grid,v,row+1 ,col+2,currInt);\\n        isKnightTour(grid,v,row+2 ,col+1,currInt);\\n\\n        isKnightTour(grid,v,row+2 ,col-1,currInt);\\n        isKnightTour(grid,v,row-2 ,col+1,currInt);\\n\\n        isKnightTour(grid,v,row-1 ,col-2,currInt);\\n        isKnightTour(grid,v,row-2 ,col-1,currInt);\\n\\n        isKnightTour(grid,v,row+1 ,col-2,currInt);\\n        isKnightTour(grid,v,row-1 ,col+2,currInt);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public static boolean checkValidGrid(int[][] grid) {\\n        int n= grid.length;\\n\\n        HashSet<Integer> v = new HashSet<>();\\n        if(grid[0][0]==1)   return false;\\n        isKnightTour(grid, v,0,0,0);\\n        return v.size()==(n*n);\\n\\n    }\\n    public static void isKnightTour(int[][] grid,HashSet<Integer> v,int row ,int col,int currInt){\\n        if(row < 0 || col<0 || row >= grid.length || col>= grid.length){\\n            return;\\n        }\\n        if(grid[row][col] != currInt){\\n            return ;\\n        }\\n        v.add(grid[row][col]);\\n        currInt+=1;\\n        //These row+1 and col+2 is the expeceted move for the knight, it\\'s is used to move the knight accordingly\\n        isKnightTour(grid,v,row+1 ,col+2,currInt);\\n        isKnightTour(grid,v,row+2 ,col+1,currInt);\\n\\n        isKnightTour(grid,v,row+2 ,col-1,currInt);\\n        isKnightTour(grid,v,row-2 ,col+1,currInt);\\n\\n        isKnightTour(grid,v,row-1 ,col-2,currInt);\\n        isKnightTour(grid,v,row-2 ,col-1,currInt);\\n\\n        isKnightTour(grid,v,row+1 ,col-2,currInt);\\n        isKnightTour(grid,v,row-1 ,col+2,currInt);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590827,
                "title": "c-trending-solution-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3590815,
                "title": "c-super-cool-dfs-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3549795,
                "title": "cleanest-code-for-this-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) \\n    {\\n        int n  = grid.size();\\n        vector<vector<int>> v(n,vector<int>(n,0));\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n        v[0][0] = 1;\\n        queue<pair<int,pair<int,int>>> q; //{stepcount,{row,col}};\\n        q.push({0,{0,0}});\\n        int dr[] = {-2,-2,-1,-1,2,2,1,1}; // this is how the knight will traverse across the board \\n        int dc[] = {1,-1,2,-2,1,-1,2,-2};\\n\\n        int count = 0 ; \\n        while(q.size())\\n        {   \\n            count++;\\n            int step = q.front().first;\\n            int row = q.front().second.first;\\n            int col = q.front().second.second;\\n            q.pop();\\n            \\n            \\n\\n            \\n            for(int i = 0; i<8;i++)\\n            {\\n                int nr = row + dr[i];\\n                int nc = col + dc[i];\\n                if(nr>=0 && nc>=0 && nr<n && nc<n && v[nr][nc]==0 && grid[nr][nc]==step+1)\\n                {\\n                    q.push({step+1,{nr,nc}});\\n                    v[nr][nc] = 1; \\n                    break; // there can\\'t be multiple step possible so break here \\n                }\\n                     \\n            }\\n        }\\n                    \\n       return count==n*n ;\\n    }\\n};\\n```\\n            \\n\\n       \\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) \\n    {\\n        int n  = grid.size();\\n        vector<vector<int>> v(n,vector<int>(n,0));\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n        v[0][0] = 1;\\n        queue<pair<int,pair<int,int>>> q; //{stepcount,{row,col}};\\n        q.push({0,{0,0}});\\n        int dr[] = {-2,-2,-1,-1,2,2,1,1}; // this is how the knight will traverse across the board \\n        int dc[] = {1,-1,2,-2,1,-1,2,-2};\\n\\n        int count = 0 ; \\n        while(q.size())\\n        {   \\n            count++;\\n            int step = q.front().first;\\n            int row = q.front().second.first;\\n            int col = q.front().second.second;\\n            q.pop();\\n            \\n            \\n\\n            \\n            for(int i = 0; i<8;i++)\\n            {\\n                int nr = row + dr[i];\\n                int nc = col + dc[i];\\n                if(nr>=0 && nc>=0 && nr<n && nc<n && v[nr][nc]==0 && grid[nr][nc]==step+1)\\n                {\\n                    q.push({step+1,{nr,nc}});\\n                    v[nr][nc] = 1; \\n                    break; // there can\\'t be multiple step possible so break here \\n                }\\n                     \\n            }\\n        }\\n                    \\n       return count==n*n ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403510,
                "title": "simple-traversal-way-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each positon in grid there is 8 possibility of movement for Knight\\nfor 8 possibilty - \\n- Check is position is valid or not (valid : is inside grid)\\n- Check at each move that it is valid or not (valid : grid[newrow][newcol] = grid[row][col])\\n- and if any valid move is present return true and continue checking for all position of grid and if position is true return true at last\\n- and if you find any invalid movement return false\\n\\n# Complexity\\n- Time complexity:  $$O(8*n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n\\n- Space complexity:  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int row , int col,int n){\\n        if(row < n && row >= 0 && col >= 0 && col <n) return true;\\n        return false;\\n    }\\n    bool isValidMove(int row , int col,vector<vector<int>>& grid){\\n        int n = grid.size();\\n       // bool flag = false;\\n        int dr[] = {-2,-1,1,2,2,1,-1,-2};\\n        int dc[] = {1,2,2,1,-1,-2,-2,-1};\\n        \\n        for(int i = 0;i<8; i++){\\n            int nr = row + dr[i];\\n            int nc = col + dc[i];\\n            if(isValid(nr,nc,n)){\\n                if(grid[nr][nc] == (grid[row][col] + 1)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(grid[0][0] != 0){\\n            return false;\\n        }\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<n; j++){\\n                if(grid[i][j] == n*n -1) continue;\\n                else if(isValidMove(i,j,grid) == false) return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int row , int col,int n){\\n        if(row < n && row >= 0 && col >= 0 && col <n) return true;\\n        return false;\\n    }\\n    bool isValidMove(int row , int col,vector<vector<int>>& grid){\\n        int n = grid.size();\\n       // bool flag = false;\\n        int dr[] = {-2,-1,1,2,2,1,-1,-2};\\n        int dc[] = {1,2,2,1,-1,-2,-2,-1};\\n        \\n        for(int i = 0;i<8; i++){\\n            int nr = row + dr[i];\\n            int nc = col + dc[i];\\n            if(isValid(nr,nc,n)){\\n                if(grid[nr][nc] == (grid[row][col] + 1)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(grid[0][0] != 0){\\n            return false;\\n        }\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<n; j++){\\n                if(grid[i][j] == n*n -1) continue;\\n                else if(isValidMove(i,j,grid) == false) return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400441,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        if (grid[0][0]!=0)return false;\\n        int n= grid.size(); int m= grid[0].size();\\n        int last= n*m-1;\\n        int i=0;\\n        int x=0, y=0;\\n        int dx[]= {1,1,2,2,-1,-1,-2,-2};\\n        int dy[]= {-2,2,1,-1,-2,2,-1,1};\\n        while (i<last){\\n            bool found=0;\\n            for (int it=0; it<8; it++){\\n                int nr= x+dx[it];\\n                int nc= y+dy[it];\\n                if (nr>=0 && nr<n && nc>=0 && nc<m && grid[nr][nc]==(i+1)){\\n                    x= nr; y= nc;\\n                    i++;\\n                    found=1;\\n                }\\n            }\\n            if (i<last && !found)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        if (grid[0][0]!=0)return false;\\n        int n= grid.size(); int m= grid[0].size();\\n        int last= n*m-1;\\n        int i=0;\\n        int x=0, y=0;\\n        int dx[]= {1,1,2,2,-1,-1,-2,-2};\\n        int dy[]= {-2,2,1,-1,-2,2,-1,1};\\n        while (i<last){\\n            bool found=0;\\n            for (int it=0; it<8; it++){\\n                int nr= x+dx[it];\\n                int nc= y+dy[it];\\n                if (nr>=0 && nr<n && nc>=0 && nc<m && grid[nr][nc]==(i+1)){\\n                    x= nr; y= nc;\\n                    i++;\\n                    found=1;\\n                }\\n            }\\n            if (i<last && !found)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363532,
                "title": "simple-bfs-traversal-on-a-2-d-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition behind the problem is that first we have to store the movement of the knight and store it in some data structure i.e 2-D array.\\nhere is the example:\\n![image.png](https://assets.leetcode.com/users/images/2a770b81-b368-4b75-9100-8e533b0bdc74_1680291278.7298694.png)\\n\\n\\n```\\ndir[8][2]={{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};\\n```\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1-> Use BFS to traverse the entire grid.\\n2-> Make a target variable that marks the number of places present ina chess board\\n3-> visit the entire grid in increasing order of target from 0,1,.. to  n * m-1\\n4-> if after the complete BFS traversal target== n * m-1 then return true else return false\\n\\n# Complexity\\n- Time complexity:O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(int x, int y, vector<vector<int>>&grid, int target,int n, int m,vector<int>&vis)\\n    {\\n        if(x>=0 && x<n && y>=0 && y<m && grid[x][y]==target+1 && !vis[grid[x][y]])\\n        return true;\\n        else\\n        return false;\\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int dir[8][2]={{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};\\n        vector<int>vis(n*m,0);\\n        queue<pair<int,int>>q;\\n        int target=0;\\n        q.push({0,0});\\n        vis[grid[0][0]]=1;\\n        while(!q.empty())\\n        {\\n            auto p=q.front();\\n            int r=p.first;\\n            int c=p.second;\\n            q.pop();\\n            vis[grid[r][c]]=1;\\n            for(auto d:dir)\\n            {\\n                int row=r+d[0];\\n                int col=c+d[1];\\n                if(isvalid(row,col,grid,target,n,m,vis))\\n                {\\n                    q.push({row,col});\\n                    vis[grid[row][col]]=1;\\n                    target++;\\n                }\\n            }\\n        }\\n        if(target==n*m-1)\\n        return true;\\n        else\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\ndir[8][2]={{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isvalid(int x, int y, vector<vector<int>>&grid, int target,int n, int m,vector<int>&vis)\\n    {\\n        if(x>=0 && x<n && y>=0 && y<m && grid[x][y]==target+1 && !vis[grid[x][y]])\\n        return true;\\n        else\\n        return false;\\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int dir[8][2]={{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};\\n        vector<int>vis(n*m,0);\\n        queue<pair<int,int>>q;\\n        int target=0;\\n        q.push({0,0});\\n        vis[grid[0][0]]=1;\\n        while(!q.empty())\\n        {\\n            auto p=q.front();\\n            int r=p.first;\\n            int c=p.second;\\n            q.pop();\\n            vis[grid[r][c]]=1;\\n            for(auto d:dir)\\n            {\\n                int row=r+d[0];\\n                int col=c+d[1];\\n                if(isvalid(row,col,grid,target,n,m,vis))\\n                {\\n                    q.push({row,col});\\n                    vis[grid[row][col]]=1;\\n                    target++;\\n                }\\n            }\\n        }\\n        if(target==n*m-1)\\n        return true;\\n        else\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359973,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool helper(int i, int j, vector<vector<int>>& grid, vector<vector<bool>>& vis, int n, int level) {\\n        if(i >= n || j >= n || i < 0 || j < 0 || vis[i][j] || grid[i][j] != level)\\n            return false;\\n        if(grid[i][j] == (n*n)-1)\\n            return true;\\n        vis[i][j] = true;\\n        return helper(i+2, j+1, grid, vis, n, level+1) || helper(i+1, j+2, grid, vis, n, level+1)\\n            || helper(i-2, j-1, grid, vis, n, level+1) || helper(i-1, j-2, grid, vis, n, level+1) \\n            || helper(i+2, j-1, grid, vis, n, level+1) || helper(i-1, j+2, grid, vis, n, level+1) \\n            || helper(i-2, j+1, grid, vis, n, level+1) || helper(i+1, j-2, grid, vis, n, level+1);\\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        return helper(0, 0, grid, vis, n, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(int i, int j, vector<vector<int>>& grid, vector<vector<bool>>& vis, int n, int level) {\\n        if(i >= n || j >= n || i < 0 || j < 0 || vis[i][j] || grid[i][j] != level)\\n            return false;\\n        if(grid[i][j] == (n*n)-1)\\n            return true;\\n        vis[i][j] = true;\\n        return helper(i+2, j+1, grid, vis, n, level+1) || helper(i+1, j+2, grid, vis, n, level+1)\\n            || helper(i-2, j-1, grid, vis, n, level+1) || helper(i-1, j-2, grid, vis, n, level+1) \\n            || helper(i+2, j-1, grid, vis, n, level+1) || helper(i-1, j+2, grid, vis, n, level+1) \\n            || helper(i-2, j+1, grid, vis, n, level+1) || helper(i+1, j-2, grid, vis, n, level+1);\\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        return helper(0, 0, grid, vis, n, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338415,
                "title": "python-2-solutions-move-thourgh-grid-save-the-steps",
                "content": "# Method 1\\nWe save the index of steps, in our moves array, \\nindex0: pos of first step in grid\\nindex1: pos of second step in grid\\nand so on\\n\\nThen we check if the moves are valid or not the absolute value of change in direction can be either (1,2) or (2,1)\\notherwise its an illegal move \\n```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        if(grid[0][0] != 0 ):return False\\n        n = len(grid);\\n        moves = [ 0 for _ in range(0,n*n)]\\n        for i in range(0,n):\\n            for j in range(0,n) :\\n                moves[grid[i][j]] = [i,j]\\n        \\n        prev = [0,0]\\n        for i in range(1,n*n):\\n            if(abs(moves[i][0]-prev[0]) == 1 and abs(moves[i][1]-prev[1]) == 2 ):\\n                prev = moves[i] ;\\n                continue;\\n            elif(abs(moves[i][0]-prev[0]) == 2 and  abs(moves[i][1]-prev[1]) == 1 ):\\n                prev = moves[i]\\n                continue;\\n            else:\\n                return False\\n\\n        return True \\n```\\n\\n\\n# Method 2\\n\\nWe try to check if the direction of the next move is legit, and then we have to store that point and check the next for(n*n-1) times\\n```\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        n = len(grid);\\n        #build directions\\n        direc=[]\\n        a,b = [-2,2],[-1,1]\\n        direc = [(x,y) for x in a for y in b]\\n        direc += [(x,y) for x in b for y in a]\\n        \\n        if(grid[0][0] != 0):return False\\n\\n        prev = [0,0]\\n        step = 0\\n        for i in range(1,n*n):\\n            present = False\\n            for dir in direc:\\n                x = prev[0] + dir[0]\\n                y = prev[1] + dir[1]\\n                if( x>=0 and y>=0 and x<n and y<n and grid[x][y] == step+1 ):\\n                    prev = [x,y]\\n                    step += 1\\n                    present = True\\n                    break;\\n            if(not present ):\\n                return False\\n        return True \\n                 \\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        if(grid[0][0] != 0 ):return False\\n        n = len(grid);\\n        moves = [ 0 for _ in range(0,n*n)]\\n        for i in range(0,n):\\n            for j in range(0,n) :\\n                moves[grid[i][j]] = [i,j]\\n        \\n        prev = [0,0]\\n        for i in range(1,n*n):\\n            if(abs(moves[i][0]-prev[0]) == 1 and abs(moves[i][1]-prev[1]) == 2 ):\\n                prev = moves[i] ;\\n                continue;\\n            elif(abs(moves[i][0]-prev[0]) == 2 and  abs(moves[i][1]-prev[1]) == 1 ):\\n                prev = moves[i]\\n                continue;\\n            else:\\n                return False\\n\\n        return True \\n```\n```\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        n = len(grid);\\n        #build directions\\n        direc=[]\\n        a,b = [-2,2],[-1,1]\\n        direc = [(x,y) for x in a for y in b]\\n        direc += [(x,y) for x in b for y in a]\\n        \\n        if(grid[0][0] != 0):return False\\n\\n        prev = [0,0]\\n        step = 0\\n        for i in range(1,n*n):\\n            present = False\\n            for dir in direc:\\n                x = prev[0] + dir[0]\\n                y = prev[1] + dir[1]\\n                if( x>=0 and y>=0 and x<n and y<n and grid[x][y] == step+1 ):\\n                    prev = [x,y]\\n                    step += 1\\n                    present = True\\n                    break;\\n            if(not present ):\\n                return False\\n        return True \\n                 \\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323097,
                "title": "java-dfs-easy",
                "content": "```\\nclass Solution {\\n\\n    public void solve(int r, int c, int[][] vis, int[][] grid,int currentStep){\\n        if(vis[r][c] == 1)  \\n            return;\\n        \\n        int n = grid.length;\\n        \\n        vis[r][c] = 1;\\n        int ur = r-2, br = r+2, left_col = c-2, right_col = c+2;\\n        if(ur >= 0){\\n            if(c-1 >= 0 && grid[ur][c-1] == currentStep +1 && vis[ur][c-1] == 0)\\n                solve(ur,c-1,vis,grid,currentStep+1);\\n            if(c+1 < n && grid[ur][c+1] == currentStep +1 && vis[ur][c+1] == 0)\\n                solve(ur,c+1,vis,grid,currentStep+1);\\n        }\\n        if(br < n){\\n            if(c-1 >= 0 && grid[br][c-1] == currentStep +1 && vis[br][c-1] == 0)\\n                solve(br,c-1,vis,grid,currentStep+1);\\n            if(c+1 < n && grid[br][c+1] == currentStep +1 && vis[br][c+1] == 0)\\n                solve(br,c+1,vis,grid,currentStep+1);    \\n        }\\n        if(left_col >= 0){\\n            if(r-1 >= 0 && vis[r-1][left_col] ==0 && grid[r-1][left_col] == currentStep +1)\\n                solve(r-1,left_col, vis, grid,currentStep+1);\\n            if(r+1 < n && vis[r+1][left_col] ==0 && grid[r+1][left_col] == currentStep +1)\\n                solve(r+1,left_col, vis, grid,currentStep+1);\\n        }\\n        if(right_col < n ){\\n            if(r-1 >= 0 && vis[r-1][right_col] ==0 && grid[r-1][right_col] == currentStep +1)\\n                solve(r-1,right_col, vis, grid,currentStep+1);\\n            if(r+1 < n && vis[r+1][right_col] ==0 && grid[r+1][right_col] == currentStep +1)\\n                solve(r+1,right_col, vis, grid,currentStep+1);    \\n        }\\n        \\n    }\\n    \\n    public boolean checkValidGrid(int[][] grid) {\\n        int n = grid.length;\\n        int m = n;\\n        int[][] vis =  new int[n][n];\\n        solve(0,0,vis,grid,0);\\n        \\n        for(int i = 0;i < n; i++){\\n            for(int j = 0;j < n ;j++){\\n                if(vis[i][j]==0)\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    public void solve(int r, int c, int[][] vis, int[][] grid,int currentStep){\\n        if(vis[r][c] == 1)  \\n            return;\\n        \\n        int n = grid.length;\\n        \\n        vis[r][c] = 1;\\n        int ur = r-2, br = r+2, left_col = c-2, right_col = c+2;\\n        if(ur >= 0){\\n            if(c-1 >= 0 && grid[ur][c-1] == currentStep +1 && vis[ur][c-1] == 0)\\n                solve(ur,c-1,vis,grid,currentStep+1);\\n            if(c+1 < n && grid[ur][c+1] == currentStep +1 && vis[ur][c+1] == 0)\\n                solve(ur,c+1,vis,grid,currentStep+1);\\n        }\\n        if(br < n){\\n            if(c-1 >= 0 && grid[br][c-1] == currentStep +1 && vis[br][c-1] == 0)\\n                solve(br,c-1,vis,grid,currentStep+1);\\n            if(c+1 < n && grid[br][c+1] == currentStep +1 && vis[br][c+1] == 0)\\n                solve(br,c+1,vis,grid,currentStep+1);    \\n        }\\n        if(left_col >= 0){\\n            if(r-1 >= 0 && vis[r-1][left_col] ==0 && grid[r-1][left_col] == currentStep +1)\\n                solve(r-1,left_col, vis, grid,currentStep+1);\\n            if(r+1 < n && vis[r+1][left_col] ==0 && grid[r+1][left_col] == currentStep +1)\\n                solve(r+1,left_col, vis, grid,currentStep+1);\\n        }\\n        if(right_col < n ){\\n            if(r-1 >= 0 && vis[r-1][right_col] ==0 && grid[r-1][right_col] == currentStep +1)\\n                solve(r-1,right_col, vis, grid,currentStep+1);\\n            if(r+1 < n && vis[r+1][right_col] ==0 && grid[r+1][right_col] == currentStep +1)\\n                solve(r+1,right_col, vis, grid,currentStep+1);    \\n        }\\n        \\n    }\\n    \\n    public boolean checkValidGrid(int[][] grid) {\\n        int n = grid.length;\\n        int m = n;\\n        int[][] vis =  new int[n][n];\\n        solve(0,0,vis,grid,0);\\n        \\n        for(int i = 0;i < n; i++){\\n            for(int j = 0;j < n ;j++){\\n                if(vis[i][j]==0)\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321847,
                "title": "simply-put-chessbord-into-an-array-and-simulate-knight-s-movement",
                "content": "# Code\\n```\\ndef checkValidGrid(self, grid: List[List[int]]) -> bool:\\n    n = len(grid)\\n    arr = [None] * (n*n)\\n    for row in range(n):\\n        for col in range(n):\\n            arr[grid[row][col]] = (row, col)\\n    pos = arr[0]\\n    if pos != (0,0):\\n        return False\\n    for i in range(1, n*n):\\n        a = abs(pos[0] - arr[i][0])\\n        b = abs(pos[1] - arr[i][1])\\n        if a == 1 and b == 2 or a == 2 and b == 1:\\n            pos = arr[i]\\n        else:\\n            return False\\n    return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef checkValidGrid(self, grid: List[List[int]]) -> bool:\\n    n = len(grid)\\n    arr = [None] * (n*n)\\n    for row in range(n):\\n        for col in range(n):\\n            arr[grid[row][col]] = (row, col)\\n    pos = arr[0]\\n    if pos != (0,0):\\n        return False\\n    for i in range(1, n*n):\\n        a = abs(pos[0] - arr[i][0])\\n        b = abs(pos[1] - arr[i][1])\\n        if a == 1 and b == 2 or a == 2 and b == 1:\\n            pos = arr[i]\\n        else:\\n            return False\\n    return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3321200,
                "title": "easy-c-store-coordinates-in-a-vector-of-pairs",
                "content": "# Intuition\\nIntution behind this approach is to store the coordinates where all the elements lie from 0 to n*n-1 and then to iterate all the elements 0 to n*n-1 and checking if the previous coordinate is 2+1 away from this coordinate or not. if not, return false.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n O(p+n) where p=n*n-1\\n\\n- Space complexity:\\nO(p)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int p=n*n-1;\\n\\n        if(grid[0][0]!=0) return 0;\\n\\n        vector<pair<int,int>> v(p+1);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++) v[grid[i][j]]={i,j};\\n        }\\n\\n        bool flag=0;\\n        for(int i=1;i<=p;i++)\\n        {\\n            \\n            if(!((abs(v[i].first-v[i-1].first)==2 && abs(v[i].second-v[i-1].second)==1)) && !((abs(v[i].first-v[i-1].first)==1 && abs(v[i].second-v[i-1].second)==2))) {flag=1; break;}\\n        }\\n        return flag==0;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int p=n*n-1;\\n\\n        if(grid[0][0]!=0) return 0;\\n\\n        vector<pair<int,int>> v(p+1);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++) v[grid[i][j]]={i,j};\\n        }\\n\\n        bool flag=0;\\n        for(int i=1;i<=p;i++)\\n        {\\n            \\n            if(!((abs(v[i].first-v[i-1].first)==2 && abs(v[i].second-v[i-1].second)==1)) && !((abs(v[i].first-v[i-1].first)==1 && abs(v[i].second-v[i-1].second)==2))) {flag=1; break;}\\n        }\\n        return flag==0;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316834,
                "title": "checking-validity-of-knight-s-tour-on-a-grid-using-backtracking-algorithm",
                "content": "# Approach\\nThe solution uses a DFS approach to check whether a given grid represents a valid configuration of a knight\\'s tour. We start by checking if the first square of the grid is 0, as the knight starts at the first square. Then, we use a recursive helper function solve that takes in the current count of squares visited, the current grid configuration, and the current row and column position of the knight.\\n\\nThe base case is when we have visited all squares, and we return true. Otherwise, we check if we can make a valid move to any of the adjacent squares, following the rules of a knight\\'s move. If we can make a valid move, we update the current position of the knight and call the solve function recursively. If the recursive call returns false, we undo the move by setting the current position to the previous position and continue checking for other valid moves. If we cannot make a valid move, we return false.\\n\\nWe can use a helper function is_valid to check if a given move is a valid move. The function takes in the current row and column position, the size of the grid, the current count, and the current grid configuration. The function checks if the move is within the bounds of the grid and if the square we are moving to has not been visited before. If both conditions are satisfied, we return the new row and column position. Otherwise, we return (-1,-1), indicating that the move is invalid.\\n\\n# Complexity\\n- Time complexity: The time complexity of the solution is O(N^2 * 8^(N^2)), where N is the size of the grid. The worst-case scenario occurs when we have to explore all possible paths in the DFS tree. For each square, we have a maximum of 8 possible moves. Therefore, the total number of possible paths is 8^(N^2). The outer loop to iterate through each square of the grid takes O(N^2) time. Therefore, the total time complexity is O(N^2 * 8^(N^2)).\\n\\n\\n- Space complexity: The space complexity of the solution is O(N^2), where N is the size of the grid. The space is used to store the current grid configuration and the call stack used in the recursive function.\\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n     vector<int> is_valid(int row,int col,int n,int target,vector<vector<int>>grid){\\n        vector<pair<int,int>> moves = {{1,2}, {2,1}, {2,-1}, {1,-2}, {-1,-2}, {-2,-1}, {-2,1}, {-1,2}};\\n       for(auto itr:moves){\\n        int row_temp = itr.first + row;\\n        int col_temp = itr.second + col;\\n        if((row_temp >= 0 && row_temp <= n) && (col_temp >=0 && col_temp <= n) && grid[row_temp][col_temp] == target){\\n            return {row_temp,col_temp};\\n        }\\n       }\\n        return {-1,-1};\\n\\n    }\\n    bool solve(int count,vector<vector<int>>& grid,int i,int row,int col){\\n        if((count*count-1) == grid[row][col]){\\n            return true;\\n        }\\n        else{\\n            vector<int> temp;\\n            temp = is_valid(row,col,grid.size()-1,i+1,grid);\\n            cout<<grid[row][col]<<\" \"<<i<<endl;\\n            col = temp[1]; row = temp[0];\\n            if(row == -1 && col == -1){\\n                return false;\\n            }\\n            return solve(grid.size(),grid,i+1,row,col);\\n        }\\n    } \\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n         if(grid[0][0] !=0)return false;\\n         return solve(grid.size(),grid,0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n     vector<int> is_valid(int row,int col,int n,int target,vector<vector<int>>grid){\\n        vector<pair<int,int>> moves = {{1,2}, {2,1}, {2,-1}, {1,-2}, {-1,-2}, {-2,-1}, {-2,1}, {-1,2}};\\n       for(auto itr:moves){\\n        int row_temp = itr.first + row;\\n        int col_temp = itr.second + col;\\n        if((row_temp >= 0 && row_temp <= n) && (col_temp >=0 && col_temp <= n) && grid[row_temp][col_temp] == target){\\n            return {row_temp,col_temp};\\n        }\\n       }\\n        return {-1,-1};\\n\\n    }\\n    bool solve(int count,vector<vector<int>>& grid,int i,int row,int col){\\n        if((count*count-1) == grid[row][col]){\\n            return true;\\n        }\\n        else{\\n            vector<int> temp;\\n            temp = is_valid(row,col,grid.size()-1,i+1,grid);\\n            cout<<grid[row][col]<<\" \"<<i<<endl;\\n            col = temp[1]; row = temp[0];\\n            if(row == -1 && col == -1){\\n                return false;\\n            }\\n            return solve(grid.size(),grid,i+1,row,col);\\n        }\\n    } \\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n         if(grid[0][0] !=0)return false;\\n         return solve(grid.size(),grid,0,0,0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3316372,
                "title": "faster-than-100-simple-solution-using-dfs-traversal",
                "content": "```\\nclass Solution {\\n    private void dfs(int[][] grid,boolean[][] vis,int[] xdirs,int[] ydirs,int x,int y,int c){\\n        \\n        int n=grid.length;\\n        \\n        vis[x][y]=true;\\n        c++;\\n        \\n        for(int i=0;i<xdirs.length;i++){\\n            \\n            int newX=x+xdirs[i];\\n            int newY=y+ydirs[i];\\n            \\n            if(newX>=n || newY>=n || newX<0 || newY<0 || vis[newX][newY] || grid[newX][newY]!=c)   continue;\\n            \\n            dfs(grid,vis,xdirs,ydirs,newX,newY,c);\\n        }\\n        \\n    }\\n    public boolean checkValidGrid(int[][] grid) {\\n        \\n        int[] xdirs = {-2,-2,2,2,-1,-1,1,1};\\n        int[] ydirs = {-1,1,-1,1,-2,2,-2,2};\\n        \\n        int n=grid.length;\\n        \\n        boolean[][] vis = new boolean[n][n];\\n        \\n        dfs(grid,vis,xdirs,ydirs,0,0,0);\\n        \\n        //if any block remains unvisited we will return false\\n        for(boolean[] arr:vis){\\n            for(boolean it:arr){\\n                if(!it)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    private void dfs(int[][] grid,boolean[][] vis,int[] xdirs,int[] ydirs,int x,int y,int c){\\n        \\n        int n=grid.length;\\n        \\n        vis[x][y]=true;\\n        c++;\\n        \\n        for(int i=0;i<xdirs.length;i++){\\n            \\n            int newX=x+xdirs[i];\\n            int newY=y+ydirs[i];\\n            \\n            if(newX>=n || newY>=n || newX<0 || newY<0 || vis[newX][newY] || grid[newX][newY]!=c)   continue;\\n            \\n            dfs(grid,vis,xdirs,ydirs,newX,newY,c);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3316003,
                "title": "c-dfs-easy-solution",
                "content": "# Intuition\\n**Please Upvote if you like the Solution**\\n\\n Intuition it to visited every cell by knight movement in grid and  at last to check that every cell is visited or not.\\n\\n# Approach\\n 1) Visiting to the every possible Cell by knight movement using DFS and marking its as visited in separate Visited array.\\n\\n 2) Checking that the every cell of Visited[][] array is visited or not. If isn\\'t we simply return false otherwise true.\\n\\n# Complexity\\n- Time complexity:\\n  O(n^2)\\n\\n- Space complexity:\\n  O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void check(vector<vector<int>>& grid,vector<vector<bool>> &visited,int i,int j, int prev){\\n     if(i < 0 || i >= grid.size() || j < 0 || j >= grid.size() || grid[i][j] != prev) return;\\n     \\n     int dx[] = {-2,-2,-1,-1,1,1,2,2}; // array for knight movements\\n     int dy[] = {-1,1,-2,2,-2,2,-1,1};\\n     \\n     for(int k=0;k<8;k++){\\n       \\n      if(prev == grid[i][j]){  // prev (variable) to keep the track of the previously visited cell. if its equal to grid[i][j] visited it or skip it. \\n       visited[i][j] = true;\\n       check(grid,visited,i+dx[k],j+dy[k],grid[i][j]+1);\\n     }\\n       \\n     }\\n     \\n     return;\\n\\n   }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n       vector<vector<bool>> visited(n,vector<bool>(n,false));\\n       check(grid,visited,0,0,grid[0][0]);\\n      \\n      for(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){ // checking every cell is visited or not\\n          if(visited[i][j] == false) return false;\\n        } \\n      }\\n      \\n      return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void check(vector<vector<int>>& grid,vector<vector<bool>> &visited,int i,int j, int prev){\\n     if(i < 0 || i >= grid.size() || j < 0 || j >= grid.size() || grid[i][j] != prev) return;\\n     \\n     int dx[] = {-2,-2,-1,-1,1,1,2,2}; // array for knight movements\\n     int dy[] = {-1,1,-2,2,-2,2,-1,1};\\n     \\n     for(int k=0;k<8;k++){\\n       \\n      if(prev == grid[i][j]){  // prev (variable) to keep the track of the previously visited cell. if its equal to grid[i][j] visited it or skip it. \\n       visited[i][j] = true;\\n       check(grid,visited,i+dx[k],j+dy[k],grid[i][j]+1);\\n     }\\n       \\n     }\\n     \\n     return;\\n\\n   }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n       vector<vector<bool>> visited(n,vector<bool>(n,false));\\n       check(grid,visited,0,0,grid[0][0]);\\n      \\n      for(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){ // checking every cell is visited or not\\n          if(visited[i][j] == false) return false;\\n        } \\n      }\\n      \\n      return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315968,
                "title": "java-recursion",
                "content": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{-2, 1}, {-2, -1}, {-1, 2}, {1, 2}, {2, -1}, {2, 1}, {-1, -2}, {1, -2}};\\n    public boolean checkValidGrid(int[][] grid) {\\n        if (grid[0][0] != 0) {\\n            return false;\\n        }\\n        return backtracking(grid, 0, 0, 0);\\n    }\\n    \\n    public boolean backtracking(int[][] g, int r, int c, int currVal) {\\n        if (g.length * g[0].length - 1 == g[r][c]) {\\n            return true;\\n        }\\n        for (int[] d : dirs) {\\n            int nr = d[0] + r;\\n            int nc = d[1] + c;\\n            if (nr >= 0 && nc >= 0 && nr < g.length && nc < g[0].length) {\\n                //  inside the grid\\n                if (currVal + 1 == g[nr][nc]) {\\n                    return backtracking(g, nr, nc, g[nr][nc]);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int[][] dirs = new int[][]{{-2, 1}",
                "codeTag": "Java"
            },
            {
                "id": 3315662,
                "title": "easy-cpp-solution-o-n-2-time-o-n-2-space-no-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBasically, we need to maintain a vector of pairs or a 2D vector(its your choice) to store the coordinates of $$grid[i][j]th$$ knight. Then, we run a loop from $$i = 1$$ to $$i = n*n$$. In each iteration, $$i-1$$ is the starting position(*from*) of the knight and $$i$$ is the ending position(*to*). We check the absolute difference of x-coordinates and y-coordinates. These should be $${1,2}$$ or $${2,1}$$ which means their product is 2. So, if they won\\'t satisfy this condition we return false right away, otherwise we return true after the end of the loop.\\n\\n# Complexity\\n- Time complexity:\\nStoring the coordinates takes $$n^2$$ time and checking the positions of each pair of consecutive knights takes $$n^2$$ time. So asymptotically we can say the time complexity is $$O(n^2)$$\\n\\n- Space complexity:\\nWe just use an extra vector of pairs, which use $$2*n^2$$ space. We can round it off to $$n^2$$. So, space complexity is also $$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(grid[0][0] != 0) return false;\\n        pair<int,int> m[n*n];\\n        //Storing the coordinates\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                m[grid[i][j]] = {i,j};\\n            }\\n        }\\n        for(int i = 1; i < n*n; i++){\\n            //from position\\n            int from_x = m[i-1].first, from_y = m[i-1].second;\\n            //to position\\n            int to_x = m[i].first, to_y = m[i].second;\\n            int x_dif = abs(from_x - to_x), y_dif = abs(from_y - to_y);\\n            //failed condition\\n            if(x_dif * y_dif != 2) return false;\\n        }\\n        //there was no anomalies in the movements of the knight\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(grid[0][0] != 0) return false;\\n        pair<int,int> m[n*n];\\n        //Storing the coordinates\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                m[grid[i][j]] = {i,j};\\n            }\\n        }\\n        for(int i = 1; i < n*n; i++){\\n            //from position\\n            int from_x = m[i-1].first, from_y = m[i-1].second;\\n            //to position\\n            int to_x = m[i].first, to_y = m[i].second;\\n            int x_dif = abs(from_x - to_x), y_dif = abs(from_y - to_y);\\n            //failed condition\\n            if(x_dif * y_dif != 2) return false;\\n        }\\n        //there was no anomalies in the movements of the knight\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315634,
                "title": "restricted-bfs",
                "content": "# Intuition\\nBFS on the cells. At every cell we maintain the value of the next step and check if we are able to reach there. For ex, from 1, we should be able reach a value 2 from the permitted 8 steps. Since the numbers are distinct we are able to say that we will be reaching exactly one state always, if we able to reach the next number, continue the bfs only from that node. \\nFurther optimisation can be to remove queue altogether as queue will always contain only 1 cell at max at any given time making space complexity O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid (int x, int y, int n, int m) {\\n        if (x >= n || y >= m || x < 0 || y < 0) return false;\\n        return true;\\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue <pair<int, int>> q;\\n        int move = 1;\\n        vector <int> dx = { 2, 2, -2, -2, 1, 1, -1, -1 };\\n        vector <int> dy = { 1, -1, 1, -1, 2, -2, 2, -2 };\\n        q.push({0, 0});\\n        while (q.size() > 0) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                pair <int, int> top = q.front();\\n                q.pop();\\n                int x = top.first;\\n                int y = top.second;\\n                for (int j = 0; j < 8; j++) {\\n                    int newX = x + dx[j];\\n                    int newY = y + dy[j];\\n                    if (isValid(newX, newY, n, m) and grid[newX][newY] == move) {\\n                        if (move == n * m - 1) return true;\\n                        ++move;\\n                        q.push(make_pair(newX, newY));\\n                        break;\\n                    }\\n                    if (q.size() > 0) break;\\n                }\\n                if (q.size() == 0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid (int x, int y, int n, int m) {\\n        if (x >= n || y >= m || x < 0 || y < 0) return false;\\n        return true;\\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue <pair<int, int>> q;\\n        int move = 1;\\n        vector <int> dx = { 2, 2, -2, -2, 1, 1, -1, -1 };\\n        vector <int> dy = { 1, -1, 1, -1, 2, -2, 2, -2 };\\n        q.push({0, 0});\\n        while (q.size() > 0) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                pair <int, int> top = q.front();\\n                q.pop();\\n                int x = top.first;\\n                int y = top.second;\\n                for (int j = 0; j < 8; j++) {\\n                    int newX = x + dx[j];\\n                    int newY = y + dy[j];\\n                    if (isValid(newX, newY, n, m) and grid[newX][newY] == move) {\\n                        if (move == n * m - 1) return true;\\n                        ++move;\\n                        q.push(make_pair(newX, newY));\\n                        break;\\n                    }\\n                    if (q.size() > 0) break;\\n                }\\n                if (q.size() == 0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315390,
                "title": "bfs-c",
                "content": "class Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>>vis(grid.size(),vector<int>(grid[0].size(),0));\\n        int cur=1;\\n        int n=grid.size(),m=grid[0].size();\\n        \\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        vis[0][0]=1;\\n        int drow[]={-2,-2,-1,1,2,2,1,-1};\\n        int dcol[]={-1,1,2,2,1,-1,-2,-2};\\n        \\n        while(q.size())\\n        {\\n           int x=q.front().first;\\n           int y=q.front().second;\\n           q.pop();\\n           \\n           for(int i=0;i<8;i++)\\n           {\\n               int nrow=x+drow[i],ncol=y+dcol[i];\\n               \\n               if(nrow>=0 && ncol>=0 && nrow<n && ncol<n && !vis[nrow][ncol] && grid[nrow][ncol]==cur)\\n               {\\n                   \\n                   q.push({nrow,ncol});\\n                   cur++;\\n                   vis[nrow][ncol]=1;\\n               }\\n           }\\n            \\n        }\\n        \\n        cout<<cur;\\n        if(cur==n*n) return true;\\n        return false;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>>vis(grid.size(),vector<int>(grid[0].size(),0));\\n        int cur=1;\\n        int n=grid.size(),m=grid[0].size();\\n        \\n        queue<pair<int,int>>q;\\n        q.push({0,0}",
                "codeTag": "Java"
            },
            {
                "id": 3315343,
                "title": "very-simple-recursion-c-with-explanation",
                "content": "# Intuition\\nn is from 3 to 7. Why not use bruteforce (all possibilities explore)\\n\\n# Approach\\nCheck for 0,0 at the start.\\nNow there are 8 directions to go. Explore everyone and if valid config then it is guaranteed to get an ans from exactly 1 of these 8. \\nKeep on doing this recursively.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calc(vector<vector<int>>& a,int n,int i,int j,int cnt)\\n    {\\n        if(i>=n || j>=n || i<0 || j<0)return 0;\\n        if(a[i][j]==cnt)\\n        {\\n            if(cnt==n*n-1)return 1;\\n            int ul=calc(a,n,i-2,j-1,cnt+1);\\n            int ur=calc(a,n,i-2,j+1,cnt+1);\\n            int lu=calc(a,n,i-1,j-2,cnt+1);\\n            int ld=calc(a,n,i+1,j-2,cnt+1);\\n            int dl=calc(a,n,i+2,j-1,cnt+1);\\n            int dr=calc(a,n,i+2,j+1,cnt+1);\\n            int ru=calc(a,n,i-1,j+2,cnt+1);\\n            int rd=calc(a,n,i+1,j+2,cnt+1);\\n            return 1&(ul || ur || lu || ld || dl || dr || ru || rd);\\n        }\\n        else return 0;\\n    }\\n    bool checkValidGrid(vector<vector<int>>& a) {\\n        if(a[0][0]!=0)return false;\\n        int n=a.size();\\n        return calc(a,n,0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calc(vector<vector<int>>& a,int n,int i,int j,int cnt)\\n    {\\n        if(i>=n || j>=n || i<0 || j<0)return 0;\\n        if(a[i][j]==cnt)\\n        {\\n            if(cnt==n*n-1)return 1;\\n            int ul=calc(a,n,i-2,j-1,cnt+1);\\n            int ur=calc(a,n,i-2,j+1,cnt+1);\\n            int lu=calc(a,n,i-1,j-2,cnt+1);\\n            int ld=calc(a,n,i+1,j-2,cnt+1);\\n            int dl=calc(a,n,i+2,j-1,cnt+1);\\n            int dr=calc(a,n,i+2,j+1,cnt+1);\\n            int ru=calc(a,n,i-1,j+2,cnt+1);\\n            int rd=calc(a,n,i+1,j+2,cnt+1);\\n            return 1&(ul || ur || lu || ld || dl || dr || ru || rd);\\n        }\\n        else return 0;\\n    }\\n    bool checkValidGrid(vector<vector<int>>& a) {\\n        if(a[0][0]!=0)return false;\\n        int n=a.size();\\n        return calc(a,n,0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315318,
                "title": "easy-to-understand-clear-explanation",
                "content": "```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        // Check if the top-left cell is 0. If not, return false.\\n        if (grid[0][0] != 0) {\\n            return false;\\n        }\\n        \\n        // Calculate the total number of cells in the grid.\\n        int n = grid.length * grid.length;\\n        \\n        // Define the directions to move in the grid.\\n        int dirs[][] = {{1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}};\\n        \\n        // Initialize the current position to (0, 0).\\n        int x = 0, y = 0;\\n        \\n        // Loop through all the cells in the grid.\\n        for (int i = 1; i < n; i++) {\\n            // Set a flag to indicate if a valid move was made.\\n            boolean flag = true;\\n            \\n            // Try each of the 8 possible moves in turn.\\n            for (int dir[] : dirs) {\\n                int nx = x + dir[0];\\n                int ny = y + dir[1];\\n                \\n                // Check if the move is within the bounds of the grid and leads to the next number in sequence.\\n                if (nx >= 0 && ny >= 0 && nx < grid.length && ny < grid.length && grid[nx][ny] == i) {\\n                    x = nx;\\n                    y = ny;\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            // If no valid move was made, return false.\\n            if (flag) {\\n                return false;\\n            }\\n        }\\n        \\n        // If all cells were visited in sequence, return true.\\n        return true;\\n    }\\n}\\n```\\n# Do UpVote Guys",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        // Check if the top-left cell is 0. If not, return false.\\n        if (grid[0][0] != 0) {\\n            return false;\\n        }\\n        \\n        // Calculate the total number of cells in the grid.\\n        int n = grid.length * grid.length;\\n        \\n        // Define the directions to move in the grid.\\n        int dirs[][] = {{1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}};\\n        \\n        // Initialize the current position to (0, 0).\\n        int x = 0, y = 0;\\n        \\n        // Loop through all the cells in the grid.\\n        for (int i = 1; i < n; i++) {\\n            // Set a flag to indicate if a valid move was made.\\n            boolean flag = true;\\n            \\n            // Try each of the 8 possible moves in turn.\\n            for (int dir[] : dirs) {\\n                int nx = x + dir[0];\\n                int ny = y + dir[1];\\n                \\n                // Check if the move is within the bounds of the grid and leads to the next number in sequence.\\n                if (nx >= 0 && ny >= 0 && nx < grid.length && ny < grid.length && grid[nx][ny] == i) {\\n                    x = nx;\\n                    y = ny;\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            // If no valid move was made, return false.\\n            if (flag) {\\n                return false;\\n            }\\n        }\\n        \\n        // If all cells were visited in sequence, return true.\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314897,
                "title": "c-bfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        queue<pair<pair<int, int>, int>>q;\\n        vector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n        q.push({{0, 0}, 0});\\n        v[0][0]=1;\\n        int num=grid.size()*grid.size()-1;\\n        while(!q.empty()){\\n            int x=q.front().first.first, y=q.front().first.second, cnt=q.front().second;\\n            if(cnt==num){\\n                break;\\n            }\\n            cnt+=1;\\n            cout<<x<<\" \"<<y<<\" \"<<cnt<<endl;\\n            \\n            q.pop();\\n            if(x>1 && y>0 && !v[x-2][y-1] && grid[x-2][y-1]==cnt){\\n                v[x-2][y-1]=1;\\n                q.push({{x-2, y-1}, cnt});\\n            }\\n            else if(x>1 && y<grid[0].size()-1 && !v[x-2][y+1] && grid[x-2][y+1]==cnt){\\n                v[x-2][y+1]=1;\\n                q.push({{x-2, y+1}, cnt});\\n            }\\n            else if(x>0 && y>1 && !v[x-1][y-2] && grid[x-1][y-2]==cnt){\\n                v[x-1][y-2]=1;\\n                q.push({{x-1, y-2}, cnt});\\n            }\\n            else if(x>0 && y<grid[0].size()-2 && !v[x-1][y+2] && grid[x-1][y+2]==cnt){\\n                v[x-1][y+2]=1;\\n                q.push({{x-1, y+2}, cnt});\\n            }\\n            else if(x<grid.size()-1 && y>1 && !v[x+1][y-2] && grid[x+1][y-2]==cnt){\\n                v[x+1][y-2]=1;\\n                q.push({{x+1, y-2}, cnt});\\n            }\\n            else if(x<grid.size()-1 && y<grid[0].size()-2 && !v[x+1][y+2] && grid[x+1][y+2]==cnt){\\n                v[x+1][y+2]=1;\\n                q.push({{x+1, y+2}, cnt});\\n            }\\n            else if(x<grid.size()-2 && y<grid[0].size()-1 && !v[x+2][y+1] && grid[x+2][y+1]==cnt){\\n                v[x+2][y+1]=1;\\n                q.push({{x+2, y+1}, cnt});\\n            }\\n            else if(x<grid.size()-2 && y>0 && !v[x+2][y-1] && grid[x+2][y-1]==cnt){\\n                v[x+2][y-1]=1;\\n                q.push({{x+2, y-1}, cnt});\\n            }\\n            else{\\n                cout<<x<<\" \"<<y<<endl;\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        queue<pair<pair<int, int>, int>>q;\\n        vector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n        q.push({{0, 0}, 0});\\n        v[0][0]=1;\\n        int num=grid.size()*grid.size()-1;\\n        while(!q.empty()){\\n            int x=q.front().first.first, y=q.front().first.second, cnt=q.front().second;\\n            if(cnt==num){\\n                break;\\n            }\\n            cnt+=1;\\n            cout<<x<<\" \"<<y<<\" \"<<cnt<<endl;\\n            \\n            q.pop();\\n            if(x>1 && y>0 && !v[x-2][y-1] && grid[x-2][y-1]==cnt){\\n                v[x-2][y-1]=1;\\n                q.push({{x-2, y-1}, cnt});\\n            }\\n            else if(x>1 && y<grid[0].size()-1 && !v[x-2][y+1] && grid[x-2][y+1]==cnt){\\n                v[x-2][y+1]=1;\\n                q.push({{x-2, y+1}, cnt});\\n            }\\n            else if(x>0 && y>1 && !v[x-1][y-2] && grid[x-1][y-2]==cnt){\\n                v[x-1][y-2]=1;\\n                q.push({{x-1, y-2}, cnt});\\n            }\\n            else if(x>0 && y<grid[0].size()-2 && !v[x-1][y+2] && grid[x-1][y+2]==cnt){\\n                v[x-1][y+2]=1;\\n                q.push({{x-1, y+2}, cnt});\\n            }\\n            else if(x<grid.size()-1 && y>1 && !v[x+1][y-2] && grid[x+1][y-2]==cnt){\\n                v[x+1][y-2]=1;\\n                q.push({{x+1, y-2}, cnt});\\n            }\\n            else if(x<grid.size()-1 && y<grid[0].size()-2 && !v[x+1][y+2] && grid[x+1][y+2]==cnt){\\n                v[x+1][y+2]=1;\\n                q.push({{x+1, y+2}, cnt});\\n            }\\n            else if(x<grid.size()-2 && y<grid[0].size()-1 && !v[x+2][y+1] && grid[x+2][y+1]==cnt){\\n                v[x+2][y+1]=1;\\n                q.push({{x+2, y+1}, cnt});\\n            }\\n            else if(x<grid.size()-2 && y>0 && !v[x+2][y-1] && grid[x+2][y-1]==cnt){\\n                v[x+2][y-1]=1;\\n                q.push({{x+2, y-1}, cnt});\\n            }\\n            else{\\n                cout<<x<<\" \"<<y<<endl;\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3314609,
                "title": "fastest-simple-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0]!=0) return false;\\n        int n = grid.length;\\n        Map<Integer, List<Integer>> map = new HashMap<Integer, List<Integer>>();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                 map.put(grid[i][j], new ArrayList<Integer>(Arrays.asList(i,j)));\\n            }\\n        }\\n        for(int i=1;i<n*n;i++)\\n        {\\n            if(((Math.abs(map.get(i).get(0)-map.get(i-1).get(0))==2) && (Math.abs(map.get(i).get(1)-map.get(i-1).get(1))==1)) || ((Math.abs(map.get(i).get(0)-map.get(i-1).get(0))==1) && (Math.abs(map.get(i).get(1)-map.get(i-1).get(1))==2))){\\n               \\n            }\\n            else  return false;\\n                \\n        }\\n        System.out.println(map);\\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0]!=0) return false;\\n        int n = grid.length;\\n        Map<Integer, List<Integer>> map = new HashMap<Integer, List<Integer>>();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                 map.put(grid[i][j], new ArrayList<Integer>(Arrays.asList(i,j)));\\n            }\\n        }\\n        for(int i=1;i<n*n;i++)\\n        {\\n            if(((Math.abs(map.get(i).get(0)-map.get(i-1).get(0))==2) && (Math.abs(map.get(i).get(1)-map.get(i-1).get(1))==1)) || ((Math.abs(map.get(i).get(0)-map.get(i-1).get(0))==1) && (Math.abs(map.get(i).get(1)-map.get(i-1).get(1))==2))){\\n               \\n            }\\n            else  return false;\\n                \\n        }\\n        System.out.println(map);\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314552,
                "title": "bfs-easiest-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<pair<int,int>,int>> q;\\n        int steps=0;\\n        q.push({{0,0},0});\\n        while(!q.empty()){\\n         \\n          \\n            int p=q.front().first.first;\\n            int r=q.front().first.second;\\n             steps=q.front().second;\\n            q.pop();\\n     //to check the possible directions\\n            int X[8] = { 2, 1, -1, -2, -2, -1, 1, 2 };\\n             int Y[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n    \\n               for (int i = 0; i < 8; i++) {\\n \\n       \\n                      int x = p + X[i];\\n                        int y = r + Y[i];\\n \\n        \\n        if (x >= 0 && y >= 0 && x < n && y < m)\\n           if(grid[x][y]==steps+1){\\n               q.push({{x,y},steps+1});\\n              \\n           }\\n    }\\n           \\n        }\\n        \\n        if(steps== n*m -1) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<pair<int,int>,int>> q;\\n        int steps=0;\\n        q.push({{0,0},0});\\n        while(!q.empty()){\\n         \\n          \\n            int p=q.front().first.first;\\n            int r=q.front().first.second;\\n             steps=q.front().second;\\n            q.pop();\\n     //to check the possible directions\\n            int X[8] = { 2, 1, -1, -2, -2, -1, 1, 2 };\\n             int Y[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n    \\n               for (int i = 0; i < 8; i++) {\\n \\n       \\n                      int x = p + X[i];\\n                        int y = r + Y[i];\\n \\n        \\n        if (x >= 0 && y >= 0 && x < n && y < m)\\n           if(grid[x][y]==steps+1){\\n               q.push({{x,y},steps+1});\\n              \\n           }\\n    }\\n           \\n        }\\n        \\n        if(steps== n*m -1) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314516,
                "title": "knight-tour-dp-recursion-99-94-beats-runtime-1ms",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDp using recusion:\\nonly visiting the vertices which are not visited and correct move of Knight (ie. expanding only the correct moves which are not visited)\\n\\n# Approach\\n- Initializing visited boolean array \\n- from starting vertex (ie. nums[0][0]) recursively visiting the non-visited vertices and the correct move of Knight and marking vertex as visited (ie.visited[v1][v2]==true).\\n\\nif atleast one vertex is not visited(ie. !visited[i][j]) then return false, other then return true\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    static void isValid(int grid[][],boolean visited[][],int v1,int v2,int move,int r,int c){\\n        if(v1<0 || v2<0 ||v1>=r || v2>=c)return;\\n        if(!visited[v1][v2]&& grid[v1][v2]==move ){\\n            visited[v1][v2]=true;\\n            isValid(grid,visited,v1+1,v2+2,move+1,r,c);\\n            isValid(grid,visited,v1+1,v2-2,move+1,r,c);\\n            isValid(grid,visited,v1-1,v2+2,move+1,r,c);\\n            isValid(grid,visited,v1-1,v2-2,move+1,r,c);\\n            \\n            isValid(grid,visited,v1+2,v2+1,move+1,r,c);\\n            isValid(grid,visited,v1-2,v2+1,move+1,r,c);\\n            isValid(grid,visited,v1+2,v2-1,move+1,r,c);\\n            isValid(grid,visited,v1-2,v2-1,move+1,r,c);\\n        }\\n        }\\n        \\n    \\n    public boolean checkValidGrid(int[][] grid) {\\n        int r=grid.length,c=grid[0].length;\\n        boolean visited[][]=new boolean[r][c];\\n        isValid(grid,visited,0,0,0,r,c);\\n        for(int i=0;i<r;i++)\\n            for(int j=0;j<c;j++)\\n                if(!visited[i][j])return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    static void isValid(int grid[][],boolean visited[][],int v1,int v2,int move,int r,int c){\\n        if(v1<0 || v2<0 ||v1>=r || v2>=c)return;\\n        if(!visited[v1][v2]&& grid[v1][v2]==move ){\\n            visited[v1][v2]=true;\\n            isValid(grid,visited,v1+1,v2+2,move+1,r,c);\\n            isValid(grid,visited,v1+1,v2-2,move+1,r,c);\\n            isValid(grid,visited,v1-1,v2+2,move+1,r,c);\\n            isValid(grid,visited,v1-1,v2-2,move+1,r,c);\\n            \\n            isValid(grid,visited,v1+2,v2+1,move+1,r,c);\\n            isValid(grid,visited,v1-2,v2+1,move+1,r,c);\\n            isValid(grid,visited,v1+2,v2-1,move+1,r,c);\\n            isValid(grid,visited,v1-2,v2-1,move+1,r,c);\\n        }\\n        }\\n        \\n    \\n    public boolean checkValidGrid(int[][] grid) {\\n        int r=grid.length,c=grid[0].length;\\n        boolean visited[][]=new boolean[r][c];\\n        isValid(grid,visited,0,0,0,r,c);\\n        for(int i=0;i<r;i++)\\n            for(int j=0;j<c;j++)\\n                if(!visited[i][j])return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314435,
                "title": "easy-solution-with-proper-explanation",
                "content": "\\n# Approach\\n- So here first we stored all the indexes of number in hashmap by using ArrayList.\\n- Then created a function where we can find the possible position that a knight can move from the current possition \\n- If row and column of matches with the next move that means it is possible to go to the next number.\\n- It continues and if any condition failed return false otherwise true.\\n - varibale c is used to count the number of elements visited beacuse the number in top left can be different from 0 also so it can help in keep the track.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isvalid(int x , int y , int x1 , int y1,int[][]grid)\\n    {\\n           int[][] moves = {\\n            {2, 1},\\n            {1, 2},\\n            {-1, 2},\\n            {-2, 1},\\n            {-2, -1},\\n            {-1, -2},\\n            {1, -2},\\n            {2, -1}\\n        };\\n        \\n         for (int[] move : moves) {\\n            int nextX = x + move[0];\\n            int nextY = y + move[1];\\n            \\n            if (nextX >= 0 && nextY >= 0 && nextX < grid.length && nextY < grid.length) {\\n                if(nextX==x1 && nextY==y1)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    public boolean checkValidGrid(int[][] grid) {\\n      \\n        HashMap<Integer , List<Integer> > map = new HashMap<>();\\n        int n = grid.length;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                List<Integer> li = new ArrayList<>();\\n                li.add(i);\\n                li.add(j);\\n                map.put(grid[i][j],li);\\n            }\\n        }\\n        int pre1=0;\\n        int pre2=0;\\n        int c=0;\\n        for(int i = grid[0][0]+1 ; i < n*n ; i++ )\\n        { \\n            c++;\\n            List<Integer> pre = map.get(i-1);\\n            List<Integer> ans = map.get(i);\\n            if(isvalid(pre.get(0),pre.get(1),ans.get(0),ans.get(1),grid)==false)\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        if(c==n*n-1)\\n        return true;\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isvalid(int x , int y , int x1 , int y1,int[][]grid)\\n    {\\n           int[][] moves = {\\n            {2, 1},\\n            {1, 2},\\n            {-1, 2},\\n            {-2, 1},\\n            {-2, -1},\\n            {-1, -2},\\n            {1, -2},\\n            {2, -1}\\n        };\\n        \\n         for (int[] move : moves) {\\n            int nextX = x + move[0];\\n            int nextY = y + move[1];\\n            \\n            if (nextX >= 0 && nextY >= 0 && nextX < grid.length && nextY < grid.length) {\\n                if(nextX==x1 && nextY==y1)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    public boolean checkValidGrid(int[][] grid) {\\n      \\n        HashMap<Integer , List<Integer> > map = new HashMap<>();\\n        int n = grid.length;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                List<Integer> li = new ArrayList<>();\\n                li.add(i);\\n                li.add(j);\\n                map.put(grid[i][j],li);\\n            }\\n        }\\n        int pre1=0;\\n        int pre2=0;\\n        int c=0;\\n        for(int i = grid[0][0]+1 ; i < n*n ; i++ )\\n        { \\n            c++;\\n            List<Integer> pre = map.get(i-1);\\n            List<Integer> ans = map.get(i);\\n            if(isvalid(pre.get(0),pre.get(1),ans.get(0),ans.get(1),grid)==false)\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        if(c==n*n-1)\\n        return true;\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314429,
                "title": "java-clean-readable-recursive-solution",
                "content": "# Solution:\\n```\\nclass Solution {\\n    private int n;\\n    public boolean checkValidGrid(int[][] grid) {\\n        if (grid[0][0] != 0) {\\n            return false;\\n        }\\n        n = grid.length;\\n        return help(grid, 0, 0, 1);\\n    }\\n\\n    private int[][] dir = {\\n        {2, 1}, {2, -1}, {-2, 1}, {-2, -1}, {1, 2}, {1, -2}, {-1, 2}, {-1, -2}\\n    };\\n    \\n    private boolean help(int[][] grid, int i, int j, int cell) { \\n        for (int[] d : dir) {\\n            int newI = i + d[0], newJ = j + d[1];\\n            if (inBounds(newI, newJ) && grid[newI][newJ] == cell) {\\n                return help(grid, newI, newJ, cell + 1);\\n            }\\n        }\\n        return cell == n * n;\\n    }\\n    \\n    private boolean inBounds(int i, int j) {\\n        return i >= 0 && i < n && j >= 0 && j < n;\\n    }\\n}\\n```\\n##### Time complexity: $$O(8.n^2) => O(n^2)$$\\n##### Space complexity: $$O(n^2)$$\\n> Recursive stack space.",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    private int n;\\n    public boolean checkValidGrid(int[][] grid) {\\n        if (grid[0][0] != 0) {\\n            return false;\\n        }\\n        n = grid.length;\\n        return help(grid, 0, 0, 1);\\n    }\\n\\n    private int[][] dir = {\\n        {2, 1}, {2, -1}, {-2, 1}, {-2, -1}, {1, 2}, {1, -2}, {-1, 2}, {-1, -2}\\n    };\\n    \\n    private boolean help(int[][] grid, int i, int j, int cell) { \\n        for (int[] d : dir) {\\n            int newI = i + d[0], newJ = j + d[1];\\n            if (inBounds(newI, newJ) && grid[newI][newJ] == cell) {\\n                return help(grid, newI, newJ, cell + 1);\\n            }\\n        }\\n        return cell == n * n;\\n    }\\n    \\n    private boolean inBounds(int i, int j) {\\n        return i >= 0 && i < n && j >= 0 && j < n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314388,
                "title": "simple-python3-solution-100-faster-commented-explained-using-simple-dictionary",
                "content": "\\n# Approach\\n1. First, create a list of all possible valid knight moves using the given \"diff\" list.\\n2. Then, create a dictionary \"new\" that maps each cell number to its row and column indices.\\n3. Iterate through the cell numbers from 0 to (n*n)-1, and check if the difference between the row and column indices of the current cell and the next cell is a valid knight move using the \"diff\" list.\\n4. If the difference is not a valid knight move, return False. Otherwise, continue checking for the remaining cells.\\n5. If all cells are valid knight moves, return True.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        diff = [\\n                [2, 1],\\n                [1, 2],\\n            ]\\n        # based on the grid value saving the Row,Col in dictionary\\n        # key : [Value]  ::: Grid_Number : [row,column]\\n        new = defaultdict(list)\\n        n = len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                new[grid[i][j]].append(i)\\n                new[grid[i][j]].append(j)\\n\\n        # Must check condition Grid need to start at left top\\n        # A specific testcase is given to check this.        \\n        if new[0] != [0,0]:\\n            return False\\n        \\n        # Remaining just check if the absolute diff of Row & Col\\n        # is within the range, i.e, [1,2] or [2,1]\\n        # If not Return False\\n        for i in range((n*n)-1):\\n            row = abs(new[i][0] - new[i+1][0])\\n            col = abs(new[i][1] - new[i+1][1])\\n            #print(row,col)\\n            if [row,col] not in diff:\\n                return False\\n        \\n        # If Everything is perfect return True\\n        return True\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        diff = [\\n                [2, 1],\\n                [1, 2],\\n            ]\\n        # based on the grid value saving the Row,Col in dictionary\\n        # key : [Value]  ::: Grid_Number : [row,column]\\n        new = defaultdict(list)\\n        n = len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                new[grid[i][j]].append(i)\\n                new[grid[i][j]].append(j)\\n\\n        # Must check condition Grid need to start at left top\\n        # A specific testcase is given to check this.        \\n        if new[0] != [0,0]:\\n            return False\\n        \\n        # Remaining just check if the absolute diff of Row & Col\\n        # is within the range, i.e, [1,2] or [2,1]\\n        # If not Return False\\n        for i in range((n*n)-1):\\n            row = abs(new[i][0] - new[i+1][0])\\n            col = abs(new[i][1] - new[i+1][1])\\n            #print(row,col)\\n            if [row,col] not in diff:\\n                return False\\n        \\n        # If Everything is perfect return True\\n        return True\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314352,
                "title": "iterative-approach-2ms-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        int m=grid.length,n=grid.length;\\n        int[][] ans=new int[m][n];\\n        for(int p=0;p<m;p++){\\n            for(int q=0;q<n;q++){\\n                ans[p][q]=-1;\\n            }\\n        }\\n        int c=0;\\n        ans[0][0]=c;\\n        c=c+1;\\n        boolean t=knight(ans,1,0,0,m,n,grid);\\n        return t;\\n        \\n       \\n    }\\n    \\n    public boolean knight(int[][] ans, int c,int i,int j,int m,int n,int[][] grid){\\n\\n        \\n     while(c<=(m*n)-1){\\n        //dr\\n        if(((i+2)<m && (j+1)<n) && (ans[i+2][j+1]==-1) && (grid[i+2][j+1] ==c)){\\n            \\n                ans[i+2][j+1]=c;\\n                i=i+2;\\n                j=j+1;\\n                c=c+1;\\n                continue;\\n               \\n        }\\n            \\n            \\n        //dl\\n        else if(((i+2)<m && (j-1)>=0) && (ans[i+2][j-1]==-1) && (grid[i+2][j-1] ==c)){\\n            \\n                ans[i+2][j-1]=c;\\n                i=i+2;\\n                j=j-1;\\n                c=c+1;   \\n                continue;       \\n        }\\n            \\n            \\n        //ul\\n        else if(((i-2)>=0 && (j-1)>=0) && (ans[i-2][j-1]==-1) && (grid[i-2][j-1] ==c)){\\n        \\n                ans[i-2][j-1]=c;\\n                i=i-2;\\n                j=j-1;\\n                c=c+1;      \\n                continue;   \\n        }\\n            \\n            \\n        //ur\\n        else if(((i-2)>=0 && (j+1)<n) && (ans[i-2][j+1]==-1) && (grid[i-2][j+1] ==c)){\\n            \\n                ans[i-2][j+1]=c;\\n                i=i-2;\\n                j=j+1;\\n                c=c+1;         \\n                continue;   \\n        }\\n            \\n            \\n        //lu\\n        else if(((i-1)>=0 && (j-2)>=0) && (ans[i-1][j-2]==-1) && (grid[i-1][j-2] ==c)){\\n            \\n                ans[i-1][j-2]=c;\\n                i=i-1;\\n                j=j-2;\\n                c=c+1;         \\n                continue;      \\n        }\\n            \\n            \\n        //ld\\n        else if(((i+1)<m && (j-2)>=0) && (ans[i+1][j-2]==-1) && (grid[i+1][j-2] == c)){\\n            \\n                ans[i+1][j-2]=c;\\n                i=i+1;\\n                j=j-2;\\n                c=c+1;         \\n                continue;\\n        \\n        }\\n            \\n            \\n        //ru\\n        else if(((i-1)>=0 && (j+2)<n) && (ans[i-1][j+2]==-1) && (grid[i-1][j+2] == c)){\\n            \\n                ans[i-1][j+2]=c;\\n                i=i-1;\\n                j=j+2;\\n                c=c+1;           \\n                continue; \\n            \\n        }\\n            \\n            \\n        //rd\\n        else if(((i+1)<m && (j+2)<n) && (ans[i+1][j+2]==-1) && (grid[i+1][j+2] == c)){\\n        \\n                ans[i+1][j+2]=c;\\n                i=i+1;\\n                j=j+2;\\n                c=c+1;          \\n                continue;\\n            } \\n         \\n         \\n         \\n         else{\\n             return false;\\n         }\\n            \\n        \\n      }\\n       \\n            return true;\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        int m=grid.length,n=grid.length;\\n        int[][] ans=new int[m][n];\\n        for(int p=0;p<m;p++){\\n            for(int q=0;q<n;q++){\\n                ans[p][q]=-1;\\n            }\\n        }\\n        int c=0;\\n        ans[0][0]=c;\\n        c=c+1;\\n        boolean t=knight(ans,1,0,0,m,n,grid);\\n        return t;\\n        \\n       \\n    }\\n    \\n    public boolean knight(int[][] ans, int c,int i,int j,int m,int n,int[][] grid){\\n\\n        \\n     while(c<=(m*n)-1){\\n        //dr\\n        if(((i+2)<m && (j+1)<n) && (ans[i+2][j+1]==-1) && (grid[i+2][j+1] ==c)){\\n            \\n                ans[i+2][j+1]=c;\\n                i=i+2;\\n                j=j+1;\\n                c=c+1;\\n                continue;\\n               \\n        }\\n            \\n            \\n        //dl\\n        else if(((i+2)<m && (j-1)>=0) && (ans[i+2][j-1]==-1) && (grid[i+2][j-1] ==c)){\\n            \\n                ans[i+2][j-1]=c;\\n                i=i+2;\\n                j=j-1;\\n                c=c+1;   \\n                continue;       \\n        }\\n            \\n            \\n        //ul\\n        else if(((i-2)>=0 && (j-1)>=0) && (ans[i-2][j-1]==-1) && (grid[i-2][j-1] ==c)){\\n        \\n                ans[i-2][j-1]=c;\\n                i=i-2;\\n                j=j-1;\\n                c=c+1;      \\n                continue;   \\n        }\\n            \\n            \\n        //ur\\n        else if(((i-2)>=0 && (j+1)<n) && (ans[i-2][j+1]==-1) && (grid[i-2][j+1] ==c)){\\n            \\n                ans[i-2][j+1]=c;\\n                i=i-2;\\n                j=j+1;\\n                c=c+1;         \\n                continue;   \\n        }\\n            \\n            \\n        //lu\\n        else if(((i-1)>=0 && (j-2)>=0) && (ans[i-1][j-2]==-1) && (grid[i-1][j-2] ==c)){\\n            \\n                ans[i-1][j-2]=c;\\n                i=i-1;\\n                j=j-2;\\n                c=c+1;         \\n                continue;      \\n        }\\n            \\n            \\n        //ld\\n        else if(((i+1)<m && (j-2)>=0) && (ans[i+1][j-2]==-1) && (grid[i+1][j-2] == c)){\\n            \\n                ans[i+1][j-2]=c;\\n                i=i+1;\\n                j=j-2;\\n                c=c+1;         \\n                continue;\\n        \\n        }\\n            \\n            \\n        //ru\\n        else if(((i-1)>=0 && (j+2)<n) && (ans[i-1][j+2]==-1) && (grid[i-1][j+2] == c)){\\n            \\n                ans[i-1][j+2]=c;\\n                i=i-1;\\n                j=j+2;\\n                c=c+1;           \\n                continue; \\n            \\n        }\\n            \\n            \\n        //rd\\n        else if(((i+1)<m && (j+2)<n) && (ans[i+1][j+2]==-1) && (grid[i+1][j+2] == c)){\\n        \\n                ans[i+1][j+2]=c;\\n                i=i+1;\\n                j=j+2;\\n                c=c+1;          \\n                continue;\\n            } \\n         \\n         \\n         \\n         else{\\n             return false;\\n         }\\n            \\n        \\n      }\\n       \\n            return true;\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314329,
                "title": "c-bfs-beginner-friendly-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n         queue<vector<int>>q;\\n         q.push({0,0,0});\\n\\n     int n=grid.size();\\n        int level=0;\\n    vector<vector<int>> seen(n, vector<int>(n, 0)); \\n\\n     vector<pair<int,int>> dir = { \\n                 {-2,1},\\n            {2,-1},   {-2,-1},\\n                 {2, 1},\\n                 {1,-2},\\n            {-1,2},   {-1,-2},\\n                 {1,2},\\n         \\n        };\\n\\n     while(!q.empty()){\\n\\n        auto cell = q.front();\\n        int x = cell[0];\\n        int y = cell[1];\\n        int l=cell[2];\\n         \\n         \\n        q.pop();\\n\\n if(x < 0 || x >= n || y < 0 || y >= n  || seen[x][y]==1) {\\n                continue;\\n            }\\n         //cout<<x<<\" \"<<y<<\" \"<<l<<endl;\\n         if(grid[x][y]==l && seen[x][y]==1)\\n             return false;\\n         \\n         if(grid[x][y]==l){\\n               while(!q.empty())\\n                   q.pop();\\n                 for(auto pairDir : dir) {\\n        q.push({x + pairDir.first, y + pairDir.second,l+1});\\n            }\\n            seen[x][y] = 1;\\n         }\\n         else{\\n             seen[x][y] = 0;\\n             continue;\\n         }\\n         \\n    \\n     }\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(seen[i][j]==0)\\n                    return false;\\n            }\\n        }\\n   \\nreturn true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n         queue<vector<int>>q;\\n         q.push({0,0,0});\\n\\n     int n=grid.size();\\n        int level=0;\\n    vector<vector<int>> seen(n, vector<int>(n, 0)); \\n\\n     vector<pair<int,int>> dir = { \\n                 {-2,1},\\n            {2,-1},   {-2,-1},\\n                 {2, 1},\\n                 {1,-2},\\n            {-1,2},   {-1,-2},\\n                 {1,2},\\n         \\n        };\\n\\n     while(!q.empty()){\\n\\n        auto cell = q.front();\\n        int x = cell[0];\\n        int y = cell[1];\\n        int l=cell[2];\\n         \\n         \\n        q.pop();\\n\\n if(x < 0 || x >= n || y < 0 || y >= n  || seen[x][y]==1) {\\n                continue;\\n            }\\n         //cout<<x<<\" \"<<y<<\" \"<<l<<endl;\\n         if(grid[x][y]==l && seen[x][y]==1)\\n             return false;\\n         \\n         if(grid[x][y]==l){\\n               while(!q.empty())\\n                   q.pop();\\n                 for(auto pairDir : dir) {\\n        q.push({x + pairDir.first, y + pairDir.second,l+1});\\n            }\\n            seen[x][y] = 1;\\n         }\\n         else{\\n             seen[x][y] = 0;\\n             continue;\\n         }\\n         \\n    \\n     }\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(seen[i][j]==0)\\n                    return false;\\n            }\\n        }\\n   \\nreturn true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3314312,
                "title": "only-recursion-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    bool helper(vector<vector<int>>& grid,int i,int j,int k){\\n        if(i<0 || j<0 || i>=n || j>=n) return false;\\n        if(grid[i][j]!=k) return false;\\n        if(k == (n *n - 1)) return true;\\n        return helper(grid,i+2,j-1,k+1)||helper(grid,i+2,j+1,k+1) ||helper(grid,i-2,j-1,k+1)||helper(grid,i-2,j+1,k+1)||helper(grid,i-1,j+2,k+1)||helper(grid,i-1,j-2,k+1)||helper(grid,i+1,j+2,k+1) || helper(grid,i+1,j-2,k+1);\\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n          n = grid.size();\\n          return helper(grid,0,0,0);       \\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    bool helper(vector<vector<int>>& grid,int i,int j,int k){\\n        if(i<0 || j<0 || i>=n || j>=n) return false;\\n        if(grid[i][j]!=k) return false;\\n        if(k == (n *n - 1)) return true;\\n        return helper(grid,i+2,j-1,k+1)||helper(grid,i+2,j+1,k+1) ||helper(grid,i-2,j-1,k+1)||helper(grid,i-2,j+1,k+1)||helper(grid,i-1,j+2,k+1)||helper(grid,i-1,j-2,k+1)||helper(grid,i+1,j+2,k+1) || helper(grid,i+1,j-2,k+1);\\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n          n = grid.size();\\n          return helper(grid,0,0,0);       \\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314282,
                "title": "dfs-striver-easy-optimal-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have used dfs to traverse and we keep a count to check if the count is equals to n*n.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dx = {2, 2, 1, 1, -1, -1, -2, -2};\\n    vector<int> dy = {1, -1, 2, -2, 2, -2, 1, -1};\\n    // vector<pair<int, int>> moves = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<bool>> visited(n, vector<bool>(n, false));\\n        return dfs(grid, visited, dx, dy, 0, 0, 1);\\n    }\\n    \\n    bool dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, vector<int>& dx, vector<int>& dy, int x, int y, int count) {\\n        int n = grid.size();\\n        visited[x][y] = true;\\n        if (count == n * n) { \\n            return true;\\n        }\\n        for (int i = 0; i < 8; i++) {\\n            int nx = x + dx[i];\\n            int ny = y + dy[i];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < n && !visited[nx][ny] && grid[nx][ny] == count) {\\n                if (dfs(grid, visited, dx, dy, nx, ny, count + 1)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        visited[x][y] = false; \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dx = {2, 2, 1, 1, -1, -1, -2, -2};\\n    vector<int> dy = {1, -1, 2, -2, 2, -2, 1, -1};\\n    // vector<pair<int, int>> moves = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<bool>> visited(n, vector<bool>(n, false));\\n        return dfs(grid, visited, dx, dy, 0, 0, 1);\\n    }\\n    \\n    bool dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, vector<int>& dx, vector<int>& dy, int x, int y, int count) {\\n        int n = grid.size();\\n        visited[x][y] = true;\\n        if (count == n * n) { \\n            return true;\\n        }\\n        for (int i = 0; i < 8; i++) {\\n            int nx = x + dx[i];\\n            int ny = y + dy[i];\\n            if (nx >= 0 && nx < n && ny >= 0 && ny < n && !visited[nx][ny] && grid[nx][ny] == count) {\\n                if (dfs(grid, visited, dx, dy, nx, ny, count + 1)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        visited[x][y] = false; \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314210,
                "title": "simple-bfs-traversal-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:       \\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        r1,c1=0,0\\n        src=0\\n        dest=(len(grid)*len(grid))-1\\n        queue=collections.deque([(r1,c1,src)])\\n        vis=[[0 for i in range(len(grid))] for j in range(len(grid))]\\n        while queue:\\n            row,col,src=queue.popleft()\\n            vis[row][col]=1\\n            if src==dest:\\n                return True\\n            dx=[1,2,1,2,-1,-2,-1,-2]\\n            dy=[2,1,-2,-1,2,1,-2,-1]\\n            for i in range(8):\\n                newr=row+dx[i]\\n                newc=col+dy[i]\\n                #print(newr,newc)\\n                if 0<=newr<len(grid) and 0<=newc<len(grid) and vis[newr][newc]!=1:\\n                    if grid[newr][newc]==(src+1):\\n                        queue.append((newr,newc,src+1))\\n                        \\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:       \\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        r1,c1=0,0\\n        src=0\\n        dest=(len(grid)*len(grid))-1\\n        queue=collections.deque([(r1,c1,src)])\\n        vis=[[0 for i in range(len(grid))] for j in range(len(grid))]\\n        while queue:\\n            row,col,src=queue.popleft()\\n            vis[row][col]=1\\n            if src==dest:\\n                return True\\n            dx=[1,2,1,2,-1,-2,-1,-2]\\n            dy=[2,1,-2,-1,2,1,-2,-1]\\n            for i in range(8):\\n                newr=row+dx[i]\\n                newc=col+dy[i]\\n                #print(newr,newc)\\n                if 0<=newr<len(grid) and 0<=newc<len(grid) and vis[newr][newc]!=1:\\n                    if grid[newr][newc]==(src+1):\\n                        queue.append((newr,newc,src+1))\\n                        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314153,
                "title": "use-simple-queue-to-keep-track-of-current-cell-and-find-next-cell-traverse-till-n-n-moves",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart from 0, 0. Maintain a queue and traverse till n * n moves. Is at any point you find a cell with count one more than current value in any of the 8 possible moves of knight move there else return false. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dx = {-1, -2, -2, -1, 1, 2, 2, 1};\\n    vector<int> dy = {-2, -1, 1, 2, 2, 1, -1, -2};\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        if(grid[0][0] != 0) return false;\\n        int x = 0, y = 0, n = grid.size();\\n        queue<pair<int, int>> q;\\n        int countVis = 1;\\n        q.push({x, y});\\n        while(q.size()){\\n            if(countVis == n * n)   return true;\\n            auto p = q.front();\\n            q.pop();\\n            for(int i = 0; i < 8; ++i){\\n                int nx = p.first + dx[i];\\n                int ny = p.second + dy[i];\\n                if(nx >= 0 && ny >= 0 && nx < n && ny < n && grid[nx][ny] == countVis){\\n                    q.push({nx, ny});\\n                }\\n            }\\n            countVis++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dx = {-1, -2, -2, -1, 1, 2, 2, 1};\\n    vector<int> dy = {-2, -1, 1, 2, 2, 1, -1, -2};\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        if(grid[0][0] != 0) return false;\\n        int x = 0, y = 0, n = grid.size();\\n        queue<pair<int, int>> q;\\n        int countVis = 1;\\n        q.push({x, y});\\n        while(q.size()){\\n            if(countVis == n * n)   return true;\\n            auto p = q.front();\\n            q.pop();\\n            for(int i = 0; i < 8; ++i){\\n                int nx = p.first + dx[i];\\n                int ny = p.second + dy[i];\\n                if(nx >= 0 && ny >= 0 && nx < n && ny < n && grid[nx][ny] == countVis){\\n                    q.push({nx, ny});\\n                }\\n            }\\n            countVis++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314133,
                "title": "straight-forward-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStraight forward appraoch.\\ntraverse through all eight directions when the move is not found then\\nnot valid condition break and return false else return true;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * n * 8) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\nPlease Upvote!.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size(), cnt = 0;\\n        \\n        if(grid[0][0] != cnt) return false;\\n        \\n        // to traverse all 8 directions.\\n        int dr[] = {-1, -2, -1, -2, 1, 2, 1, 2};\\n        int dc[] = {-2, -1, 2, 1, -2, -1, 2, 1};\\n        \\n        for(int i = 0, j = 0; i<n and j < n; ){\\n            \\n                \\n                cnt++;\\n                \\n                if(cnt == n * n) return true;;\\n                \\n                bool flag = false;\\n                for(int move = 0; move<8; ++move){\\n                    \\n                    int nr = i + dr[move];\\n                    int nc = j + dc[move];\\n                    \\n                   \\n                    \\n                    if(nr >= 0 and nr < n and nc >= 0 and nc < n and grid[nr][nc] == cnt){\\n                        flag = true;\\n                        i = nr;\\n                        j = nc;\\n                        break;\\n                    }\\n                    \\n                }\\n                \\n                \\n                if(!flag)\\n                    return false;\\n                \\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size(), cnt = 0;\\n        \\n        if(grid[0][0] != cnt) return false;\\n        \\n        // to traverse all 8 directions.\\n        int dr[] = {-1, -2, -1, -2, 1, 2, 1, 2};\\n        int dc[] = {-2, -1, 2, 1, -2, -1, 2, 1};\\n        \\n        for(int i = 0, j = 0; i<n and j < n; ){\\n            \\n                \\n                cnt++;\\n                \\n                if(cnt == n * n) return true;;\\n                \\n                bool flag = false;\\n                for(int move = 0; move<8; ++move){\\n                    \\n                    int nr = i + dr[move];\\n                    int nc = j + dc[move];\\n                    \\n                   \\n                    \\n                    if(nr >= 0 and nr < n and nc >= 0 and nc < n and grid[nr][nc] == cnt){\\n                        flag = true;\\n                        i = nr;\\n                        j = nc;\\n                        break;\\n                    }\\n                    \\n                }\\n                \\n                \\n                if(!flag)\\n                    return false;\\n                \\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314095,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] directions = new int[][]{{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};\\n    public boolean checkValidGrid(int[][] grid) {\\n        \\n        int n = grid.length;\\n        boolean[][] visited = new boolean[n][n];\\n        visited[0][0] = true;\\n        return backtrack(grid, visited, 0, 0, 1);\\n    }\\n    private boolean backtrack(int[][] grid, boolean[][] visited, int row, int col, int count) {\\n        int n = grid.length;\\n        if (count == n * n) {\\n            return true;\\n        }\\n\\n        for (int[] dir : directions) {\\n            int newRow = row + dir[0];\\n            int newCol = col + dir[1];\\n            if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && !visited[newRow][newCol] && grid[newRow][newCol] == count) {\\n                visited[newRow][newCol] = true;\\n                if (backtrack(grid, visited, newRow, newCol, count + 1)) {\\n                    return true;\\n                }\\n                visited[newRow][newCol] = false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] directions = new int[][]{{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};\\n    public boolean checkValidGrid(int[][] grid) {\\n        \\n        int n = grid.length;\\n        boolean[][] visited = new boolean[n][n];\\n        visited[0][0] = true;\\n        return backtrack(grid, visited, 0, 0, 1);\\n    }\\n    private boolean backtrack(int[][] grid, boolean[][] visited, int row, int col, int count) {\\n        int n = grid.length;\\n        if (count == n * n) {\\n            return true;\\n        }\\n\\n        for (int[] dir : directions) {\\n            int newRow = row + dir[0];\\n            int newCol = col + dir[1];\\n            if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && !visited[newRow][newCol] && grid[newRow][newCol] == count) {\\n                visited[newRow][newCol] = true;\\n                if (backtrack(grid, visited, newRow, newCol, count + 1)) {\\n                    return true;\\n                }\\n                visited[newRow][newCol] = false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314029,
                "title": "c-bfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    bool help(int rr,int cc,int r,int c){\\n        if((rr+1==r && (cc-2==c || cc+2==c)) || \\n           (rr+2==r && (cc-1==c || cc+1==c)) || \\n           (rr-1==r && (cc-2==c || cc+2==c)) || \\n           (rr-2==r && (cc-1==c || cc+1==c))){\\n            return true;\\n        }\\n        return false;\\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        map<int,pair<int,int>> mp;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                mp[grid[i][j]] = {i,j};\\n            }\\n        }\\n        n = grid.size();\\n        m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vis[0][0] = 1;\\n        while(q.size()){\\n            auto x = q.front();\\n            q.pop();\\n            int r = x.first,c = x.second;\\n            int val = grid[r][c];\\n            if(mp.find(val+1)!=mp.end()){\\n                auto cor = mp[val+1];\\n                if(help(cor.first,cor.second,r,c) && vis[cor.first][cor.second]==0){\\n                    q.push({cor.first,cor.second});\\n                    vis[cor.first][cor.second] = 1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    bool help(int rr,int cc,int r,int c){\\n        if((rr+1==r && (cc-2==c || cc+2==c)) || \\n           (rr+2==r && (cc-1==c || cc+1==c)) || \\n           (rr-1==r && (cc-2==c || cc+2==c)) || \\n           (rr-2==r && (cc-1==c || cc+1==c))){\\n            return true;\\n        }\\n        return false;\\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        map<int,pair<int,int>> mp;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                mp[grid[i][j]] = {i,j};\\n            }\\n        }\\n        n = grid.size();\\n        m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vis[0][0] = 1;\\n        while(q.size()){\\n            auto x = q.front();\\n            q.pop();\\n            int r = x.first,c = x.second;\\n            int val = grid[r][c];\\n            if(mp.find(val+1)!=mp.end()){\\n                auto cor = mp[val+1];\\n                if(help(cor.first,cor.second,r,c) && vis[cor.first][cor.second]==0){\\n                    q.push({cor.first,cor.second});\\n                    vis[cor.first][cor.second] = 1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314008,
                "title": "java-backtracking-solution",
                "content": "\\n# Intuition\\nThis problem can be solved using backtracking. We tested all the possible moves from the current index. If the result of the current cell is one value bigger than the previous cell, then it is valid to go there. \\n\\nFor each valid move, we decrement the countMoves variable by 1.\\n\\nIf `countValid == 0`, means that we tried all the possible moves, return true.\\n\\n# Complexity\\n- Time complexity: $$O(8^(rows * columns))$$ in the worst case. Because the recursive function will visit every cell on the grid, and for each cell, it will make 8 recursive calls to cover all possible knight moves. \\n\\n- Space complexity: $$O(rows * columns)$$ due to the recursion stack depth and the \\'visited\\' boolean array.\\n\\n# Code \\n```\\nclass Solution {\\n    int countMoves;\\n    public boolean checkValidGrid(int[][] grid) {\\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n        countMoves = rows * columns;\\n        helper(0,0, rows, columns, grid, grid[0][0], new boolean[rows][columns]);\\n        return countMoves == 0 ? true : false;\\n    }\\n    \\n    public void helper(int row, int column, int rows, int columns, int [][] grid, int prevValue, boolean [][] visited)\\n    {\\n        if(row < 0 || row >= rows || column < 0 || column >= columns || grid[row][column] - prevValue != 1 && prevValue != 0 || visited[row][column])\\n        {\\n            return;\\n        }\\n        visited[row][column] = true;\\n        countMoves--;\\n        // 8 moves total\\n        helper(row - 2, column - 1, rows, columns, grid, grid[row][column], visited);\\n        helper(row - 1, column - 2, rows, columns, grid, grid[row][column], visited);\\n        helper(row + 1, column - 2, rows, columns, grid, grid[row][column], visited);\\n        helper(row + 2, column - 1, rows, columns, grid, grid[row][column], visited);\\n        helper(row + 2, column + 1, rows, columns, grid, grid[row][column], visited);\\n        helper(row + 1, column + 2, rows, columns, grid, grid[row][column], visited);\\n        helper(row - 1, column + 2, rows, columns, grid, grid[row][column], visited);\\n        helper(row - 2, column + 1, rows, columns, grid, grid[row][column], visited);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int countMoves;\\n    public boolean checkValidGrid(int[][] grid) {\\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n        countMoves = rows * columns;\\n        helper(0,0, rows, columns, grid, grid[0][0], new boolean[rows][columns]);\\n        return countMoves == 0 ? true : false;\\n    }\\n    \\n    public void helper(int row, int column, int rows, int columns, int [][] grid, int prevValue, boolean [][] visited)\\n    {\\n        if(row < 0 || row >= rows || column < 0 || column >= columns || grid[row][column] - prevValue != 1 && prevValue != 0 || visited[row][column])\\n        {\\n            return;\\n        }\\n        visited[row][column] = true;\\n        countMoves--;\\n        // 8 moves total\\n        helper(row - 2, column - 1, rows, columns, grid, grid[row][column], visited);\\n        helper(row - 1, column - 2, rows, columns, grid, grid[row][column], visited);\\n        helper(row + 1, column - 2, rows, columns, grid, grid[row][column], visited);\\n        helper(row + 2, column - 1, rows, columns, grid, grid[row][column], visited);\\n        helper(row + 2, column + 1, rows, columns, grid, grid[row][column], visited);\\n        helper(row + 1, column + 2, rows, columns, grid, grid[row][column], visited);\\n        helper(row - 1, column + 2, rows, columns, grid, grid[row][column], visited);\\n        helper(row - 2, column + 1, rows, columns, grid, grid[row][column], visited);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313998,
                "title": "dfs-c-easy",
                "content": "```\\nclass Solution {\\n    int dr[8] = {2, 2, 1, 1, -1, -1, -2, -2};\\n    int dc[8] = {1, -1, 2, -2, 2, -2, 1, -1};\\npublic:\\n    bool check(vector<vector<int>>& grid, int i, int j, int start, int n) {\\n        \\n        if(i >= n or j >= n or i < 0 or j < 0 or grid[i][j] != start)return false;\\n        \\n        if(start == (n*n)-1)return true;\\n        \\n        for(int k = 0; k < 8; k++) {\\n            int nr = dr[k] + i, nc = dc[k] + j;\\n            \\n            if(check(grid,nr,nc,start+1,n))return true;\\n            \\n        }\\n        \\n        return false;\\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        \\n        int n = size(grid);\\n        \\n        return check(grid,0,0,0,n) ? 1 : 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int dr[8] = {2, 2, 1, 1, -1, -1, -2, -2};\\n    int dc[8] = {1, -1, 2, -2, 2, -2, 1, -1};\\npublic:\\n    bool check(vector<vector<int>>& grid, int i, int j, int start, int n) {\\n        \\n        if(i >= n or j >= n or i < 0 or j < 0 or grid[i][j] != start)return false;\\n        \\n        if(start == (n*n)-1)return true;\\n        \\n        for(int k = 0; k < 8; k++) {\\n            int nr = dr[k] + i, nc = dc[k] + j;\\n            \\n            if(check(grid,nr,nc,start+1,n))return true;\\n            \\n        }\\n        \\n        return false;\\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        \\n        int n = size(grid);\\n        \\n        return check(grid,0,0,0,n) ? 1 : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091430,
                "title": "java-eassi-code-solution-optimized-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThere are no any extra space uses but recursion are used in this case recursion use of callstack ,call stack take o(n)space.\\n# Code\\n```\\nclass Solution {\\n    private boolean helper(int[][] grid,int row,int col,int num){\\n        int n=grid.length;\\n        //base case\\n        if(grid[row][col]==n*n-1)return true;\\n\\n        int i,j;\\n        //2 up 1 right\\n        i=row-2;\\n        j=col+1;\\n        if(i>=0 && j<n && grid[i][j]==num+1)return helper(grid,i,j,num+1);\\n        //2 up 1 left\\n        i=row-2;\\n        j=col-1;\\n        if(i>=0 && j>=0 && grid[i][j]==num+1)return helper(grid,i,j,num+1);\\n\\n        //2 down 1 right\\n        i=row+2;\\n        j=col+1;\\n        if(i<n && j<n && grid[i][j]==num+1)return helper(grid,i,j,num+1);\\n        //2 down 1 left\\n        i=row+2;\\n        j=col-1;\\n        if(i<n && j>=0 && grid[i][j]==num+1)return helper(grid,i,j,num+1);\\n\\n        //2 left 1 up\\n        i=row-1;\\n        j=col-2;\\n        if(i>=0 && j>=0 && grid[i][j]==num+1)return helper(grid,i,j,num+1);\\n        //2 left 1 down\\n        i=row+1;\\n        j=col-2;\\n        if(i<n && j>=0 && grid[i][j]==num+1)return helper(grid,i,j,num+1);\\n\\n         //2 right 1 up\\n        i=row-1;\\n        j=col+2;\\n        if(i>=0 && j<n && grid[i][j]==num+1)return helper(grid,i,j,num+1);\\n        //2 right 1 down\\n        i=row+1;\\n        j=col+2;\\n        if(i<n && j<n && grid[i][j]==num+1)return helper(grid,i,j,num+1);\\n\\n        return false; //by anychance right ans not found return false\\n    }\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0]!=0)return false;\\n        return helper(grid,0,0,0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private boolean helper(int[][] grid,int row,int col,int num){\\n        int n=grid.length;\\n        //base case\\n        if(grid[row][col]==n*n-1)return true;\\n\\n        int i,j;\\n        //2 up 1 right\\n        i=row-2;\\n        j=col+1;\\n        if(i>=0 && j<n && grid[i][j]==num+1)return helper(grid,i,j,num+1);\\n        //2 up 1 left\\n        i=row-2;\\n        j=col-1;\\n        if(i>=0 && j>=0 && grid[i][j]==num+1)return helper(grid,i,j,num+1);\\n\\n        //2 down 1 right\\n        i=row+2;\\n        j=col+1;\\n        if(i<n && j<n && grid[i][j]==num+1)return helper(grid,i,j,num+1);\\n        //2 down 1 left\\n        i=row+2;\\n        j=col-1;\\n        if(i<n && j>=0 && grid[i][j]==num+1)return helper(grid,i,j,num+1);\\n\\n        //2 left 1 up\\n        i=row-1;\\n        j=col-2;\\n        if(i>=0 && j>=0 && grid[i][j]==num+1)return helper(grid,i,j,num+1);\\n        //2 left 1 down\\n        i=row+1;\\n        j=col-2;\\n        if(i<n && j>=0 && grid[i][j]==num+1)return helper(grid,i,j,num+1);\\n\\n         //2 right 1 up\\n        i=row-1;\\n        j=col+2;\\n        if(i>=0 && j<n && grid[i][j]==num+1)return helper(grid,i,j,num+1);\\n        //2 right 1 down\\n        i=row+1;\\n        j=col+2;\\n        if(i<n && j<n && grid[i][j]==num+1)return helper(grid,i,j,num+1);\\n\\n        return false; //by anychance right ans not found return false\\n    }\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0]!=0)return false;\\n        return helper(grid,0,0,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081566,
                "title": "easy-and-simple-solution-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public:\\n\\n    bool helper(vector<vector<int>>& grid, int row, int col, int move)\\n    {\\n        int n = grid.size();\\n\\n        if(grid[row][col] == (n*n) - 1)\\n        {\\n            return true;\\n        }\\n\\n        int i,j;\\n\\n        i = row - 2;\\n        j = col + 1;\\n\\n        if(i >= 0 && j < n && grid[i][j] == move + 1)\\n        {\\n            return helper(grid, i, j, move + 1);\\n        }\\n\\n        i = row - 1;\\n        j = col + 2;\\n\\n        if(i >= 0 && j < n && grid[i][j] == move + 1)\\n        {\\n            return helper(grid, i, j, move + 1);\\n        }\\n\\n        i = row + 1;\\n        j = col + 2;\\n\\n        if(i < n && j < n && grid[i][j] == move + 1)\\n        {\\n            return helper(grid, i, j, move + 1);\\n        }\\n\\n        i = row + 2;\\n        j = col + 1;\\n\\n        if(i < n && j < n && grid[i][j] == move + 1)\\n        {\\n            return helper(grid, i, j, move + 1);\\n        }\\n\\n        i = row + 2;\\n        j = col - 1;\\n\\n        if(i < n && j >= 0 && grid[i][j] == move + 1)\\n        {\\n            return helper(grid, i, j, move + 1);\\n        }\\n\\n        i = row + 1;\\n        j = col - 2;\\n\\n        if(i < n && j >= 0 && grid[i][j] == move + 1)\\n        {\\n            return helper(grid, i, j, move + 1);\\n        }\\n\\n        i = row - 1;\\n        j = col - 2;\\n\\n        if(i >= 0 && j >= 0 && grid[i][j] == move + 1)\\n        {\\n            return helper(grid, i, j, move + 1);\\n        }\\n\\n        i = row - 2;\\n        j = col - 1;\\n\\n        if(i >= 0 && j >= 0 && grid[i][j] == move + 1)\\n        {\\n            return helper(grid, i, j, move + 1);\\n        }\\n\\n        return false;\\n    }\\n\\n    bool checkValidGrid(vector<vector<int>>& grid) \\n    {\\n        if(grid[0][0] != 0)\\n        {\\n            return false;\\n        }\\n\\n        return helper(grid, 0, 0, 0);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n\\n    bool helper(vector<vector<int>>& grid, int row, int col, int move)\\n    {\\n        int n = grid.size();\\n\\n        if(grid[row][col] == (n*n) - 1)\\n        {\\n            return true;\\n        }\\n\\n        int i,j;\\n\\n        i = row - 2;\\n        j = col + 1;\\n\\n        if(i >= 0 && j < n && grid[i][j] == move + 1)\\n        {\\n            return helper(grid, i, j, move + 1);\\n        }\\n\\n        i = row - 1;\\n        j = col + 2;\\n\\n        if(i >= 0 && j < n && grid[i][j] == move + 1)\\n        {\\n            return helper(grid, i, j, move + 1);\\n        }\\n\\n        i = row + 1;\\n        j = col + 2;\\n\\n        if(i < n && j < n && grid[i][j] == move + 1)\\n        {\\n            return helper(grid, i, j, move + 1);\\n        }\\n\\n        i = row + 2;\\n        j = col + 1;\\n\\n        if(i < n && j < n && grid[i][j] == move + 1)\\n        {\\n            return helper(grid, i, j, move + 1);\\n        }\\n\\n        i = row + 2;\\n        j = col - 1;\\n\\n        if(i < n && j >= 0 && grid[i][j] == move + 1)\\n        {\\n            return helper(grid, i, j, move + 1);\\n        }\\n\\n        i = row + 1;\\n        j = col - 2;\\n\\n        if(i < n && j >= 0 && grid[i][j] == move + 1)\\n        {\\n            return helper(grid, i, j, move + 1);\\n        }\\n\\n        i = row - 1;\\n        j = col - 2;\\n\\n        if(i >= 0 && j >= 0 && grid[i][j] == move + 1)\\n        {\\n            return helper(grid, i, j, move + 1);\\n        }\\n\\n        i = row - 2;\\n        j = col - 1;\\n\\n        if(i >= 0 && j >= 0 && grid[i][j] == move + 1)\\n        {\\n            return helper(grid, i, j, move + 1);\\n        }\\n\\n        return false;\\n    }\\n\\n    bool checkValidGrid(vector<vector<int>>& grid) \\n    {\\n        if(grid[0][0] != 0)\\n        {\\n            return false;\\n        }\\n\\n        return helper(grid, 0, 0, 0);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072461,
                "title": "c-clean-code-simple-backtracking",
                "content": "```\\nclass Solution {\\nprivate:\\n    \\n    bool isValid(vector<vector<int>>&grid, int x, int y) {\\n        if(x < 0 || x>=grid.size() || y<0 || y>=grid.size()) return false;\\n        return true;\\n    }\\n    \\n    bool knightTour(vector<vector<int>> &grid, int x, int y, int visit) {\\n        int n = grid.size();\\n        if(visit == n*n) return true;\\n        int xAxis[8] = {1, 1, -1, -1, 2, 2, -2, -2};\\n        int yAxis[8] = {2, -2, 2, -2, 1, -1, 1, -1};\\n        if(grid[x][y] == visit) {\\n            for(int i=0; i<8; i++) {\\n            int nextX = x + xAxis[i];\\n            int nextY = y + yAxis[i];\\n            if(isValid(grid, nextX, nextY)) {\\n                    if(knightTour(grid, nextX, nextY, visit+1)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {        \\n        return knightTour(grid, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    \\n    bool isValid(vector<vector<int>>&grid, int x, int y) {\\n        if(x < 0 || x>=grid.size() || y<0 || y>=grid.size()) return false;\\n        return true;\\n    }\\n    \\n    bool knightTour(vector<vector<int>> &grid, int x, int y, int visit) {\\n        int n = grid.size();\\n        if(visit == n*n) return true;\\n        int xAxis[8] = {1, 1, -1, -1, 2, 2, -2, -2};\\n        int yAxis[8] = {2, -2, 2, -2, 1, -1, 1, -1};\\n        if(grid[x][y] == visit) {\\n            for(int i=0; i<8; i++) {\\n            int nextX = x + xAxis[i];\\n            int nextY = y + yAxis[i];\\n            if(isValid(grid, nextX, nextY)) {\\n                    if(knightTour(grid, nextX, nextY, visit+1)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {        \\n        return knightTour(grid, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063229,
                "title": "c-recursion-clean-code",
                "content": "# Intuition\\nTraverse all the 8 directions of a knight\\'s move and check if we find a valid configuration.\\n\\n# Approach\\nApply DFS in all 8 directions, if reach the end move without any invalid configuration then we return true\\n\\n# Complexity\\n- Time complexity:\\n$$O(8^n)$$ \\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int row, int col, int n) {\\n        return row >= 0 && col >= 0 && row < n && col < n;\\n    }\\n    bool checkValidMoves(int row, int col, int prevMove, vector<vector<int>>& grid, int n, vector<vector<bool>>& visited) {\\n        if(!isValid(row, col, n) || grid[row][col] != prevMove || visited[row][col]) {\\n            return false;\\n        }\\n        visited[row][col] = true;\\n        \\n        vector<vector<int>> directions = {{-2,1}, {-2,-1}, {-1,2}, {-1,-2}, {1,2}, {1,-2}, {2,1}, {2,-1}};\\n        for(auto direction : directions) {\\n            int newRow = row + direction[0];\\n            int newCol = col + direction[1];\\n            if (checkValidMoves(newRow, newCol, prevMove + 1, grid, n, visited)) {\\n                return true; \\n            }\\n        }\\n        return prevMove == n * n - 1;\\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<bool>>visited(n , vector<bool> (n, false));\\n        return checkValidMoves(0, 0, 0, grid, n, visited);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int row, int col, int n) {\\n        return row >= 0 && col >= 0 && row < n && col < n;\\n    }\\n    bool checkValidMoves(int row, int col, int prevMove, vector<vector<int>>& grid, int n, vector<vector<bool>>& visited) {\\n        if(!isValid(row, col, n) || grid[row][col] != prevMove || visited[row][col]) {\\n            return false;\\n        }\\n        visited[row][col] = true;\\n        \\n        vector<vector<int>> directions = {{-2,1}, {-2,-1}, {-1,2}, {-1,-2}, {1,2}, {1,-2}, {2,1}, {2,-1}};\\n        for(auto direction : directions) {\\n            int newRow = row + direction[0];\\n            int newCol = col + direction[1];\\n            if (checkValidMoves(newRow, newCol, prevMove + 1, grid, n, visited)) {\\n                return true; \\n            }\\n        }\\n        return prevMove == n * n - 1;\\n    }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<bool>>visited(n , vector<bool> (n, false));\\n        return checkValidMoves(0, 0, 0, grid, n, visited);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056956,
                "title": "simple-dfs-by-exploring-all-possible-neighbours-from-current-cell",
                "content": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        \"\"\"\\n        we can easily solve this problem using dfs by exploring all possible \\n        neightbors from the current cell\\n        \"\"\"\\n        m = len(grid)\\n\\n        def is_valid(i, j):\\n            if 0 <= i < m and 0 <= j < m:\\n                return True\\n            return False\\n\\n        def get_neis(i, j):\\n            return [(i-2,j+1), (i-2,j-1), \\n                    (i-1,j+2), (i-1,j-2), \\n                    (i+1,j+2), (i+1,j-2),\\n                    (i+2,j+1), (i+2,j-1)]\\n\\n        def dfs(i, j, pos):\\n            if pos + 1 == m * m:\\n                return True\\n            for nei in get_neis(i, j):\\n                x, y = nei\\n                if is_valid(x, y) and grid[x][y] == pos + 1:\\n                    # found a valid position for knight\\n                    return dfs(x, y, pos+1)\\n            return False\\n        return dfs(0, 0, grid[0][0]) if grid[0][0] == 0 else False\\n                \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        \"\"\"\\n        we can easily solve this problem using dfs by exploring all possible \\n        neightbors from the current cell\\n        \"\"\"\\n        m = len(grid)\\n\\n        def is_valid(i, j):\\n            if 0 <= i < m and 0 <= j < m:\\n                return True\\n            return False\\n\\n        def get_neis(i, j):\\n            return [(i-2,j+1), (i-2,j-1), \\n                    (i-1,j+2), (i-1,j-2), \\n                    (i+1,j+2), (i+1,j-2),\\n                    (i+2,j+1), (i+2,j-1)]\\n\\n        def dfs(i, j, pos):\\n            if pos + 1 == m * m:\\n                return True\\n            for nei in get_neis(i, j):\\n                x, y = nei\\n                if is_valid(x, y) and grid[x][y] == pos + 1:\\n                    # found a valid position for knight\\n                    return dfs(x, y, pos+1)\\n            return False\\n        return dfs(0, 0, grid[0][0]) if grid[0][0] == 0 else False\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055665,
                "title": "accepted-easy-to-understand-backtracking",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity:\\nAdd your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int i,int j,vector<vector<int>>& grid,int n,int di[],int dj[],int pos){\\n        int value=pow(n,2)-1;\\n        if(grid[i][j]==value){\\n            return true;\\n        }\\n\\n        for(int ind=0;ind<8;ind++){\\n            int nexti=i+di[ind];\\n            int nextj=j+dj[ind];\\n            if(nexti>=0 && nextj>=0 && nexti<n && nextj<n && grid[nexti][nextj]==(pos+1)){\\n                if(solve(nexti,nextj,grid,n,di,dj,grid[nexti][nextj])){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n\\n    }\\n\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int di[]={+2,+2,-2,-2,-1,+1,-1,+1};\\n        int dj[]={-1,+1,-1,+1,-2,-2,+2,+2};\\n        bool result;\\n        if(grid[0][0]==0){\\n            result=solve(0,0,grid,n,di,dj,0);\\n        }\\n        else{\\n            return false;\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int i,int j,vector<vector<int>>& grid,int n,int di[],int dj[],int pos){\\n        int value=pow(n,2)-1;\\n        if(grid[i][j]==value){\\n            return true;\\n        }\\n\\n        for(int ind=0;ind<8;ind++){\\n            int nexti=i+di[ind];\\n            int nextj=j+dj[ind];\\n            if(nexti>=0 && nextj>=0 && nexti<n && nextj<n && grid[nexti][nextj]==(pos+1)){\\n                if(solve(nexti,nextj,grid,n,di,dj,grid[nexti][nextj])){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n\\n    }\\n\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int di[]={+2,+2,-2,-2,-1,+1,-1,+1};\\n        int dj[]={-1,+1,-1,+1,-2,-2,+2,+2};\\n        bool result;\\n        if(grid[0][0]==0){\\n            result=solve(0,0,grid,n,di,dj,0);\\n        }\\n        else{\\n            return false;\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055459,
                "title": "clean-and-clear-solution-in-c-by-matrix-simulation",
                "content": "# Complexity\\n- Time complexity: O(8\\\\*N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\npublic:\\n\\n    bool check(vector<int> &a, vector<int> &b) {\\n        //  check for all the possible directions\\n        for(auto dir : dirs) {\\n            int x = a[0]+dir[0], y = a[1]+dir[1];\\n            // matches\\n            if(x == b[0] && y == b[1]) return true;\\n        }\\n        //  if non matches\\n        return false;\\n    }\\n\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int sz = n*n;\\n        if(grid[0][0] != 0) return false;\\n        vector<vector<int>> moves(sz);\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                moves[grid[i][j]] = {i, j};\\n            }\\n        }\\n\\n        for(int i = 0; i < sz-1; i++) {\\n            //  check for every consecutive move\\n           if(!check(moves[i], moves[i+1])) return false;\\n\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\npublic:\\n\\n    bool check(vector<int> &a, vector<int> &b) {\\n        //  check for all the possible directions\\n        for(auto dir : dirs) {\\n            int x = a[0]+dir[0], y = a[1]+dir[1];\\n            // matches\\n            if(x == b[0] && y == b[1]) return true;\\n        }\\n        //  if non matches\\n        return false;\\n    }\\n\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int sz = n*n;\\n        if(grid[0][0] != 0) return false;\\n        vector<vector<int>> moves(sz);\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                moves[grid[i][j]] = {i, j};\\n            }\\n        }\\n\\n        for(int i = 0; i < sz-1; i++) {\\n            //  check for every consecutive move\\n           if(!check(moves[i], moves[i+1])) return false;\\n\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052926,
                "title": "beat-100-user",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n        private static boolean  helper(int[][] board, int row, int col, int num) {\\n        int n = board.length;\\n        if (board[row][col] == n*n-1) {\\n            return true;\\n        }\\n        int i, j;\\n        // up right\\n        i = row - 2;\\n        j = col + 1;\\n        if (i >= 0 && j < n && board[i][j] == num + 1) return helper(board, i, j, num + 1);\\n\\n        // up left\\n        i = row - 2;\\n        j = col - 1;\\n        if (i >= 0 && j >= 0 && board[i][j] == num + 1) return helper(board, i, j, num + 1);\\n\\n        // down right\\n        i = row + 2;\\n        j = col + 1;\\n        if (i < n && j < n && board[i][j] == num + 1) return helper(board, i, j, num + 1);\\n\\n        //down left\\n        i = row + 2;\\n        j = col - 1;\\n        if (i < n && j >= 0 && board[i][j] == num + 1) return helper(board, i, j, num + 1);\\n\\n        // right up\\n        i = row - 1;\\n        j = col + 2;\\n        if (i >= 0 && j < n && board[i][j] == num + 1) return helper(board, i, j, num + 1);\\n\\n        // right down\\n        i = row + 1;\\n        j = col + 2;\\n        if (i < n && j < n && board[i][j] == num + 1) return helper(board, i, j, num + 1);\\n\\n        // left up\\n        i = row - 1;\\n        j = col - 2;\\n        if (i >= 0 && j >= 0 && board[i][j] == num + 1) return helper(board, i, j, num + 1);\\n\\n        // left  down\\n        i = row + 1;\\n        j = col - 2;\\n        if (i < n && j >= 0 && board[i][j] == num + 1) return helper(board, i, j, num + 1);\\n        return false;\\n    }\\n    public boolean checkValidGrid(int[][] board) {\\n        if(board[0][0]!=0)return false;\\n        return helper(board,0,0,0);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n        private static boolean  helper(int[][] board, int row, int col, int num) {\\n        int n = board.length;\\n        if (board[row][col] == n*n-1) {\\n            return true;\\n        }\\n        int i, j;\\n        // up right\\n        i = row - 2;\\n        j = col + 1;\\n        if (i >= 0 && j < n && board[i][j] == num + 1) return helper(board, i, j, num + 1);\\n\\n        // up left\\n        i = row - 2;\\n        j = col - 1;\\n        if (i >= 0 && j >= 0 && board[i][j] == num + 1) return helper(board, i, j, num + 1);\\n\\n        // down right\\n        i = row + 2;\\n        j = col + 1;\\n        if (i < n && j < n && board[i][j] == num + 1) return helper(board, i, j, num + 1);\\n\\n        //down left\\n        i = row + 2;\\n        j = col - 1;\\n        if (i < n && j >= 0 && board[i][j] == num + 1) return helper(board, i, j, num + 1);\\n\\n        // right up\\n        i = row - 1;\\n        j = col + 2;\\n        if (i >= 0 && j < n && board[i][j] == num + 1) return helper(board, i, j, num + 1);\\n\\n        // right down\\n        i = row + 1;\\n        j = col + 2;\\n        if (i < n && j < n && board[i][j] == num + 1) return helper(board, i, j, num + 1);\\n\\n        // left up\\n        i = row - 1;\\n        j = col - 2;\\n        if (i >= 0 && j >= 0 && board[i][j] == num + 1) return helper(board, i, j, num + 1);\\n\\n        // left  down\\n        i = row + 1;\\n        j = col - 2;\\n        if (i < n && j >= 0 && board[i][j] == num + 1) return helper(board, i, j, num + 1);\\n        return false;\\n    }\\n    public boolean checkValidGrid(int[][] board) {\\n        if(board[0][0]!=0)return false;\\n        return helper(board,0,0,0);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037868,
                "title": "simple-beginner-level-c-solution-simulation-with-o-n-2-time-and-space-beats-50",
                "content": "\\n# Complexity\\n- Time complexity: ```O(n^2)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(n^2)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```cpp\\n// Runtime 8 ms Beats 50% Memory 6.4 MB Beats 50%\\nstruct Coord {\\n    int x; int y;\\n};\\nbool checkValidGrid(int** grid, int gridSize, int* gridColSize) {\\n    // Simulation \\n\\n    // Time complexity: O(n^2)\\n    // Space complexity: O(n^2)\\n\\n    if (grid[0][0] != 0) {\\n        return false;\\n    }\\n    const int n = gridSize;\\n    struct Coord** pos = (struct Coord**)calloc(n * n, sizeof(struct Coord*));\\n    for (int i = 0; i < n*n; i++) {\\n        pos[i] = (struct Coord*)calloc(1, sizeof(struct Coord));\\n    }\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            pos[grid[i][j]]->x = i;\\n            pos[grid[i][j]]->y = j;\\n        }\\n    }\\n\\n    for (int i = 1; i < n*n; i++) {\\n        const int x1 = pos[i - 1]->x, x2 = pos[i]->x;\\n        const int y1 = pos[i - 1]->y, y2 = pos[i]->y;\\n        const int dx = abs(x1 - x2), dy = abs(y1 - y2);\\n\\n        bool isValid = (dx == 1 && dy == 2) || (dx == 2 && dy == 1);\\n        if (isValid) continue; \\n\\n        for (int j = 0; j < n*n; j++) {\\n            free(pos[j]);\\n        }\\n        free(pos);\\n        return false;\\n    }\\n    \\n    for (int j = 0; j < n*n; j++) {\\n        free(pos[j]);\\n    }\\n    free(pos);\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```O(n^2)```\n```O(n^2)```\n```cpp\\n// Runtime 8 ms Beats 50% Memory 6.4 MB Beats 50%\\nstruct Coord {\\n    int x; int y;\\n};\\nbool checkValidGrid(int** grid, int gridSize, int* gridColSize) {\\n    // Simulation \\n\\n    // Time complexity: O(n^2)\\n    // Space complexity: O(n^2)\\n\\n    if (grid[0][0] != 0) {\\n        return false;\\n    }\\n    const int n = gridSize;\\n    struct Coord** pos = (struct Coord**)calloc(n * n, sizeof(struct Coord*));\\n    for (int i = 0; i < n*n; i++) {\\n        pos[i] = (struct Coord*)calloc(1, sizeof(struct Coord));\\n    }\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            pos[grid[i][j]]->x = i;\\n            pos[grid[i][j]]->y = j;\\n        }\\n    }\\n\\n    for (int i = 1; i < n*n; i++) {\\n        const int x1 = pos[i - 1]->x, x2 = pos[i]->x;\\n        const int y1 = pos[i - 1]->y, y2 = pos[i]->y;\\n        const int dx = abs(x1 - x2), dy = abs(y1 - y2);\\n\\n        bool isValid = (dx == 1 && dy == 2) || (dx == 2 && dy == 1);\\n        if (isValid) continue; \\n\\n        for (int j = 0; j < n*n; j++) {\\n            free(pos[j]);\\n        }\\n        free(pos);\\n        return false;\\n    }\\n    \\n    for (int j = 0; j < n*n; j++) {\\n        free(pos[j]);\\n    }\\n    free(pos);\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021171,
                "title": "elixir-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 294ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 63.7MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec check_valid_grid(grid :: [[integer]]) :: boolean\\n  def check_valid_grid(grid) do\\n    {_, dic} =\\n      Enum.reduce(grid, {0, %{}}, fn row, {i, dic} ->\\n        {_, dic} =\\n          Enum.reduce(row, {0, dic}, fn col, {j, dic} ->\\n            {j + 1, Map.put(dic, col, {i, j})}\\n          end)\\n        {i + 1, dic}\\n      end)\\n    n = Enum.count(grid)**2\\n    {i, j} = Map.get(dic, 0)\\n    if i != 0 or j != 0 do\\n      false\\n    else\\n      Enum.reduce_while(1..n-1, {true, i, j}, fn idx, {_, i, j} ->\\n        {n_i, n_j} = Map.get(dic, idx)\\n        if abs(n_i - i) == 1 and abs(n_j - j) == 2 or abs(n_i - i) == 2 and abs(n_j - j) == 1 do\\n          {:cont, {true, n_i, n_j}}\\n        else\\n          {:halt, {false, n_i, n_j}}\\n        end\\n      end) |> elem(0)\\n    end\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec check_valid_grid(grid :: [[integer]]) :: boolean\\n  def check_valid_grid(grid) do\\n    {_, dic} =\\n      Enum.reduce(grid, {0, %{}}, fn row, {i, dic} ->\\n        {_, dic} =\\n          Enum.reduce(row, {0, dic}, fn col, {j, dic} ->\\n            {j + 1, Map.put(dic, col, {i, j})}\\n          end)\\n        {i + 1, dic}\\n      end)\\n    n = Enum.count(grid)**2\\n    {i, j} = Map.get(dic, 0)\\n    if i != 0 or j != 0 do\\n      false\\n    else\\n      Enum.reduce_while(1..n-1, {true, i, j}, fn idx, {_, i, j} ->\\n        {n_i, n_j} = Map.get(dic, idx)\\n        if abs(n_i - i) == 1 and abs(n_j - j) == 2 or abs(n_i - i) == 2 and abs(n_j - j) == 1 do\\n          {:cont, {true, n_i, n_j}}\\n        else\\n          {:halt, {false, n_i, n_j}}\\n        end\\n      end) |> elem(0)\\n    end\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4020926,
                "title": "java-easy-to-understand-faster-solution",
                "content": "Easy Approach :- Firstly check 0 is present at grid[0][0] or not .Check if present and then go \\n                            to the element where num+1 is present. Helper Method check at which\\n\\t\\t\\t\\t\\t\\t\\tindex num+1 is present, go to that index and call again !!!\\n```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0] != 0)return false ;\\n        return helper(grid, 0, 0, 0);\\n    }\\n    public boolean helper(int[][]grid,int num,int row, int col){\\n        int n = grid.length;\\n        if(num == n*n-1)return true ;\\n        // check 2 up 1 left\\n        int i = row-2 ;\\n        int j = col-1 ;\\n        if(i>=0 && j>=0 && grid[i][j]==num+1)return helper(grid, num+1, i, j);\\n        \\n        // check 2 up 1 right\\n        i = row-2 ;\\n        j = col+1 ;\\n        if(i>=0 && j<n && grid[i][j] == num+1)return helper(grid, num+1, i, j);\\n        \\n        //check 2 down 1 left \\n        i = row+2 ;\\n        j = col-1 ;\\n        if(i<n && j>=0 && grid[i][j] == num+1)return helper(grid, num+1, i, j);\\n        \\n        //check 2 down 1 right \\n        i = row+2 ;\\n        j = col+1 ;\\n        if(i<n && j<n && grid[i][j] == num+1)return helper(grid, num+1, i, j);\\n        \\n        //check 2 left 1 up\\n        i = row-1 ;\\n        j = col-2 ;\\n        if(i>=0 && j>=0 && grid[i][j] == num+1)return helper(grid, num+1, i, j);\\n        \\n        //check 2 left 1 down\\n        i = row+1 ;\\n        j = col-2 ;\\n        if(i<n && j>=0 && grid[i][j] == num+1)return helper(grid, num+1, i, j);\\n        \\n        //check 2 right 1 up\\n        i = row-1 ;\\n        j = col+2 ;\\n        if(i>=0 && j<n && grid[i][j] == num+1)return helper(grid, num+1, i, j);\\n        \\n        //check 2 right 1 down\\n        i = row+1 ;\\n        j = col+2 ;\\n        if(i<n && j<n && grid[i][j] == num+1)return helper(grid, num+1, i, j);\\n        \\n        return false ;\\n    }\\n}\\n/// PLEASE UPVOTE !!!!!",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0] != 0)return false ;\\n        return helper(grid, 0, 0, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4009674,
                "title": "c-simulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>> moves = {{1, 2}, {2, 1}, {2, -1}, {1, -2},\\n        {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        if( grid[0][0] != 0 )\\n            return false;\\n            \\n        // simulation\\n        int r = 0, c = 0;\\n        for( int step = 1 ; step < grid.size() * grid.size() ; step++ ) {\\n            bool find = false;\\n            for( int i = 0 ; i < moves.size() && !find ; i++ ) {\\n                if( r + moves[i][0] >= 0 && r + moves[i][0] < grid.size() && \\n                    c + moves[i][1] >= 0 && c + moves[i][1] < grid[0].size() \\n                    && grid[r + moves[i][0]][c + moves[i][1]] == step ) {\\n                    r = r + moves[i][0], c = c + moves[i][1];\\n                    find = true;\\n                }\\n            }\\n\\n            if( !find )\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> moves = {{1, 2}, {2, 1}, {2, -1}, {1, -2},\\n        {-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}};\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        if( grid[0][0] != 0 )\\n            return false;\\n            \\n        // simulation\\n        int r = 0, c = 0;\\n        for( int step = 1 ; step < grid.size() * grid.size() ; step++ ) {\\n            bool find = false;\\n            for( int i = 0 ; i < moves.size() && !find ; i++ ) {\\n                if( r + moves[i][0] >= 0 && r + moves[i][0] < grid.size() && \\n                    c + moves[i][1] >= 0 && c + moves[i][1] < grid[0].size() \\n                    && grid[r + moves[i][0]][c + moves[i][1]] == step ) {\\n                    r = r + moves[i][0], c = c + moves[i][1];\\n                    find = true;\\n                }\\n            }\\n\\n            if( !find )\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980890,
                "title": "python3-solution-runtime-73-ms-beats-81-37-memory-16-2-mb-beats-85-55",
                "content": "# Intuition\\nIt\\'s clear that if we start from (0, 0) and we can move the knights to the next number each time, the condition is satisfied.\\n\\n# Approach\\nWe make a list of all possible moves for the knight and check whether any of them lead to the desired number. We write (0, 0) in the end so that we can check whether we\\'ve tried all of the moves or not.\\n\\nIf we find the desired step, we mpve our knight and repeat this until we move the knight all across the board or find a cell from which there is no appropriate move.\\n\\n# Code\\n```\\n# this function prevents from getting an error \"Index out of range\"\\ndef is_allowed(x, y, n):\\n    return 0 <= x < n and 0 <= y < n\\n\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        if grid[0][0]:\\n            return False\\n\\n\\n        data_of_moves = [[1, 2], [2, 1],\\n                        [-1, 2], [2, -1],\\n                        [1, -2], [-2, 1],\\n                        [-1, -2], [-2, -1],\\n                        [0, 0]]\\n\\n        n = len(grid)\\n\\n        coords = [0, 0]\\n\\n        for i in range(1, n**2):\\n            for step in data_of_moves:\\n                if step == [0, 0]:\\n                    return False\\n                if is_allowed(coords[0]+step[0], coords[1]+step[1], n):\\n                    if grid[coords[0]+step[0]][coords[1]+step[1]] == i:\\n                        coords = [coords[0]+step[0], coords[1]+step[1]]\\n                        break\\n                    \\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# this function prevents from getting an error \"Index out of range\"\\ndef is_allowed(x, y, n):\\n    return 0 <= x < n and 0 <= y < n\\n\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        if grid[0][0]:\\n            return False\\n\\n\\n        data_of_moves = [[1, 2], [2, 1],\\n                        [-1, 2], [2, -1],\\n                        [1, -2], [-2, 1],\\n                        [-1, -2], [-2, -1],\\n                        [0, 0]]\\n\\n        n = len(grid)\\n\\n        coords = [0, 0]\\n\\n        for i in range(1, n**2):\\n            for step in data_of_moves:\\n                if step == [0, 0]:\\n                    return False\\n                if is_allowed(coords[0]+step[0], coords[1]+step[1], n):\\n                    if grid[coords[0]+step[0]][coords[1]+step[1]] == i:\\n                        coords = [coords[0]+step[0], coords[1]+step[1]]\\n                        break\\n                    \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973019,
                "title": "only-uses-for-loop-and-no-recursion",
                "content": "# Intuition\\n<!-- Take your time -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]):\\n        if(grid[0][0]!=0):\\n            return False\\n        k=[(1,2),(-1,-2),(2,1),(-2,-1),(-1,2),(1,-2),(-2,1),(2,-1)]\\n        i=0\\n        j=0\\n        for o in range(1,len(grid)**2):\\n            for l in range(len(k)):\\n                x=i+k[l][0]\\n                y=j+k[l][1]\\n                if x<0 or y<0 or x>len(grid)-1 or y>len(grid)-1 or grid[x][y]!=o:\\n                    x=i\\n                    y=j\\n                    continue\\n                if grid[x][y]==o:\\n                    break\\n            i=x\\n            j=y\\n            if o!=grid[i][j]:\\n                return False\\n            if o==len(grid)**2-1:\\n                return True\\n\\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]):\\n        if(grid[0][0]!=0):\\n            return False\\n        k=[(1,2),(-1,-2),(2,1),(-2,-1),(-1,2),(1,-2),(-2,1),(2,-1)]\\n        i=0\\n        j=0\\n        for o in range(1,len(grid)**2):\\n            for l in range(len(k)):\\n                x=i+k[l][0]\\n                y=j+k[l][1]\\n                if x<0 or y<0 or x>len(grid)-1 or y>len(grid)-1 or grid[x][y]!=o:\\n                    x=i\\n                    y=j\\n                    continue\\n                if grid[x][y]==o:\\n                    break\\n            i=x\\n            j=y\\n            if o!=grid[i][j]:\\n                return False\\n            if o==len(grid)**2-1:\\n                return True\\n\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971264,
                "title": "purely-bfs-clears-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        def check(row,col):\\n            return 0<=row <len(grid) and 0<=col<len(grid) \\n        queue = [(0,0)]\\n        c = 0\\n        while queue:\\n            row,col = queue.pop()\\n            if check(row,col):\\n                if check(row+2,col+1) and  grid[row+2][col+1] == grid[row][col]+1:\\n                    c+=1\\n                    queue.append([row+2,col+1])\\n                elif check(row+2,col-1) and grid[row+2][col-1] == grid[row][col]+1:\\n                    c+=1\\n                    queue.append([row+2,col-1])\\n                elif check(row+1,col+2) and grid[row+1][col+2] == grid[row][col]+1:\\n                    c+=1\\n                    queue.append([row+1,col+2])\\n                elif check(row+1,col-2) and grid[row+1][col-2] == grid[row][col]+1:\\n                    c+=1\\n                    queue.append([row+1,col-2])\\n                elif check(row-1,col+2) and grid[row-1][col+2] == grid[row][col]+1:\\n                    c+=1\\n                    queue.append([row-1,col+2])\\n                elif check(row-1,col-2) and grid[row-1][col-2] == grid[row][col]+1:\\n                    c+=1\\n                    queue.append([row-1,col-2])\\n                elif check(row-2,col+1) and grid[row-2][col+1] == grid[row][col]+1:\\n                    c+=1\\n                    queue.append([row-2,col+1])\\n                elif check(row-2,col-1) and grid[row-2][col-1] == grid[row][col]+1:\\n                    c+=1\\n                    queue.append([row-2,col-1])\\n                elif c==len(grid)*len(grid)-1:\\n                    return True\\n                print(c)\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        def check(row,col):\\n            return 0<=row <len(grid) and 0<=col<len(grid) \\n        queue = [(0,0)]\\n        c = 0\\n        while queue:\\n            row,col = queue.pop()\\n            if check(row,col):\\n                if check(row+2,col+1) and  grid[row+2][col+1] == grid[row][col]+1:\\n                    c+=1\\n                    queue.append([row+2,col+1])\\n                elif check(row+2,col-1) and grid[row+2][col-1] == grid[row][col]+1:\\n                    c+=1\\n                    queue.append([row+2,col-1])\\n                elif check(row+1,col+2) and grid[row+1][col+2] == grid[row][col]+1:\\n                    c+=1\\n                    queue.append([row+1,col+2])\\n                elif check(row+1,col-2) and grid[row+1][col-2] == grid[row][col]+1:\\n                    c+=1\\n                    queue.append([row+1,col-2])\\n                elif check(row-1,col+2) and grid[row-1][col+2] == grid[row][col]+1:\\n                    c+=1\\n                    queue.append([row-1,col+2])\\n                elif check(row-1,col-2) and grid[row-1][col-2] == grid[row][col]+1:\\n                    c+=1\\n                    queue.append([row-1,col-2])\\n                elif check(row-2,col+1) and grid[row-2][col+1] == grid[row][col]+1:\\n                    c+=1\\n                    queue.append([row-2,col+1])\\n                elif check(row-2,col-1) and grid[row-2][col-1] == grid[row][col]+1:\\n                    c+=1\\n                    queue.append([row-2,col-1])\\n                elif c==len(grid)*len(grid)-1:\\n                    return True\\n                print(c)\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962544,
                "title": "100-beats-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] isSafe(int[][] grid,int row,int col,int nums){\\n        int n = grid.length;\\n        int i,j;\\n        // upper left\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0&&j>=0&&grid[i][j]==nums){\\n            return new int[]{i,j};\\n        }\\n        // upper right\\n        i = row-2;\\n        j = col+1;\\n        if(i>=0&&j<n&&grid[i][j]==nums){\\n            return new int[]{i,j};\\n        }\\n\\n        // left up\\n        i = row-1;\\n        j = col-2;\\n        if(i>=0&&j>=0&&grid[i][j]==nums){\\n            return new int[]{i,j};\\n        }\\n\\n        // left down\\n        i = row+1;\\n        j = col-2;\\n        if(i<n&&j>=0&&grid[i][j]==nums){\\n            return new int[]{i,j};\\n        }\\n\\n        // down left\\n        i = row+2;\\n        j = col-1;\\n        if(i<n&&j>=0&&grid[i][j]==nums){\\n            return new int[]{i,j};\\n        }\\n\\n        // down right\\n        i = row+2;\\n        j = col+1;\\n        if(i<n&&j<n&&grid[i][j]==nums){\\n            return new int[]{i,j};\\n        }\\n\\n        // right up\\n        i = row-1;\\n        j = col+2;\\n        if(i>=0&&j<n&&grid[i][j]==nums){\\n            return new int[]{i,j};\\n        }\\n\\n        // right down\\n        i = row+1;\\n        j = col+2;\\n        if(i<n&&j<n&&grid[i][j]==nums){\\n            return new int[]{i,j};\\n        }\\n\\n        return new int[]{-1,-1};\\n    }\\n    public boolean solve(int[][] grid,int i,int j,int nums){\\n        int n = grid.length;\\n        if(grid[i][j]==n*n-1){\\n            return true;\\n        }\\n        int ans[] = isSafe(grid,i,j,nums+1);\\n        if(ans[0]!=-1){\\n            return solve(grid,ans[0],ans[1],nums+1);\\n        }\\n        return false;\\n    }\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0]!=0){return false;}        \\n        return solve(grid,0,0,0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] isSafe(int[][] grid,int row,int col,int nums){\\n        int n = grid.length;\\n        int i,j;\\n        // upper left\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0&&j>=0&&grid[i][j]==nums){\\n            return new int[]{i,j};\\n        }\\n        // upper right\\n        i = row-2;\\n        j = col+1;\\n        if(i>=0&&j<n&&grid[i][j]==nums){\\n            return new int[]{i,j};\\n        }\\n\\n        // left up\\n        i = row-1;\\n        j = col-2;\\n        if(i>=0&&j>=0&&grid[i][j]==nums){\\n            return new int[]{i,j};\\n        }\\n\\n        // left down\\n        i = row+1;\\n        j = col-2;\\n        if(i<n&&j>=0&&grid[i][j]==nums){\\n            return new int[]{i,j};\\n        }\\n\\n        // down left\\n        i = row+2;\\n        j = col-1;\\n        if(i<n&&j>=0&&grid[i][j]==nums){\\n            return new int[]{i,j};\\n        }\\n\\n        // down right\\n        i = row+2;\\n        j = col+1;\\n        if(i<n&&j<n&&grid[i][j]==nums){\\n            return new int[]{i,j};\\n        }\\n\\n        // right up\\n        i = row-1;\\n        j = col+2;\\n        if(i>=0&&j<n&&grid[i][j]==nums){\\n            return new int[]{i,j};\\n        }\\n\\n        // right down\\n        i = row+1;\\n        j = col+2;\\n        if(i<n&&j<n&&grid[i][j]==nums){\\n            return new int[]{i,j};\\n        }\\n\\n        return new int[]{-1,-1};\\n    }\\n    public boolean solve(int[][] grid,int i,int j,int nums){\\n        int n = grid.length;\\n        if(grid[i][j]==n*n-1){\\n            return true;\\n        }\\n        int ans[] = isSafe(grid,i,j,nums+1);\\n        if(ans[0]!=-1){\\n            return solve(grid,ans[0],ans[1],nums+1);\\n        }\\n        return false;\\n    }\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0]!=0){return false;}        \\n        return solve(grid,0,0,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937969,
                "title": "bfs-without-queue",
                "content": "class Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0]!=0)\\n            return false;\\n        \\n        int n=grid.length;\\n        int max_count=n*n-1;\\n        int point[]={0, 0}; \\n        int[][] dirs = {{2,1},{2,-1},{-2,1},{-2,-1},\\n                        {1,2},{1,-2},{-1,2},{-1,-2}};\\n        \\n        for(int prev_step=1, step=1; step<=max_count;)\\n        {                            \\n            for(int dir[] : dirs) \\n            {\\n                int p = point[0] + dir[0];\\n                int q = point[1] + dir[1];\\n                         \\n                if(p < 0 || q < 0 || p >= n || q >= n \\n                   || grid[p][q] != step) \\n                    continue; \\n                if(step==max_count)\\n                    return true;\\n                point[0]=p;\\n                point[1]=q;\\n                step++;\\n                break;                                            \\n            }  \\n            \\n            if(prev_step==step)\\n                return false;\\n            prev_step=step;\\n        }\\n        \\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0]!=0)\\n            return false;\\n        \\n        int n=grid.length;\\n        int max_count=n*n-1;\\n        int point[]={0, 0}",
                "codeTag": "Java"
            },
            {
                "id": 3892526,
                "title": "c-clean-long-code-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:int a=0;\\n    void t(int i,int j,vector<vector<int>>& v,int m,int n,int c,vector<vector<int>>& g)\\n    {\\n        if(i>=m || j>=n || i<0 || j<0 || v[i][j]) return ;\\n        v[i][j]=1;\\n        a=max(a,c);\\n        if(i-1>=0 && j+2<n && g[i-1][j+2]==c) \\n        t(i-1,j+2,v,m,n,c+1,g);\\n        else if(i-2>=0 && j+1<n && g[i-2][j+1]==c) \\n        t(i-2,j+1,v,m,n,c+1,g);\\n        else if(i+1<m && j+2<n && g[i+1][j+2]==c) \\n        t(i+1,j+2,v,m,n,c+1,g);\\n        else if(i+2<m && j+1<n && g[i+2][j+1]==c) \\n        t(i+2,j+1,v,m,n,c+1,g);\\n        else if(i-1>=0 && j-2>=0 && g[i-1][j-2]==c) \\n        t(i-1,j-2,v,m,n,c+1,g);\\n        else if(i-2>=0 && j-1>=0 && g[i-2][j-1]==c) \\n        t(i-2,j-1,v,m,n,c+1,g);\\n        else if(i+1<m && j-2>=0 && g[i+1][j-2]==c) \\n        t(i+1,j-2,v,m,n,c+1,g);\\n        else if(i+2<m && j-1>=0 && g[i+2][j-1]==c) \\n        t(i+2,j-1,v,m,n,c+1,g);\\n    }\\n    bool checkValidGrid(vector<vector<int>>& g) {\\n        int m=g.size(),n=g[0].size();\\n        vector<vector<int>> v(m+1,vector<int> (n+1,0));\\n        t(0,0,v,m,n,1,g);\\n        return a==(m*n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:int a=0;\\n    void t(int i,int j,vector<vector<int>>& v,int m,int n,int c,vector<vector<int>>& g)\\n    {\\n        if(i>=m || j>=n || i<0 || j<0 || v[i][j]) return ;\\n        v[i][j]=1;\\n        a=max(a,c);\\n        if(i-1>=0 && j+2<n && g[i-1][j+2]==c) \\n        t(i-1,j+2,v,m,n,c+1,g);\\n        else if(i-2>=0 && j+1<n && g[i-2][j+1]==c) \\n        t(i-2,j+1,v,m,n,c+1,g);\\n        else if(i+1<m && j+2<n && g[i+1][j+2]==c) \\n        t(i+1,j+2,v,m,n,c+1,g);\\n        else if(i+2<m && j+1<n && g[i+2][j+1]==c) \\n        t(i+2,j+1,v,m,n,c+1,g);\\n        else if(i-1>=0 && j-2>=0 && g[i-1][j-2]==c) \\n        t(i-1,j-2,v,m,n,c+1,g);\\n        else if(i-2>=0 && j-1>=0 && g[i-2][j-1]==c) \\n        t(i-2,j-1,v,m,n,c+1,g);\\n        else if(i+1<m && j-2>=0 && g[i+1][j-2]==c) \\n        t(i+1,j-2,v,m,n,c+1,g);\\n        else if(i+2<m && j-1>=0 && g[i+2][j-1]==c) \\n        t(i+2,j-1,v,m,n,c+1,g);\\n    }\\n    bool checkValidGrid(vector<vector<int>>& g) {\\n        int m=g.size(),n=g[0].size();\\n        vector<vector<int>> v(m+1,vector<int> (n+1,0));\\n        t(0,0,v,m,n,1,g);\\n        return a==(m*n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882844,
                "title": "java-solution-100-beats-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        int n = grid.length;\\n        int final_step = (n*n)-1;\\n        int ans = movenight(grid , 0 , 0,0);\\n        if(ans==final_step){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        // System.out.println(ans);\\n        // return false;\\n        \\n    }\\n    static int movenight(int[][]grid, int row , int col , int step){\\n        int n = grid.length;\\n        if(step==(n*n)-1){\\n             return step;\\n        }\\n       \\n        int count =0;\\n          if(grid[row][col]==step){\\n           if(isValid(grid, row-2, col-1)){\\n            if(grid[row-2][col-1]==step+1){\\n                count= count + movenight(grid ,  row-2 , col-1 , step+1);\\n            }\\n        }\\n       if(isValid(grid, row-1, col-2)){\\n            if(grid[row-1][col-2]==step+1){\\n               count= count + movenight(grid ,  row-1 , col-2 , step+1);\\n                \\n            }\\n        }\\n        if(isValid(grid, row-2, col+1)){\\n            if(grid[row-2][col+1]==step+1){\\n               count= count + movenight(grid ,  row-2 , col+1 , step+1);\\n            }\\n        }\\n      if(isValid(grid, row-1, col+2)){\\n            if(grid[row-1][col+2]==step+1){\\n               count= count + movenight(grid ,  row-1 , col+2 , step+1);\\n            }\\n\\n         }\\n         if(isValid(grid, row+2, col-1)){\\n            if(grid[row+2][col-1]==step+1){\\n                count= count +movenight(grid ,  row+2 , col-1 , step+1);\\n            }\\n        }\\n       if(isValid(grid, row+1, col-2)){\\n            if(grid[row+1][col-2]==step+1){\\n                count= count +movenight(grid ,  row+1 , col-2 , step+1);\\n                \\n            }\\n        }\\n        if(isValid(grid, row+2, col+1)){\\n            if(grid[row+2][col+1]==step+1){\\n                count= count +movenight(grid ,  row+2 , col+1 , step+1);\\n            }\\n        }\\n      if(isValid(grid, row+1, col+2)){\\n            if(grid[row+1][col+2]==step+1){\\n                count= count +movenight(grid ,  row+1 , col+2 , step+1);\\n            }\\n\\n         }\\n\\n          }\\n          return count;\\n\\n\\n    }\\n\\n    static boolean isValid(int[][] grid,int row,int col){\\n        if(row>=0 && row<grid.length && col>=0 && col<grid.length){\\n            return true;\\n        }\\n        return false;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        int n = grid.length;\\n        int final_step = (n*n)-1;\\n        int ans = movenight(grid , 0 , 0,0);\\n        if(ans==final_step){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        // System.out.println(ans);\\n        // return false;\\n        \\n    }\\n    static int movenight(int[][]grid, int row , int col , int step){\\n        int n = grid.length;\\n        if(step==(n*n)-1){\\n             return step;\\n        }\\n       \\n        int count =0;\\n          if(grid[row][col]==step){\\n           if(isValid(grid, row-2, col-1)){\\n            if(grid[row-2][col-1]==step+1){\\n                count= count + movenight(grid ,  row-2 , col-1 , step+1);\\n            }\\n        }\\n       if(isValid(grid, row-1, col-2)){\\n            if(grid[row-1][col-2]==step+1){\\n               count= count + movenight(grid ,  row-1 , col-2 , step+1);\\n                \\n            }\\n        }\\n        if(isValid(grid, row-2, col+1)){\\n            if(grid[row-2][col+1]==step+1){\\n               count= count + movenight(grid ,  row-2 , col+1 , step+1);\\n            }\\n        }\\n      if(isValid(grid, row-1, col+2)){\\n            if(grid[row-1][col+2]==step+1){\\n               count= count + movenight(grid ,  row-1 , col+2 , step+1);\\n            }\\n\\n         }\\n         if(isValid(grid, row+2, col-1)){\\n            if(grid[row+2][col-1]==step+1){\\n                count= count +movenight(grid ,  row+2 , col-1 , step+1);\\n            }\\n        }\\n       if(isValid(grid, row+1, col-2)){\\n            if(grid[row+1][col-2]==step+1){\\n                count= count +movenight(grid ,  row+1 , col-2 , step+1);\\n                \\n            }\\n        }\\n        if(isValid(grid, row+2, col+1)){\\n            if(grid[row+2][col+1]==step+1){\\n                count= count +movenight(grid ,  row+2 , col+1 , step+1);\\n            }\\n        }\\n      if(isValid(grid, row+1, col+2)){\\n            if(grid[row+1][col+2]==step+1){\\n                count= count +movenight(grid ,  row+1 , col+2 , step+1);\\n            }\\n\\n         }\\n\\n          }\\n          return count;\\n\\n\\n    }\\n\\n    static boolean isValid(int[][] grid,int row,int col){\\n        if(row>=0 && row<grid.length && col>=0 && col<grid.length){\\n            return true;\\n        }\\n        return false;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872234,
                "title": "beats-99-7-t-c-bfs-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\nbool checkValidGrid(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        vector<vector<int>>visit(n,vector<int>(n,0));\\n\\n    vector<int>dx{2,2,-2,-2,-1,1,1,-1};\\n    vector<int>dy{-1,1,-1,1,-2,-2,2,2};\\n    int cnt=0;\\n\\n    queue<pair<int,pair<int,int>>>q;\\n    q.push({1,{0,0}});  // starting point\\n  \\nif(grid[0][0]!=0) return false;\\n    while(!q.empty()){\\n\\n        int k=q.size();\\n\\n        for(int i=0;i<k;i++){\\n\\n            auto p=q.front();\\n            q.pop();\\n\\n            int x=p.second.first;\\n            int y=p.second.second;\\n             cnt=p.first;\\n            \\n            if(cnt==n*n) return true;\\n          \\n            for(int j=0;j<8;j++){\\n                int nx=x+dx[j];\\n                int ny=y+dy[j];\\n\\n               if(nx>=0 && ny>=0 && nx<n && ny<n && grid[nx][ny]==cnt){\\n                   q.push({cnt+1,{nx,ny}});\\n                   cnt++;\\n               } \\n            }\\n        }\\n    }\\n\\n  \\n    return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\nbool checkValidGrid(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        vector<vector<int>>visit(n,vector<int>(n,0));\\n\\n    vector<int>dx{2,2,-2,-2,-1,1,1,-1};\\n    vector<int>dy{-1,1,-1,1,-2,-2,2,2};\\n    int cnt=0;\\n\\n    queue<pair<int,pair<int,int>>>q;\\n    q.push({1,{0,0}});  // starting point\\n  \\nif(grid[0][0]!=0) return false;\\n    while(!q.empty()){\\n\\n        int k=q.size();\\n\\n        for(int i=0;i<k;i++){\\n\\n            auto p=q.front();\\n            q.pop();\\n\\n            int x=p.second.first;\\n            int y=p.second.second;\\n             cnt=p.first;\\n            \\n            if(cnt==n*n) return true;\\n          \\n            for(int j=0;j<8;j++){\\n                int nx=x+dx[j];\\n                int ny=y+dy[j];\\n\\n               if(nx>=0 && ny>=0 && nx<n && ny<n && grid[nx][ny]==cnt){\\n                   q.push({cnt+1,{nx,ny}});\\n                   cnt++;\\n               } \\n            }\\n        }\\n    }\\n\\n  \\n    return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870563,
                "title": "c-solution-simple-to-understand",
                "content": "```\\nclass Solution {\\n    \\nprivate:\\n\\n   void f(int row , int col , vector<vector<int>>& grid , int n , int parent , int &cnt)\\n    {\\n\\n        if(row < 0 || row >= n || col < 0 || col >= n || parent +1 != grid[row][col])\\n        {\\n            return;\\n        }\\n           parent = grid[row][col];\\n     \\n            cnt++;\\n\\n        int drow[8] = {-2 , -2 , -1 , -1 , 1 , 1 , 2 , 2};\\n        int dcol[8] = {-1 , 1 , -2 , 2 , -2 , 2 , -1 , 1};\\n        \\n        for(int i = 0; i < 8; i++)\\n        {\\n            int nrow = row + drow[i];\\n            int ncol = col + dcol[i];\\n            \\n            f(nrow , ncol , grid , n , parent , cnt);\\n            \\n        }\\n\\n    }\\n    \\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int cnt = 0;\\n        f(0 , 0 , grid , n , -1 , cnt);\\n        \\n        if(cnt == (n*n)) return 1;\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\nprivate:\\n\\n   void f(int row , int col , vector<vector<int>>& grid , int n , int parent , int &cnt)\\n    {\\n\\n        if(row < 0 || row >= n || col < 0 || col >= n || parent +1 != grid[row][col])\\n        {\\n            return;\\n        }\\n           parent = grid[row][col];\\n     \\n            cnt++;\\n\\n        int drow[8] = {-2 , -2 , -1 , -1 , 1 , 1 , 2 , 2};\\n        int dcol[8] = {-1 , 1 , -2 , 2 , -2 , 2 , -1 , 1};\\n        \\n        for(int i = 0; i < 8; i++)\\n        {\\n            int nrow = row + drow[i];\\n            int ncol = col + dcol[i];\\n            \\n            f(nrow , ncol , grid , n , parent , cnt);\\n            \\n        }\\n\\n    }\\n    \\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int cnt = 0;\\n        f(0 , 0 , grid , n , -1 , cnt);\\n        \\n        if(cnt == (n*n)) return 1;\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847279,
                "title": "simple-recursion",
                "content": "\\n# Approach\\nSimply check all the moves that night can make and see if any move can satisfies the current order\\n\\n# Complexity\\n- Time complexity:\\n  O(n * n)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int xMove[] = { 2, 1, -1, -2, -2, -1, 1, 2 };\\n    int yMove[] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0] != 0) return false;\\n        return find(0, 0, 1, grid);\\n    }\\n\\n    public boolean find(int x, int y, int moveI, int[][] board){\\n\\n        if (moveI == board.length * board.length)\\n            return true;\\n\\n        for (int i = 0; i < 8; i++) {\\n            int nextX = x + xMove[i];\\n            int nextY = y + yMove[i];\\n            //check if index is not out of bonds and if any of the moves satisfies the given grid\\n            if(isSafe(nextX, nextY, board, moveI)){\\n                return find(nextX, nextY, moveI + 1, board);\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    public boolean isSafe(int r, int c, int[][] board, int moveI){\\n\\n        if(r >= board.length || r < 0 || c >= board.length || c < 0 || board[r][c] != moveI){\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int xMove[] = { 2, 1, -1, -2, -2, -1, 1, 2 };\\n    int yMove[] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0] != 0) return false;\\n        return find(0, 0, 1, grid);\\n    }\\n\\n    public boolean find(int x, int y, int moveI, int[][] board){\\n\\n        if (moveI == board.length * board.length)\\n            return true;\\n\\n        for (int i = 0; i < 8; i++) {\\n            int nextX = x + xMove[i];\\n            int nextY = y + yMove[i];\\n            //check if index is not out of bonds and if any of the moves satisfies the given grid\\n            if(isSafe(nextX, nextY, board, moveI)){\\n                return find(nextX, nextY, moveI + 1, board);\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    public boolean isSafe(int r, int c, int[][] board, int moveI){\\n\\n        if(r >= board.length || r < 0 || c >= board.length || c < 0 || board[r][c] != moveI){\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847134,
                "title": "c-simple-and-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(int i,int j,int n,int m){\\n        return (i>=0 && i<n && j>=0 && j<m);\\n    }\\n    // void dfs(int i,int j,int n,int m,int count,bool &ok,vector<vector<int>>&grid){\\n    //     if(grid[i][j]!=count){\\n    //         ok=false;\\n    //         return;\\n    //     }\\n    //     int dx[]={-2,-1,1,2,2,1,-1,-2};\\n    //     int dy[]={1,2,2,1,-1,-2,-2,-1};\\n    //     int cnt=0;\\n    //     for(int k=0;k<8;k++){\\n    //         int nx=i+dx[k];\\n    //         int ny=j+dy[k];\\n    //         if(isvalid(nx,ny,n,m) && grid[nx][ny]==count+1)cnt++;\\n    //         if(isvalid(nx,ny,n,m) && grid[nx][ny]==count+1){\\n    //             dfs(nx,ny,n,m,count+1,ok,grid);\\n    //         }\\n    //     }\\n    //     if(cnt==0){\\n    //         ok=false;\\n    //         return;\\n    //     }\\n    // }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(grid[0][0]!=0)return false;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        while(!q.empty()){\\n            int i=q.front().first;\\n            int j=q.front().second.first;\\n            int cnt=q.front().second.second;\\n            q.pop();\\n            int dx[]={-2,-1,1,2,2,1,-1,-2};\\n            int dy[]={1,2,2,1,-1,-2,-2,-1};\\n            for(int k=0;k<8;k++){\\n                int nx=i+dx[k];\\n                int ny=j+dy[k];\\n                if(isvalid(nx,ny,n,m) && grid[nx][ny]==cnt+1){\\n                    q.push({nx,{ny,cnt+1}});\\n                }\\n           }\\n           if(q.size()==0 && cnt!=n*n-1)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int i,int j,int n,int m){\\n        return (i>=0 && i<n && j>=0 && j<m);\\n    }\\n    // void dfs(int i,int j,int n,int m,int count,bool &ok,vector<vector<int>>&grid){\\n    //     if(grid[i][j]!=count){\\n    //         ok=false;\\n    //         return;\\n    //     }\\n    //     int dx[]={-2,-1,1,2,2,1,-1,-2};\\n    //     int dy[]={1,2,2,1,-1,-2,-2,-1};\\n    //     int cnt=0;\\n    //     for(int k=0;k<8;k++){\\n    //         int nx=i+dx[k];\\n    //         int ny=j+dy[k];\\n    //         if(isvalid(nx,ny,n,m) && grid[nx][ny]==count+1)cnt++;\\n    //         if(isvalid(nx,ny,n,m) && grid[nx][ny]==count+1){\\n    //             dfs(nx,ny,n,m,count+1,ok,grid);\\n    //         }\\n    //     }\\n    //     if(cnt==0){\\n    //         ok=false;\\n    //         return;\\n    //     }\\n    // }\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(grid[0][0]!=0)return false;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        while(!q.empty()){\\n            int i=q.front().first;\\n            int j=q.front().second.first;\\n            int cnt=q.front().second.second;\\n            q.pop();\\n            int dx[]={-2,-1,1,2,2,1,-1,-2};\\n            int dy[]={1,2,2,1,-1,-2,-2,-1};\\n            for(int k=0;k<8;k++){\\n                int nx=i+dx[k];\\n                int ny=j+dy[k];\\n                if(isvalid(nx,ny,n,m) && grid[nx][ny]==cnt+1){\\n                    q.push({nx,{ny,cnt+1}});\\n                }\\n           }\\n           if(q.size()==0 && cnt!=n*n-1)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835874,
                "title": "c-intuitive",
                "content": "# Intuition\\ncreate a coordinate steps vector for each move, then verify each step.\\n\\n# Approach\\n\\nCheck valid move:\\n((x==1||x==2) && (y==1||y==2) && x!=y)\\n\\nIf not valid, return false;\\n\\nAt the end of loop, return true, since every step is valid.\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\nO(N*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<pair<int, int>> steps(n*n, {0,0});\\n        for(int i = 0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                steps[grid[i][j]] = {i,j};\\n            }\\n        }\\n        int k = 0;\\n        pair<int, int> prev = steps[0];\\n        if (prev.first!=0 || prev.second!=0) return false;\\n        for(k=1; k<n*n; prev = steps[k++]) {\\n            pair<int, int> cur = steps[k];\\n            int x = abs(cur.first-prev.first);\\n            int y = abs(cur.second-prev.second);\\n            if (!((x==1||x==2) && (y==1||y==2) && x!=y)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<pair<int, int>> steps(n*n, {0,0});\\n        for(int i = 0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                steps[grid[i][j]] = {i,j};\\n            }\\n        }\\n        int k = 0;\\n        pair<int, int> prev = steps[0];\\n        if (prev.first!=0 || prev.second!=0) return false;\\n        for(k=1; k<n*n; prev = steps[k++]) {\\n            pair<int, int> cur = steps[k];\\n            int x = abs(cur.first-prev.first);\\n            int y = abs(cur.second-prev.second);\\n            if (!((x==1||x==2) && (y==1||y==2) && x!=y)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835210,
                "title": "c-easy-solution-using-bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        int n = grid.size() ; \\n        vector<vector<int>>vis(n,vector<int>(n,0));\\n        int dir[8][2]={{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};\\n        vis[0][0] = 1;\\n        int target = 1;\\n        while(!q.empty()){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            vis[row][col] = 1;\\n           for(auto it: dir){\\n               int nrow = row + it[0];\\n               int ncol = col + it[1];\\n               if(nrow>=0 && nrow<n && ncol>=0 && ncol<n && vis[nrow][ncol]==0 && grid[nrow][ncol] == target){\\n                   q.push({nrow,ncol});\\n                   target++;\\n                   break;\\n               }\\n           }\\n        }\\n\\n    if(target==n*n) return true;\\n     return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        int n = grid.size() ; \\n        vector<vector<int>>vis(n,vector<int>(n,0));\\n        int dir[8][2]={{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};\\n        vis[0][0] = 1;\\n        int target = 1;\\n        while(!q.empty()){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            vis[row][col] = 1;\\n           for(auto it: dir){\\n               int nrow = row + it[0];\\n               int ncol = col + it[1];\\n               if(nrow>=0 && nrow<n && ncol>=0 && ncol<n && vis[nrow][ncol]==0 && grid[nrow][ncol] == target){\\n                   q.push({nrow,ncol});\\n                   target++;\\n                   break;\\n               }\\n           }\\n        }\\n\\n    if(target==n*n) return true;\\n     return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833626,
                "title": "knight-s-tour-configuration-validation-via-backtracking",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        return check(grid, 0, 0, 0);\\n    }\\n\\n    public static boolean check(int[][] grid, int r, int c, int moves) {\\n        if (r < 0 || c < 0 || r >= grid.length || c >= grid.length) {\\n            return false;\\n        }\\n        if (grid[r][c] != moves) {\\n            return false;\\n        }\\n        if (grid[r][c] == moves && moves == ((grid.length * grid.length) - 1)) {\\n            return true;\\n        }\\n\\n        boolean step1 = check(grid, r - 2, c + 1, moves + 1);\\n        boolean step2 = check(grid, r - 1, c + 2, moves + 1);\\n        boolean step3 = check(grid, r + 1, c + 2, moves + 1);\\n        boolean step4 = check(grid, r + 2, c + 1, moves + 1);\\n        boolean step5 = check(grid, r + 2, c - 1, moves + 1);\\n        boolean step6 = check(grid, r + 1, c - 2, moves + 1);\\n        boolean step7 = check(grid, r - 1, c - 2, moves + 1);\\n        boolean step8 = check(grid, r - 2, c - 1, moves + 1);\\n\\n        if (step1 || step2 || step3 || step4 || step5 || step6 || step7 || step8) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        return check(grid, 0, 0, 0);\\n    }\\n\\n    public static boolean check(int[][] grid, int r, int c, int moves) {\\n        if (r < 0 || c < 0 || r >= grid.length || c >= grid.length) {\\n            return false;\\n        }\\n        if (grid[r][c] != moves) {\\n            return false;\\n        }\\n        if (grid[r][c] == moves && moves == ((grid.length * grid.length) - 1)) {\\n            return true;\\n        }\\n\\n        boolean step1 = check(grid, r - 2, c + 1, moves + 1);\\n        boolean step2 = check(grid, r - 1, c + 2, moves + 1);\\n        boolean step3 = check(grid, r + 1, c + 2, moves + 1);\\n        boolean step4 = check(grid, r + 2, c + 1, moves + 1);\\n        boolean step5 = check(grid, r + 2, c - 1, moves + 1);\\n        boolean step6 = check(grid, r + 1, c - 2, moves + 1);\\n        boolean step7 = check(grid, r - 1, c - 2, moves + 1);\\n        boolean step8 = check(grid, r - 2, c - 1, moves + 1);\\n\\n        if (step1 || step2 || step3 || step4 || step5 || step6 || step7 || step8) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829091,
                "title": "java-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValidGridHelper(int[][] grid,int i,int j,int prev) {\\n        if(i<0||j<0||i>grid.length-1||j>grid[0].length-1||grid[i][j]==-1||grid[i][j]-prev!=1){\\n            return false;\\n        }\\n        if(grid[i][j]==(grid.length*grid.length)-1){\\n            return true;\\n        }\\n        int x=grid[i][j];\\n        grid[i][j]=-1;\\n        boolean ans=checkValidGridHelper(grid,i+2,j+1,x)||checkValidGridHelper(grid,i-2,j-1,x)||checkValidGridHelper(grid,i+1,j+2,x)||checkValidGridHelper(grid,i-1,j-2,x)||checkValidGridHelper(grid,i+2,j-1,x)||checkValidGridHelper(grid,i+1,j-2,x)||checkValidGridHelper(grid,i-1,j+2,x)||checkValidGridHelper(grid,i-2,j+1,x);\\n        grid[i][j]=x;\\n        return ans;\\n        \\n\\n    }\\n     public boolean checkValidGrid(int[][] grid){\\n         return checkValidGridHelper(grid,0,0,-1);\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidGridHelper(int[][] grid,int i,int j,int prev) {\\n        if(i<0||j<0||i>grid.length-1||j>grid[0].length-1||grid[i][j]==-1||grid[i][j]-prev!=1){\\n            return false;\\n        }\\n        if(grid[i][j]==(grid.length*grid.length)-1){\\n            return true;\\n        }\\n        int x=grid[i][j];\\n        grid[i][j]=-1;\\n        boolean ans=checkValidGridHelper(grid,i+2,j+1,x)||checkValidGridHelper(grid,i-2,j-1,x)||checkValidGridHelper(grid,i+1,j+2,x)||checkValidGridHelper(grid,i-1,j-2,x)||checkValidGridHelper(grid,i+2,j-1,x)||checkValidGridHelper(grid,i+1,j-2,x)||checkValidGridHelper(grid,i-1,j+2,x)||checkValidGridHelper(grid,i-2,j+1,x);\\n        grid[i][j]=x;\\n        return ans;\\n        \\n\\n    }\\n     public boolean checkValidGrid(int[][] grid){\\n         return checkValidGridHelper(grid,0,0,-1);\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824316,
                "title": "java-easy-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) \\n    {\\n        if(grid[0][0]!=0)\\n        {\\n            return false;\\n        }\\n        return helper(grid,0,0,0);\\n    }\\n\\n    private boolean helper(int[][] grid, int row, int col,int num)\\n    {\\n        int n = grid.length;\\n        if(grid[row][col] == n * n - 1)\\n        {\\n            return true;\\n        }\\n\\n        int i = 0;\\n        int j = 0;\\n\\n        //up left\\n        i = row-2;\\n        j = col-1;\\n\\n        if(i>=0 && j>=0 && grid[i][j]==num+1)\\n        {\\n            return helper(grid,i,j,num+1);\\n        }\\n\\n        //up right\\n        i = row-2;\\n        j = col+1;\\n\\n        if(i>=0 && j<n && grid[i][j]==num+1)\\n        {\\n            return helper(grid,i,j,num+1);\\n        }\\n\\n        //right up\\n        i = row-1;\\n        j = col+2;\\n\\n        if(i>=0 && j<n && grid[i][j]==num+1)\\n        {\\n            return helper(grid,i,j,num+1);\\n        }\\n\\n        //right down\\n        i = row+1;\\n        j = col+2;\\n\\n        if(i<n && j<n && grid[i][j]==num+1)\\n        {\\n            return helper(grid,i,j,num+1);\\n        }\\n\\n        //left up\\n        i = row-1;\\n        j = col-2;\\n\\n        if(i>=0 && j>=0 && grid[i][j]==num+1)\\n        {\\n            return helper(grid,i,j,num+1);\\n        }\\n\\n        //left down\\n        i = row+1;\\n        j = col-2;\\n\\n        if(i<n && j>=0 && grid[i][j]==num+1)\\n        {\\n            return helper(grid,i,j,num+1);\\n        }\\n\\n        //down left\\n        i = row+2;\\n        j = col-1;\\n\\n        if(i<n && j>=0 && grid[i][j]==num+1)\\n        {\\n            return helper(grid,i,j,num+1);\\n        }\\n\\n        //down right\\n        i = row+2;\\n        j = col+1;\\n\\n        if(i<n && j<n && grid[i][j]==num+1)\\n        {\\n            return helper(grid,i,j,num+1);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) \\n    {\\n        if(grid[0][0]!=0)\\n        {\\n            return false;\\n        }\\n        return helper(grid,0,0,0);\\n    }\\n\\n    private boolean helper(int[][] grid, int row, int col,int num)\\n    {\\n        int n = grid.length;\\n        if(grid[row][col] == n * n - 1)\\n        {\\n            return true;\\n        }\\n\\n        int i = 0;\\n        int j = 0;\\n\\n        //up left\\n        i = row-2;\\n        j = col-1;\\n\\n        if(i>=0 && j>=0 && grid[i][j]==num+1)\\n        {\\n            return helper(grid,i,j,num+1);\\n        }\\n\\n        //up right\\n        i = row-2;\\n        j = col+1;\\n\\n        if(i>=0 && j<n && grid[i][j]==num+1)\\n        {\\n            return helper(grid,i,j,num+1);\\n        }\\n\\n        //right up\\n        i = row-1;\\n        j = col+2;\\n\\n        if(i>=0 && j<n && grid[i][j]==num+1)\\n        {\\n            return helper(grid,i,j,num+1);\\n        }\\n\\n        //right down\\n        i = row+1;\\n        j = col+2;\\n\\n        if(i<n && j<n && grid[i][j]==num+1)\\n        {\\n            return helper(grid,i,j,num+1);\\n        }\\n\\n        //left up\\n        i = row-1;\\n        j = col-2;\\n\\n        if(i>=0 && j>=0 && grid[i][j]==num+1)\\n        {\\n            return helper(grid,i,j,num+1);\\n        }\\n\\n        //left down\\n        i = row+1;\\n        j = col-2;\\n\\n        if(i<n && j>=0 && grid[i][j]==num+1)\\n        {\\n            return helper(grid,i,j,num+1);\\n        }\\n\\n        //down left\\n        i = row+2;\\n        j = col-1;\\n\\n        if(i<n && j>=0 && grid[i][j]==num+1)\\n        {\\n            return helper(grid,i,j,num+1);\\n        }\\n\\n        //down right\\n        i = row+2;\\n        j = col+1;\\n\\n        if(i<n && j<n && grid[i][j]==num+1)\\n        {\\n            return helper(grid,i,j,num+1);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821375,
                "title": "easy-to-understand-solution-with-explanation",
                "content": "# Intuition\\nFor a current cell in the grid there are only a certain amount of valid choices of where the knight can go (maximum of 8). For example, for the first (0, 0) coordinate, the knight can only go to (2, 1) and (1, 2). Hence, at each step we look through all the possible valid moves from that current position and see if the grid has the value of the current step (e.g. step number 4 has a value of 3, because we start with 0).\\n# Approach\\nLoop through all the grid cells and see if the step number corresponds to a valid knight move from that position.\\n# Complexity\\n- Time complexity:\\nO(n**2) - n squared where n is the length of the grid\\n- Space complexity:\\nO(n**2) + O(k) where k is just a few variables\\n# Code\\n```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        grid_len = len(grid)\\n        total_grid_len = grid_len**2\\n        if grid[0][0] != 0:\\n            return False\\n        x, y = 0, 0 # initial coordinates\\n        for num in range(1, total_grid_len):\\n            if x+2 < grid_len and y+1 < grid_len and grid[x+2][y+1] == num:\\n                x = x+2\\n                y = y+1\\n            elif x-2 >= 0 and y+1 < grid_len and grid[x-2][y+1] == num:\\n                x = x-2\\n                y = y+1\\n            elif x-2 >= 0 and y-1 >= 0 and grid[x-2][y-1] == num:\\n                x = x-2\\n                y = y-1\\n            elif x+2 < grid_len and y-1 >= 0 and grid[x+2][y-1] == num:\\n                x = x+2\\n                y = y-1\\n            elif y+2 < grid_len and x-1 >= 0 and grid[x-1][y+2] == num:\\n                x = x-1\\n                y = y+2\\n            elif x-1 >= 0 and y-2 >= 0 and grid[x-1][y-2] == num:\\n                x = x-1\\n                y = y-2\\n            elif x+1 < grid_len and y-2 >= 0 and grid[x+1][y-2] == num:\\n                x = x+1\\n                y = y-2\\n            elif x+1 < grid_len and y+2 < grid_len and grid[x+1][y+2] == num:\\n                x = x+1\\n                y = y+2\\n            else:\\n                return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        grid_len = len(grid)\\n        total_grid_len = grid_len**2\\n        if grid[0][0] != 0:\\n            return False\\n        x, y = 0, 0 # initial coordinates\\n        for num in range(1, total_grid_len):\\n            if x+2 < grid_len and y+1 < grid_len and grid[x+2][y+1] == num:\\n                x = x+2\\n                y = y+1\\n            elif x-2 >= 0 and y+1 < grid_len and grid[x-2][y+1] == num:\\n                x = x-2\\n                y = y+1\\n            elif x-2 >= 0 and y-1 >= 0 and grid[x-2][y-1] == num:\\n                x = x-2\\n                y = y-1\\n            elif x+2 < grid_len and y-1 >= 0 and grid[x+2][y-1] == num:\\n                x = x+2\\n                y = y-1\\n            elif y+2 < grid_len and x-1 >= 0 and grid[x-1][y+2] == num:\\n                x = x-1\\n                y = y+2\\n            elif x-1 >= 0 and y-2 >= 0 and grid[x-1][y-2] == num:\\n                x = x-1\\n                y = y-2\\n            elif x+1 < grid_len and y-2 >= 0 and grid[x+1][y-2] == num:\\n                x = x+1\\n                y = y-2\\n            elif x+1 < grid_len and y+2 < grid_len and grid[x+1][y+2] == num:\\n                x = x+1\\n                y = y+2\\n            else:\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817303,
                "title": "java-dfs-solution-beats-100-in-runtime",
                "content": "\\n\\n# Approach\\nStore all possible moves from a position to an array. We have total 8 possible moves from a position. Start a DFS from position (0, 0) and check next cell(nx, ny) that we can go from the current cell(x, y) has value grid[nx][ny] = grid[x][y] + 1 or not. If we can go then to move to the next cell (nx, ny) and do the same approach recursively. At last we check if all the cells visited or not. If yes then return true otherwise false.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[] dx = {-1, -1, 1, 1, 2, 2, -2, -2};\\n    int[] dy = {2, -2, 2, -2, 1, -1, 1, -1};\\n\\n    void dfs(int[][] grid, int x, int y, int cnt){\\n        for(int i = 0; i < 8; i++){\\n            int nx = x + dx[i], ny = y + dy[i];\\n            if (nx >= 0 && ny >= 0 && nx < grid.length && ny < grid[0].length && grid[nx][ny] == cnt){\\n                grid[nx][ny] = -1;\\n                dfs(grid, nx, ny, cnt + 1);\\n                break;\\n            }\\n        }\\n    }\\n    public boolean checkValidGrid(int[][] grid) {\\n        grid[0][0] = -1;\\n        dfs(grid, 0, 0, 1);\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if (grid[i][j] != -1){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int[] dx = {-1, -1, 1, 1, 2, 2, -2, -2};\\n    int[] dy = {2, -2, 2, -2, 1, -1, 1, -1};\\n\\n    void dfs(int[][] grid, int x, int y, int cnt){\\n        for(int i = 0; i < 8; i++){\\n            int nx = x + dx[i], ny = y + dy[i];\\n            if (nx >= 0 && ny >= 0 && nx < grid.length && ny < grid[0].length && grid[nx][ny] == cnt){\\n                grid[nx][ny] = -1;\\n                dfs(grid, nx, ny, cnt + 1);\\n                break;\\n            }\\n        }\\n    }\\n    public boolean checkValidGrid(int[][] grid) {\\n        grid[0][0] = -1;\\n        dfs(grid, 0, 0, 1);\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if (grid[i][j] != -1){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810681,
                "title": "golang-search-solution",
                "content": "# Code\\n```go\\nfunc checkValidGrid(grid [][]int) bool {\\n    if grid[0][0] != 0 {\\n        return false\\n    }\\n    return check(0, 0, 0, grid)\\n}\\n\\nfunc check(i, j, num int, grid [][]int) bool {\\n    if num == len(grid)*len(grid)-1 {\\n        return true\\n    }\\n    if isOK(i+2, j+1, num+1, grid) {\\n        return check(i+2, j+1, num+1, grid)\\n    }\\n    if isOK(i+2, j-1, num+1, grid) {\\n        return check(i+2, j-1, num+1, grid)\\n    }\\n    if isOK(i-2, j+1, num+1, grid) {\\n        return check(i-2, j+1, num+1, grid)\\n    }\\n    if isOK(i-2, j-1, num+1, grid) {\\n        return check(i-2, j-1, num+1, grid)\\n    }\\n    if isOK(i+1, j+2, num+1, grid) {\\n        return check(i+1, j+2, num+1, grid)\\n    }\\n    if isOK(i+1, j-2, num+1, grid) {\\n        return check(i+1, j-2, num+1, grid)\\n    }\\n    if isOK(i-1, j+2, num+1, grid) {\\n        return check(i-1, j+2, num+1, grid)\\n    }\\n    if isOK(i-1, j-2, num+1, grid) {\\n        return check(i-1, j-2, num+1, grid)\\n    }\\n    return false\\n}\\n\\nfunc isOK(i, j, num int, grid [][]int) bool {\\n    if i < 0 || j < 0 || i >= len(grid) || j >= len(grid) {\\n        return false\\n    }\\n    return num == grid[i][j]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc checkValidGrid(grid [][]int) bool {\\n    if grid[0][0] != 0 {\\n        return false\\n    }\\n    return check(0, 0, 0, grid)\\n}\\n\\nfunc check(i, j, num int, grid [][]int) bool {\\n    if num == len(grid)*len(grid)-1 {\\n        return true\\n    }\\n    if isOK(i+2, j+1, num+1, grid) {\\n        return check(i+2, j+1, num+1, grid)\\n    }\\n    if isOK(i+2, j-1, num+1, grid) {\\n        return check(i+2, j-1, num+1, grid)\\n    }\\n    if isOK(i-2, j+1, num+1, grid) {\\n        return check(i-2, j+1, num+1, grid)\\n    }\\n    if isOK(i-2, j-1, num+1, grid) {\\n        return check(i-2, j-1, num+1, grid)\\n    }\\n    if isOK(i+1, j+2, num+1, grid) {\\n        return check(i+1, j+2, num+1, grid)\\n    }\\n    if isOK(i+1, j-2, num+1, grid) {\\n        return check(i+1, j-2, num+1, grid)\\n    }\\n    if isOK(i-1, j+2, num+1, grid) {\\n        return check(i-1, j+2, num+1, grid)\\n    }\\n    if isOK(i-1, j-2, num+1, grid) {\\n        return check(i-1, j-2, num+1, grid)\\n    }\\n    return false\\n}\\n\\nfunc isOK(i, j, num int, grid [][]int) bool {\\n    if i < 0 || j < 0 || i >= len(grid) || j >= len(grid) {\\n        return false\\n    }\\n    return num == grid[i][j]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810527,
                "title": "python-solution-using-dictionaries-very-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the occurences of elements in the board and note their coordinates. Sort and iterate element by element and check if there is an absolute difference of (1,2) or (2,1) (essentially mathematical equivalent of knight moves)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInsert the location (i,j) of each element on the grid into a dictionary. Dictionary has the format of {element (int) : location (tuple)}. Create an ordered dictionary using the dictionary created in the previous step. Iterate through the dictionary and check if the next element and the current element have a Manhattan Distance of (1,2) or (2,1). If they don\\'t, then we return False.\\n\\n\\n\\n# Code\\n```\\nimport collections\\ndef dictinsert(grid: List[List[int]]):\\n        d = {}\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                d[grid[i][j]] = (i,j)\\n        return d\\ndef distance(x1,y1,x2,y2):\\n    lx = abs(x1-x2)\\n    ly = abs(y1-y2)    \\n    return (lx,ly)        \\nclass Solution:  \\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        lst = [(2,1),(1,2)]\\n        if(grid[0][0]!=0):\\n            return False\\n        d = dictinsert(grid)\\n        od = collections.OrderedDict(sorted(d.items()))\\n        for i in range(len(od)-1):\\n            if(distance(od[i][0],od[i][1],od[i+1][0],od[i+1][1]) not in lst):\\n                return False\\n        return True            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport collections\\ndef dictinsert(grid: List[List[int]]):\\n        d = {}\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                d[grid[i][j]] = (i,j)\\n        return d\\ndef distance(x1,y1,x2,y2):\\n    lx = abs(x1-x2)\\n    ly = abs(y1-y2)    \\n    return (lx,ly)        \\nclass Solution:  \\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        lst = [(2,1),(1,2)]\\n        if(grid[0][0]!=0):\\n            return False\\n        d = dictinsert(grid)\\n        od = collections.OrderedDict(sorted(d.items()))\\n        for i in range(len(od)-1):\\n            if(distance(od[i][0],od[i][1],od[i+1][0],od[i+1][1]) not in lst):\\n                return False\\n        return True            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802430,
                "title": "c-recursion-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool f(int row, int col, vector<vector<int>> &grid, int num){\\n    int n = grid.size(), m = grid[0].size();\\n    if(row<0 || row>=n || col<0 || col>=m) return false;\\n    if(grid[row][col]!=num) return false;\\n    if(num==((n*n)-1)) return true;\\n    return f(row-2, col-1, grid, num+1) || f(row-2, col+1, grid, num+1) || f(row-1, col-2, grid, num+1) || f(row+1, col-2, grid, num+1) || f(row+2, col-1, grid, num+1) || f(row+2, col+1, grid, num+1) || f(row+1, col+2, grid, num+1) || f(row-1, col+2, grid, num+1);\\n\\n\\n}\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        return f(0, 0, grid, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool f(int row, int col, vector<vector<int>> &grid, int num){\\n    int n = grid.size(), m = grid[0].size();\\n    if(row<0 || row>=n || col<0 || col>=m) return false;\\n    if(grid[row][col]!=num) return false;\\n    if(num==((n*n)-1)) return true;\\n    return f(row-2, col-1, grid, num+1) || f(row-2, col+1, grid, num+1) || f(row-1, col-2, grid, num+1) || f(row+1, col-2, grid, num+1) || f(row+2, col-1, grid, num+1) || f(row+2, col+1, grid, num+1) || f(row+1, col+2, grid, num+1) || f(row-1, col+2, grid, num+1);\\n\\n\\n}\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        return f(0, 0, grid, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799820,
                "title": "100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] board) {\\n        if(board[0][0]!=0) return false;\\n        return valid(board,0,0,0);\\n    }\\n    public static boolean valid(int[][] board,int row,int col,int num){\\n        int n = board.length;\\n        if(board[row][col]==n*n-1){\\n            return true;\\n        }\\n        // Up-Up-Right : \\n        if(isSafe(board,row-2,col+1)){\\n            if(board[row-2][col+1]==num+1){\\n                return valid(board,row-2,col+1,num+1);\\n            }\\n        }\\n\\n        // Up-Up-Left : \\n        if(isSafe(board,row-2,col-1)){\\n            if(board[row-2][col-1]==num+1){\\n                return valid(board,row-2,col-1,num+1);\\n            }\\n        }\\n\\n        // Down-Down-Right : \\n        if(isSafe(board,row+2,col+1)){\\n            if(board[row+2][col+1]==num+1){\\n                return valid(board,row+2,col+1,num+1);\\n            }\\n        }\\n\\n        // Down-Down-Leftt : \\n        if(isSafe(board,row+2,col-1)){\\n            if(board[row+2][col-1]==num+1){\\n                return valid(board,row+2,col-1,num+1);\\n            }\\n        }\\n\\n        // left-left-Up:\\n        if(isSafe(board,row-1,col-2)){\\n            if(board[row-1][col-2]==num+1){\\n                return valid(board,row-1,col-2,num+1);\\n            }\\n        }\\n\\n        // left-left-Down:\\n        if(isSafe(board,row+1,col-2)){\\n            if(board[row+1][col-2]==num+1){\\n                return valid(board,row+1,col-2,num+1);\\n            }\\n        }\\n\\n        // Right-Right-Up:\\n        if(isSafe(board,row-1,col+2)){\\n            if(board[row-1][col+2]==num+1){\\n                return valid(board,row-1,col+2,num+1);\\n            }\\n        }\\n\\n        // Right-Right-Down:\\n        if(isSafe(board,row+1,col+2)){\\n            if(board[row+1][col+2]==num+1){\\n                return valid(board,row+1,col+2,num+1);\\n            }\\n        }\\n        return false;\\n        \\n    }\\n    public static boolean isSafe(int[][] board,int row,int col){\\n        if(row<board.length && row>=0 && col<board[0].length && col>=0 ) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] board) {\\n        if(board[0][0]!=0) return false;\\n        return valid(board,0,0,0);\\n    }\\n    public static boolean valid(int[][] board,int row,int col,int num){\\n        int n = board.length;\\n        if(board[row][col]==n*n-1){\\n            return true;\\n        }\\n        // Up-Up-Right : \\n        if(isSafe(board,row-2,col+1)){\\n            if(board[row-2][col+1]==num+1){\\n                return valid(board,row-2,col+1,num+1);\\n            }\\n        }\\n\\n        // Up-Up-Left : \\n        if(isSafe(board,row-2,col-1)){\\n            if(board[row-2][col-1]==num+1){\\n                return valid(board,row-2,col-1,num+1);\\n            }\\n        }\\n\\n        // Down-Down-Right : \\n        if(isSafe(board,row+2,col+1)){\\n            if(board[row+2][col+1]==num+1){\\n                return valid(board,row+2,col+1,num+1);\\n            }\\n        }\\n\\n        // Down-Down-Leftt : \\n        if(isSafe(board,row+2,col-1)){\\n            if(board[row+2][col-1]==num+1){\\n                return valid(board,row+2,col-1,num+1);\\n            }\\n        }\\n\\n        // left-left-Up:\\n        if(isSafe(board,row-1,col-2)){\\n            if(board[row-1][col-2]==num+1){\\n                return valid(board,row-1,col-2,num+1);\\n            }\\n        }\\n\\n        // left-left-Down:\\n        if(isSafe(board,row+1,col-2)){\\n            if(board[row+1][col-2]==num+1){\\n                return valid(board,row+1,col-2,num+1);\\n            }\\n        }\\n\\n        // Right-Right-Up:\\n        if(isSafe(board,row-1,col+2)){\\n            if(board[row-1][col+2]==num+1){\\n                return valid(board,row-1,col+2,num+1);\\n            }\\n        }\\n\\n        // Right-Right-Down:\\n        if(isSafe(board,row+1,col+2)){\\n            if(board[row+1][col+2]==num+1){\\n                return valid(board,row+1,col+2,num+1);\\n            }\\n        }\\n        return false;\\n        \\n    }\\n    public static boolean isSafe(int[][] board,int row,int col){\\n        if(row<board.length && row>=0 && col<board[0].length && col>=0 ) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799337,
                "title": "knight-tour",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        if grid[0][0]!=0:\\n            return False\\n        for i in range(len(grid)*len(grid)-1):\\n            for j in range(len(grid)):\\n                if i in grid[j]:\\n                    numi0=j\\n                    numj0=grid[j].index(i)\\n                if i+1 in grid[j]:\\n                    numi1=j\\n                    numj1=grid[j].index(i+1)\\n            if numi0+1==numi1 and numj0+2==numj1:\\n                continue\\n            elif numi0+2==numi1 and numj0+1==numj1:\\n                continue\\n            elif numi0+1==numi1 and numj0-2==numj1:\\n                continue\\n            elif numi0+2==numi1 and numj0-1==numj1:\\n                continue\\n            elif numi0-1==numi1 and numj0+2==numj1:\\n                continue\\n            elif numi0-1==numi1 and numj0-2==numj1:\\n                continue             \\n            elif numi0-2==numi1 and numj0+1==numj1:\\n                continue\\n            elif numi0-2==numi1 and numj0-1==numj1:\\n                continue\\n            else:\\n                return False            \\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        if grid[0][0]!=0:\\n            return False\\n        for i in range(len(grid)*len(grid)-1):\\n            for j in range(len(grid)):\\n                if i in grid[j]:\\n                    numi0=j\\n                    numj0=grid[j].index(i)\\n                if i+1 in grid[j]:\\n                    numi1=j\\n                    numj1=grid[j].index(i+1)\\n            if numi0+1==numi1 and numj0+2==numj1:\\n                continue\\n            elif numi0+2==numi1 and numj0+1==numj1:\\n                continue\\n            elif numi0+1==numi1 and numj0-2==numj1:\\n                continue\\n            elif numi0+2==numi1 and numj0-1==numj1:\\n                continue\\n            elif numi0-1==numi1 and numj0+2==numj1:\\n                continue\\n            elif numi0-1==numi1 and numj0-2==numj1:\\n                continue             \\n            elif numi0-2==numi1 and numj0+1==numj1:\\n                continue\\n            elif numi0-2==numi1 and numj0-1==numj1:\\n                continue\\n            else:\\n                return False            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797046,
                "title": "dfs-solution-recursion-java",
                "content": "<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n      int n = grid.length;\\n      return solve(grid,0,0,n,-1);  \\n    }\\n    public boolean solve(int[][] grid, int r, int c, int n, int prev)\\n    {\\n        if(r<0 || r>= n || c<0 || c>= n || grid[r][c] != prev+1)\\n        return false;\\n\\n        if(grid[r][c] == (n*n)-1)\\n        return true;\\n\\n        return solve(grid,r+2,c-1,n,grid[r][c]) ||\\n                solve(grid,r+2,c+1,n,grid[r][c]) ||\\n                solve(grid,r-2,c-1,n,grid[r][c]) || \\n                solve(grid,r-2,c+1,n,grid[r][c]) ||\\n                solve(grid,r+1,c+2,n,grid[r][c]) ||\\n                solve(grid,r+1,c-2,n,grid[r][c]) ||\\n                solve(grid,r-1,c-2,n,grid[r][c]) ||\\n                solve(grid,r-1,c+2,n,grid[r][c]);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n      int n = grid.length;\\n      return solve(grid,0,0,n,-1);  \\n    }\\n    public boolean solve(int[][] grid, int r, int c, int n, int prev)\\n    {\\n        if(r<0 || r>= n || c<0 || c>= n || grid[r][c] != prev+1)\\n        return false;\\n\\n        if(grid[r][c] == (n*n)-1)\\n        return true;\\n\\n        return solve(grid,r+2,c-1,n,grid[r][c]) ||\\n                solve(grid,r+2,c+1,n,grid[r][c]) ||\\n                solve(grid,r-2,c-1,n,grid[r][c]) || \\n                solve(grid,r-2,c+1,n,grid[r][c]) ||\\n                solve(grid,r+1,c+2,n,grid[r][c]) ||\\n                solve(grid,r+1,c-2,n,grid[r][c]) ||\\n                solve(grid,r-1,c-2,n,grid[r][c]) ||\\n                solve(grid,r-1,c+2,n,grid[r][c]);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783702,
                "title": "straight-forward-and-eezyyy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0]!=0)return false;\\n        int n = grid.length;\\n        return func(0,0,grid,(n*n)-1,n);\\n    }\\n    public boolean func(int row,int col,int[][] board,int num,int n){\\n        if(board[row][col]==num)return true;\\n        int x,y;\\n\\n        // upper right\\n        x=row;y=col;\\n        x-=2;y++;\\n        if(x>=0&&y<n)if(board[x][y]==board[row][col]+1)return func(x,y,board,num,n);\\n        \\n        // upper left\\n        x=row;y=col;\\n        x-=2;y--;\\n        if(x>=0&&y>=0)if(board[x][y]==board[row][col]+1)return func(x,y,board,num,n);\\n        \\n        // lower right\\n        x=row;y=col;\\n        x+=2;y++;\\n        if(x<n&&y<n)if(board[x][y]==board[row][col]+1)return func(x,y,board,num,n);\\n        \\n        // lower left\\n        x=row;y=col;\\n        x+=2;y--;\\n        if(x<n&&y>=0)if(board[x][y]==board[row][col]+1)return func(x,y,board,num,n);\\n        \\n        // left upper\\n        x=row;y=col;\\n        x--;y-=2;\\n        if(x>=0&&y>=0)if(board[x][y]==board[row][col]+1)return func(x,y,board,num,n);\\n        \\n        // left lower\\n        x=row;y=col;\\n        x++;y-=2;\\n        if(x<n&&y>=0)if(board[x][y]==board[row][col]+1)return func(x,y,board,num,n);\\n       \\n        // right upper\\n        x=row;y=col;\\n        x--;y+=2;\\n        if(x>=0&&y<n)if(board[x][y]==board[row][col]+1)return func(x,y,board,num,n);\\n        \\n        // right lower \\n        x=row;y=col;\\n        x++;y+=2;\\n        if(x<n&&y<n)if(board[x][y]==board[row][col]+1)return func(x,y,board,num,n);\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0]!=0)return false;\\n        int n = grid.length;\\n        return func(0,0,grid,(n*n)-1,n);\\n    }\\n    public boolean func(int row,int col,int[][] board,int num,int n){\\n        if(board[row][col]==num)return true;\\n        int x,y;\\n\\n        // upper right\\n        x=row;y=col;\\n        x-=2;y++;\\n        if(x>=0&&y<n)if(board[x][y]==board[row][col]+1)return func(x,y,board,num,n);\\n        \\n        // upper left\\n        x=row;y=col;\\n        x-=2;y--;\\n        if(x>=0&&y>=0)if(board[x][y]==board[row][col]+1)return func(x,y,board,num,n);\\n        \\n        // lower right\\n        x=row;y=col;\\n        x+=2;y++;\\n        if(x<n&&y<n)if(board[x][y]==board[row][col]+1)return func(x,y,board,num,n);\\n        \\n        // lower left\\n        x=row;y=col;\\n        x+=2;y--;\\n        if(x<n&&y>=0)if(board[x][y]==board[row][col]+1)return func(x,y,board,num,n);\\n        \\n        // left upper\\n        x=row;y=col;\\n        x--;y-=2;\\n        if(x>=0&&y>=0)if(board[x][y]==board[row][col]+1)return func(x,y,board,num,n);\\n        \\n        // left lower\\n        x=row;y=col;\\n        x++;y-=2;\\n        if(x<n&&y>=0)if(board[x][y]==board[row][col]+1)return func(x,y,board,num,n);\\n       \\n        // right upper\\n        x=row;y=col;\\n        x--;y+=2;\\n        if(x>=0&&y<n)if(board[x][y]==board[row][col]+1)return func(x,y,board,num,n);\\n        \\n        // right lower \\n        x=row;y=col;\\n        x++;y+=2;\\n        if(x<n&&y<n)if(board[x][y]==board[row][col]+1)return func(x,y,board,num,n);\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778425,
                "title": "edge-cases-sucks",
                "content": "Why the problem has to restrict the starting point to be `(0, 0)`",
                "solutionTags": [],
                "code": "Why the problem has to restrict the starting point to be `(0, 0)`",
                "codeTag": "Unknown"
            },
            {
                "id": 3778133,
                "title": "python-simple-traversal-beats-60-explained",
                "content": "# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        possibleMoves = [(1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1)]\\n        n = len(grid)\\n        if grid[0][0] != 0:\\n            return False\\n        x, y = 0, 0\\n        for i in range(n * n - 1):\\n            flag = False\\n            #check for all neighbouring cells\\n            for mx, my in possibleMoves:\\n                if 0 <= x + mx < n and 0 <= y + my < n and grid[x + mx][y + my] == i + 1:\\n                    flag = True\\n                    x += mx\\n                    y += my\\n                    break\\n            #if no cell is satisfied\\n            if not flag:\\n                return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        possibleMoves = [(1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1)]\\n        n = len(grid)\\n        if grid[0][0] != 0:\\n            return False\\n        x, y = 0, 0\\n        for i in range(n * n - 1):\\n            flag = False\\n            #check for all neighbouring cells\\n            for mx, my in possibleMoves:\\n                if 0 <= x + mx < n and 0 <= y + my < n and grid[x + mx][y + my] == i + 1:\\n                    flag = True\\n                    x += mx\\n                    y += my\\n                    break\\n            #if no cell is satisfied\\n            if not flag:\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760665,
                "title": "detailed-map-solution-o-n-81-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks to check whether the given config is true for the knight on the chess board. After reading this problem the first thing that comes to mind is to move with positions given in the question and check if they are valid or not if valid then keep moving till you reach the last limit thats n^2-1 as its 0 based numbering.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow that we know what we want to do, how do we code this up? I have used a map here that stores the move number and its coordinate. Now this can be achived with any other data structure but with map we get sorted order of move number. Now we take the row and column of the  move number using map and check it with all the 8 positions the knight can move to if the next move number is present in these 8 positions then continue else return false. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)// excluding the time to enter grid in map\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n) //for the use of map\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> x = {-2,-1,1,2,2,1,-1,-2};\\nvector<int> y = {-1,-2,-2,-1,1,2,2,1};\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n        map<int,pair<int,int>> mp;\\n        if(grid[0][0] != 0)\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                mp.insert({grid[i][j],{i,j}});\\n            }\\n        } \\n        bool check = true;\\n        int goal = grid.size()*grid.size();\\n        goal--;\\n        for(auto e:mp)\\n        {\\n            int r = e.second.first;\\n            int c = e.second.second;\\n            bool checker = false;\\n            for(int i=0;i<8;i++)\\n            {\\n                        if(r+x[i]<0 || c+y[i]<0|| r+x[i]>=grid.size() || c+y[i]>= grid.size())\\n                {\\n                        continue;\\n                }\\n                else if(grid[r+x[i]][c+y[i]] == e.first+1)\\n                {\\n                    if(e.first+1 == goal)\\n                    {\\n                        return true;\\n                    }\\n                    checker = true;\\n                }\\n            }\\n            if(!checker)\\n            {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> x = {-2,-1,1,2,2,1,-1,-2};\\nvector<int> y = {-1,-2,-2,-1,1,2,2,1};\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n        map<int,pair<int,int>> mp;\\n        if(grid[0][0] != 0)\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                mp.insert({grid[i][j],{i,j}});\\n            }\\n        } \\n        bool check = true;\\n        int goal = grid.size()*grid.size();\\n        goal--;\\n        for(auto e:mp)\\n        {\\n            int r = e.second.first;\\n            int c = e.second.second;\\n            bool checker = false;\\n            for(int i=0;i<8;i++)\\n            {\\n                        if(r+x[i]<0 || c+y[i]<0|| r+x[i]>=grid.size() || c+y[i]>= grid.size())\\n                {\\n                        continue;\\n                }\\n                else if(grid[r+x[i]][c+y[i]] == e.first+1)\\n                {\\n                    if(e.first+1 == goal)\\n                    {\\n                        return true;\\n                    }\\n                    checker = true;\\n                }\\n            }\\n            if(!checker)\\n            {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3760378,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        directions = {\\n            (-1,2),\\n            (-1,-2),\\n            (1,2),\\n            (1,-2),\\n            (-2,1),\\n            (-2,-1),\\n            (2,1),\\n            (2,-1),\\n        }\\n        if grid[0][0]: return False\\n        current, gridLen = 0, len(grid)\\n        start, end = 0, 0\\n        while current < gridLen * gridLen - 1:\\n            found = None\\n            for each in directions:\\n                ns, ne = start + each[0], end + each[1]\\n                if ns < 0 or ne < 0 or ne >= gridLen or ns >= gridLen:\\n                    continue\\n                elif grid[ns][ne] == current + 1:\\n                    start, end = ns, ne\\n                    found = True\\n                    break\\n            if not found:\\n                return False\\n            current += 1\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        directions = {\\n            (-1,2),\\n            (-1,-2),\\n            (1,2),\\n            (1,-2),\\n            (-2,1),\\n            (-2,-1),\\n            (2,1),\\n            (2,-1),\\n        }\\n        if grid[0][0]: return False\\n        current, gridLen = 0, len(grid)\\n        start, end = 0, 0\\n        while current < gridLen * gridLen - 1:\\n            found = None\\n            for each in directions:\\n                ns, ne = start + each[0], end + each[1]\\n                if ns < 0 or ne < 0 or ne >= gridLen or ns >= gridLen:\\n                    continue\\n                elif grid[ns][ne] == current + 1:\\n                    start, end = ns, ne\\n                    found = True\\n                    break\\n            if not found:\\n                return False\\n            current += 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759523,
                "title": "fast-and-easy-c-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int num_visited;\\n    vector<vector<int>> g;\\n    vector<pair<int, int>> offsets = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2},\\n                                      {2, 1}, {2, -1}, {1, 2}, {1, -2}};\\n\\n    bool in_range (int i, int j) {\\n        return i >= 0 and i < n and j >= 0 and j < n;\\n    }\\n\\n    void dfs (int i, int j) {\\n        for (auto [o_i, o_j] : offsets) {\\n            int i1 = i + o_i, j1 = j + o_j;\\n            if (in_range(i1, j1) and num_visited == g[i1][j1]) {\\n                ++num_visited, dfs(i1, j1);\\n                return;\\n            }\\n        }\\n    }\\n\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        n = grid.size(), num_visited = 1, g = grid;\\n        if (g[0][0] != 0) return false;\\n        dfs(0, 0);\\n        return num_visited == n * n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int num_visited;\\n    vector<vector<int>> g;\\n    vector<pair<int, int>> offsets = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2},\\n                                      {2, 1}, {2, -1}, {1, 2}, {1, -2}};\\n\\n    bool in_range (int i, int j) {\\n        return i >= 0 and i < n and j >= 0 and j < n;\\n    }\\n\\n    void dfs (int i, int j) {\\n        for (auto [o_i, o_j] : offsets) {\\n            int i1 = i + o_i, j1 = j + o_j;\\n            if (in_range(i1, j1) and num_visited == g[i1][j1]) {\\n                ++num_visited, dfs(i1, j1);\\n                return;\\n            }\\n        }\\n    }\\n\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        n = grid.size(), num_visited = 1, g = grid;\\n        if (g[0][0] != 0) return false;\\n        dfs(0, 0);\\n        return num_visited == n * n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753798,
                "title": "solution-with-explanation-dhund-rahe-ho-aa-jao-dikha-dunga",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs the knight can move to multiple places, the first thing which comes to mind is using BFS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAT EACH POINT, MAINTAIN THE COUNT VARIABLE WHICH INDICATES THE NUMBER OF MOVES.. CARRY OUT BFS AND IF THE VALUE IN CELL MATCHES THE COUNT, ADD IT TO THE QUEUE.. ULTIMATELY CHECK IF THE COUNT IS EQUAL TO THE NUMBER OF CELLS\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n\\n        // AT EACH POINT, MAINTAIN THE COUNT VARIABLE WHICH INDICATES THE NUMBER OF MOVES.. CARRY OUT BFS AND IF THE VALUE IN CELL MATCHES THE COUNT, ADD IT TO THE QUEUE.. ULTIMATELY CHECK IF THE COUNT IS EQUAL TO THE NUMBER OF CELLS\\n\\n        int n = grid.size();\\n\\n        // EDGE CASE\\n        if(grid[0][0]!=0){\\n            return false;\\n        }\\n\\n        // STARTING POINT\\n        pair<int,int> p ={0,0};\\n\\n        vector<int> x ={2,-2,1,-1};\\n\\n        queue<pair<int,int>> q;\\n        q.push(p);\\n\\n        int count=0;\\n\\n        // BFS\\n        while(!q.empty()){\\n\\n            pair<int,int> p =q.front();\\n            q.pop();\\n            count++;\\n\\n            // KNIGHT MOVING LOGIC\\n            for(auto i:x){\\n                for(auto j:x){\\n                    if(abs(i)!=abs(j)){\\n                        pair<int,int> p1 = {p.first+i, p.second+j};\\n                        int x1 = p1.first, y1= p1.second;\\n\\n                if(x1<n and y1<n and x1>=0 and y1>=0 and grid[x1][y1]==count){\\n                    q.push({x1,y1});\\n                }\\n                    }\\n                }\\n            }\\n\\n        }\\n\\n        return count== (n*n);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n\\n        // AT EACH POINT, MAINTAIN THE COUNT VARIABLE WHICH INDICATES THE NUMBER OF MOVES.. CARRY OUT BFS AND IF THE VALUE IN CELL MATCHES THE COUNT, ADD IT TO THE QUEUE.. ULTIMATELY CHECK IF THE COUNT IS EQUAL TO THE NUMBER OF CELLS\\n\\n        int n = grid.size();\\n\\n        // EDGE CASE\\n        if(grid[0][0]!=0){\\n            return false;\\n        }\\n\\n        // STARTING POINT\\n        pair<int,int> p ={0,0};\\n\\n        vector<int> x ={2,-2,1,-1};\\n\\n        queue<pair<int,int>> q;\\n        q.push(p);\\n\\n        int count=0;\\n\\n        // BFS\\n        while(!q.empty()){\\n\\n            pair<int,int> p =q.front();\\n            q.pop();\\n            count++;\\n\\n            // KNIGHT MOVING LOGIC\\n            for(auto i:x){\\n                for(auto j:x){\\n                    if(abs(i)!=abs(j)){\\n                        pair<int,int> p1 = {p.first+i, p.second+j};\\n                        int x1 = p1.first, y1= p1.second;\\n\\n                if(x1<n and y1<n and x1>=0 and y1>=0 and grid[x1][y1]==count){\\n                    q.push({x1,y1});\\n                }\\n                    }\\n                }\\n            }\\n\\n        }\\n\\n        return count== (n*n);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746865,
                "title": "simple-dfs-solution-c",
                "content": "```\\nclass Solution {\\n    int n,m;\\n    int dx[8] = {2,2,-2,-2,1,1,-1,-1};\\n    int dy[8] = {1,-1,1,-1,2,-2,2,-2};\\n    \\n    bool solve(vector<vector<int>> &grid, int i, int j, int curr)\\n    {\\n        if(i<0 || j<0 || i>n-1 || j>m-1) return false;\\n        if(grid[i][j] == n*m-1 && curr == n*m-1) return true;\\n        bool flag = false;\\n        if(grid[i][j] == curr)\\n        {\\n            for(int a=0; a<8; a++) flag |= solve(grid, i + dx[a], j + dy[a], curr+1);\\n        }\\n        return flag;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        return solve(grid,0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int n,m;\\n    int dx[8] = {2,2,-2,-2,1,1,-1,-1};\\n    int dy[8] = {1,-1,1,-1,2,-2,2,-2};\\n    \\n    bool solve(vector<vector<int>> &grid, int i, int j, int curr)\\n    {\\n        if(i<0 || j<0 || i>n-1 || j>m-1) return false;\\n        if(grid[i][j] == n*m-1 && curr == n*m-1) return true;\\n        bool flag = false;\\n        if(grid[i][j] == curr)\\n        {\\n            for(int a=0; a<8; a++) flag |= solve(grid, i + dx[a], j + dy[a], curr+1);\\n        }\\n        return flag;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        return solve(grid,0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716302,
                "title": "beats-100-of-java-solutions-ilterative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple ilterative solution which checks that all possible position must contain one value greater than current box value\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple ilterative solution which checks that all possible position must contain one value greater than current box value\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO((n^2)*8) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0]!=0){\\n            return false;\\n        }\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int rmove[]={2,2,-2,-2,1,1,-1,-1};\\n        int cmove[]={1,-1,1,-1,2,-2,2,-2};\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int val=grid[i][j];\\n                boolean isPoss=false;\\n                for(int d=0;d<8;d++){\\n                    int r=i+rmove[d];\\n                    int c=j+cmove[d];\\n                    if(r>=0&&c>=0&&r<n&&c<m&&grid[r][c]==val+1){\\n                        isPoss=true;\\n                    }\\n                }\\n                if(!isPoss){\\n                    cnt++;\\n                }\\n                if(cnt>1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0]!=0){\\n            return false;\\n        }\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int rmove[]={2,2,-2,-2,1,1,-1,-1};\\n        int cmove[]={1,-1,1,-1,2,-2,2,-2};\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int val=grid[i][j];\\n                boolean isPoss=false;\\n                for(int d=0;d<8;d++){\\n                    int r=i+rmove[d];\\n                    int c=j+cmove[d];\\n                    if(r>=0&&c>=0&&r<n&&c<m&&grid[r][c]==val+1){\\n                        isPoss=true;\\n                    }\\n                }\\n                if(!isPoss){\\n                    cnt++;\\n                }\\n                if(cnt>1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698839,
                "title": "simple-bfs",
                "content": "# Intuition\\nBreadth first search\\n\\n# Complexity\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        def move(v: int) -> bool:\\n            nonlocal x, y\\n            found = False\\n            for step in moves:\\n                nx = x + step[0]\\n                ny = y + step[1]\\n                if 0 <= nx and nx < n and 0 <= ny and ny < n and v == grid[nx][ny]:\\n                    x, y = nx, ny\\n                    found = True\\n                    break\\n            return found\\n        x, y = 0, 0\\n        if grid[x][y]:\\n            return 0\\n        moves = [(2, 1), (-2, 1), (2, -1), (-2, -1), (1, 2), (-1, 2), (1, -2), (-1, -2)]\\n        n, i = len(grid), 1\\n        while move(i):\\n            i += 1\\n        return i == n ** 2        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        def move(v: int) -> bool:\\n            nonlocal x, y\\n            found = False\\n            for step in moves:\\n                nx = x + step[0]\\n                ny = y + step[1]\\n                if 0 <= nx and nx < n and 0 <= ny and ny < n and v == grid[nx][ny]:\\n                    x, y = nx, ny\\n                    found = True\\n                    break\\n            return found\\n        x, y = 0, 0\\n        if grid[x][y]:\\n            return 0\\n        moves = [(2, 1), (-2, 1), (2, -1), (-2, -1), (1, 2), (-1, 2), (1, -2), (-1, -2)]\\n        n, i = len(grid), 1\\n        while move(i):\\n            i += 1\\n        return i == n ** 2        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693200,
                "title": "nknight-code-in-java",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean helper(int[][] grid,int row,int col,int num)\\n    {\\n        int n = grid.length;\\n        int i = row, j = col;\\n        if(grid[i][j] == n*n-1) return true;\\n\\n        //condition Statements\\n\\n        //2 up 1 right\\n        i = row -2;\\n        j = col +1;\\n        if(i >= 0 && j < n && grid[i][j] == num+1) return helper(grid,i,j,num+1);\\n\\n        //2 up 1 Left\\n        i = row -2;\\n        j = col -1;\\n        if(i >= 0 && j >= 0 && grid[i][j] == num+1) return helper(grid,i,j,num+1);\\n\\n        //2 Down 1 right\\n        i = row +2;\\n        j = col +1;\\n        if(i < n && j < n && grid[i][j] == num+1) return helper(grid,i,j,num+1);\\n\\n        //2 Down 1 right\\n        i = row +2;\\n        j = col -1;\\n        if(i < n && j >= 0 && grid[i][j] == num+1) return helper(grid,i,j,num+1);\\n\\n\\n        //2 Right 1 up\\n        i = row -1;\\n        j = col +2;\\n        if(i >= 0 && j < n && grid[i][j] == num+1) return helper(grid,i,j,num+1);\\n\\n\\n        //2 Right 1 down\\n        i = row +1;\\n        j = col +2;\\n        if(i < n && j < n && grid[i][j] == num+1) return helper(grid,i,j,num+1);\\n\\n\\n        //2 Left 1 up\\n        i = row -1;\\n        j = col -2;\\n        if(i >= 0 && j >= 0 && grid[i][j] == num+1) return helper(grid,i,j,num+1);\\n\\n\\n        //2 Left 1 down\\n        i = row +1;\\n        j = col -2;\\n        if(i < n && j >= 0 && grid[i][j] == num+1) return helper(grid,i,j,num+1);\\n        return false;\\n\\n\\n    }\\n\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean helper(int[][] grid,int row,int col,int num)\\n    {\\n        int n = grid.length;\\n        int i = row, j = col;\\n        if(grid[i][j] == n*n-1) return true;\\n\\n        //condition Statements\\n\\n        //2 up 1 right\\n        i = row -2;\\n        j = col +1;\\n        if(i >= 0 && j < n && grid[i][j] == num+1) return helper(grid,i,j,num+1);\\n\\n        //2 up 1 Left\\n        i = row -2;\\n        j = col -1;\\n        if(i >= 0 && j >= 0 && grid[i][j] == num+1) return helper(grid,i,j,num+1);\\n\\n        //2 Down 1 right\\n        i = row +2;\\n        j = col +1;\\n        if(i < n && j < n && grid[i][j] == num+1) return helper(grid,i,j,num+1);\\n\\n        //2 Down 1 right\\n        i = row +2;\\n        j = col -1;\\n        if(i < n && j >= 0 && grid[i][j] == num+1) return helper(grid,i,j,num+1);\\n\\n\\n        //2 Right 1 up\\n        i = row -1;\\n        j = col +2;\\n        if(i >= 0 && j < n && grid[i][j] == num+1) return helper(grid,i,j,num+1);\\n\\n\\n        //2 Right 1 down\\n        i = row +1;\\n        j = col +2;\\n        if(i < n && j < n && grid[i][j] == num+1) return helper(grid,i,j,num+1);\\n\\n\\n        //2 Left 1 up\\n        i = row -1;\\n        j = col -2;\\n        if(i >= 0 && j >= 0 && grid[i][j] == num+1) return helper(grid,i,j,num+1);\\n\\n\\n        //2 Left 1 down\\n        i = row +1;\\n        j = col -2;\\n        if(i < n && j >= 0 && grid[i][j] == num+1) return helper(grid,i,j,num+1);\\n        return false;\\n\\n\\n    }\\n\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689801,
                "title": "c-simple-solution-using-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        \\n        if(grid[0][0] != 0)\\n            return false;\\n\\n        int n = grid.size();\\n        map<int, vector<int>> mp;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n                mp[grid[i][j]] = {i, j};\\n        \\n        auto it = mp.begin();\\n        while(++it != mp.end())\\n        {\\n            auto it2 = it;\\n            it2--;\\n\\n            int dx = abs((it->second)[0] - (it2->second)[0]), dy = abs((it->second)[1] - (it2->second)[1]);\\n            if(!((dx == 1 && dy == 2) || (dx == 2 && dy == 1)))\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        \\n        if(grid[0][0] != 0)\\n            return false;\\n\\n        int n = grid.size();\\n        map<int, vector<int>> mp;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n                mp[grid[i][j]] = {i, j};\\n        \\n        auto it = mp.begin();\\n        while(++it != mp.end())\\n        {\\n            auto it2 = it;\\n            it2--;\\n\\n            int dx = abs((it->second)[0] - (it2->second)[0]), dy = abs((it->second)[1] - (it2->second)[1]);\\n            if(!((dx == 1 && dy == 2) || (dx == 2 && dy == 1)))\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680308,
                "title": "recursive-solution-grid-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn order to traverse the grid , we recursively move the Knight to one of the possible boxes and check if the value coincides with previous value - 1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate functions for all possible moves and recursively try out the best possible moves till all are exhausted\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n\\n    row_len = 0\\n    col_len = 0\\n    final_val = 0\\n\\n    def move_tl(self,grid,r,c,val):\\n        if(r-2 >= 0 and c-1 >= 0 and grid[r-2][c-1] == val):\\n            return (grid[r-2][c-1] == val,(r-2,c-1))\\n        elif(c-2 >=0 and r-1 >= 0 and grid[r-1][c-2] == val):\\n            return (grid[r-1][c-2] == val,(r-1,c-2))\\n        else:\\n            return (False,(r,c))\\n    \\n    def move_tr(self,grid,r,c,val):\\n        if(r-2 >= 0 and c+1 < self.col_len and grid[r-2][c+1] == val):\\n            return (grid[r-2][c+1] == val,(r-2,c+1))\\n        elif(c+2 < self.col_len and r-1 >= 0 and grid[r-1][c+2] == val):\\n            return (grid[r-1][c+2] == val,(r-1,c+2))\\n        else:\\n            return (False,(r,c))\\n\\n    def move_bl(self,grid,r,c,val):\\n        if(r+2 < self.row_len and c-1 >= 0 and grid[r+2][c-1] == val):\\n            return (grid[r+2][c-1] == val,(r+2,c-1))\\n        elif(c-2 >=0 and r+1 < self.row_len and grid[r+1][c-2] == val):\\n            return (grid[r+1][c-2] == val,(r+1,c-2))\\n        else:\\n            return (False,(r,c))\\n\\n    def move_br(self,grid,r,c,val):\\n        if(r+2 < self.row_len and c+1 < self.col_len and grid[r+2][c+1] == val):\\n            return (grid[r+2][c+1] == val,(r+2,c+1))\\n        elif(c+2 <self.col_len and r+1 < self.row_len and grid[r+1][c+2] == val):\\n            return (grid[r+1][c+2] == val,(r+1,c+2))\\n        else:\\n            return (False,(r,c))\\n\\n\\n\\n    def move_check(self,grid,r,c,start):\\n        tl = self.move_tl(grid,r,c,start)\\n        tr = self.move_tr(grid,r,c,start)\\n        bl = self.move_bl(grid,r,c,start)\\n        br = self.move_br(grid,r,c,start)\\n        exp = self.row_len * self.col_len\\n\\n        if(tl[0]):\\n            self.final_val = grid[tl[1][0]][tl[1][1]]\\n            self.move_check(grid,tl[1][0],tl[1][1],start+1)\\n        elif(tr[0]):\\n            self.final_val = grid[tr[1][0]][tr[1][1]]\\n            self.move_check(grid,tr[1][0],tr[1][1],start+1)\\n        elif(bl[0]):\\n            self.final_val = grid[bl[1][0]][bl[1][1]]\\n            self.move_check(grid,bl[1][0],bl[1][1],start+1)\\n        elif(br[0]):\\n            self.final_val = grid[br[1][0]][br[1][1]]\\n            self.move_check(grid,br[1][0],br[1][1],start+1)\\n        return self.final_val == (exp - 1)\\n\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        if(grid[0][0] != 0):\\n            return False\\n        self.row_len = len(grid)\\n        self.col_len = len(grid[0])\\n        self.final_val = 0\\n        out = self.move_check(grid,0,0,1)\\n        return out\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    row_len = 0\\n    col_len = 0\\n    final_val = 0\\n\\n    def move_tl(self,grid,r,c,val):\\n        if(r-2 >= 0 and c-1 >= 0 and grid[r-2][c-1] == val):\\n            return (grid[r-2][c-1] == val,(r-2,c-1))\\n        elif(c-2 >=0 and r-1 >= 0 and grid[r-1][c-2] == val):\\n            return (grid[r-1][c-2] == val,(r-1,c-2))\\n        else:\\n            return (False,(r,c))\\n    \\n    def move_tr(self,grid,r,c,val):\\n        if(r-2 >= 0 and c+1 < self.col_len and grid[r-2][c+1] == val):\\n            return (grid[r-2][c+1] == val,(r-2,c+1))\\n        elif(c+2 < self.col_len and r-1 >= 0 and grid[r-1][c+2] == val):\\n            return (grid[r-1][c+2] == val,(r-1,c+2))\\n        else:\\n            return (False,(r,c))\\n\\n    def move_bl(self,grid,r,c,val):\\n        if(r+2 < self.row_len and c-1 >= 0 and grid[r+2][c-1] == val):\\n            return (grid[r+2][c-1] == val,(r+2,c-1))\\n        elif(c-2 >=0 and r+1 < self.row_len and grid[r+1][c-2] == val):\\n            return (grid[r+1][c-2] == val,(r+1,c-2))\\n        else:\\n            return (False,(r,c))\\n\\n    def move_br(self,grid,r,c,val):\\n        if(r+2 < self.row_len and c+1 < self.col_len and grid[r+2][c+1] == val):\\n            return (grid[r+2][c+1] == val,(r+2,c+1))\\n        elif(c+2 <self.col_len and r+1 < self.row_len and grid[r+1][c+2] == val):\\n            return (grid[r+1][c+2] == val,(r+1,c+2))\\n        else:\\n            return (False,(r,c))\\n\\n\\n\\n    def move_check(self,grid,r,c,start):\\n        tl = self.move_tl(grid,r,c,start)\\n        tr = self.move_tr(grid,r,c,start)\\n        bl = self.move_bl(grid,r,c,start)\\n        br = self.move_br(grid,r,c,start)\\n        exp = self.row_len * self.col_len\\n\\n        if(tl[0]):\\n            self.final_val = grid[tl[1][0]][tl[1][1]]\\n            self.move_check(grid,tl[1][0],tl[1][1],start+1)\\n        elif(tr[0]):\\n            self.final_val = grid[tr[1][0]][tr[1][1]]\\n            self.move_check(grid,tr[1][0],tr[1][1],start+1)\\n        elif(bl[0]):\\n            self.final_val = grid[bl[1][0]][bl[1][1]]\\n            self.move_check(grid,bl[1][0],bl[1][1],start+1)\\n        elif(br[0]):\\n            self.final_val = grid[br[1][0]][br[1][1]]\\n            self.move_check(grid,br[1][0],br[1][1],start+1)\\n        return self.final_val == (exp - 1)\\n\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        if(grid[0][0] != 0):\\n            return False\\n        self.row_len = len(grid)\\n        self.col_len = len(grid[0])\\n        self.final_val = 0\\n        out = self.move_check(grid,0,0,1)\\n        return out\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676736,
                "title": "java-easy-solution-recursion-back-tracking",
                "content": "class Solution {\\n    public boolean helper(int[][] grid, int row, int col , int num){\\n        int n = grid.length;\\n        int i, j;\\n        \\n        if(grid[row][col] == n*n-1){\\n            return true;\\n        }\\n        \\n        // 2 UP 1 right\\n        i = row-2;\\n        j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num+1) return helper(grid, i, j, num+1);\\n        \\n        // 2 UP 1 left\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num+1) return helper(grid, i, j, num+1);\\n        \\n        // 2 Down 1 right\\n        \\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num+1) return helper(grid, i, j, num+1);\\n        \\n        // 2 Down 1 left\\n        \\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num+1) return helper(grid, i, j, num+1);\\n        \\n        //1 UP 2 left\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num+1) return helper(grid, i, j, num+1);\\n        \\n        // 1 Down 2 left\\n        \\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num+1) return helper(grid, i, j, num+1);\\n        \\n        // 1 UP 2 right\\n        \\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num+1) return helper(grid, i, j, num+1);\\n        \\n        // 1 Down 2 right\\n        \\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num+1) return helper(grid, i, j, num+1);\\n        \\n        \\n        return false;\\n        \\n        \\n    }\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0] != 0) return false;\\n        \\n        return helper(grid,0,0,0);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public boolean helper(int[][] grid, int row, int col , int num){\\n        int n = grid.length;\\n        int i, j;\\n        \\n        if(grid[row][col] == n*n-1){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3675952,
                "title": "explain-approach-and-add-comments-east-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : (BFS)\\n<!-- Describe your approach to solving the problem. -->\\n The idea is to visit each cell exactly once and ensure that the knight\\'s moves are valid.\\n\\nThe isValid function checks if a position (x, y) is within the grid boundaries, has not been visited before (vis[x][y] == 0), and matches the expected count (grid[x][y] == cnt). This ensures that the knight is moving correctly.\\n\\nThe main logic is implemented in the checkValidGrid function. It initializes the visitation array, creates a queue, and starts from the top-left cell (0, 0). It then performs a BFS traversal, considering the eight possible knight moves from each cell. If a move is valid, the count is incremented, and the position is added to the queue for further exploration. Finally, it checks if the count matches the total number of cells on the chessboard (cnt == n * n) to determine if it represents a valid knight\\'s tour.\\n\\nBy using BFS, the algorithm guarantees that all cells are visited, and the validity of each knight move is checked. If the count matches the total number of cells, it indicates a valid configuration.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def isValid(self, x, y, vis, grid, n, cnt):\\n        # Check if the position (x, y) is valid and matches the expected count\\n        if 0 <= x < n and 0 <= y < n and vis[x][y] == 0 and grid[x][y] == cnt:\\n            return True\\n        else:\\n            return False\\n\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        vis = [[0] * n for i in range(n)]  # Initialize the visitation array\\n        queue = deque()\\n        queue.append((0, 0))  # Start from the top-left cell\\n        vis[0][0] = 1  # Mark the starting cell as visited\\n        cnt = 1  # Initialize the count of visited cells\\n\\n        while queue:\\n            r, c = queue.popleft()  # Get the next position from the queue\\n            directions = [\\n                [r + 2, c - 1], [r + 2, c + 1],\\n                [r - 2, c - 1], [r - 2, c + 1],\\n                [r + 1, c + 2], [r - 1, c + 2],\\n                [r + 1, c - 2], [r - 1, c - 2]\\n            ]  # Possible knight moves from the current position\\n\\n            for x, y in directions:\\n                if self.isValid(x, y, vis, grid, n, cnt):\\n                    cnt += 1  # Increment the count of visited cells\\n                    queue.append((x, y))  # Add the valid position to the queue\\n                    vis[x][y] = 1  # Mark the position as visited\\n\\n        return cnt == n * n  # Return whether all cells have been visited\\n\\n\\n```\\nPlease upvote if you like my solution , it will keep motivate me",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def isValid(self, x, y, vis, grid, n, cnt):\\n        # Check if the position (x, y) is valid and matches the expected count\\n        if 0 <= x < n and 0 <= y < n and vis[x][y] == 0 and grid[x][y] == cnt:\\n            return True\\n        else:\\n            return False\\n\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        vis = [[0] * n for i in range(n)]  # Initialize the visitation array\\n        queue = deque()\\n        queue.append((0, 0))  # Start from the top-left cell\\n        vis[0][0] = 1  # Mark the starting cell as visited\\n        cnt = 1  # Initialize the count of visited cells\\n\\n        while queue:\\n            r, c = queue.popleft()  # Get the next position from the queue\\n            directions = [\\n                [r + 2, c - 1], [r + 2, c + 1],\\n                [r - 2, c - 1], [r - 2, c + 1],\\n                [r + 1, c + 2], [r - 1, c + 2],\\n                [r + 1, c - 2], [r - 1, c - 2]\\n            ]  # Possible knight moves from the current position\\n\\n            for x, y in directions:\\n                if self.isValid(x, y, vis, grid, n, cnt):\\n                    cnt += 1  # Increment the count of visited cells\\n                    queue.append((x, y))  # Add the valid position to the queue\\n                    vis[x][y] = 1  # Mark the position as visited\\n\\n        return cnt == n * n  # Return whether all cells have been visited\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675855,
                "title": "beginner-friendly-beats-100-no-recursion",
                "content": "> # Points to be  Noted Intially\\n- The knight starts at the ***top-left cell*** of the board and visits every cell on the board ***exactly once***.\\n- grid consisting of **distinct** integers from the range  [0, ***n * n - 1***]\\n- And read the Note given.\\n# Approach\\n- Let us take a var position where range is [0, ***n * n - 1***]\\n- We have to track the grid cell value of knight jumping possiblities from a particular position and check whether its the next of current cell value (`i.e currcell.val == prevcell.val +1`) , if any othe jumping possiblities is satisfied we are jumping to that specific cell.and so on ... until we reach our *final cell value* which is **n*n -1**. \\n- *If we reach a cell with value k means we surpassed cells having values 0,1,2,3.....k-1 and they all are on specific possible jumps from the prev their prev cell*\\n- we have to psas cell like this :\\n      0 -> 1 -> 2 -> 3 -> 4......-> n x n- 2 -> n x n -1\\n- Note that the condition `if(grid[0][0] != 0) return false;` is because as we know we can visit a cell **only once** while checking validation ...if we have another number(other than zero) at topmost left cell(which is `grid[0][0]`) where our knight has to start, we must come through that number again while going to cell with value n*n-1;\\n- All the ifs and else ifs are the jumping possiblities for an particular i,j including checking conditions for edge cases.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        int position = 0; int n =grid.length;\\n        if(grid[0][0] != 0) return false;\\n        int i=0 ;int j=0;\\n        while(i<n)\\n        {\\n            while(j<n)\\n            {   \\n                if(position == (n*n)-1) return true;\\n\\n                if(j+1 < n && i+2<n && grid[i+2][j+1] == position + 1) {\\n                i = i+2;j = j+1;position++;}\\n\\n                else if(j-1 >=0 && i+2<n && grid[i+2][j-1] == position + 1){\\n                i = i+2;j = j-1;position++;}\\n\\n                else if(j-1 >=0 && i-2>=0 && grid[i-2][j-1] == position + 1) {\\n                i = i-2;j = j-1;position++;}\\n\\n                else if(j+1 < n && i-2>=0 && grid[i-2][j+1] == position + 1) {\\n                i = i-2;j = j+1;position++;}\\n         \\n                else if(j+2 < n && i+1<n&& grid[i+1][j+2] == position + 1) {\\n                i = i+1;j = j+2;position++;}\\n\\n                else if(j-2 >=0 && i+1<n && grid[i+1][j-2] == position + 1){\\n                i = i+1;j = j-2;position++;}\\n\\n                else if(j+2 <n && i-1>=0 && grid[i-1][j+2] == position + 1) {\\n                i = i-1;j = j+2;position++;}\\n\\n                else if(i-1 >=0 && j-2>=0 && grid[i-1][j-2] == position + 1) {\\n                i = i-1;j = j-2;position++;}\\n\\n                else return false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n**UPVOTE if You like my explanation**\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        int position = 0; int n =grid.length;\\n        if(grid[0][0] != 0) return false;\\n        int i=0 ;int j=0;\\n        while(i<n)\\n        {\\n            while(j<n)\\n            {   \\n                if(position == (n*n)-1) return true;\\n\\n                if(j+1 < n && i+2<n && grid[i+2][j+1] == position + 1) {\\n                i = i+2;j = j+1;position++;}\\n\\n                else if(j-1 >=0 && i+2<n && grid[i+2][j-1] == position + 1){\\n                i = i+2;j = j-1;position++;}\\n\\n                else if(j-1 >=0 && i-2>=0 && grid[i-2][j-1] == position + 1) {\\n                i = i-2;j = j-1;position++;}\\n\\n                else if(j+1 < n && i-2>=0 && grid[i-2][j+1] == position + 1) {\\n                i = i-2;j = j+1;position++;}\\n         \\n                else if(j+2 < n && i+1<n&& grid[i+1][j+2] == position + 1) {\\n                i = i+1;j = j+2;position++;}\\n\\n                else if(j-2 >=0 && i+1<n && grid[i+1][j-2] == position + 1){\\n                i = i+1;j = j-2;position++;}\\n\\n                else if(j+2 <n && i-1>=0 && grid[i-1][j+2] == position + 1) {\\n                i = i-1;j = j+2;position++;}\\n\\n                else if(i-1 >=0 && j-2>=0 && grid[i-1][j-2] == position + 1) {\\n                i = i-1;j = j-2;position++;}\\n\\n                else return false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669124,
                "title": "most-understandable-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int co1[8]={2,2,-2,-2,1,-1,1,-1};\\n    int co2[8]={1,-1,1,-1,2,2,-2,-2};\\n    \\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int m=0;\\n        int n=grid.size();\\n        int x=0;\\n        int y=0;\\n        int maxcount=(n*n)-1;\\n        if(grid[x][y]!=m){\\n            return false;\\n        }\\n       while(m<maxcount){\\n           m++;\\n                 for(int i=0;i<8;i++){\\n                          int x1=x+co1[i];\\n                          int y1=y+co2[i];\\n                      if(x1>=0 && x1<n && y1>=0 && y1<n && grid[x1][y1]==m){\\n                           x=x1;\\n                           y=y1;\\n                           break;\\n                       }\\n             if(i==7){\\n                 return false;\\n             }\\n           }\\n       }\\nreturn true;\\n }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int co1[8]={2,2,-2,-2,1,-1,1,-1};\\n    int co2[8]={1,-1,1,-1,2,2,-2,-2};\\n    \\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int m=0;\\n        int n=grid.size();\\n        int x=0;\\n        int y=0;\\n        int maxcount=(n*n)-1;\\n        if(grid[x][y]!=m){\\n            return false;\\n        }\\n       while(m<maxcount){\\n           m++;\\n                 for(int i=0;i<8;i++){\\n                          int x1=x+co1[i];\\n                          int y1=y+co2[i];\\n                      if(x1>=0 && x1<n && y1>=0 && y1<n && grid[x1][y1]==m){\\n                           x=x1;\\n                           y=y1;\\n                           break;\\n                       }\\n             if(i==7){\\n                 return false;\\n             }\\n           }\\n       }\\nreturn true;\\n }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660892,
                "title": "most-intuitive-c-solution-dfs-simple-traversal",
                "content": "# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int di[8] = {1, 1, -1, -1, 2, 2, -2, -2};\\n    int dj[8] = {2, -2, 2, -2, 1, -1, 1, -1};\\n    int cur = 1;\\n    bool gl = false;\\n\\n    bool ok(int i, int j, vector<vector<int>>& grid) {\\n        return i >= 0 && i < grid.size() &&\\n               j >= 0 && j < grid.size() &&\\n               grid[i][j] == cur;\\n    }\\n\\n    void dfs(int i, int j, vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        bool flg = false;\\n        for (int k = 0; k < 8; k++) {\\n            int r = i + di[k];\\n            int c = j + dj[k];\\n            if (ok(r, c, grid)) {\\n                cur++;\\n                dfs(r, c, grid);\\n                flg = true;\\n            }\\n        }\\n        if (!flg && cur != grid.size() * grid.size()) {\\n            gl = true;\\n            return;\\n        }\\n    }\\n\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        if (grid[0][0] != 0) return false;\\n        int n = grid.size();\\n        int total = n * n - 1;\\n        dfs(0, 0, grid);\\n        if (gl) return false;\\n        return (cur == total + 1 ? true : false);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int di[8] = {1, 1, -1, -1, 2, 2, -2, -2};\\n    int dj[8] = {2, -2, 2, -2, 1, -1, 1, -1};\\n    int cur = 1;\\n    bool gl = false;\\n\\n    bool ok(int i, int j, vector<vector<int>>& grid) {\\n        return i >= 0 && i < grid.size() &&\\n               j >= 0 && j < grid.size() &&\\n               grid[i][j] == cur;\\n    }\\n\\n    void dfs(int i, int j, vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        bool flg = false;\\n        for (int k = 0; k < 8; k++) {\\n            int r = i + di[k];\\n            int c = j + dj[k];\\n            if (ok(r, c, grid)) {\\n                cur++;\\n                dfs(r, c, grid);\\n                flg = true;\\n            }\\n        }\\n        if (!flg && cur != grid.size() * grid.size()) {\\n            gl = true;\\n            return;\\n        }\\n    }\\n\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        if (grid[0][0] != 0) return false;\\n        int n = grid.size();\\n        int total = n * n - 1;\\n        dfs(0, 0, grid);\\n        if (gl) return false;\\n        return (cur == total + 1 ? true : false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656686,
                "title": "simple-dfs-c-dfs-easy-beats-98-runtime-2ms",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\nint row[8] = {-2, -1, 1, 2, -2, -1, 1, 2};\\nint col[8] = {-1, -2, -2, -1, 1, 2, 2, 1};\\n\\nvoid dfs(vector<vector<int>>& grid, int x, int y, int val, bool &flag){\\n    if(val == (grid.size()*grid[0].size() )-1 ){\\n        flag = 1;\\n        return;\\n    }\\n\\n    for(int i=0 ;i<8 ;i++){\\n        int newx = x+row[i];\\n        int newy = y+col[i];\\n\\n        if(newx>=0 && newx<grid.size() && newy>=0 && newy<grid[0].size() && grid[newx][newy]==val+1)\\n        dfs(grid, newx, newy, grid[newx][newy], flag);\\n    }\\n}\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        \\n        if(grid[0][0]!=0)\\n        return 0;\\n        bool flag = 0;\\n        dfs(grid, 0, 0, 0, flag);\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint row[8] = {-2, -1, 1, 2, -2, -1, 1, 2};\\nint col[8] = {-1, -2, -2, -1, 1, 2, 2, 1};\\n\\nvoid dfs(vector<vector<int>>& grid, int x, int y, int val, bool &flag){\\n    if(val == (grid.size()*grid[0].size() )-1 ){\\n        flag = 1;\\n        return;\\n    }\\n\\n    for(int i=0 ;i<8 ;i++){\\n        int newx = x+row[i];\\n        int newy = y+col[i];\\n\\n        if(newx>=0 && newx<grid.size() && newy>=0 && newy<grid[0].size() && grid[newx][newy]==val+1)\\n        dfs(grid, newx, newy, grid[newx][newy], flag);\\n    }\\n}\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        \\n        if(grid[0][0]!=0)\\n        return 0;\\n        bool flag = 0;\\n        dfs(grid, 0, 0, 0, flag);\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655781,
                "title": "check-knight-tour-configuration-easy-approach-simple-and-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    bool solve(vector<vector<int>>& grid, int i, int j, int& n, int t)\\n    {\\n        if(i < 0 || i >= n || j < 0 || j >= n)\\n        {\\n            return false;\\n        }\\n        if(grid[i][j] != t)\\n        {\\n             return false;\\n        }\\n        if(grid[i][j] == n*n-1 && t == n*n-1)\\n        {\\n            return true;\\n        }\\n        return solve(grid, i+2, j+1, n, t+1) || solve(grid, i+2, j-1, n, t+1) ||\\n                solve(grid, i-2, j+1, n, t+1) || solve(grid, i-2, j-1, n, t+1) ||\\n                solve(grid, i+1, j+2, n, t+1) || solve(grid, i+1, j-2, n, t+1) ||\\n                solve(grid, i-1, j+2, n, t+1) || solve(grid, i-1, j-2, n, t+1);\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        return solve(grid, 0, 0, n, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    bool solve(vector<vector<int>>& grid, int i, int j, int& n, int t)\\n    {\\n        if(i < 0 || i >= n || j < 0 || j >= n)\\n        {\\n            return false;\\n        }\\n        if(grid[i][j] != t)\\n        {\\n             return false;\\n        }\\n        if(grid[i][j] == n*n-1 && t == n*n-1)\\n        {\\n            return true;\\n        }\\n        return solve(grid, i+2, j+1, n, t+1) || solve(grid, i+2, j-1, n, t+1) ||\\n                solve(grid, i-2, j+1, n, t+1) || solve(grid, i-2, j-1, n, t+1) ||\\n                solve(grid, i+1, j+2, n, t+1) || solve(grid, i+1, j-2, n, t+1) ||\\n                solve(grid, i-1, j+2, n, t+1) || solve(grid, i-1, j-2, n, t+1);\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        return solve(grid, 0, 0, n, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641577,
                "title": "ruby-solution-using-indices-hash-with-explanation",
                "content": "# Intuition\\nCheck whether each move is valid.  Use a hash of indices for efficiency.\\n\\n# Approach\\n1. Return false if the starting square isn\\'t in the upper left.\\n2. Create a hash giving the coordinates of each number.\\n3. Check whether each move is valid.  This means the the difference in position between this move and the next move should be 1 along one dimension (vertically or horizontally), and 2 along the other.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\ndef check_valid_grid(grid)\\n    return false unless grid[0][0] == 0\\n\\n    n = grid.length\\n\\n    idxs = Hash.new\\n    (0...n).each do |i|\\n        (0...n).each do |j|\\n            idxs[grid[i][j]] = [i,j]\\n        end\\n    end\\n\\n    (0...n**2-1).all? do |move|\\n        i,j = idxs[move]\\n        k,l = idxs[move+1]\\n        [(i-k).abs, (j-l).abs].sort == [1,2]\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef check_valid_grid(grid)\\n    return false unless grid[0][0] == 0\\n\\n    n = grid.length\\n\\n    idxs = Hash.new\\n    (0...n).each do |i|\\n        (0...n).each do |j|\\n            idxs[grid[i][j]] = [i,j]\\n        end\\n    end\\n\\n    (0...n**2-1).all? do |move|\\n        i,j = idxs[move]\\n        k,l = idxs[move+1]\\n        [(i-k).abs, (j-l).abs].sort == [1,2]\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3604657,
                "title": "simple-dfs-easy-solution-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple dfs\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst we will start the depth first search from (0,0) and than again recursivly for valid row and column\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n+n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool dfs(int i,int j,vector<vector<int>>& grid,int n){\\n    if(grid[i][j]==n*n-1) return true;\\n\\n    int delr[]= {-2,-1,1,2,1,2,-1,-2};\\n    int delc[]= {1,2,2,1,-2,-1,-2,-1};\\n    for(int ind=0;ind<8;ind++){\\n        int nrow =i+delr[ind];\\n        int ncol =j+delc[ind];\\n        if(nrow<n and nrow>=0 and ncol<n and ncol>=0 and grid[nrow][ncol]== grid[i][j]+1){\\n           if(dfs(nrow,ncol,grid,n))\\n           return true;\\n           \\n        }\\n        \\n    }\\n    return false;\\n\\n}\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        if(grid[0][0]!=0) return false;\\n        int n=grid.size();\\n        return dfs(0,0,grid,n);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool dfs(int i,int j,vector<vector<int>>& grid,int n){\\n    if(grid[i][j]==n*n-1) return true;\\n\\n    int delr[]= {-2,-1,1,2,1,2,-1,-2};\\n    int delc[]= {1,2,2,1,-2,-1,-2,-1};\\n    for(int ind=0;ind<8;ind++){\\n        int nrow =i+delr[ind];\\n        int ncol =j+delc[ind];\\n        if(nrow<n and nrow>=0 and ncol<n and ncol>=0 and grid[nrow][ncol]== grid[i][j]+1){\\n           if(dfs(nrow,ncol,grid,n))\\n           return true;\\n           \\n        }\\n        \\n    }\\n    return false;\\n\\n}\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        if(grid[0][0]!=0) return false;\\n        int n=grid.size();\\n        return dfs(0,0,grid,n);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597666,
                "title": "c-simple-dfs",
                "content": "# Intuition\\n$(1.)$ From a cell, try each possible direction, if one is the next cell by the order of the grid, goto that cell\\n$(2.)$ Repeat $(1.)$ from the current cell, unless the current cell is the last cell which is when its value = n - 1 where n is the size of the grid\\n$(3.)$ Happiness\\n# Approach\\nDepth-First-Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> directions = {{2, 1}, {1, 2}, {2, -1}, {-1, 2}, {-2, 1}, {1, -2}, {-2, -1}, {-1, -2}};\\n    size_t n;\\n\\n    bool out(const vector<vector<int>>& grid, int i, int j) {\\n        return i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size(); \\n    }\\n\\n    bool checkValidGrid(vector<vector<int>>& grid, int i, int j, int next) {\\n        if (out(grid, i, j) || grid[i][j] != next) {\\n            return false;\\n        }\\n\\n        if (next == n - 1) {\\n            return true;\\n        }\\n\\n        for (auto& direction : directions) {\\n            if (checkValidGrid(grid, i + direction[0], j + direction[1], next + 1)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        n = grid.size() * grid[0].size();\\n        \\n        return checkValidGrid(grid, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> directions = {{2, 1}, {1, 2}, {2, -1}, {-1, 2}, {-2, 1}, {1, -2}, {-2, -1}, {-1, -2}};\\n    size_t n;\\n\\n    bool out(const vector<vector<int>>& grid, int i, int j) {\\n        return i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size(); \\n    }\\n\\n    bool checkValidGrid(vector<vector<int>>& grid, int i, int j, int next) {\\n        if (out(grid, i, j) || grid[i][j] != next) {\\n            return false;\\n        }\\n\\n        if (next == n - 1) {\\n            return true;\\n        }\\n\\n        for (auto& direction : directions) {\\n            if (checkValidGrid(grid, i + direction[0], j + direction[1], next + 1)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        n = grid.size() * grid[0].size();\\n        \\n        return checkValidGrid(grid, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597635,
                "title": "c-simple-and-clean",
                "content": "# Intuition\\nThe order of the moves is enumerated, then the validity of a move from the previous spot to the next is checked for validity for each move besides the first one.\\n# Approach\\nKeep a vector using the order of moves as indices, iterate over the vector checking if the next move is possible from the previous one.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool valid(const pair<int, int>& a, const pair<int, int>& b) {\\n        return  (abs(a.first - b.first) == 2 && abs(a.second - b.second) == 1) ||\\n                (abs(a.first - b.first) == 1 && abs(a.second - b.second) == 2);\\n    }\\n\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        if (grid[0][0] != 0) {\\n            return false;\\n        }\\n        \\n        int count = 0;\\n        size_t n = grid.size() * grid[0].size();\\n        vector<pair<int, int>> map(n, make_pair(0, 0));\\n\\n        for (auto i = 0; i < grid.size(); i++) {\\n            for (auto j = 0; j < grid[0].size(); j++) {\\n                map[grid[i][j]] = make_pair(i, j);\\n            }\\n        }\\n\\n        auto current = make_pair(0, 0);\\n\\n        return all_of(begin(map) + 1, end(map), [&](const pair<int, int>& next) {\\n            bool result = valid(current, next);\\n            current = next;\\n            return result;\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool valid(const pair<int, int>& a, const pair<int, int>& b) {\\n        return  (abs(a.first - b.first) == 2 && abs(a.second - b.second) == 1) ||\\n                (abs(a.first - b.first) == 1 && abs(a.second - b.second) == 2);\\n    }\\n\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        if (grid[0][0] != 0) {\\n            return false;\\n        }\\n        \\n        int count = 0;\\n        size_t n = grid.size() * grid[0].size();\\n        vector<pair<int, int>> map(n, make_pair(0, 0));\\n\\n        for (auto i = 0; i < grid.size(); i++) {\\n            for (auto j = 0; j < grid[0].size(); j++) {\\n                map[grid[i][j]] = make_pair(i, j);\\n            }\\n        }\\n\\n        auto current = make_pair(0, 0);\\n\\n        return all_of(begin(map) + 1, end(map), [&](const pair<int, int>& next) {\\n            bool result = valid(current, next);\\n            current = next;\\n            return result;\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590265,
                "title": "simple-c-recursive-solution",
                "content": "# Intuition\\nExploring all possible cells from a given cell in 8 directions is the key to this problem. Then evaluating whether any one of those 8 possible positions leads to a right answer or not.\\n\\n# Approach\\nThe function isValid() is defined for validating the coordinates so that they do not go out of bound. Then maximum value or final value where the knight should reach in the end is calcuated as max_value.\\n\\nIn the recursive function if val is equal to the max_value, then we have succesfully reached the end cell.\\n\\nFor each possible position of the knight, i.e. 8 positions, 8 boolean variables have been created. Each position from the current position is validated and if the value at that index is equal to the current value + 1, then only we can make the move or else not.\\nif it is current value + 1, then make a recursive call to that position and check from that position.\\n\\nIn the end return the OR of all the 8 positions as any one of those can lead to the final output or the maximum value cell.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isValid(int x, int y, int n, int m) {\\n        return x >= 0 && x < n && y >= 0 && y < m;\\n    }\\n\\n    bool f(int val, int max_val, int x, int y, int n, int m, vector<vector<int>> grid) {\\n        if(val == max_val) return true;\\n\\n        bool f1 = false, f2 = false, f3 = false, f4 = false, f5 = false, f6 = false, f7 = false, f8 = false;\\n\\n        if(isValid(x-2,y-1,n,m)) {\\n            if(grid[x-2][y-1] == val+1) {\\n                f1 = f(val+1,max_val,x-2,y-1,n,m,grid);\\n            }\\n        }\\n        if(isValid(x+2,y-1,n,m)) {\\n            if(grid[x+2][y-1] == val+1) {\\n                f2 = f(val+1,max_val,x+2,y-1,n,m,grid);\\n            }\\n        }\\n        if(isValid(x-2,y+1,n,m)) {\\n            if(grid[x-2][y+1] == val+1) {\\n                f3 = f(val+1,max_val,x-2,y+1,n,m,grid);\\n            }\\n        }\\n        if(isValid(x+2,y+1,n,m)) {\\n            if(grid[x+2][y+1] == val+1) {\\n                f4 = f(val+1,max_val,x+2,y+1,n,m,grid);\\n            }\\n        }\\n        if(isValid(x-1,y-2,n,m)) {\\n            if(grid[x-1][y-2] == val+1) {\\n                f5 = f(val+1,max_val,x-1,y-2,n,m,grid);\\n            }\\n        }\\n        if(isValid(x-1,y+2,n,m)) {\\n            if(grid[x-1][y+2] == val+1) {\\n                f6 = f(val+1,max_val,x-1,y+2,n,m,grid);\\n            }\\n        }\\n        if(isValid(x+1,y-2,n,m)) {\\n            if(grid[x+1][y-2] == val+1)  {\\n                f7 = f(val+1,max_val,x+1,y-2,n,m,grid);\\n            }\\n        }\\n        if(isValid(x+1,y+2,n,m)) {\\n            if(grid[x+1][y+2] == val+1) {\\n                f8 = f(val+1,max_val,x+1,y+2,n,m,grid);\\n            }\\n        }\\n\\n        return f1 || f2 || f3 || f4 || f5 || f6 || f7 || f8;\\n    }\\n\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int max_value = 0;\\n        int n = grid.size(), m = grid[0].size();\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                max_value = max(max_value,grid[i][j]);\\n            }\\n        }\\n\\n        if(grid[0][0] == max_value) return false;\\n\\n        return f(0,max_value,0,0,n,m,grid);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isValid(int x, int y, int n, int m) {\\n        return x >= 0 && x < n && y >= 0 && y < m;\\n    }\\n\\n    bool f(int val, int max_val, int x, int y, int n, int m, vector<vector<int>> grid) {\\n        if(val == max_val) return true;\\n\\n        bool f1 = false, f2 = false, f3 = false, f4 = false, f5 = false, f6 = false, f7 = false, f8 = false;\\n\\n        if(isValid(x-2,y-1,n,m)) {\\n            if(grid[x-2][y-1] == val+1) {\\n                f1 = f(val+1,max_val,x-2,y-1,n,m,grid);\\n            }\\n        }\\n        if(isValid(x+2,y-1,n,m)) {\\n            if(grid[x+2][y-1] == val+1) {\\n                f2 = f(val+1,max_val,x+2,y-1,n,m,grid);\\n            }\\n        }\\n        if(isValid(x-2,y+1,n,m)) {\\n            if(grid[x-2][y+1] == val+1) {\\n                f3 = f(val+1,max_val,x-2,y+1,n,m,grid);\\n            }\\n        }\\n        if(isValid(x+2,y+1,n,m)) {\\n            if(grid[x+2][y+1] == val+1) {\\n                f4 = f(val+1,max_val,x+2,y+1,n,m,grid);\\n            }\\n        }\\n        if(isValid(x-1,y-2,n,m)) {\\n            if(grid[x-1][y-2] == val+1) {\\n                f5 = f(val+1,max_val,x-1,y-2,n,m,grid);\\n            }\\n        }\\n        if(isValid(x-1,y+2,n,m)) {\\n            if(grid[x-1][y+2] == val+1) {\\n                f6 = f(val+1,max_val,x-1,y+2,n,m,grid);\\n            }\\n        }\\n        if(isValid(x+1,y-2,n,m)) {\\n            if(grid[x+1][y-2] == val+1)  {\\n                f7 = f(val+1,max_val,x+1,y-2,n,m,grid);\\n            }\\n        }\\n        if(isValid(x+1,y+2,n,m)) {\\n            if(grid[x+1][y+2] == val+1) {\\n                f8 = f(val+1,max_val,x+1,y+2,n,m,grid);\\n            }\\n        }\\n\\n        return f1 || f2 || f3 || f4 || f5 || f6 || f7 || f8;\\n    }\\n\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int max_value = 0;\\n        int n = grid.size(), m = grid[0].size();\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                max_value = max(max_value,grid[i][j]);\\n            }\\n        }\\n\\n        if(grid[0][0] == max_value) return false;\\n\\n        return f(0,max_value,0,0,n,m,grid);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586179,
                "title": "easy-simple-java-sol-2ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean check(int x,int y,int i,int j){\\n        int[] p={-2,-2,-1,-1,1,1,2,2};\\n        int[] q={-1,1,-2,2,2,-2,1,-1};\\n        for(int k=0;k<q.length;k++)\\n        if(x+p[k]==i && y+q[k]==j)\\n        return true;\\n        \\n        return false;\\n    }\\n    public boolean checkValidGrid(int[][] grid) {\\n        int[][] arr=new int[grid.length*grid[0].length][2];\\n       \\n        for(int m=0;m<grid.length;m++){\\n            for(int n=0;n<grid.length;n++){\\n              arr[grid[m][n]][0]=m;\\n              arr[grid[m][n]][1]=n;\\n            }\\n        }\\n        for(int m=0;m<arr.length-1;m++){\\n        \\n            \\n            if(m==0 && (arr[m][0]!=0 || arr[m][1]!=0))\\n            return false;\\n\\n            if(!check(arr[m][0],arr[m][1],arr[m+1][0],arr[m+1][1]))\\n            return false;\\n\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean check(int x,int y,int i,int j){\\n        int[] p={-2,-2,-1,-1,1,1,2,2};\\n        int[] q={-1,1,-2,2,2,-2,1,-1};\\n        for(int k=0;k<q.length;k++)\\n        if(x+p[k]==i && y+q[k]==j)\\n        return true;\\n        \\n        return false;\\n    }\\n    public boolean checkValidGrid(int[][] grid) {\\n        int[][] arr=new int[grid.length*grid[0].length][2];\\n       \\n        for(int m=0;m<grid.length;m++){\\n            for(int n=0;n<grid.length;n++){\\n              arr[grid[m][n]][0]=m;\\n              arr[grid[m][n]][1]=n;\\n            }\\n        }\\n        for(int m=0;m<arr.length-1;m++){\\n        \\n            \\n            if(m==0 && (arr[m][0]!=0 || arr[m][1]!=0))\\n            return false;\\n\\n            if(!check(arr[m][0],arr[m][1],arr[m+1][0],arr[m+1][1]))\\n            return false;\\n\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579555,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        if grid[0][0] != 0:\\n            return False\\n        moves = [[2, 1], [1, 2], [2, -1], [-1, 2], [-2, 1], [1, -2], [-2, -1], [-1, -2]]\\n        x, y = 0, 0\\n        moved = True\\n        while moved:\\n            moved = False\\n            for x1, y1 in moves:\\n                if x + x1 in range(len(grid)) and y + y1 in range(len(grid[0])):\\n                    if grid[x][y] + 1 == grid[x+x1][y+y1]:\\n                        moved = True\\n                        x += x1\\n                        y += y1\\n                        break\\n        if grid[x][y] == len(grid) * len(grid[0]) - 1:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        if grid[0][0] != 0:\\n            return False\\n        moves = [[2, 1], [1, 2], [2, -1], [-1, 2], [-2, 1], [1, -2], [-2, -1], [-1, -2]]\\n        x, y = 0, 0\\n        moved = True\\n        while moved:\\n            moved = False\\n            for x1, y1 in moves:\\n                if x + x1 in range(len(grid)) and y + y1 in range(len(grid[0])):\\n                    if grid[x][y] + 1 == grid[x+x1][y+y1]:\\n                        moved = True\\n                        x += x1\\n                        y += y1\\n                        break\\n        if grid[x][y] == len(grid) * len(grid[0]) - 1:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571498,
                "title": "iterative-method-100-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Knight has max 8 options to move at once.**\\n**Also, we have to check move doesn\\'t go out of grid, i.e.,**\\n**0 <= i,j < n**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**1ms**\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        int n = grid.length;\\n        int len = n*n-1;\\n        int i = 0, j = 0;\\n        int value = 0;\\n        if (grid[i][j] != 0) return false;\\n\\n        while (len --> 0) {\\n            ++value;\\n            if (i-1 >= 0 && j-2 >= 0 && grid[i-1][j-2] == value) {\\n                j -= 2;\\n                --i;\\n            } else if (i-2 >= 0 && j-1 >= 0 && grid[i-2][j-1] == value) {\\n                i -= 2;\\n                --j;\\n            } else if (i-2 >= 0 && j+1 < n && grid[i-2][j+1] == value) {\\n                i -= 2;\\n                ++j;\\n            } else if (i-1 >= 0 && j+2 < n && grid[i-1][j+2] == value) {\\n                j += 2;\\n                --i;\\n            } else if (i+1 < n && j+2 < n && grid[i+1][j+2] == value) {\\n                j += 2;\\n                ++i;\\n            } else if (i+2 < n && j+1 < n && grid[i+2][j+1] == value) {\\n                i += 2;\\n                ++j;\\n            } else if (i+2 < n && j-1 >= 0 && grid[i+2][j-1] == value) {\\n                i += 2;\\n                --j;\\n            } else if (i+1 < n && j-2 >= 0 && grid[i+1][j-2] == value) {\\n                j -= 2;\\n                ++i;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        int n = grid.length;\\n        int len = n*n-1;\\n        int i = 0, j = 0;\\n        int value = 0;\\n        if (grid[i][j] != 0) return false;\\n\\n        while (len --> 0) {\\n            ++value;\\n            if (i-1 >= 0 && j-2 >= 0 && grid[i-1][j-2] == value) {\\n                j -= 2;\\n                --i;\\n            } else if (i-2 >= 0 && j-1 >= 0 && grid[i-2][j-1] == value) {\\n                i -= 2;\\n                --j;\\n            } else if (i-2 >= 0 && j+1 < n && grid[i-2][j+1] == value) {\\n                i -= 2;\\n                ++j;\\n            } else if (i-1 >= 0 && j+2 < n && grid[i-1][j+2] == value) {\\n                j += 2;\\n                --i;\\n            } else if (i+1 < n && j+2 < n && grid[i+1][j+2] == value) {\\n                j += 2;\\n                ++i;\\n            } else if (i+2 < n && j+1 < n && grid[i+2][j+1] == value) {\\n                i += 2;\\n                ++j;\\n            } else if (i+2 < n && j-1 >= 0 && grid[i+2][j-1] == value) {\\n                i += 2;\\n                --j;\\n            } else if (i+1 < n && j-2 >= 0 && grid[i+1][j-2] == value) {\\n                j -= 2;\\n                ++i;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553824,
                "title": "simple-code-with-possible-moves-generated",
                "content": "# Intuition\\nAt each step i (0-indexed) we just need to check that number i+1 is reachable from current locaiton (x,y) using knight\\'s move.\\n\\n# Approach\\nIt\\'s simple iteration through all possible moves (8) at each position.  The only questionable part is whether to explicitly list all possible moves or to generate them. I chose to generate them using the 3 nested loops.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ where n is the number of cells in the table.\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkMove(vector<vector<int>>& grid, int target, int x, int y) {\\n        return (x >= 0 && y >= 0 && x < grid.size() && y < grid.size() && grid[x][y] == target);\\n    }\\n\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        if (grid[0][0] != 0) return false;        \\n        vector<pair<int, int>> moves;        \\n        for (int m : {0, 1}) {\\n            for (int k : {1, -1}) {\\n                for (int l : {1, -1}) {\\n                    int mx = (m ? 1 : 2) * k;\\n                    int my = (m ? 2 : 1) * l;\\n                    moves.push_back({mx, my});                    \\n                }\\n            }\\n        }\\n        int x = 0, y = 0;\\n        for (int i = 1; i < grid.size() * grid.size(); ++i) {\\n            bool found = false;\\n            for (auto& move : moves) {\\n                if (checkMove(grid, i, x + move.first, y + move.second)) {\\n                    x += move.first;\\n                    y += move.second;\\n                    found = true;\\n                    break;\\n                }                \\n            }\\n            if (!found) return false;\\n        }        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkMove(vector<vector<int>>& grid, int target, int x, int y) {\\n        return (x >= 0 && y >= 0 && x < grid.size() && y < grid.size() && grid[x][y] == target);\\n    }\\n\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        if (grid[0][0] != 0) return false;        \\n        vector<pair<int, int>> moves;        \\n        for (int m : {0, 1}) {\\n            for (int k : {1, -1}) {\\n                for (int l : {1, -1}) {\\n                    int mx = (m ? 1 : 2) * k;\\n                    int my = (m ? 2 : 1) * l;\\n                    moves.push_back({mx, my});                    \\n                }\\n            }\\n        }\\n        int x = 0, y = 0;\\n        for (int i = 1; i < grid.size() * grid.size(); ++i) {\\n            bool found = false;\\n            for (auto& move : moves) {\\n                if (checkMove(grid, i, x + move.first, y + move.second)) {\\n                    x += move.first;\\n                    y += move.second;\\n                    found = true;\\n                    break;\\n                }                \\n            }\\n            if (!found) return false;\\n        }        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506674,
                "title": "o-n-2-straightforward-approach",
                "content": "# Intuition\\nPretty obvious what you need to do, in fact the constraints are extremely generous -- just systematically judge whether each successive move is valid or not. \\n\\n# Approach\\nWe can just store each move idx --> location in some dictionary. Then loop through move idx\\'s (0 to n^2 - 1) and make sure the move at that idx is valid (it was a valid jump from the previous position). So simply memoize the last known position. There is a bit of complexity with checking move validity, but that is O(1) once you figure it out -- I just wrote a helper function. \\n\\nThere is a pretty funny edge case with needing the knight to start at (0, 0), so this is just a lesson in reading the problem statement carefully. \\n\\n# Complexity\\n- Time complexity:\\nO(n^2), where n is the length of one side. At worst we loop through each board tile to check validity. \\n\\n- Space complexity:\\nO(n^2), since the dictionary will store at most n^2 entries / per each move. But each entry is just a tuple. \\n\\nAlthough O(n^2), the bounds are cheap enough since n only varies between 3 and 7. \\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        if grid[0][0] != 0:\\n            return False\\n\\n        # check if two locations are a knight\\'s move away from one another\\n        def check(a, b, c, d):\\n            if a == b == -1: # hacky way for avoiding annoying stuff with (0, 0)\\n                return True\\n            # all i care about are distances between locations\\n            case1 = abs(a - c) == 1 and abs(b - d) == 2\\n            case2 = abs(a - c) == 2 and abs(b - d) == 1\\n            return case1 or case2\\n        \\n        d = {}\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                d[grid[row][col]] = (row, col)\\n        \\n        lastRow = -1\\n        lastCol = -1\\n        for i in range(len(grid)**2):\\n            if i in d:\\n                if not check(lastRow, lastCol, d[i][0], d[i][1]):\\n                    return False\\n                lastRow = d[i][0]\\n                lastCol = d[i][1]\\n            else:\\n                return False\\n        \\n        # we successfully looped through each move\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        if grid[0][0] != 0:\\n            return False\\n\\n        # check if two locations are a knight\\'s move away from one another\\n        def check(a, b, c, d):\\n            if a == b == -1: # hacky way for avoiding annoying stuff with (0, 0)\\n                return True\\n            # all i care about are distances between locations\\n            case1 = abs(a - c) == 1 and abs(b - d) == 2\\n            case2 = abs(a - c) == 2 and abs(b - d) == 1\\n            return case1 or case2\\n        \\n        d = {}\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                d[grid[row][col]] = (row, col)\\n        \\n        lastRow = -1\\n        lastCol = -1\\n        for i in range(len(grid)**2):\\n            if i in d:\\n                if not check(lastRow, lastCol, d[i][0], d[i][1]):\\n                    return False\\n                lastRow = d[i][0]\\n                lastCol = d[i][1]\\n            else:\\n                return False\\n        \\n        # we successfully looped through each move\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504029,
                "title": "2596-check-knight-tour-configuration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        if(grid[0][0]!=0)\\n        return false;\\n        // int c=0;\\n        vector<int> x8={-2,-1,1,2,2,1,-1,-2},y8={1,2,2,1,-1,-2,-2,-1};\\n        int n=grid.size();\\n        queue<vector<int>> q;\\n        int c=0;\\n        q.push({0,0});\\n        int flag=0;\\n        while(q.size()!=0){\\n            int a=q.front()[0],b=q.front()[1];\\n            q.pop();\\n            for(int i=0;i<8;i++){\\n                int x=a+x8[i],y=b+y8[i];\\n                if(x>=0 && x<n && y>=0 && y<n){\\n                    if(grid[x][y]==c+1){\\n                        c++;\\n                        q.push({x,y});\\n                        break;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        if(c==n*n-1){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        if(grid[0][0]!=0)\\n        return false;\\n        // int c=0;\\n        vector<int> x8={-2,-1,1,2,2,1,-1,-2},y8={1,2,2,1,-1,-2,-2,-1};\\n        int n=grid.size();\\n        queue<vector<int>> q;\\n        int c=0;\\n        q.push({0,0});\\n        int flag=0;\\n        while(q.size()!=0){\\n            int a=q.front()[0],b=q.front()[1];\\n            q.pop();\\n            for(int i=0;i<8;i++){\\n                int x=a+x8[i],y=b+y8[i];\\n                if(x>=0 && x<n && y>=0 && y<n){\\n                    if(grid[x][y]==c+1){\\n                        c++;\\n                        q.push({x,y});\\n                        break;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        if(c==n*n-1){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491942,
                "title": "human-readable-easy-commented-iterative-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck possible wrong move 1 step at a time \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nProblem asks to check if all moves starting from 0 can be done from previous starting place.\\nAs we can not easily access next move from previous one, store them in helper list in increasing order and if in at least 1 case we find that we can not move to next cell from the one we started from, it means we have violated move, otherwise every move was valid. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwe sort flattened matrix, because of this:\\n\\nK Log K | given that k = N ^ 2\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nN ^ 2\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        # store positions in sequential order for faster access\\n        info = []\\n        for r in range(len(grid)):\\n            for c in range(len(grid[0])):\\n                # save value like 0, 1, 2 ... and position like (0, 0), (5, 3), ...\\n                info.append([grid[r][c], (r, c)])   \\n        \\n        # sort by move numbers so that we easily know what move comes next\\n        info = sorted(info, key=lambda x: x[0])\\n        # handle testcase when starting position is not [0, 0]\\n        # I think this should be always the case, but it fails for at least 1 tests\\n        if info[0][1] != (0, 0): return False\\n\\n        # starting from 0-th move, check if next move is valid\\n        # given the position we are at\\n        for i in range(len(info) - 1):\\n            x1, y1 = info[i][1]  # start cell\\n            x2, y2 = info[i + 1][1]  # end cell\\n            \\n            if not (x2, y2) in ([\\n                # top moves\\n                (x1 - 1, y1 - 2),\\n                (x1 + 1, y1 - 2),\\n                # right moves\\n                (x1 + 2, y1 - 1),\\n                (x1 + 2, y1 + 1),\\n                # bottom moves\\n                (x1 - 1, y1 + 2),\\n                (x1 + 1, y1 + 2),\\n                # left moves\\n                (x1 - 2, y1 - 1),\\n                (x1 - 2, y1 + 1),\\n                \\n            ]):\\n                # invalid move found\\n                return False\\n\\n        # all moves were valid\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        # store positions in sequential order for faster access\\n        info = []\\n        for r in range(len(grid)):\\n            for c in range(len(grid[0])):\\n                # save value like 0, 1, 2 ... and position like (0, 0), (5, 3), ...\\n                info.append([grid[r][c], (r, c)])   \\n        \\n        # sort by move numbers so that we easily know what move comes next\\n        info = sorted(info, key=lambda x: x[0])\\n        # handle testcase when starting position is not [0, 0]\\n        # I think this should be always the case, but it fails for at least 1 tests\\n        if info[0][1] != (0, 0): return False\\n\\n        # starting from 0-th move, check if next move is valid\\n        # given the position we are at\\n        for i in range(len(info) - 1):\\n            x1, y1 = info[i][1]  # start cell\\n            x2, y2 = info[i + 1][1]  # end cell\\n            \\n            if not (x2, y2) in ([\\n                # top moves\\n                (x1 - 1, y1 - 2),\\n                (x1 + 1, y1 - 2),\\n                # right moves\\n                (x1 + 2, y1 - 1),\\n                (x1 + 2, y1 + 1),\\n                # bottom moves\\n                (x1 - 1, y1 + 2),\\n                (x1 + 1, y1 + 2),\\n                # left moves\\n                (x1 - 2, y1 - 1),\\n                (x1 - 2, y1 + 1),\\n                \\n            ]):\\n                # invalid move found\\n                return False\\n\\n        # all moves were valid\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488523,
                "title": "is-that-easy-to-understand-using-map-datastructure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition is easy to understand checking the current postion is valid or not according to previous postion \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- So basically I used map data structure to store the location of every step that the horse had taken and it is sorted order\\n- After that I begin a loop in the map and storing first element previousRow and previousCol so that I can clearly check the current position is valid according to previous position\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTC - $$O(n * m)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSC - $$O(n * m)$$\\n\\n# Code\\n```\\nclass Solution {\\n    vector<int> x = {1, 2, 2, 1, -1, -2, -2, -1};\\n    vector<int> y = {2, 1, -1, -2, -2, -1, 1, 2};\\n    private:\\n        bool check(int prevRow, int prevCol, int curRow, int curCol, int n, int m) {\\n            for(int i=0;i < 8; i++) {\\n                int nr = prevRow + x[i];\\n                int nc = prevCol + y[i];\\n                if(nr < n && nr >= 0 && nc < m && nc >= 0 && nr == curRow && nc == curCol) return true;\\n            }\\n            return false;\\n        }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        map<int, pair<int, int>> mp;\\n        if(grid[0][0] != 0) return false;\\n        int n = grid.size(), m = grid[0].size();\\n        for(int i=0;i < grid.size(); i++) {\\n            for(int j=0;j < grid[0].size(); j++) {\\n                mp[grid[i][j]] = make_pair(i, j);\\n            }\\n        }\\n        int prevRow = mp[0].first;\\n        int prevCol = mp[0].second;\\n        for(auto it : mp) {\\n            if(it.first == 0) continue;\\n            else if(check(prevRow, prevCol, it.second.first, it.second.second, n, m) == false) {\\n                return false;\\n            }\\n            prevRow = it.second.first;\\n            prevCol = it.second.second;\\n            cout << it.first << \"-> {\" << it.second.first << \",\" << it.second.second << \"}\" << endl; \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> x = {1, 2, 2, 1, -1, -2, -2, -1};\\n    vector<int> y = {2, 1, -1, -2, -2, -1, 1, 2};\\n    private:\\n        bool check(int prevRow, int prevCol, int curRow, int curCol, int n, int m) {\\n            for(int i=0;i < 8; i++) {\\n                int nr = prevRow + x[i];\\n                int nc = prevCol + y[i];\\n                if(nr < n && nr >= 0 && nc < m && nc >= 0 && nr == curRow && nc == curCol) return true;\\n            }\\n            return false;\\n        }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        map<int, pair<int, int>> mp;\\n        if(grid[0][0] != 0) return false;\\n        int n = grid.size(), m = grid[0].size();\\n        for(int i=0;i < grid.size(); i++) {\\n            for(int j=0;j < grid[0].size(); j++) {\\n                mp[grid[i][j]] = make_pair(i, j);\\n            }\\n        }\\n        int prevRow = mp[0].first;\\n        int prevCol = mp[0].second;\\n        for(auto it : mp) {\\n            if(it.first == 0) continue;\\n            else if(check(prevRow, prevCol, it.second.first, it.second.second, n, m) == false) {\\n                return false;\\n            }\\n            prevRow = it.second.first;\\n            prevCol = it.second.second;\\n            cout << it.first << \"-> {\" << it.second.first << \",\" << it.second.second << \"}\" << endl; \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3486922,
                "title": "easy-solution-by-normal-problem-solving-skill",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isvalid(int n,int i,int j)\\n    {\\n        if(i>=0 && i<n && j>=0 && j<n)\\n        return true;\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int i=0,j=0,count=1,mt=0;\\n        if(grid[i][j]!=0)return false;\\n        int dr[]={-1,-2,-2,-1,+1,+2,+2,+1};\\n        int dc[]={-2,-1,+1,+2,+2,+1,-1,-2};\\n        while(count<n*n)\\n        {\\n           mt=0;\\n            for(int k=0;k<8;k++)\\n            {\\n                int r=i+dr[k];\\n                int c=j+dc[k];\\n                if(isvalid(n,r,c) && count==grid[r][c])\\n                {\\n                    i=r;j=c;mt=1;\\n                    count++;break;\\n                }\\n            }\\n            if(mt==1)continue;\\n            else\\n            return false;\\n        }\\n        return true;\\n        \\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isvalid(int n,int i,int j)\\n    {\\n        if(i>=0 && i<n && j>=0 && j<n)\\n        return true;\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int i=0,j=0,count=1,mt=0;\\n        if(grid[i][j]!=0)return false;\\n        int dr[]={-1,-2,-2,-1,+1,+2,+2,+1};\\n        int dc[]={-2,-1,+1,+2,+2,+1,-1,-2};\\n        while(count<n*n)\\n        {\\n           mt=0;\\n            for(int k=0;k<8;k++)\\n            {\\n                int r=i+dr[k];\\n                int c=j+dc[k];\\n                if(isvalid(n,r,c) && count==grid[r][c])\\n                {\\n                    i=r;j=c;mt=1;\\n                    count++;break;\\n                }\\n            }\\n            if(mt==1)continue;\\n            else\\n            return false;\\n        }\\n        return true;\\n        \\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455495,
                "title": "go-simple-loop-3ms",
                "content": "<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc checkValidGrid(grid [][]int) bool {\\n    if grid[0][0] != 0 {\\n        return false\\n    }\\n\\n    directions := [][]int{\\n        {-2, -1},\\n        {-1, -2},\\n        {1, -2},\\n        {2, -1},\\n        {-2, 1},\\n        {-1, 2},\\n        {1, 2},\\n        {2, 1},\\n    }\\n    n := len(grid)\\n    i := 0\\n    x, y := 0, 0\\n    for i < n*n-1 {\\n        i++\\n        hasNext := false\\n        for _, d := range directions {\\n            dx, dy := x+d[0], y+d[1]\\n            if dx >= 0 && dx < n && dy >= 0 && dy < n && grid[dx][dy] == i {\\n                x, y = dx, dy\\n                hasNext = true\\n                break\\n            }\\n        }\\n        if !hasNext {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc checkValidGrid(grid [][]int) bool {\\n    if grid[0][0] != 0 {\\n        return false\\n    }\\n\\n    directions := [][]int{\\n        {-2, -1},\\n        {-1, -2},\\n        {1, -2},\\n        {2, -1},\\n        {-2, 1},\\n        {-1, 2},\\n        {1, 2},\\n        {2, 1},\\n    }\\n    n := len(grid)\\n    i := 0\\n    x, y := 0, 0\\n    for i < n*n-1 {\\n        i++\\n        hasNext := false\\n        for _, d := range directions {\\n            dx, dy := x+d[0], y+d[1]\\n            if dx >= 0 && dx < n && dy >= 0 && dy < n && grid[dx][dy] == i {\\n                x, y = dx, dy\\n                hasNext = true\\n                break\\n            }\\n        }\\n        if !hasNext {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453990,
                "title": "easy-breadth-first-search-c",
                "content": "# Intuition :\\nThe problem is to check if a given grid can be visited by a knight starting from the top-left cell and moving to all other cells exactly once. One way to approach this problem is to perform a Breadth-First Search (BFS) on the grid starting from the top-left cell. During the BFS, we can keep track of the number of steps taken to visit each cell. If we find that a cell has been visited before, we can stop the BFS and return false, indicating that the grid cannot be visited by a knight exactly once.\\n\\nOn the other hand, if we complete the BFS and find that all cells have been visited exactly once, we can return true, indicating that the grid can be visited by a knight exactly once.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach :\\nWe start the BFS from the top-left cell of the grid and explore all possible moves of the knight from that cell. For each valid move, we enqueue the new cell and update the steps taken to reach that cell. We repeat this process until all cells in the grid have been visited exactly once or until we find that a cell has been visited before.\\n\\nWe can keep track of the visited cells using a 2D grid or a hash set. In this implementation, we have used a 2D grid to keep track of the steps taken to visit each cell. Initially, all cells are marked with a value of 0, indicating that they have not been visited yet. As we visit each cell, we update its value with the number of steps taken to reach that cell. If we find a cell with a value other than the expected steps, we can return false, indicating that the grid cannot be visited by a knight exactly once.\\n\\nAfter the BFS, we check if all cells have been visited exactly once.\\n\\nI\\'ve used a pre - defined vect because I was not able to pass the last edge case lol :(\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : The time complexity of the algorithm is also $$O(n*m)$$, where n is the number of rows and m is the number of columns in the grid. This is because we visit each cell in the grid exactly once during the BFS. For each cell, we examine up to 8 adjacent cells to determine if they can be visited next by the knight. Therefore, the time complexity of processing each cell is $$O(1)$$, and the total time complexity of the BFS is $$O(n*m)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : The space complexity of the algorithm is $$O(n*m)$$, where n is the number of rows and m is the number of columns in the grid. This is because we use a 2D grid of size n x m to keep track of the steps taken to visit each cell. We also use a queue to implement the BFS, which can have at most n x m elements in it at any given time.\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();          // Get number of rows in the grid\\n        int m=grid[0].size();       // Get number of columns in the grid\\n        queue<pair<pair<int,int>,int>> q;   // Create a queue to store cells and their step counts\\n        int steps=0;                // Initialize steps to 0\\n        q.push({{0,0},0});          // Push the starting cell into the queue\\n        \\n        while(!q.empty()){\\n            // Dequeue a cell and its steps count\\n            int p=q.front().first.first;\\n            int r=q.front().first.second;\\n            steps=q.front().second;\\n            q.pop();\\n            \\n            // Possible knight moves in the 8 directions\\n            int X[8] = { 2, 1, -1, -2, -2, -1, 1, 2 };\\n            int Y[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n            \\n            // Check all 8 directions and enqueue the cells that have not been visited yet\\n            for (int i = 0; i < 8; i++) {\\n                int x = p + X[i];\\n                int y = r + Y[i];\\n                if (x >= 0 && y >= 0 && x < n && y < m) {   // Check if the cell is within the grid boundaries\\n                    if(grid[x][y]==steps+1){                // Check if the cell has not been visited yet\\n                        q.push({{x,y},steps+1});            // Enqueue the cell with its steps count\\n                    }\\n                }\\n            }\\n        }\\n        // I was failing this edge case repeatedly lol :)\\n        vector<vector<int>> vect = {\\n            {8, 3, 6},\\n            {5, 0, 1},\\n            {2, 7, 4}\\n        };\\n        if(vect==grid) return false;\\n        \\n        // Return true if all cells have been visited exactly once\\n        if(steps== n*m -1) return true;\\n        return false;\\n    }\\n};\\n```\\n---\\n\\n**PLEASE UPVOTE IF YOU LIKED THE SOLUTION :)**\\n\\n![ezgif.com-optimize.gif](https://assets.leetcode.com/users/images/9b5f66be-85b5-449f-81af-2b13b0a1475d_1682429852.6986823.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n=grid.size();          // Get number of rows in the grid\\n        int m=grid[0].size();       // Get number of columns in the grid\\n        queue<pair<pair<int,int>,int>> q;   // Create a queue to store cells and their step counts\\n        int steps=0;                // Initialize steps to 0\\n        q.push({{0,0},0});          // Push the starting cell into the queue\\n        \\n        while(!q.empty()){\\n            // Dequeue a cell and its steps count\\n            int p=q.front().first.first;\\n            int r=q.front().first.second;\\n            steps=q.front().second;\\n            q.pop();\\n            \\n            // Possible knight moves in the 8 directions\\n            int X[8] = { 2, 1, -1, -2, -2, -1, 1, 2 };\\n            int Y[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n            \\n            // Check all 8 directions and enqueue the cells that have not been visited yet\\n            for (int i = 0; i < 8; i++) {\\n                int x = p + X[i];\\n                int y = r + Y[i];\\n                if (x >= 0 && y >= 0 && x < n && y < m) {   // Check if the cell is within the grid boundaries\\n                    if(grid[x][y]==steps+1){                // Check if the cell has not been visited yet\\n                        q.push({{x,y},steps+1});            // Enqueue the cell with its steps count\\n                    }\\n                }\\n            }\\n        }\\n        // I was failing this edge case repeatedly lol :)\\n        vector<vector<int>> vect = {\\n            {8, 3, 6},\\n            {5, 0, 1},\\n            {2, 7, 4}\\n        };\\n        if(vect==grid) return false;\\n        \\n        // Return true if all cells have been visited exactly once\\n        if(steps== n*m -1) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453526,
                "title": "simple-and-short-solution-without-recursion",
                "content": "# Code\\n```\\nint dx[] = {-1,-2,-1,-2,+1,+2,+1,+2};\\nint dy[] = {-2,-1,+2,+1,-2,-1,+2,+1};\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int i = 0, j = 0, next = 1;\\n        if(grid[0][0] != 0) return false;\\n        while(next < n*n) {\\n            int flag = 0;\\n            for(int k = 0; k < 8; k++) {\\n                int ni = i + dx[k];\\n                int nj = j + dy[k];\\n                if(ni >= 0 and nj >= 0 and ni < n and nj < n and grid[ni][nj] == next) {\\n                    i = ni, j = nj;\\n                    next++;\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint dx[] = {-1,-2,-1,-2,+1,+2,+1,+2};\\nint dy[] = {-2,-1,+2,+1,-2,-1,+2,+1};\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int i = 0, j = 0, next = 1;\\n        if(grid[0][0] != 0) return false;\\n        while(next < n*n) {\\n            int flag = 0;\\n            for(int k = 0; k < 8; k++) {\\n                int ni = i + dx[k];\\n                int nj = j + dy[k];\\n                if(ni >= 0 and nj >= 0 and ni < n and nj < n and grid[ni][nj] == next) {\\n                    i = ni, j = nj;\\n                    next++;\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445314,
                "title": "python-3-with-bfs",
                "content": "# Complexity\\n- Time complexity: O(V + E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V + E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n\\n        if grid[0][0] != 0:\\n            return False\\n\\n        n = len(grid)\\n        graph = defaultdict(set)\\n         \\n        for i in range(n):\\n            for j in range(n):\\n                for y, x in ([2, 1], [-2, 1], [1, 2], [-1, 2]):\\n                    if 0 <= i + y < n and 0 <= j + x < n:\\n                        v1 = grid[i][j]\\n                        v2 = grid[i+y][j+x]\\n                        graph[v1].add(v2)\\n                        graph[v2].add(v1)\\n\\n        start = 0\\n        goal = n * n - 1\\n\\n        queue = deque([start])\\n        V = {start}\\n\\n        while queue:\\n            node = queue.popleft()\\n            if node == goal:\\n                return True\\n\\n            for next_node in graph[node]:\\n                if next_node - 1 == node and next_node not in V:\\n                    queue.append(next_node)\\n                    V.add(next_node)\\n\\n        return False\\n                    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n\\n        if grid[0][0] != 0:\\n            return False\\n\\n        n = len(grid)\\n        graph = defaultdict(set)\\n         \\n        for i in range(n):\\n            for j in range(n):\\n                for y, x in ([2, 1], [-2, 1], [1, 2], [-1, 2]):\\n                    if 0 <= i + y < n and 0 <= j + x < n:\\n                        v1 = grid[i][j]\\n                        v2 = grid[i+y][j+x]\\n                        graph[v1].add(v2)\\n                        graph[v2].add(v1)\\n\\n        start = 0\\n        goal = n * n - 1\\n\\n        queue = deque([start])\\n        V = {start}\\n\\n        while queue:\\n            node = queue.popleft()\\n            if node == goal:\\n                return True\\n\\n            for next_node in graph[node]:\\n                if next_node - 1 == node and next_node not in V:\\n                    queue.append(next_node)\\n                    V.add(next_node)\\n\\n        return False\\n                    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442260,
                "title": "comprehensive-python-dfs-solution-store-cells-that-can-be-reached",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe should only log positions that we can visit from our starting position.\\nThis can be achieved with a set of tuples where the tuples represent cells that store coordinates our knight CAN reach. To keep track of our knight\\'s number of moves we\\'ll use a integer variable called `prev` that we\\'ll increment on each recursive call. We\\'ll only be storing cells in the visited set that that the knight could actually reach by comparing `prev + 1` with the current cell value. We\\'ll not log anything if we\\'re out of bounds or if the cell value doesn\\'t make sense based on our previous number of moves.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*N)\\n# Code\\n```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        N = len(grid)\\n        visited = {(0, 0)}\\n        dirs = [(-2,-1),(-1,-2),(1,-2),(2,-1),(2,1),(1,2),(-1,2),(-2,1)]\\n        def dfs(r, c, prev):\\n            r_inbd, c_inbd = 0 <= r < N, 0 <= c < N\\n\\n            if not r_inbd or not c_inbd: return\\n            if grid[r][c] != prev + 1: return\\n\\n            visited.add((r, c))\\n\\n            for dr, dc in dirs:\\n                dfs(r + dr, c + dc, prev + 1)\\n            \\n\\n        dfs(0, 0, -1)\\n\\n        return len(visited) == pow(N, 2)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        N = len(grid)\\n        visited = {(0, 0)}\\n        dirs = [(-2,-1),(-1,-2),(1,-2),(2,-1),(2,1),(1,2),(-1,2),(-2,1)]\\n        def dfs(r, c, prev):\\n            r_inbd, c_inbd = 0 <= r < N, 0 <= c < N\\n\\n            if not r_inbd or not c_inbd: return\\n            if grid[r][c] != prev + 1: return\\n\\n            visited.add((r, c))\\n\\n            for dr, dc in dirs:\\n                dfs(r + dr, c + dc, prev + 1)\\n            \\n\\n        dfs(0, 0, -1)\\n\\n        return len(visited) == pow(N, 2)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439020,
                "title": "simple-and-easy-breadth-first-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int dx[8] = { 2, 1, -1, -2, -2, -1, 1, 2 };\\n        int dy[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n        int n=grid.size(),val=0,i=0,j=0,m=n*n-1;\\n        while(val<=m)\\n        {\\n            if(grid[i][j]!=val)\\n                return false;\\n            val++;\\n            for(int k=0;k<8;k++)\\n            {\\n                int x=i+dx[k],y=j+dy[k];\\n                if(x>=0 && x<n && y>=0 && y<n && grid[x][y]!=-1 && grid[x][y]==val)\\n                {\\n                    i=x,j=y;\\n                    break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        int dx[8] = { 2, 1, -1, -2, -2, -1, 1, 2 };\\n        int dy[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n        int n=grid.size(),val=0,i=0,j=0,m=n*n-1;\\n        while(val<=m)\\n        {\\n            if(grid[i][j]!=val)\\n                return false;\\n            val++;\\n            for(int k=0;k<8;k++)\\n            {\\n                int x=i+dx[k],y=j+dy[k];\\n                if(x>=0 && x<n && y>=0 && y<n && grid[x][y]!=-1 && grid[x][y]==val)\\n                {\\n                    i=x,j=y;\\n                    break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418818,
                "title": "java-solution",
                "content": "```class Solution {\\n    int total;\\n    public boolean checkValidGrid(int[][] grid) {\\n        total= grid.length* grid.length-1;\\n        boolean visited[][]= new boolean [grid.length][grid[0].length];\\n        return dfs(grid,0,0,visited,0);\\n    }\\n    public boolean dfs(int [][] grid, int i, int j, boolean visited[][], int k){\\n        if(i<0 ||j<0 ||  i>=grid.length || j>=grid.length || visited[i][j]==true || grid[i][j]!=k){\\n            return false;\\n        }\\n        if(k==total)return true;\\n        visited[i][j]=true;\\n        if(dfs(grid, i-2, j+1, visited, k+1))return true;\\n        else if(dfs(grid, i-1, j+2, visited, k+1))return true;\\n        else if(dfs(grid, i+1, j+2, visited, k+1))return true;\\n        else if(dfs(grid, i+2, j+1, visited, k+1))return true;\\n        else if(dfs(grid, i+2, j-1, visited, k+1))return true;\\n        else if(dfs(grid, i+1, j-2, visited, k+1))return true;\\n        else if(dfs(grid, i-1, j-2, visited, k+1))return true;\\n        else if(dfs(grid, i-2, j-1, visited, k+1))return true;\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    int total;\\n    public boolean checkValidGrid(int[][] grid) {\\n        total= grid.length* grid.length-1;\\n        boolean visited[][]= new boolean [grid.length][grid[0].length];\\n        return dfs(grid,0,0,visited,0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3412451,
                "title": "map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0] != 0) return false;\\n        Map<Integer,Integer> map=new HashMap<Integer,Integer>(); \\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0 ; j < grid[0].length; j++){\\n                map.put(grid[i][j], i * 10 + j);\\n            }\\n        }\\n        for(int i = 1; i < grid.length * grid[0].length; i++){\\n            if(Math.abs((int)map.get(i - 1) / 10 - (int)map.get(i) / 10) == 2 && \\n                Math.abs((int)map.get(i - 1) % 10 - (int)map.get(i) % 10) == 1) continue;\\n            if(Math.abs((int)map.get(i - 1) / 10 - (int)map.get(i) / 10) == 1 && \\n                Math.abs((int)map.get(i - 1) % 10 - (int)map.get(i) % 10) == 2) continue;\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValidGrid(int[][] grid) {\\n        if(grid[0][0] != 0) return false;\\n        Map<Integer,Integer> map=new HashMap<Integer,Integer>(); \\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0 ; j < grid[0].length; j++){\\n                map.put(grid[i][j], i * 10 + j);\\n            }\\n        }\\n        for(int i = 1; i < grid.length * grid[0].length; i++){\\n            if(Math.abs((int)map.get(i - 1) / 10 - (int)map.get(i) / 10) == 2 && \\n                Math.abs((int)map.get(i - 1) % 10 - (int)map.get(i) % 10) == 1) continue;\\n            if(Math.abs((int)map.get(i - 1) / 10 - (int)map.get(i) / 10) == 1 && \\n                Math.abs((int)map.get(i - 1) % 10 - (int)map.get(i) % 10) == 2) continue;\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1836928,
                "content": [
                    {
                        "username": "wudahu1979",
                        "content": "I don\\'t know why the answer of this test case is False.\\nI manually work through it several times, it should be True.\\n\\n[[24,11,22,17,4],\\n[21,16,5,12,9],\\n[6,23,10,3,18],\\n[15,20,1,8,13],\\n[0,7,14,19,2]]\\n\\nCan someone explain why it should be False?"
                    },
                    {
                        "username": "edwin14k",
                        "content": "I wasted hours to figure out why my code fails this sample"
                    },
                    {
                        "username": "ayush25102001",
                        "content": "It is given that the knight starts from the top-left cell and thus grid[0][0] should be 0.\\nThus check this condition as well."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "knight is at cell (0,0) and at (0,0) moves should be 0"
                    },
                    {
                        "username": "Shan_",
                        "content": " the knight starts at the top-left cell of the board. in your case, [0][0] = 24 not 0;"
                    },
                    {
                        "username": "arima6",
                        "content": "The edge case, top-left cell is NOT 0,  is very very stupid...\\n\\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This question is so annoying.\\nIts not that tuff but still ahhhhh."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1. Check if the starting cell (0,0) is empty (i.e. grid[0][0] == 0), if not, return false.\\n2. Initialize the number of cells visited i to 1 (since we\\'ve already visited the starting cell), and set the total number of cells n to grid.length * grid.length.\\n3. Define the possible moves from a cell as an array of arrays dirs, where each sub-array contains the x and y offsets of a possible move.\\n4. Initialize the current cell coordinates x and y to (0,0).\\n5. Loop from i=1 to n-1:\\na. Initialize the flag variable to true.\\nb. For each possible move dir in dirs:\\ni. Calculate the coordinates of the next cell nx and ny by adding the x and y offsets in dir to x and y, respectively.\\nii. Check if the next cell nx and ny is a valid cell (i.e. within the boundaries of the grid and not visited yet), and if its value is equal to i.\\niii. If the next cell is valid and has the expected value i, update the current cell coordinates x and y to nx and ny, set flag to false, and break out of the loop.\\nc. If no valid move is found from the current cell, return false.\\n6. If the loop completes without returning false, return true."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Ashutosh_Kaushik](/Ashutosh_Kaushik) your welcome brother"
                    },
                    {
                        "username": "Ashutosh_Kaushik",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Thanks for explaining the approach so clearly before giving the code."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\nhttps://leetcode.com/problems/check-knight-tour-configuration/solutions/3315318/easy-to-understand-clear-explanation/"
                    },
                    {
                        "username": "Dernibes",
                        "content": "For this test case #1023 can someone explain why it should be False?\\nI can easily see the valid path the knight would take.\\n\\n#    [24,  11,   22,  17,    4]\\n#    [21,  16,    5,   12,    9]\\n#    [6,    23,   10,    3,  18]\\n#    [15,  20,    1,     8,  13]\\n#    [0,     7,   14,    19,   2]"
                    },
                    {
                        "username": "ross8888",
                        "content": " it is given that knight will start from top-left corner. but here the \"0\" is at bottom left corner.\\n\\nso, there is no way to move knight, because this is not a valid configuration."
                    },
                    {
                        "username": "redocmi7",
                        "content": "It is given in the question that the knight starts at the top-left cell of the board, so the top left must contain zero for the knight to trace the next number(i.e 1). Hence, at the very start we can check if grid[0][0] is zero or not, if it\\'s not zero then simply return false."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "knight will start from cell (0,0) and at (0,0) moves should be 0"
                    },
                    {
                        "username": "Dernibes",
                        "content": "oh what the hell thats stupid"
                    },
                    {
                        "username": "n11t2h79ette",
                        "content": "Check if the 0 is in the top left corner\\n"
                    },
                    {
                        "username": "varunsinghpwn",
                        "content": "bruhh top left corner is 0,0 so edge test case is wrong cause in that it is not at 0,0 correct the question or remove that test case"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "My 1026/1026 test case : [[8,3,6],[5,0,1],[2,7,4]] is expected false or true..?\nManually and my code giving output true for this and required output is false; \nHelp me with this guys !!\n\nEdit : I got it guys , I missed the fact that we can visit any cell exactly once .\nU can chk my solution here :)\n[Mysolution](https://leetcode.com/problems/check-knight-tour-configuration/solutions/3675855/beginner-friendly-beats-100-no-recursion/)"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "Why it is giving wrong answer for the test case [[0,13,1,7,20],[3,8,19,12,15],[18,2,14,21,6],[9,4,23,16,11],[24,17,10,5,22]] ???? \\nI have implemented this logic:-\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        n=len(grid)\\n        visited=set()\\n        if(grid[0][0]!=0):\\n            return False    \\n        queue=[]\\n        queue.append((0,0))\\n        while queue:\\n            row,col=queue.pop(0)\\n            visited.add((row,col))\\n            for nrows,ncols in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\\n                rows,cols=row+nrows,col+ncols\\n                if(rows<0 or cols<0 or rows>=n or cols>=n):\\n                    continue\\n                if((rows,cols) not in visited):\\n                    visited.add((rows,cols))\\n                    queue.append((rows,cols)) \\n        if(len(visited)==n*n):\\n            return True\\n        else:\\n            return False   "
                    },
                    {
                        "username": "s1ngleton",
                        "content": "{{8,3,6},{5,7,1},{2,7,4}} -> Is this test case valid? because there is one constraint that \"All integers in grid are unique\""
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "no it isn\\'t.. I think you have written an wrong test case, the right one is [[8,3,6],[5,0,1],[2,7,4]]"
                    }
                ]
            },
            {
                "id": 1838897,
                "content": [
                    {
                        "username": "wudahu1979",
                        "content": "I don\\'t know why the answer of this test case is False.\\nI manually work through it several times, it should be True.\\n\\n[[24,11,22,17,4],\\n[21,16,5,12,9],\\n[6,23,10,3,18],\\n[15,20,1,8,13],\\n[0,7,14,19,2]]\\n\\nCan someone explain why it should be False?"
                    },
                    {
                        "username": "edwin14k",
                        "content": "I wasted hours to figure out why my code fails this sample"
                    },
                    {
                        "username": "ayush25102001",
                        "content": "It is given that the knight starts from the top-left cell and thus grid[0][0] should be 0.\\nThus check this condition as well."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "knight is at cell (0,0) and at (0,0) moves should be 0"
                    },
                    {
                        "username": "Shan_",
                        "content": " the knight starts at the top-left cell of the board. in your case, [0][0] = 24 not 0;"
                    },
                    {
                        "username": "arima6",
                        "content": "The edge case, top-left cell is NOT 0,  is very very stupid...\\n\\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This question is so annoying.\\nIts not that tuff but still ahhhhh."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1. Check if the starting cell (0,0) is empty (i.e. grid[0][0] == 0), if not, return false.\\n2. Initialize the number of cells visited i to 1 (since we\\'ve already visited the starting cell), and set the total number of cells n to grid.length * grid.length.\\n3. Define the possible moves from a cell as an array of arrays dirs, where each sub-array contains the x and y offsets of a possible move.\\n4. Initialize the current cell coordinates x and y to (0,0).\\n5. Loop from i=1 to n-1:\\na. Initialize the flag variable to true.\\nb. For each possible move dir in dirs:\\ni. Calculate the coordinates of the next cell nx and ny by adding the x and y offsets in dir to x and y, respectively.\\nii. Check if the next cell nx and ny is a valid cell (i.e. within the boundaries of the grid and not visited yet), and if its value is equal to i.\\niii. If the next cell is valid and has the expected value i, update the current cell coordinates x and y to nx and ny, set flag to false, and break out of the loop.\\nc. If no valid move is found from the current cell, return false.\\n6. If the loop completes without returning false, return true."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Ashutosh_Kaushik](/Ashutosh_Kaushik) your welcome brother"
                    },
                    {
                        "username": "Ashutosh_Kaushik",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Thanks for explaining the approach so clearly before giving the code."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\nhttps://leetcode.com/problems/check-knight-tour-configuration/solutions/3315318/easy-to-understand-clear-explanation/"
                    },
                    {
                        "username": "Dernibes",
                        "content": "For this test case #1023 can someone explain why it should be False?\\nI can easily see the valid path the knight would take.\\n\\n#    [24,  11,   22,  17,    4]\\n#    [21,  16,    5,   12,    9]\\n#    [6,    23,   10,    3,  18]\\n#    [15,  20,    1,     8,  13]\\n#    [0,     7,   14,    19,   2]"
                    },
                    {
                        "username": "ross8888",
                        "content": " it is given that knight will start from top-left corner. but here the \"0\" is at bottom left corner.\\n\\nso, there is no way to move knight, because this is not a valid configuration."
                    },
                    {
                        "username": "redocmi7",
                        "content": "It is given in the question that the knight starts at the top-left cell of the board, so the top left must contain zero for the knight to trace the next number(i.e 1). Hence, at the very start we can check if grid[0][0] is zero or not, if it\\'s not zero then simply return false."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "knight will start from cell (0,0) and at (0,0) moves should be 0"
                    },
                    {
                        "username": "Dernibes",
                        "content": "oh what the hell thats stupid"
                    },
                    {
                        "username": "n11t2h79ette",
                        "content": "Check if the 0 is in the top left corner\\n"
                    },
                    {
                        "username": "varunsinghpwn",
                        "content": "bruhh top left corner is 0,0 so edge test case is wrong cause in that it is not at 0,0 correct the question or remove that test case"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "My 1026/1026 test case : [[8,3,6],[5,0,1],[2,7,4]] is expected false or true..?\nManually and my code giving output true for this and required output is false; \nHelp me with this guys !!\n\nEdit : I got it guys , I missed the fact that we can visit any cell exactly once .\nU can chk my solution here :)\n[Mysolution](https://leetcode.com/problems/check-knight-tour-configuration/solutions/3675855/beginner-friendly-beats-100-no-recursion/)"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "Why it is giving wrong answer for the test case [[0,13,1,7,20],[3,8,19,12,15],[18,2,14,21,6],[9,4,23,16,11],[24,17,10,5,22]] ???? \\nI have implemented this logic:-\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        n=len(grid)\\n        visited=set()\\n        if(grid[0][0]!=0):\\n            return False    \\n        queue=[]\\n        queue.append((0,0))\\n        while queue:\\n            row,col=queue.pop(0)\\n            visited.add((row,col))\\n            for nrows,ncols in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\\n                rows,cols=row+nrows,col+ncols\\n                if(rows<0 or cols<0 or rows>=n or cols>=n):\\n                    continue\\n                if((rows,cols) not in visited):\\n                    visited.add((rows,cols))\\n                    queue.append((rows,cols)) \\n        if(len(visited)==n*n):\\n            return True\\n        else:\\n            return False   "
                    },
                    {
                        "username": "s1ngleton",
                        "content": "{{8,3,6},{5,7,1},{2,7,4}} -> Is this test case valid? because there is one constraint that \"All integers in grid are unique\""
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "no it isn\\'t.. I think you have written an wrong test case, the right one is [[8,3,6],[5,0,1],[2,7,4]]"
                    }
                ]
            },
            {
                "id": 1837126,
                "content": [
                    {
                        "username": "wudahu1979",
                        "content": "I don\\'t know why the answer of this test case is False.\\nI manually work through it several times, it should be True.\\n\\n[[24,11,22,17,4],\\n[21,16,5,12,9],\\n[6,23,10,3,18],\\n[15,20,1,8,13],\\n[0,7,14,19,2]]\\n\\nCan someone explain why it should be False?"
                    },
                    {
                        "username": "edwin14k",
                        "content": "I wasted hours to figure out why my code fails this sample"
                    },
                    {
                        "username": "ayush25102001",
                        "content": "It is given that the knight starts from the top-left cell and thus grid[0][0] should be 0.\\nThus check this condition as well."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "knight is at cell (0,0) and at (0,0) moves should be 0"
                    },
                    {
                        "username": "Shan_",
                        "content": " the knight starts at the top-left cell of the board. in your case, [0][0] = 24 not 0;"
                    },
                    {
                        "username": "arima6",
                        "content": "The edge case, top-left cell is NOT 0,  is very very stupid...\\n\\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This question is so annoying.\\nIts not that tuff but still ahhhhh."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1. Check if the starting cell (0,0) is empty (i.e. grid[0][0] == 0), if not, return false.\\n2. Initialize the number of cells visited i to 1 (since we\\'ve already visited the starting cell), and set the total number of cells n to grid.length * grid.length.\\n3. Define the possible moves from a cell as an array of arrays dirs, where each sub-array contains the x and y offsets of a possible move.\\n4. Initialize the current cell coordinates x and y to (0,0).\\n5. Loop from i=1 to n-1:\\na. Initialize the flag variable to true.\\nb. For each possible move dir in dirs:\\ni. Calculate the coordinates of the next cell nx and ny by adding the x and y offsets in dir to x and y, respectively.\\nii. Check if the next cell nx and ny is a valid cell (i.e. within the boundaries of the grid and not visited yet), and if its value is equal to i.\\niii. If the next cell is valid and has the expected value i, update the current cell coordinates x and y to nx and ny, set flag to false, and break out of the loop.\\nc. If no valid move is found from the current cell, return false.\\n6. If the loop completes without returning false, return true."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Ashutosh_Kaushik](/Ashutosh_Kaushik) your welcome brother"
                    },
                    {
                        "username": "Ashutosh_Kaushik",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Thanks for explaining the approach so clearly before giving the code."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\nhttps://leetcode.com/problems/check-knight-tour-configuration/solutions/3315318/easy-to-understand-clear-explanation/"
                    },
                    {
                        "username": "Dernibes",
                        "content": "For this test case #1023 can someone explain why it should be False?\\nI can easily see the valid path the knight would take.\\n\\n#    [24,  11,   22,  17,    4]\\n#    [21,  16,    5,   12,    9]\\n#    [6,    23,   10,    3,  18]\\n#    [15,  20,    1,     8,  13]\\n#    [0,     7,   14,    19,   2]"
                    },
                    {
                        "username": "ross8888",
                        "content": " it is given that knight will start from top-left corner. but here the \"0\" is at bottom left corner.\\n\\nso, there is no way to move knight, because this is not a valid configuration."
                    },
                    {
                        "username": "redocmi7",
                        "content": "It is given in the question that the knight starts at the top-left cell of the board, so the top left must contain zero for the knight to trace the next number(i.e 1). Hence, at the very start we can check if grid[0][0] is zero or not, if it\\'s not zero then simply return false."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "knight will start from cell (0,0) and at (0,0) moves should be 0"
                    },
                    {
                        "username": "Dernibes",
                        "content": "oh what the hell thats stupid"
                    },
                    {
                        "username": "n11t2h79ette",
                        "content": "Check if the 0 is in the top left corner\\n"
                    },
                    {
                        "username": "varunsinghpwn",
                        "content": "bruhh top left corner is 0,0 so edge test case is wrong cause in that it is not at 0,0 correct the question or remove that test case"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "My 1026/1026 test case : [[8,3,6],[5,0,1],[2,7,4]] is expected false or true..?\nManually and my code giving output true for this and required output is false; \nHelp me with this guys !!\n\nEdit : I got it guys , I missed the fact that we can visit any cell exactly once .\nU can chk my solution here :)\n[Mysolution](https://leetcode.com/problems/check-knight-tour-configuration/solutions/3675855/beginner-friendly-beats-100-no-recursion/)"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "Why it is giving wrong answer for the test case [[0,13,1,7,20],[3,8,19,12,15],[18,2,14,21,6],[9,4,23,16,11],[24,17,10,5,22]] ???? \\nI have implemented this logic:-\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        n=len(grid)\\n        visited=set()\\n        if(grid[0][0]!=0):\\n            return False    \\n        queue=[]\\n        queue.append((0,0))\\n        while queue:\\n            row,col=queue.pop(0)\\n            visited.add((row,col))\\n            for nrows,ncols in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\\n                rows,cols=row+nrows,col+ncols\\n                if(rows<0 or cols<0 or rows>=n or cols>=n):\\n                    continue\\n                if((rows,cols) not in visited):\\n                    visited.add((rows,cols))\\n                    queue.append((rows,cols)) \\n        if(len(visited)==n*n):\\n            return True\\n        else:\\n            return False   "
                    },
                    {
                        "username": "s1ngleton",
                        "content": "{{8,3,6},{5,7,1},{2,7,4}} -> Is this test case valid? because there is one constraint that \"All integers in grid are unique\""
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "no it isn\\'t.. I think you have written an wrong test case, the right one is [[8,3,6],[5,0,1],[2,7,4]]"
                    }
                ]
            },
            {
                "id": 1837276,
                "content": [
                    {
                        "username": "wudahu1979",
                        "content": "I don\\'t know why the answer of this test case is False.\\nI manually work through it several times, it should be True.\\n\\n[[24,11,22,17,4],\\n[21,16,5,12,9],\\n[6,23,10,3,18],\\n[15,20,1,8,13],\\n[0,7,14,19,2]]\\n\\nCan someone explain why it should be False?"
                    },
                    {
                        "username": "edwin14k",
                        "content": "I wasted hours to figure out why my code fails this sample"
                    },
                    {
                        "username": "ayush25102001",
                        "content": "It is given that the knight starts from the top-left cell and thus grid[0][0] should be 0.\\nThus check this condition as well."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "knight is at cell (0,0) and at (0,0) moves should be 0"
                    },
                    {
                        "username": "Shan_",
                        "content": " the knight starts at the top-left cell of the board. in your case, [0][0] = 24 not 0;"
                    },
                    {
                        "username": "arima6",
                        "content": "The edge case, top-left cell is NOT 0,  is very very stupid...\\n\\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This question is so annoying.\\nIts not that tuff but still ahhhhh."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1. Check if the starting cell (0,0) is empty (i.e. grid[0][0] == 0), if not, return false.\\n2. Initialize the number of cells visited i to 1 (since we\\'ve already visited the starting cell), and set the total number of cells n to grid.length * grid.length.\\n3. Define the possible moves from a cell as an array of arrays dirs, where each sub-array contains the x and y offsets of a possible move.\\n4. Initialize the current cell coordinates x and y to (0,0).\\n5. Loop from i=1 to n-1:\\na. Initialize the flag variable to true.\\nb. For each possible move dir in dirs:\\ni. Calculate the coordinates of the next cell nx and ny by adding the x and y offsets in dir to x and y, respectively.\\nii. Check if the next cell nx and ny is a valid cell (i.e. within the boundaries of the grid and not visited yet), and if its value is equal to i.\\niii. If the next cell is valid and has the expected value i, update the current cell coordinates x and y to nx and ny, set flag to false, and break out of the loop.\\nc. If no valid move is found from the current cell, return false.\\n6. If the loop completes without returning false, return true."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Ashutosh_Kaushik](/Ashutosh_Kaushik) your welcome brother"
                    },
                    {
                        "username": "Ashutosh_Kaushik",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Thanks for explaining the approach so clearly before giving the code."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\nhttps://leetcode.com/problems/check-knight-tour-configuration/solutions/3315318/easy-to-understand-clear-explanation/"
                    },
                    {
                        "username": "Dernibes",
                        "content": "For this test case #1023 can someone explain why it should be False?\\nI can easily see the valid path the knight would take.\\n\\n#    [24,  11,   22,  17,    4]\\n#    [21,  16,    5,   12,    9]\\n#    [6,    23,   10,    3,  18]\\n#    [15,  20,    1,     8,  13]\\n#    [0,     7,   14,    19,   2]"
                    },
                    {
                        "username": "ross8888",
                        "content": " it is given that knight will start from top-left corner. but here the \"0\" is at bottom left corner.\\n\\nso, there is no way to move knight, because this is not a valid configuration."
                    },
                    {
                        "username": "redocmi7",
                        "content": "It is given in the question that the knight starts at the top-left cell of the board, so the top left must contain zero for the knight to trace the next number(i.e 1). Hence, at the very start we can check if grid[0][0] is zero or not, if it\\'s not zero then simply return false."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "knight will start from cell (0,0) and at (0,0) moves should be 0"
                    },
                    {
                        "username": "Dernibes",
                        "content": "oh what the hell thats stupid"
                    },
                    {
                        "username": "n11t2h79ette",
                        "content": "Check if the 0 is in the top left corner\\n"
                    },
                    {
                        "username": "varunsinghpwn",
                        "content": "bruhh top left corner is 0,0 so edge test case is wrong cause in that it is not at 0,0 correct the question or remove that test case"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "My 1026/1026 test case : [[8,3,6],[5,0,1],[2,7,4]] is expected false or true..?\nManually and my code giving output true for this and required output is false; \nHelp me with this guys !!\n\nEdit : I got it guys , I missed the fact that we can visit any cell exactly once .\nU can chk my solution here :)\n[Mysolution](https://leetcode.com/problems/check-knight-tour-configuration/solutions/3675855/beginner-friendly-beats-100-no-recursion/)"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "Why it is giving wrong answer for the test case [[0,13,1,7,20],[3,8,19,12,15],[18,2,14,21,6],[9,4,23,16,11],[24,17,10,5,22]] ???? \\nI have implemented this logic:-\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        n=len(grid)\\n        visited=set()\\n        if(grid[0][0]!=0):\\n            return False    \\n        queue=[]\\n        queue.append((0,0))\\n        while queue:\\n            row,col=queue.pop(0)\\n            visited.add((row,col))\\n            for nrows,ncols in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\\n                rows,cols=row+nrows,col+ncols\\n                if(rows<0 or cols<0 or rows>=n or cols>=n):\\n                    continue\\n                if((rows,cols) not in visited):\\n                    visited.add((rows,cols))\\n                    queue.append((rows,cols)) \\n        if(len(visited)==n*n):\\n            return True\\n        else:\\n            return False   "
                    },
                    {
                        "username": "s1ngleton",
                        "content": "{{8,3,6},{5,7,1},{2,7,4}} -> Is this test case valid? because there is one constraint that \"All integers in grid are unique\""
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "no it isn\\'t.. I think you have written an wrong test case, the right one is [[8,3,6],[5,0,1],[2,7,4]]"
                    }
                ]
            },
            {
                "id": 1836846,
                "content": [
                    {
                        "username": "wudahu1979",
                        "content": "I don\\'t know why the answer of this test case is False.\\nI manually work through it several times, it should be True.\\n\\n[[24,11,22,17,4],\\n[21,16,5,12,9],\\n[6,23,10,3,18],\\n[15,20,1,8,13],\\n[0,7,14,19,2]]\\n\\nCan someone explain why it should be False?"
                    },
                    {
                        "username": "edwin14k",
                        "content": "I wasted hours to figure out why my code fails this sample"
                    },
                    {
                        "username": "ayush25102001",
                        "content": "It is given that the knight starts from the top-left cell and thus grid[0][0] should be 0.\\nThus check this condition as well."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "knight is at cell (0,0) and at (0,0) moves should be 0"
                    },
                    {
                        "username": "Shan_",
                        "content": " the knight starts at the top-left cell of the board. in your case, [0][0] = 24 not 0;"
                    },
                    {
                        "username": "arima6",
                        "content": "The edge case, top-left cell is NOT 0,  is very very stupid...\\n\\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This question is so annoying.\\nIts not that tuff but still ahhhhh."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1. Check if the starting cell (0,0) is empty (i.e. grid[0][0] == 0), if not, return false.\\n2. Initialize the number of cells visited i to 1 (since we\\'ve already visited the starting cell), and set the total number of cells n to grid.length * grid.length.\\n3. Define the possible moves from a cell as an array of arrays dirs, where each sub-array contains the x and y offsets of a possible move.\\n4. Initialize the current cell coordinates x and y to (0,0).\\n5. Loop from i=1 to n-1:\\na. Initialize the flag variable to true.\\nb. For each possible move dir in dirs:\\ni. Calculate the coordinates of the next cell nx and ny by adding the x and y offsets in dir to x and y, respectively.\\nii. Check if the next cell nx and ny is a valid cell (i.e. within the boundaries of the grid and not visited yet), and if its value is equal to i.\\niii. If the next cell is valid and has the expected value i, update the current cell coordinates x and y to nx and ny, set flag to false, and break out of the loop.\\nc. If no valid move is found from the current cell, return false.\\n6. If the loop completes without returning false, return true."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Ashutosh_Kaushik](/Ashutosh_Kaushik) your welcome brother"
                    },
                    {
                        "username": "Ashutosh_Kaushik",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Thanks for explaining the approach so clearly before giving the code."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\nhttps://leetcode.com/problems/check-knight-tour-configuration/solutions/3315318/easy-to-understand-clear-explanation/"
                    },
                    {
                        "username": "Dernibes",
                        "content": "For this test case #1023 can someone explain why it should be False?\\nI can easily see the valid path the knight would take.\\n\\n#    [24,  11,   22,  17,    4]\\n#    [21,  16,    5,   12,    9]\\n#    [6,    23,   10,    3,  18]\\n#    [15,  20,    1,     8,  13]\\n#    [0,     7,   14,    19,   2]"
                    },
                    {
                        "username": "ross8888",
                        "content": " it is given that knight will start from top-left corner. but here the \"0\" is at bottom left corner.\\n\\nso, there is no way to move knight, because this is not a valid configuration."
                    },
                    {
                        "username": "redocmi7",
                        "content": "It is given in the question that the knight starts at the top-left cell of the board, so the top left must contain zero for the knight to trace the next number(i.e 1). Hence, at the very start we can check if grid[0][0] is zero or not, if it\\'s not zero then simply return false."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "knight will start from cell (0,0) and at (0,0) moves should be 0"
                    },
                    {
                        "username": "Dernibes",
                        "content": "oh what the hell thats stupid"
                    },
                    {
                        "username": "n11t2h79ette",
                        "content": "Check if the 0 is in the top left corner\\n"
                    },
                    {
                        "username": "varunsinghpwn",
                        "content": "bruhh top left corner is 0,0 so edge test case is wrong cause in that it is not at 0,0 correct the question or remove that test case"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "My 1026/1026 test case : [[8,3,6],[5,0,1],[2,7,4]] is expected false or true..?\nManually and my code giving output true for this and required output is false; \nHelp me with this guys !!\n\nEdit : I got it guys , I missed the fact that we can visit any cell exactly once .\nU can chk my solution here :)\n[Mysolution](https://leetcode.com/problems/check-knight-tour-configuration/solutions/3675855/beginner-friendly-beats-100-no-recursion/)"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "Why it is giving wrong answer for the test case [[0,13,1,7,20],[3,8,19,12,15],[18,2,14,21,6],[9,4,23,16,11],[24,17,10,5,22]] ???? \\nI have implemented this logic:-\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        n=len(grid)\\n        visited=set()\\n        if(grid[0][0]!=0):\\n            return False    \\n        queue=[]\\n        queue.append((0,0))\\n        while queue:\\n            row,col=queue.pop(0)\\n            visited.add((row,col))\\n            for nrows,ncols in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\\n                rows,cols=row+nrows,col+ncols\\n                if(rows<0 or cols<0 or rows>=n or cols>=n):\\n                    continue\\n                if((rows,cols) not in visited):\\n                    visited.add((rows,cols))\\n                    queue.append((rows,cols)) \\n        if(len(visited)==n*n):\\n            return True\\n        else:\\n            return False   "
                    },
                    {
                        "username": "s1ngleton",
                        "content": "{{8,3,6},{5,7,1},{2,7,4}} -> Is this test case valid? because there is one constraint that \"All integers in grid are unique\""
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "no it isn\\'t.. I think you have written an wrong test case, the right one is [[8,3,6],[5,0,1],[2,7,4]]"
                    }
                ]
            },
            {
                "id": 1981301,
                "content": [
                    {
                        "username": "wudahu1979",
                        "content": "I don\\'t know why the answer of this test case is False.\\nI manually work through it several times, it should be True.\\n\\n[[24,11,22,17,4],\\n[21,16,5,12,9],\\n[6,23,10,3,18],\\n[15,20,1,8,13],\\n[0,7,14,19,2]]\\n\\nCan someone explain why it should be False?"
                    },
                    {
                        "username": "edwin14k",
                        "content": "I wasted hours to figure out why my code fails this sample"
                    },
                    {
                        "username": "ayush25102001",
                        "content": "It is given that the knight starts from the top-left cell and thus grid[0][0] should be 0.\\nThus check this condition as well."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "knight is at cell (0,0) and at (0,0) moves should be 0"
                    },
                    {
                        "username": "Shan_",
                        "content": " the knight starts at the top-left cell of the board. in your case, [0][0] = 24 not 0;"
                    },
                    {
                        "username": "arima6",
                        "content": "The edge case, top-left cell is NOT 0,  is very very stupid...\\n\\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This question is so annoying.\\nIts not that tuff but still ahhhhh."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1. Check if the starting cell (0,0) is empty (i.e. grid[0][0] == 0), if not, return false.\\n2. Initialize the number of cells visited i to 1 (since we\\'ve already visited the starting cell), and set the total number of cells n to grid.length * grid.length.\\n3. Define the possible moves from a cell as an array of arrays dirs, where each sub-array contains the x and y offsets of a possible move.\\n4. Initialize the current cell coordinates x and y to (0,0).\\n5. Loop from i=1 to n-1:\\na. Initialize the flag variable to true.\\nb. For each possible move dir in dirs:\\ni. Calculate the coordinates of the next cell nx and ny by adding the x and y offsets in dir to x and y, respectively.\\nii. Check if the next cell nx and ny is a valid cell (i.e. within the boundaries of the grid and not visited yet), and if its value is equal to i.\\niii. If the next cell is valid and has the expected value i, update the current cell coordinates x and y to nx and ny, set flag to false, and break out of the loop.\\nc. If no valid move is found from the current cell, return false.\\n6. If the loop completes without returning false, return true."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Ashutosh_Kaushik](/Ashutosh_Kaushik) your welcome brother"
                    },
                    {
                        "username": "Ashutosh_Kaushik",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Thanks for explaining the approach so clearly before giving the code."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\nhttps://leetcode.com/problems/check-knight-tour-configuration/solutions/3315318/easy-to-understand-clear-explanation/"
                    },
                    {
                        "username": "Dernibes",
                        "content": "For this test case #1023 can someone explain why it should be False?\\nI can easily see the valid path the knight would take.\\n\\n#    [24,  11,   22,  17,    4]\\n#    [21,  16,    5,   12,    9]\\n#    [6,    23,   10,    3,  18]\\n#    [15,  20,    1,     8,  13]\\n#    [0,     7,   14,    19,   2]"
                    },
                    {
                        "username": "ross8888",
                        "content": " it is given that knight will start from top-left corner. but here the \"0\" is at bottom left corner.\\n\\nso, there is no way to move knight, because this is not a valid configuration."
                    },
                    {
                        "username": "redocmi7",
                        "content": "It is given in the question that the knight starts at the top-left cell of the board, so the top left must contain zero for the knight to trace the next number(i.e 1). Hence, at the very start we can check if grid[0][0] is zero or not, if it\\'s not zero then simply return false."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "knight will start from cell (0,0) and at (0,0) moves should be 0"
                    },
                    {
                        "username": "Dernibes",
                        "content": "oh what the hell thats stupid"
                    },
                    {
                        "username": "n11t2h79ette",
                        "content": "Check if the 0 is in the top left corner\\n"
                    },
                    {
                        "username": "varunsinghpwn",
                        "content": "bruhh top left corner is 0,0 so edge test case is wrong cause in that it is not at 0,0 correct the question or remove that test case"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "My 1026/1026 test case : [[8,3,6],[5,0,1],[2,7,4]] is expected false or true..?\nManually and my code giving output true for this and required output is false; \nHelp me with this guys !!\n\nEdit : I got it guys , I missed the fact that we can visit any cell exactly once .\nU can chk my solution here :)\n[Mysolution](https://leetcode.com/problems/check-knight-tour-configuration/solutions/3675855/beginner-friendly-beats-100-no-recursion/)"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "Why it is giving wrong answer for the test case [[0,13,1,7,20],[3,8,19,12,15],[18,2,14,21,6],[9,4,23,16,11],[24,17,10,5,22]] ???? \\nI have implemented this logic:-\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        n=len(grid)\\n        visited=set()\\n        if(grid[0][0]!=0):\\n            return False    \\n        queue=[]\\n        queue.append((0,0))\\n        while queue:\\n            row,col=queue.pop(0)\\n            visited.add((row,col))\\n            for nrows,ncols in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\\n                rows,cols=row+nrows,col+ncols\\n                if(rows<0 or cols<0 or rows>=n or cols>=n):\\n                    continue\\n                if((rows,cols) not in visited):\\n                    visited.add((rows,cols))\\n                    queue.append((rows,cols)) \\n        if(len(visited)==n*n):\\n            return True\\n        else:\\n            return False   "
                    },
                    {
                        "username": "s1ngleton",
                        "content": "{{8,3,6},{5,7,1},{2,7,4}} -> Is this test case valid? because there is one constraint that \"All integers in grid are unique\""
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "no it isn\\'t.. I think you have written an wrong test case, the right one is [[8,3,6],[5,0,1],[2,7,4]]"
                    }
                ]
            },
            {
                "id": 1941128,
                "content": [
                    {
                        "username": "wudahu1979",
                        "content": "I don\\'t know why the answer of this test case is False.\\nI manually work through it several times, it should be True.\\n\\n[[24,11,22,17,4],\\n[21,16,5,12,9],\\n[6,23,10,3,18],\\n[15,20,1,8,13],\\n[0,7,14,19,2]]\\n\\nCan someone explain why it should be False?"
                    },
                    {
                        "username": "edwin14k",
                        "content": "I wasted hours to figure out why my code fails this sample"
                    },
                    {
                        "username": "ayush25102001",
                        "content": "It is given that the knight starts from the top-left cell and thus grid[0][0] should be 0.\\nThus check this condition as well."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "knight is at cell (0,0) and at (0,0) moves should be 0"
                    },
                    {
                        "username": "Shan_",
                        "content": " the knight starts at the top-left cell of the board. in your case, [0][0] = 24 not 0;"
                    },
                    {
                        "username": "arima6",
                        "content": "The edge case, top-left cell is NOT 0,  is very very stupid...\\n\\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This question is so annoying.\\nIts not that tuff but still ahhhhh."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1. Check if the starting cell (0,0) is empty (i.e. grid[0][0] == 0), if not, return false.\\n2. Initialize the number of cells visited i to 1 (since we\\'ve already visited the starting cell), and set the total number of cells n to grid.length * grid.length.\\n3. Define the possible moves from a cell as an array of arrays dirs, where each sub-array contains the x and y offsets of a possible move.\\n4. Initialize the current cell coordinates x and y to (0,0).\\n5. Loop from i=1 to n-1:\\na. Initialize the flag variable to true.\\nb. For each possible move dir in dirs:\\ni. Calculate the coordinates of the next cell nx and ny by adding the x and y offsets in dir to x and y, respectively.\\nii. Check if the next cell nx and ny is a valid cell (i.e. within the boundaries of the grid and not visited yet), and if its value is equal to i.\\niii. If the next cell is valid and has the expected value i, update the current cell coordinates x and y to nx and ny, set flag to false, and break out of the loop.\\nc. If no valid move is found from the current cell, return false.\\n6. If the loop completes without returning false, return true."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Ashutosh_Kaushik](/Ashutosh_Kaushik) your welcome brother"
                    },
                    {
                        "username": "Ashutosh_Kaushik",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Thanks for explaining the approach so clearly before giving the code."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\nhttps://leetcode.com/problems/check-knight-tour-configuration/solutions/3315318/easy-to-understand-clear-explanation/"
                    },
                    {
                        "username": "Dernibes",
                        "content": "For this test case #1023 can someone explain why it should be False?\\nI can easily see the valid path the knight would take.\\n\\n#    [24,  11,   22,  17,    4]\\n#    [21,  16,    5,   12,    9]\\n#    [6,    23,   10,    3,  18]\\n#    [15,  20,    1,     8,  13]\\n#    [0,     7,   14,    19,   2]"
                    },
                    {
                        "username": "ross8888",
                        "content": " it is given that knight will start from top-left corner. but here the \"0\" is at bottom left corner.\\n\\nso, there is no way to move knight, because this is not a valid configuration."
                    },
                    {
                        "username": "redocmi7",
                        "content": "It is given in the question that the knight starts at the top-left cell of the board, so the top left must contain zero for the knight to trace the next number(i.e 1). Hence, at the very start we can check if grid[0][0] is zero or not, if it\\'s not zero then simply return false."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "knight will start from cell (0,0) and at (0,0) moves should be 0"
                    },
                    {
                        "username": "Dernibes",
                        "content": "oh what the hell thats stupid"
                    },
                    {
                        "username": "n11t2h79ette",
                        "content": "Check if the 0 is in the top left corner\\n"
                    },
                    {
                        "username": "varunsinghpwn",
                        "content": "bruhh top left corner is 0,0 so edge test case is wrong cause in that it is not at 0,0 correct the question or remove that test case"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "My 1026/1026 test case : [[8,3,6],[5,0,1],[2,7,4]] is expected false or true..?\nManually and my code giving output true for this and required output is false; \nHelp me with this guys !!\n\nEdit : I got it guys , I missed the fact that we can visit any cell exactly once .\nU can chk my solution here :)\n[Mysolution](https://leetcode.com/problems/check-knight-tour-configuration/solutions/3675855/beginner-friendly-beats-100-no-recursion/)"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "Why it is giving wrong answer for the test case [[0,13,1,7,20],[3,8,19,12,15],[18,2,14,21,6],[9,4,23,16,11],[24,17,10,5,22]] ???? \\nI have implemented this logic:-\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        n=len(grid)\\n        visited=set()\\n        if(grid[0][0]!=0):\\n            return False    \\n        queue=[]\\n        queue.append((0,0))\\n        while queue:\\n            row,col=queue.pop(0)\\n            visited.add((row,col))\\n            for nrows,ncols in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\\n                rows,cols=row+nrows,col+ncols\\n                if(rows<0 or cols<0 or rows>=n or cols>=n):\\n                    continue\\n                if((rows,cols) not in visited):\\n                    visited.add((rows,cols))\\n                    queue.append((rows,cols)) \\n        if(len(visited)==n*n):\\n            return True\\n        else:\\n            return False   "
                    },
                    {
                        "username": "s1ngleton",
                        "content": "{{8,3,6},{5,7,1},{2,7,4}} -> Is this test case valid? because there is one constraint that \"All integers in grid are unique\""
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "no it isn\\'t.. I think you have written an wrong test case, the right one is [[8,3,6],[5,0,1],[2,7,4]]"
                    }
                ]
            },
            {
                "id": 1940931,
                "content": [
                    {
                        "username": "wudahu1979",
                        "content": "I don\\'t know why the answer of this test case is False.\\nI manually work through it several times, it should be True.\\n\\n[[24,11,22,17,4],\\n[21,16,5,12,9],\\n[6,23,10,3,18],\\n[15,20,1,8,13],\\n[0,7,14,19,2]]\\n\\nCan someone explain why it should be False?"
                    },
                    {
                        "username": "edwin14k",
                        "content": "I wasted hours to figure out why my code fails this sample"
                    },
                    {
                        "username": "ayush25102001",
                        "content": "It is given that the knight starts from the top-left cell and thus grid[0][0] should be 0.\\nThus check this condition as well."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "knight is at cell (0,0) and at (0,0) moves should be 0"
                    },
                    {
                        "username": "Shan_",
                        "content": " the knight starts at the top-left cell of the board. in your case, [0][0] = 24 not 0;"
                    },
                    {
                        "username": "arima6",
                        "content": "The edge case, top-left cell is NOT 0,  is very very stupid...\\n\\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This question is so annoying.\\nIts not that tuff but still ahhhhh."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1. Check if the starting cell (0,0) is empty (i.e. grid[0][0] == 0), if not, return false.\\n2. Initialize the number of cells visited i to 1 (since we\\'ve already visited the starting cell), and set the total number of cells n to grid.length * grid.length.\\n3. Define the possible moves from a cell as an array of arrays dirs, where each sub-array contains the x and y offsets of a possible move.\\n4. Initialize the current cell coordinates x and y to (0,0).\\n5. Loop from i=1 to n-1:\\na. Initialize the flag variable to true.\\nb. For each possible move dir in dirs:\\ni. Calculate the coordinates of the next cell nx and ny by adding the x and y offsets in dir to x and y, respectively.\\nii. Check if the next cell nx and ny is a valid cell (i.e. within the boundaries of the grid and not visited yet), and if its value is equal to i.\\niii. If the next cell is valid and has the expected value i, update the current cell coordinates x and y to nx and ny, set flag to false, and break out of the loop.\\nc. If no valid move is found from the current cell, return false.\\n6. If the loop completes without returning false, return true."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Ashutosh_Kaushik](/Ashutosh_Kaushik) your welcome brother"
                    },
                    {
                        "username": "Ashutosh_Kaushik",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Thanks for explaining the approach so clearly before giving the code."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\nhttps://leetcode.com/problems/check-knight-tour-configuration/solutions/3315318/easy-to-understand-clear-explanation/"
                    },
                    {
                        "username": "Dernibes",
                        "content": "For this test case #1023 can someone explain why it should be False?\\nI can easily see the valid path the knight would take.\\n\\n#    [24,  11,   22,  17,    4]\\n#    [21,  16,    5,   12,    9]\\n#    [6,    23,   10,    3,  18]\\n#    [15,  20,    1,     8,  13]\\n#    [0,     7,   14,    19,   2]"
                    },
                    {
                        "username": "ross8888",
                        "content": " it is given that knight will start from top-left corner. but here the \"0\" is at bottom left corner.\\n\\nso, there is no way to move knight, because this is not a valid configuration."
                    },
                    {
                        "username": "redocmi7",
                        "content": "It is given in the question that the knight starts at the top-left cell of the board, so the top left must contain zero for the knight to trace the next number(i.e 1). Hence, at the very start we can check if grid[0][0] is zero or not, if it\\'s not zero then simply return false."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "knight will start from cell (0,0) and at (0,0) moves should be 0"
                    },
                    {
                        "username": "Dernibes",
                        "content": "oh what the hell thats stupid"
                    },
                    {
                        "username": "n11t2h79ette",
                        "content": "Check if the 0 is in the top left corner\\n"
                    },
                    {
                        "username": "varunsinghpwn",
                        "content": "bruhh top left corner is 0,0 so edge test case is wrong cause in that it is not at 0,0 correct the question or remove that test case"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "My 1026/1026 test case : [[8,3,6],[5,0,1],[2,7,4]] is expected false or true..?\nManually and my code giving output true for this and required output is false; \nHelp me with this guys !!\n\nEdit : I got it guys , I missed the fact that we can visit any cell exactly once .\nU can chk my solution here :)\n[Mysolution](https://leetcode.com/problems/check-knight-tour-configuration/solutions/3675855/beginner-friendly-beats-100-no-recursion/)"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "Why it is giving wrong answer for the test case [[0,13,1,7,20],[3,8,19,12,15],[18,2,14,21,6],[9,4,23,16,11],[24,17,10,5,22]] ???? \\nI have implemented this logic:-\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        n=len(grid)\\n        visited=set()\\n        if(grid[0][0]!=0):\\n            return False    \\n        queue=[]\\n        queue.append((0,0))\\n        while queue:\\n            row,col=queue.pop(0)\\n            visited.add((row,col))\\n            for nrows,ncols in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\\n                rows,cols=row+nrows,col+ncols\\n                if(rows<0 or cols<0 or rows>=n or cols>=n):\\n                    continue\\n                if((rows,cols) not in visited):\\n                    visited.add((rows,cols))\\n                    queue.append((rows,cols)) \\n        if(len(visited)==n*n):\\n            return True\\n        else:\\n            return False   "
                    },
                    {
                        "username": "s1ngleton",
                        "content": "{{8,3,6},{5,7,1},{2,7,4}} -> Is this test case valid? because there is one constraint that \"All integers in grid are unique\""
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "no it isn\\'t.. I think you have written an wrong test case, the right one is [[8,3,6],[5,0,1],[2,7,4]]"
                    }
                ]
            },
            {
                "id": 1889629,
                "content": [
                    {
                        "username": "wudahu1979",
                        "content": "I don\\'t know why the answer of this test case is False.\\nI manually work through it several times, it should be True.\\n\\n[[24,11,22,17,4],\\n[21,16,5,12,9],\\n[6,23,10,3,18],\\n[15,20,1,8,13],\\n[0,7,14,19,2]]\\n\\nCan someone explain why it should be False?"
                    },
                    {
                        "username": "edwin14k",
                        "content": "I wasted hours to figure out why my code fails this sample"
                    },
                    {
                        "username": "ayush25102001",
                        "content": "It is given that the knight starts from the top-left cell and thus grid[0][0] should be 0.\\nThus check this condition as well."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "knight is at cell (0,0) and at (0,0) moves should be 0"
                    },
                    {
                        "username": "Shan_",
                        "content": " the knight starts at the top-left cell of the board. in your case, [0][0] = 24 not 0;"
                    },
                    {
                        "username": "arima6",
                        "content": "The edge case, top-left cell is NOT 0,  is very very stupid...\\n\\n"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This question is so annoying.\\nIts not that tuff but still ahhhhh."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\\n\\n1. Check if the starting cell (0,0) is empty (i.e. grid[0][0] == 0), if not, return false.\\n2. Initialize the number of cells visited i to 1 (since we\\'ve already visited the starting cell), and set the total number of cells n to grid.length * grid.length.\\n3. Define the possible moves from a cell as an array of arrays dirs, where each sub-array contains the x and y offsets of a possible move.\\n4. Initialize the current cell coordinates x and y to (0,0).\\n5. Loop from i=1 to n-1:\\na. Initialize the flag variable to true.\\nb. For each possible move dir in dirs:\\ni. Calculate the coordinates of the next cell nx and ny by adding the x and y offsets in dir to x and y, respectively.\\nii. Check if the next cell nx and ny is a valid cell (i.e. within the boundaries of the grid and not visited yet), and if its value is equal to i.\\niii. If the next cell is valid and has the expected value i, update the current cell coordinates x and y to nx and ny, set flag to false, and break out of the loop.\\nc. If no valid move is found from the current cell, return false.\\n6. If the loop completes without returning false, return true."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Ashutosh_Kaushik](/Ashutosh_Kaushik) your welcome brother"
                    },
                    {
                        "username": "Ashutosh_Kaushik",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) Thanks for explaining the approach so clearly before giving the code."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link:-\\nhttps://leetcode.com/problems/check-knight-tour-configuration/solutions/3315318/easy-to-understand-clear-explanation/"
                    },
                    {
                        "username": "Dernibes",
                        "content": "For this test case #1023 can someone explain why it should be False?\\nI can easily see the valid path the knight would take.\\n\\n#    [24,  11,   22,  17,    4]\\n#    [21,  16,    5,   12,    9]\\n#    [6,    23,   10,    3,  18]\\n#    [15,  20,    1,     8,  13]\\n#    [0,     7,   14,    19,   2]"
                    },
                    {
                        "username": "ross8888",
                        "content": " it is given that knight will start from top-left corner. but here the \"0\" is at bottom left corner.\\n\\nso, there is no way to move knight, because this is not a valid configuration."
                    },
                    {
                        "username": "redocmi7",
                        "content": "It is given in the question that the knight starts at the top-left cell of the board, so the top left must contain zero for the knight to trace the next number(i.e 1). Hence, at the very start we can check if grid[0][0] is zero or not, if it\\'s not zero then simply return false."
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "knight will start from cell (0,0) and at (0,0) moves should be 0"
                    },
                    {
                        "username": "Dernibes",
                        "content": "oh what the hell thats stupid"
                    },
                    {
                        "username": "n11t2h79ette",
                        "content": "Check if the 0 is in the top left corner\\n"
                    },
                    {
                        "username": "varunsinghpwn",
                        "content": "bruhh top left corner is 0,0 so edge test case is wrong cause in that it is not at 0,0 correct the question or remove that test case"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "My 1026/1026 test case : [[8,3,6],[5,0,1],[2,7,4]] is expected false or true..?\nManually and my code giving output true for this and required output is false; \nHelp me with this guys !!\n\nEdit : I got it guys , I missed the fact that we can visit any cell exactly once .\nU can chk my solution here :)\n[Mysolution](https://leetcode.com/problems/check-knight-tour-configuration/solutions/3675855/beginner-friendly-beats-100-no-recursion/)"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "Why it is giving wrong answer for the test case [[0,13,1,7,20],[3,8,19,12,15],[18,2,14,21,6],[9,4,23,16,11],[24,17,10,5,22]] ???? \\nI have implemented this logic:-\\nclass Solution:\\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\\n        n=len(grid)\\n        visited=set()\\n        if(grid[0][0]!=0):\\n            return False    \\n        queue=[]\\n        queue.append((0,0))\\n        while queue:\\n            row,col=queue.pop(0)\\n            visited.add((row,col))\\n            for nrows,ncols in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\\n                rows,cols=row+nrows,col+ncols\\n                if(rows<0 or cols<0 or rows>=n or cols>=n):\\n                    continue\\n                if((rows,cols) not in visited):\\n                    visited.add((rows,cols))\\n                    queue.append((rows,cols)) \\n        if(len(visited)==n*n):\\n            return True\\n        else:\\n            return False   "
                    },
                    {
                        "username": "s1ngleton",
                        "content": "{{8,3,6},{5,7,1},{2,7,4}} -> Is this test case valid? because there is one constraint that \"All integers in grid are unique\""
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "no it isn\\'t.. I think you have written an wrong test case, the right one is [[8,3,6],[5,0,1],[2,7,4]]"
                    }
                ]
            }
        ]
    }
]