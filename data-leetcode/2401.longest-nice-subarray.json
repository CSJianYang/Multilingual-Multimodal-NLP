[
    {
        "title": "Longest Nice Subarray",
        "question_content": "You are given an array nums consisting of positive integers.\nWe call a subarray of nums nice if the bitwise AND of every pair of elements that are in different positions in the subarray is equal to 0.\nReturn the length of the longest nice subarray.\nA subarray is a contiguous part of an array.\nNote that subarrays of length 1 are always considered nice.\n&nbsp;\nExample 1:\n\nInput: nums = [1,3,8,48,10]\nOutput: 3\nExplanation: The longest nice subarray is [3,8,48]. This subarray satisfies the conditions:\n- 3 AND 8 = 0.\n- 3 AND 48 = 0.\n- 8 AND 48 = 0.\nIt can be proven that no longer nice subarray can be obtained, so we return 3.\nExample 2:\n\nInput: nums = [3,1,5,11,13]\nOutput: 1\nExplanation: The length of the longest nice subarray is 1. Any subarray of length 1 can be chosen.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 2527272,
                "title": "sliding-window",
                "content": "\\n**Intuition:** each element in the nice array has unique bits.\\n    \\nWe use the sliding window approach, tracking `used` bits. We use OR to combine bits.\\n    \\nIf the next number has a conflicting bit (`used & nums[i] != 0`), we shrink the window until there are no conflicts. We use XOR to remove bits as the window shrinks.\\n   \\n**Java**\\n```java\\npublic int longestNiceSubarray(int[] nums) {\\n    int used = 0, j = 0, res = 0;\\n    for (int i = 0; i < nums.length; ++i) {\\n        while ((used & nums[i]) != 0)\\n            used ^= nums[j++];\\n        used |= nums[i];\\n        res = Math.max(res, i - j + 1);\\n    }\\n    return res;    \\n}\\n```\\n**C++**\\n```cpp\\nint longestNiceSubarray(vector<int>& nums) {\\n    int used = 0, j = 0, res = 0;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        while ((used & nums[i]) != 0)\\n            used ^= nums[j++];\\n        used |= nums[i];\\n        res = max(res, i - j + 1);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int longestNiceSubarray(int[] nums) {\\n    int used = 0, j = 0, res = 0;\\n    for (int i = 0; i < nums.length; ++i) {\\n        while ((used & nums[i]) != 0)\\n            used ^= nums[j++];\\n        used |= nums[i];\\n        res = Math.max(res, i - j + 1);\\n    }\\n    return res;    \\n}\\n```\n```cpp\\nint longestNiceSubarray(vector<int>& nums) {\\n    int used = 0, j = 0, res = 0;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        while ((used & nums[i]) != 0)\\n            used ^= nums[j++];\\n        used |= nums[i];\\n        res = max(res, i - j + 1);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527496,
                "title": "java-c-python-sliding-window",
                "content": "# **Explanation**\\nSliding window, `AND` is the AND result in the window.\\nLet\\'s slide a subarray window and keep it nice.\\n\\nIf it\\'s nice to add a new element `a` to the window,\\n`AND & a` should be 0,\\nand then we update `AND |= A[j]`\\n\\nOtherwice we move the head out of the window by doing `AND ^= A[i]`\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int longestNiceSubarray(int[] A) {\\n        int AND = 0, i = 0, res = 0, n = A.length;\\n        for (int j = 0; j < n; ++j) {\\n            while ((AND & A[j]) > 0)\\n                AND ^= A[i++];\\n            AND |= A[j];\\n            res = Math.max(res, j - i + 1);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int longestNiceSubarray(vector<int>& A) {\\n        int AND = 0, i = 0, res = 0, n = A.size();\\n        for (int j = 0; j < n; ++j) {\\n            while ((AND & A[j]) > 0)\\n                AND ^= A[i++];\\n            AND |= A[j];\\n            res = max(res, j - i + 1);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def longestNiceSubarray(self, A):\\n        res = AND = i = 0\\n        for j in range(len(A)):\\n            while AND & A[j]:\\n                AND ^= A[i]\\n                i += 1\\n            AND |= A[j]\\n            res = max(res, j - i + 1)\\n        return res\\n```\\n<br>\\n\\n# More Similar Sliding Window Problems\\nHere are some similar sliding window problems.\\nAlso find more explanations and discussion.\\nGood luck and have fun.\\n\\n- 2401. [Longest Nice Subarray](https://leetcode.com/problems/longest-nice-subarray/discuss/2527496/Python-Sliding-Window)\\n- 2398. [Maximum Number of Robots Within Budget](https://leetcode.com/problems/maximum-number-of-robots-within-budget/discuss/2524838/Python-Sliding-Window-O(n))\\n- 1838. [Frequency of the Most Frequent Element](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175090/JavaC%2B%2BPython-Sliding-Window)\\n- 1493. [Longest Subarray of 1\\'s After Deleting One Element](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/discuss/708112/JavaC%2B%2BPython-Sliding-Window-at-most-one-0)\\n- 1425. [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC++Python-O(N)-Decreasing-Deque)\\n- 1358. [Number of Substrings Containing All Three Characters](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/discuss/516977/JavaC++Python-Easy-and-Concise)\\n- 1248. [Count Number of Nice Subarrays](https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\\n- 1234. [Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/)\\n- 1004. [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/JavaC%2B%2BPython-Sliding-Window)\\n-  930. [Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/)\\n-  992. [Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/523136/JavaC%2B%2BPython-Sliding-Window)\\n-  904. [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements)\\n-  862. [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque)\\n-  209. [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/433123/JavaC++Python-Sliding-Window)\\n<br>\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int longestNiceSubarray(int[] A) {\\n        int AND = 0, i = 0, res = 0, n = A.length;\\n        for (int j = 0; j < n; ++j) {\\n            while ((AND & A[j]) > 0)\\n                AND ^= A[i++];\\n            AND |= A[j];\\n            res = Math.max(res, j - i + 1);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int longestNiceSubarray(vector<int>& A) {\\n        int AND = 0, i = 0, res = 0, n = A.size();\\n        for (int j = 0; j < n; ++j) {\\n            while ((AND & A[j]) > 0)\\n                AND ^= A[i++];\\n            AND |= A[j];\\n            res = max(res, j - i + 1);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def longestNiceSubarray(self, A):\\n        res = AND = i = 0\\n        for j in range(len(A)):\\n            while AND & A[j]:\\n                AND ^= A[i]\\n                i += 1\\n            AND |= A[j]\\n            res = max(res, j - i + 1)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2527281,
                "title": "java-python-3-sliding-window-bit-manipulation-w-explanation-comments-and-analysis",
                "content": "**Q & A**\\n\\n*Q*: How to think of such approach in interview?\\n*A*: I believe the key point is how to understand and then use the constraint \"bitwise AND of every pair of elements that are in different positions in the subarray is equal to 0.\"\\n\\nThe other point is that a subarray is a **contiguous** part of an array, which reminds me of sliding window.\\n\\n**End of Q & A**\\n\\n----\\n\\n\\n**Intuition:**\\n\\nAccording to the problem description: \"bitwise AND of every pair of elements that are in different positions in the subarray is equal to 0.\", we can conclude that **the elements within the subarray have distinct set (`1`) bits.**, which implies that we can use an integer as a mask to record the set bits of elements within the sliding window.\\n\\nTherefore, we can maintain a sliding window such that the set bits of all elements in the window are distinct.\\n\\n**Algorithm**\\n\\n1. Use an integer to represent the set bits within the sliding window;  use bitwise OR operation to roll an element into window;\\n2. If there are duplicate set bits in current sliding window, their bitwise AND must be greater than `0`; use bitwise XOR to keep rolling the element at left bound out of the sliding window till bitwise AND becomes `0`;\\n3. Update the maximum window size.\\n\\n```java\\n    public int longestNiceSubarray(int[] nums) {\\n        int ans = 0, mask = 0;\\n        for (int lo = -1, hi = 0; hi < nums.length; ++hi) {\\n            while ((mask & nums[hi]) != 0) { // nums[hi] has duplicate set bits for current sliding window.\\n                mask ^= nums[++lo]; // shrink left bound of current sliding window, and remove the corresponding element.\\n            }\\n            mask |= nums[hi]; // Expand right bound and put nums[hi] into window.\\n            ans = Math.max(ans, hi - lo); // update the max window size.\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        lo, mask, ans = -1, 0, 1\\n        for hi, n in enumerate(nums):\\n            while (mask & n): # n has duplicate set bits for current sliding window.\\n                lo += 1 # shrink left bound of current sliding window.\\n                mask ^= nums[lo] # remove the corresponding element out of the window.\\n            mask |= n # Expand right bound and put n into window.\\n            ans = max(ans, hi - lo) # update the max window size.\\n        return ans\\n```\\n\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`, where `n = nums.length`.\\n\\n----\\n\\n\\nSimilar Sliding Window Problems:\\n\\n[159. Longest Substring with At Most Two Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/) (Premium)\\n[209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/description/)\\n[424. Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)\\n[904. Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/)\\n[992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/)\\n[1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/)\\n[1234. Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/)\\n[1248. Count Number of Nice Subarrays](https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419321/JavaPython-3-1-pass-Sliding-Window-O(n)-time-O(1)-space-w-brief-explanation.)\\n[1838. Frequency of the Most Frequent Element](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175081/JavaPython-3-Sort-then-slide-window)\\n[2398. Maximum Number of Robots Within Budget](https://leetcode.com/problems/maximum-number-of-robots-within-budget/)\\n[2401. Longest Nice Subarray](https://leetcode.com/problems/longest-nice-subarray/discuss/2527281/JavaPython-3-Sliding-window-w-bit-manipulation.)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int longestNiceSubarray(int[] nums) {\\n        int ans = 0, mask = 0;\\n        for (int lo = -1, hi = 0; hi < nums.length; ++hi) {\\n            while ((mask & nums[hi]) != 0) { // nums[hi] has duplicate set bits for current sliding window.\\n                mask ^= nums[++lo]; // shrink left bound of current sliding window, and remove the corresponding element.\\n            }\\n            mask |= nums[hi]; // Expand right bound and put nums[hi] into window.\\n            ans = Math.max(ans, hi - lo); // update the max window size.\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        lo, mask, ans = -1, 0, 1\\n        for hi, n in enumerate(nums):\\n            while (mask & n): # n has duplicate set bits for current sliding window.\\n                lo += 1 # shrink left bound of current sliding window.\\n                mask ^= nums[lo] # remove the corresponding element out of the window.\\n            mask |= n # Expand right bound and put n into window.\\n            ans = max(ans, hi - lo) # update the max window size.\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2527357,
                "title": "sliding-window-o-n-fully-explained",
                "content": "Few observations:\\n\\n1. Subarray (contiguous subsequence) should hint us towards a sliding window\\n2. nums.length bounded at 1*10^5 -> maximum time complexity of O(Nlogn).\\n\\nThe brute force solution is to start at index i and let j form a subarray (double for loop).\\nWe would bitwise all the different positions and whenever one of them is not 0, we will increment i and start again.\\n\\nBut we can do better,\\ninstead of repeating ourselves we know that if A & B == 0 then we can add them to form A+B\\n\\nWhen we add the numbers, the 1 bits will be \"merged\", for example:\\n\\n3 (10 base) => 0011 (2  base)\\n8 (10 base) => 1000 (2 base)\\n3+8 => 1011\\n\\nThis way we can check the next number C only with A+B.\\nC & (A+B).\\nThis will reduce the check to constant time.\\n\\nAnd given this condition we can form a sliding window. We need to have the longest consecutive numbers that\\nwhen bit wise AND together form 0.\\nIf they dont, shrink the window until that property matches or the window is of size 1.\\n\\n```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        cur_num = nums[0]\\n        longest = 1\\n        l = 0\\n        \\n        for r in range(1, len(nums)):\\n            while l != r and nums[r] & cur_num != 0:\\n                cur_num -= nums[l]\\n                l += 1\\n            \\n            longest = max(longest, r - l + 1)\\n            cur_num += nums[r]\\n        \\n        \\n        return longest\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        cur_num = nums[0]\\n        longest = 1\\n        l = 0\\n        \\n        for r in range(1, len(nums)):\\n            while l != r and nums[r] & cur_num != 0:\\n                cur_num -= nums[l]\\n                l += 1\\n            \\n            longest = max(longest, r - l + 1)\\n            cur_num += nums[r]\\n        \\n        \\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527285,
                "title": "bit-magic-with-explanation-and-complexities",
                "content": "##### Rationale\\n* We need to do check whether we could include a number in the current window in constant time\\n* We could represent the group with bitwise OR for the all the numbers in the current window\\n\\t* Given a window, `[3, 8, 48]`, we need to know whether we could include the next number in the window in constant time. Notice that the next number must have pairwise bitwise AND zero with all the members in the group. In other words, it should have not any set bit at a position where any member of the group already has a set bit. How do we know at what positions the group members have a set bit? The group\\'s bitwise OR would have that information \\n\\t* Consider the next number to be `4`, we could easily include it in the window as all the pair wise AND would be 0. How do we know that? The group, `[3, 8, 48]` could be represented with `3 | 8 | 48` or `111011`. Any number that could be included in the group must not have a set bit at the positions where the bit is set in the group. 4 or `100` is such a number. If we AND it with group, we would get `0` as the result\\n\\t* Since 4 could be included, the group would increase to `[3, 8, 48, 4]` or `111111`. Notice how a bitwise OR with the previous group would give us the mentioned bitmask\\n* If the bitwise AND for the group and the current number is 0, we could include the number\\n* To remove an element when we shrink the window, we could do a bitwise AND for the ~(element that is to be reomved) and the group\\n\\t* Since we need to remove the contribution from the number that is to be removed from the window, we need to unset the bits that came from the to-be-removed number\\n\\t* Note that this would never to lead ambiguity. You might think that, \"Hey, what if the to-be-removed number unsets the bits that were set by another number?\". It can never happen. Notice how we only include numbers in the group when they do not have any set bits in common\\n* Rest is trivial if you\\'re familiar with sliding window\\n\\n##### Complexities\\n* Time: `O(n)`\\n* Space: `O(1)`\\n\\n\\n```python\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        maximum_length = 1\\n        n = len(nums)\\n        \\n        current_group = 0\\n        left = 0\\n        \\n        for right in range(n):\\n\\t\\t\\t# If the number at the right point is safe to include, include it in the group and update the maximum length.\\n            if nums[right] & current_group == 0:\\n                current_group |=nums[right]\\n                maximum_length = max(maximum_length, right - left + 1)\\n                continue\\n                \\n\\t\\t\\t# Shrink the window until the number at the right pointer is safe to include.\\n            while left < right and nums[right] & current_group != 0:    \\n                current_group &= (~nums[left]) \\n                left += 1\\n            \\n\\t\\t\\t# Include the number at the right pointer in the group.\\n            current_group |= nums[right]\\n                \\n        return maximum_length\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        maximum_length = 1\\n        n = len(nums)\\n        \\n        current_group = 0\\n        left = 0\\n        \\n        for right in range(n):\\n\\t\\t\\t# If the number at the right point is safe to include, include it in the group and update the maximum length.\\n            if nums[right] & current_group == 0:\\n                current_group |=nums[right]\\n                maximum_length = max(maximum_length, right - left + 1)\\n                continue\\n                \\n\\t\\t\\t# Shrink the window until the number at the right pointer is safe to include.\\n            while left < right and nums[right] & current_group != 0:    \\n                current_group &= (~nums[left]) \\n                left += 1\\n            \\n\\t\\t\\t# Include the number at the right pointer in the group.\\n            current_group |= nums[right]\\n                \\n        return maximum_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527619,
                "title": "xor-sum",
                "content": "Calculating the longest subarray whose of xor sum in equal to the sum of the numbers in the subarray.\\n1. we use the ith loop for the starting index.\\n2. jth loop for iterating from the starting index till the last index were the condition satisfies.\\n3. break out of the loop if not matches.\\n4. keep track of the max length of the subarray.\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans=0;\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            int len =1;\\n            int temp = nums[i];\\n            for(int j =i;j<nums.size()-1;j++)\\n            {\\n                if((temp xor nums[j+1])== temp+nums[j+1])\\n                {\\n                    temp+=nums[j+1];\\n                    len++;\\n                }\\n                else\\n                    break;\\n                    \\n            }\\n            ans=max(len,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans=0;\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            int len =1;\\n            int temp = nums[i];\\n            for(int j =i;j<nums.size()-1;j++)\\n            {\\n                if((temp xor nums[j+1])== temp+nums[j+1])\\n                {\\n                    temp+=nums[j+1];\\n                    len++;\\n                }\\n                else\\n                    break;\\n                    \\n            }\\n            ans=max(len,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543577,
                "title": "leetcode-the-hard-way-sliding-window-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n**C++**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        // the observation is that each number has unique bits in the nice array\\n        // finding a subarray of something -> a hint to use sliding window\\n        int l = 0, n = nums.size(), x = 0, ans = 0;\\n        // iterate right pointer\\n        for (int r = 0; r < n; r++) {\\n            // x is the current AND value of current window at this point\\n            // now we want to include nums[r] in the window\\n            // however, if we include it, the current window may become not nice (i.e. x_new != 0)\\n            // therefore, in this case, we need to remove some bits using XOR, \\n            // i.e shrinking the window from the left\\n            while ((x & nums[r]) != 0) x ^= nums[l++];\\n            // here we are good to include nums[r], we use OR to set the bits\\n            x |= nums[r];\\n            // record the max length\\n            ans = max(ans, r - l + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        // the observation is that each number has unique bits in the nice array\\n        // finding a subarray of something -> a hint to use sliding window\\n        int l = 0, n = nums.size(), x = 0, ans = 0;\\n        // iterate right pointer\\n        for (int r = 0; r < n; r++) {\\n            // x is the current AND value of current window at this point\\n            // now we want to include nums[r] in the window\\n            // however, if we include it, the current window may become not nice (i.e. x_new != 0)\\n            // therefore, in this case, we need to remove some bits using XOR, \\n            // i.e shrinking the window from the left\\n            while ((x & nums[r]) != 0) x ^= nums[l++];\\n            // here we are good to include nums[r], we use OR to set the bits\\n            x |= nums[r];\\n            // record the max length\\n            ans = max(ans, r - l + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527499,
                "title": "python-3-explanation-with-pictures-sliding-window",
                "content": "Collect the `1`s indexes of each number in binary representation, for example: 10 = (1010), the bits on indexes `1` and `3` are `1`, thus we represent `10` as `{1, 3}`. \\n\\n![image](https://assets.leetcode.com/users/images/d770ddcc-5ca9-4003-818f-15366d5c8d0b_1662264461.7018573.png)\\n\\nWe create a sliding window, let\\'s say the AND of all numbers in window is `tmp`.\\n- If the number on right boundary `right` meets `tmp & right = 0`, then its okay to add `right` in the current window. \\n- Otherwise, meaning we need to remove numbers from `left`, until `tmp & right = 0`.\\n\\nThese operations are just basic bit manipulations, take the picture below as an example.\\n\\n![image](https://assets.leetcode.com/users/images/c156bc17-4990-467d-a513-f3e6e05c54c5_1662264465.5537527.png)\\n\\n**python**\\n```\\ndef longestNiceSubarray(self, A: List[int]) -> int:\\n        ans, cur, j = 1, 1, 0\\n        tmp = A[0]\\n\\n        for i in range(1, len(A)):\\n            # If conflict by AND.\\n            while j < i and (tmp & A[i]):\\n                # Remove number from left side (i) using XOR.\\n                tmp ^= A[j]\\n                j += 1\\n                cur -= 1\\n                \\n            # Add number from right (j) using OR.\\n            tmp |= A[i]\\n            ans = max(ans, i - j + 1)\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef longestNiceSubarray(self, A: List[int]) -> int:\\n        ans, cur, j = 1, 1, 0\\n        tmp = A[0]\\n\\n        for i in range(1, len(A)):\\n            # If conflict by AND.\\n            while j < i and (tmp & A[i]):\\n                # Remove number from left side (i) using XOR.\\n                tmp ^= A[j]\\n                j += 1\\n                cur -= 1\\n                \\n            # Add number from right (j) using OR.\\n            tmp |= A[i]\\n            ans = max(ans, i - j + 1)\\n        \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2527311,
                "title": "c-sliding-window-bit",
                "content": "**What to Do ?**\\n```\\nAnd operation for every pair in subarray should be 0\\n```\\n\\n**How to Do ?**\\n```\\n1. And operation is 0 means there should not be any matching bits\\nin a window\\n```\\n\\n**CODE**\\n```\\nclass Solution {\\npublic:\\n    bool check(int a , vector<int> &vis){\\n        for(int i = 0 ; i < 32 ; i++){\\n            if(((a>>i)&1) == 1 and vis[i]==1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void fill(int a , vector<int> &vis){\\n        for(int i = 0 ; i < 32 ; i++){\\n            if(((a>>i)&1) == 1){\\n                vis[i]=1;\\n            }\\n        }\\n    }\\n    void clear(int a , vector<int> &vis){\\n        for(int i = 0 ; i < 32 ; i++){\\n            if(((a>>i)&1) == 1){\\n                vis[i]=0;\\n            }\\n        }\\n    }\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0  , j = i+1 , maxlen = 1;\\n        vector<int> vis(32,0);\\n        fill(nums[0],vis);\\n        \\n        while(i<n and j<n){\\n\\n            // checking if window is as per requirement\\n            while(!check(nums[j],vis) and i<j){\\n                clear(nums[i],vis);\\n                i++;\\n            }    \\n\\n            // filling window\\n            if(check(nums[j],vis)){\\n                fill(nums[j],vis);\\n                j++;\\n                maxlen = max(maxlen,j-i);\\n            }\\n        }\\n        \\n        return maxlen;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nAnd operation for every pair in subarray should be 0\\n```\n```\\n1. And operation is 0 means there should not be any matching bits\\nin a window\\n```\n```\\nclass Solution {\\npublic:\\n    bool check(int a , vector<int> &vis){\\n        for(int i = 0 ; i < 32 ; i++){\\n            if(((a>>i)&1) == 1 and vis[i]==1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void fill(int a , vector<int> &vis){\\n        for(int i = 0 ; i < 32 ; i++){\\n            if(((a>>i)&1) == 1){\\n                vis[i]=1;\\n            }\\n        }\\n    }\\n    void clear(int a , vector<int> &vis){\\n        for(int i = 0 ; i < 32 ; i++){\\n            if(((a>>i)&1) == 1){\\n                vis[i]=0;\\n            }\\n        }\\n    }\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0  , j = i+1 , maxlen = 1;\\n        vector<int> vis(32,0);\\n        fill(nums[0],vis);\\n        \\n        while(i<n and j<n){\\n\\n            // checking if window is as per requirement\\n            while(!check(nums[j],vis) and i<j){\\n                clear(nums[i],vis);\\n                i++;\\n            }    \\n\\n            // filling window\\n            if(check(nums[j],vis)){\\n                fill(nums[j],vis);\\n                j++;\\n                maxlen = max(maxlen,j-i);\\n            }\\n        }\\n        \\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527278,
                "title": "cpp-window-sliding-bit-mask-time-o-n-space-o-1",
                "content": "**Intuition :** If in a subarray for `bitwise and` of any pair to be `0`  , No two same bits should be on in whole subarray.\\n`Example:` `[1010 , 0100,0001]` here no two bits are on for any two element at same position. So it\\'s valid\\nLet\\'s consider `[1010 , 1100,0001]` so `1010` and `1100` share same bit as on , i.e first bit. So its invalid\\n\\n**Time complexity : O(n)\\nSpace complexity : O(1)**\\n\\n**If you have any doubt feel free to ask in comment section I\\'ll be happy to help**\\n\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        long n=v.size(),start=0,end=0,ans=0,cnt=0,s=0;\\n        while(end<n){\\n            s+=v[end];\\n            cnt = cnt | v[end];\\n            int curr = v[end++];\\n            int mask=0;\\n            while(s>cnt){\\n                s-=v[start];\\n                cnt -= v[start];\\n                if(curr & v[start]){\\n                    int toAdd = (curr & v[start]);\\n                    if(mask & toAdd){\\n                        toAdd = toAdd & (~mask);\\n                    }\\n                    cnt+=toAdd;\\n                    mask  |= toAdd;\\n                }\\n                start++;\\n            }\\n            ans=max(ans,end-start);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        long n=v.size(),start=0,end=0,ans=0,cnt=0,s=0;\\n        while(end<n){\\n            s+=v[end];\\n            cnt = cnt | v[end];\\n            int curr = v[end++];\\n            int mask=0;\\n            while(s>cnt){\\n                s-=v[start];\\n                cnt -= v[start];\\n                if(curr & v[start]){\\n                    int toAdd = (curr & v[start]);\\n                    if(mask & toAdd){\\n                        toAdd = toAdd & (~mask);\\n                    }\\n                    cnt+=toAdd;\\n                    mask  |= toAdd;\\n                }\\n                start++;\\n            }\\n            ans=max(ans,end-start);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609299,
                "title": "c-sliding-window-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int longestNiceSubarray(vector<int>& nums) {\\n        \\n        // using sliding window of variable length \\n        //we have to find the maximum window size\\n        \\n        int i=0,j=0;\\n        int num = 0;\\n        int ans = 0;\\n        \\n        //iterate through all the elements\\n        for(i=0;i<nums.size();i++){\\n            \\n            //if at any point a single position has more than 1 bit set\\n            while((num&nums[i])!=0){\\n                //unset the bits at that position until & of the two is not equal to 0 again\\n                num^=nums[j];\\n                //keep moving the previous end of the window by removing the element from the window\\n                j++;\\n            }\\n            \\n            //if there is no issue and the & of the numbers is 0\\n            //keep on setting the bits for that position in num\\n            num |= nums[i];\\n            \\n            //keep count of the maximum window size \\n            ans = max(ans, i-j+1);\\n            \\n        }\\n        \\n        //return maximum window size\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int longestNiceSubarray(vector<int>& nums) {\\n        \\n        // using sliding window of variable length \\n        //we have to find the maximum window size\\n        \\n        int i=0,j=0;\\n        int num = 0;\\n        int ans = 0;\\n        \\n        //iterate through all the elements\\n        for(i=0;i<nums.size();i++){\\n            \\n            //if at any point a single position has more than 1 bit set\\n            while((num&nums[i])!=0){\\n                //unset the bits at that position until & of the two is not equal to 0 again\\n                num^=nums[j];\\n                //keep moving the previous end of the window by removing the element from the window\\n                j++;\\n            }\\n            \\n            //if there is no issue and the & of the numbers is 0\\n            //keep on setting the bits for that position in num\\n            num |= nums[i];\\n            \\n            //keep count of the maximum window size \\n            ans = max(ans, i-j+1);\\n            \\n        }\\n        \\n        //return maximum window size\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155560,
                "title": "basic-sliding-window-bit-mask-c-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAND of each possible pair in a subarray must be 0 => BITMASK\\nVariable Length Subarray => SLINDING WINDOW + VARIABLE SIZE\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake a integer `bitmask` to store each bits of numbers in num array\\nNow 2 Points must be taken into consideration, Lets suppose\\n- \\' | \\' ( OR ) is used for adding bits of 2 integer\\n- \\' ^ \\' ( XOR ) is used for subtracting the bits \\n\\n### How does OR and XOR perform addition and subtraction ??\\n=> Take Integers \\n3 => 0011\\n4 => 0100\\n5 => 0101\\n3 => 0011 \\n##### Performing OR (ADDITION )Operation\\n   3 | 4 => 0011 | 0100 => 0111 => 7\\n   5 | 3 => 0101 | 0011 => 0111 => 7\\nmeans it generates a bitmask comprising of `\\'1\\'` at every position\\n##### Performing XOR (SUBTRACTION) Operation\\n  3 ^ 4 = 0011 ^ 0100 => 0111 => 7\\n  7 ^ 5 = 0111 ^ 0101 => 0010 = > 2\\n  2 ^ 3 => 0010 ^ 0011 = 0001 =>1\\n\\nLets take a `bitmask` and store the value of `3^4^5`\\nso `bitmask^3  === 4^5` thats how it performs subtraction.\\n\\n## Basic Sliding Window\\n=> Remaining solution is now basic Sliding window,\\n=> Take 2 pointers `start`,`end `and a bitmask\\n=> Push current element (`end`) into bitmask by using `|`\\n=> If `&` is not zero then decrease the size of window by incrementing start and subtracting the start element from the `bitmask` using `^`.\\n \\n   \\n# Complexity\\n- Time complexity:  O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = size(nums);\\n\\n        int start = 0;\\n        int end = 0;\\n        int bitmask = 0;\\n        int ans = 0;\\n\\n       while(end<n){\\n           \\n           // check the AND of bitmask of numbers till now and current number stored in nums[end]\\n           while((bitmask & nums[end])!=0){\\n               // remove the bits of start element if AND is not 0\\n            bitmask^=nums[start++];\\n               // ^ is used to remove the bits of start from bitmask()\\n                \\n           }\\n           // | is used for adding bits of each data element into bitmask\\n           bitmask |= nums[end];\\n           ans = max(ans,end-start+1);\\n           end++;\\n       }\\n   return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = size(nums);\\n\\n        int start = 0;\\n        int end = 0;\\n        int bitmask = 0;\\n        int ans = 0;\\n\\n       while(end<n){\\n           \\n           // check the AND of bitmask of numbers till now and current number stored in nums[end]\\n           while((bitmask & nums[end])!=0){\\n               // remove the bits of start element if AND is not 0\\n            bitmask^=nums[start++];\\n               // ^ is used to remove the bits of start from bitmask()\\n                \\n           }\\n           // | is used for adding bits of each data element into bitmask\\n           bitmask |= nums[end];\\n           ans = max(ans,end-start+1);\\n           end++;\\n       }\\n   return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603282,
                "title": "python3-8-lines-two-pointer-dict-w-explanation-t-m-95-43",
                "content": "```\\nclass Solution:         # Here\\'s the plan:\\n                       \\n                        #   1) Initiate two pointers (left and right) and an int variable tally\\n                        #      to keeping track of the accumulated XOR as the pointers slide.\\n                       \\n                        #   2) Slide the right ptr to the right as long as tally&num is zero, which means that \\n                        #      [left, right] continues to be a nice subarray. Update the tally by tally^= num.\\n\\n                        #   3) If the tally&num becames non-zero, [left, right] is no longer nice. Slide the \\n\\t\\t\\t\\t\\t\\t#      left ptr to the right until [left, right] becomes nice again (or we run out of \\n                        #      array). For each slide, undo the effect of each num on tally by tally^= num.\\n\\n                        #   4) Update the max as necessary and return max when nums is exhausted.\\n                      \\n                        #   As an example, let nums = [1,4,8,48,10]:\\n                        #  \\n                        #               nums |   tally   | tally&num  | ans\\n                        #               \\u2014\\u2014\\u2014\\u2014\\u2014|\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014|\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014|\\u2014\\u2014\\u2014\\u2014\\u2014\\n                        #                1         0         0&1  = 0   [1]     \\n                        #                4      0^1  =  1    1&4  = 0   [1,4]\\n                        #                8      1^4  =  5    5&8  = 0   [1,4,8]\\n                        #               48      1^8  =  9    9&48 = 0   [1,4,8,48] --> answer is 4\\n                        #               10      9^48 = 57   57&10 = 8   [10]\\n\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        left, ans, tally = 0, 0, 0          # <-- 1)\\n        \\n        for right in range(len(nums)):      # <-- 2)\\n            \\n            while tally&nums[right]:        # <-- 3)\\n                tally^= nums[left]\\n                left+= 1\\n            \\n            ans = max(ans, right-left+1)    # <-- 4)\\n            tally^= nums[right]\\n\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:         # Here\\'s the plan:\\n                       \\n                        #   1) Initiate two pointers (left and right) and an int variable tally\\n                        #      to keeping track of the accumulated XOR as the pointers slide.\\n                       \\n                        #   2) Slide the right ptr to the right as long as tally&num is zero, which means that \\n                        #      [left, right] continues to be a nice subarray. Update the tally by tally^= num.\\n\\n                        #   3) If the tally&num becames non-zero, [left, right] is no longer nice. Slide the \\n\\t\\t\\t\\t\\t\\t#      left ptr to the right until [left, right] becomes nice again (or we run out of \\n                        #      array). For each slide, undo the effect of each num on tally by tally^= num.\\n\\n                        #   4) Update the max as necessary and return max when nums is exhausted.\\n                      \\n                        #   As an example, let nums = [1,4,8,48,10]:\\n                        #  \\n                        #               nums |   tally   | tally&num  | ans\\n                        #               \\u2014\\u2014\\u2014\\u2014\\u2014|\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014|\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014|\\u2014\\u2014\\u2014\\u2014\\u2014\\n                        #                1         0         0&1  = 0   [1]     \\n                        #                4      0^1  =  1    1&4  = 0   [1,4]\\n                        #                8      1^4  =  5    5&8  = 0   [1,4,8]\\n                        #               48      1^8  =  9    9&48 = 0   [1,4,8,48] --> answer is 4\\n                        #               10      9^48 = 57   57&10 = 8   [10]\\n\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        left, ans, tally = 0, 0, 0          # <-- 1)\\n        \\n        for right in range(len(nums)):      # <-- 2)\\n            \\n            while tally&nums[right]:        # <-- 3)\\n                tally^= nums[left]\\n                left+= 1\\n            \\n            ans = max(ans, right-left+1)    # <-- 4)\\n            tally^= nums[right]\\n\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2527514,
                "title": "c-solution-using-window-sliding",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int n;\\n    bool check(vector<long long>&bit)\\n    {\\n        // any number more than two bit are same or not pair wise\\n        for(int i=0;i<32;i++)\\n        {\\n            if(bit[i]>=2)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int longestNiceSubarray(vector<int> &nums)\\n    {\\n        n = nums.size();\\n        int j = 0;\\n        int ans = 1;\\n        vector < long long > bit(32, 0);\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int x = 0; x < 32; x++)\\n            {\\n                if (nums[i] &(1 << x))\\n                {\\n                    bit[x]++;\\n                }\\n            }\\n            while (j <= i && check(bit) == false)\\n            {\\n                for (int x = 0; x < 32; x++)\\n                {\\n                    if (nums[j] &(1 << x))\\n                    {\\n                        bit[x]--;\\n                    }\\n                }\\n                j++;\\n            }\\n            ans = max(ans, i - j + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int n;\\n    bool check(vector<long long>&bit)\\n    {\\n        // any number more than two bit are same or not pair wise\\n        for(int i=0;i<32;i++)\\n        {\\n            if(bit[i]>=2)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int longestNiceSubarray(vector<int> &nums)\\n    {\\n        n = nums.size();\\n        int j = 0;\\n        int ans = 1;\\n        vector < long long > bit(32, 0);\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int x = 0; x < 32; x++)\\n            {\\n                if (nums[i] &(1 << x))\\n                {\\n                    bit[x]++;\\n                }\\n            }\\n            while (j <= i && check(bit) == false)\\n            {\\n                for (int x = 0; x < 32; x++)\\n                {\\n                    if (nums[j] &(1 << x))\\n                    {\\n                        bit[x]--;\\n                    }\\n                }\\n                j++;\\n            }\\n            ans = max(ans, i - j + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848052,
                "title": "c-o-n-32-sliding-window",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& a) {\\n        int n=a.size();\\n        vector<int> bitCount(32,0);\\n        \\n        int i=0,j=0;\\n        \\n        int ans=0;\\n        \\n        while(j<n){\\n            bool foundRepeatingBits=false;\\n            \\n            for(int bit=0;bit<32;bit++){\\n                if(a[j] & (1<<bit)) bitCount[bit]++;\\n                if(bitCount[bit]>1) foundRepeatingBits=true;\\n            }\\n            \\n            while(i<j && foundRepeatingBits){\\n                foundRepeatingBits=false;\\n                for(int bit=0;bit<32;bit++){\\n                    if(a[i] & (1<<bit)) bitCount[bit]--;\\n                    if(bitCount[bit]>1) foundRepeatingBits=true;\\n                }\\n                i++;\\n            }\\n\\t\\t\\t\\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Do upvote if it helps:)**",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& a) {\\n        int n=a.size();\\n        vector<int> bitCount(32,0);\\n        \\n        int i=0,j=0;\\n        \\n        int ans=0;\\n        \\n        while(j<n){\\n            bool foundRepeatingBits=false;\\n            \\n            for(int bit=0;bit<32;bit++){\\n                if(a[j] & (1<<bit)) bitCount[bit]++;\\n                if(bitCount[bit]>1) foundRepeatingBits=true;\\n            }\\n            \\n            while(i<j && foundRepeatingBits){\\n                foundRepeatingBits=false;\\n                for(int bit=0;bit<32;bit++){\\n                    if(a[i] & (1<<bit)) bitCount[bit]--;\\n                    if(bitCount[bit]>1) foundRepeatingBits=true;\\n                }\\n                i++;\\n            }\\n\\t\\t\\t\\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2743639,
                "title": "c",
                "content": "class Solution {\\npublic:\\n    bool check(int a , vector<int> &vis){\\n        for(int i = 0 ; i < 32 ; i++){\\n            if(((a>>i)&1) == 1 and vis[i]==1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void fill(int a , vector<int> &vis){\\n        for(int i = 0 ; i < 32 ; i++){\\n            if(((a>>i)&1) == 1){\\n                vis[i]=1;\\n            }\\n        }\\n    }\\n    void clear(int a , vector<int> &vis){\\n        for(int i = 0 ; i < 32 ; i++){\\n            if(((a>>i)&1) == 1){\\n                vis[i]=0;\\n            }\\n        }\\n    }\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0  , j = i+1 , maxlen = 1;\\n        vector<int> vis(32,0);\\n        fill(nums[0],vis);\\n        \\n        while(i<n and j<n){\\n\\n            // checking if window is as per requirement\\n            while(!check(nums[j],vis) and i<j){\\n                clear(nums[i],vis);\\n                i++;\\n            }    \\n\\n            // filling window\\n            if(check(nums[j],vis)){\\n                fill(nums[j],vis);\\n                j++;\\n                maxlen = max(maxlen,j-i);\\n            }\\n        }\\n        \\n        return maxlen;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool check(int a , vector<int> &vis){\\n        for(int i = 0 ; i < 32 ; i++){\\n            if(((a>>i)&1) == 1 and vis[i]==1){\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2567454,
                "title": "c-o-n-32-easy-brute-force-solution",
                "content": "* **Assertion:** Answer could be at max 32.\\n\\n\\n*  **Proof:** Because there are total of 32 bits in integer. If every number has only one bit set, then there could be at max 32 numbers such that they are at distinct positions, 33rd number must share a position with some previous number(**Pigeonhole Principal**).\\n\\n* For example- > `[0001 ,1000, 0100, 0010]` , the AND operation of every combination of elements will be zero because none element share a bit which is set in both the elements. \\n\\n* **TIME-> O(32*N) SPACE->O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& arr) {\\n        \\n        int ans = 1 ;\\n        for(int i = 0 ; i< arr.size() ; i++){\\n            long mask = 0 ;\\n            for(int j = i; j < min((int)arr.size(),i + 32) ; j++){\\n                if(mask&arr[j]) break;\\n                ans = max(ans,j-i+1);\\n                mask |= arr[j];\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& arr) {\\n        \\n        int ans = 1 ;\\n        for(int i = 0 ; i< arr.size() ; i++){\\n            long mask = 0 ;\\n            for(int j = i; j < min((int)arr.size(),i + 32) ; j++){\\n                if(mask&arr[j]) break;\\n                ans = max(ans,j-i+1);\\n                mask |= arr[j];\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527585,
                "title": "easy-java-solution-map-bit-manipulation",
                "content": "# Longest Nice Subarray\\n**Easy Java Solution**\\n\\n**Approach:**\\n1.) We call the helper function to check upto what length subarray is nice starting from provided index\\n2.) We keep track of set bit in hashmap\\nfor eg suppose array 3,8,5,6,7\\n    so when we call function for index 0\\n        it will in first pass store that for number 3, bit 0 and 1 are set\\n        for number 8 bit 2 is set\\n        so now in hashmap bit 0,1,2 are set \\n        then for number 5 again bit 0 is set, so we terminate and return ans\\n3.) In such a way we call functon array.length -1 times and store the maximum of all in res and return answer\\n\\n```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int res=1;\\n        for(int i=0;i<nums.length-1;i++){\\n            //Calling function nums.length-1 times\\n            int ans=helper(nums,i);\\n            res=Math.max(res,ans);\\n        }\\n        return res;\\n    }\\n    public int helper(int[] nums,int a){\\n        int ans=0;\\n        //Creating a hashmap\\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\\n        //Running the forloop from a top length of array\\n        for(int i=a;i<nums.length;i++){\\n            //Accesing the number at index i\\n            int num=nums[i];\\n            //To keep track of the current bit number\\n            int no=0;\\n            ans++;\\n            //Running while loop till number >0\\n            while(num>0){\\n                //Doing bitwise AND of num and 1\\n                int bit=num&1;\\n                //If bit is 1, then in hashmap I will store that the the bit bumber no is set\\n                if(bit==1){\\n                    //If already bit number no is set then we cannot move further as this violates the conditiom\\n                    if(map.containsKey(no)){\\n                        return ans-1;\\n                    }\\n                    else{\\n                        map.put(no,i);\\n                    }\\n                }\\n                //Doing right shift\\n                num=num>>1;\\n                //Increamenting bit number\\n                no++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int res=1;\\n        for(int i=0;i<nums.length-1;i++){\\n            //Calling function nums.length-1 times\\n            int ans=helper(nums,i);\\n            res=Math.max(res,ans);\\n        }\\n        return res;\\n    }\\n    public int helper(int[] nums,int a){\\n        int ans=0;\\n        //Creating a hashmap\\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\\n        //Running the forloop from a top length of array\\n        for(int i=a;i<nums.length;i++){\\n            //Accesing the number at index i\\n            int num=nums[i];\\n            //To keep track of the current bit number\\n            int no=0;\\n            ans++;\\n            //Running while loop till number >0\\n            while(num>0){\\n                //Doing bitwise AND of num and 1\\n                int bit=num&1;\\n                //If bit is 1, then in hashmap I will store that the the bit bumber no is set\\n                if(bit==1){\\n                    //If already bit number no is set then we cannot move further as this violates the conditiom\\n                    if(map.containsKey(no)){\\n                        return ans-1;\\n                    }\\n                    else{\\n                        map.put(no,i);\\n                    }\\n                }\\n                //Doing right shift\\n                num=num>>1;\\n                //Increamenting bit number\\n                no++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527296,
                "title": "sliding-window-another-10-leetcode-problems",
                "content": "**Approach**\\n- We will maintain a window starting from i position and ending at j position.\\n- If the window is valid, we will check if it is of maximum length.\\n- If window is valid, we will increase the left boundary of window by one and update our answer accordingly.\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int N = nums.size();\\n        int res = nums[0], ans = 0, i = 0;\\n\\n        vector<int> bits(32, 0);\\n\\n        for(int j = 0; j < N; j++) {\\n\\n            for(int k = 31; k >= 0; k--) {\\n                if(nums[j] & (1 << k)) {\\n                    bits[k] += 1;\\n                }\\n            }\\n\\n            int maxBit = *max_element(bits.begin(), bits.end());\\n\\n            // Increase the window size from left direction.\\n            while(maxBit > 1 && i < j) {\\n                // Remove all the bits of ith element.\\n                for(int k = 31; k >= 0; k--) {\\n                    if(nums[i] & (1 << k)) {\\n                        bits[k] -= 1;\\n                    }\\n                }\\n                i++;\\n                maxBit = *max_element(bits.begin(), bits.end());\\n            }\\n\\n\\t// Update the answer with window size which is valid\\n            ans = max(ans, j - i + 1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n**Template**\\n```cpp\\nint i = 0, j = 0, ans = 0;\\nfor (; j < N; ++j) {\\n    // CODE: use A[j] to update state which might make the window invalid\\n    for (; invalid(); ++i) { // when invalid, keep shrinking the left edge until it\\'s valid again\\n        // CODE: update state using A[i]\\n    }\\n    ans = max(ans, j - i + 1); // the window [i, j] is the maximum window we\\'ve found thus far\\n}\\nreturn ans;\\n\\n```\\n\\n**Top Sliding Window Problems on LeetCode (Same Template)**\\n\\n1. [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)\\n2. [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)\\n3. [Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)\\n4. [Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/)\\n5. [Maximum Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/)\\n6. [Frequency of Most Frequent Elements](https://leetcode.com/problems/frequency-of-the-most-frequent-element/)\\n7. [Number of Smooth Descent Periods of a Stock](https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/)\\n8. [Count Subarray With Score Less Than K](https://leetcode.com/problems/count-subarrays-with-score-less-than-k/)\\n9.  [Number of Zero Filled Subarrays](https://leetcode.com/problems/number-of-zero-filled-subarrays/)\\n10. [Maximize The Confusion of Exam](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/)\\n\\nSolutions - Sliding Window\\n\\n**1. Longest Substring Without Repeating Characters**\\n```cpp\\nclass Solution {\\npublic:\\n    int lengthOfLongestSubstring(string s) {\\n        int N = s.length();\\n        int ans = 0, i = 0;\\n        \\n        unordered_map<char, int> M;\\n        \\n        for(int j = 0; j < N; j++) {\\n            \\n            M[s[j]]++;\\n            \\n            // Window size increases from left side.\\n            while(M[s[j]] > 1) {\\n                M[s[i++]]--;\\n            }\\n            \\n            ans = max(ans, j - i + 1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n\\n**2. Minimum Size Subarray Sum**\\n```cpp\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        \\n        int N = nums.size();\\n        int ans = INT_MAX;\\n        int i = 0, sum = 0;\\n        \\n        for(int j = 0; j < N; j++) {\\n            sum += nums[j];\\n            \\n            // Decrease the window size.\\n            while(sum >= target) {\\n                ans = min(ans, j - i + 1);\\n                \\n                sum -= nums[i++];\\n            }\\n        }\\n        \\n        return ans == INT_MAX ? 0 : ans;\\n    }\\n};\\n\\n```\\n**Comment Below If you want the solutions of other 8 problems with same template.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int N = nums.size();\\n        int res = nums[0], ans = 0, i = 0;\\n\\n        vector<int> bits(32, 0);\\n\\n        for(int j = 0; j < N; j++) {\\n\\n            for(int k = 31; k >= 0; k--) {\\n                if(nums[j] & (1 << k)) {\\n                    bits[k] += 1;\\n                }\\n            }\\n\\n            int maxBit = *max_element(bits.begin(), bits.end());\\n\\n            // Increase the window size from left direction.\\n            while(maxBit > 1 && i < j) {\\n                // Remove all the bits of ith element.\\n                for(int k = 31; k >= 0; k--) {\\n                    if(nums[i] & (1 << k)) {\\n                        bits[k] -= 1;\\n                    }\\n                }\\n                i++;\\n                maxBit = *max_element(bits.begin(), bits.end());\\n            }\\n\\n\\t// Update the answer with window size which is valid\\n            ans = max(ans, j - i + 1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```\n```cpp\\nint i = 0, j = 0, ans = 0;\\nfor (; j < N; ++j) {\\n    // CODE: use A[j] to update state which might make the window invalid\\n    for (; invalid(); ++i) { // when invalid, keep shrinking the left edge until it\\'s valid again\\n        // CODE: update state using A[i]\\n    }\\n    ans = max(ans, j - i + 1); // the window [i, j] is the maximum window we\\'ve found thus far\\n}\\nreturn ans;\\n\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int lengthOfLongestSubstring(string s) {\\n        int N = s.length();\\n        int ans = 0, i = 0;\\n        \\n        unordered_map<char, int> M;\\n        \\n        for(int j = 0; j < N; j++) {\\n            \\n            M[s[j]]++;\\n            \\n            // Window size increases from left side.\\n            while(M[s[j]] > 1) {\\n                M[s[i++]]--;\\n            }\\n            \\n            ans = max(ans, j - i + 1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        \\n        int N = nums.size();\\n        int ans = INT_MAX;\\n        int i = 0, sum = 0;\\n        \\n        for(int j = 0; j < N; j++) {\\n            sum += nums[j];\\n            \\n            // Decrease the window size.\\n            while(sum >= target) {\\n                ans = min(ans, j - i + 1);\\n                \\n                sum -= nums[i++];\\n            }\\n        }\\n        \\n        return ans == INT_MAX ? 0 : ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762329,
                "title": "c-faster-than-97-12-with-constant-space",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        \\n        int len = 1 ;\\n        int i = 0;\\n        \\n        while(i<nums.size())\\n        {\\n            int j = i + 1 ;\\n            \\n            while( j < nums.size() )\\n            {\\n                int k = i;\\n\\n                while(k<j && ( (nums[j] & nums[k]) == 0) )\\n                k++;\\n\\n                if(k == j)\\n                j++;\\n                else\\n                {\\n                    \\n                    len = max(len , j-i);\\n                    j = k;\\n                    break;\\n                }\\n            }\\n            \\n            len = max(len , j-i);\\n            if(i == j)\\n            i++;\\n            else\\n            i = j;\\n        }\\n\\n        return len;\\n    }\\n};\\n\\n\\n// [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        \\n        int len = 1 ;\\n        int i = 0;\\n        \\n        while(i<nums.size())\\n        {\\n            int j = i + 1 ;\\n            \\n            while( j < nums.size() )\\n            {\\n                int k = i;\\n\\n                while(k<j && ( (nums[j] & nums[k]) == 0) )\\n                k++;\\n\\n                if(k == j)\\n                j++;\\n                else\\n                {\\n                    \\n                    len = max(len , j-i);\\n                    j = k;\\n                    break;\\n                }\\n            }\\n            \\n            len = max(len , j-i);\\n            if(i == j)\\n            i++;\\n            else\\n            i = j;\\n        }\\n\\n        return len;\\n    }\\n};\\n\\n\\n// [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532613,
                "title": "c-sliding-window-using-bit-manipulation",
                "content": "# Introduction\\n- It is a really nice problem using the concept of sliding-window and bit-manipulation. \\n- Normally, we use two pointer and a DS in sliding window.  The DS can be anything. For example, string, set, hash-map and other things. \\n- But here we use a number as the window.  On the `end` we set the bits in the window and if the condition is not satisfied we unset the bits on the `start`.\\n- Refer the diagram below for detailed explanation and working.\\n# Code\\n```cpp\\nclass SolutionRunningSum {\\npublic:\\n    int longestNiceSubarray(vector<int> &nums) {\\n        if (nums.size() == 1) {\\n            return nums.size();\\n        }\\n\\t\\t// We have to take a bigger data type, as sum can give integer overflow in this solution\\n        long long int currSum = nums[0];\\n        int start = 0;\\n        int maxLen = 0;\\n        for (int end = 1; end < nums.size(); end++) {\\n            while (end != start && ((currSum & nums[end]) != 0)) {\\n                currSum -= nums[start];\\n                start++;\\n            }\\n            maxLen = max(maxLen, end - start + 1);\\n            currSum += nums[end];\\n        }\\n        return maxLen;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int> &nums) {\\n        if (nums.size() == 1) {\\n            return nums.size();\\n        }\\n        int window = nums[0];\\n        int start = 0;\\n        int maxLen = 0;\\n        for (int end = 1; end < nums.size(); end++) {\\n            while (end != start && ((window & nums[end]) != 0)) {\\n                window ^= nums[start];\\n                start++;\\n            }\\n            window |= nums[end];\\n            maxLen = max(maxLen, end - start + 1);\\n        }\\n        return maxLen;\\n    }\\n};\\n```\\n# Explanation\\n![image](https://assets.leetcode.com/users/images/fde5c2f3-370b-4fee-a110-6c9a7f048cd6_1662350917.9630933.png)\\n",
                "solutionTags": [
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```cpp\\nclass SolutionRunningSum {\\npublic:\\n    int longestNiceSubarray(vector<int> &nums) {\\n        if (nums.size() == 1) {\\n            return nums.size();\\n        }\\n\\t\\t// We have to take a bigger data type, as sum can give integer overflow in this solution\\n        long long int currSum = nums[0];\\n        int start = 0;\\n        int maxLen = 0;\\n        for (int end = 1; end < nums.size(); end++) {\\n            while (end != start && ((currSum & nums[end]) != 0)) {\\n                currSum -= nums[start];\\n                start++;\\n            }\\n            maxLen = max(maxLen, end - start + 1);\\n            currSum += nums[end];\\n        }\\n        return maxLen;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int> &nums) {\\n        if (nums.size() == 1) {\\n            return nums.size();\\n        }\\n        int window = nums[0];\\n        int start = 0;\\n        int maxLen = 0;\\n        for (int end = 1; end < nums.size(); end++) {\\n            while (end != start && ((window & nums[end]) != 0)) {\\n                window ^= nums[start];\\n                start++;\\n            }\\n            window |= nums[end];\\n            maxLen = max(maxLen, end - start + 1);\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532371,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Sliding Window && Bit Manipulation***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int left = 0;\\n        \\n        // andd will store the (or) of all the numbers of subarray\\n        \\n        int andd = 0;\\n        \\n        int maxi = INT_MIN;\\n        \\n        for(int right = 0; right < n; right++)\\n        {\\n            // remove the nos. from left side, untill andd becomes zero\\n            \\n            while(left <= right && (andd & nums[right]) != 0)\\n            {\\n                andd = (andd) ^ nums[left];\\n                \\n                left++;\\n            }\\n            \\n            // update the maxi\\n            \\n            int curr_size = (right - left + 1);\\n            \\n            maxi = max(maxi, curr_size);\\n            \\n            // include the curr no. in subarray\\n            \\n            andd = (andd | nums[right]);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int left = 0;\\n        \\n        // andd will store the (or) of all the numbers of subarray\\n        \\n        int andd = 0;\\n        \\n        int maxi = INT_MIN;\\n        \\n        for(int right = 0; right < n; right++)\\n        {\\n            // remove the nos. from left side, untill andd becomes zero\\n            \\n            while(left <= right && (andd & nums[right]) != 0)\\n            {\\n                andd = (andd) ^ nums[left];\\n                \\n                left++;\\n            }\\n            \\n            // update the maxi\\n            \\n            int curr_size = (right - left + 1);\\n            \\n            maxi = max(maxi, curr_size);\\n            \\n            // include the curr no. in subarray\\n            \\n            andd = (andd | nums[right]);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528134,
                "title": "sliding-window-java-linear-time-solution",
                "content": "```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {        \\n        int i,j,n=nums.length,res,max=1;\\n        for(i=j=res=0;j<n;){\\n            if((res&nums[j])>0){\\n                res=res^nums[i];\\n                i++;\\n            }else{\\n                res=res|nums[j];\\n                j++;\\n            }\\n            max=Math.max(max,j-i);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {        \\n        int i,j,n=nums.length,res,max=1;\\n        for(i=j=res=0;j<n;){\\n            if((res&nums[j])>0){\\n                res=res^nums[i];\\n                i++;\\n            }else{\\n                res=res|nums[j];\\n                j++;\\n            }\\n            max=Math.max(max,j-i);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527327,
                "title": "python3-sliding-window",
                "content": "Intuition:\\n\\nElements in a nice subarray should not have same bits of 1s\\nFor example, we can not have 1 and 3 in a nice subarray, because bit #0 in both numbers is 1\\n1 -> 0001\\n3 -> 0011\\n\\nSo we use sliding window and keep tracking of all bits in the current window by using OR operator.\\nAnd when we encounter a number that would make our current window not nice, we shrink the window by removing the the left most number in the window until it is no longer conflicting.\\n\\nTo remove bits of element from current window, we use XOR operator.\\n\\n```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        l = 0\\n        r = 0\\n        n = len(nums)\\n        \\n        curr_mask = 0\\n        ans = 1\\n        while r < n:\\n            while l < r and curr_mask & nums[r] != 0:\\n                curr_mask = curr_mask ^ nums[l]\\n                l += 1\\n            \\n            curr_mask = curr_mask | nums[r]\\n            r += 1\\n            ans = max(ans, r - l)\\n        return ans\\n ```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        l = 0\\n        r = 0\\n        n = len(nums)\\n        \\n        curr_mask = 0\\n        ans = 1\\n        while r < n:\\n            while l < r and curr_mask & nums[r] != 0:\\n                curr_mask = curr_mask ^ nums[l]\\n                l += 1\\n            \\n            curr_mask = curr_mask | nums[r]\\n            r += 1\\n            ans = max(ans, r - l)\\n        return ans\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2527313,
                "title": "sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans = 1, ct = nums[0];\\n        \\n        for(int i=0, j=1; j<nums.size() && i<nums.size(); ){\\n            if((ct & nums[j]) == 0){\\n                ct = ct | nums[j];\\n                ans = max(ans, j-i+1);\\n                j++;\\n            } else if(i==j) {\\n                ct = nums[i];\\n                j++;\\n            }\\n            else {\\n                i++;\\n                ct = nums[i];\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans = 1, ct = nums[0];\\n        \\n        for(int i=0, j=1; j<nums.size() && i<nums.size(); ){\\n            if((ct & nums[j]) == 0){\\n                ct = ct | nums[j];\\n                ans = max(ans, j-i+1);\\n                j++;\\n            } else if(i==j) {\\n                ct = nums[i];\\n                j++;\\n            }\\n            else {\\n                i++;\\n                ct = nums[i];\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933803,
                "title": "sliding-window-and-bit-manipulation-o-n-time",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use sliding window algo for keeping the track of the subarray which is nice, if you observe you should find that if a subarray is nice then the set bits of all of their elements must not overlap, using this we can keep track of all the setbits of elements in our window and check if next element can be added to the window or not by anding them with the all the set bits which we will store in our mask variable, set bits of an element can be stored in mask by oring the mask with the element.\\n\\nIf suppose that the next element makes the window not nice and  cannot be added, then we start to remove the element from the left until the subarray is nice again upon adding the next element. To remove the element means, to remove the set bits of that element from the mask we can do this by anding the mask with complement of the element.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int mask = 0;\\n        int Max = 0;\\n        for(int left= 0, right = 0; right < n; right++){\\n            int temp = nums[right]&mask;\\n            // removing set bits of leftmost element from mask if the current element cannot be added to subarray\\n            while(temp != 0){\\n                mask = mask & (~nums[left]);\\n                temp = nums[right]&mask;\\n                left++;\\n            }\\n            // adding the setbits of current element in the mask\\n            mask = mask | nums[right];\\n            Max = max(Max, right-left);\\n        }\\n\\n        return Max+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int mask = 0;\\n        int Max = 0;\\n        for(int left= 0, right = 0; right < n; right++){\\n            int temp = nums[right]&mask;\\n            // removing set bits of leftmost element from mask if the current element cannot be added to subarray\\n            while(temp != 0){\\n                mask = mask & (~nums[left]);\\n                temp = nums[right]&mask;\\n                left++;\\n            }\\n            // adding the setbits of current element in the mask\\n            mask = mask | nums[right];\\n            Max = max(Max, right-left);\\n        }\\n\\n        return Max+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832828,
                "title": "cpp-easy-to-understand-bit-magic",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) \\n    {\\n        long long int num=0;\\n        \\n        int ans=1;\\n        \\n        int start=0;\\n        int end=0;\\n        \\n        while(end<nums.size())\\n        {\\n            //checking if the curr num can be taken or not\\n            if(start==end)\\n            {\\n            num = num ^ nums[end];\\n            end++;\\t\\n            }\\n            else if((num & (nums[end])) > 0)\\n            {\\n                num = num ^ nums[start];\\n                start++;\\n            }\\n            else if((num & (nums[end])) ==0)\\n            {\\n                ans = max(ans,(end-start+1));\\n                num = num ^ nums[end];\\n                end++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) \\n    {\\n        long long int num=0;\\n        \\n        int ans=1;\\n        \\n        int start=0;\\n        int end=0;\\n        \\n        while(end<nums.size())\\n        {\\n            //checking if the curr num can be taken or not\\n            if(start==end)\\n            {\\n            num = num ^ nums[end];\\n            end++;\\t\\n            }\\n            else if((num & (nums[end])) > 0)\\n            {\\n                num = num ^ nums[start];\\n                start++;\\n            }\\n            else if((num & (nums[end])) ==0)\\n            {\\n                ans = max(ans,(end-start+1));\\n                num = num ^ nums[end];\\n                end++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822213,
                "title": "simple-solution-cpp-not-used-xor",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& ar) {\\n        /*\\n        AND               OR\\n        0 & 0 = 0         0 & 0 = 0\\n        0 & 1 = 0         0 & 1 = 1\\n        1 & 0 = 0         1 & 0 = 1\\n        1 & 1 = 1         1 & 1 = 1\\n        \\n        We using mask for comparing all pairs bitwise AND equal to 0\\n        */\\n        \\n        int n = ar.size(), ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            int cnt = 0, mask = 0, j = i;\\n            while(j < n && !(mask & ar[j])) {\\n                cnt++; ans = max(ans, cnt);\\n                mask |= ar[j];\\n                j++;\\n            }\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& ar) {\\n        /*\\n        AND               OR\\n        0 & 0 = 0         0 & 0 = 0\\n        0 & 1 = 0         0 & 1 = 1\\n        1 & 0 = 0         1 & 0 = 1\\n        1 & 1 = 1         1 & 1 = 1\\n        \\n        We using mask for comparing all pairs bitwise AND equal to 0\\n        */\\n        \\n        int n = ar.size(), ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            int cnt = 0, mask = 0, j = i;\\n            while(j < n && !(mask & ar[j])) {\\n                cnt++; ans = max(ans, cnt);\\n                mask |= ar[j];\\n                j++;\\n            }\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714395,
                "title": "c-java-sliding-window",
                "content": "# Please Uvote If Usefull.\\n**Intution**\\n* THis is Just Basic Question of Sliding Window as U Have Solved many Problem Related to Sliding Window ( For Basic Sliding Window Question [https://leetcode.com/list/erxhqopd](http://))\\n\\n* Logic Here is As We  Increase  Window Size ( in case of Addition we r doing Or \\'|\\' operator to \\n store resultant of all bits of number in window and \\n\\t * if our Condition is Not Satisfied we Shrink our Window in Sl.Window  so\\n\\n\\t * So  , Here Condition or Shrinking is if (  cumulating bits of all no. present in window  **^(XOR)**\\n\\t  front value of Sliding Window==0 . then shrink SLI .WINDOW.\\n\\t\\t  * Now To Remove front Value We Can Do XOR with  \\n\\t\\t  ( curr=cumulating bits of all no. present in window ) it will remove front value of SL.WINDOW.\\n\\t\\n**Please Use Pen and Paper IF Not Getting**\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& a) {\\n        int ans=1; // There will be Always 1 size smaller\\n        \\n        int i=0,j=0,cur=0;\\n        \\n        for( i=0;i<a.size();i++){\\n            \\n            while( j< i && (cur & a[i])!=0 ) cur =cur^a[j++];\\n            \\n            cur=cur | a[i] ;\\n            ans=max( ans, i-j+1) ;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& a) {\\n        int ans=1; // There will be Always 1 size smaller\\n        \\n        int i=0,j=0,cur=0;\\n        \\n        for( i=0;i<a.size();i++){\\n            \\n            while( j< i && (cur & a[i])!=0 ) cur =cur^a[j++];\\n            \\n            cur=cur | a[i] ;\\n            ans=max( ans, i-j+1) ;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613977,
                "title": "java-two-solutions-brute-and-optimized",
                "content": "### Please Upvote !!! **(\\u25E0\\u203F\\u25E0)**\\n##### 1. Brute force approach: \\n```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int maxLen = 1;\\n\\n        for(int i = 0; i < nums.length - maxLen; i++) {\\n            int currLen = 1;\\n            int subarrayOR = nums[i];\\n\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if ((subarrayOR & nums[j]) == 0) {\\n                    subarrayOR |= nums[j];\\n                    currLen++;\\n                }\\n\\n                else break;\\n            }\\n\\n            maxLen = Math.max(maxLen, currLen);\\n        }\\n\\n        return maxLen;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\\n##### 2. Optimized approach (using Sliding Window):\\n```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int start = 0,\\n            maxLen = 1, subarrayOR = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            while ((subarrayOR & nums[i]) != 0) {\\n                subarrayOR ^= nums[start++];\\n            }\\n\\n            subarrayOR |= nums[i];\\n\\n            int currLen = i - start + 1;\\n            maxLen = Math.max(maxLen, currLen);\\n        }\\n\\n        return maxLen;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int maxLen = 1;\\n\\n        for(int i = 0; i < nums.length - maxLen; i++) {\\n            int currLen = 1;\\n            int subarrayOR = nums[i];\\n\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if ((subarrayOR & nums[j]) == 0) {\\n                    subarrayOR |= nums[j];\\n                    currLen++;\\n                }\\n\\n                else break;\\n            }\\n\\n            maxLen = Math.max(maxLen, currLen);\\n        }\\n\\n        return maxLen;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\n```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int start = 0,\\n            maxLen = 1, subarrayOR = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            while ((subarrayOR & nums[i]) != 0) {\\n                subarrayOR ^= nums[start++];\\n            }\\n\\n            subarrayOR |= nums[i];\\n\\n            int currLen = i - start + 1;\\n            maxLen = Math.max(maxLen, currLen);\\n        }\\n\\n        return maxLen;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558172,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int count = 0, startidx = 0, val = 0;\\n        for(int i=0; i<nums.length; i++){\\n            while((val & nums[i]) != 0){\\n                val ^= nums[startidx++];\\n            }\\n            val |= nums[i];\\n            count = Math.max(count, i - startidx + 1);\\n        }\\n        return count;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar longestNiceSubarray = function(nums) {\\n    let count = 0, startidx = 0, val = 0\\n    for(let i=0; i<nums.length; i++){\\n        while((val & nums[i]) != 0){\\n            val ^= nums[startidx++]\\n        }\\n        val |= nums[i]\\n        count = Math.max(count, i - startidx + 1)\\n    }\\n    return count\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def longestNiceSubarray(self, nums):\\n        count = startidx = val = 0\\n        for i in range(len(nums)):\\n            while (val & nums[i]) != 0:\\n                val ^= nums[startidx]\\n                startidx += 1\\n            val |= nums[i]\\n            count = max(count, i - startidx + 1)\\n        return count\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int count = 0, startidx = 0, val = 0;\\n        for(int i=0; i<nums.length; i++){\\n            while((val & nums[i]) != 0){\\n                val ^= nums[startidx++];\\n            }\\n            val |= nums[i];\\n            count = Math.max(count, i - startidx + 1);\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nvar longestNiceSubarray = function(nums) {\\n    let count = 0, startidx = 0, val = 0\\n    for(let i=0; i<nums.length; i++){\\n        while((val & nums[i]) != 0){\\n            val ^= nums[startidx++]\\n        }\\n        val |= nums[i]\\n        count = Math.max(count, i - startidx + 1)\\n    }\\n    return count\\n};\\n```\n```\\nclass Solution(object):\\n    def longestNiceSubarray(self, nums):\\n        count = startidx = val = 0\\n        for i in range(len(nums)):\\n            while (val & nums[i]) != 0:\\n                val ^= nums[startidx]\\n                startidx += 1\\n            val |= nums[i]\\n            count = max(count, i - startidx + 1)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547581,
                "title": "o-n-solution-detailed-explanation",
                "content": "When I read the problem the first time I just missed the point \\u201CEvery pair in the subarray\\u201D\\n\\nThis means each value in the subarray will be having different set bits(two elements won\\u2019t be having same set bits). (Since `1 <= nums[i]\"`\\n\\nEg: [1,2,8,10] binary representation: [0101, 0010, 1000, 1001], if we AND 1 and 10 we would be getting 1. So in this case the nice subarray is [0001, 0010, 1000] and set bits in the subarray: 10011. So we are planning to add new value i.e, increase length of the subarray. We have to check with the set bits of all the elements with the element that is going to be added to the subarray. If the set bits of subarray and new element is different we can add it to the nice subarray.  \\n\\nIf the subarray set bits and new element setbits are common off the set bits in the nicest subarray if we \\u2018AND\\u2019 it with new value, if we are getting value greater than zero. \\n\\nUsed sliding window technique : O(n) Time complexity\\n\\n```cpp\\nint longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int andSubArr = 0;\\n        int ans = 0;\\n        for (int i = 0, j = 0; i < n; i++) {\\n            while(andSubArr & nums[i]) {\\n                andSubArr ^= nums[j++];\\n            }\\n            andSubArr |= nums[i];\\n            ans = max(ans, i - j + 1);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```cpp\\nint longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int andSubArr = 0;\\n        int ans = 0;\\n        for (int i = 0, j = 0; i < n; i++) {\\n            while(andSubArr & nums[i]) {\\n                andSubArr ^= nums[j++];\\n            }\\n            andSubArr |= nums[i];\\n            ans = max(ans, i - j + 1);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2528949,
                "title": "basic-and-very-intuitive-explained",
                "content": "see as there is subarray in the question the first intuition goes towards sliding window, here the task is how would we compare the present pos with all the numbers that are present in our window right now if we do brute like iterating over all elements in the window we would get tle , so one thing we can do is that take or while moving forward so that all the set bits for the elments present in our window is already there with us so we can just compare the new number with this or value. now while moving the start of window we need to remove the elemnts from  out total or value for this we ca xor that index value from our or value .... and just move like that , you will get the solution.....\\n//code\\n\\n int longestNiceSubarray(vector<int>& nums) {\\n        int i=0;\\n        int j=0;\\n        int n=nums.size();\\n        int val=0;\\n        int ans=1;\\n        while(j<n){\\n            while(i<=j && val&nums[j]){\\n                val=val^nums[i];\\n                i++;\\n            }\\n            val=val|nums[j];\\n            int temp=(j-i+1);\\n            ans=max(temp,ans);\\n            j++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "see as there is subarray in the question the first intuition goes towards sliding window, here the task is how would we compare the present pos with all the numbers that are present in our window right now if we do brute like iterating over all elements in the window we would get tle , so one thing we can do is that take or while moving forward so that all the set bits for the elments present in our window is already there with us so we can just compare the new number with this or value. now while moving the start of window we need to remove the elemnts from  out total or value for this we ca xor that index value from our or value .... and just move like that , you will get the solution.....\\n//code\\n\\n int longestNiceSubarray(vector<int>& nums) {\\n        int i=0;\\n        int j=0;\\n        int n=nums.size();\\n        int val=0;\\n        int ans=1;\\n        while(j<n){\\n            while(i<=j && val&nums[j]){\\n                val=val^nums[i];\\n                i++;\\n            }\\n            val=val|nums[j];\\n            int temp=(j-i+1);\\n            ans=max(temp,ans);\\n            j++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2527853,
                "title": "c-100-faster-no-extra-space-upvote-plz",
                "content": "```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector<int>& nums) \\n    {\\n        int ans = 1;\\n        int currlen = 1;\\n        int i = 0;\\n        while(i < nums.size()-1)\\n        {\\n            if((nums[i] & nums[i+1]) == 0)\\n            {\\n              currlen++;\\n              if(currlen > 2)\\n              {\\n                  int check = 1;\\n                  int checked_len = 2;\\n                  while(checked_len != currlen)\\n                  {\\n                      if((nums[i-check] & nums[i+1]) == 0)\\n                      {\\n                          checked_len++;\\n                          check++;\\n                      }\\n                      else\\n                          break;\\n                  }\\n                  if(checked_len != currlen)\\n                      currlen = checked_len;    \\n              }\\n              ans = max(ans,currlen);  \\n              i++;  \\n            }\\n            else\\n            {\\n               currlen = 1;    \\n               i++;\\n            }     \\n        }\\n      return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector<int>& nums) \\n    {\\n        int ans = 1;\\n        int currlen = 1;\\n        int i = 0;\\n        while(i < nums.size()-1)\\n        {\\n            if((nums[i] & nums[i+1]) == 0)\\n            {\\n              currlen++;\\n              if(currlen > 2)\\n              {\\n                  int check = 1;\\n                  int checked_len = 2;\\n                  while(checked_len != currlen)\\n                  {\\n                      if((nums[i-check] & nums[i+1]) == 0)\\n                      {\\n                          checked_len++;\\n                          check++;\\n                      }\\n                      else\\n                          break;\\n                  }\\n                  if(checked_len != currlen)\\n                      currlen = checked_len;    \\n              }\\n              ans = max(ans,currlen);  \\n              i++;  \\n            }\\n            else\\n            {\\n               currlen = 1;    \\n               i++;\\n            }     \\n        }\\n      return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527840,
                "title": "c-solution-sliding-window",
                "content": "```cpp\\nclass Solution {\\n   public:\\n    int longestNiceSubarray(vector<int> &nums) {\\n        int n = nums.size();\\n        int res = 1, l = 0, r = 1;\\n        while (r < n) {\\n            int d = 32;\\n            bool flag = true;\\n            for (int k = r - 1; k >= l && d--; k--) {\\n                if (nums[k] & nums[r]) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                res = max(res, r - l + 1);\\n                r++;\\n            } else {\\n                l++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```cpp\\nclass Solution {\\n   public:\\n    int longestNiceSubarray(vector<int> &nums) {\\n        int n = nums.size();\\n        int res = 1, l = 0, r = 1;\\n        while (r < n) {\\n            int d = 32;\\n            bool flag = true;\\n            for (int k = r - 1; k >= l && d--; k--) {\\n                if (nums[k] & nums[r]) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                res = max(res, r - l + 1);\\n                r++;\\n            } else {\\n                l++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527759,
                "title": "c-simple-solution-using-sliding-window",
                "content": "Here, The obsevation is that if one subarray contain two or more set bit at same position then it is definately not part of our Nice Subarray Because \"AND\" operation between that elements given non-zero value.\\n```\\nclass Solution {\\n    void helper(int nums, vector<int> &bits, int op){\\n        for(int i=0; i<=30; i++){\\n            if(nums & (1ll << i)){\\n                bits[i] += op;\\n            }\\n        }\\n    }\\n    \\n    bool isValid(vector<int> &bits){\\n        for(int i=0; i<=30; i++){\\n            if(bits[i] > 1) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0;\\n        int i = 0, j = 0;\\n        vector<int> bits(32, 0);\\n        while(j < n){\\n            helper(nums[j], bits, 1); // adding to out subarray count\\n            \\n            while(!isValid(bits)){ // remove the element from starting till not get Nice Subarray\\n                helper(nums[i], bits, -1); // subtract 1 from bit\\n                i++;\\n            }\\n            ans = max(ans, j-i+1);\\n            j++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    void helper(int nums, vector<int> &bits, int op){\\n        for(int i=0; i<=30; i++){\\n            if(nums & (1ll << i)){\\n                bits[i] += op;\\n            }\\n        }\\n    }\\n    \\n    bool isValid(vector<int> &bits){\\n        for(int i=0; i<=30; i++){\\n            if(bits[i] > 1) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0;\\n        int i = 0, j = 0;\\n        vector<int> bits(32, 0);\\n        while(j < n){\\n            helper(nums[j], bits, 1); // adding to out subarray count\\n            \\n            while(!isValid(bits)){ // remove the element from starting till not get Nice Subarray\\n                helper(nums[i], bits, -1); // subtract 1 from bit\\n                i++;\\n            }\\n            ans = max(ans, j-i+1);\\n            j++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527757,
                "title": "python-3-sliding-window-running-sum",
                "content": "Keep a running sum and slide our window to add a new number to the sum. If **current_sum + new_number == current_sum | new_number**, all numbers in the window have set bits at unique locations. Otherwise slide the left end of the window until the condition is satisfied.\\n\\n```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1:\\n            return 1\\n        \\n        ans = 1\\n        i = 0\\n        cur = nums[0]\\n        for j in range(1, n):\\n            if cur + nums[j] == cur | nums[j]:\\n                ans = max(ans, j - i + 1)\\n            else:\\n                while cur & nums[j]:\\n                    cur -= nums[i]\\n                    i += 1\\n            cur += nums[j]\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1:\\n            return 1\\n        \\n        ans = 1\\n        i = 0\\n        cur = nums[0]\\n        for j in range(1, n):\\n            if cur + nums[j] == cur | nums[j]:\\n                ans = max(ans, j - i + 1)\\n            else:\\n                while cur & nums[j]:\\n                    cur -= nums[i]\\n                    i += 1\\n            cur += nums[j]\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527692,
                "title": "python-sliding-window-o-n-with-line-by-line-comments",
                "content": "The idea is to use sliding window technique. Whenever a new element has a bit position same as the window we will remove the left most element from the window using XOR until the window can include the new element. Note that we need to use OR to include a element in the window.\\n```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        window = nums[0] # initialize the window with the first element in nums\\n        left = 0 # left indx of the window is at 0\\n        res = 1 # since we have the first element in window, the size of this window is 1\\n        for right in range(1,len(nums)):\\n            # if the left < right, and window & the right most element is not equal to zero,\\n            # we need to remove the left most element in the window by using XOR (^), and increment left by 1\\n            while left<right and window&nums[right]!=0:\\n                window = window^nums[left]\\n                left += 1\\n            # now we know that window AND indx right element is 0, we need to use OR(|) to add nums[right] to the window\\n            window = window|nums[right]\\n            # record the longest window size\\n            res = max(res,right-left+1)\\n        return res\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        window = nums[0] # initialize the window with the first element in nums\\n        left = 0 # left indx of the window is at 0\\n        res = 1 # since we have the first element in window, the size of this window is 1\\n        for right in range(1,len(nums)):\\n            # if the left < right, and window & the right most element is not equal to zero,\\n            # we need to remove the left most element in the window by using XOR (^), and increment left by 1\\n            while left<right and window&nums[right]!=0:\\n                window = window^nums[left]\\n                left += 1\\n            # now we know that window AND indx right element is 0, we need to use OR(|) to add nums[right] to the window\\n            window = window|nums[right]\\n            # record the longest window size\\n            res = max(res,right-left+1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527538,
                "title": "sliding-window-c-no-bit-manipulatin",
                "content": "This is a standard sliding window problem ,\\nTo keep track of AND of elements , we can create a vector of size 32(given n to be at max) 10^9 which is int ) to store the bits .\\n\\n\\n\\n```\\n   bool isSafe(vector<int>& vec){           // if all elements are less than or equal to 1 -> the number after anding is 0 \\n        for(int i =0;i<vec.size();i++){\\n            if(vec[i]>1)return false;\\n        }\\n        return true;\\n    }\\n    \\n    int longestNiceSubarray(vector<int>& nums) {\\n      \\n        int i =0,j=0;\\n        vector<int> vec(35,0);\\n        \\n        int win = 1;             // window size\\n        while(j<nums.size()){\\n           \\n            int n = (int)(log2(nums[j]));\\n           \\n            string num =  bitset<32>(nums[j]).to_string().substr(32 - n - 1);    // take and of this number \\n            reverse(num.begin(),num.end());\\n            for(int i =0;i<num.size();i++){\\n                     if(num[i]==\\'1\\'){\\n                         vec[i]++;\\n                     }\\n            }\\n         \\n            if(!isSafe(vec)){                  // check if taking and was giving 0 or not \\n                \\n                 n = (int)(log2(nums[i]));              // remove the ith number\\n                 string k =  bitset<32>(nums[i]).to_string().substr(32 - n - 1); \\n                 reverse(k.begin(),k.end());\\n                \\n                for(int i =0;i<k.size();i++){\\n                     if(k[i]==\\'1\\'){\\n                         vec[i]--;\\n                     } } \\n                \\n                i++;\\n            }\\n             \\n\\n            win = max(win,j-i+1);\\n            j++;\\n            \\n        }\\n        \\n        return win;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n   bool isSafe(vector<int>& vec){           // if all elements are less than or equal to 1 -> the number after anding is 0 \\n        for(int i =0;i<vec.size();i++){\\n            if(vec[i]>1)return false;\\n        }\\n        return true;\\n    }\\n    \\n    int longestNiceSubarray(vector<int>& nums) {\\n      \\n        int i =0,j=0;\\n        vector<int> vec(35,0);\\n        \\n        int win = 1;             // window size\\n        while(j<nums.size()){\\n           \\n            int n = (int)(log2(nums[j]));\\n           \\n            string num =  bitset<32>(nums[j]).to_string().substr(32 - n - 1);    // take and of this number \\n            reverse(num.begin(),num.end());\\n            for(int i =0;i<num.size();i++){\\n                     if(num[i]==\\'1\\'){\\n                         vec[i]++;\\n                     }\\n            }\\n         \\n            if(!isSafe(vec)){                  // check if taking and was giving 0 or not \\n                \\n                 n = (int)(log2(nums[i]));              // remove the ith number\\n                 string k =  bitset<32>(nums[i]).to_string().substr(32 - n - 1); \\n                 reverse(k.begin(),k.end());\\n                \\n                for(int i =0;i<k.size();i++){\\n                     if(k[i]==\\'1\\'){\\n                         vec[i]--;\\n                     } } \\n                \\n                i++;\\n            }\\n             \\n\\n            win = max(win,j-i+1);\\n            j++;\\n            \\n        }\\n        \\n        return win;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527431,
                "title": "sliding-window-prefix-sum-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int a[n][32];\\n        memset(a,0,sizeof(a));\\n        \\n        for(int i=0;i<n;i++){\\n            int p=nums[i];\\n            int q=0;\\n            while(p>0){\\n                a[i][q]=p%2;\\n                p/=2;\\n                q++;\\n            }\\n        }\\n        \\n        int prefix[n][32];\\n        memset(prefix,0,sizeof(prefix));\\n        \\n        for(int i=0;i<32;i++){\\n            prefix[0][i]=a[0][i];\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<32;j++){\\n                prefix[i][j]+=prefix[i-1][j]+a[i][j];\\n            }\\n        }\\n        \\n        int p=0,q=0;\\n        int ans=1;\\n        \\n        while(q<n){\\n            int f=1;\\n            if(p==0){\\n               for(int i=0;i<32;i++){\\n                if(prefix[q][i]>1){\\n                    p++;f=0;\\n                    break;\\n                }\\n               }\\n            }\\n            else{\\n               for(int i=0;i<32;i++){\\n                if(prefix[q][i]-prefix[p-1][i]>1){\\n                    p++;f=0;\\n                    break;\\n                }\\n               }\\n            }\\n            \\n            if(f==1){\\n                ans=max(ans,q-p+1);\\n                q++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int a[n][32];\\n        memset(a,0,sizeof(a));\\n        \\n        for(int i=0;i<n;i++){\\n            int p=nums[i];\\n            int q=0;\\n            while(p>0){\\n                a[i][q]=p%2;\\n                p/=2;\\n                q++;\\n            }\\n        }\\n        \\n        int prefix[n][32];\\n        memset(prefix,0,sizeof(prefix));\\n        \\n        for(int i=0;i<32;i++){\\n            prefix[0][i]=a[0][i];\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<32;j++){\\n                prefix[i][j]+=prefix[i-1][j]+a[i][j];\\n            }\\n        }\\n        \\n        int p=0,q=0;\\n        int ans=1;\\n        \\n        while(q<n){\\n            int f=1;\\n            if(p==0){\\n               for(int i=0;i<32;i++){\\n                if(prefix[q][i]>1){\\n                    p++;f=0;\\n                    break;\\n                }\\n               }\\n            }\\n            else{\\n               for(int i=0;i<32;i++){\\n                if(prefix[q][i]-prefix[p-1][i]>1){\\n                    p++;f=0;\\n                    break;\\n                }\\n               }\\n            }\\n            \\n            if(f==1){\\n                ans=max(ans,q-p+1);\\n                q++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527365,
                "title": "python-sliding-window",
                "content": "We start with the window `[0, 0]`. At each step we try to see if adding one more element to the contiguous subarray would overlap some bit to the used bits among the numbers present in the current subarray.\r\n* When we can make the window larger to the right, we update the used bits as well\r\n* When we cannot make the window larget to the right, we shorten it from the left, making sure to update the used bits. We also check the size of the window, to see if we found a larger window.\r\n\r\n&#8718;\r\n\r\n```python\r\nclass Solution:\r\n    def longestNiceSubarray(self, nums: List[int]) -> int:\r\n        n = len(nums)\r\n        left, right = 0, 1\r\n        \r\n        usedBits = nums[0]\r\n        longestNice = 1\r\n        while right < n:\r\n            while right < n and usedBits & nums[right] == 0: # while there is no bit overlap keep making longer to the right\r\n                usedBits |= nums[right]  # turn on bits from right num\r\n                right += 1\r\n            longestNice = max(longestNice, right - left)\r\n            usedBits ^= nums[left]  # turn off bits from left num\r\n            left += 1\r\n                \r\n        return longestNice\r\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\r\nclass Solution:\r\n    def longestNiceSubarray(self, nums: List[int]) -> int:\r\n        n = len(nums)\r\n        left, right = 0, 1\r\n        \r\n        usedBits = nums[0]\r\n        longestNice = 1\r\n        while right < n:\r\n            while right < n and usedBits & nums[right] == 0: # while there is no bit overlap keep making longer to the right\r\n                usedBits |= nums[right]  # turn on bits from right num\r\n                right += 1\r\n            longestNice = max(longestNice, right - left)\r\n            usedBits ^= nums[left]  # turn off bits from left num\r\n            left += 1\r\n                \r\n        return longestNice\r\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527294,
                "title": "python-easy-sliding-window-solution",
                "content": "```\\n    def longestNiceSubarray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        maxV = 1\\n        j = 0\\n        accumOR = nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i] & accumOR == 0:\\n                maxV = max(maxV, i - j + 1)\\n            else:\\n                while nums[i] & accumOR != 0:\\n                    accumOR ^= nums[j]\\n                    j += 1\\n                maxV = max(maxV, i - j + 1)\\n            accumOR |= nums[i]\\n        return maxV\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def longestNiceSubarray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        maxV = 1\\n        j = 0\\n        accumOR = nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i] & accumOR == 0:\\n                maxV = max(maxV, i - j + 1)\\n            else:\\n                while nums[i] & accumOR != 0:\\n                    accumOR ^= nums[j]\\n                    j += 1\\n                maxV = max(maxV, i - j + 1)\\n            accumOR |= nums[i]\\n        return maxV\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3772002,
                "title": "c-using-sliding-window-bit-manipulation-t-c-o-n-s-c-o-1",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(N)\\n        Space Complexity : O(1)\\n    */\\n    \\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int res = 1;\\n        int start = 0, end = 0;\\n        int bMap[31] = {0}; // Binary frequency Map\\n        \\n        while(end < nums.size()){\\n            bool flag = false;\\n            \\n            // Storing the binary representation of the current number\\n            for(int i=0; i<31; i++){\\n                if(nums[end] & (1<<i)){\\n                    bMap[i]++;\\n                    \\n                    if(bMap[i] > 1){\\n                        flag = true;\\n                    }\\n                }\\n            }\\n            \\n            // Check if any bit is repeating\\n            while(flag){\\n                int num = nums[start];\\n\\n                for(int i=0; i<31; i++){\\n                    if(num & (1<<i)){\\n                        bMap[i]--;\\n                    }\\n                }\\n\\n                bool f = false;\\n                for(int i=0; i<31; i++){\\n                    if(bMap[i] >  1){\\n                        f = true;\\n                    }\\n                }\\n\\n                start++;\\n\\n                if(!f){ \\n                    flag = false;\\n                }\\n            }\\n            \\n            res = max(res, end-start+1);\\n            end++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(N)\\n        Space Complexity : O(1)\\n    */\\n    \\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int res = 1;\\n        int start = 0, end = 0;\\n        int bMap[31] = {0}; // Binary frequency Map\\n        \\n        while(end < nums.size()){\\n            bool flag = false;\\n            \\n            // Storing the binary representation of the current number\\n            for(int i=0; i<31; i++){\\n                if(nums[end] & (1<<i)){\\n                    bMap[i]++;\\n                    \\n                    if(bMap[i] > 1){\\n                        flag = true;\\n                    }\\n                }\\n            }\\n            \\n            // Check if any bit is repeating\\n            while(flag){\\n                int num = nums[start];\\n\\n                for(int i=0; i<31; i++){\\n                    if(num & (1<<i)){\\n                        bMap[i]--;\\n                    }\\n                }\\n\\n                bool f = false;\\n                for(int i=0; i<31; i++){\\n                    if(bMap[i] >  1){\\n                        f = true;\\n                    }\\n                }\\n\\n                start++;\\n\\n                if(!f){ \\n                    flag = false;\\n                }\\n            }\\n            \\n            res = max(res, end-start+1);\\n            end++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634425,
                "title": "sliding-window-bit-manipulation-c",
                "content": "```\\nclass Solution {\\n    void add(int n, vector<int> &bits) {\\n        for(int i = 0; i < 32; i++) {\\n            bits[i] += n & 1;\\n            n >>= 1;\\n        }\\n    }\\n    void remove(int n, vector<int> &bits) {\\n        for(int i = 0; i < 32; i++) {\\n            bits[i] -= n & 1;\\n            n >>= 1;\\n        }\\n    }\\n    bool good(vector<int> &bits) {\\n        for(int i = 0; i < 32; i++) {\\n            if(bits[i] == 2) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size(), i = 0, ans = 1;\\n        vector<int> bits(32);\\n\\n        for(int j = 0; j < n; j++) {\\n            add(nums[j], bits);\\n\\n            while(i < j && !good(bits)) {\\n                remove(nums[i], bits);\\n                i++;\\n            }\\n            ans = max(ans, j - i + 1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    void add(int n, vector<int> &bits) {\\n        for(int i = 0; i < 32; i++) {\\n            bits[i] += n & 1;\\n            n >>= 1;\\n        }\\n    }\\n    void remove(int n, vector<int> &bits) {\\n        for(int i = 0; i < 32; i++) {\\n            bits[i] -= n & 1;\\n            n >>= 1;\\n        }\\n    }\\n    bool good(vector<int> &bits) {\\n        for(int i = 0; i < 32; i++) {\\n            if(bits[i] == 2) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size(), i = 0, ans = 1;\\n        vector<int> bits(32);\\n\\n        for(int j = 0; j < n; j++) {\\n            add(nums[j], bits);\\n\\n            while(i < j && !good(bits)) {\\n                remove(nums[i], bits);\\n                i++;\\n            }\\n            ans = max(ans, j - i + 1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177702,
                "title": "easy-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int j=0;\\n        int i=1;\\n        int lul = nums[0];\\n        int ans = 1;\\n        int cnt = 0;\\n        while(i<nums.size()){\\n            while(j<=i&&(nums[i]&lul)){\\n                lul^=nums[j++];\\n                ans=max(ans,i-j+1);\\n            }\\n            lul|=nums[i];\\n            ans=max(ans,i-j+1);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int j=0;\\n        int i=1;\\n        int lul = nums[0];\\n        int ans = 1;\\n        int cnt = 0;\\n        while(i<nums.size()){\\n            while(j<=i&&(nums[i]&lul)){\\n                lul^=nums[j++];\\n                ans=max(ans,i-j+1);\\n            }\\n            lul|=nums[i];\\n            ans=max(ans,i-j+1);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155610,
                "title": "100-python-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        l,r = 0,1\\n        res = 0\\n\\n        while r < len(nums):\\n            i = l\\n\\n            \"\"\"do the bitwise AND for the entire window so far\"\"\"\\n            while i < r and ((nums[r] & nums[i]) == 0):\\n                # print(f\"AND passed {nums[r],nums[i]}\")\\n                i += 1\\n\\n            \\n\\n            if i == r:\\n                res = max(res, r-l+1)\\n                r += 1\\n            else:\\n                l = i + 1 \\n                r = l + 1\\n\\n            \\n\\n        return max(res,1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        l,r = 0,1\\n        res = 0\\n\\n        while r < len(nums):\\n            i = l\\n\\n            \"\"\"do the bitwise AND for the entire window so far\"\"\"\\n            while i < r and ((nums[r] & nums[i]) == 0):\\n                # print(f\"AND passed {nums[r],nums[i]}\")\\n                i += 1\\n\\n            \\n\\n            if i == r:\\n                res = max(res, r-l+1)\\n                r += 1\\n            else:\\n                l = i + 1 \\n                r = l + 1\\n\\n            \\n\\n        return max(res,1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058506,
                "title": "bit-manipulation-and-sliding-window-java",
                "content": "```\\npublic int longestNiceSubarray(int[] nums) {\\n        int temp = 0 , ans = 0; \\n        for(int i = 0 , j = 0 ; i < nums.length ; i++){\\n            while((temp&nums[i])!=0){\\n                temp -= nums[j];\\n                j++;\\n            }\\n            temp |= nums[i];\\n            ans = Math.max(ans,i-j+1);\\n        }\\n        return ans ; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int longestNiceSubarray(int[] nums) {\\n        int temp = 0 , ans = 0; \\n        for(int i = 0 , j = 0 ; i < nums.length ; i++){\\n            while((temp&nums[i])!=0){\\n                temp -= nums[j];\\n                j++;\\n            }\\n            temp |= nums[i];\\n            ans = Math.max(ans,i-j+1);\\n        }\\n        return ans ; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3011377,
                "title": "c-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n            \\n            int s=0,e=0;\\n            int ans=0;\\n            int n=nums.size();\\n            int prev=0;\\n            \\n            while(e<n){\\n                if((nums[e] & prev) == 0){\\n                    prev|=nums[e];\\n                    ans=max(ans,e-s+1);\\n                    e++;\\n                    \\n                }else{\\n                    while(s<e && (nums[e]&prev)!=0){\\n                        prev&=(~nums[s]);\\n                        s++;\\n                    }\\n\\n                    prev|=nums[e];\\n                    e++;\\n                }\\n            }\\n            return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n            \\n            int s=0,e=0;\\n            int ans=0;\\n            int n=nums.size();\\n            int prev=0;\\n            \\n            while(e<n){\\n                if((nums[e] & prev) == 0){\\n                    prev|=nums[e];\\n                    ans=max(ans,e-s+1);\\n                    e++;\\n                    \\n                }else{\\n                    while(s<e && (nums[e]&prev)!=0){\\n                        prev&=(~nums[s]);\\n                        s++;\\n                    }\\n\\n                    prev|=nums[e];\\n                    e++;\\n                }\\n            }\\n            return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998527,
                "title": "c-setbitcount-wierd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans=1;\\n        int curr_size=1,n=nums.size();long long subarray_OR=nums[0];\\n        long long count=__builtin_popcount(nums[0]);\\n\\n        for(int i=1;i<n;i++){\\n            int a=__builtin_popcount(nums[i]);\\n\\n            if((nums[i]&nums[i-1])==0){\\n                subarray_OR=(subarray_OR|nums[i]);count+=a;\\n                int b=__builtin_popcount(subarray_OR);\\n\\n                if(b==count){\\n                    curr_size++;    ans=max(ans,curr_size);\\n                    }else{\\n                        subarray_OR=nums[i];curr_size=1;int j=i-1;count=a;\\n                        \\n                        while(j>0&&((nums[j]&nums[i])==0)){\\n                            int c=__builtin_popcount(nums[j]); count+=c;curr_size++;\\n                            subarray_OR=(subarray_OR|(long long)nums[j]);j--;\\n                        }\\n                    }\\n            }else{\\n                subarray_OR=nums[i];count=a;curr_size=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans=1;\\n        int curr_size=1,n=nums.size();long long subarray_OR=nums[0];\\n        long long count=__builtin_popcount(nums[0]);\\n\\n        for(int i=1;i<n;i++){\\n            int a=__builtin_popcount(nums[i]);\\n\\n            if((nums[i]&nums[i-1])==0){\\n                subarray_OR=(subarray_OR|nums[i]);count+=a;\\n                int b=__builtin_popcount(subarray_OR);\\n\\n                if(b==count){\\n                    curr_size++;    ans=max(ans,curr_size);\\n                    }else{\\n                        subarray_OR=nums[i];curr_size=1;int j=i-1;count=a;\\n                        \\n                        while(j>0&&((nums[j]&nums[i])==0)){\\n                            int c=__builtin_popcount(nums[j]); count+=c;curr_size++;\\n                            subarray_OR=(subarray_OR|(long long)nums[j]);j--;\\n                        }\\n                    }\\n            }else{\\n                subarray_OR=nums[i];count=a;curr_size=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854880,
                "title": "sliding-window-and-bit-manipulation-faster-than-100-intuitive-solution-o-n",
                "content": "```\\npub fn longest_nice_subarray(nums: Vec<i32>) -> i32 {\\n    let mut left = 0;\\n    let mut right = 0;\\n    let len = nums.len();\\n    let mut mask = 0;\\n        \\n    let mut ans = 1;\\n        \\n    while right < len {\\n        if mask & nums[right] == 0 {\\n            ans = ans.max(right - left + 1);\\n        } else{\\n            while left < right && (mask & nums[right] != 0) {\\n                mask = mask ^ nums[left];\\n                left += 1;\\n            }\\n        }\\n            \\n        mask = mask ^ nums[right];\\n            \\n        right += 1;\\n    }\\n        \\n    ans as i32\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```\\npub fn longest_nice_subarray(nums: Vec<i32>) -> i32 {\\n    let mut left = 0;\\n    let mut right = 0;\\n    let len = nums.len();\\n    let mut mask = 0;\\n        \\n    let mut ans = 1;\\n        \\n    while right < len {\\n        if mask & nums[right] == 0 {\\n            ans = ans.max(right - left + 1);\\n        } else{\\n            while left < right && (mask & nums[right] != 0) {\\n                mask = mask ^ nums[left];\\n                left += 1;\\n            }\\n        }\\n            \\n        mask = mask ^ nums[right];\\n            \\n        right += 1;\\n    }\\n        \\n    ans as i32\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2671549,
                "title": "faster-than-96-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n       int n=nums.size(),ans=1,val=nums[0],j=0,i=1,len=1;\\n       while(i<n && j<n)\\n       {\\n           if((val&nums[i])==0)\\n           {\\n               int index=j+1;\\n               while(index<i)\\n               {\\n                   if(!(nums[i]&nums[index])) ++index;\\n                   else break;\\n               }\\n               if(index==i){ \\n                   len=i-j+1;\\n                   i++;\\n               }\\n               else \\n                {\\n                    ans=max(ans,len);\\n                    j++;\\n                    val=nums[j];\\n                    if(i==j) ++i;\\n                }\\n           }\\n           else \\n           {\\n               ans=max(ans,len);\\n               j++;\\n               val=nums[j];\\n               if(i==j) ++i;\\n           }\\n       }\\n       ans=max(ans,len);\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n       int n=nums.size(),ans=1,val=nums[0],j=0,i=1,len=1;\\n       while(i<n && j<n)\\n       {\\n           if((val&nums[i])==0)\\n           {\\n               int index=j+1;\\n               while(index<i)\\n               {\\n                   if(!(nums[i]&nums[index])) ++index;\\n                   else break;\\n               }\\n               if(index==i){ \\n                   len=i-j+1;\\n                   i++;\\n               }\\n               else \\n                {\\n                    ans=max(ans,len);\\n                    j++;\\n                    val=nums[j];\\n                    if(i==j) ++i;\\n                }\\n           }\\n           else \\n           {\\n               ans=max(ans,len);\\n               j++;\\n               val=nums[j];\\n               if(i==j) ++i;\\n           }\\n       }\\n       ans=max(ans,len);\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661428,
                "title": "c-two-approaches-sliding-window",
                "content": "```\\n/*\\n\\nTime Complexity  : O(N*32)\\nSpace Complexity : O(32)\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    void Mark_Bit(vector<int>&prefix,int num,int &cnt){\\n        \\n        for(int i=0;i<32;i++){\\n            \\n            if((num&(1<<i))){\\n                \\n                prefix[i]++;\\n                \\n                if(prefix[i] == 2){\\n                    cnt++;\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    \\n    void Unmark_Bit(vector<int>&prefix,int num,int &cnt){\\n        \\n        for(int i=0;i<32;i++){\\n            \\n            if((num&(1<<i))){\\n                \\n                prefix[i]--;\\n                \\n                if(prefix[i] == 1){\\n                    cnt--;\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    int longestNiceSubarray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int maxLen = 0;\\n        \\n        int l = 0, r = 0;\\n        \\n        int count = 0;\\n        \\n        vector<int>prefix(32,0);\\n        \\n        while(l<n && r<n){\\n            \\n            Mark_Bit(prefix,nums[r],count);\\n            \\n            while(l<=r && count){\\n                \\n                Unmark_Bit(prefix,nums[l],count);\\n                \\n                l++;\\n                \\n            }\\n            \\n            maxLen = max(maxLen,r-l+1);    \\n                \\n            r++;\\n            \\n        }\\n        \\n        return maxLen;\\n        \\n    }\\n};\\n```\\n\\n--------------------------------------------------------------------------------\\n\\n```\\n/*\\n\\nTime Complexity  : O(N)\\nSpace Complexity : O(1)\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    int longestNiceSubarray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int maxLen = 0;\\n        \\n        int l=0, r=0, bit=0;\\n        \\n        while(l<n && r<n){\\n            \\n            while((bit&nums[r])!=0){\\n                \\n                bit^=nums[l];\\n                \\n                l++;\\n                \\n            }\\n            \\n            bit|=nums[r];\\n            \\n            maxLen = max(maxLen,r-l+1);\\n            \\n            r++;\\n            \\n        }\\n        \\n        return maxLen;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\nTime Complexity  : O(N*32)\\nSpace Complexity : O(32)\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    void Mark_Bit(vector<int>&prefix,int num,int &cnt){\\n        \\n        for(int i=0;i<32;i++){\\n            \\n            if((num&(1<<i))){\\n                \\n                prefix[i]++;\\n                \\n                if(prefix[i] == 2){\\n                    cnt++;\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    \\n    void Unmark_Bit(vector<int>&prefix,int num,int &cnt){\\n        \\n        for(int i=0;i<32;i++){\\n            \\n            if((num&(1<<i))){\\n                \\n                prefix[i]--;\\n                \\n                if(prefix[i] == 1){\\n                    cnt--;\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    int longestNiceSubarray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int maxLen = 0;\\n        \\n        int l = 0, r = 0;\\n        \\n        int count = 0;\\n        \\n        vector<int>prefix(32,0);\\n        \\n        while(l<n && r<n){\\n            \\n            Mark_Bit(prefix,nums[r],count);\\n            \\n            while(l<=r && count){\\n                \\n                Unmark_Bit(prefix,nums[l],count);\\n                \\n                l++;\\n                \\n            }\\n            \\n            maxLen = max(maxLen,r-l+1);    \\n                \\n            r++;\\n            \\n        }\\n        \\n        return maxLen;\\n        \\n    }\\n};\\n```\n```\\n/*\\n\\nTime Complexity  : O(N)\\nSpace Complexity : O(1)\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    int longestNiceSubarray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int maxLen = 0;\\n        \\n        int l=0, r=0, bit=0;\\n        \\n        while(l<n && r<n){\\n            \\n            while((bit&nums[r])!=0){\\n                \\n                bit^=nums[l];\\n                \\n                l++;\\n                \\n            }\\n            \\n            bit|=nums[r];\\n            \\n            maxLen = max(maxLen,r-l+1);\\n            \\n            r++;\\n            \\n        }\\n        \\n        return maxLen;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592850,
                "title": "longest-nice-subarray-solution-java",
                "content": "class Solution {\\n  public int longestNiceSubarray(int[] nums) {\\n    int ans = 0;\\n    int usedBits = 0;\\n\\n    for (int l = 0, r = 0; r < nums.length; ++r) {\\n      while ((usedBits & nums[r]) > 0)\\n        usedBits ^= nums[l++];\\n      usedBits |= nums[r];\\n      ans = Math.max(ans, r - l + 1);\\n    }\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n  public int longestNiceSubarray(int[] nums) {\\n    int ans = 0;\\n    int usedBits = 0;\\n\\n    for (int l = 0, r = 0; r < nums.length; ++r) {\\n      while ((usedBits & nums[r]) > 0)\\n        usedBits ^= nums[l++];\\n      usedBits |= nums[r];\\n      ans = Math.max(ans, r - l + 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2579330,
                "title": "rust-sliding-window-with-bitwise-operations",
                "content": "\\n```rust\\npub fn longest_nice_subarray(nums: Vec<i32>) -> i32 {\\n    // a bitset to track all 1 bits in the sliding window\\n    let mut used = 0i32;\\n\\n    // the longest sliding window found so far\\n    let mut best = 0;\\n\\n    // start/end of hte current sliding window\\n    let mut lo = 0;\\n    let mut hi = 0;\\n\\n    // expand the sliding window until we have processed all input numbers\\n    while hi < nums.len() {\\n        // Shrink the sliding window until there are no common bits\\n        while nums[hi] & used != 0 {\\n            // delete the leftmost number from the sliding window\\n            used ^= nums[lo];\\n            lo += 1;\\n        }\\n        // expand the sliding window with the current rightmost number\\n        used |= nums[hi];\\n\\n        // Calculate the sliding window length and update the answer\\n        hi += 1;\\n        best = best.max(hi - lo);\\n    }\\n\\n    best as i32\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```rust\\npub fn longest_nice_subarray(nums: Vec<i32>) -> i32 {\\n    // a bitset to track all 1 bits in the sliding window\\n    let mut used = 0i32;\\n\\n    // the longest sliding window found so far\\n    let mut best = 0;\\n\\n    // start/end of hte current sliding window\\n    let mut lo = 0;\\n    let mut hi = 0;\\n\\n    // expand the sliding window until we have processed all input numbers\\n    while hi < nums.len() {\\n        // Shrink the sliding window until there are no common bits\\n        while nums[hi] & used != 0 {\\n            // delete the leftmost number from the sliding window\\n            used ^= nums[lo];\\n            lo += 1;\\n        }\\n        // expand the sliding window with the current rightmost number\\n        used |= nums[hi];\\n\\n        // Calculate the sliding window length and update the answer\\n        hi += 1;\\n        best = best.max(hi - lo);\\n    }\\n\\n    best as i32\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569732,
                "title": "sliding-window",
                "content": "the idea is to perform sliding window, and for every new value first do bitwise AND(&) if that result is 0 that means we can increase the size of our subarray \\nif the result is not 0 then we should remove the elements from the left (basic sliding window logic)\\n\\nthe extra part is how will you manage the cumulative value\\nfor every value that satisfy the condition perform the OR (|) and put it in the cumulative such that all the binary \\'1\\' of the taken subarray are taken into consideration\\n\\n\\n```\\npublic int longestNiceSubarray(int[] nums) {\\n        \\n        int cumulative=0;   // to take cumulative AND (&), OR(|) and XOR (^)\\n        int max=1;   // min value will be 1\\n        int left=0,right=0;\\n        \\n        while(right < nums.length){\\n            \\n            int val1 = nums[right];  // take every element \\n            int res = val1 & cumulative;  // perform the & operation \\n            \\n\\t\\t\\t// if the result of above & operation is not 0 then remove the elements from left side one by one\\n            while(  left<=right  && (val1 & cumulative) != 0){  \\n                int val2 = nums[left];\\n                cumulative = val2 ^ cumulative;   // now when we are removing the left element we need to remove it from the cumulative value as well,\\n                left++;\\n            }\\n            cumulative = val1 | cumulative;  // now add the right value to the cumulative \\n            \\n            if(res==0){\\n                max = Math.max(max, right-left+1 ); // check for the max window size/ max subarray\\n            }\\n            \\n            right++;   \\n        }\\n        \\n        return max;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int longestNiceSubarray(int[] nums) {\\n        \\n        int cumulative=0;   // to take cumulative AND (&), OR(|) and XOR (^)\\n        int max=1;   // min value will be 1\\n        int left=0,right=0;\\n        \\n        while(right < nums.length){\\n            \\n            int val1 = nums[right];  // take every element \\n            int res = val1 & cumulative;  // perform the & operation \\n            \\n\\t\\t\\t// if the result of above & operation is not 0 then remove the elements from left side one by one\\n            while(  left<=right  && (val1 & cumulative) != 0){  \\n                int val2 = nums[left];\\n                cumulative = val2 ^ cumulative;   // now when we are removing the left element we need to remove it from the cumulative value as well,\\n                left++;\\n            }\\n            cumulative = val1 | cumulative;  // now add the right value to the cumulative \\n            \\n            if(res==0){\\n                max = Math.max(max, right-left+1 ); // check for the max window size/ max subarray\\n            }\\n            \\n            right++;   \\n        }\\n        \\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2558413,
                "title": "sliding-window-bitwise-magic",
                "content": "Logic is simple :-> if every possible AND pair in a subarray is 0, i.e. **each bit in any two numbers is at different position..\\nMeans in that subarray : Xor of all elements will be equal to sum of elements...**\\nImplemented the same using sliding window...\\n\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int i = 0, j = 1;\\n        int n = nums.size();\\n        int ans = 1;\\n        long curr = nums[i];\\n        long sum = nums[i];\\n        while(i < n && j < n){\\n            if(i == j){\\n                curr = nums[i];\\n                sum = nums[i];\\n                j++;\\n                continue;\\n            }\\n            if(curr == sum && ((curr^nums[j]) == (sum+nums[j]))){\\n                curr = curr^nums[j];\\n                sum = sum + nums[j];\\n                ans = max(ans,j-i+1);\\n                j++;\\n            }\\n            else{\\n                sum -= nums[i];\\n                curr = curr^nums[i];\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHope it helped \\uD83E\\uDD17!",
                "solutionTags": [
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int i = 0, j = 1;\\n        int n = nums.size();\\n        int ans = 1;\\n        long curr = nums[i];\\n        long sum = nums[i];\\n        while(i < n && j < n){\\n            if(i == j){\\n                curr = nums[i];\\n                sum = nums[i];\\n                j++;\\n                continue;\\n            }\\n            if(curr == sum && ((curr^nums[j]) == (sum+nums[j]))){\\n                curr = curr^nums[j];\\n                sum = sum + nums[j];\\n                ans = max(ans,j-i+1);\\n                j++;\\n            }\\n            else{\\n                sum -= nums[i];\\n                curr = curr^nums[i];\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554324,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        \\n        int i=0,j=0;\\n        int count=1;\\n        \\n  while(i<n){\\n     \\n      for(int k=j;k<i;k++){\\n          if((nums[i]&nums[k])!=0)j=k+1;\\n      }\\n      \\n      count=max(count,i-j+1);\\n      \\n      i++;\\n  }  \\n        \\n   \\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        \\n        int i=0,j=0;\\n        int count=1;\\n        \\n  while(i<n){\\n     \\n      for(int k=j;k<i;k++){\\n          if((nums[i]&nums[k])!=0)j=k+1;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2553119,
                "title": "c-bits-sliding-window",
                "content": "\\nBits AND of the elements in the window should be 0, if not pop elements from the back\\n\\nsum reperesents bits sum of the window, when AND is 0\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans = 0, sum = 0, first = 0;\\n\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\twhile ((sum & nums[i]) > 0)\\n\\t\\t\\t\\tsum ^= nums[first++];\\n\\t\\t\\tsum |= nums[i];\\n\\t\\t\\tans = max(ans, i - first + 1);\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans = 0, sum = 0, first = 0;\\n\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\twhile ((sum & nums[i]) > 0)\\n\\t\\t\\t\\tsum ^= nums[first++];\\n\\t\\t\\tsum |= nums[i];\\n\\t\\t\\tans = max(ans, i - first + 1);\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551223,
                "title": "c-sliding-window-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums)\\n    {\\n        int p=0,j=0,ans=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            while((p&nums[i])!=0)\\n            {\\n                p^=nums[j++];\\n            }\\n            p|=nums[i];\\n            ans=max(ans,i-j+1);\\n        }\\n        return ans;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums)\\n    {\\n        int p=0,j=0,ans=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            while((p&nums[i])!=0)\\n            {\\n                p^=nums[j++];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2547418,
                "title": "java-solution-hard-code-bit-manipulation",
                "content": "```\\npublic int longestNiceSubarray(int[] nums) {\\n        int maxCount = 1;\\n        int count = 1;\\n\\n        List<Integer> list = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            list.clear();\\n            list.add(nums[i]);\\n            count = 1;\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if ((nums[i] & nums[j]) == 0) {\\n                    list.add(nums[j]);\\n                } else\\n                    break;\\n            }\\n\\n            boolean bool = true;\\n                if (list.size() != 1) {\\n                for (int i1 = 1; i1 < list.size(); i1++) {\\n                    for (int j = 0; j < i1; j++) {\\n                        if (i1!=j&&(list.get(i1) & list.get(j)) != 0) {\\n                            bool = false;\\n                            break;\\n                        }\\n                    }\\n                    if (bool)\\n                        count++;\\n                    else\\n                        break;\\n                }\\n                \\n                if (maxCount<count)\\n                    maxCount = count;\\n            }\\n        }\\n        return maxCount;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int longestNiceSubarray(int[] nums) {\\n        int maxCount = 1;\\n        int count = 1;\\n\\n        List<Integer> list = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            list.clear();\\n            list.add(nums[i]);\\n            count = 1;\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if ((nums[i] & nums[j]) == 0) {\\n                    list.add(nums[j]);\\n                } else\\n                    break;\\n            }\\n\\n            boolean bool = true;\\n                if (list.size() != 1) {\\n                for (int i1 = 1; i1 < list.size(); i1++) {\\n                    for (int j = 0; j < i1; j++) {\\n                        if (i1!=j&&(list.get(i1) & list.get(j)) != 0) {\\n                            bool = false;\\n                            break;\\n                        }\\n                    }\\n                    if (bool)\\n                        count++;\\n                    else\\n                        break;\\n                }\\n                \\n                if (maxCount<count)\\n                    maxCount = count;\\n            }\\n        }\\n        return maxCount;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2544401,
                "title": "sliding-window-bitmask-c-7-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& a) {\\n        //We use a sliding window to keep track of the longest window/subarray.\\n        //We also need a mask to keep track of the set bit positions in the window.\\n        //At any time, a[left ... right] is the longest valid window with uncommon bits\\n        //ending at right.\\n        //(this is done to make the AND of all the pairs non-zero)\\n        \\n        int ans=0, mask=0;\\n        for(int left=0, right=0;right<a.size();right++){\\n            while(mask & a[right])\\n                mask^=a[left++]; // this unsets the bits used by left\\n            mask|=a[right]; // this sets the bits used by right\\n            ans=max(ans, right-left+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& a) {\\n        //We use a sliding window to keep track of the longest window/subarray.\\n        //We also need a mask to keep track of the set bit positions in the window.\\n        //At any time, a[left ... right] is the longest valid window with uncommon bits\\n        //ending at right.\\n        //(this is done to make the AND of all the pairs non-zero)\\n        \\n        int ans=0, mask=0;\\n        for(int left=0, right=0;right<a.size();right++){\\n            while(mask & a[right])\\n                mask^=a[left++]; // this unsets the bits used by left\\n            mask|=a[right]; // this sets the bits used by right\\n            ans=max(ans, right-left+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542213,
                "title": "rust-3-ms-functional-style-sliding-window-with-bitwise-operations-with-detailed-comments",
                "content": "This [solution](https://leetcode.com/submissions/detail/793397051/) employs a functional-style implementation of sliding window technique with bitwise operations to account bits. It demonstrated **3 ms runtime (100%)** and used **4.0 MB memory (38.46%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn longest_nice_subarray(nums: Vec<i32>) -> i32 \\n    {\\n        let mut used_ : i32 = 0;\\n        let mut used  : i32 = 0;\\n        \\n        // [1] initial position of a sliding window is iterated linearly\\n        nums.iter().enumerate().map(|(i,val)| \\n        {\\n            used = *val;\\n            // [2] final position of a sliding window is also iterated linearly,\\n            //     however, this cycle won\\'t exceed 30 rounds, thus, overall complexity is O(30*n)=O(n)\\n            let f = (i+1..nums.len()).take_while(|&j|\\n            {\\n                // [3] the main idea of this solution is that while \\n                //     the results of binary \\'or\\' and binary \\'xor\\' coincide\\n                //     we accumulate new 1 bits, thus, extend nice subarray;\\n                used_ = used ^ nums[j]; \\n                used |= nums[j]; \\n                \\n                // [4] once the results of binary \\'or\\' and binary \\'xor\\' are different,\\n                //     then there is some duplicated bit in the candidate nice subarray [i,f)\\n                used == used_\\n            }).last().unwrap_or(i); // [5] take index of the right boundary of sliding window\\n            (f - i + 1) as i32\\n        }).max().unwrap_or(1)       // [6] take max length of sliding window     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Sliding Window"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn longest_nice_subarray(nums: Vec<i32>) -> i32 \\n    {\\n        let mut used_ : i32 = 0;\\n        let mut used  : i32 = 0;\\n        \\n        // [1] initial position of a sliding window is iterated linearly\\n        nums.iter().enumerate().map(|(i,val)| \\n        {\\n            used = *val;\\n            // [2] final position of a sliding window is also iterated linearly,\\n            //     however, this cycle won\\'t exceed 30 rounds, thus, overall complexity is O(30*n)=O(n)\\n            let f = (i+1..nums.len()).take_while(|&j|\\n            {\\n                // [3] the main idea of this solution is that while \\n                //     the results of binary \\'or\\' and binary \\'xor\\' coincide\\n                //     we accumulate new 1 bits, thus, extend nice subarray;\\n                used_ = used ^ nums[j]; \\n                used |= nums[j]; \\n                \\n                // [4] once the results of binary \\'or\\' and binary \\'xor\\' are different,\\n                //     then there is some duplicated bit in the candidate nice subarray [i,f)\\n                used == used_\\n            }).last().unwrap_or(i); // [5] take index of the right boundary of sliding window\\n            (f - i + 1) as i32\\n        }).max().unwrap_or(1)       // [6] take max length of sliding window     \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2540570,
                "title": "non-sliding-window-solution-o-32-n-the-maximum-size-of-a-nice-array-is-32",
                "content": "```\\n    int longestNiceSubarray(vector<int>&a) {\\n        int ans=1;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            int OR=a[i];\\n            int j=i+1;\\n            while(j<a.size()&&(OR&a[j])==0)OR|=a[j++];\\n            ans=max(ans,j-i);\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int longestNiceSubarray(vector<int>&a) {\\n        int ans=1;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            int OR=a[i];\\n            int j=i+1;\\n            while(j<a.size()&&(OR&a[j])==0)OR|=a[j++];\\n            ans=max(ans,j-i);\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2538803,
                "title": "c-sliding-window",
                "content": "**Sliding Window With Bit-Manipulation**\\nwe are checking every element with next element\\nand if we getting zero we add the bit of that next number to previous number (in num)\\nand if we not getting zero we delete that bit from that one num (in num)\\nQ. How to check bit of two number is zero?\\nAns.  **AND**    \"**&**\"   bit operator \\nQ. How to add bit of number  ?\\nAns. **OR**  \"**|**\"  bit operator\\nQ. How to delete bit of number ?\\nAns **XOR** \"**^**\" bit operator\\nQ. How to get ans?\\nAns. store the maximum value of sliding window every time\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int num=0;\\n        int j=0;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            while((num & nums[i])!=0){\\n                // XOR operation do 1^1 =0\\n                num^=nums[j++];\\n                // removing number from back\\n            }\\n            // adding bit of every number in num\\n            // OR operation\\n            num|=nums[i];\\n            // getting maximum value with sliding window                i-j+1\\n            ans=max(ans,i-j+1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Up Vote if it is helpful***",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int num=0;\\n        int j=0;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            while((num & nums[i])!=0){\\n                // XOR operation do 1^1 =0\\n                num^=nums[j++];\\n                // removing number from back\\n            }\\n            // adding bit of every number in num\\n            // OR operation\\n            num|=nums[i];\\n            // getting maximum value with sliding window                i-j+1\\n            ans=max(ans,i-j+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535332,
                "title": "c-intuition-and-o-n-sliding-window-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/longest-nice-subarray/\\n    \\n    TC: O(N)\\n    SC: O(1)\\n    \\n    Intuition:\\n    A window is nice if each of the numbers there have unique set bits positions.\\n    Eg: [2,3,1]\\n    2 = 010, 3 = 011, 1 = 001\\n    Nice => [2,1] 010 & 001 => 000\\n    Whereas [3,1] 011 & 001 => 001\\n    \\n    Since any pair within that subarray should be nice as well, that means overall\\n    all the numbers should have unique set bit positions, hence we can just track\\n    whether the subarray is nice or not using a single variable which has OR of all the\\n    nums in that subarray.\\n    \\n    Using sliding window we expand the window and then shrink the window when the window becomes invalid.\\n    To take away the contribution of previous number from the subarray we can use XOR, as XOR of same bits is 0.\\n    So XOR of same number with the window_and will reset the contribution of that number.\\n    \\n    Usually in a max len sliding window, we do expansion and then shrink, but here it might get tricky to do that.\\n    So we first ensure that the window is safe to add the current number by shrinking and then add the current number.\\n*/\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int start = 0, end = 0;\\n        int max_len = 0;\\n        int n = nums.size(), window_nums = 0;\\n        \\n        while(end < n) {\\n            // Check if adding the current number makes the \\n            // window not nice or not\\n            // A window will be nice, if each of the set bits \\n            // of all the numbers are mutually exclusive and when\\n            // that happens the window AND num = 0\\n            while(window_nums & nums[end]) {\\n                // Unset the bits of left side number and shrink the\\n                // window further\\n                window_nums ^= nums[start];\\n                ++start;\\n            }\\n            // expand the window by adding the current number to the window\\n            // We add the set bits of current number by doing the OR operation\\n            window_nums |= nums[end++];\\n            \\n            max_len = max(max_len, end - start);\\n        }\\n        return max_len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/longest-nice-subarray/\\n    \\n    TC: O(N)\\n    SC: O(1)\\n    \\n    Intuition:\\n    A window is nice if each of the numbers there have unique set bits positions.\\n    Eg: [2,3,1]\\n    2 = 010, 3 = 011, 1 = 001\\n    Nice => [2,1] 010 & 001 => 000\\n    Whereas [3,1] 011 & 001 => 001\\n    \\n    Since any pair within that subarray should be nice as well, that means overall\\n    all the numbers should have unique set bit positions, hence we can just track\\n    whether the subarray is nice or not using a single variable which has OR of all the\\n    nums in that subarray.\\n    \\n    Using sliding window we expand the window and then shrink the window when the window becomes invalid.\\n    To take away the contribution of previous number from the subarray we can use XOR, as XOR of same bits is 0.\\n    So XOR of same number with the window_and will reset the contribution of that number.\\n    \\n    Usually in a max len sliding window, we do expansion and then shrink, but here it might get tricky to do that.\\n    So we first ensure that the window is safe to add the current number by shrinking and then add the current number.\\n*/\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int start = 0, end = 0;\\n        int max_len = 0;\\n        int n = nums.size(), window_nums = 0;\\n        \\n        while(end < n) {\\n            // Check if adding the current number makes the \\n            // window not nice or not\\n            // A window will be nice, if each of the set bits \\n            // of all the numbers are mutually exclusive and when\\n            // that happens the window AND num = 0\\n            while(window_nums & nums[end]) {\\n                // Unset the bits of left side number and shrink the\\n                // window further\\n                window_nums ^= nums[start];\\n                ++start;\\n            }\\n            // expand the window by adding the current number to the window\\n            // We add the set bits of current number by doing the OR operation\\n            window_nums |= nums[end++];\\n            \\n            max_len = max(max_len, end - start);\\n        }\\n        return max_len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534834,
                "title": "java-simple-sliding-window",
                "content": "```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        \\n        int i = 0, j = 1, ans = 1;\\n        int windowBits = nums[0];\\n        \\n        while(j < nums.length) {\\n            \\n            if((windowBits & nums[j]) == 0) {\\n                windowBits = windowBits | nums[j];\\n                ans = Math.max(ans, j-i+1);\\n                j++; \\n            }\\n            \\n            else if((windowBits & nums[j]) != 0) {\\n                while((windowBits & nums[j]) != 0 && i < nums.length) {\\n                    windowBits = windowBits ^ nums[i];   i++;\\n                }\\n                windowBits = windowBits | nums[j];  j++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        \\n        int i = 0, j = 1, ans = 1;\\n        int windowBits = nums[0];\\n        \\n        while(j < nums.length) {\\n            \\n            if((windowBits & nums[j]) == 0) {\\n                windowBits = windowBits | nums[j];\\n                ans = Math.max(ans, j-i+1);\\n                j++; \\n            }\\n            \\n            else if((windowBits & nums[j]) != 0) {\\n                while((windowBits & nums[j]) != 0 && i < nums.length) {\\n                    windowBits = windowBits ^ nums[i];   i++;\\n                }\\n                windowBits = windowBits | nums[j];  j++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534644,
                "title": "sliding-window-bit-manipulation-easy-understanding-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        /*\\n          How window will move?\\n            For AND of two numbers to be zero, no two bits should be set in the same \\n            place. If we expand the same logic to the window,all elements inside the\\n            same window must have their bits at unique place.\\n            \\n            How can we check if the elements of the window have unique bits?\\n            \\n            Let\\'s suppose we have a window of size i and now we want to check element\\n            i+1 will be valid or not. Assume we have a variable totalor which contains\\n            the OR of all the elements in the window. In other words, it will contain\\n            all the already set bits from the elements of the window. Now if i do a \\n            bitwise AND of totalor and a[i+1], it should be zero which means that the\\n            element do not contain any repetitive bit set.\\n            \\n            If it\\'s not equal to zero, then we need to shrink the window, here by shrinking\\n            i mean remove all those bits, which are set by the left pointer of window. \\n            That\\'s what XOR does. It will un-set the bits in totalor which are set by \\n            left pointer.\\n            \\n          How to find the answer?\\n            It can be easily done by using a max variable which will hold the maxiumum \\n            range found till now\\n        */\\n        int totalor = 0, sl=0, ans=0;\\n        for(int fs=0; fs<nums.size();++fs){\\n            while( (totalor & nums[fs]) !=0){\\n                //window needs to be shrinked\\n                totalor ^= nums[sl];\\n                sl++;\\n            }\\n            //window needs to be expanded\\n            totalor^=nums[fs];\\n            ans = max(ans,fs-sl+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        /*\\n          How window will move?\\n            For AND of two numbers to be zero, no two bits should be set in the same \\n            place. If we expand the same logic to the window,all elements inside the\\n            same window must have their bits at unique place.\\n            \\n            How can we check if the elements of the window have unique bits?\\n            \\n            Let\\'s suppose we have a window of size i and now we want to check element\\n            i+1 will be valid or not. Assume we have a variable totalor which contains\\n            the OR of all the elements in the window. In other words, it will contain\\n            all the already set bits from the elements of the window. Now if i do a \\n            bitwise AND of totalor and a[i+1], it should be zero which means that the\\n            element do not contain any repetitive bit set.\\n            \\n            If it\\'s not equal to zero, then we need to shrink the window, here by shrinking\\n            i mean remove all those bits, which are set by the left pointer of window. \\n            That\\'s what XOR does. It will un-set the bits in totalor which are set by \\n            left pointer.\\n            \\n          How to find the answer?\\n            It can be easily done by using a max variable which will hold the maxiumum \\n            range found till now\\n        */\\n        int totalor = 0, sl=0, ans=0;\\n        for(int fs=0; fs<nums.size();++fs){\\n            while( (totalor & nums[fs]) !=0){\\n                //window needs to be shrinked\\n                totalor ^= nums[sl];\\n                sl++;\\n            }\\n            //window needs to be expanded\\n            totalor^=nums[fs];\\n            ans = max(ans,fs-sl+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534331,
                "title": "sliding-window-on-each-bit",
                "content": "This problem can just be seen as an extension of the problem to find largest subarray size with maximum sum less than or equal to 1. Here, we just need to check that condition for every bit.\\n\\n```\\n    bool ok(vector<int> &f){\\n        for(auto x:f)if(x>1)return false;\\n        return true;\\n    }\\n    \\n    int longestNiceSubarray(vector<int>& nums) {\\n        vector<vector<int>> bits(nums.size(), vector<int>(32, 0));\\n        for(int i = 0; i<nums.size(); i++){\\n            int k = 0, temp = nums[i];\\n            while(temp){\\n                bits[i][k] = temp%2;\\n                temp = temp/2;\\n                k++;\\n            }\\n        }\\n        int ans = 1;\\n        vector<int> f(32, 0);\\n        int i = 0, j = 0;\\n        while(j<nums.size()){\\n            for(int k = 0; k<32; k++)f[k] += bits[j][k];\\n            while(!ok(f)){\\n                for(int k = 0; k<32; k++)f[k] = f[k] - bits[i][k];\\n                i++;\\n            }\\n            ans = max(ans, j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n```\\n\\nTime Complexity: O(n*32)",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\n    bool ok(vector<int> &f){\\n        for(auto x:f)if(x>1)return false;\\n        return true;\\n    }\\n    \\n    int longestNiceSubarray(vector<int>& nums) {\\n        vector<vector<int>> bits(nums.size(), vector<int>(32, 0));\\n        for(int i = 0; i<nums.size(); i++){\\n            int k = 0, temp = nums[i];\\n            while(temp){\\n                bits[i][k] = temp%2;\\n                temp = temp/2;\\n                k++;\\n            }\\n        }\\n        int ans = 1;\\n        vector<int> f(32, 0);\\n        int i = 0, j = 0;\\n        while(j<nums.size()){\\n            for(int k = 0; k<32; k++)f[k] += bits[j][k];\\n            while(!ok(f)){\\n                for(int k = 0; k<32; k++)f[k] = f[k] - bits[i][k];\\n                i++;\\n            }\\n            ans = max(ans, j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2533683,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        # using sliding window\\n        l = ans = acum = 0\\n        \\n        for r, num in enumerate(nums):\\n            while (acum & num) != 0:\\n                acum = acum ^ nums[l]\\n                l += 1\\n            acum ^= num\\n            ans = max(ans, r-l+1)\\n        return ans\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        # using sliding window\\n        l = ans = acum = 0\\n        \\n        for r, num in enumerate(nums):\\n            while (acum & num) != 0:\\n                acum = acum ^ nums[l]\\n                l += 1\\n            acum ^= num\\n            ans = max(ans, r-l+1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533408,
                "title": "sliding-window-certain-level-of-understanding-in-bit-manipulation-required",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int AND = 0, i = 0, ans = 0;\\n        for (int j = 0; j < nums.size(); ++ j) {\\n            while (AND & nums[j]) AND ^= nums[i ++];\\n            AND |= nums[j];\\n            ans = max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int AND = 0, i = 0, ans = 0;\\n        for (int j = 0; j < nums.size(); ++ j) {\\n            while (AND & nums[j]) AND ^= nums[i ++];\\n            AND |= nums[j];\\n            ans = max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531997,
                "title": "javascript-brute-force-151ms",
                "content": "```\\nconst longestNiceSubarray = (a) => {\\n    let n = a.length, res = 1;\\n    for (let i = 0; i < n; i++) {\\n        let cur = a[i];\\n        for (let j = i + 1; j < n && ((cur & a[j]) == 0); j++) {\\n            cur |= a[j];\\n            res = Math.max(res, j - i + 1);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst longestNiceSubarray = (a) => {\\n    let n = a.length, res = 1;\\n    for (let i = 0; i < n; i++) {\\n        let cur = a[i];\\n        for (let j = i + 1; j < n && ((cur & a[j]) == 0); j++) {\\n            cur |= a[j];\\n            res = Math.max(res, j - i + 1);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2531559,
                "title": "python-easy-bit-manipulation-sliding-window",
                "content": "# Sliding Window\\n## Time -> O(32*N)\\n## Space -> O(32)\\n```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        bit = {}\\n        N = len(nums)\\n        for i in range(1,32):\\n            bit[i] = 0\\n        last = 0\\n        ans = 0\\n        for first in range(N):\\n            flag = True\\n            currE = nums[first]\\n            for j in range(1,32):\\n                if currE & 1<<(j-1):\\n                    bit[j] += 1\\n                    if bit[j] > 1:\\n                        flag = False\\n            if flag:\\n                ans = max(ans,first-last+1)\\n            else:\\n                while True:\\n                    nxt = nums[last]\\n                    if last > N:\\n                        break\\n                    last += 1\\n                    for j in range(1,32):\\n                        if nxt & 1<<(j-1):\\n                            bit[j] -=1\\n                    f = True\\n                    for j in range(1,32):\\n                        if bit[j] > 1:\\n                            f = False\\n                            break\\n                    if f:\\n                        break\\n                    \\n        return ans\\n```\\n\\n### \\uD83D\\uDE02 Random Dev Meme\\n<img src=\"https://random-memer.herokuapp.com/\" width=\"400px\"/>",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        bit = {}\\n        N = len(nums)\\n        for i in range(1,32):\\n            bit[i] = 0\\n        last = 0\\n        ans = 0\\n        for first in range(N):\\n            flag = True\\n            currE = nums[first]\\n            for j in range(1,32):\\n                if currE & 1<<(j-1):\\n                    bit[j] += 1\\n                    if bit[j] > 1:\\n                        flag = False\\n            if flag:\\n                ans = max(ans,first-last+1)\\n            else:\\n                while True:\\n                    nxt = nums[last]\\n                    if last > N:\\n                        break\\n                    last += 1\\n                    for j in range(1,32):\\n                        if nxt & 1<<(j-1):\\n                            bit[j] -=1\\n                    f = True\\n                    for j in range(1,32):\\n                        if bit[j] > 1:\\n                            f = False\\n                            break\\n                    if f:\\n                        break\\n                    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530686,
                "title": "c-sliding-window-with-bit-manipulation",
                "content": "**The bitwise AND of all of pairs of a subarray will be zero only when there is no set bit common between any of them**\\nFor example : [3, 8, 48]\\n3 :   000011\\n8 :   001000\\n48 : 110000\\n**If we add the corresponding bits of the elements of the array, no sum would exceed 1**\\nFor above example their sum would be 111011\\nSo the idea here is to create 32 sized array to store the sum of corresponding bits of the elements and apply the sliding window technique.\\nWe will keep on adding the elements till the sum of corresponding bits is  <=1, if it exceeds 1 we will slide our window till it again becomes <=1\\n\\n**Time Complexity : O(n)**\\n**Space Complexity: O(1)** (we are always creating a vector of size 32)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> bitForm(int n){ // function to represent a number in binary form \\n        vector<int> bits(32, 0);\\n        int x = 31;\\n        while(n){\\n            bits[x--] = n%2;\\n            n/=2;\\n        }\\n        return bits;\\n    }\\n    \\n    void add(vector<int> &x, vector<int> y){ // function to add corresponding bits of a number to the existing sum of bits\\n        for(int i=0;i<32;i++){\\n            x[i]+= y[i];\\n        }\\n    }\\n    \\n    void sub(vector<int> &x, vector<int> y){ // function to substract corresponding bits of a number from the existing sum of bits\\n        for(int i=0;i<32;i++){\\n            x[i]-= y[i];\\n        }\\n    }\\n    \\n    bool check(vector<int> &v){ // function to check whether sum of any corresponding bit exceeds 1\\n        for(int i=0;i<32;i++){\\n            if(v[i] > 1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 1;\\n        int start = 0, end = 0;\\n        vector<int> v(32, 0);\\n        while(end < n){\\n            add(v, bitForm(nums[end])); // adding an element into our window\\n            while(start < end && check(v) == false){ // sliding window till our condition is satisfied\\n                sub(v, bitForm(nums[start]));\\n                start++;\\n            }\\n            ans = max(ans, end-start+1); \\n            end++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> bitForm(int n){ // function to represent a number in binary form \\n        vector<int> bits(32, 0);\\n        int x = 31;\\n        while(n){\\n            bits[x--] = n%2;\\n            n/=2;\\n        }\\n        return bits;\\n    }\\n    \\n    void add(vector<int> &x, vector<int> y){ // function to add corresponding bits of a number to the existing sum of bits\\n        for(int i=0;i<32;i++){\\n            x[i]+= y[i];\\n        }\\n    }\\n    \\n    void sub(vector<int> &x, vector<int> y){ // function to substract corresponding bits of a number from the existing sum of bits\\n        for(int i=0;i<32;i++){\\n            x[i]-= y[i];\\n        }\\n    }\\n    \\n    bool check(vector<int> &v){ // function to check whether sum of any corresponding bit exceeds 1\\n        for(int i=0;i<32;i++){\\n            if(v[i] > 1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 1;\\n        int start = 0, end = 0;\\n        vector<int> v(32, 0);\\n        while(end < n){\\n            add(v, bitForm(nums[end])); // adding an element into our window\\n            while(start < end && check(v) == false){ // sliding window till our condition is satisfied\\n                sub(v, bitForm(nums[start]));\\n                start++;\\n            }\\n            ans = max(ans, end-start+1); \\n            end++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530065,
                "title": "rust-double-loops",
                "content": "~~~\\nimpl Solution {\\n    pub fn longest_nice_subarray(nums: Vec<i32>) -> i32 {\\n        let (n, mut ret) = (nums.len(), 1);\\n        \\n        for i in 0..n {\\n            let mut temp = 0i32;\\n            for j in 0..n { // this loop ends quickly\\n                if  i + j == n || (temp & nums[i + j]) != 0 { break }\\n                temp = temp | nums[i + j];\\n                ret = ret.max(j + 1);\\n            }\\n        }\\n        \\n        ret as i32\\n    }\\n}\\n~~~",
                "solutionTags": [],
                "code": "~~~\\nimpl Solution {\\n    pub fn longest_nice_subarray(nums: Vec<i32>) -> i32 {\\n        let (n, mut ret) = (nums.len(), 1);\\n        \\n        for i in 0..n {\\n            let mut temp = 0i32;\\n            for j in 0..n { // this loop ends quickly\\n                if  i + j == n || (temp & nums[i + j]) != 0 { break }\\n                temp = temp | nums[i + j];\\n                ret = ret.max(j + 1);\\n            }\\n        }\\n        \\n        ret as i32\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2529777,
                "title": "c-sliding-window-max-answer-cannot-exceed-32",
                "content": "Since each of the 32 bits can appear at max once in the subarray we are considering hence our answer can never exceed 32 (No zeroes in the array hence no repetition either). We maintain a mask which represents what all bit we found and we use sliding window concept to check for the longest subarray.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int mask=0, l=0, ans=0;\\n        for(int r=0; r<nums.size(); r++) {\\n            while((mask & nums[r])) mask^=nums[l++];\\n            mask|=nums[r];\\n            ans=max(ans,r-l+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int mask=0, l=0, ans=0;\\n        for(int r=0; r<nums.size(); r++) {\\n            while((mask & nums[r])) mask^=nums[l++];\\n            mask|=nums[r];\\n            ans=max(ans,r-l+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529352,
                "title": "c-observation-brute-force-bits",
                "content": "Since AND of ANY two elements should be 0, thus every bit should have only one contributor.\\ni.e. 2[0010],4[0100],8[1000] is an example because all have distinct set bits.\\nThus we have to break when any element repeats at any position which already has a set bit, now the main catch in brute force is since 1e9 has at max 31 distinct bits so we can have our answer at most 31, and that will be when we have distinct powers of 2 (from 0 to 30), now we can easily run a brute force solution which runs from i to min(i+31,n) because in the best possible case any bit would repeat at 32th element from current index.\\n```\\nint final=1,n=nums.size();\\n        for(int i=0;i<n;i++) {\\n            bool cur=0;\\n            vector<int> bit(31,0);\\n            for(int j=i;j<min(i+31,n);j++) {\\n                int val=nums[j];\\n                fk(32) {\\n                    if(val&(1<<k)) {\\n                        if(bit[k]) { cur=1; break;}\\n                            bit[k]=1;\\n                        }\\n                    }\\n                if(cur) break;\\n                final=max(final,j-i+1);\\n                }\\n            }\\n        return final;\\n\\t\\t\\nTC- O(n). 31. 31",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "Since AND of ANY two elements should be 0, thus every bit should have only one contributor.\\ni.e. 2[0010],4[0100],8[1000] is an example because all have distinct set bits.\\nThus we have to break when any element repeats at any position which already has a set bit, now the main catch in brute force is since 1e9 has at max 31 distinct bits so we can have our answer at most 31, and that will be when we have distinct powers of 2 (from 0 to 30), now we can easily run a brute force solution which runs from i to min(i+31,n) because in the best possible case any bit would repeat at 32th element from current index.\\n```\\nint final=1,n=nums.size();\\n        for(int i=0;i<n;i++) {\\n            bool cur=0;\\n            vector<int> bit(31,0);\\n            for(int j=i;j<min(i+31,n);j++) {\\n                int val=nums[j];\\n                fk(32) {\\n                    if(val&(1<<k)) {\\n                        if(bit[k]) { cur=1; break;}\\n                            bit[k]=1;\\n                        }\\n                    }\\n                if(cur) break;\\n                final=max(final,j-i+1);\\n                }\\n            }\\n        return final;\\n\\t\\t\\nTC- O(n). 31. 31",
                "codeTag": "Unknown"
            },
            {
                "id": 2529315,
                "title": "javascript-sliding-window-explained",
                "content": "Take mask. The mask will have all the bits 1 which were found set in the window sub array under consideration.\\n\\xA0 \\xA0If the next element is having any common bit set to one with mask then we can\\'t take the next element as it will create a none 0 value for AND with an existing element in the sub array. \\n\\xA0 \\xA0 We keep removing elements from the left side of the existing sub array until we don\\'t have any common bit set to 1 in mask and the current element. \\n\\xA0 \\xA0 After the removal of values we will add take the bits of the current element in the mask. \\n    To remove the set bits of any previous number (nums[j]) from mask we will do operation (mask & ~nums[j])\\n\\xA0 \\xA0 In each iteration, we will track of the maximum length of the valid sub array and return it as the answer.\\n\\t\\n\\t\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestNiceSubarray = function(nums) {\\n    let mask=0,j=0,maxWindow=0;\\n    for(let i=0;i<nums.length;i++){\\n        while((mask & nums[i])!==0){//Need to reduce the window\\n            mask = mask & ~nums[j];\\n            j++;\\n        }\\n        mask = mask|nums[i];\\n        maxWindow = Math.max(maxWindow,i-j+1);\\n    }\\n    return maxWindow;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestNiceSubarray = function(nums) {\\n    let mask=0,j=0,maxWindow=0;\\n    for(let i=0;i<nums.length;i++){\\n        while((mask & nums[i])!==0){//Need to reduce the window\\n            mask = mask & ~nums[j];\\n            j++;\\n        }\\n        mask = mask|nums[i];\\n        maxWindow = Math.max(maxWindow,i-j+1);\\n    }\\n    return maxWindow;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2529212,
                "title": "binary-search-sliding-window-c-easy",
                "content": "We use binary search to get a particular window size. We then check if we can get a subarray in *nums* that can give us the required answer which is, every pair in the subarray has a bitwise and of 0. \\nWe use XOR operator to see which bits are set in the previous elements of the chosen window. So if any number is in the window, such that the bitwise AND is not 0, then we break from that window, and move on to the next window of that particular length. \\nI find this binary search method more intuitive and easier than the other solutions. We first choose a window size, which could lie between 0 and the size of the array. If we find a subarray that satisfies the given condition, we then store this in the answer and move to the next half to see if we can find a longer subarray as we need to find the longest possible answer.\\n```\\nclass Solution {\\n    bool check(long long int k,vector<int> &nums){\\n        //idea is to keep a mask that records which bits are set in a certain window\\n        if(k<=1)\\n            return true;\\n        for(int i=0;i<nums.size()-k+1;++i){\\n            long long int mask=nums[i];\\n            for(int j=i+1;j<i+k;++j){\\n                if((mask & nums[j])!=0)\\n                    break;\\n                mask=mask^nums[j];\\n                if(j==(i+k-1))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        long long int start=0;\\n        long long int end=nums.size();\\n        long long int ans=1;\\n        long long int mid;\\n        while(start<=end){\\n            mid=start+(end-start)/2;\\n            \\n            if(check(mid,nums)){\\n                ans=mid;\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    bool check(long long int k,vector<int> &nums){\\n        //idea is to keep a mask that records which bits are set in a certain window\\n        if(k<=1)\\n            return true;\\n        for(int i=0;i<nums.size()-k+1;++i){\\n            long long int mask=nums[i];\\n            for(int j=i+1;j<i+k;++j){\\n                if((mask & nums[j])!=0)\\n                    break;\\n                mask=mask^nums[j];\\n                if(j==(i+k-1))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        long long int start=0;\\n        long long int end=nums.size();\\n        long long int ans=1;\\n        long long int mid;\\n        while(start<=end){\\n            mid=start+(end-start)/2;\\n            \\n            if(check(mid,nums)){\\n                ans=mid;\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529173,
                "title": "my-java-solution",
                "content": "***Time Complexity: O(N * B), Where \\'B\\' is the value of bound[0 <= B <= N - 1]***\\n***Space Complexity: O(N)***\\n```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int N = nums.length;\\n        int len = 0, bound = 0;\\n        int[] temp = new int[N - 1];\\n        for(int i = N - 2 ;i>=0 ;i--) {\\n            int j = i + 1;\\n            for(int k = 0 ;k <= bound ;k++)\\n                if((nums[i] & nums[j++]) == 0) {\\n                    temp[i]++;\\n                } else {\\n                    break;\\n                }\\n            bound = temp[i];\\n        }\\n        for(int val : temp) len = Math.max(len, val);\\n        return len + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int N = nums.length;\\n        int len = 0, bound = 0;\\n        int[] temp = new int[N - 1];\\n        for(int i = N - 2 ;i>=0 ;i--) {\\n            int j = i + 1;\\n            for(int k = 0 ;k <= bound ;k++)\\n                if((nums[i] & nums[j++]) == 0) {\\n                    temp[i]++;\\n                } else {\\n                    break;\\n                }\\n            bound = temp[i];\\n        }\\n        for(int val : temp) len = Math.max(len, val);\\n        return len + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528792,
                "title": "wondering-why-xor-works",
                "content": "**Why XOR works:**\\n\\n1. XOR of two same number is zero, means X ^ X = 0\\n2. let\\'s say sub array has 5 elements (A, B, C, D, E)\\n\\t - We know `A | B | C | D | E = X`, now to remove any element and find OR again will take **O(N) time in brute force way**. But with XOR it will be in **O(1)**\\n\\t -  Means, `B | C | D | E = X ^ A`\\n\\n**Proof**\\n\\nlet\\' s say OR of 5 elements in X, and we want to find out XOR of last 4 in the window. we can simply XOR A on both side.\\n```\\nA | B | C | D | E = X\\nA | B | C | D | E ^ A = X ^ A\\nB | C | D | E = X ^ A\\n```\\n\\n\\nSimilar properties are used here: [136. Single Number](https://leetcode.com/problems/single-number/discuss/2528739/XOR-all-number-or-O(N)-or-Java)\\n\\n\\n**Java Code:**\\n\\n```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int ans = 1;\\n        int i = 0;\\n        int j = 0;\\n        long or = 0;\\n\\n        while(i < nums.length) {\\n            if(i==j) {\\n                or = (or | nums[i]);\\n                i++;\\n                continue;\\n            }\\n            \\n            if((or & nums[i]) == 0) {\\n                ans = Math.max(ans, i-j+1);\\n                or = (or | nums[i]);\\n                i++;\\n            }\\n            else {\\n                while(j < i && (or & nums[i]) != 0) {\\n                    or = (or ^ nums[j]);\\n                    j++;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nA | B | C | D | E = X\\nA | B | C | D | E ^ A = X ^ A\\nB | C | D | E = X ^ A\\n```\n```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int ans = 1;\\n        int i = 0;\\n        int j = 0;\\n        long or = 0;\\n\\n        while(i < nums.length) {\\n            if(i==j) {\\n                or = (or | nums[i]);\\n                i++;\\n                continue;\\n            }\\n            \\n            if((or & nums[i]) == 0) {\\n                ans = Math.max(ans, i-j+1);\\n                or = (or | nums[i]);\\n                i++;\\n            }\\n            else {\\n                while(j < i && (or & nums[i]) != 0) {\\n                    or = (or ^ nums[j]);\\n                    j++;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528495,
                "title": "java-3ms-solution-100-time-and-space-sliding-window",
                "content": "\\tclass Solution {\\n\\t\\tpublic int longestNiceSubarray(int[] nums) {\\n\\t\\t\\tif(nums.length==1) return 1;\\n\\t\\t\\tint ans=1;        \\n\\t\\t\\tint i=0;\\n\\t\\t\\tint j=1;\\n\\t\\t\\twhile(j<nums.length){\\n\\t\\t\\t\\tint tmp1 = i;\\n\\t\\t\\t\\twhile(tmp1<j){\\n\\t\\t\\t\\t\\tint tmp = tmp1+1;\\n\\t\\t\\t\\t\\twhile(tmp<=j){\\n\\t\\t\\t\\t\\t\\tif((nums[tmp1] & nums[tmp]) != 0) {\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\ttmp++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(tmp<=j) break;\\n\\t\\t\\t\\t\\ttmp1++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t   \\n\\t\\t\\t\\tif(tmp1>=j){\\n\\t\\t\\t\\t\\tans = Math.max(ans,j-i+1);\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;   \\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\t\\tpublic int longestNiceSubarray(int[] nums) {\\n\\t\\t\\tif(nums.length==1) return 1;\\n\\t\\t\\tint ans=1;        \\n\\t\\t\\tint i=0;\\n\\t\\t\\tint j=1;\\n\\t\\t\\twhile(j<nums.length){\\n\\t\\t\\t\\tint tmp1 = i;\\n\\t\\t\\t\\twhile(tmp1<j){\\n\\t\\t\\t\\t\\tint tmp = tmp1+1;\\n\\t\\t\\t\\t\\twhile(tmp<=j){\\n\\t\\t\\t\\t\\t\\tif((nums[tmp1] & nums[tmp]) != 0) {\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2528430,
                "title": "c-easy-no-sliding-window-o-n-32",
                "content": "You Just have to see the last two positions of every bit where they are set, that will be sufficient to get our answer.\\n\\n\\nint longestNiceSubarray(vector<int>& a) {\\n        vector<pair<int,int>> v(32,{-1,-1});\\n        int ans=0,n=a.size();\\n        for(int i=0;i<n;i++){\\n            int mn=1e9;\\n            for(int j=0;j<32;j++){\\n                if((a[i]>>j)&1){\\n                    mn=min(mn,i-v[j].first);\\n                    v[j].second=v[j].first;\\n                    v[j].first=i;\\n                }\\n                 else   \\n                 mn=min(mn,i-v[j].second);\\n               \\n            }\\n            ans=max(ans,mn);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "You Just have to see the last two positions of every bit where they are set, that will be sufficient to get our answer.\\n\\n\\nint longestNiceSubarray(vector<int>& a) {\\n        vector<pair<int,int>> v(32,{-1,-1});\\n        int ans=0,n=a.size();\\n        for(int i=0;i<n;i++){\\n            int mn=1e9;\\n            for(int j=0;j<32;j++){\\n                if((a[i]>>j)&1){\\n                    mn=min(mn,i-v[j].first);\\n                    v[j].second=v[j].first;\\n                    v[j].first=i;\\n                }\\n                 else   \\n                 mn=min(mn,i-v[j].second);\\n               \\n            }\\n            ans=max(ans,mn);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2527934,
                "title": "c-sliding-window",
                "content": "We make use of sliding window approach for this problem. To ensure that the bitwise AND of each pair of numbers is equal to 0, we have to make sure that there is at most one number in the window which has 1 at each  bit position. If more than one number has a 1 at the same position, then their bitwise AND will become non-zero.   \\n```\\nclass Solution {\\npublic:\\n    void addFreq(int num,vector<int> &freq){\\n        for(int j=0;j<32;j++){\\n            if(num&(1<<j))\\n                freq[j]++;\\n        }\\n    }\\n    void subFreq(int num,vector<int> &freq){\\n        for(int j=0;j<32;j++){\\n            if(num&(1<<j))\\n                freq[j]--;\\n        }\\n    }\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> freq(32,0);\\n        int ans = 1;\\n        for(int r=0,l=0;r<n;r++){\\n            addFreq(nums[r],freq);\\n            for(int j=0;j<32;j++){\\n                while(freq[j]>1)\\n                    subFreq(nums[l++],freq);\\n            }\\n            ans = max(ans,r-l+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void addFreq(int num,vector<int> &freq){\\n        for(int j=0;j<32;j++){\\n            if(num&(1<<j))\\n                freq[j]++;\\n        }\\n    }\\n    void subFreq(int num,vector<int> &freq){\\n        for(int j=0;j<32;j++){\\n            if(num&(1<<j))\\n                freq[j]--;\\n        }\\n    }\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> freq(32,0);\\n        int ans = 1;\\n        for(int r=0,l=0;r<n;r++){\\n            addFreq(nums[r],freq);\\n            for(int j=0;j<32;j++){\\n                while(freq[j]>1)\\n                    subFreq(nums[l++],freq);\\n            }\\n            ans = max(ans,r-l+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527920,
                "title": "recursive-1000ms",
                "content": "```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        HashSet<Integer>[] map = new HashSet[nums.length];\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            map[i] = new HashSet<>();\\n\\n            int cur = nums[i];\\n            int j = 0;\\n            while (cur > 0) {\\n                if ((cur & 1) == 1)\\n                    map[i].add(j);\\n\\n                j++;\\n                cur >>= 1;\\n            }\\n        }\\n\\n        int max = 0;\\n        for (int i = 0; i < nums.length; i++)\\n            max = Math.max(max, helper(i, map, new boolean[30]));\\n\\n        return max;\\n    }\\n\\n    int helper(int index, HashSet<Integer>[] map, boolean[] curMap) {\\n        if (index == map.length)\\n            return 0;\\n\\n        for (int item : map[index]) {\\n            if (curMap[item])\\n                return 0;\\n            curMap[item] = true;\\n        }\\n\\n        return 1 + helper(index + 1, map, curMap);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        HashSet<Integer>[] map = new HashSet[nums.length];\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            map[i] = new HashSet<>();\\n\\n            int cur = nums[i];\\n            int j = 0;\\n            while (cur > 0) {\\n                if ((cur & 1) == 1)\\n                    map[i].add(j);\\n\\n                j++;\\n                cur >>= 1;\\n            }\\n        }\\n\\n        int max = 0;\\n        for (int i = 0; i < nums.length; i++)\\n            max = Math.max(max, helper(i, map, new boolean[30]));\\n\\n        return max;\\n    }\\n\\n    int helper(int index, HashSet<Integer>[] map, boolean[] curMap) {\\n        if (index == map.length)\\n            return 0;\\n\\n        for (int item : map[index]) {\\n            if (curMap[item])\\n                return 0;\\n            curMap[item] = true;\\n        }\\n\\n        return 1 + helper(index + 1, map, curMap);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527828,
                "title": "c-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int n=v.size();\\n        vector<vector<int>> pre(n,vector<int>(32,0));\\n        for(int i=0;i<32;i++){\\n            if(v[0]&(1<<i)) pre[0][i]=1; \\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<32;j++){\\n                if(v[i]&(1<<j)) pre[i][j]=pre[i-1][j]+1;\\n                else pre[i][j]=pre[i-1][j];\\n            }\\n        }\\n        int ans=1;\\n        int i=0,j=1;\\n        while(j<n){\\n            while(i<=j){\\n                bool ok=true;\\n                vector<int> t(32,0);\\n                for(int k=0;k<32;k++) t[k]=pre[j-1][k]-((i-1>=0)?pre[i-1][k]:0);\\n                vector<int> t1(32,0);\\n                for(int k=0;k<32;k++){\\n                    if(v[j]&(1<<k)) t1[k]=1;\\n                }\\n                for(int k=0;k<32;k++){\\n                    if(t[k]&t1[k]) {ok=false;break;}\\n                }\\n                if(ok) {ans=max(ans,j-i+1);break;}\\n                else i++;\\n            }j++;\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int n=v.size();\\n        vector<vector<int>> pre(n,vector<int>(32,0));\\n        for(int i=0;i<32;i++){\\n            if(v[0]&(1<<i)) pre[0][i]=1; \\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<32;j++){\\n                if(v[i]&(1<<j)) pre[i][j]=pre[i-1][j]+1;\\n                else pre[i][j]=pre[i-1][j];\\n            }\\n        }\\n        int ans=1;\\n        int i=0,j=1;\\n        while(j<n){\\n            while(i<=j){\\n                bool ok=true;\\n                vector<int> t(32,0);\\n                for(int k=0;k<32;k++) t[k]=pre[j-1][k]-((i-1>=0)?pre[i-1][k]:0);\\n                vector<int> t1(32,0);\\n                for(int k=0;k<32;k++){\\n                    if(v[j]&(1<<k)) t1[k]=1;\\n                }\\n                for(int k=0;k<32;k++){\\n                    if(t[k]&t1[k]) {ok=false;break;}\\n                }\\n                if(ok) {ans=max(ans,j-i+1);break;}\\n                else i++;\\n            }j++;\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527688,
                "title": "easy-to-understand",
                "content": "```\\n**class Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        int i=0;\\n        int j=0;\\n        int takingand=0;\\n        while (j<n)\\n        {\\n            int andd=takingand&nums[j];\\n            if (andd==0)\\n            {\\n                ans=max(ans,j-i+1);\\n                takingand|=nums[j];\\n                j++;\\n            }\\n            else\\n            {\\n                takingand^=nums[i];\\n                i++;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};**\\n\\n\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\n**class Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        int i=0;\\n        int j=0;\\n        int takingand=0;\\n        while (j<n)\\n        {\\n            int andd=takingand&nums[j];\\n            if (andd==0)\\n            {\\n                ans=max(ans,j-i+1);\\n                takingand|=nums[j];\\n                j++;\\n            }\\n            else\\n            {\\n                takingand^=nums[i];\\n                i++;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};**\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527586,
                "title": "rust-two-pointers-with-comments",
                "content": "This is my unaltered submission for the 2022-09-04 Weekly Contest 309. I use a two pointer solution and keep track of the maximum window length. The `mask` are the ORed bits of all the numbers of the current window. I add to the right as long as the mask doesn\\'t have any set bits in the same positions as the mask (no collisions). If I have collisions, I remove from the left and XOR out the bits for these numbers from the mask.\\n\\nComments: I like bit twiddling and two pointer solutions, so this was a pleasant surprise as the third problem in the contest.\\n\\nTime: O(n)\\nSpace: O(1)\\n\\n```\\nimpl Solution {\\n    pub fn longest_nice_subarray(nums: Vec<i32>) -> i32 {\\n        let mut left = 0;\\n        let mut max_len = 1;\\n        let mut mask = nums[0];\\n        for (right, num) in nums.iter().enumerate().skip(1) {\\n            while *num & mask != 0 {\\n                mask ^= nums[left];\\n                left += 1;\\n            }\\n            mask |= *num;\\n            max_len = (right - left + 1).max(max_len);\\n        }\\n        max_len as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn longest_nice_subarray(nums: Vec<i32>) -> i32 {\\n        let mut left = 0;\\n        let mut max_len = 1;\\n        let mut mask = nums[0];\\n        for (right, num) in nums.iter().enumerate().skip(1) {\\n            while *num & mask != 0 {\\n                mask ^= nums[left];\\n                left += 1;\\n            }\\n            mask |= *num;\\n            max_len = (right - left + 1).max(max_len);\\n        }\\n        max_len as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527550,
                "title": "go-sliding-window-bitwise-time-o-n-space-o-1",
                "content": "`&nums[r]` to verify if the nums at `l` can match with condition\\n`^=` to remove the combine of nums at `l`\\n`|=` to combine with nums as `r`\\n\\n```go\\nfunc longestNiceSubarray(nums []int) int {\\n\\tn := len(nums)\\n\\tl, r := 0, 0\\n\\tcurMask := 0\\n\\tmax := 1\\n\\tfor r < n {\\n\\t\\tfor (l < r) && (curMask&nums[r] != 0) {\\n\\t\\t\\tcurMask ^= nums[l]\\n\\t\\t\\tl++\\n\\t\\t}\\n\\t\\tcurMask |= nums[r]\\n\\t\\tr++\\n\\t\\tif max < r-l {\\n\\t\\t\\tmax = r - l\\n\\t\\t}\\n\\t}\\n\\treturn max\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc longestNiceSubarray(nums []int) int {\\n\\tn := len(nums)\\n\\tl, r := 0, 0\\n\\tcurMask := 0\\n\\tmax := 1\\n\\tfor r < n {\\n\\t\\tfor (l < r) && (curMask&nums[r] != 0) {\\n\\t\\t\\tcurMask ^= nums[l]\\n\\t\\t\\tl++\\n\\t\\t}\\n\\t\\tcurMask |= nums[r]\\n\\t\\tr++\\n\\t\\tif max < r-l {\\n\\t\\t\\tmax = r - l\\n\\t\\t}\\n\\t}\\n\\treturn max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527413,
                "title": "javascript-solution-simple-100-runtime-stack",
                "content": "![image](https://assets.leetcode.com/users/images/ea41a227-a759-412e-8b1d-8c19af748dc8_1662264328.188127.png)\\n\\n\\n```\\nvar longestNiceSubarray = function(nums) {\\n    let max = 1;\\n    let stack = [];\\n    for(let i =0;i<nums.length;i++){\\n        if(nums[i]&nums[i+1]) continue;\\n        stack.push(nums[i])\\n        for(let j =i+1;j<nums.length;j++){\\n            let state = true;\\n            for(el of stack){\\n                if(el&nums[j]){\\n                    state=false;\\n                    break;\\n                }\\n            }\\n            if(state) {\\n                stack.push(nums[j]);\\n                max = Math.max(max,stack.length);\\n            }\\n            else{\\n                stack = []\\n                break;\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Sliding Window"
                ],
                "code": "```\\nvar longestNiceSubarray = function(nums) {\\n    let max = 1;\\n    let stack = [];\\n    for(let i =0;i<nums.length;i++){\\n        if(nums[i]&nums[i+1]) continue;\\n        stack.push(nums[i])\\n        for(let j =i+1;j<nums.length;j++){\\n            let state = true;\\n            for(el of stack){\\n                if(el&nums[j]){\\n                    state=false;\\n                    break;\\n                }\\n            }\\n            if(state) {\\n                stack.push(nums[j]);\\n                max = Math.max(max,stack.length);\\n            }\\n            else{\\n                stack = []\\n                break;\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527407,
                "title": "c-sliding-window-hindi-video-explanation",
                "content": "In case you prefer video: https://youtu.be/Y3BdRMaxnDg\\n\\n```\\nclass Solution {\\npublic:\\n    bool getBits(int cur, vector<int>& ones_count, bool add) {\\n      bool all_valid = true;\\n      int index = 0;\\n      while (cur) {\\n        if (add) ones_count[index++] += cur % 2;\\n        else ones_count[index++] -= cur % 2;\\n        cur = cur / 2;\\n      }\\n      \\n      for (int i = 0; i < 33; ++i) {\\n        // bitwise AND cannot be 0, 2 numbers have same bit set to 1\\n        if (ones_count[i] > 1) return false;\\n      }\\n      return true;\\n    }\\n  \\n    /*\\n    3 =    0011\\n    8 =    1000\\n  48 =  1010000\\n    */\\n    int longestNiceSubarray(vector<int>& nums) {\\n      int n = nums.size();\\n      int start = 0, ans = 0;\\n      // 2^33 > 10^9\\n      vector<int> ones_count(33, 0);\\n      \\n      for (int i = 0; i < n; ++i) {\\n        int all_valid = getBits(nums[i], ones_count, true);   \\n        while (start < i && !all_valid) {\\n          all_valid = getBits(nums[start++], ones_count, false);\\n        }\\n        //\\n        if (all_valid) ans = max(ans, i - start + 1);\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool getBits(int cur, vector<int>& ones_count, bool add) {\\n      bool all_valid = true;\\n      int index = 0;\\n      while (cur) {\\n        if (add) ones_count[index++] += cur % 2;\\n        else ones_count[index++] -= cur % 2;\\n        cur = cur / 2;\\n      }\\n      \\n      for (int i = 0; i < 33; ++i) {\\n        // bitwise AND cannot be 0, 2 numbers have same bit set to 1\\n        if (ones_count[i] > 1) return false;\\n      }\\n      return true;\\n    }\\n  \\n    /*\\n    3 =    0011\\n    8 =    1000\\n  48 =  1010000\\n    */\\n    int longestNiceSubarray(vector<int>& nums) {\\n      int n = nums.size();\\n      int start = 0, ans = 0;\\n      // 2^33 > 10^9\\n      vector<int> ones_count(33, 0);\\n      \\n      for (int i = 0; i < n; ++i) {\\n        int all_valid = getBits(nums[i], ones_count, true);   \\n        while (start < i && !all_valid) {\\n          all_valid = getBits(nums[start++], ones_count, false);\\n        }\\n        //\\n        if (all_valid) ans = max(ans, i - start + 1);\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527277,
                "title": "sliding-window-bitmasking-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans = 1, mask = 0;\\n        for(int i=0,j=0;j<nums.size();j++){\\n            if(mask & nums[j]){\\n                while(i < j and (mask & nums[j])){\\n                    for(int k=0;k<32;k++){\\n                        if(nums[i] & 1<<k) mask &= ~(1<<k);\\n                    }\\n                    i++;\\n                }\\n            }\\n            mask |= nums[j];\\n            ans = max(ans,j-i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans = 1, mask = 0;\\n        for(int i=0,j=0;j<nums.size();j++){\\n            if(mask & nums[j]){\\n                while(i < j and (mask & nums[j])){\\n                    for(int k=0;k<32;k++){\\n                        if(nums[i] & 1<<k) mask &= ~(1<<k);\\n                    }\\n                    i++;\\n                }\\n            }\\n            mask |= nums[j];\\n            ans = max(ans,j-i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088714,
                "title": "no-bit-manipulation-solution-c-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        vector<int> ia(32,-1);\\n\\n        int mx=1,prem=-1;\\n        for(int i = 0 ; i<nums.size() ;++i)\\n        {\\n            int rem=prem;\\n            for(int j = 0 ; j < 32 ; ++j)\\n                if(nums[i]&(1<<j))\\n                {\\n                    if(ia[j]!=-1)\\n                        rem=max(rem,ia[j]);\\n                    ia[j]=i;\\n                } \\n\\n            if(rem!=prem)\\n                for(int j = 0 ; j < 32 ; ++j)\\n                    if(ia[j]<=rem)\\n                        ia[j]=-1;\\n           \\n            mx = max(mx,i-rem);\\n            prem = rem;\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        vector<int> ia(32,-1);\\n\\n        int mx=1,prem=-1;\\n        for(int i = 0 ; i<nums.size() ;++i)\\n        {\\n            int rem=prem;\\n            for(int j = 0 ; j < 32 ; ++j)\\n                if(nums[i]&(1<<j))\\n                {\\n                    if(ia[j]!=-1)\\n                        rem=max(rem,ia[j]);\\n                    ia[j]=i;\\n                } \\n\\n            if(rem!=prem)\\n                for(int j = 0 ; j < 32 ; ++j)\\n                    if(ia[j]<=rem)\\n                        ia[j]=-1;\\n           \\n            mx = max(mx,i-rem);\\n            prem = rem;\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043998,
                "title": "bit-mask-with-sliding-window-r-85-m-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**! We call a subarray of nums nice if the bitwise AND of every pair of elements that are in different positions in the subarray is equal to 0. !**\\nWe need to annull every \\'1\\' bit to get 0.\\nAll we need is to keep track of \\'1\\' placement for every number in subarray.\\n Which is easy to do with a bit mask == 0.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse 0 as starting bit mask.\\nUse sliding window to keep track of subarray lengths.\\nFor every number we add into the window, add it\\'s \\'1\\' placement into a bit mask with bitwise OR\\n **bit_mask |= number**\\nExpand sliding window while there\\'s no incorrect pairs.\\n**bit_mask & number == 0**\\nShrink it if there\\'s incorrect pair in the subarray.\\n By deleting \\'1\\' bits of the most left element from the bit mask.\\nDelete them with XOR. 1-1 => 0.\\n**bit_mask ^= most_left**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n)**\\nn - len of input array.\\nWorst case:\\nOnly subarray with length == 1 present,\\nwe will always fail and remove previously used index.\\nEvery index from input array will be used twice => O(2n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(1)**\\nOnly constants used, none of them depends on input.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        # Standard sliding window.\\n        l_limit: int = 0\\n        r_limit: int = 0\\n        bit_mask: int = 0\\n        max_len: int = 0\\n        # Essentially we shouldn\\'t have any pair with same position of \\'1\\' bit.\\n        # We can just store all \\'1\\' placements in a bit_mask, and check on it.\\n        while r_limit != len(nums):\\n            while (nums[r_limit] & bit_mask) != 0:\\n                # 1-1 == 0, and remove it with XOR.\\n                bit_mask ^= nums[l_limit]\\n                l_limit += 1\\n            # 1-0, 0-1 == 1, place every \\'1\\' with OR.\\n            bit_mask |= nums[r_limit]\\n            # 0-indexed, +1 for correct length.\\n            max_len = max(max_len, (r_limit - l_limit) + 1)\\n            # ! 1 <= nums[i] <= 10 ** 9 ! <- constraint.\\n            # If all 1 placed, we will never have option with 0.\\n            # So it\\'s always fail after 30.\\n            if max_len == 30:\\n                return max_len\\n            r_limit += 1\\n        return max_len\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        # Standard sliding window.\\n        l_limit: int = 0\\n        r_limit: int = 0\\n        bit_mask: int = 0\\n        max_len: int = 0\\n        # Essentially we shouldn\\'t have any pair with same position of \\'1\\' bit.\\n        # We can just store all \\'1\\' placements in a bit_mask, and check on it.\\n        while r_limit != len(nums):\\n            while (nums[r_limit] & bit_mask) != 0:\\n                # 1-1 == 0, and remove it with XOR.\\n                bit_mask ^= nums[l_limit]\\n                l_limit += 1\\n            # 1-0, 0-1 == 1, place every \\'1\\' with OR.\\n            bit_mask |= nums[r_limit]\\n            # 0-indexed, +1 for correct length.\\n            max_len = max(max_len, (r_limit - l_limit) + 1)\\n            # ! 1 <= nums[i] <= 10 ** 9 ! <- constraint.\\n            # If all 1 placed, we will never have option with 0.\\n            # So it\\'s always fail after 30.\\n            if max_len == 30:\\n                return max_len\\n            r_limit += 1\\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030206,
                "title": "simplest-sliding-window",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans = 0, i = 0, j = 0, n = nums.size(), ln = 0;\\n        while(j < n)\\n        {\\n            while(ans&nums[j]) {\\n                ans-=nums[i++];\\n            }\\n            ans += nums[j++];\\n            ln = max(ln, j-i);\\n        }\\n        return ln;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans = 0, i = 0, j = 0, n = nums.size(), ln = 0;\\n        while(j < n)\\n        {\\n            while(ans&nums[j]) {\\n                ans-=nums[i++];\\n            }\\n            ans += nums[j++];\\n            ln = max(ln, j-i);\\n        }\\n        return ln;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011044,
                "title": "tc-o-n-sc-o-1-easiest-beginner-friendly-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every `l` get the rightmost `r` which satisfies the condition.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- (a^b) = (a+b) => a & b = 0 or a, b has opposite bits at every posn or a = b = 0.\\n- sum of [l, r] defines the set bit of all the integers involved in given subarray [l, r].\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans = 0;\\n        int r = 0;\\n        long int sum = 0;\\n        for(int l = 0; l < nums.size(); l++)\\n        {\\n            sum += nums[r];\\n            // (a^b) = (a+b) => a & b = 0 or a, b has opposite bits at every posn or a = b = 0.\\n            // sum of [l, r] defines the set bit of all the integers involved in given subarray [l, r].\\n            cout << sum << \" \" << l << \" \" << r << endl;\\n            while(r+1 < nums.size() && (nums[r+1] ^ sum) == (sum + nums[r+1]))\\n            {\\n                sum += nums[r+1];\\n                r++;\\n            }\\n            ans = max(ans, r-l+1);\\n            sum -= nums[r]; // value at this r will be added again in next iteration of loop\\n            sum -= nums[l];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n> **Comment your doubts.**\\n\\n> **Dont forget to upvote**",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans = 0;\\n        int r = 0;\\n        long int sum = 0;\\n        for(int l = 0; l < nums.size(); l++)\\n        {\\n            sum += nums[r];\\n            // (a^b) = (a+b) => a & b = 0 or a, b has opposite bits at every posn or a = b = 0.\\n            // sum of [l, r] defines the set bit of all the integers involved in given subarray [l, r].\\n            cout << sum << \" \" << l << \" \" << r << endl;\\n            while(r+1 < nums.size() && (nums[r+1] ^ sum) == (sum + nums[r+1]))\\n            {\\n                sum += nums[r+1];\\n                r++;\\n            }\\n            ans = max(ans, r-l+1);\\n            sum -= nums[r]; // value at this r will be added again in next iteration of loop\\n            sum -= nums[l];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4008144,
                "title": "window-sliding-bit-operation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int longestNiceSubarray(vector<int>& nums) {\\n        long long head=0,tail=0,ans=1;  \\n        int curr=0;   \\n        while(head<nums.size())\\n        {    \\n            while(curr&nums[head])\\n            { \\n                curr=curr&(~nums[tail]);\\n                tail++;\\n            }\\n            ans=max(ans,head-tail+1);\\n            curr=curr|nums[head]; \\n            head++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int longestNiceSubarray(vector<int>& nums) {\\n        long long head=0,tail=0,ans=1;  \\n        int curr=0;   \\n        while(head<nums.size())\\n        {    \\n            while(curr&nums[head])\\n            { \\n                curr=curr&(~nums[tail]);\\n                tail++;\\n            }\\n            ans=max(ans,head-tail+1);\\n            curr=curr|nums[head]; \\n            head++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002200,
                "title": "java-sliding-window-two-pointers-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJava Sliding Window/ Two Pointers Easy Solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJava Sliding Window/ Two Pointers Easy Solution\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int maxLength = 1;\\n\\n        int start = 0;\\n        int end = 0;\\n        long acc = 0;\\n        int max = 0;\\n\\n        for(int i=0; i<nums.length; i++){\\n\\n            if(((nums[i] & acc) == 0)){\\n                end++;\\n                acc |= nums[i];\\n            }else{\\n                acc = 0;\\n                start = start + 1;\\n                i = start-1;//for i++\\n                end = start;\\n            }\\n\\n           \\n            if(end-start > max){\\n                max = end-start;\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int maxLength = 1;\\n\\n        int start = 0;\\n        int end = 0;\\n        long acc = 0;\\n        int max = 0;\\n\\n        for(int i=0; i<nums.length; i++){\\n\\n            if(((nums[i] & acc) == 0)){\\n                end++;\\n                acc |= nums[i];\\n            }else{\\n                acc = 0;\\n                start = start + 1;\\n                i = start-1;//for i++\\n                end = start;\\n            }\\n\\n           \\n            if(end-start > max){\\n                max = end-start;\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001422,
                "title": "2-pointers-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans=1;int n=nums.size();\\n        int lo=0,hi=0;\\n        while(hi+1<n){\\n            hi++;\\n            int t=hi-1;bool e=0;\\n            while(t>=lo){\\n                if(nums[t]&nums[hi]){\\n                    e=1;\\n                    break;\\n                }\\n                t--;\\n            }\\n            if(e==1){\\n                t++;\\n                ans=max(ans,hi-t+1);\\n                lo=t;\\n            }\\n            else{\\n                ans=max(ans,hi-lo+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans=1;int n=nums.size();\\n        int lo=0,hi=0;\\n        while(hi+1<n){\\n            hi++;\\n            int t=hi-1;bool e=0;\\n            while(t>=lo){\\n                if(nums[t]&nums[hi]){\\n                    e=1;\\n                    break;\\n                }\\n                t--;\\n            }\\n            if(e==1){\\n                t++;\\n                ans=max(ans,hi-t+1);\\n                lo=t;\\n            }\\n            else{\\n                ans=max(ans,hi-lo+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971678,
                "title": "c-sliding-window-bit-manipulation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0,j = 1;\\n        int Or = nums[0];\\n        int ans = 1;\\n        while(j<n)\\n        {\\n            int a = Or&nums[j];\\n            if(a==0)\\n            {\\n                Or|=nums[j];\\n                ans = max(ans,j-i+1);\\n            }\\n            else\\n            {\\n                int b = Or&nums[j];\\n                while(b!=0 && i<=j)\\n                {\\n                    Or^=nums[i];\\n                    i++;\\n                    b = Or&nums[j];\\n                }\\n                if(i==j)\\n                Or = nums[j];\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0,j = 1;\\n        int Or = nums[0];\\n        int ans = 1;\\n        while(j<n)\\n        {\\n            int a = Or&nums[j];\\n            if(a==0)\\n            {\\n                Or|=nums[j];\\n                ans = max(ans,j-i+1);\\n            }\\n            else\\n            {\\n                int b = Or&nums[j];\\n                while(b!=0 && i<=j)\\n                {\\n                    Or^=nums[i];\\n                    i++;\\n                    b = Or&nums[j];\\n                }\\n                if(i==j)\\n                Or = nums[j];\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941996,
                "title": "bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans=0,j=0,curr_or=0;\\n           for(int i=0;i<nums.size();i++){\\n          while((curr_or &nums[i])!=0&&j<i){\\n              curr_or^=nums[j];\\n              j++; }  \\n        curr_or|=nums[i];\\n          ans=max(ans,i-j+1);\\n      }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans=0,j=0,curr_or=0;\\n           for(int i=0;i<nums.size();i++){\\n          while((curr_or &nums[i])!=0&&j<i){\\n              curr_or^=nums[j];\\n              j++; }  \\n        curr_or|=nums[i];\\n          ans=max(ans,i-j+1);\\n      }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941546,
                "title": "java-sliding-window-o-n-beats-99-time-o-1-space",
                "content": "# Intuition\\nWhenever we are asked to do something related to subarrays, we should always try to think of sliding window first as it gives output in O(n), or O(nlogn) in complex problem.\\n# Approach\\nHere we have to make sure AND of every pair of element is 0, which means no 2 numbers can share bits in same position. As such when 2 number give & as 0. We combine their bits by using OR operator for future use. And next time we use & in this combined value.\\nAny time the AND of combine value and new number coming to window violates the condition, we shirnk the window. And to take a number out of combined value, we simple XOR it, as XOR gives 0 when bits are same and 1 when diffent.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int tot = 0;\\n        int wS = 0;\\n        int wE = 0;\\n        int max = 0;\\n        for(;wE<nums.length;wE++){\\n            if( (tot & nums[wE]) != 0){\\n                while( wS <= wE && (tot & nums[wE]) != 0){\\n                    tot = tot^nums[wS++];\\n                }\\n            }\\n            tot = tot | nums[wE];  \\n            max = Math.max(max,wE-wS+1);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int tot = 0;\\n        int wS = 0;\\n        int wE = 0;\\n        int max = 0;\\n        for(;wE<nums.length;wE++){\\n            if( (tot & nums[wE]) != 0){\\n                while( wS <= wE && (tot & nums[wE]) != 0){\\n                    tot = tot^nums[wS++];\\n                }\\n            }\\n            tot = tot | nums[wE];  \\n            max = Math.max(max,wE-wS+1);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924618,
                "title": "java-sliding-windows-solution-with-clear-explanation-and-real-life-application",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThink of this like a game. You start at the beginning of your list of numbers. You keep adding numbers to your chain until you hit a number that breaks the rule with the chain you\\'re building. If that happens, you reset and start building a new chain.\\n\\n\\nThe solution tries to maintain a moving window (subarray) between two pointers left and right. At every step, it checks if the current window (subarray) is \"nice\". If it isn\\'t, it adjusts the window by moving the left pointer. If it is, it tries to expand the window by moving the right pointer.\\n\\n##### What is a bitwise AND?\\nConsider two numbers, say 5 and 3. Their binary representation is:\\n```\\n5 = 101\\n3 = 011\\n```\\n\\nWhen you do a bitwise AND:\\n```\\n  101\\n& 011\\n-------\\n  001   (which is the number 1 in decimal)\\n\\n```\\n\\nYou take each pair of bits from the numbers (from right to left) and apply the AND operation. The result is 1 only if both bits are 1, otherwise, it\\'s 0.\\n\\n# Approach\\nTo satisfy the condtion, we want the AND result to be zero for every pair of numbers in the subarray. The trick is to use the concept of an \"OR\" of numbers in a subarray.\\n\\nIf a number AND with the OR of some previous numbers is not 0, it means this number cannot be added to the current subarray.\\n\\n**Here\\'s a simple step-by-step solution:**\\n\\n1) Start from the first number. This can be our starting point.\\n\\n2) As we go through the list, keep track of the OR of all numbers from the starting point up to our current number.\\n3) For each new number, check if it ANDed with our tracked OR is zero.\\n- If it\\'s 0, great! Continue to the next number.\\n\\n- If not, move our starting point one step ahead and adjust our tracked OR.\\n\\n4) All the while, keep track of the longest group of numbers (subarray) that meets our condition.\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int max = 1;\\n        int left = 0;\\n        int right = 0; \\n        int subarrayOR = 0; \\n\\n        while(right < nums.length)\\n        {\\n            // Check if current number AND subarrayOR is not 0\\n            while((subarrayOR & nums[right]) != 0)\\n            {\\n                // If it\\'s not 0, remove the effect of the number at \\'left\\' from subarrayOR\\n                subarrayOR ^= nums[left];\\n                left++;\\n            }\\n\\n            // Add the current number to our subarrayOR\\n            subarrayOR |= nums[right];\\n            \\n            // Update maxLen if current subarray is longer\\n            max = Math.max(max, right - left + 1);\\n            right++;\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n```\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is the length of the input array\\n\\n- Space complexity: $$O(1)$$ because we only use a constant amount of extra space.\\n\\n\\n# Application\\nThe problem **Longest Nice Subarray** have several real-life applications:\\n\\n1. Error Detection and Correction: Bitwise operations are often used in error-detecting codes, including parity bits and CRCs, to ensure data integrity during transmission.\\n\\n2. Data Compression: In algorithms like Huffman coding, bitwise operations are used to compress data efficiently.\\n\\n3. Cryptography: Bitwise operations are fundamental in designing cryptographic algorithms where data is encrypted into unreadable formats.\\n\\n4. Graphics: In graphic processing, bitwise operations might be used for tasks like masking certain bits of a color, blending, or other pixel-based operations.\\n\\n5. Network Communications: IP addresses and subnet masks, crucial for routing in networks, often require bitwise operations for tasks like determining if an IP belongs to a particular subnet.\\n\\n*Thank you for reading! If you found this solution helpful, please give me an upvote. Feel free to add suggestions.*",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\n5 = 101\\n3 = 011\\n```\n```\\n  101\\n& 011\\n-------\\n  001   (which is the number 1 in decimal)\\n\\n```\n```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int max = 1;\\n        int left = 0;\\n        int right = 0; \\n        int subarrayOR = 0; \\n\\n        while(right < nums.length)\\n        {\\n            // Check if current number AND subarrayOR is not 0\\n            while((subarrayOR & nums[right]) != 0)\\n            {\\n                // If it\\'s not 0, remove the effect of the number at \\'left\\' from subarrayOR\\n                subarrayOR ^= nums[left];\\n                left++;\\n            }\\n\\n            // Add the current number to our subarrayOR\\n            subarrayOR |= nums[right];\\n            \\n            // Update maxLen if current subarray is longer\\n            max = Math.max(max, right - left + 1);\\n            right++;\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915845,
                "title": "python-n-with-xor-and-30n-sliding-windows",
                "content": "```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        \"\"\"\\n        [i] > 0\\n        AND of every pair of elements in different pos in sb = 0\\n        ret longest nice\\n        sb of len = 1 -> nice\\n        \\n        1     3    8     48   10\\n        001 011 1000 110000 1010\\n        \\n        3 & 8\\n        3 & 48\\n        8 & 48\\n        \\n        011 & 1000 & 110000 <-- longest\\n        \\n          3   1   5   11   13\\n        011 001 101 1011 1101\\n        \\n        !!! 00[1] 010 01[1] !!! <-- invalid trio\\n        should be no more than 1 bit at the same pos during numbers \\'merging\\'\\n        \\n        longest subarray with non overlapping bits?\\n        \"\"\"\\n        N = len(nums)\\n        left = 0\\n        max_len = 1\\n        curr = 0\\n        for right in range(N):\\n            if curr & nums[right] == 0: # if no conflict -> merge nums (e.g. 001 and 010)\\n                curr |= nums[right]\\n            else: # if there\\'s a conflict with current and nums[right] (e.g. 001 and 011). Remove left till no conflict. !! Merge nums[right] as it has not been merged yet\\n                while curr & nums[right]:\\n                    curr ^= nums[left]\\n                    left += 1\\n                curr |= nums[right]\\n            max_len = max(max_len, right - left + 1)\\n        return max_len\\n    \\n\\t    # 30N solution: not so smart, but easy to figure out what\\'s going on\\n        # N = len(nums)\\n        # bits = [0] * 30\\n        # left = 0\\n        # max_len = 1\\n        # for right in range(N):\\n        #     num = nums[right]\\n        #     b = 0\\n        #     eq_2_count = 0\\n        #     while num != 0:\\n        #         if num & 1:\\n        #             bits[b] += 1\\n        #             if bits[b] == 2:\\n        #                 eq_2_count += 1\\n        #         num >>= 1\\n        #         b += 1\\n        #     while eq_2_count > 0:\\n        #         num = nums[left]\\n        #         b = 0\\n        #         while num != 0:\\n        #             if num & 1:\\n        #                 if bits[b] == 2:\\n        #                     eq_2_count -= 1\\n        #                 bits[b] -= 1\\n        #             num >>= 1\\n        #             b += 1\\n        #         left += 1\\n        #     max_len = max(max_len, right - left + 1)\\n        # return max_len\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        \"\"\"\\n        [i] > 0\\n        AND of every pair of elements in different pos in sb = 0\\n        ret longest nice\\n        sb of len = 1 -> nice\\n        \\n        1     3    8     48   10\\n        001 011 1000 110000 1010\\n        \\n        3 & 8\\n        3 & 48\\n        8 & 48\\n        \\n        011 & 1000 & 110000 <-- longest\\n        \\n          3   1   5   11   13\\n        011 001 101 1011 1101\\n        \\n        !!! 00[1] 010 01[1] !!! <-- invalid trio\\n        should be no more than 1 bit at the same pos during numbers \\'merging\\'\\n        \\n        longest subarray with non overlapping bits?\\n        \"\"\"\\n        N = len(nums)\\n        left = 0\\n        max_len = 1\\n        curr = 0\\n        for right in range(N):\\n            if curr & nums[right] == 0: # if no conflict -> merge nums (e.g. 001 and 010)\\n                curr |= nums[right]\\n            else: # if there\\'s a conflict with current and nums[right] (e.g. 001 and 011). Remove left till no conflict. !! Merge nums[right] as it has not been merged yet\\n                while curr & nums[right]:\\n                    curr ^= nums[left]\\n                    left += 1\\n                curr |= nums[right]\\n            max_len = max(max_len, right - left + 1)\\n        return max_len\\n    \\n\\t    # 30N solution: not so smart, but easy to figure out what\\'s going on\\n        # N = len(nums)\\n        # bits = [0] * 30\\n        # left = 0\\n        # max_len = 1\\n        # for right in range(N):\\n        #     num = nums[right]\\n        #     b = 0\\n        #     eq_2_count = 0\\n        #     while num != 0:\\n        #         if num & 1:\\n        #             bits[b] += 1\\n        #             if bits[b] == 2:\\n        #                 eq_2_count += 1\\n        #         num >>= 1\\n        #         b += 1\\n        #     while eq_2_count > 0:\\n        #         num = nums[left]\\n        #         b = 0\\n        #         while num != 0:\\n        #             if num & 1:\\n        #                 if bits[b] == 2:\\n        #                     eq_2_count -= 1\\n        #                 bits[b] -= 1\\n        #             num >>= 1\\n        #             b += 1\\n        #         left += 1\\n        #     max_len = max(max_len, right - left + 1)\\n        # return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895442,
                "title": "golang-sliding-window-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```go\\nfunc longestNiceSubarray(nums []int) int {\\n\\tmaxSize := 1\\n\\tfor leftBound, rightBound, orValue := 0, 0, 0; rightBound < len(nums); {\\n\\t\\tif orValue & nums[rightBound] == 0 {\\n\\t\\t\\torValue |= nums[rightBound]\\n\\t\\t\\tcurSize := rightBound - leftBound + 1\\n\\t\\t\\tif curSize > maxSize {\\n\\t\\t\\t\\tmaxSize = curSize\\n\\t\\t\\t}\\n\\t\\t\\trightBound++\\n\\t\\t} else {\\n\\t\\t\\torValue ^= nums[leftBound]\\n\\t\\t\\tleftBound++\\n\\t\\t}\\n\\t}\\n\\treturn maxSize\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sliding Window"
                ],
                "code": "```go\\nfunc longestNiceSubarray(nums []int) int {\\n\\tmaxSize := 1\\n\\tfor leftBound, rightBound, orValue := 0, 0, 0; rightBound < len(nums); {\\n\\t\\tif orValue & nums[rightBound] == 0 {\\n\\t\\t\\torValue |= nums[rightBound]\\n\\t\\t\\tcurSize := rightBound - leftBound + 1\\n\\t\\t\\tif curSize > maxSize {\\n\\t\\t\\t\\tmaxSize = curSize\\n\\t\\t\\t}\\n\\t\\t\\trightBound++\\n\\t\\t} else {\\n\\t\\t\\torValue ^= nums[leftBound]\\n\\t\\t\\tleftBound++\\n\\t\\t}\\n\\t}\\n\\treturn maxSize\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3857629,
                "title": "c-o-n-and-o-32-n-solutions",
                "content": "# Approach 1 (Counting bits of Every number)\\nFirst we will count the bits of every no and store/add them in a vector if count of any vector[i] > 1 means we have 2 setbits(1) at that position which means we cannot make their & equal to 0 so then we will substract the numbers from starting till we get all the counts in vector less than 2.\\n\\n# Approach 2 (Using XOR)\\nWe wil take a bitmask and OR(to add) the number with it untill (nums[i] & bitmask == 0) if it is not equal to 0 we will remove elements from starting using xor. \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n  O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // SC - O(N) solution using XOR\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans = 0, i = 0, j = 0, bitmask = 0;\\n        while(i < nums.size()) {\\n            while((bitmask & nums[i]) != 0) {\\n                bitmask ^= nums[j++];\\n            }\\n            bitmask |= nums[i];\\n            ans = max(ans, i-j+1);\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n    // SC - O(32*N) solution using count of bits of every number\\n\\n    // int longestNiceSubarray(vector<int>& nums) {\\n    //     int i = 0, j = 0, ans = 1;\\n    //     vector<int> setbit(32, 0);\\n    //     while(i < nums.size()) {\\n    //         bool flag = true;\\n    //         for(int k=0;k<32;k++) {\\n    //             if(nums[i] & (1<<k)) {\\n    //                 setbit[k]++;\\n    //                 if(setbit[k] > 1) flag = false;\\n    //             }\\n    //         }\\n    //         while(!flag) {\\n    //             flag = true;\\n    //             for(int k=0;k<32;k++) {\\n    //                 int bit = (nums[j]>>k)&1;\\n    //                 setbit[k] -= bit;\\n    //                 if(setbit[k] > 1) flag = false;\\n    //             }\\n    //             j++;\\n    //         }\\n    //         ans = max(ans, i-j+1);\\n    //         i++;\\n    //     }\\n    //     return ans;\\n    // }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Sliding Window",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // SC - O(N) solution using XOR\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans = 0, i = 0, j = 0, bitmask = 0;\\n        while(i < nums.size()) {\\n            while((bitmask & nums[i]) != 0) {\\n                bitmask ^= nums[j++];\\n            }\\n            bitmask |= nums[i];\\n            ans = max(ans, i-j+1);\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n    // SC - O(32*N) solution using count of bits of every number\\n\\n    // int longestNiceSubarray(vector<int>& nums) {\\n    //     int i = 0, j = 0, ans = 1;\\n    //     vector<int> setbit(32, 0);\\n    //     while(i < nums.size()) {\\n    //         bool flag = true;\\n    //         for(int k=0;k<32;k++) {\\n    //             if(nums[i] & (1<<k)) {\\n    //                 setbit[k]++;\\n    //                 if(setbit[k] > 1) flag = false;\\n    //             }\\n    //         }\\n    //         while(!flag) {\\n    //             flag = true;\\n    //             for(int k=0;k<32;k++) {\\n    //                 int bit = (nums[j]>>k)&1;\\n    //                 setbit[k] -= bit;\\n    //                 if(setbit[k] > 1) flag = false;\\n    //             }\\n    //             j++;\\n    //         }\\n    //         ans = max(ans, i-j+1);\\n    //         i++;\\n    //     }\\n    //     return ans;\\n    // }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853992,
                "title": "simple-c-beats-98-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans = 1;\\n        for (int i = 0; i < nums.size(); i++){\\n            int j = i + 1, l = 1;\\n            int tmp = nums[i];\\n            while (j < nums.size()){\\n                if ((nums[j] & tmp) == 0){\\n                    l++;\\n                    ans = max(l, ans);\\n                    tmp = tmp | nums[j];\\n                    j++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans = 1;\\n        for (int i = 0; i < nums.size(); i++){\\n            int j = i + 1, l = 1;\\n            int tmp = nums[i];\\n            while (j < nums.size()){\\n                if ((nums[j] & tmp) == 0){\\n                    l++;\\n                    ans = max(l, ans);\\n                    tmp = tmp | nums[j];\\n                    j++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841746,
                "title": "python-code-simple-solution",
                "content": "# Intuition\\n- Prefix \"OR\" value\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n- Sliding Window approach with prefix \"OR\" value.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        prefix_or=0\\n        res=1\\n        i=0\\n        j=0\\n        while(i<=j and j<len(nums)):\\n            if prefix_or&nums[j]!=0:\\n                while(prefix_or&nums[j] and i<=j):\\n                    prefix_or^=nums[i]\\n                    i+=1\\n            res=max(res,j-i+1)\\n            prefix_or|=nums[j]\\n            j+=1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        prefix_or=0\\n        res=1\\n        i=0\\n        j=0\\n        while(i<=j and j<len(nums)):\\n            if prefix_or&nums[j]!=0:\\n                while(prefix_or&nums[j] and i<=j):\\n                    prefix_or^=nums[i]\\n                    i+=1\\n            res=max(res,j-i+1)\\n            prefix_or|=nums[j]\\n            j+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818504,
                "title": "c-easy-sliding-window",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n       \\n       int mask = 0;\\n       \\n       int n = nums.size();\\n       \\n       int head = 0;\\n       int tail = 0;\\n\\n        int ans = 1;\\n\\n       while(head<n)\\n       {\\n           int check = nums[head];\\n\\n               if(check & mask)\\n               {\\n                   while(mask & check)\\n                   {\\n                       mask = mask & ~(nums[tail]);\\n                       tail++;\\n                   }\\n               }\\n           \\n           mask = mask | check;\\n           ans = max(ans,head-tail+1);\\n           head++;\\n       }\\n\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n       \\n       int mask = 0;\\n       \\n       int n = nums.size();\\n       \\n       int head = 0;\\n       int tail = 0;\\n\\n        int ans = 1;\\n\\n       while(head<n)\\n       {\\n           int check = nums[head];\\n\\n               if(check & mask)\\n               {\\n                   while(mask & check)\\n                   {\\n                       mask = mask & ~(nums[tail]);\\n                       tail++;\\n                   }\\n               }\\n           \\n           mask = mask | check;\\n           ans = max(ans,head-tail+1);\\n           head++;\\n       }\\n\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809708,
                "title": "javascript-easy-sliding-window-technique",
                "content": "# Approach\\n- Using the sliding window technique and storing the values using the OR function and comparing with the next to increase size of the window\\n- In each iteration of increasing the sizing, we are comparing the current maxlength of sub array and size of the current window, and storing the higest value as maxlengh\\n\\n# Complexity\\n- Time complexity:\\n    -  O(n^2)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestNiceSubarray = function(nums) {\\n    let maxlength = 0;\\n\\n    for(let i = 0; i< nums.length; i++) {\\n        let orValue = 0\\n        let windowEnd = i;\\n        while(windowEnd < nums.length && (orValue & nums[windowEnd]) === 0) {\\n            maxlength = Math.max(maxlength, (windowEnd - i + 1));\\n            orValue = orValue | nums[windowEnd];\\n            windowEnd++;\\n        }\\n    }\\n    return maxlength;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestNiceSubarray = function(nums) {\\n    let maxlength = 0;\\n\\n    for(let i = 0; i< nums.length; i++) {\\n        let orValue = 0\\n        let windowEnd = i;\\n        while(windowEnd < nums.length && (orValue & nums[windowEnd]) === 0) {\\n            maxlength = Math.max(maxlength, (windowEnd - i + 1));\\n            orValue = orValue | nums[windowEnd];\\n            windowEnd++;\\n        }\\n    }\\n    return maxlength;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3797392,
                "title": "cpp-sliding-window-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int i=0,j=0,ans=0,bits=0;\\n        \\n        while(j<n){\\n            bool chk = bits&(nums[j]);\\n            \\n            if(!chk) {\\n                bits|=nums[j];\\n                ans=max(ans,j-i+1);\\n            }\\n            else{\\n                while(bits&nums[j]){\\n                    bits^=nums[i++];\\n                }\\n                bits|=nums[j];\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int i=0,j=0,ans=0,bits=0;\\n        \\n        while(j<n){\\n            bool chk = bits&(nums[j]);\\n            \\n            if(!chk) {\\n                bits|=nums[j];\\n                ans=max(ans,j-i+1);\\n            }\\n            else{\\n                while(bits&nums[j]){\\n                    bits^=nums[i++];\\n                }\\n                bits|=nums[j];\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787972,
                "title": "sliding-window-variation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) \\n    {\\n        int ans=0;\\n        int start=0;\\n        int Nice=0;\\n        for(int end=0 ; end < nums.size();end++)\\n        {\\n            if((Nice & nums[end])==0)\\n            {\\n                Nice=Nice | nums[end];\\n                ans=max(ans, end-start+1);\\n                cout<<start<<\"\"<<end;\\n                continue;\\n            }\\n            else \\n            {\\n                while((Nice & nums[end])!=0 && start!=end)\\n                {\\n                     Nice = Nice ^ nums[start];\\n                     start++;\\n                }\\n               Nice = Nice | nums[end];\\n            }\\n        }\\n        return ans==0 ? 1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) \\n    {\\n        int ans=0;\\n        int start=0;\\n        int Nice=0;\\n        for(int end=0 ; end < nums.size();end++)\\n        {\\n            if((Nice & nums[end])==0)\\n            {\\n                Nice=Nice | nums[end];\\n                ans=max(ans, end-start+1);\\n                cout<<start<<\"\"<<end;\\n                continue;\\n            }\\n            else \\n            {\\n                while((Nice & nums[end])!=0 && start!=end)\\n                {\\n                     Nice = Nice ^ nums[start];\\n                     start++;\\n                }\\n               Nice = Nice | nums[end];\\n            }\\n        }\\n        return ans==0 ? 1 : ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3784120,
                "title": "easiest-java-solution-beginner-friendly-solution-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple solution. Suppose this is our window [1,2]. Now we need to check if 4 is a valid addition to this window or not. The naive way of doing it would be to check if 1 AND 3, 2 AND 3 both equal zero. Instead we look at the bits of 1 and 2. 1 -> 001, 2 -> 010 and 4 - 100. Now what we can do is, we can combine the bits of 1 and 2. Thus we can save 001 OR 010 = 011 which is the number 3 in decimal which is also equal to 1 + 2. Hence we find that to combine the bits, we need to add. Thus we need to check if nums[right] AND sum(nums[left]....nums[right - 1]) == 0. If this isn\\'t zero, we minus and remove the left element and only keep the bits of the rest of the elements\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple sliding window approach once you understand the question\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int ans = 1;\\n        for(int right = 1, left = 0, curr = nums[0]; right < nums.length; curr += nums[right++]){\\n            while((nums[right] & curr) != 0){\\n                curr -= nums[left++];\\n            }\\n            ans = Math.max(ans, right - left + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int ans = 1;\\n        for(int right = 1, left = 0, curr = nums[0]; right < nums.length; curr += nums[right++]){\\n            while((nums[right] & curr) != 0){\\n                curr -= nums[left++];\\n            }\\n            ans = Math.max(ans, right - left + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783635,
                "title": "java-simplest-solution-brute-force",
                "content": "```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int i = 0, n = nums.length, ans = 1, j = 1;\\n        while (j < n) {\\n            if (isValidWindow(nums, i, j)) {\\n                ans = Math.max(ans, j - i + 1);\\n                j++;\\n            } else {\\n                i++;\\n                j = i + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean isValidWindow(int[] nums, int i, int j) {\\n        int num = nums[j];\\n        int k = j - 1;\\n        while (k >= i) {\\n            if ((num & nums[k]) != 0) return false;\\n            k--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int i = 0, n = nums.length, ans = 1, j = 1;\\n        while (j < n) {\\n            if (isValidWindow(nums, i, j)) {\\n                ans = Math.max(ans, j - i + 1);\\n                j++;\\n            } else {\\n                i++;\\n                j = i + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean isValidWindow(int[] nums, int i, int j) {\\n        int num = nums[j];\\n        int k = j - 1;\\n        while (k >= i) {\\n            if ((num & nums[k]) != 0) return false;\\n            k--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777348,
                "title": "easy-to-understand-first-time-accepted",
                "content": "```\\n// it\\'s all about counting the bits\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& a) {\\n        int n = a.size();\\n        int i = n-1, j = n-1;\\n        int ans = 0;\\n        int temp = 0;\\n        while(i >= 0){\\n            while(a[i]&temp){\\n                temp ^= a[j];\\n                j--;\\n            }\\n            temp |= a[i];\\n            ans = max(ans, j-i+1);\\n            i--;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& a) {\\n        int n = a.size();\\n        int i = n-1, j = n-1;\\n        int ans = 0;\\n        int temp = 0;\\n        while(i >= 0){\\n            while(a[i]&temp){\\n                temp ^= a[j];\\n                j--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3765197,
                "title": "bit-mask",
                "content": "# Intuition\\nNice sub array means elements\\' bit masks do not overlap. To find the longest sub array we need to use a sliding window.\\n\\nIt you like my approach please vote!\\n\\n# Code\\n```\\nclass Solution:\\n    def longestNiceSubarray(self, a: List[int]) -> int:\\n        i, n, r, bits = 0, len(a), 1, a[0]\\n        for j in range(1, n):\\n            while bits & a[j]:\\n                bits -= a[i]\\n                i += 1\\n            r = max(r, j - i + 1)\\n            bits |= a[j]\\n        return r\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubarray(self, a: List[int]) -> int:\\n        i, n, r, bits = 0, len(a), 1, a[0]\\n        for j in range(1, n):\\n            while bits & a[j]:\\n                bits -= a[i]\\n                i += 1\\n            r = max(r, j - i + 1)\\n            bits |= a[j]\\n        return r\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751931,
                "title": "best-solution-o-n-faang-solution",
                "content": "class Solution {\\npublic:\\n//approach is if we are at jth index then we take OR of its previous elements from i to (j-1)th index then we do do AND with nums[j] if it is zero count subarray length if it is not zero then remove the nums[i] by doing the xor of the nums[i] with the OR of all elements hence it will cancle the nums[i] because x^x==0 hota h \\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans=0,result=0;\\n        int i=0,j=0;\\n        int n=nums.size();\\n        while(j<n){\\n            while((ans & nums[j])>0){  //doing AND with nums[i] of total OR \\n                ans=ans^nums[i]; //remove the nums[i]\\n                i++;\\n            }\\n            ans=ans|nums[j]; //doing and because total set bit ek saath aa jayenge saare numbers ke\\n            result=max(result,j-i+1);\\n            j++; //slide the window\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n//approach is if we are at jth index then we take OR of its previous elements from i to (j-1)th index then we do do AND with nums[j] if it is zero count subarray length if it is not zero then remove the nums[i] by doing the xor of the nums[i] with the OR of all elements hence it will cancle the nums[i] because x^x==0 hota h \\n    int longestNiceSubarray(vector<int>& nums) {\\n        int ans=0,result=0;\\n        int i=0,j=0;\\n        int n=nums.size();\\n        while(j<n){\\n            while((ans & nums[j])>0){  //doing AND with nums[i] of total OR \\n                ans=ans^nums[i]; //remove the nums[i]\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3744691,
                "title": "o-n-o-1-sliding-window-short-code-explained",
                "content": "When adding a new number to the \"*window*\" (incrementing `right`), check whether it\\'s \"***nice***\", by comparing it to the other numbers already existing in the window (all array numbers between `left` and `right` indexes).\\n\\nSince any mismatch will invalidate the entire window, speed it up by checking from right towards left, instead of slowly incrementing the `left` variabile in a loop, as the usual template goes.\\n\\nPlease **upvote** if this helped. Thank you!\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestNiceSubarray(int[] nums) \\n    {\\n        int left = 0, max = 0;\\n        \\n        for(int right = 0; right < nums.Length; right++)\\n        {\\n            for(int i = right - 1; i >= left; i--)\\n                if ((nums[right] & nums[i]) != 0)\\n                {\\n                    left = i + 1;\\n                    break;\\n                }\\n\\n            max = Math.Max(max, right - left + 1);\\n        } \\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Sliding Window"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestNiceSubarray(int[] nums) \\n    {\\n        int left = 0, max = 0;\\n        \\n        for(int right = 0; right < nums.Length; right++)\\n        {\\n            for(int i = right - 1; i >= left; i--)\\n                if ((nums[right] & nums[i]) != 0)\\n                {\\n                    left = i + 1;\\n                    break;\\n                }\\n\\n            max = Math.Max(max, right - left + 1);\\n        } \\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733807,
                "title": "simple-and-fast-java-solution",
                "content": "```\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int i = 0;\\n        int j = 0;\\n        int ans = 1;\\n        int tempNum = 0;\\n        while(j < arr.length){\\n            while((tempNum & arr[j]) != 0){\\n                tempNum = tempNum ^ arr[i];\\n                i++;\\n            }\\n            tempNum = tempNum | arr[j];\\n            ans = Math.max(j - i + 1 , ans);\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**Please upVote, if found useful :)**",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int i = 0;\\n        int j = 0;\\n        int ans = 1;\\n        int tempNum = 0;\\n        while(j < arr.length){\\n            while((tempNum & arr[j]) != 0){\\n                tempNum = tempNum ^ arr[i];\\n                i++;\\n            }\\n            tempNum = tempNum | arr[j];\\n            ans = Math.max(j - i + 1 , ans);\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733500,
                "title": "sliding-window-easy-bit-manipulation-detailed-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return 1;\\n        //logic, for a set of numbers to have ans as 0, they should have all used different bits to create that number without any clashes\\n        //like (100 & 011) == 0 but  (100 & 110) !=0 as bits are clashing at the msb\\n        // we need to remove that number which earlier used that bit where the clash was happening\\n        int low=0;\\n        int high=0;\\n        int ans=0;\\n        int usedbits=0;\\n        while(high!=nums.size() && low<=high)\\n        {\\n            while(low!=nums.size() && (usedbits & nums[high])!=0 )//if we\\'re getting a non zero ans, one or more bits are clashing in the entire window\\n            {   \\n                usedbits^=nums[low];//1^1 will be 0 and so the bit is not free to use\\n                low++;\\n            }\\n\\n            usedbits|=nums[high];//summing up all bits used to know occupied positions\\n            ans=max(ans,high-low+1);\\n            high++;  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return 1;\\n        //logic, for a set of numbers to have ans as 0, they should have all used different bits to create that number without any clashes\\n        //like (100 & 011) == 0 but  (100 & 110) !=0 as bits are clashing at the msb\\n        // we need to remove that number which earlier used that bit where the clash was happening\\n        int low=0;\\n        int high=0;\\n        int ans=0;\\n        int usedbits=0;\\n        while(high!=nums.size() && low<=high)\\n        {\\n            while(low!=nums.size() && (usedbits & nums[high])!=0 )//if we\\'re getting a non zero ans, one or more bits are clashing in the entire window\\n            {   \\n                usedbits^=nums[low];//1^1 will be 0 and so the bit is not free to use\\n                low++;\\n            }\\n\\n            usedbits|=nums[high];//summing up all bits used to know occupied positions\\n            ans=max(ans,high-low+1);\\n            high++;  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733499,
                "title": "sliding-window-easy-bit-manipulation-detailed-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return 1;\\n        //logic, for a set of numbers to have ans as 0, they should have all used different bits to create that number without any clashes\\n        //like (100 & 011) == 0 but  (100 & 110) !=0 as bits are clashing at the msb\\n        // we need to remove that number which earlier used that bit where the clash was happening\\n        int low=0;\\n        int high=0;\\n        int ans=0;\\n        int usedbits=0;\\n        while(high!=nums.size() && low<=high)\\n        {\\n            while(low!=nums.size() && (usedbits & nums[high])!=0 )//if we\\'re getting a non zero ans, one or more bits are clashing in the entire window\\n            {   \\n                usedbits^=nums[low];//1^1 will be 0 and so the bit is not free to use\\n                low++;\\n            }\\n\\n            usedbits|=nums[high];//summing up all bits used to know occupied positions\\n            ans=max(ans,high-low+1);\\n            high++;  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return 1;\\n        //logic, for a set of numbers to have ans as 0, they should have all used different bits to create that number without any clashes\\n        //like (100 & 011) == 0 but  (100 & 110) !=0 as bits are clashing at the msb\\n        // we need to remove that number which earlier used that bit where the clash was happening\\n        int low=0;\\n        int high=0;\\n        int ans=0;\\n        int usedbits=0;\\n        while(high!=nums.size() && low<=high)\\n        {\\n            while(low!=nums.size() && (usedbits & nums[high])!=0 )//if we\\'re getting a non zero ans, one or more bits are clashing in the entire window\\n            {   \\n                usedbits^=nums[low];//1^1 will be 0 and so the bit is not free to use\\n                low++;\\n            }\\n\\n            usedbits|=nums[high];//summing up all bits used to know occupied positions\\n            ans=max(ans,high-low+1);\\n            high++;  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733413,
                "title": "using-standard-sliding-window-template",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void fillup(vector<int>&bits,int x){\\n        for(int i=0;i<bits.size();i++){\\n            if(x & (1<<i)){\\n                bits[i]++;\\n            }\\n        }\\n    }\\n    void clear(vector<int>&bits,int x){\\n        for(int i=0;i<bits.size();i++){\\n            if(x & (1<<i)){\\n                bits[i]--;\\n            }\\n        }\\n    }\\n    bool flag(vector<int>&bits){\\n        for(int i=0;i<bits.size();i++){\\n            if(bits[i]>1) return false;\\n        }\\n        return true;\\n    }\\n    int longestNiceSubarray(vector<int>& nums) {\\n        vector<int>bits(32,0);\\n        int left=0,right=0,ans=0;\\n        while(right<nums.size()){\\n           fillup(bits,nums[right]);\\n            while(!flag(bits) && left<right){\\n                clear(bits,nums[left]);\\n                left++;\\n            }\\n            ans=max(ans,right-left+1);\\n            right++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void fillup(vector<int>&bits,int x){\\n        for(int i=0;i<bits.size();i++){\\n            if(x & (1<<i)){\\n                bits[i]++;\\n            }\\n        }\\n    }\\n    void clear(vector<int>&bits,int x){\\n        for(int i=0;i<bits.size();i++){\\n            if(x & (1<<i)){\\n                bits[i]--;\\n            }\\n        }\\n    }\\n    bool flag(vector<int>&bits){\\n        for(int i=0;i<bits.size();i++){\\n            if(bits[i]>1) return false;\\n        }\\n        return true;\\n    }\\n    int longestNiceSubarray(vector<int>& nums) {\\n        vector<int>bits(32,0);\\n        int left=0,right=0,ans=0;\\n        while(right<nums.size()){\\n           fillup(bits,nums[right]);\\n            while(!flag(bits) && left<right){\\n                clear(bits,nums[left]);\\n                left++;\\n            }\\n            ans=max(ans,right-left+1);\\n            right++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732590,
                "title": "sliding-window-bit-manipulation-approach-java-simple-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    int bits[];\\n    void addBits(int num){\\n        for(int i = 0;i < 32;i++){\\n            bits[i] += (num >> i) & 1;\\n        }\\n    }\\n    void removeBits(int num){\\n        for(int i = 0;i < 32;i++){\\n            bits[i] -= (num >> i) & 1;\\n        }\\n    }\\n    boolean check(){\\n        for(var b:bits) if(b > 1) return false;\\n        return true;\\n    }\\n    public int longestNiceSubarray(int[] nums) {\\n        bits = new int[32];\\n        int ans = 1;\\n        for(int i = 0,j = 0;i <= j && j < nums.length;j++){\\n            addBits(nums[j]);\\n            for(;i <= j && !check();i++){\\n                removeBits(nums[i]);\\n            }\\n            ans = Math.max(ans,j - i + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```java\\nclass Solution {\\n    int bits[];\\n    void addBits(int num){\\n        for(int i = 0;i < 32;i++){\\n            bits[i] += (num >> i) & 1;\\n        }\\n    }\\n    void removeBits(int num){\\n        for(int i = 0;i < 32;i++){\\n            bits[i] -= (num >> i) & 1;\\n        }\\n    }\\n    boolean check(){\\n        for(var b:bits) if(b > 1) return false;\\n        return true;\\n    }\\n    public int longestNiceSubarray(int[] nums) {\\n        bits = new int[32];\\n        int ans = 1;\\n        for(int i = 0,j = 0;i <= j && j < nums.length;j++){\\n            addBits(nums[j]);\\n            for(;i <= j && !check();i++){\\n                removeBits(nums[i]);\\n            }\\n            ans = Math.max(ans,j - i + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731693,
                "title": "binary-search-sliding-window",
                "content": "# Code\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool f(vector<int>nums, int mid) {\\n\\n        vector<int>bit(31, 0);\\n\\n        for(int i = 0; i < mid; i++) {\\n            \\n            for(int j = 0; j < 31; j++) {\\n                int val = nums[i];\\n                val = ((val >> j) & 1);\\n                if(val) bit[j]++;\\n            }\\n        \\n        }\\n\\n        bool allone = true;\\n        for(int i = 0; i < 31; i++) {\\n            if(bit[i] > 1) allone = false;\\n        }\\n\\n        if(allone) return true;\\n\\n        int i = 0;\\n        int j = mid - 1;\\n        while(j < nums.size()) {\\n\\n            if(i == nums.size()) break;\\n            for(int k = 0; k < 31; k++) {\\n                int val = nums[i];\\n                val = ((val >> k) & 1);\\n                if(val) bit[k]--;\\n            }\\n\\n            i++;\\n            j++;\\n\\n            if(j == nums.size()) break;\\n            for(int k = 0; k < 31; k++) {\\n                int val = nums[j];\\n                val = ((val >> k) & 1);\\n                if(val) bit[k]++;\\n            }\\n\\n            allone = true;\\n            for(int k = 0; k < 31; k++) {\\n                if(bit[k] > 1) allone = false;\\n            }\\n            if(allone) return true;\\n        \\n        }\\n\\n        return false;\\n\\n    }\\n\\n    int longestNiceSubarray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n\\n        int ans = 1;\\n        int l = 1;\\n        int r = n;\\n        while(l <= r) {\\n            int mid = l + (r - l)/2;\\n            bool poss = f(nums, mid);\\n            if(poss) {\\n                l = mid + 1;\\n                ans = mid;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n\\nThe above binary search approach will give TLE .\\noverall Time Complexity is O(N * logN* 31)\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int longestNiceSubarray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n\\n        int ans = 1;\\n\\n        int start = 0;\\n\\n        vector<int>bit(31, 0);\\n\\n        for(int end = 0; end < nums.size(); end++) {\\n            \\n            for(int k = 0; k < 31; k++) {\\n                int val = nums[end];\\n                val = ((val >> k) & 1);\\n                if(val) bit[k]++;\\n            }\\n\\n            bool allone = true;\\n            for(int k = 0; k < 31; k++) {\\n                if(bit[k] > 1) allone = false;\\n            }\\n            if(allone) {\\n                ans = max(ans, end - start + 1);\\n                // cout<<start<<\" \"<<end<<endl;\\n            }\\n\\n            while(!allone && start < end) {\\n               \\n                for(int k = 0; k < 31; k++) {\\n                    int val = nums[start];\\n                    val = ((val >> k) & 1);\\n                    if(val) bit[k]--;\\n                }\\n\\n                start++;\\n                \\n                allone = true;\\n                for(int k = 0; k < 31; k++) {\\n                    if(bit[k] > 1) allone = false;\\n                }\\n                \\n                if(allone) {\\n                    ans = max(ans, end - start + 1);\\n                }\\n\\n            }\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n\\n\\nThe Time complexity of above approach is O((N + N)* 31)",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool f(vector<int>nums, int mid) {\\n\\n        vector<int>bit(31, 0);\\n\\n        for(int i = 0; i < mid; i++) {\\n            \\n            for(int j = 0; j < 31; j++) {\\n                int val = nums[i];\\n                val = ((val >> j) & 1);\\n                if(val) bit[j]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3731279,
                "title": "even-my-cat-understood-this-code",
                "content": "\\tclass Solution:\\n\\t\\tdef longestNiceSubarray(self, nums: List[int]) -> int:\\n\\t\\t\\tstate = [0] * 32\\n\\t\\t\\t#-----------------------------------------\\n\\t\\t\\tdef removeIt(state,value):\\n\\t\\t\\t\\tindex=0\\n\\t\\t\\t\\twhile value>0:\\n\\t\\t\\t\\t\\tif (value&1)==1:\\n\\t\\t\\t\\t\\t\\tstate[index]=0\\n\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\tvalue>>=1\\n\\t\\t\\t#-----------------------------------------\\n\\t\\t\\tdef mergeIt(state,value):\\n\\t\\t\\t\\tindex=0\\n\\t\\t\\t\\twhile value>0:\\n\\t\\t\\t\\t\\tif (value&1)==1:\\n\\t\\t\\t\\t\\t\\tstate[index]=1\\n\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\tvalue>>=1\\n\\t\\t\\t#-------------------------------------------\\n\\t\\t\\tdef isMergePossible(state,value):\\n\\t\\t\\t\\tindex = 0\\n\\t\\t\\t\\twhile value>0:\\n\\t\\t\\t\\t\\tif (value&1)==1 and state[index]==1:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\tvalue>>=1\\n\\t\\t\\t\\treturn True\\n\\t\\t\\t#=-------------------------------------\\n\\t\\t\\tres = 0\\n\\t\\t\\tpre = 0\\n\\t\\t\\tfor i,v in enumerate(nums):\\n\\t\\t\\t\\tif isMergePossible(state,v):\\n\\t\\t\\t\\t\\tmergeIt(state,v)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t#--------------------\\n\\t\\t\\t\\t\\twhile isMergePossible(state,v)!=True and pre<i:\\n\\t\\t\\t\\t\\t\\tremoveIt(state,nums[pre])\\n\\t\\t\\t\\t\\t\\tpre+=1\\n\\t\\t\\t\\t\\t#-------------------\\n\\t\\t\\t\\t\\tmergeIt(state,v)\\n\\t\\t\\t\\tres = max(res,i-pre+1)  \\n\\t\\t\\treturn res\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef longestNiceSubarray(self, nums: List[int]) -> int:\\n\\t\\t\\tstate = [0] * 32\\n\\t\\t\\t#-----------------------------------------\\n\\t\\t\\tdef removeIt(state,value):\\n\\t\\t\\t\\tindex=0\\n\\t\\t\\t\\twhile value>0:\\n\\t\\t\\t\\t\\tif (value&1)==1:\\n\\t\\t\\t\\t\\t\\tstate[index]=0\\n\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\tvalue>>=1\\n\\t\\t\\t#-----------------------------------------\\n\\t\\t\\tdef mergeIt(state,value):\\n\\t\\t\\t\\tindex=0\\n\\t\\t\\t\\twhile value>0:\\n\\t\\t\\t\\t\\tif (value&1)==1:\\n\\t\\t\\t\\t\\t\\tstate[index]=1\\n\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\tvalue>>=1\\n\\t\\t\\t#-------------------------------------------\\n\\t\\t\\tdef isMergePossible(state,value):\\n\\t\\t\\t\\tindex = 0\\n\\t\\t\\t\\twhile value>0:\\n\\t\\t\\t\\t\\tif (value&1)==1 and state[index]==1:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\tvalue>>=1\\n\\t\\t\\t\\treturn True\\n\\t\\t\\t#=-------------------------------------\\n\\t\\t\\tres = 0\\n\\t\\t\\tpre = 0\\n\\t\\t\\tfor i,v in enumerate(nums):\\n\\t\\t\\t\\tif isMergePossible(state,v):\\n\\t\\t\\t\\t\\tmergeIt(state,v)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t#--------------------\\n\\t\\t\\t\\t\\twhile isMergePossible(state,v)!=True and pre<i:\\n\\t\\t\\t\\t\\t\\tremoveIt(state,nums[pre])\\n\\t\\t\\t\\t\\t\\tpre+=1\\n\\t\\t\\t\\t\\t#-------------------\\n\\t\\t\\t\\t\\tmergeIt(state,v)\\n\\t\\t\\t\\tres = max(res,i-pre+1)  \\n\\t\\t\\treturn res\\n\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3730974,
                "title": "sliding-window-o-n",
                "content": "Key Point: \\n<!--dirn-->\\nWhenever question is about subarray we can think of Sliding Window\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor AND of subarray to be : 0\\nPosition of SET BITS of all the numbers in subarray should be different \\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int i=0,j=1;\\n        int ans =1;\\n        int mask = nums[0];\\n        while(j<n){\\n            int andd = mask&nums[j];\\n            \\n            while(andd != 0 && i<j){\\n                mask = mask^nums[i];\\n                i++;\\n                andd = mask&nums[j];\\n            }\\n            ans = max(ans,j-i+1);\\n            mask = mask|nums[j];\\n            j++;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int i=0,j=1;\\n        int ans =1;\\n        int mask = nums[0];\\n        while(j<n){\\n            int andd = mask&nums[j];\\n            \\n            while(andd != 0 && i<j){\\n                mask = mask^nums[i];\\n                i++;\\n                andd = mask&nums[j];\\n            }\\n            ans = max(ans,j-i+1);\\n            mask = mask|nums[j];\\n            j++;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730772,
                "title": "simple-c-solution-using-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*32)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(32)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&freq){\\n        for(int i=0;i<32;i++){\\n            if(freq[i]>1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n     void dfreq(vector<int>&freq,int n){\\n        for(int i=0;i<32;i++){\\n            if(1&(n>>i)){\\n                freq[i]--;\\n            }\\n        }\\n    }\\n    void ifreq(vector<int>&freq,int n){\\n        for(int i=0;i<32;i++){\\n            if(1&(n>>i)){\\n                freq[i]++;\\n            }\\n        }\\n    }\\n    \\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>freq(32,0);\\n        int start=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ifreq(freq,nums[i]);\\n            while(check(freq)!=true){\\n                 dfreq(freq,nums[start]);\\n                 start++;\\n            }\\n          ans=max(ans,i-start+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&freq){\\n        for(int i=0;i<32;i++){\\n            if(freq[i]>1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n     void dfreq(vector<int>&freq,int n){\\n        for(int i=0;i<32;i++){\\n            if(1&(n>>i)){\\n                freq[i]--;\\n            }\\n        }\\n    }\\n    void ifreq(vector<int>&freq,int n){\\n        for(int i=0;i<32;i++){\\n            if(1&(n>>i)){\\n                freq[i]++;\\n            }\\n        }\\n    }\\n    \\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>freq(32,0);\\n        int start=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ifreq(freq,nums[i]);\\n            while(check(freq)!=true){\\n                 dfreq(freq,nums[start]);\\n                 start++;\\n            }\\n          ans=max(ans,i-start+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730117,
                "title": "c-easy-sliding-window",
                "content": "```\\nclass Solution {\\nprivate:\\n    void fill(vector<int> &vis, int n){\\n        for(int i = 0; i<32; ++i){\\n            if(n & (1 << i)) vis[i]++;\\n        }\\n    }\\n    void clear(vector<int> &vis, int n){\\n        for(int i = 0; i<32; ++i){\\n            if(n & (1 << i)) vis[i]--;\\n        }\\n    }\\n    bool check(vector<int> &vis){\\n        for(int i = 0; i<32; ++i){\\n            if(vis[i] > 1) return 0;\\n        }\\n        return 1;\\n    }\\npublic:\\n    int longestNiceSubarray(vector<int>& a) {\\n        int n = a.size();\\n        int i = 0, ans = 1;\\n        vector<int> vis(32,0);\\n        for(int j = 0; j<n; ++j){\\n            fill(vis, a[j]);\\n            while(!check(vis)){\\n                clear(vis, a[i]);\\n                i++;\\n            }\\n            ans = max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void fill(vector<int> &vis, int n){\\n        for(int i = 0; i<32; ++i){\\n            if(n & (1 << i)) vis[i]++;\\n        }\\n    }\\n    void clear(vector<int> &vis, int n){\\n        for(int i = 0; i<32; ++i){\\n            if(n & (1 << i)) vis[i]--;\\n        }\\n    }\\n    bool check(vector<int> &vis){\\n        for(int i = 0; i<32; ++i){\\n            if(vis[i] > 1) return 0;\\n        }\\n        return 1;\\n    }\\npublic:\\n    int longestNiceSubarray(vector<int>& a) {\\n        int n = a.size();\\n        int i = 0, ans = 1;\\n        vector<int> vis(32,0);\\n        for(int j = 0; j<n; ++j){\\n            fill(vis, a[j]);\\n            while(!check(vis)){\\n                clear(vis, a[i]);\\n                i++;\\n            }\\n            ans = max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722891,
                "title": "longest-nice-subarray-sliding-window-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing sliding window approach perform XOR to exclude bits and OR to include the bits\\nPls do upvote if you found this helpful.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n   **Concepts :**\\n\\n    - AND - In bitwise AND if both bits in the compared position of the bit patterns are 1, the bit in the resulting bit pattern is 1, otherwise 0.\\n    \\n    - OR - Bitwise OR is also similar to bitwise AND. If both bits in the compared position of the bit patterns are 0, the bit in the resulting bit pattern is 0, otherwise 1.\\n\\n    - XOR - In bitwise XOR if both bits are 0 or 1, the result will be 0, otherwise 1\\n\\n\\n**Understanding Question :**\\n\\n     - we have to find a continuous subarray where AND all numbers should be 0\\n     - the numbers satisfying CANNOT be from discontinous positions\\n     \\n\\n**Approach :**\\n\\n    - we have to use a sliding window approach \\n    - whenever we find a number which when performed AND gives 1 ,\\n    - we keep dropping the first number from the window until AND gives us 0\\n\\n\\n    Example : \\n        [1 , 3 , 8 , 48 , 10]\\n\\n    - num variable is used in code to store binary representation of all numbers which gives us 1\\n    - intitally num = 0\\n    - [1 , 3 , 8 , 48 , 10]\\n      left right\\n\\n      num    AND                 include(OR)              exclude(XOR)\\n    -  0     0&1=0                  0|1 = 1                 --\\n    -  1    01&11=01                 --                   O1^11=10 (note : we eliminated 1 from start of window , now we have 3 )\\n    -  3    0011&1000=0           0011|1000=1011            --\\n    - 3, 8  001011&110000=0       001011|110000=111011      --\\n    - 3,8,48 111011&001010=001010      --                111011^000011 = 111000 \\n    \\n- NOTE : When you XOR , XOR **current num** with **number at starting of sliding window**\\n- also ,  when we include number using OR ,  we include all pairs we find during traversal , so we **do not** have to revisit pairs           \\n    \\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        \\n        int left = 0;\\n        //num is used for storing binary representation of all number satisfying AND == 0\\n        int num = 0;\\n        int maxlen = 0;\\n        for(int right = 0 ; right < nums.length;right++)\\n        {\\n            while((num & nums[right]) != 0)\\n            {\\n                //if AND != 0 , exclude the bits from start of window\\n                //XOR - exclude number from start of window\\n                num = num ^ nums[left];\\n                left++;\\n            }\\n            //if AND == 0 , include the bits of current number into num\\n            //OR operations includes bits\\n            num = num | nums[right];\\n            maxlen = Math.max(maxlen , right - left + 1);\\n        }\\n\\n        return maxlen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        \\n        int left = 0;\\n        //num is used for storing binary representation of all number satisfying AND == 0\\n        int num = 0;\\n        int maxlen = 0;\\n        for(int right = 0 ; right < nums.length;right++)\\n        {\\n            while((num & nums[right]) != 0)\\n            {\\n                //if AND != 0 , exclude the bits from start of window\\n                //XOR - exclude number from start of window\\n                num = num ^ nums[left];\\n                left++;\\n            }\\n            //if AND == 0 , include the bits of current number into num\\n            //OR operations includes bits\\n            num = num | nums[right];\\n            maxlen = Math.max(maxlen , right - left + 1);\\n        }\\n\\n        return maxlen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716697,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int j = 0;\\n        int ans = 0;\\n        int temp = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            while(j<=i && temp&nums[i]){\\n                temp ^= nums[j];\\n                j++;\\n            }\\n            temp |= nums[i];\\n            ans = max(ans,i-j+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int j = 0;\\n        int ans = 0;\\n        int temp = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            while(j<=i && temp&nums[i]){\\n                temp ^= nums[j];\\n                j++;\\n            }\\n            temp |= nums[i];\\n            ans = max(ans,i-j+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706221,
                "title": "sliding-window-simple-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) \\n    {\\n        int num = 0;\\n        int j=0;\\n        int ans = INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            while((num & nums[i])!=0)\\n            {\\n                num^=nums[j];\\n                j++;\\n            }\\n            num|=nums[i];\\n            ans = max(ans,i-j+1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) \\n    {\\n        int num = 0;\\n        int j=0;\\n        int ans = INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            while((num & nums[i])!=0)\\n            {\\n                num^=nums[j];\\n                j++;\\n            }\\n            num|=nums[i];\\n            ans = max(ans,i-j+1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689064,
                "title": "simple-python-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        countNums = len(nums)\\n        longestNiceSubarray = 1\\n\\n        for i in range(countNums):\\n            xor = nums[i]\\n            for j in range(i + 1, countNums):\\n                if xor & nums[j] > 0:\\n                    break\\n                longestNiceSubarray = max(longestNiceSubarray, j - i + 1)\\n                xor ^= nums[j]\\n        return longestNiceSubarray\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        countNums = len(nums)\\n        longestNiceSubarray = 1\\n\\n        for i in range(countNums):\\n            xor = nums[i]\\n            for j in range(i + 1, countNums):\\n                if xor & nums[j] > 0:\\n                    break\\n                longestNiceSubarray = max(longestNiceSubarray, j - i + 1)\\n                xor ^= nums[j]\\n        return longestNiceSubarray\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686554,
                "title": "easy-solution-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvery numbers that \"obliterate\" each other, have their 1s in different positions in the binary:\\n|number | binary|\\n| - | -------|\\n| 3 | 0000011|\\n| 8 | 0001000|\\n| 48| 0110000|\\n| 64| 1000000|\\n\\nYou can see all of them nicely obliterating each other cause where one number has 1s, others have zeros.\\nBecause they all have ones in different positions we can just store them all together:\\n```ts\\ncurSum = 3 + 8 + 48 // 59 = 00111011 in binary\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo you can easily check that if new number would obliterate all others,\\njust by doing & operation with a current sum:\\n```ts\\n59 & 64 = 00111011 & 1000000 = 0\\n```\\nIf they are not result in 0, you can remove some numbers from the start to make it happen. Since they all have ones in different places, you can just use ordinary - operation:\\n```ts\\n// 00111011 -\\n// 00000011\\n// --------\\n// 00111000\\n59 - 3 = 3 + 8 + 48 - 3 = 8 + 48 = 56\\n```\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction longestNiceSubarray(nums: number[]): number {\\n    let [start, end] = [0, 0];\\n    let curSum = 0;\\n    const n = nums.length;\\n    let len = 1;\\n    while (start < n && end < n) {\\n        while (start < n && ((curSum & nums[end]) !== 0)) {\\n            curSum -= nums[start];\\n            start++;\\n        }\\n        curSum += nums[end];\\n        len = Math.max(len, end - start + 1);\\n        end++;\\n    }\\n    return len;\\n\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\ncurSum = 3 + 8 + 48 // 59 = 00111011 in binary\\n```\n```ts\\n59 & 64 = 00111011 & 1000000 = 0\\n```\n```ts\\n// 00111011 -\\n// 00000011\\n// --------\\n// 00111000\\n59 - 3 = 3 + 8 + 48 - 3 = 8 + 48 = 56\\n```\n```\\nfunction longestNiceSubarray(nums: number[]): number {\\n    let [start, end] = [0, 0];\\n    let curSum = 0;\\n    const n = nums.length;\\n    let len = 1;\\n    while (start < n && end < n) {\\n        while (start < n && ((curSum & nums[end]) !== 0)) {\\n            curSum -= nums[start];\\n            start++;\\n        }\\n        curSum += nums[end];\\n        len = Math.max(len, end - start + 1);\\n        end++;\\n    }\\n    return len;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683832,
                "title": "c-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n    int n=nums.size(),mx=0,i=0,j=0,bit=0;\\n    while(i<n and j<n){\\n        while(bit&nums[j]){\\n            bit^=nums[i];\\n            i++;\\n        }\\n    bit|=nums[j];\\n    mx=max(mx,j-i+1);\\n    j++;\\n    }\\n    return mx;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n    int n=nums.size(),mx=0,i=0,j=0,bit=0;\\n    while(i<n and j<n){\\n        while(bit&nums[j]){\\n            bit^=nums[i];\\n            i++;\\n        }\\n    bit|=nums[j];\\n    mx=max(mx,j-i+1);\\n    j++;\\n    }\\n    return mx;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658559,
                "title": "c-easiest-solution-sliding-window-bit",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int res=1;\\n        int i =0 , j=1;\\n        int till  = nums[0];\\n        while(j<n){\\n            if( (till&nums[j])==0 ){\\n                till = (till|nums[j]);\\n                res=max(res,j-i+1);\\n                j++;\\n            }else{\\n                till= (till& ~(nums[i]));\\n                i++;\\n            }\\n        }\\n          \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Sliding Window",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int res=1;\\n        int i =0 , j=1;\\n        int till  = nums[0];\\n        while(j<n){\\n            if( (till&nums[j])==0 ){\\n                till = (till|nums[j]);\\n                res=max(res,j-i+1);\\n                j++;\\n            }else{\\n                till= (till& ~(nums[i]));\\n                i++;\\n            }\\n        }\\n          \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657736,
                "title": "c-easy-and-fast-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int LongestNiceSubarray(int[] nums) {\\n            int maxres = 1;\\n            for (int i = 0; i < nums.Length - 1; i++)\\n            {\\n                int res = 1;\\n                int te = nums[i];\\n                for (int j = i + 1; j < nums.Length; j++)\\n                {\\n\\n                    if ((te & nums[j]) == 0)\\n                    {\\n                        res++;\\n                        if (res > maxres)\\n                        {\\n                            maxres = res;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                    te = te | nums[j];\\n                }\\n            }\\n            return maxres;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestNiceSubarray(int[] nums) {\\n            int maxres = 1;\\n            for (int i = 0; i < nums.Length - 1; i++)\\n            {\\n                int res = 1;\\n                int te = nums[i];\\n                for (int j = i + 1; j < nums.Length; j++)\\n                {\\n\\n                    if ((te & nums[j]) == 0)\\n                    {\\n                        res++;\\n                        if (res > maxres)\\n                        {\\n                            maxres = res;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                    te = te | nums[j];\\n                }\\n            }\\n            return maxres;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649122,
                "title": "python-simple-solution",
                "content": "Here is my solution.\\n\\n```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        start, end, result = 0, 0, 1\\n\\n        for i in range(1, len(nums)):\\n            for j in range(end, start - 1, -1):\\n                if nums[i] & nums[j] != 0:\\n                    start = j + 1\\n                    break\\n\\n            end = i\\n            result = max(result, end - start + 1)\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        start, end, result = 0, 0, 1\\n\\n        for i in range(1, len(nums)):\\n            for j in range(end, start - 1, -1):\\n                if nums[i] & nums[j] != 0:\\n                    start = j + 1\\n                    break\\n\\n            end = i\\n            result = max(result, end - start + 1)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641376,
                "title": "sliding-window-and-bit-manipulation-time-complexity-o-n-space-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe question appears to be another variation of the sliding window algorithm.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n<b>Pseudocode</b> \\n\\n```\\n\\n/* We need to check each element in the array this will be very computationally slow if we recalculate \\nrepeated results sliding window algorith allows us to use previous calculations */\\n\\n\\nlongestNiceArrayLength = 0 \\n\\n// represents start/end index of sliding window\\nstartIndex = 0, endIndex = 0 \\n\\n// aggregation of values in sliding window\\naggregatedResult = 0   \\n\\nwhile endIndex < nums.length\\n\\n    nice =  aggregatedResult AND nums[endIndex] === 0\\n\\n    while not nice, \\n        remove the nums[startIndex] pattern from aggregatedResult\\n        inc startIndex\\n        nice =  aggregatedResult AND nums[endIndex] === 0 \\n\\n    is current nice array longer than longest so far? If so update\\n\\n\\n    // update the aggregatedResult with new end value of sliding window\\n    aggregatedResult = aggregatedResult | nums[endIndex]\\n\\n    inc the endIndex \\n\\n\\n return longestNiceArray\\n\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction longestNiceSubarray(nums: number[]): number {\\n    let [startIndex, endIndex, longestNiceArrayLength, aggregatedResult] = [0,0,0,0];\\n\\n    while(endIndex < nums.length){\\n        let nice = (aggregatedResult & nums[endIndex]) === 0;\\n\\n        while(!nice){\\n           // remove the nums[startIndex] pattern from aggregatedResult\\n           aggregatedResult = ~nums[startIndex] & aggregatedResult;\\n           ++startIndex;\\n           nice = (aggregatedResult & nums[endIndex]) === 0;\\n        }\\n\\n        longestNiceArrayLength = Math.max(longestNiceArrayLength, endIndex - startIndex + 1);\\n        // update the aggregatedResult with new element at end of window\\n        aggregatedResult = nums[endIndex] | aggregatedResult;\\n        ++endIndex;\\n    }\\n\\n    return longestNiceArrayLength;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n\\n/* We need to check each element in the array this will be very computationally slow if we recalculate \\nrepeated results sliding window algorith allows us to use previous calculations */\\n\\n\\nlongestNiceArrayLength = 0 \\n\\n// represents start/end index of sliding window\\nstartIndex = 0, endIndex = 0 \\n\\n// aggregation of values in sliding window\\naggregatedResult = 0   \\n\\nwhile endIndex < nums.length\\n\\n    nice =  aggregatedResult AND nums[endIndex] === 0\\n\\n    while not nice, \\n        remove the nums[startIndex] pattern from aggregatedResult\\n        inc startIndex\\n        nice =  aggregatedResult AND nums[endIndex] === 0 \\n\\n    is current nice array longer than longest so far? If so update\\n\\n\\n    // update the aggregatedResult with new end value of sliding window\\n    aggregatedResult = aggregatedResult | nums[endIndex]\\n\\n    inc the endIndex \\n\\n\\n return longestNiceArray\\n\\n```\n```\\nfunction longestNiceSubarray(nums: number[]): number {\\n    let [startIndex, endIndex, longestNiceArrayLength, aggregatedResult] = [0,0,0,0];\\n\\n    while(endIndex < nums.length){\\n        let nice = (aggregatedResult & nums[endIndex]) === 0;\\n\\n        while(!nice){\\n           // remove the nums[startIndex] pattern from aggregatedResult\\n           aggregatedResult = ~nums[startIndex] & aggregatedResult;\\n           ++startIndex;\\n           nice = (aggregatedResult & nums[endIndex]) === 0;\\n        }\\n\\n        longestNiceArrayLength = Math.max(longestNiceArrayLength, endIndex - startIndex + 1);\\n        // update the aggregatedResult with new element at end of window\\n        aggregatedResult = nums[endIndex] | aggregatedResult;\\n        ++endIndex;\\n    }\\n\\n    return longestNiceArrayLength;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3598416,
                "title": "ruby-in-10-lines",
                "content": "```\\n# hint: 11102 XOR 10012 = 01112 (this is equivalent to addition without carry)\\n# ref: https://en.wikipedia.org/wiki/Exclusive_or\\n\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef longest_nice_subarray(nums)\\n  left_idx = res = tally = 0\\n  (0...nums.size).each { |right_idx|\\n    while tally & nums[right_idx] > 0\\n      tally ^= nums[left_idx]\\n      left_idx += 1\\n    end\\n    res = [res, right_idx - left_idx + 1].max\\n    tally ^= nums[right_idx]\\n  }\\n  res\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# hint: 11102 XOR 10012 = 01112 (this is equivalent to addition without carry)\\n# ref: https://en.wikipedia.org/wiki/Exclusive_or\\n\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef longest_nice_subarray(nums)\\n  left_idx = res = tally = 0\\n  (0...nums.size).each { |right_idx|\\n    while tally & nums[right_idx] > 0\\n      tally ^= nums[left_idx]\\n      left_idx += 1\\n    end\\n    res = [res, right_idx - left_idx + 1].max\\n    tally ^= nums[right_idx]\\n  }\\n  res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3555578,
                "title": "c-and-java-solution-sld-wind-bit-manip",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n\\n**PLS UPVOTE**\\n# C++\\n```\\nint n=nums.length;\\n        int ans=1;\\n        int or_res=0;\\n        int i=0;\\n        int j;\\n        for(j=0;j<n;j++){\\n            while(j<n && ((or_res & nums[j])==0)){\\n                or_res=or_res | nums[j];\\n                j++;\\n            }\\n            ans=max(ans,j-i);\\n            if(j==n) break;\\n            while(i<j && ((or_res & nums[j])!=0)){\\n                or_res^=nums[i];\\n                i++;\\n            }\\n            if(i==j){\\n                or_res|=nums[j];\\n            }\\n            else j--;\\n        }\\n        return ans;\\n```\\n# Code\\n```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int n=nums.length;\\n        int ans=1;\\n        int or_res=0;\\n        int i=0;\\n        int j;\\n        for(j=0;j<n;j++){\\n            while(j<n && ((or_res & nums[j])==0)){\\n                or_res=or_res | nums[j];\\n                j++;\\n            }\\n            ans=Math.max(ans,j-i);\\n            if(j==n) break;\\n            while(i<j && ((or_res & nums[j])!=0)){\\n                or_res^=nums[i];\\n                i++;\\n            }\\n            if(i==j){\\n                or_res|=nums[j];\\n            }\\n            else j--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint n=nums.length;\\n        int ans=1;\\n        int or_res=0;\\n        int i=0;\\n        int j;\\n        for(j=0;j<n;j++){\\n            while(j<n && ((or_res & nums[j])==0)){\\n                or_res=or_res | nums[j];\\n                j++;\\n            }\\n            ans=max(ans,j-i);\\n            if(j==n) break;\\n            while(i<j && ((or_res & nums[j])!=0)){\\n                or_res^=nums[i];\\n                i++;\\n            }\\n            if(i==j){\\n                or_res|=nums[j];\\n            }\\n            else j--;\\n        }\\n        return ans;\\n```\n```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int n=nums.length;\\n        int ans=1;\\n        int or_res=0;\\n        int i=0;\\n        int j;\\n        for(j=0;j<n;j++){\\n            while(j<n && ((or_res & nums[j])==0)){\\n                or_res=or_res | nums[j];\\n                j++;\\n            }\\n            ans=Math.max(ans,j-i);\\n            if(j==n) break;\\n            while(i<j && ((or_res & nums[j])!=0)){\\n                or_res^=nums[i];\\n                i++;\\n            }\\n            if(i==j){\\n                or_res|=nums[j];\\n            }\\n            else j--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511355,
                "title": "two-pinters-c-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int j=0;\\n        int num=0;\\n        int maxx=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            while((num&nums[i])!=0){\\n                num^=nums[j++]; //XOR OF THE J INDEXED NUMBERS\\n            }\\n            num|=nums[i];\\n            maxx=max(maxx,(i-j)+1);\\n        }\\n        return maxx;\\n\\n\\n\\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int j=0;\\n        int num=0;\\n        int maxx=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            while((num&nums[i])!=0){\\n                num^=nums[j++]; //XOR OF THE J INDEXED NUMBERS\\n            }\\n            num|=nums[i];\\n            maxx=max(maxx,(i-j)+1);\\n        }\\n        return maxx;\\n\\n\\n\\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500764,
                "title": "sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        res = AND = l = 0\\n        for r in range(len(nums)):\\n            while AND & nums[r]: # narrowing window\\n                AND ^= nums[l] # remove the effect of nums[l], as AND is realized according to AND | nums[r] and AND & nums[r] = 0\\n                l += 1 # window left edge shift to right \\n            AND |= nums[r]\\n            res = max(res, r - l + 1)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        res = AND = l = 0\\n        for r in range(len(nums)):\\n            while AND & nums[r]: # narrowing window\\n                AND ^= nums[l] # remove the effect of nums[l], as AND is realized according to AND | nums[r] and AND & nums[r] = 0\\n                l += 1 # window left edge shift to right \\n            AND |= nums[r]\\n            res = max(res, r - l + 1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469714,
                "title": "longest-nice-subarray",
                "content": "----------------- Easy C++ Solution -------------------\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n    int ans = 0;\\n    int usedBits = 0;\\n\\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\\n      while (usedBits & nums[r])\\n        usedBits ^= nums[l++];\\n      usedBits |= nums[r];\\n      ans = max(ans, r - l + 1);\\n    }\\n\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n    int ans = 0;\\n    int usedBits = 0;\\n\\n    for (int l = 0, r = 0; r < nums.size(); ++r) {\\n      while (usedBits & nums[r])\\n        usedBits ^= nums[l++];\\n      usedBits |= nums[r];\\n      ans = max(ans, r - l + 1);\\n    }\\n\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466928,
                "title": "python3-solution-sliding-window-and-bitmask",
                "content": "\\n```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        mxl = 0\\n        n = len(nums)\\n        l = 0\\n\\n        cnt = bm = 0\\n        \\n        for r,val in enumerate(nums):\\n            while bm & val != 0 and l<=r:\\n                bm = bm ^ nums[l]\\n                l += 1\\n                cnt -= 1\\n                \\n            if bm & val == 0:\\n                cnt += 1\\n\\n            mxl = max(mxl,cnt)\\n            bm = bm | val\\n        \\n        return mxl\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        mxl = 0\\n        n = len(nums)\\n        l = 0\\n\\n        cnt = bm = 0\\n        \\n        for r,val in enumerate(nums):\\n            while bm & val != 0 and l<=r:\\n                bm = bm ^ nums[l]\\n                l += 1\\n                cnt -= 1\\n                \\n            if bm & val == 0:\\n                cnt += 1\\n\\n            mxl = max(mxl,cnt)\\n            bm = bm | val\\n        \\n        return mxl\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455331,
                "title": "python3-sliding-window-approach",
                "content": "# Intuition\\nWe need to find longest nice subarray. That means that we need to find longest subarray, any two items of which have AND equal ``0``, that means not having a common bit. \\nWe can use sliding window approach for that. \\nWe will keep all bits that are set for any of the items in the window - that will be bitwise OR of the items.\\n\\n# Approach\\n1. Initialize window bits as ``0``\\n2. On each step if consequent value ``nums[i]`` has common bits with any item in the window (has non-zero AND with current window bits) - moving left side of the window right until ``nums[i]`` doesn\\'t have any common bits with the window.\\n3. Add ``nums[i]`` to window bits (by using XOR operation) and update longest window length\\n4. Return lomgest window length\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        longest = 1\\n        i1 = 0\\n        n = len(nums)\\n        current = 0\\n        for i in range(n):\\n            while i1 < i and current & nums[i]:\\n                current ^= nums[i1]\\n                i1 += 1\\n            current |= nums[i]\\n            longest = max(longest, i-i1+1)\\n\\n        return longest\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def longestNiceSubarray(self, nums: List[int]) -> int:\\n        longest = 1\\n        i1 = 0\\n        n = len(nums)\\n        current = 0\\n        for i in range(n):\\n            while i1 < i and current & nums[i]:\\n                current ^= nums[i1]\\n                i1 += 1\\n            current |= nums[i]\\n            longest = max(longest, i-i1+1)\\n\\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455229,
                "title": "using-binary-search-and-sliding-window-30-n-log-n-solution",
                "content": "Was trying to make use of the monotonic search space, was doing search on the length of the subarray possible, from 1 to 30, and The problem is The code passed all the test case, but Still showing Time Limit Exceeded, Any suggestion why it i happening.. \\n```\\nint longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> v(n, vector<int>(30,0));\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < 30; j++){\\n                if(nums[i] & (1 << j)){\\n                    v[i][j] = 1;\\n                }\\n            }\\n            \\n        }\\n        int l = 1, r = min(30, n), maxi = 1;\\n        while(l <= r){\\n            int mid = (l + r)/2;\\n            unordered_map<int,int> mp;\\n            int count = 0;\\n            bool flag = false;\\n            for(int i = 0; i < mid; i++){\\n                for(int j = 0; j < 30; j++){\\n                    if(v[i][j] == 1) mp[j]++, count++;\\n                }\\n            }\\n            for(int i = mid; i < n; i++){\\n                if(count == mp.size()){\\n                    flag = true;\\n                    break;\\n                }\\n                for(int j = 0; j < 30; j++){\\n                    if(v[i][j] == 1) mp[j]++, count++;\\n                }\\n                for(int j = 0; j < 30; j++){\\n                    if(v[i - mid][j] == 1){ \\n                        mp[j]--, count--;\\n                        if(mp[j] == 0) mp.erase(j);\\n                    }\\n                }\\n            }\\n            if(count == mp.size()){\\n                    flag = true;\\n            }\\n            if(flag){\\n                l = mid + 1;\\n                maxi = max(maxi, mid);\\n            }\\n            else{\\n                r = mid - 1;\\n            } \\n        }\\n        return maxi;\\n    }\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nint longestNiceSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> v(n, vector<int>(30,0));\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < 30; j++){\\n                if(nums[i] & (1 << j)){\\n                    v[i][j] = 1;\\n                }\\n            }\\n            \\n        }\\n        int l = 1, r = min(30, n), maxi = 1;\\n        while(l <= r){\\n            int mid = (l + r)/2;\\n            unordered_map<int,int> mp;\\n            int count = 0;\\n            bool flag = false;\\n            for(int i = 0; i < mid; i++){\\n                for(int j = 0; j < 30; j++){\\n                    if(v[i][j] == 1) mp[j]++, count++;\\n                }\\n            }\\n            for(int i = mid; i < n; i++){\\n                if(count == mp.size()){\\n                    flag = true;\\n                    break;\\n                }\\n                for(int j = 0; j < 30; j++){\\n                    if(v[i][j] == 1) mp[j]++, count++;\\n                }\\n                for(int j = 0; j < 30; j++){\\n                    if(v[i - mid][j] == 1){ \\n                        mp[j]--, count--;\\n                        if(mp[j] == 0) mp.erase(j);\\n                    }\\n                }\\n            }\\n            if(count == mp.size()){\\n                    flag = true;\\n            }\\n            if(flag){\\n                l = mid + 1;\\n                maxi = max(maxi, mid);\\n            }\\n            else{\\n                r = mid - 1;\\n            } \\n        }\\n        return maxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3424764,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int temp=nums[i];\\n            int len=1;\\n            for(int j=i;j<n-1;j++)\\n            {\\n                if((temp xor nums[j+1])== temp+nums[j+1] )\\n                {\\n                    len++;\\n                    temp+=nums[j+1];\\n                }\\n                else\\n                    break;\\n\\n            }       \\n            ans=max(ans,len);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int temp=nums[i];\\n            int len=1;\\n            for(int j=i;j<n-1;j++)\\n            {\\n                if((temp xor nums[j+1])== temp+nums[j+1] )\\n                {\\n                    len++;\\n                    temp+=nums[j+1];\\n                }\\n                else\\n                    break;\\n\\n            }       \\n            ans=max(ans,len);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419540,
                "title": "simple-c-solution-using-bit-manipulation",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int final=1;\\n        int res=nums[0],ans=1,k=0;\\n        for(int i=1;i<nums.size();++i){\\n            if((res&nums[i])==0){\\n                ans++;\\n                res=res|nums[i];\\n            }\\n            else{\\n                final=max(final,ans);\\n                while(k<i && (res&nums[i])!=0){\\n                    res=res^nums[k++];\\n                    ans--;\\n                } \\n                ans++;\\n                res|=nums[i];\\n            }\\n        }\\n        final=max(final,ans); \\n        return final;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int final=1;\\n        int res=nums[0],ans=1,k=0;\\n        for(int i=1;i<nums.size();++i){\\n            if((res&nums[i])==0){\\n                ans++;\\n                res=res|nums[i];\\n            }\\n            else{\\n                final=max(final,ans);\\n                while(k<i && (res&nums[i])!=0){\\n                    res=res^nums[k++];\\n                    ans--;\\n                } \\n                ans++;\\n                res|=nums[i];\\n            }\\n        }\\n        final=max(final,ans); \\n        return final;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400465,
                "title": "sliding-window-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int res=0;int curor=0;int i=0; int j=0;int n=nums.length;\\n        while(j<n){\\n            while((nums[j] & curor) >0 ){\\n                curor ^=nums[i];\\n                i++;\\n            }\\n            curor |= nums[j];\\n            res=Math.max(res,j-i+1);\\n            j++;\\n            \\n        }\\n       return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int longestNiceSubarray(int[] nums) {\\n        int res=0;int curor=0;int i=0; int j=0;int n=nums.length;\\n        while(j<n){\\n            while((nums[j] & curor) >0 ){\\n                curor ^=nums[i];\\n                i++;\\n            }\\n            curor |= nums[j];\\n            res=Math.max(res,j-i+1);\\n            j++;\\n            \\n        }\\n       return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396519,
                "title": "python-linear-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def longestNiceSubarray(self, nums):\\n        window_size, curr_sum, longest = 1, nums[0], 1\\n\\n        for i in range(1,len(nums)):       \\n            while curr_sum & nums[i] != 0:\\n                curr_sum -= nums[i-window_size]\\n                window_size-=1\\n            curr_sum+=nums[i]\\n            window_size+=1\\n            longest = max(longest, window_size)\\n\\n        return longest\\n\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestNiceSubarray(self, nums):\\n        window_size, curr_sum, longest = 1, nums[0], 1\\n\\n        for i in range(1,len(nums)):       \\n            while curr_sum & nums[i] != 0:\\n                curr_sum -= nums[i-window_size]\\n                window_size-=1\\n            curr_sum+=nums[i]\\n            window_size+=1\\n            longest = max(longest, window_size)\\n\\n        return longest\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381136,
                "title": "c-faster-than-93-88-o-n-2-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int leftBound = 0, res = 1, n = nums.size();\\n        for (int i = 1; i < n; ++ i) {\\n            for (int j = i - 1; j >= leftBound; -- j) {\\n                if ((nums[i] & nums[j]) != 0) {\\n                    res = max(res, i - leftBound);\\n                    leftBound = j + 1;\\n                    break;\\n                }\\n            }\\n        }\\n        res = max(res, n - leftBound);\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& nums) {\\n        int leftBound = 0, res = 1, n = nums.size();\\n        for (int i = 1; i < n; ++ i) {\\n            for (int j = i - 1; j >= leftBound; -- j) {\\n                if ((nums[i] & nums[j]) != 0) {\\n                    res = max(res, i - leftBound);\\n                    leftBound = j + 1;\\n                    break;\\n                }\\n            }\\n        }\\n        res = max(res, n - leftBound);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1791815,
                "content": [
                    {
                        "username": "suck_77",
                        "content": "Since the range of `nums[i]`, the size of sliding windows is guaranteed not larger than 32. As a result, O(n^2) solutions without sliding window are also accepted. I suggest that add zero to the range of `nums[i]` and add test cases like `[0] * 100000`."
                    },
                    {
                        "username": "MiepjeMadelon",
                        "content": "[904163577,321202512,470948612,490925389,550193477,87742556,151890632,655280661,4,263168,32,573703555,886743681,937599702,120293650,725712231,257119393] \ngives me the result \n[4, 263168, 32, 886743681], which I believe is correct. Does anyone know why the answer still is 3 instead of 4? \nEDIT: Just found out the subarray has to be continuous in the array. I'll leave the comment if anyone else has the same question."
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "[4, 263168, 32, 886743681] bro this is not contiguous in your testcase , look it carefully that\\'swhy he gave u the 3 ans in ur testcase the contiguous subarray is this... \\n      [4, 263168, 32, 573703555 ,886743681]"
                    },
                    {
                        "username": "No-one1",
                        "content": "Someone please help me with this code :\\n\\n```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector& nums) {\\nlong long mask = 0;\\nint res=0;\\nint count = 0;\\nfor(int i=0 ; i<nums.size() ; i++){\\nint x = mask&nums[i];\\nif(x==0){\\nmask = mask|nums[i];\\n\\n            cout<<count<<endl;\\n \\n            count++;\\n            \\n        }\\n        else{\\n            cout<<count<<endl;\\n            res = max(count,res);\\n            mask=nums[i];\\n            count=1;\\n        }\\n    }\\n    res = max(count,res);\\n    return res;\\n}\\n};\\n```\\nI am stuck at the test case : [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\nwhere desired output is 8 but I am getting 7 "
                    },
                    {
                        "username": "moradiya84",
                        "content": "i think i get it what we are doing is if subarray[1...5]is nicearray then adding 6 is not making it nice so we are jumping directly to 6 but it's not necessary what if subarray[3....9] is nice we are not considering so we should keep on decreasing our size untill it became nice once again or i==j."
                    },
                    {
                        "username": "moradiya84",
                        "content": "did you get it? \\nI am also stuck at same test case\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int ans=1;\\n        int x=1;\\n        long long p=v[0];\\n        for(int i=1;i<v.size();i++){\\n            long long z=v[i];\\n            if((p&z)==0){\\n                x++;\\n                ans=max(ans,x);\\n                p=p|z;\\n            }\\n            else{\\n                x=1;\\n                p=(long long)v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere\\'s mt code"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n for this test cases I believe the longest nice subarray is [65552,50331652,1,1048576,16384,544,270532608] and its length is 7 but the answer is 8.\\ncan someone please verify this?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur)[@Darshan Jain](/No-one1) so , instead what we can do is instead of shiffting both left and right pointers to the current index, we can shift left pointer to the index where the fault begin ( i.e. to the last element where OR != 0 \\n \\ni am pasting code here you can refer :\\n\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int mask = 0; \\n\\n        int l = 0 , r= 0; \\n        int max = 0; \\n\\n        while( r < arr.length ){\\n\\n            if( (mask&arr[r]) == 0 ){\\n                mask = mask | arr[r]; \\n                max = Math.max(max,r-l+1); \\n                r++; \\n            }else{\\n                mask = mask^arr[l]; \\n                l++; \\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur) yes bro i think i found where the  mistake is \\nso , the problem is [ a , b , c , d, e, f, g, h , i] suppose this is the given array and we have to find longest Nice subarray and suppose answer is 5 and we are getting 4 according to our code  , and the answer subarrray is [ c , d,e,g,h] , but according to our code if it found that current subbarray is not nice , we directly jump both left and right pointers to the current element. For example [ a , b , c , d] was a nice subarray but  b | e != 0 then according to our code it will directy jump to e . instead our left pointer should point towards c , i.e, to the next element that was creating fault. \\n\\nHope u understand ;>)"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[@No-one1](/No-one1)  still no answer :\\'("
                    },
                    {
                        "username": "No-one1",
                        "content": "Have you got the answer?\\nI am also stuck here can you please explain"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thank you people in the comments for the test cases!"
                    },
                    {
                        "username": "neo_mxn0",
                        "content": "Wrong test case or I\\'m I miss understand?\\n\\nTest case 40/65: [744437702, 379056602, 145555074, 392756761, 560864007, 934981918, 113312475, 1090, 16384, 33, 217313281, 117883195, 978927664]\\n\\nwhich has longest nice sub arr [1090, 16384, 33, 217313281]\\nlen 4\\nbut expected ans is 3"
                    },
                    {
                        "username": "smolsquirrel936",
                        "content": "[@ggcrispim](/ggcrispim) 33 & 217313281 = 1"
                    },
                    {
                        "username": "ggcrispim",
                        "content": " I am having the same issue ... did you discover why?"
                    },
                    {
                        "username": "AmanVerma_1101",
                        "content": "The length of the longest nice subarray cannot exceed 30. Why is that?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because you have only 30 bits left for and to be false of all"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long sum=0;\\n            long long prexor=0;\\n            for(int j=0;j<32;j++){\\n                if(i+j>=nums.size())\\n                break;\\n                sum=sum+nums[i+j];\\n                prexor=prexor^nums[i+j];\\n                if(sum!=prexor)\\n                break;\\n                ans=max(ans,j+1);\\n            }\\n        }\\n        return ans;\\n\\nwhy inner loop is working is constant time i.e 32 because nice array max size is possible of 32\\nnums[i]<pw(2,31)\\nin worst case if there only power of 2 elements are persent because in 32 element any two numbers can have and not eqaul to zero\\npresum and prexor take care these parameter \\n\\nevery code you seen will have some space this code don\\'t have space complexity so do give me a like which will motivate me to pin more solution like this\\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "you didnt explain the main logic of your solution\nwhy using xor and sum , \nwhy sum comparing to prexor"
                    },
                    {
                        "username": "rjkly98",
                        "content": "l: left index\nr: right index\n[l...r]: nice subarray from l to r\nhint: r is nice with [l...r-1]: [l...r-1]&r == 0 \ncan be optimized as : bitwise or (bitor[l...r-1] & r == 0)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hello, Can anyone please tell me. Why the Expected output is 5?\\n\\n`Input\\nnums =\\n[178830999,19325904,844110858,806734874,280746028,64,256,33554432,882197187,104359873,453049214,820924081,624788281,710612132,839991691]\\nOutput\\n5\\nExpected\\n4`"
                    },
                    {
                        "username": "245120733119",
                        "content": "[@2nishantthakur](/2nishantthakur) No the subarray is  806734874,280746028,64,256,33554432 the ans should be 5, may be the test case evaluation was wrong from leetcode"
                    },
                    {
                        "username": "245120733119",
                        "content": "Stuck in Same test case"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[280746028,64,256,33554432] is the longest beautiful subarray in the above test case I believe hence the expected result is 4"
                    }
                ]
            },
            {
                "id": 1737300,
                "content": [
                    {
                        "username": "suck_77",
                        "content": "Since the range of `nums[i]`, the size of sliding windows is guaranteed not larger than 32. As a result, O(n^2) solutions without sliding window are also accepted. I suggest that add zero to the range of `nums[i]` and add test cases like `[0] * 100000`."
                    },
                    {
                        "username": "MiepjeMadelon",
                        "content": "[904163577,321202512,470948612,490925389,550193477,87742556,151890632,655280661,4,263168,32,573703555,886743681,937599702,120293650,725712231,257119393] \ngives me the result \n[4, 263168, 32, 886743681], which I believe is correct. Does anyone know why the answer still is 3 instead of 4? \nEDIT: Just found out the subarray has to be continuous in the array. I'll leave the comment if anyone else has the same question."
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "[4, 263168, 32, 886743681] bro this is not contiguous in your testcase , look it carefully that\\'swhy he gave u the 3 ans in ur testcase the contiguous subarray is this... \\n      [4, 263168, 32, 573703555 ,886743681]"
                    },
                    {
                        "username": "No-one1",
                        "content": "Someone please help me with this code :\\n\\n```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector& nums) {\\nlong long mask = 0;\\nint res=0;\\nint count = 0;\\nfor(int i=0 ; i<nums.size() ; i++){\\nint x = mask&nums[i];\\nif(x==0){\\nmask = mask|nums[i];\\n\\n            cout<<count<<endl;\\n \\n            count++;\\n            \\n        }\\n        else{\\n            cout<<count<<endl;\\n            res = max(count,res);\\n            mask=nums[i];\\n            count=1;\\n        }\\n    }\\n    res = max(count,res);\\n    return res;\\n}\\n};\\n```\\nI am stuck at the test case : [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\nwhere desired output is 8 but I am getting 7 "
                    },
                    {
                        "username": "moradiya84",
                        "content": "i think i get it what we are doing is if subarray[1...5]is nicearray then adding 6 is not making it nice so we are jumping directly to 6 but it's not necessary what if subarray[3....9] is nice we are not considering so we should keep on decreasing our size untill it became nice once again or i==j."
                    },
                    {
                        "username": "moradiya84",
                        "content": "did you get it? \\nI am also stuck at same test case\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int ans=1;\\n        int x=1;\\n        long long p=v[0];\\n        for(int i=1;i<v.size();i++){\\n            long long z=v[i];\\n            if((p&z)==0){\\n                x++;\\n                ans=max(ans,x);\\n                p=p|z;\\n            }\\n            else{\\n                x=1;\\n                p=(long long)v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere\\'s mt code"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n for this test cases I believe the longest nice subarray is [65552,50331652,1,1048576,16384,544,270532608] and its length is 7 but the answer is 8.\\ncan someone please verify this?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur)[@Darshan Jain](/No-one1) so , instead what we can do is instead of shiffting both left and right pointers to the current index, we can shift left pointer to the index where the fault begin ( i.e. to the last element where OR != 0 \\n \\ni am pasting code here you can refer :\\n\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int mask = 0; \\n\\n        int l = 0 , r= 0; \\n        int max = 0; \\n\\n        while( r < arr.length ){\\n\\n            if( (mask&arr[r]) == 0 ){\\n                mask = mask | arr[r]; \\n                max = Math.max(max,r-l+1); \\n                r++; \\n            }else{\\n                mask = mask^arr[l]; \\n                l++; \\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur) yes bro i think i found where the  mistake is \\nso , the problem is [ a , b , c , d, e, f, g, h , i] suppose this is the given array and we have to find longest Nice subarray and suppose answer is 5 and we are getting 4 according to our code  , and the answer subarrray is [ c , d,e,g,h] , but according to our code if it found that current subbarray is not nice , we directly jump both left and right pointers to the current element. For example [ a , b , c , d] was a nice subarray but  b | e != 0 then according to our code it will directy jump to e . instead our left pointer should point towards c , i.e, to the next element that was creating fault. \\n\\nHope u understand ;>)"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[@No-one1](/No-one1)  still no answer :\\'("
                    },
                    {
                        "username": "No-one1",
                        "content": "Have you got the answer?\\nI am also stuck here can you please explain"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thank you people in the comments for the test cases!"
                    },
                    {
                        "username": "neo_mxn0",
                        "content": "Wrong test case or I\\'m I miss understand?\\n\\nTest case 40/65: [744437702, 379056602, 145555074, 392756761, 560864007, 934981918, 113312475, 1090, 16384, 33, 217313281, 117883195, 978927664]\\n\\nwhich has longest nice sub arr [1090, 16384, 33, 217313281]\\nlen 4\\nbut expected ans is 3"
                    },
                    {
                        "username": "smolsquirrel936",
                        "content": "[@ggcrispim](/ggcrispim) 33 & 217313281 = 1"
                    },
                    {
                        "username": "ggcrispim",
                        "content": " I am having the same issue ... did you discover why?"
                    },
                    {
                        "username": "AmanVerma_1101",
                        "content": "The length of the longest nice subarray cannot exceed 30. Why is that?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because you have only 30 bits left for and to be false of all"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long sum=0;\\n            long long prexor=0;\\n            for(int j=0;j<32;j++){\\n                if(i+j>=nums.size())\\n                break;\\n                sum=sum+nums[i+j];\\n                prexor=prexor^nums[i+j];\\n                if(sum!=prexor)\\n                break;\\n                ans=max(ans,j+1);\\n            }\\n        }\\n        return ans;\\n\\nwhy inner loop is working is constant time i.e 32 because nice array max size is possible of 32\\nnums[i]<pw(2,31)\\nin worst case if there only power of 2 elements are persent because in 32 element any two numbers can have and not eqaul to zero\\npresum and prexor take care these parameter \\n\\nevery code you seen will have some space this code don\\'t have space complexity so do give me a like which will motivate me to pin more solution like this\\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "you didnt explain the main logic of your solution\nwhy using xor and sum , \nwhy sum comparing to prexor"
                    },
                    {
                        "username": "rjkly98",
                        "content": "l: left index\nr: right index\n[l...r]: nice subarray from l to r\nhint: r is nice with [l...r-1]: [l...r-1]&r == 0 \ncan be optimized as : bitwise or (bitor[l...r-1] & r == 0)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hello, Can anyone please tell me. Why the Expected output is 5?\\n\\n`Input\\nnums =\\n[178830999,19325904,844110858,806734874,280746028,64,256,33554432,882197187,104359873,453049214,820924081,624788281,710612132,839991691]\\nOutput\\n5\\nExpected\\n4`"
                    },
                    {
                        "username": "245120733119",
                        "content": "[@2nishantthakur](/2nishantthakur) No the subarray is  806734874,280746028,64,256,33554432 the ans should be 5, may be the test case evaluation was wrong from leetcode"
                    },
                    {
                        "username": "245120733119",
                        "content": "Stuck in Same test case"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[280746028,64,256,33554432] is the longest beautiful subarray in the above test case I believe hence the expected result is 4"
                    }
                ]
            },
            {
                "id": 1902229,
                "content": [
                    {
                        "username": "suck_77",
                        "content": "Since the range of `nums[i]`, the size of sliding windows is guaranteed not larger than 32. As a result, O(n^2) solutions without sliding window are also accepted. I suggest that add zero to the range of `nums[i]` and add test cases like `[0] * 100000`."
                    },
                    {
                        "username": "MiepjeMadelon",
                        "content": "[904163577,321202512,470948612,490925389,550193477,87742556,151890632,655280661,4,263168,32,573703555,886743681,937599702,120293650,725712231,257119393] \ngives me the result \n[4, 263168, 32, 886743681], which I believe is correct. Does anyone know why the answer still is 3 instead of 4? \nEDIT: Just found out the subarray has to be continuous in the array. I'll leave the comment if anyone else has the same question."
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "[4, 263168, 32, 886743681] bro this is not contiguous in your testcase , look it carefully that\\'swhy he gave u the 3 ans in ur testcase the contiguous subarray is this... \\n      [4, 263168, 32, 573703555 ,886743681]"
                    },
                    {
                        "username": "No-one1",
                        "content": "Someone please help me with this code :\\n\\n```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector& nums) {\\nlong long mask = 0;\\nint res=0;\\nint count = 0;\\nfor(int i=0 ; i<nums.size() ; i++){\\nint x = mask&nums[i];\\nif(x==0){\\nmask = mask|nums[i];\\n\\n            cout<<count<<endl;\\n \\n            count++;\\n            \\n        }\\n        else{\\n            cout<<count<<endl;\\n            res = max(count,res);\\n            mask=nums[i];\\n            count=1;\\n        }\\n    }\\n    res = max(count,res);\\n    return res;\\n}\\n};\\n```\\nI am stuck at the test case : [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\nwhere desired output is 8 but I am getting 7 "
                    },
                    {
                        "username": "moradiya84",
                        "content": "i think i get it what we are doing is if subarray[1...5]is nicearray then adding 6 is not making it nice so we are jumping directly to 6 but it's not necessary what if subarray[3....9] is nice we are not considering so we should keep on decreasing our size untill it became nice once again or i==j."
                    },
                    {
                        "username": "moradiya84",
                        "content": "did you get it? \\nI am also stuck at same test case\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int ans=1;\\n        int x=1;\\n        long long p=v[0];\\n        for(int i=1;i<v.size();i++){\\n            long long z=v[i];\\n            if((p&z)==0){\\n                x++;\\n                ans=max(ans,x);\\n                p=p|z;\\n            }\\n            else{\\n                x=1;\\n                p=(long long)v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere\\'s mt code"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n for this test cases I believe the longest nice subarray is [65552,50331652,1,1048576,16384,544,270532608] and its length is 7 but the answer is 8.\\ncan someone please verify this?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur)[@Darshan Jain](/No-one1) so , instead what we can do is instead of shiffting both left and right pointers to the current index, we can shift left pointer to the index where the fault begin ( i.e. to the last element where OR != 0 \\n \\ni am pasting code here you can refer :\\n\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int mask = 0; \\n\\n        int l = 0 , r= 0; \\n        int max = 0; \\n\\n        while( r < arr.length ){\\n\\n            if( (mask&arr[r]) == 0 ){\\n                mask = mask | arr[r]; \\n                max = Math.max(max,r-l+1); \\n                r++; \\n            }else{\\n                mask = mask^arr[l]; \\n                l++; \\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur) yes bro i think i found where the  mistake is \\nso , the problem is [ a , b , c , d, e, f, g, h , i] suppose this is the given array and we have to find longest Nice subarray and suppose answer is 5 and we are getting 4 according to our code  , and the answer subarrray is [ c , d,e,g,h] , but according to our code if it found that current subbarray is not nice , we directly jump both left and right pointers to the current element. For example [ a , b , c , d] was a nice subarray but  b | e != 0 then according to our code it will directy jump to e . instead our left pointer should point towards c , i.e, to the next element that was creating fault. \\n\\nHope u understand ;>)"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[@No-one1](/No-one1)  still no answer :\\'("
                    },
                    {
                        "username": "No-one1",
                        "content": "Have you got the answer?\\nI am also stuck here can you please explain"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thank you people in the comments for the test cases!"
                    },
                    {
                        "username": "neo_mxn0",
                        "content": "Wrong test case or I\\'m I miss understand?\\n\\nTest case 40/65: [744437702, 379056602, 145555074, 392756761, 560864007, 934981918, 113312475, 1090, 16384, 33, 217313281, 117883195, 978927664]\\n\\nwhich has longest nice sub arr [1090, 16384, 33, 217313281]\\nlen 4\\nbut expected ans is 3"
                    },
                    {
                        "username": "smolsquirrel936",
                        "content": "[@ggcrispim](/ggcrispim) 33 & 217313281 = 1"
                    },
                    {
                        "username": "ggcrispim",
                        "content": " I am having the same issue ... did you discover why?"
                    },
                    {
                        "username": "AmanVerma_1101",
                        "content": "The length of the longest nice subarray cannot exceed 30. Why is that?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because you have only 30 bits left for and to be false of all"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long sum=0;\\n            long long prexor=0;\\n            for(int j=0;j<32;j++){\\n                if(i+j>=nums.size())\\n                break;\\n                sum=sum+nums[i+j];\\n                prexor=prexor^nums[i+j];\\n                if(sum!=prexor)\\n                break;\\n                ans=max(ans,j+1);\\n            }\\n        }\\n        return ans;\\n\\nwhy inner loop is working is constant time i.e 32 because nice array max size is possible of 32\\nnums[i]<pw(2,31)\\nin worst case if there only power of 2 elements are persent because in 32 element any two numbers can have and not eqaul to zero\\npresum and prexor take care these parameter \\n\\nevery code you seen will have some space this code don\\'t have space complexity so do give me a like which will motivate me to pin more solution like this\\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "you didnt explain the main logic of your solution\nwhy using xor and sum , \nwhy sum comparing to prexor"
                    },
                    {
                        "username": "rjkly98",
                        "content": "l: left index\nr: right index\n[l...r]: nice subarray from l to r\nhint: r is nice with [l...r-1]: [l...r-1]&r == 0 \ncan be optimized as : bitwise or (bitor[l...r-1] & r == 0)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hello, Can anyone please tell me. Why the Expected output is 5?\\n\\n`Input\\nnums =\\n[178830999,19325904,844110858,806734874,280746028,64,256,33554432,882197187,104359873,453049214,820924081,624788281,710612132,839991691]\\nOutput\\n5\\nExpected\\n4`"
                    },
                    {
                        "username": "245120733119",
                        "content": "[@2nishantthakur](/2nishantthakur) No the subarray is  806734874,280746028,64,256,33554432 the ans should be 5, may be the test case evaluation was wrong from leetcode"
                    },
                    {
                        "username": "245120733119",
                        "content": "Stuck in Same test case"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[280746028,64,256,33554432] is the longest beautiful subarray in the above test case I believe hence the expected result is 4"
                    }
                ]
            },
            {
                "id": 1897896,
                "content": [
                    {
                        "username": "suck_77",
                        "content": "Since the range of `nums[i]`, the size of sliding windows is guaranteed not larger than 32. As a result, O(n^2) solutions without sliding window are also accepted. I suggest that add zero to the range of `nums[i]` and add test cases like `[0] * 100000`."
                    },
                    {
                        "username": "MiepjeMadelon",
                        "content": "[904163577,321202512,470948612,490925389,550193477,87742556,151890632,655280661,4,263168,32,573703555,886743681,937599702,120293650,725712231,257119393] \ngives me the result \n[4, 263168, 32, 886743681], which I believe is correct. Does anyone know why the answer still is 3 instead of 4? \nEDIT: Just found out the subarray has to be continuous in the array. I'll leave the comment if anyone else has the same question."
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "[4, 263168, 32, 886743681] bro this is not contiguous in your testcase , look it carefully that\\'swhy he gave u the 3 ans in ur testcase the contiguous subarray is this... \\n      [4, 263168, 32, 573703555 ,886743681]"
                    },
                    {
                        "username": "No-one1",
                        "content": "Someone please help me with this code :\\n\\n```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector& nums) {\\nlong long mask = 0;\\nint res=0;\\nint count = 0;\\nfor(int i=0 ; i<nums.size() ; i++){\\nint x = mask&nums[i];\\nif(x==0){\\nmask = mask|nums[i];\\n\\n            cout<<count<<endl;\\n \\n            count++;\\n            \\n        }\\n        else{\\n            cout<<count<<endl;\\n            res = max(count,res);\\n            mask=nums[i];\\n            count=1;\\n        }\\n    }\\n    res = max(count,res);\\n    return res;\\n}\\n};\\n```\\nI am stuck at the test case : [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\nwhere desired output is 8 but I am getting 7 "
                    },
                    {
                        "username": "moradiya84",
                        "content": "i think i get it what we are doing is if subarray[1...5]is nicearray then adding 6 is not making it nice so we are jumping directly to 6 but it's not necessary what if subarray[3....9] is nice we are not considering so we should keep on decreasing our size untill it became nice once again or i==j."
                    },
                    {
                        "username": "moradiya84",
                        "content": "did you get it? \\nI am also stuck at same test case\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int ans=1;\\n        int x=1;\\n        long long p=v[0];\\n        for(int i=1;i<v.size();i++){\\n            long long z=v[i];\\n            if((p&z)==0){\\n                x++;\\n                ans=max(ans,x);\\n                p=p|z;\\n            }\\n            else{\\n                x=1;\\n                p=(long long)v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere\\'s mt code"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n for this test cases I believe the longest nice subarray is [65552,50331652,1,1048576,16384,544,270532608] and its length is 7 but the answer is 8.\\ncan someone please verify this?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur)[@Darshan Jain](/No-one1) so , instead what we can do is instead of shiffting both left and right pointers to the current index, we can shift left pointer to the index where the fault begin ( i.e. to the last element where OR != 0 \\n \\ni am pasting code here you can refer :\\n\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int mask = 0; \\n\\n        int l = 0 , r= 0; \\n        int max = 0; \\n\\n        while( r < arr.length ){\\n\\n            if( (mask&arr[r]) == 0 ){\\n                mask = mask | arr[r]; \\n                max = Math.max(max,r-l+1); \\n                r++; \\n            }else{\\n                mask = mask^arr[l]; \\n                l++; \\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur) yes bro i think i found where the  mistake is \\nso , the problem is [ a , b , c , d, e, f, g, h , i] suppose this is the given array and we have to find longest Nice subarray and suppose answer is 5 and we are getting 4 according to our code  , and the answer subarrray is [ c , d,e,g,h] , but according to our code if it found that current subbarray is not nice , we directly jump both left and right pointers to the current element. For example [ a , b , c , d] was a nice subarray but  b | e != 0 then according to our code it will directy jump to e . instead our left pointer should point towards c , i.e, to the next element that was creating fault. \\n\\nHope u understand ;>)"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[@No-one1](/No-one1)  still no answer :\\'("
                    },
                    {
                        "username": "No-one1",
                        "content": "Have you got the answer?\\nI am also stuck here can you please explain"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thank you people in the comments for the test cases!"
                    },
                    {
                        "username": "neo_mxn0",
                        "content": "Wrong test case or I\\'m I miss understand?\\n\\nTest case 40/65: [744437702, 379056602, 145555074, 392756761, 560864007, 934981918, 113312475, 1090, 16384, 33, 217313281, 117883195, 978927664]\\n\\nwhich has longest nice sub arr [1090, 16384, 33, 217313281]\\nlen 4\\nbut expected ans is 3"
                    },
                    {
                        "username": "smolsquirrel936",
                        "content": "[@ggcrispim](/ggcrispim) 33 & 217313281 = 1"
                    },
                    {
                        "username": "ggcrispim",
                        "content": " I am having the same issue ... did you discover why?"
                    },
                    {
                        "username": "AmanVerma_1101",
                        "content": "The length of the longest nice subarray cannot exceed 30. Why is that?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because you have only 30 bits left for and to be false of all"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long sum=0;\\n            long long prexor=0;\\n            for(int j=0;j<32;j++){\\n                if(i+j>=nums.size())\\n                break;\\n                sum=sum+nums[i+j];\\n                prexor=prexor^nums[i+j];\\n                if(sum!=prexor)\\n                break;\\n                ans=max(ans,j+1);\\n            }\\n        }\\n        return ans;\\n\\nwhy inner loop is working is constant time i.e 32 because nice array max size is possible of 32\\nnums[i]<pw(2,31)\\nin worst case if there only power of 2 elements are persent because in 32 element any two numbers can have and not eqaul to zero\\npresum and prexor take care these parameter \\n\\nevery code you seen will have some space this code don\\'t have space complexity so do give me a like which will motivate me to pin more solution like this\\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "you didnt explain the main logic of your solution\nwhy using xor and sum , \nwhy sum comparing to prexor"
                    },
                    {
                        "username": "rjkly98",
                        "content": "l: left index\nr: right index\n[l...r]: nice subarray from l to r\nhint: r is nice with [l...r-1]: [l...r-1]&r == 0 \ncan be optimized as : bitwise or (bitor[l...r-1] & r == 0)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hello, Can anyone please tell me. Why the Expected output is 5?\\n\\n`Input\\nnums =\\n[178830999,19325904,844110858,806734874,280746028,64,256,33554432,882197187,104359873,453049214,820924081,624788281,710612132,839991691]\\nOutput\\n5\\nExpected\\n4`"
                    },
                    {
                        "username": "245120733119",
                        "content": "[@2nishantthakur](/2nishantthakur) No the subarray is  806734874,280746028,64,256,33554432 the ans should be 5, may be the test case evaluation was wrong from leetcode"
                    },
                    {
                        "username": "245120733119",
                        "content": "Stuck in Same test case"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[280746028,64,256,33554432] is the longest beautiful subarray in the above test case I believe hence the expected result is 4"
                    }
                ]
            },
            {
                "id": 1883174,
                "content": [
                    {
                        "username": "suck_77",
                        "content": "Since the range of `nums[i]`, the size of sliding windows is guaranteed not larger than 32. As a result, O(n^2) solutions without sliding window are also accepted. I suggest that add zero to the range of `nums[i]` and add test cases like `[0] * 100000`."
                    },
                    {
                        "username": "MiepjeMadelon",
                        "content": "[904163577,321202512,470948612,490925389,550193477,87742556,151890632,655280661,4,263168,32,573703555,886743681,937599702,120293650,725712231,257119393] \ngives me the result \n[4, 263168, 32, 886743681], which I believe is correct. Does anyone know why the answer still is 3 instead of 4? \nEDIT: Just found out the subarray has to be continuous in the array. I'll leave the comment if anyone else has the same question."
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "[4, 263168, 32, 886743681] bro this is not contiguous in your testcase , look it carefully that\\'swhy he gave u the 3 ans in ur testcase the contiguous subarray is this... \\n      [4, 263168, 32, 573703555 ,886743681]"
                    },
                    {
                        "username": "No-one1",
                        "content": "Someone please help me with this code :\\n\\n```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector& nums) {\\nlong long mask = 0;\\nint res=0;\\nint count = 0;\\nfor(int i=0 ; i<nums.size() ; i++){\\nint x = mask&nums[i];\\nif(x==0){\\nmask = mask|nums[i];\\n\\n            cout<<count<<endl;\\n \\n            count++;\\n            \\n        }\\n        else{\\n            cout<<count<<endl;\\n            res = max(count,res);\\n            mask=nums[i];\\n            count=1;\\n        }\\n    }\\n    res = max(count,res);\\n    return res;\\n}\\n};\\n```\\nI am stuck at the test case : [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\nwhere desired output is 8 but I am getting 7 "
                    },
                    {
                        "username": "moradiya84",
                        "content": "i think i get it what we are doing is if subarray[1...5]is nicearray then adding 6 is not making it nice so we are jumping directly to 6 but it's not necessary what if subarray[3....9] is nice we are not considering so we should keep on decreasing our size untill it became nice once again or i==j."
                    },
                    {
                        "username": "moradiya84",
                        "content": "did you get it? \\nI am also stuck at same test case\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int ans=1;\\n        int x=1;\\n        long long p=v[0];\\n        for(int i=1;i<v.size();i++){\\n            long long z=v[i];\\n            if((p&z)==0){\\n                x++;\\n                ans=max(ans,x);\\n                p=p|z;\\n            }\\n            else{\\n                x=1;\\n                p=(long long)v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere\\'s mt code"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n for this test cases I believe the longest nice subarray is [65552,50331652,1,1048576,16384,544,270532608] and its length is 7 but the answer is 8.\\ncan someone please verify this?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur)[@Darshan Jain](/No-one1) so , instead what we can do is instead of shiffting both left and right pointers to the current index, we can shift left pointer to the index where the fault begin ( i.e. to the last element where OR != 0 \\n \\ni am pasting code here you can refer :\\n\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int mask = 0; \\n\\n        int l = 0 , r= 0; \\n        int max = 0; \\n\\n        while( r < arr.length ){\\n\\n            if( (mask&arr[r]) == 0 ){\\n                mask = mask | arr[r]; \\n                max = Math.max(max,r-l+1); \\n                r++; \\n            }else{\\n                mask = mask^arr[l]; \\n                l++; \\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur) yes bro i think i found where the  mistake is \\nso , the problem is [ a , b , c , d, e, f, g, h , i] suppose this is the given array and we have to find longest Nice subarray and suppose answer is 5 and we are getting 4 according to our code  , and the answer subarrray is [ c , d,e,g,h] , but according to our code if it found that current subbarray is not nice , we directly jump both left and right pointers to the current element. For example [ a , b , c , d] was a nice subarray but  b | e != 0 then according to our code it will directy jump to e . instead our left pointer should point towards c , i.e, to the next element that was creating fault. \\n\\nHope u understand ;>)"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[@No-one1](/No-one1)  still no answer :\\'("
                    },
                    {
                        "username": "No-one1",
                        "content": "Have you got the answer?\\nI am also stuck here can you please explain"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thank you people in the comments for the test cases!"
                    },
                    {
                        "username": "neo_mxn0",
                        "content": "Wrong test case or I\\'m I miss understand?\\n\\nTest case 40/65: [744437702, 379056602, 145555074, 392756761, 560864007, 934981918, 113312475, 1090, 16384, 33, 217313281, 117883195, 978927664]\\n\\nwhich has longest nice sub arr [1090, 16384, 33, 217313281]\\nlen 4\\nbut expected ans is 3"
                    },
                    {
                        "username": "smolsquirrel936",
                        "content": "[@ggcrispim](/ggcrispim) 33 & 217313281 = 1"
                    },
                    {
                        "username": "ggcrispim",
                        "content": " I am having the same issue ... did you discover why?"
                    },
                    {
                        "username": "AmanVerma_1101",
                        "content": "The length of the longest nice subarray cannot exceed 30. Why is that?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because you have only 30 bits left for and to be false of all"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long sum=0;\\n            long long prexor=0;\\n            for(int j=0;j<32;j++){\\n                if(i+j>=nums.size())\\n                break;\\n                sum=sum+nums[i+j];\\n                prexor=prexor^nums[i+j];\\n                if(sum!=prexor)\\n                break;\\n                ans=max(ans,j+1);\\n            }\\n        }\\n        return ans;\\n\\nwhy inner loop is working is constant time i.e 32 because nice array max size is possible of 32\\nnums[i]<pw(2,31)\\nin worst case if there only power of 2 elements are persent because in 32 element any two numbers can have and not eqaul to zero\\npresum and prexor take care these parameter \\n\\nevery code you seen will have some space this code don\\'t have space complexity so do give me a like which will motivate me to pin more solution like this\\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "you didnt explain the main logic of your solution\nwhy using xor and sum , \nwhy sum comparing to prexor"
                    },
                    {
                        "username": "rjkly98",
                        "content": "l: left index\nr: right index\n[l...r]: nice subarray from l to r\nhint: r is nice with [l...r-1]: [l...r-1]&r == 0 \ncan be optimized as : bitwise or (bitor[l...r-1] & r == 0)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hello, Can anyone please tell me. Why the Expected output is 5?\\n\\n`Input\\nnums =\\n[178830999,19325904,844110858,806734874,280746028,64,256,33554432,882197187,104359873,453049214,820924081,624788281,710612132,839991691]\\nOutput\\n5\\nExpected\\n4`"
                    },
                    {
                        "username": "245120733119",
                        "content": "[@2nishantthakur](/2nishantthakur) No the subarray is  806734874,280746028,64,256,33554432 the ans should be 5, may be the test case evaluation was wrong from leetcode"
                    },
                    {
                        "username": "245120733119",
                        "content": "Stuck in Same test case"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[280746028,64,256,33554432] is the longest beautiful subarray in the above test case I believe hence the expected result is 4"
                    }
                ]
            },
            {
                "id": 1824111,
                "content": [
                    {
                        "username": "suck_77",
                        "content": "Since the range of `nums[i]`, the size of sliding windows is guaranteed not larger than 32. As a result, O(n^2) solutions without sliding window are also accepted. I suggest that add zero to the range of `nums[i]` and add test cases like `[0] * 100000`."
                    },
                    {
                        "username": "MiepjeMadelon",
                        "content": "[904163577,321202512,470948612,490925389,550193477,87742556,151890632,655280661,4,263168,32,573703555,886743681,937599702,120293650,725712231,257119393] \ngives me the result \n[4, 263168, 32, 886743681], which I believe is correct. Does anyone know why the answer still is 3 instead of 4? \nEDIT: Just found out the subarray has to be continuous in the array. I'll leave the comment if anyone else has the same question."
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "[4, 263168, 32, 886743681] bro this is not contiguous in your testcase , look it carefully that\\'swhy he gave u the 3 ans in ur testcase the contiguous subarray is this... \\n      [4, 263168, 32, 573703555 ,886743681]"
                    },
                    {
                        "username": "No-one1",
                        "content": "Someone please help me with this code :\\n\\n```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector& nums) {\\nlong long mask = 0;\\nint res=0;\\nint count = 0;\\nfor(int i=0 ; i<nums.size() ; i++){\\nint x = mask&nums[i];\\nif(x==0){\\nmask = mask|nums[i];\\n\\n            cout<<count<<endl;\\n \\n            count++;\\n            \\n        }\\n        else{\\n            cout<<count<<endl;\\n            res = max(count,res);\\n            mask=nums[i];\\n            count=1;\\n        }\\n    }\\n    res = max(count,res);\\n    return res;\\n}\\n};\\n```\\nI am stuck at the test case : [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\nwhere desired output is 8 but I am getting 7 "
                    },
                    {
                        "username": "moradiya84",
                        "content": "i think i get it what we are doing is if subarray[1...5]is nicearray then adding 6 is not making it nice so we are jumping directly to 6 but it's not necessary what if subarray[3....9] is nice we are not considering so we should keep on decreasing our size untill it became nice once again or i==j."
                    },
                    {
                        "username": "moradiya84",
                        "content": "did you get it? \\nI am also stuck at same test case\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int ans=1;\\n        int x=1;\\n        long long p=v[0];\\n        for(int i=1;i<v.size();i++){\\n            long long z=v[i];\\n            if((p&z)==0){\\n                x++;\\n                ans=max(ans,x);\\n                p=p|z;\\n            }\\n            else{\\n                x=1;\\n                p=(long long)v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere\\'s mt code"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n for this test cases I believe the longest nice subarray is [65552,50331652,1,1048576,16384,544,270532608] and its length is 7 but the answer is 8.\\ncan someone please verify this?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur)[@Darshan Jain](/No-one1) so , instead what we can do is instead of shiffting both left and right pointers to the current index, we can shift left pointer to the index where the fault begin ( i.e. to the last element where OR != 0 \\n \\ni am pasting code here you can refer :\\n\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int mask = 0; \\n\\n        int l = 0 , r= 0; \\n        int max = 0; \\n\\n        while( r < arr.length ){\\n\\n            if( (mask&arr[r]) == 0 ){\\n                mask = mask | arr[r]; \\n                max = Math.max(max,r-l+1); \\n                r++; \\n            }else{\\n                mask = mask^arr[l]; \\n                l++; \\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur) yes bro i think i found where the  mistake is \\nso , the problem is [ a , b , c , d, e, f, g, h , i] suppose this is the given array and we have to find longest Nice subarray and suppose answer is 5 and we are getting 4 according to our code  , and the answer subarrray is [ c , d,e,g,h] , but according to our code if it found that current subbarray is not nice , we directly jump both left and right pointers to the current element. For example [ a , b , c , d] was a nice subarray but  b | e != 0 then according to our code it will directy jump to e . instead our left pointer should point towards c , i.e, to the next element that was creating fault. \\n\\nHope u understand ;>)"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[@No-one1](/No-one1)  still no answer :\\'("
                    },
                    {
                        "username": "No-one1",
                        "content": "Have you got the answer?\\nI am also stuck here can you please explain"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thank you people in the comments for the test cases!"
                    },
                    {
                        "username": "neo_mxn0",
                        "content": "Wrong test case or I\\'m I miss understand?\\n\\nTest case 40/65: [744437702, 379056602, 145555074, 392756761, 560864007, 934981918, 113312475, 1090, 16384, 33, 217313281, 117883195, 978927664]\\n\\nwhich has longest nice sub arr [1090, 16384, 33, 217313281]\\nlen 4\\nbut expected ans is 3"
                    },
                    {
                        "username": "smolsquirrel936",
                        "content": "[@ggcrispim](/ggcrispim) 33 & 217313281 = 1"
                    },
                    {
                        "username": "ggcrispim",
                        "content": " I am having the same issue ... did you discover why?"
                    },
                    {
                        "username": "AmanVerma_1101",
                        "content": "The length of the longest nice subarray cannot exceed 30. Why is that?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because you have only 30 bits left for and to be false of all"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long sum=0;\\n            long long prexor=0;\\n            for(int j=0;j<32;j++){\\n                if(i+j>=nums.size())\\n                break;\\n                sum=sum+nums[i+j];\\n                prexor=prexor^nums[i+j];\\n                if(sum!=prexor)\\n                break;\\n                ans=max(ans,j+1);\\n            }\\n        }\\n        return ans;\\n\\nwhy inner loop is working is constant time i.e 32 because nice array max size is possible of 32\\nnums[i]<pw(2,31)\\nin worst case if there only power of 2 elements are persent because in 32 element any two numbers can have and not eqaul to zero\\npresum and prexor take care these parameter \\n\\nevery code you seen will have some space this code don\\'t have space complexity so do give me a like which will motivate me to pin more solution like this\\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "you didnt explain the main logic of your solution\nwhy using xor and sum , \nwhy sum comparing to prexor"
                    },
                    {
                        "username": "rjkly98",
                        "content": "l: left index\nr: right index\n[l...r]: nice subarray from l to r\nhint: r is nice with [l...r-1]: [l...r-1]&r == 0 \ncan be optimized as : bitwise or (bitor[l...r-1] & r == 0)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hello, Can anyone please tell me. Why the Expected output is 5?\\n\\n`Input\\nnums =\\n[178830999,19325904,844110858,806734874,280746028,64,256,33554432,882197187,104359873,453049214,820924081,624788281,710612132,839991691]\\nOutput\\n5\\nExpected\\n4`"
                    },
                    {
                        "username": "245120733119",
                        "content": "[@2nishantthakur](/2nishantthakur) No the subarray is  806734874,280746028,64,256,33554432 the ans should be 5, may be the test case evaluation was wrong from leetcode"
                    },
                    {
                        "username": "245120733119",
                        "content": "Stuck in Same test case"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[280746028,64,256,33554432] is the longest beautiful subarray in the above test case I believe hence the expected result is 4"
                    }
                ]
            },
            {
                "id": 1793215,
                "content": [
                    {
                        "username": "suck_77",
                        "content": "Since the range of `nums[i]`, the size of sliding windows is guaranteed not larger than 32. As a result, O(n^2) solutions without sliding window are also accepted. I suggest that add zero to the range of `nums[i]` and add test cases like `[0] * 100000`."
                    },
                    {
                        "username": "MiepjeMadelon",
                        "content": "[904163577,321202512,470948612,490925389,550193477,87742556,151890632,655280661,4,263168,32,573703555,886743681,937599702,120293650,725712231,257119393] \ngives me the result \n[4, 263168, 32, 886743681], which I believe is correct. Does anyone know why the answer still is 3 instead of 4? \nEDIT: Just found out the subarray has to be continuous in the array. I'll leave the comment if anyone else has the same question."
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "[4, 263168, 32, 886743681] bro this is not contiguous in your testcase , look it carefully that\\'swhy he gave u the 3 ans in ur testcase the contiguous subarray is this... \\n      [4, 263168, 32, 573703555 ,886743681]"
                    },
                    {
                        "username": "No-one1",
                        "content": "Someone please help me with this code :\\n\\n```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector& nums) {\\nlong long mask = 0;\\nint res=0;\\nint count = 0;\\nfor(int i=0 ; i<nums.size() ; i++){\\nint x = mask&nums[i];\\nif(x==0){\\nmask = mask|nums[i];\\n\\n            cout<<count<<endl;\\n \\n            count++;\\n            \\n        }\\n        else{\\n            cout<<count<<endl;\\n            res = max(count,res);\\n            mask=nums[i];\\n            count=1;\\n        }\\n    }\\n    res = max(count,res);\\n    return res;\\n}\\n};\\n```\\nI am stuck at the test case : [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\nwhere desired output is 8 but I am getting 7 "
                    },
                    {
                        "username": "moradiya84",
                        "content": "i think i get it what we are doing is if subarray[1...5]is nicearray then adding 6 is not making it nice so we are jumping directly to 6 but it's not necessary what if subarray[3....9] is nice we are not considering so we should keep on decreasing our size untill it became nice once again or i==j."
                    },
                    {
                        "username": "moradiya84",
                        "content": "did you get it? \\nI am also stuck at same test case\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int ans=1;\\n        int x=1;\\n        long long p=v[0];\\n        for(int i=1;i<v.size();i++){\\n            long long z=v[i];\\n            if((p&z)==0){\\n                x++;\\n                ans=max(ans,x);\\n                p=p|z;\\n            }\\n            else{\\n                x=1;\\n                p=(long long)v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere\\'s mt code"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n for this test cases I believe the longest nice subarray is [65552,50331652,1,1048576,16384,544,270532608] and its length is 7 but the answer is 8.\\ncan someone please verify this?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur)[@Darshan Jain](/No-one1) so , instead what we can do is instead of shiffting both left and right pointers to the current index, we can shift left pointer to the index where the fault begin ( i.e. to the last element where OR != 0 \\n \\ni am pasting code here you can refer :\\n\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int mask = 0; \\n\\n        int l = 0 , r= 0; \\n        int max = 0; \\n\\n        while( r < arr.length ){\\n\\n            if( (mask&arr[r]) == 0 ){\\n                mask = mask | arr[r]; \\n                max = Math.max(max,r-l+1); \\n                r++; \\n            }else{\\n                mask = mask^arr[l]; \\n                l++; \\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur) yes bro i think i found where the  mistake is \\nso , the problem is [ a , b , c , d, e, f, g, h , i] suppose this is the given array and we have to find longest Nice subarray and suppose answer is 5 and we are getting 4 according to our code  , and the answer subarrray is [ c , d,e,g,h] , but according to our code if it found that current subbarray is not nice , we directly jump both left and right pointers to the current element. For example [ a , b , c , d] was a nice subarray but  b | e != 0 then according to our code it will directy jump to e . instead our left pointer should point towards c , i.e, to the next element that was creating fault. \\n\\nHope u understand ;>)"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[@No-one1](/No-one1)  still no answer :\\'("
                    },
                    {
                        "username": "No-one1",
                        "content": "Have you got the answer?\\nI am also stuck here can you please explain"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thank you people in the comments for the test cases!"
                    },
                    {
                        "username": "neo_mxn0",
                        "content": "Wrong test case or I\\'m I miss understand?\\n\\nTest case 40/65: [744437702, 379056602, 145555074, 392756761, 560864007, 934981918, 113312475, 1090, 16384, 33, 217313281, 117883195, 978927664]\\n\\nwhich has longest nice sub arr [1090, 16384, 33, 217313281]\\nlen 4\\nbut expected ans is 3"
                    },
                    {
                        "username": "smolsquirrel936",
                        "content": "[@ggcrispim](/ggcrispim) 33 & 217313281 = 1"
                    },
                    {
                        "username": "ggcrispim",
                        "content": " I am having the same issue ... did you discover why?"
                    },
                    {
                        "username": "AmanVerma_1101",
                        "content": "The length of the longest nice subarray cannot exceed 30. Why is that?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because you have only 30 bits left for and to be false of all"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long sum=0;\\n            long long prexor=0;\\n            for(int j=0;j<32;j++){\\n                if(i+j>=nums.size())\\n                break;\\n                sum=sum+nums[i+j];\\n                prexor=prexor^nums[i+j];\\n                if(sum!=prexor)\\n                break;\\n                ans=max(ans,j+1);\\n            }\\n        }\\n        return ans;\\n\\nwhy inner loop is working is constant time i.e 32 because nice array max size is possible of 32\\nnums[i]<pw(2,31)\\nin worst case if there only power of 2 elements are persent because in 32 element any two numbers can have and not eqaul to zero\\npresum and prexor take care these parameter \\n\\nevery code you seen will have some space this code don\\'t have space complexity so do give me a like which will motivate me to pin more solution like this\\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "you didnt explain the main logic of your solution\nwhy using xor and sum , \nwhy sum comparing to prexor"
                    },
                    {
                        "username": "rjkly98",
                        "content": "l: left index\nr: right index\n[l...r]: nice subarray from l to r\nhint: r is nice with [l...r-1]: [l...r-1]&r == 0 \ncan be optimized as : bitwise or (bitor[l...r-1] & r == 0)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hello, Can anyone please tell me. Why the Expected output is 5?\\n\\n`Input\\nnums =\\n[178830999,19325904,844110858,806734874,280746028,64,256,33554432,882197187,104359873,453049214,820924081,624788281,710612132,839991691]\\nOutput\\n5\\nExpected\\n4`"
                    },
                    {
                        "username": "245120733119",
                        "content": "[@2nishantthakur](/2nishantthakur) No the subarray is  806734874,280746028,64,256,33554432 the ans should be 5, may be the test case evaluation was wrong from leetcode"
                    },
                    {
                        "username": "245120733119",
                        "content": "Stuck in Same test case"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[280746028,64,256,33554432] is the longest beautiful subarray in the above test case I believe hence the expected result is 4"
                    }
                ]
            },
            {
                "id": 1734473,
                "content": [
                    {
                        "username": "suck_77",
                        "content": "Since the range of `nums[i]`, the size of sliding windows is guaranteed not larger than 32. As a result, O(n^2) solutions without sliding window are also accepted. I suggest that add zero to the range of `nums[i]` and add test cases like `[0] * 100000`."
                    },
                    {
                        "username": "MiepjeMadelon",
                        "content": "[904163577,321202512,470948612,490925389,550193477,87742556,151890632,655280661,4,263168,32,573703555,886743681,937599702,120293650,725712231,257119393] \ngives me the result \n[4, 263168, 32, 886743681], which I believe is correct. Does anyone know why the answer still is 3 instead of 4? \nEDIT: Just found out the subarray has to be continuous in the array. I'll leave the comment if anyone else has the same question."
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "[4, 263168, 32, 886743681] bro this is not contiguous in your testcase , look it carefully that\\'swhy he gave u the 3 ans in ur testcase the contiguous subarray is this... \\n      [4, 263168, 32, 573703555 ,886743681]"
                    },
                    {
                        "username": "No-one1",
                        "content": "Someone please help me with this code :\\n\\n```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector& nums) {\\nlong long mask = 0;\\nint res=0;\\nint count = 0;\\nfor(int i=0 ; i<nums.size() ; i++){\\nint x = mask&nums[i];\\nif(x==0){\\nmask = mask|nums[i];\\n\\n            cout<<count<<endl;\\n \\n            count++;\\n            \\n        }\\n        else{\\n            cout<<count<<endl;\\n            res = max(count,res);\\n            mask=nums[i];\\n            count=1;\\n        }\\n    }\\n    res = max(count,res);\\n    return res;\\n}\\n};\\n```\\nI am stuck at the test case : [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\nwhere desired output is 8 but I am getting 7 "
                    },
                    {
                        "username": "moradiya84",
                        "content": "i think i get it what we are doing is if subarray[1...5]is nicearray then adding 6 is not making it nice so we are jumping directly to 6 but it's not necessary what if subarray[3....9] is nice we are not considering so we should keep on decreasing our size untill it became nice once again or i==j."
                    },
                    {
                        "username": "moradiya84",
                        "content": "did you get it? \\nI am also stuck at same test case\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int ans=1;\\n        int x=1;\\n        long long p=v[0];\\n        for(int i=1;i<v.size();i++){\\n            long long z=v[i];\\n            if((p&z)==0){\\n                x++;\\n                ans=max(ans,x);\\n                p=p|z;\\n            }\\n            else{\\n                x=1;\\n                p=(long long)v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere\\'s mt code"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n for this test cases I believe the longest nice subarray is [65552,50331652,1,1048576,16384,544,270532608] and its length is 7 but the answer is 8.\\ncan someone please verify this?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur)[@Darshan Jain](/No-one1) so , instead what we can do is instead of shiffting both left and right pointers to the current index, we can shift left pointer to the index where the fault begin ( i.e. to the last element where OR != 0 \\n \\ni am pasting code here you can refer :\\n\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int mask = 0; \\n\\n        int l = 0 , r= 0; \\n        int max = 0; \\n\\n        while( r < arr.length ){\\n\\n            if( (mask&arr[r]) == 0 ){\\n                mask = mask | arr[r]; \\n                max = Math.max(max,r-l+1); \\n                r++; \\n            }else{\\n                mask = mask^arr[l]; \\n                l++; \\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur) yes bro i think i found where the  mistake is \\nso , the problem is [ a , b , c , d, e, f, g, h , i] suppose this is the given array and we have to find longest Nice subarray and suppose answer is 5 and we are getting 4 according to our code  , and the answer subarrray is [ c , d,e,g,h] , but according to our code if it found that current subbarray is not nice , we directly jump both left and right pointers to the current element. For example [ a , b , c , d] was a nice subarray but  b | e != 0 then according to our code it will directy jump to e . instead our left pointer should point towards c , i.e, to the next element that was creating fault. \\n\\nHope u understand ;>)"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[@No-one1](/No-one1)  still no answer :\\'("
                    },
                    {
                        "username": "No-one1",
                        "content": "Have you got the answer?\\nI am also stuck here can you please explain"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thank you people in the comments for the test cases!"
                    },
                    {
                        "username": "neo_mxn0",
                        "content": "Wrong test case or I\\'m I miss understand?\\n\\nTest case 40/65: [744437702, 379056602, 145555074, 392756761, 560864007, 934981918, 113312475, 1090, 16384, 33, 217313281, 117883195, 978927664]\\n\\nwhich has longest nice sub arr [1090, 16384, 33, 217313281]\\nlen 4\\nbut expected ans is 3"
                    },
                    {
                        "username": "smolsquirrel936",
                        "content": "[@ggcrispim](/ggcrispim) 33 & 217313281 = 1"
                    },
                    {
                        "username": "ggcrispim",
                        "content": " I am having the same issue ... did you discover why?"
                    },
                    {
                        "username": "AmanVerma_1101",
                        "content": "The length of the longest nice subarray cannot exceed 30. Why is that?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because you have only 30 bits left for and to be false of all"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long sum=0;\\n            long long prexor=0;\\n            for(int j=0;j<32;j++){\\n                if(i+j>=nums.size())\\n                break;\\n                sum=sum+nums[i+j];\\n                prexor=prexor^nums[i+j];\\n                if(sum!=prexor)\\n                break;\\n                ans=max(ans,j+1);\\n            }\\n        }\\n        return ans;\\n\\nwhy inner loop is working is constant time i.e 32 because nice array max size is possible of 32\\nnums[i]<pw(2,31)\\nin worst case if there only power of 2 elements are persent because in 32 element any two numbers can have and not eqaul to zero\\npresum and prexor take care these parameter \\n\\nevery code you seen will have some space this code don\\'t have space complexity so do give me a like which will motivate me to pin more solution like this\\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "you didnt explain the main logic of your solution\nwhy using xor and sum , \nwhy sum comparing to prexor"
                    },
                    {
                        "username": "rjkly98",
                        "content": "l: left index\nr: right index\n[l...r]: nice subarray from l to r\nhint: r is nice with [l...r-1]: [l...r-1]&r == 0 \ncan be optimized as : bitwise or (bitor[l...r-1] & r == 0)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hello, Can anyone please tell me. Why the Expected output is 5?\\n\\n`Input\\nnums =\\n[178830999,19325904,844110858,806734874,280746028,64,256,33554432,882197187,104359873,453049214,820924081,624788281,710612132,839991691]\\nOutput\\n5\\nExpected\\n4`"
                    },
                    {
                        "username": "245120733119",
                        "content": "[@2nishantthakur](/2nishantthakur) No the subarray is  806734874,280746028,64,256,33554432 the ans should be 5, may be the test case evaluation was wrong from leetcode"
                    },
                    {
                        "username": "245120733119",
                        "content": "Stuck in Same test case"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[280746028,64,256,33554432] is the longest beautiful subarray in the above test case I believe hence the expected result is 4"
                    }
                ]
            },
            {
                "id": 2058649,
                "content": [
                    {
                        "username": "suck_77",
                        "content": "Since the range of `nums[i]`, the size of sliding windows is guaranteed not larger than 32. As a result, O(n^2) solutions without sliding window are also accepted. I suggest that add zero to the range of `nums[i]` and add test cases like `[0] * 100000`."
                    },
                    {
                        "username": "MiepjeMadelon",
                        "content": "[904163577,321202512,470948612,490925389,550193477,87742556,151890632,655280661,4,263168,32,573703555,886743681,937599702,120293650,725712231,257119393] \ngives me the result \n[4, 263168, 32, 886743681], which I believe is correct. Does anyone know why the answer still is 3 instead of 4? \nEDIT: Just found out the subarray has to be continuous in the array. I'll leave the comment if anyone else has the same question."
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "[4, 263168, 32, 886743681] bro this is not contiguous in your testcase , look it carefully that\\'swhy he gave u the 3 ans in ur testcase the contiguous subarray is this... \\n      [4, 263168, 32, 573703555 ,886743681]"
                    },
                    {
                        "username": "No-one1",
                        "content": "Someone please help me with this code :\\n\\n```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector& nums) {\\nlong long mask = 0;\\nint res=0;\\nint count = 0;\\nfor(int i=0 ; i<nums.size() ; i++){\\nint x = mask&nums[i];\\nif(x==0){\\nmask = mask|nums[i];\\n\\n            cout<<count<<endl;\\n \\n            count++;\\n            \\n        }\\n        else{\\n            cout<<count<<endl;\\n            res = max(count,res);\\n            mask=nums[i];\\n            count=1;\\n        }\\n    }\\n    res = max(count,res);\\n    return res;\\n}\\n};\\n```\\nI am stuck at the test case : [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\nwhere desired output is 8 but I am getting 7 "
                    },
                    {
                        "username": "moradiya84",
                        "content": "i think i get it what we are doing is if subarray[1...5]is nicearray then adding 6 is not making it nice so we are jumping directly to 6 but it's not necessary what if subarray[3....9] is nice we are not considering so we should keep on decreasing our size untill it became nice once again or i==j."
                    },
                    {
                        "username": "moradiya84",
                        "content": "did you get it? \\nI am also stuck at same test case\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int ans=1;\\n        int x=1;\\n        long long p=v[0];\\n        for(int i=1;i<v.size();i++){\\n            long long z=v[i];\\n            if((p&z)==0){\\n                x++;\\n                ans=max(ans,x);\\n                p=p|z;\\n            }\\n            else{\\n                x=1;\\n                p=(long long)v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere\\'s mt code"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n for this test cases I believe the longest nice subarray is [65552,50331652,1,1048576,16384,544,270532608] and its length is 7 but the answer is 8.\\ncan someone please verify this?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur)[@Darshan Jain](/No-one1) so , instead what we can do is instead of shiffting both left and right pointers to the current index, we can shift left pointer to the index where the fault begin ( i.e. to the last element where OR != 0 \\n \\ni am pasting code here you can refer :\\n\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int mask = 0; \\n\\n        int l = 0 , r= 0; \\n        int max = 0; \\n\\n        while( r < arr.length ){\\n\\n            if( (mask&arr[r]) == 0 ){\\n                mask = mask | arr[r]; \\n                max = Math.max(max,r-l+1); \\n                r++; \\n            }else{\\n                mask = mask^arr[l]; \\n                l++; \\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur) yes bro i think i found where the  mistake is \\nso , the problem is [ a , b , c , d, e, f, g, h , i] suppose this is the given array and we have to find longest Nice subarray and suppose answer is 5 and we are getting 4 according to our code  , and the answer subarrray is [ c , d,e,g,h] , but according to our code if it found that current subbarray is not nice , we directly jump both left and right pointers to the current element. For example [ a , b , c , d] was a nice subarray but  b | e != 0 then according to our code it will directy jump to e . instead our left pointer should point towards c , i.e, to the next element that was creating fault. \\n\\nHope u understand ;>)"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[@No-one1](/No-one1)  still no answer :\\'("
                    },
                    {
                        "username": "No-one1",
                        "content": "Have you got the answer?\\nI am also stuck here can you please explain"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thank you people in the comments for the test cases!"
                    },
                    {
                        "username": "neo_mxn0",
                        "content": "Wrong test case or I\\'m I miss understand?\\n\\nTest case 40/65: [744437702, 379056602, 145555074, 392756761, 560864007, 934981918, 113312475, 1090, 16384, 33, 217313281, 117883195, 978927664]\\n\\nwhich has longest nice sub arr [1090, 16384, 33, 217313281]\\nlen 4\\nbut expected ans is 3"
                    },
                    {
                        "username": "smolsquirrel936",
                        "content": "[@ggcrispim](/ggcrispim) 33 & 217313281 = 1"
                    },
                    {
                        "username": "ggcrispim",
                        "content": " I am having the same issue ... did you discover why?"
                    },
                    {
                        "username": "AmanVerma_1101",
                        "content": "The length of the longest nice subarray cannot exceed 30. Why is that?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because you have only 30 bits left for and to be false of all"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long sum=0;\\n            long long prexor=0;\\n            for(int j=0;j<32;j++){\\n                if(i+j>=nums.size())\\n                break;\\n                sum=sum+nums[i+j];\\n                prexor=prexor^nums[i+j];\\n                if(sum!=prexor)\\n                break;\\n                ans=max(ans,j+1);\\n            }\\n        }\\n        return ans;\\n\\nwhy inner loop is working is constant time i.e 32 because nice array max size is possible of 32\\nnums[i]<pw(2,31)\\nin worst case if there only power of 2 elements are persent because in 32 element any two numbers can have and not eqaul to zero\\npresum and prexor take care these parameter \\n\\nevery code you seen will have some space this code don\\'t have space complexity so do give me a like which will motivate me to pin more solution like this\\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "you didnt explain the main logic of your solution\nwhy using xor and sum , \nwhy sum comparing to prexor"
                    },
                    {
                        "username": "rjkly98",
                        "content": "l: left index\nr: right index\n[l...r]: nice subarray from l to r\nhint: r is nice with [l...r-1]: [l...r-1]&r == 0 \ncan be optimized as : bitwise or (bitor[l...r-1] & r == 0)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hello, Can anyone please tell me. Why the Expected output is 5?\\n\\n`Input\\nnums =\\n[178830999,19325904,844110858,806734874,280746028,64,256,33554432,882197187,104359873,453049214,820924081,624788281,710612132,839991691]\\nOutput\\n5\\nExpected\\n4`"
                    },
                    {
                        "username": "245120733119",
                        "content": "[@2nishantthakur](/2nishantthakur) No the subarray is  806734874,280746028,64,256,33554432 the ans should be 5, may be the test case evaluation was wrong from leetcode"
                    },
                    {
                        "username": "245120733119",
                        "content": "Stuck in Same test case"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[280746028,64,256,33554432] is the longest beautiful subarray in the above test case I believe hence the expected result is 4"
                    }
                ]
            },
            {
                "id": 1871108,
                "content": [
                    {
                        "username": "suck_77",
                        "content": "Since the range of `nums[i]`, the size of sliding windows is guaranteed not larger than 32. As a result, O(n^2) solutions without sliding window are also accepted. I suggest that add zero to the range of `nums[i]` and add test cases like `[0] * 100000`."
                    },
                    {
                        "username": "MiepjeMadelon",
                        "content": "[904163577,321202512,470948612,490925389,550193477,87742556,151890632,655280661,4,263168,32,573703555,886743681,937599702,120293650,725712231,257119393] \ngives me the result \n[4, 263168, 32, 886743681], which I believe is correct. Does anyone know why the answer still is 3 instead of 4? \nEDIT: Just found out the subarray has to be continuous in the array. I'll leave the comment if anyone else has the same question."
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "[4, 263168, 32, 886743681] bro this is not contiguous in your testcase , look it carefully that\\'swhy he gave u the 3 ans in ur testcase the contiguous subarray is this... \\n      [4, 263168, 32, 573703555 ,886743681]"
                    },
                    {
                        "username": "No-one1",
                        "content": "Someone please help me with this code :\\n\\n```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector& nums) {\\nlong long mask = 0;\\nint res=0;\\nint count = 0;\\nfor(int i=0 ; i<nums.size() ; i++){\\nint x = mask&nums[i];\\nif(x==0){\\nmask = mask|nums[i];\\n\\n            cout<<count<<endl;\\n \\n            count++;\\n            \\n        }\\n        else{\\n            cout<<count<<endl;\\n            res = max(count,res);\\n            mask=nums[i];\\n            count=1;\\n        }\\n    }\\n    res = max(count,res);\\n    return res;\\n}\\n};\\n```\\nI am stuck at the test case : [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\nwhere desired output is 8 but I am getting 7 "
                    },
                    {
                        "username": "moradiya84",
                        "content": "i think i get it what we are doing is if subarray[1...5]is nicearray then adding 6 is not making it nice so we are jumping directly to 6 but it's not necessary what if subarray[3....9] is nice we are not considering so we should keep on decreasing our size untill it became nice once again or i==j."
                    },
                    {
                        "username": "moradiya84",
                        "content": "did you get it? \\nI am also stuck at same test case\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int ans=1;\\n        int x=1;\\n        long long p=v[0];\\n        for(int i=1;i<v.size();i++){\\n            long long z=v[i];\\n            if((p&z)==0){\\n                x++;\\n                ans=max(ans,x);\\n                p=p|z;\\n            }\\n            else{\\n                x=1;\\n                p=(long long)v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere\\'s mt code"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n for this test cases I believe the longest nice subarray is [65552,50331652,1,1048576,16384,544,270532608] and its length is 7 but the answer is 8.\\ncan someone please verify this?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur)[@Darshan Jain](/No-one1) so , instead what we can do is instead of shiffting both left and right pointers to the current index, we can shift left pointer to the index where the fault begin ( i.e. to the last element where OR != 0 \\n \\ni am pasting code here you can refer :\\n\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int mask = 0; \\n\\n        int l = 0 , r= 0; \\n        int max = 0; \\n\\n        while( r < arr.length ){\\n\\n            if( (mask&arr[r]) == 0 ){\\n                mask = mask | arr[r]; \\n                max = Math.max(max,r-l+1); \\n                r++; \\n            }else{\\n                mask = mask^arr[l]; \\n                l++; \\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur) yes bro i think i found where the  mistake is \\nso , the problem is [ a , b , c , d, e, f, g, h , i] suppose this is the given array and we have to find longest Nice subarray and suppose answer is 5 and we are getting 4 according to our code  , and the answer subarrray is [ c , d,e,g,h] , but according to our code if it found that current subbarray is not nice , we directly jump both left and right pointers to the current element. For example [ a , b , c , d] was a nice subarray but  b | e != 0 then according to our code it will directy jump to e . instead our left pointer should point towards c , i.e, to the next element that was creating fault. \\n\\nHope u understand ;>)"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[@No-one1](/No-one1)  still no answer :\\'("
                    },
                    {
                        "username": "No-one1",
                        "content": "Have you got the answer?\\nI am also stuck here can you please explain"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thank you people in the comments for the test cases!"
                    },
                    {
                        "username": "neo_mxn0",
                        "content": "Wrong test case or I\\'m I miss understand?\\n\\nTest case 40/65: [744437702, 379056602, 145555074, 392756761, 560864007, 934981918, 113312475, 1090, 16384, 33, 217313281, 117883195, 978927664]\\n\\nwhich has longest nice sub arr [1090, 16384, 33, 217313281]\\nlen 4\\nbut expected ans is 3"
                    },
                    {
                        "username": "smolsquirrel936",
                        "content": "[@ggcrispim](/ggcrispim) 33 & 217313281 = 1"
                    },
                    {
                        "username": "ggcrispim",
                        "content": " I am having the same issue ... did you discover why?"
                    },
                    {
                        "username": "AmanVerma_1101",
                        "content": "The length of the longest nice subarray cannot exceed 30. Why is that?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because you have only 30 bits left for and to be false of all"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long sum=0;\\n            long long prexor=0;\\n            for(int j=0;j<32;j++){\\n                if(i+j>=nums.size())\\n                break;\\n                sum=sum+nums[i+j];\\n                prexor=prexor^nums[i+j];\\n                if(sum!=prexor)\\n                break;\\n                ans=max(ans,j+1);\\n            }\\n        }\\n        return ans;\\n\\nwhy inner loop is working is constant time i.e 32 because nice array max size is possible of 32\\nnums[i]<pw(2,31)\\nin worst case if there only power of 2 elements are persent because in 32 element any two numbers can have and not eqaul to zero\\npresum and prexor take care these parameter \\n\\nevery code you seen will have some space this code don\\'t have space complexity so do give me a like which will motivate me to pin more solution like this\\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "you didnt explain the main logic of your solution\nwhy using xor and sum , \nwhy sum comparing to prexor"
                    },
                    {
                        "username": "rjkly98",
                        "content": "l: left index\nr: right index\n[l...r]: nice subarray from l to r\nhint: r is nice with [l...r-1]: [l...r-1]&r == 0 \ncan be optimized as : bitwise or (bitor[l...r-1] & r == 0)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hello, Can anyone please tell me. Why the Expected output is 5?\\n\\n`Input\\nnums =\\n[178830999,19325904,844110858,806734874,280746028,64,256,33554432,882197187,104359873,453049214,820924081,624788281,710612132,839991691]\\nOutput\\n5\\nExpected\\n4`"
                    },
                    {
                        "username": "245120733119",
                        "content": "[@2nishantthakur](/2nishantthakur) No the subarray is  806734874,280746028,64,256,33554432 the ans should be 5, may be the test case evaluation was wrong from leetcode"
                    },
                    {
                        "username": "245120733119",
                        "content": "Stuck in Same test case"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[280746028,64,256,33554432] is the longest beautiful subarray in the above test case I believe hence the expected result is 4"
                    }
                ]
            },
            {
                "id": 1791815,
                "content": [
                    {
                        "username": "suck_77",
                        "content": "Since the range of `nums[i]`, the size of sliding windows is guaranteed not larger than 32. As a result, O(n^2) solutions without sliding window are also accepted. I suggest that add zero to the range of `nums[i]` and add test cases like `[0] * 100000`."
                    },
                    {
                        "username": "MiepjeMadelon",
                        "content": "[904163577,321202512,470948612,490925389,550193477,87742556,151890632,655280661,4,263168,32,573703555,886743681,937599702,120293650,725712231,257119393] \ngives me the result \n[4, 263168, 32, 886743681], which I believe is correct. Does anyone know why the answer still is 3 instead of 4? \nEDIT: Just found out the subarray has to be continuous in the array. I'll leave the comment if anyone else has the same question."
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "[4, 263168, 32, 886743681] bro this is not contiguous in your testcase , look it carefully that\\'swhy he gave u the 3 ans in ur testcase the contiguous subarray is this... \\n      [4, 263168, 32, 573703555 ,886743681]"
                    },
                    {
                        "username": "No-one1",
                        "content": "Someone please help me with this code :\\n\\n```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector& nums) {\\nlong long mask = 0;\\nint res=0;\\nint count = 0;\\nfor(int i=0 ; i<nums.size() ; i++){\\nint x = mask&nums[i];\\nif(x==0){\\nmask = mask|nums[i];\\n\\n            cout<<count<<endl;\\n \\n            count++;\\n            \\n        }\\n        else{\\n            cout<<count<<endl;\\n            res = max(count,res);\\n            mask=nums[i];\\n            count=1;\\n        }\\n    }\\n    res = max(count,res);\\n    return res;\\n}\\n};\\n```\\nI am stuck at the test case : [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\nwhere desired output is 8 but I am getting 7 "
                    },
                    {
                        "username": "moradiya84",
                        "content": "i think i get it what we are doing is if subarray[1...5]is nicearray then adding 6 is not making it nice so we are jumping directly to 6 but it's not necessary what if subarray[3....9] is nice we are not considering so we should keep on decreasing our size untill it became nice once again or i==j."
                    },
                    {
                        "username": "moradiya84",
                        "content": "did you get it? \\nI am also stuck at same test case\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int ans=1;\\n        int x=1;\\n        long long p=v[0];\\n        for(int i=1;i<v.size();i++){\\n            long long z=v[i];\\n            if((p&z)==0){\\n                x++;\\n                ans=max(ans,x);\\n                p=p|z;\\n            }\\n            else{\\n                x=1;\\n                p=(long long)v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere\\'s mt code"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n for this test cases I believe the longest nice subarray is [65552,50331652,1,1048576,16384,544,270532608] and its length is 7 but the answer is 8.\\ncan someone please verify this?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur)[@Darshan Jain](/No-one1) so , instead what we can do is instead of shiffting both left and right pointers to the current index, we can shift left pointer to the index where the fault begin ( i.e. to the last element where OR != 0 \\n \\ni am pasting code here you can refer :\\n\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int mask = 0; \\n\\n        int l = 0 , r= 0; \\n        int max = 0; \\n\\n        while( r < arr.length ){\\n\\n            if( (mask&arr[r]) == 0 ){\\n                mask = mask | arr[r]; \\n                max = Math.max(max,r-l+1); \\n                r++; \\n            }else{\\n                mask = mask^arr[l]; \\n                l++; \\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur) yes bro i think i found where the  mistake is \\nso , the problem is [ a , b , c , d, e, f, g, h , i] suppose this is the given array and we have to find longest Nice subarray and suppose answer is 5 and we are getting 4 according to our code  , and the answer subarrray is [ c , d,e,g,h] , but according to our code if it found that current subbarray is not nice , we directly jump both left and right pointers to the current element. For example [ a , b , c , d] was a nice subarray but  b | e != 0 then according to our code it will directy jump to e . instead our left pointer should point towards c , i.e, to the next element that was creating fault. \\n\\nHope u understand ;>)"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[@No-one1](/No-one1)  still no answer :\\'("
                    },
                    {
                        "username": "No-one1",
                        "content": "Have you got the answer?\\nI am also stuck here can you please explain"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thank you people in the comments for the test cases!"
                    },
                    {
                        "username": "neo_mxn0",
                        "content": "Wrong test case or I\\'m I miss understand?\\n\\nTest case 40/65: [744437702, 379056602, 145555074, 392756761, 560864007, 934981918, 113312475, 1090, 16384, 33, 217313281, 117883195, 978927664]\\n\\nwhich has longest nice sub arr [1090, 16384, 33, 217313281]\\nlen 4\\nbut expected ans is 3"
                    },
                    {
                        "username": "smolsquirrel936",
                        "content": "[@ggcrispim](/ggcrispim) 33 & 217313281 = 1"
                    },
                    {
                        "username": "ggcrispim",
                        "content": " I am having the same issue ... did you discover why?"
                    },
                    {
                        "username": "AmanVerma_1101",
                        "content": "The length of the longest nice subarray cannot exceed 30. Why is that?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because you have only 30 bits left for and to be false of all"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long sum=0;\\n            long long prexor=0;\\n            for(int j=0;j<32;j++){\\n                if(i+j>=nums.size())\\n                break;\\n                sum=sum+nums[i+j];\\n                prexor=prexor^nums[i+j];\\n                if(sum!=prexor)\\n                break;\\n                ans=max(ans,j+1);\\n            }\\n        }\\n        return ans;\\n\\nwhy inner loop is working is constant time i.e 32 because nice array max size is possible of 32\\nnums[i]<pw(2,31)\\nin worst case if there only power of 2 elements are persent because in 32 element any two numbers can have and not eqaul to zero\\npresum and prexor take care these parameter \\n\\nevery code you seen will have some space this code don\\'t have space complexity so do give me a like which will motivate me to pin more solution like this\\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "you didnt explain the main logic of your solution\nwhy using xor and sum , \nwhy sum comparing to prexor"
                    },
                    {
                        "username": "rjkly98",
                        "content": "l: left index\nr: right index\n[l...r]: nice subarray from l to r\nhint: r is nice with [l...r-1]: [l...r-1]&r == 0 \ncan be optimized as : bitwise or (bitor[l...r-1] & r == 0)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hello, Can anyone please tell me. Why the Expected output is 5?\\n\\n`Input\\nnums =\\n[178830999,19325904,844110858,806734874,280746028,64,256,33554432,882197187,104359873,453049214,820924081,624788281,710612132,839991691]\\nOutput\\n5\\nExpected\\n4`"
                    },
                    {
                        "username": "245120733119",
                        "content": "[@2nishantthakur](/2nishantthakur) No the subarray is  806734874,280746028,64,256,33554432 the ans should be 5, may be the test case evaluation was wrong from leetcode"
                    },
                    {
                        "username": "245120733119",
                        "content": "Stuck in Same test case"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[280746028,64,256,33554432] is the longest beautiful subarray in the above test case I believe hence the expected result is 4"
                    }
                ]
            },
            {
                "id": 1737300,
                "content": [
                    {
                        "username": "suck_77",
                        "content": "Since the range of `nums[i]`, the size of sliding windows is guaranteed not larger than 32. As a result, O(n^2) solutions without sliding window are also accepted. I suggest that add zero to the range of `nums[i]` and add test cases like `[0] * 100000`."
                    },
                    {
                        "username": "MiepjeMadelon",
                        "content": "[904163577,321202512,470948612,490925389,550193477,87742556,151890632,655280661,4,263168,32,573703555,886743681,937599702,120293650,725712231,257119393] \ngives me the result \n[4, 263168, 32, 886743681], which I believe is correct. Does anyone know why the answer still is 3 instead of 4? \nEDIT: Just found out the subarray has to be continuous in the array. I'll leave the comment if anyone else has the same question."
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "[4, 263168, 32, 886743681] bro this is not contiguous in your testcase , look it carefully that\\'swhy he gave u the 3 ans in ur testcase the contiguous subarray is this... \\n      [4, 263168, 32, 573703555 ,886743681]"
                    },
                    {
                        "username": "No-one1",
                        "content": "Someone please help me with this code :\\n\\n```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector& nums) {\\nlong long mask = 0;\\nint res=0;\\nint count = 0;\\nfor(int i=0 ; i<nums.size() ; i++){\\nint x = mask&nums[i];\\nif(x==0){\\nmask = mask|nums[i];\\n\\n            cout<<count<<endl;\\n \\n            count++;\\n            \\n        }\\n        else{\\n            cout<<count<<endl;\\n            res = max(count,res);\\n            mask=nums[i];\\n            count=1;\\n        }\\n    }\\n    res = max(count,res);\\n    return res;\\n}\\n};\\n```\\nI am stuck at the test case : [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\nwhere desired output is 8 but I am getting 7 "
                    },
                    {
                        "username": "moradiya84",
                        "content": "i think i get it what we are doing is if subarray[1...5]is nicearray then adding 6 is not making it nice so we are jumping directly to 6 but it's not necessary what if subarray[3....9] is nice we are not considering so we should keep on decreasing our size untill it became nice once again or i==j."
                    },
                    {
                        "username": "moradiya84",
                        "content": "did you get it? \\nI am also stuck at same test case\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int ans=1;\\n        int x=1;\\n        long long p=v[0];\\n        for(int i=1;i<v.size();i++){\\n            long long z=v[i];\\n            if((p&z)==0){\\n                x++;\\n                ans=max(ans,x);\\n                p=p|z;\\n            }\\n            else{\\n                x=1;\\n                p=(long long)v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere\\'s mt code"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n for this test cases I believe the longest nice subarray is [65552,50331652,1,1048576,16384,544,270532608] and its length is 7 but the answer is 8.\\ncan someone please verify this?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur)[@Darshan Jain](/No-one1) so , instead what we can do is instead of shiffting both left and right pointers to the current index, we can shift left pointer to the index where the fault begin ( i.e. to the last element where OR != 0 \\n \\ni am pasting code here you can refer :\\n\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int mask = 0; \\n\\n        int l = 0 , r= 0; \\n        int max = 0; \\n\\n        while( r < arr.length ){\\n\\n            if( (mask&arr[r]) == 0 ){\\n                mask = mask | arr[r]; \\n                max = Math.max(max,r-l+1); \\n                r++; \\n            }else{\\n                mask = mask^arr[l]; \\n                l++; \\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur) yes bro i think i found where the  mistake is \\nso , the problem is [ a , b , c , d, e, f, g, h , i] suppose this is the given array and we have to find longest Nice subarray and suppose answer is 5 and we are getting 4 according to our code  , and the answer subarrray is [ c , d,e,g,h] , but according to our code if it found that current subbarray is not nice , we directly jump both left and right pointers to the current element. For example [ a , b , c , d] was a nice subarray but  b | e != 0 then according to our code it will directy jump to e . instead our left pointer should point towards c , i.e, to the next element that was creating fault. \\n\\nHope u understand ;>)"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[@No-one1](/No-one1)  still no answer :\\'("
                    },
                    {
                        "username": "No-one1",
                        "content": "Have you got the answer?\\nI am also stuck here can you please explain"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thank you people in the comments for the test cases!"
                    },
                    {
                        "username": "neo_mxn0",
                        "content": "Wrong test case or I\\'m I miss understand?\\n\\nTest case 40/65: [744437702, 379056602, 145555074, 392756761, 560864007, 934981918, 113312475, 1090, 16384, 33, 217313281, 117883195, 978927664]\\n\\nwhich has longest nice sub arr [1090, 16384, 33, 217313281]\\nlen 4\\nbut expected ans is 3"
                    },
                    {
                        "username": "smolsquirrel936",
                        "content": "[@ggcrispim](/ggcrispim) 33 & 217313281 = 1"
                    },
                    {
                        "username": "ggcrispim",
                        "content": " I am having the same issue ... did you discover why?"
                    },
                    {
                        "username": "AmanVerma_1101",
                        "content": "The length of the longest nice subarray cannot exceed 30. Why is that?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because you have only 30 bits left for and to be false of all"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long sum=0;\\n            long long prexor=0;\\n            for(int j=0;j<32;j++){\\n                if(i+j>=nums.size())\\n                break;\\n                sum=sum+nums[i+j];\\n                prexor=prexor^nums[i+j];\\n                if(sum!=prexor)\\n                break;\\n                ans=max(ans,j+1);\\n            }\\n        }\\n        return ans;\\n\\nwhy inner loop is working is constant time i.e 32 because nice array max size is possible of 32\\nnums[i]<pw(2,31)\\nin worst case if there only power of 2 elements are persent because in 32 element any two numbers can have and not eqaul to zero\\npresum and prexor take care these parameter \\n\\nevery code you seen will have some space this code don\\'t have space complexity so do give me a like which will motivate me to pin more solution like this\\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "you didnt explain the main logic of your solution\nwhy using xor and sum , \nwhy sum comparing to prexor"
                    },
                    {
                        "username": "rjkly98",
                        "content": "l: left index\nr: right index\n[l...r]: nice subarray from l to r\nhint: r is nice with [l...r-1]: [l...r-1]&r == 0 \ncan be optimized as : bitwise or (bitor[l...r-1] & r == 0)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hello, Can anyone please tell me. Why the Expected output is 5?\\n\\n`Input\\nnums =\\n[178830999,19325904,844110858,806734874,280746028,64,256,33554432,882197187,104359873,453049214,820924081,624788281,710612132,839991691]\\nOutput\\n5\\nExpected\\n4`"
                    },
                    {
                        "username": "245120733119",
                        "content": "[@2nishantthakur](/2nishantthakur) No the subarray is  806734874,280746028,64,256,33554432 the ans should be 5, may be the test case evaluation was wrong from leetcode"
                    },
                    {
                        "username": "245120733119",
                        "content": "Stuck in Same test case"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[280746028,64,256,33554432] is the longest beautiful subarray in the above test case I believe hence the expected result is 4"
                    }
                ]
            },
            {
                "id": 1902229,
                "content": [
                    {
                        "username": "suck_77",
                        "content": "Since the range of `nums[i]`, the size of sliding windows is guaranteed not larger than 32. As a result, O(n^2) solutions without sliding window are also accepted. I suggest that add zero to the range of `nums[i]` and add test cases like `[0] * 100000`."
                    },
                    {
                        "username": "MiepjeMadelon",
                        "content": "[904163577,321202512,470948612,490925389,550193477,87742556,151890632,655280661,4,263168,32,573703555,886743681,937599702,120293650,725712231,257119393] \ngives me the result \n[4, 263168, 32, 886743681], which I believe is correct. Does anyone know why the answer still is 3 instead of 4? \nEDIT: Just found out the subarray has to be continuous in the array. I'll leave the comment if anyone else has the same question."
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "[4, 263168, 32, 886743681] bro this is not contiguous in your testcase , look it carefully that\\'swhy he gave u the 3 ans in ur testcase the contiguous subarray is this... \\n      [4, 263168, 32, 573703555 ,886743681]"
                    },
                    {
                        "username": "No-one1",
                        "content": "Someone please help me with this code :\\n\\n```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector& nums) {\\nlong long mask = 0;\\nint res=0;\\nint count = 0;\\nfor(int i=0 ; i<nums.size() ; i++){\\nint x = mask&nums[i];\\nif(x==0){\\nmask = mask|nums[i];\\n\\n            cout<<count<<endl;\\n \\n            count++;\\n            \\n        }\\n        else{\\n            cout<<count<<endl;\\n            res = max(count,res);\\n            mask=nums[i];\\n            count=1;\\n        }\\n    }\\n    res = max(count,res);\\n    return res;\\n}\\n};\\n```\\nI am stuck at the test case : [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\nwhere desired output is 8 but I am getting 7 "
                    },
                    {
                        "username": "moradiya84",
                        "content": "i think i get it what we are doing is if subarray[1...5]is nicearray then adding 6 is not making it nice so we are jumping directly to 6 but it's not necessary what if subarray[3....9] is nice we are not considering so we should keep on decreasing our size untill it became nice once again or i==j."
                    },
                    {
                        "username": "moradiya84",
                        "content": "did you get it? \\nI am also stuck at same test case\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int ans=1;\\n        int x=1;\\n        long long p=v[0];\\n        for(int i=1;i<v.size();i++){\\n            long long z=v[i];\\n            if((p&z)==0){\\n                x++;\\n                ans=max(ans,x);\\n                p=p|z;\\n            }\\n            else{\\n                x=1;\\n                p=(long long)v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere\\'s mt code"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n for this test cases I believe the longest nice subarray is [65552,50331652,1,1048576,16384,544,270532608] and its length is 7 but the answer is 8.\\ncan someone please verify this?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur)[@Darshan Jain](/No-one1) so , instead what we can do is instead of shiffting both left and right pointers to the current index, we can shift left pointer to the index where the fault begin ( i.e. to the last element where OR != 0 \\n \\ni am pasting code here you can refer :\\n\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int mask = 0; \\n\\n        int l = 0 , r= 0; \\n        int max = 0; \\n\\n        while( r < arr.length ){\\n\\n            if( (mask&arr[r]) == 0 ){\\n                mask = mask | arr[r]; \\n                max = Math.max(max,r-l+1); \\n                r++; \\n            }else{\\n                mask = mask^arr[l]; \\n                l++; \\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur) yes bro i think i found where the  mistake is \\nso , the problem is [ a , b , c , d, e, f, g, h , i] suppose this is the given array and we have to find longest Nice subarray and suppose answer is 5 and we are getting 4 according to our code  , and the answer subarrray is [ c , d,e,g,h] , but according to our code if it found that current subbarray is not nice , we directly jump both left and right pointers to the current element. For example [ a , b , c , d] was a nice subarray but  b | e != 0 then according to our code it will directy jump to e . instead our left pointer should point towards c , i.e, to the next element that was creating fault. \\n\\nHope u understand ;>)"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[@No-one1](/No-one1)  still no answer :\\'("
                    },
                    {
                        "username": "No-one1",
                        "content": "Have you got the answer?\\nI am also stuck here can you please explain"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thank you people in the comments for the test cases!"
                    },
                    {
                        "username": "neo_mxn0",
                        "content": "Wrong test case or I\\'m I miss understand?\\n\\nTest case 40/65: [744437702, 379056602, 145555074, 392756761, 560864007, 934981918, 113312475, 1090, 16384, 33, 217313281, 117883195, 978927664]\\n\\nwhich has longest nice sub arr [1090, 16384, 33, 217313281]\\nlen 4\\nbut expected ans is 3"
                    },
                    {
                        "username": "smolsquirrel936",
                        "content": "[@ggcrispim](/ggcrispim) 33 & 217313281 = 1"
                    },
                    {
                        "username": "ggcrispim",
                        "content": " I am having the same issue ... did you discover why?"
                    },
                    {
                        "username": "AmanVerma_1101",
                        "content": "The length of the longest nice subarray cannot exceed 30. Why is that?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because you have only 30 bits left for and to be false of all"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long sum=0;\\n            long long prexor=0;\\n            for(int j=0;j<32;j++){\\n                if(i+j>=nums.size())\\n                break;\\n                sum=sum+nums[i+j];\\n                prexor=prexor^nums[i+j];\\n                if(sum!=prexor)\\n                break;\\n                ans=max(ans,j+1);\\n            }\\n        }\\n        return ans;\\n\\nwhy inner loop is working is constant time i.e 32 because nice array max size is possible of 32\\nnums[i]<pw(2,31)\\nin worst case if there only power of 2 elements are persent because in 32 element any two numbers can have and not eqaul to zero\\npresum and prexor take care these parameter \\n\\nevery code you seen will have some space this code don\\'t have space complexity so do give me a like which will motivate me to pin more solution like this\\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "you didnt explain the main logic of your solution\nwhy using xor and sum , \nwhy sum comparing to prexor"
                    },
                    {
                        "username": "rjkly98",
                        "content": "l: left index\nr: right index\n[l...r]: nice subarray from l to r\nhint: r is nice with [l...r-1]: [l...r-1]&r == 0 \ncan be optimized as : bitwise or (bitor[l...r-1] & r == 0)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hello, Can anyone please tell me. Why the Expected output is 5?\\n\\n`Input\\nnums =\\n[178830999,19325904,844110858,806734874,280746028,64,256,33554432,882197187,104359873,453049214,820924081,624788281,710612132,839991691]\\nOutput\\n5\\nExpected\\n4`"
                    },
                    {
                        "username": "245120733119",
                        "content": "[@2nishantthakur](/2nishantthakur) No the subarray is  806734874,280746028,64,256,33554432 the ans should be 5, may be the test case evaluation was wrong from leetcode"
                    },
                    {
                        "username": "245120733119",
                        "content": "Stuck in Same test case"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[280746028,64,256,33554432] is the longest beautiful subarray in the above test case I believe hence the expected result is 4"
                    }
                ]
            },
            {
                "id": 1897896,
                "content": [
                    {
                        "username": "suck_77",
                        "content": "Since the range of `nums[i]`, the size of sliding windows is guaranteed not larger than 32. As a result, O(n^2) solutions without sliding window are also accepted. I suggest that add zero to the range of `nums[i]` and add test cases like `[0] * 100000`."
                    },
                    {
                        "username": "MiepjeMadelon",
                        "content": "[904163577,321202512,470948612,490925389,550193477,87742556,151890632,655280661,4,263168,32,573703555,886743681,937599702,120293650,725712231,257119393] \ngives me the result \n[4, 263168, 32, 886743681], which I believe is correct. Does anyone know why the answer still is 3 instead of 4? \nEDIT: Just found out the subarray has to be continuous in the array. I'll leave the comment if anyone else has the same question."
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "[4, 263168, 32, 886743681] bro this is not contiguous in your testcase , look it carefully that\\'swhy he gave u the 3 ans in ur testcase the contiguous subarray is this... \\n      [4, 263168, 32, 573703555 ,886743681]"
                    },
                    {
                        "username": "No-one1",
                        "content": "Someone please help me with this code :\\n\\n```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector& nums) {\\nlong long mask = 0;\\nint res=0;\\nint count = 0;\\nfor(int i=0 ; i<nums.size() ; i++){\\nint x = mask&nums[i];\\nif(x==0){\\nmask = mask|nums[i];\\n\\n            cout<<count<<endl;\\n \\n            count++;\\n            \\n        }\\n        else{\\n            cout<<count<<endl;\\n            res = max(count,res);\\n            mask=nums[i];\\n            count=1;\\n        }\\n    }\\n    res = max(count,res);\\n    return res;\\n}\\n};\\n```\\nI am stuck at the test case : [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\nwhere desired output is 8 but I am getting 7 "
                    },
                    {
                        "username": "moradiya84",
                        "content": "i think i get it what we are doing is if subarray[1...5]is nicearray then adding 6 is not making it nice so we are jumping directly to 6 but it's not necessary what if subarray[3....9] is nice we are not considering so we should keep on decreasing our size untill it became nice once again or i==j."
                    },
                    {
                        "username": "moradiya84",
                        "content": "did you get it? \\nI am also stuck at same test case\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int ans=1;\\n        int x=1;\\n        long long p=v[0];\\n        for(int i=1;i<v.size();i++){\\n            long long z=v[i];\\n            if((p&z)==0){\\n                x++;\\n                ans=max(ans,x);\\n                p=p|z;\\n            }\\n            else{\\n                x=1;\\n                p=(long long)v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere\\'s mt code"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n for this test cases I believe the longest nice subarray is [65552,50331652,1,1048576,16384,544,270532608] and its length is 7 but the answer is 8.\\ncan someone please verify this?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur)[@Darshan Jain](/No-one1) so , instead what we can do is instead of shiffting both left and right pointers to the current index, we can shift left pointer to the index where the fault begin ( i.e. to the last element where OR != 0 \\n \\ni am pasting code here you can refer :\\n\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int mask = 0; \\n\\n        int l = 0 , r= 0; \\n        int max = 0; \\n\\n        while( r < arr.length ){\\n\\n            if( (mask&arr[r]) == 0 ){\\n                mask = mask | arr[r]; \\n                max = Math.max(max,r-l+1); \\n                r++; \\n            }else{\\n                mask = mask^arr[l]; \\n                l++; \\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur) yes bro i think i found where the  mistake is \\nso , the problem is [ a , b , c , d, e, f, g, h , i] suppose this is the given array and we have to find longest Nice subarray and suppose answer is 5 and we are getting 4 according to our code  , and the answer subarrray is [ c , d,e,g,h] , but according to our code if it found that current subbarray is not nice , we directly jump both left and right pointers to the current element. For example [ a , b , c , d] was a nice subarray but  b | e != 0 then according to our code it will directy jump to e . instead our left pointer should point towards c , i.e, to the next element that was creating fault. \\n\\nHope u understand ;>)"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[@No-one1](/No-one1)  still no answer :\\'("
                    },
                    {
                        "username": "No-one1",
                        "content": "Have you got the answer?\\nI am also stuck here can you please explain"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thank you people in the comments for the test cases!"
                    },
                    {
                        "username": "neo_mxn0",
                        "content": "Wrong test case or I\\'m I miss understand?\\n\\nTest case 40/65: [744437702, 379056602, 145555074, 392756761, 560864007, 934981918, 113312475, 1090, 16384, 33, 217313281, 117883195, 978927664]\\n\\nwhich has longest nice sub arr [1090, 16384, 33, 217313281]\\nlen 4\\nbut expected ans is 3"
                    },
                    {
                        "username": "smolsquirrel936",
                        "content": "[@ggcrispim](/ggcrispim) 33 & 217313281 = 1"
                    },
                    {
                        "username": "ggcrispim",
                        "content": " I am having the same issue ... did you discover why?"
                    },
                    {
                        "username": "AmanVerma_1101",
                        "content": "The length of the longest nice subarray cannot exceed 30. Why is that?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because you have only 30 bits left for and to be false of all"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long sum=0;\\n            long long prexor=0;\\n            for(int j=0;j<32;j++){\\n                if(i+j>=nums.size())\\n                break;\\n                sum=sum+nums[i+j];\\n                prexor=prexor^nums[i+j];\\n                if(sum!=prexor)\\n                break;\\n                ans=max(ans,j+1);\\n            }\\n        }\\n        return ans;\\n\\nwhy inner loop is working is constant time i.e 32 because nice array max size is possible of 32\\nnums[i]<pw(2,31)\\nin worst case if there only power of 2 elements are persent because in 32 element any two numbers can have and not eqaul to zero\\npresum and prexor take care these parameter \\n\\nevery code you seen will have some space this code don\\'t have space complexity so do give me a like which will motivate me to pin more solution like this\\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "you didnt explain the main logic of your solution\nwhy using xor and sum , \nwhy sum comparing to prexor"
                    },
                    {
                        "username": "rjkly98",
                        "content": "l: left index\nr: right index\n[l...r]: nice subarray from l to r\nhint: r is nice with [l...r-1]: [l...r-1]&r == 0 \ncan be optimized as : bitwise or (bitor[l...r-1] & r == 0)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hello, Can anyone please tell me. Why the Expected output is 5?\\n\\n`Input\\nnums =\\n[178830999,19325904,844110858,806734874,280746028,64,256,33554432,882197187,104359873,453049214,820924081,624788281,710612132,839991691]\\nOutput\\n5\\nExpected\\n4`"
                    },
                    {
                        "username": "245120733119",
                        "content": "[@2nishantthakur](/2nishantthakur) No the subarray is  806734874,280746028,64,256,33554432 the ans should be 5, may be the test case evaluation was wrong from leetcode"
                    },
                    {
                        "username": "245120733119",
                        "content": "Stuck in Same test case"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[280746028,64,256,33554432] is the longest beautiful subarray in the above test case I believe hence the expected result is 4"
                    }
                ]
            },
            {
                "id": 1883174,
                "content": [
                    {
                        "username": "suck_77",
                        "content": "Since the range of `nums[i]`, the size of sliding windows is guaranteed not larger than 32. As a result, O(n^2) solutions without sliding window are also accepted. I suggest that add zero to the range of `nums[i]` and add test cases like `[0] * 100000`."
                    },
                    {
                        "username": "MiepjeMadelon",
                        "content": "[904163577,321202512,470948612,490925389,550193477,87742556,151890632,655280661,4,263168,32,573703555,886743681,937599702,120293650,725712231,257119393] \ngives me the result \n[4, 263168, 32, 886743681], which I believe is correct. Does anyone know why the answer still is 3 instead of 4? \nEDIT: Just found out the subarray has to be continuous in the array. I'll leave the comment if anyone else has the same question."
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "[4, 263168, 32, 886743681] bro this is not contiguous in your testcase , look it carefully that\\'swhy he gave u the 3 ans in ur testcase the contiguous subarray is this... \\n      [4, 263168, 32, 573703555 ,886743681]"
                    },
                    {
                        "username": "No-one1",
                        "content": "Someone please help me with this code :\\n\\n```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector& nums) {\\nlong long mask = 0;\\nint res=0;\\nint count = 0;\\nfor(int i=0 ; i<nums.size() ; i++){\\nint x = mask&nums[i];\\nif(x==0){\\nmask = mask|nums[i];\\n\\n            cout<<count<<endl;\\n \\n            count++;\\n            \\n        }\\n        else{\\n            cout<<count<<endl;\\n            res = max(count,res);\\n            mask=nums[i];\\n            count=1;\\n        }\\n    }\\n    res = max(count,res);\\n    return res;\\n}\\n};\\n```\\nI am stuck at the test case : [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\nwhere desired output is 8 but I am getting 7 "
                    },
                    {
                        "username": "moradiya84",
                        "content": "i think i get it what we are doing is if subarray[1...5]is nicearray then adding 6 is not making it nice so we are jumping directly to 6 but it's not necessary what if subarray[3....9] is nice we are not considering so we should keep on decreasing our size untill it became nice once again or i==j."
                    },
                    {
                        "username": "moradiya84",
                        "content": "did you get it? \\nI am also stuck at same test case\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int ans=1;\\n        int x=1;\\n        long long p=v[0];\\n        for(int i=1;i<v.size();i++){\\n            long long z=v[i];\\n            if((p&z)==0){\\n                x++;\\n                ans=max(ans,x);\\n                p=p|z;\\n            }\\n            else{\\n                x=1;\\n                p=(long long)v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere\\'s mt code"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n for this test cases I believe the longest nice subarray is [65552,50331652,1,1048576,16384,544,270532608] and its length is 7 but the answer is 8.\\ncan someone please verify this?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur)[@Darshan Jain](/No-one1) so , instead what we can do is instead of shiffting both left and right pointers to the current index, we can shift left pointer to the index where the fault begin ( i.e. to the last element where OR != 0 \\n \\ni am pasting code here you can refer :\\n\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int mask = 0; \\n\\n        int l = 0 , r= 0; \\n        int max = 0; \\n\\n        while( r < arr.length ){\\n\\n            if( (mask&arr[r]) == 0 ){\\n                mask = mask | arr[r]; \\n                max = Math.max(max,r-l+1); \\n                r++; \\n            }else{\\n                mask = mask^arr[l]; \\n                l++; \\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur) yes bro i think i found where the  mistake is \\nso , the problem is [ a , b , c , d, e, f, g, h , i] suppose this is the given array and we have to find longest Nice subarray and suppose answer is 5 and we are getting 4 according to our code  , and the answer subarrray is [ c , d,e,g,h] , but according to our code if it found that current subbarray is not nice , we directly jump both left and right pointers to the current element. For example [ a , b , c , d] was a nice subarray but  b | e != 0 then according to our code it will directy jump to e . instead our left pointer should point towards c , i.e, to the next element that was creating fault. \\n\\nHope u understand ;>)"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[@No-one1](/No-one1)  still no answer :\\'("
                    },
                    {
                        "username": "No-one1",
                        "content": "Have you got the answer?\\nI am also stuck here can you please explain"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thank you people in the comments for the test cases!"
                    },
                    {
                        "username": "neo_mxn0",
                        "content": "Wrong test case or I\\'m I miss understand?\\n\\nTest case 40/65: [744437702, 379056602, 145555074, 392756761, 560864007, 934981918, 113312475, 1090, 16384, 33, 217313281, 117883195, 978927664]\\n\\nwhich has longest nice sub arr [1090, 16384, 33, 217313281]\\nlen 4\\nbut expected ans is 3"
                    },
                    {
                        "username": "smolsquirrel936",
                        "content": "[@ggcrispim](/ggcrispim) 33 & 217313281 = 1"
                    },
                    {
                        "username": "ggcrispim",
                        "content": " I am having the same issue ... did you discover why?"
                    },
                    {
                        "username": "AmanVerma_1101",
                        "content": "The length of the longest nice subarray cannot exceed 30. Why is that?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because you have only 30 bits left for and to be false of all"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long sum=0;\\n            long long prexor=0;\\n            for(int j=0;j<32;j++){\\n                if(i+j>=nums.size())\\n                break;\\n                sum=sum+nums[i+j];\\n                prexor=prexor^nums[i+j];\\n                if(sum!=prexor)\\n                break;\\n                ans=max(ans,j+1);\\n            }\\n        }\\n        return ans;\\n\\nwhy inner loop is working is constant time i.e 32 because nice array max size is possible of 32\\nnums[i]<pw(2,31)\\nin worst case if there only power of 2 elements are persent because in 32 element any two numbers can have and not eqaul to zero\\npresum and prexor take care these parameter \\n\\nevery code you seen will have some space this code don\\'t have space complexity so do give me a like which will motivate me to pin more solution like this\\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "you didnt explain the main logic of your solution\nwhy using xor and sum , \nwhy sum comparing to prexor"
                    },
                    {
                        "username": "rjkly98",
                        "content": "l: left index\nr: right index\n[l...r]: nice subarray from l to r\nhint: r is nice with [l...r-1]: [l...r-1]&r == 0 \ncan be optimized as : bitwise or (bitor[l...r-1] & r == 0)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hello, Can anyone please tell me. Why the Expected output is 5?\\n\\n`Input\\nnums =\\n[178830999,19325904,844110858,806734874,280746028,64,256,33554432,882197187,104359873,453049214,820924081,624788281,710612132,839991691]\\nOutput\\n5\\nExpected\\n4`"
                    },
                    {
                        "username": "245120733119",
                        "content": "[@2nishantthakur](/2nishantthakur) No the subarray is  806734874,280746028,64,256,33554432 the ans should be 5, may be the test case evaluation was wrong from leetcode"
                    },
                    {
                        "username": "245120733119",
                        "content": "Stuck in Same test case"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[280746028,64,256,33554432] is the longest beautiful subarray in the above test case I believe hence the expected result is 4"
                    }
                ]
            },
            {
                "id": 1824111,
                "content": [
                    {
                        "username": "suck_77",
                        "content": "Since the range of `nums[i]`, the size of sliding windows is guaranteed not larger than 32. As a result, O(n^2) solutions without sliding window are also accepted. I suggest that add zero to the range of `nums[i]` and add test cases like `[0] * 100000`."
                    },
                    {
                        "username": "MiepjeMadelon",
                        "content": "[904163577,321202512,470948612,490925389,550193477,87742556,151890632,655280661,4,263168,32,573703555,886743681,937599702,120293650,725712231,257119393] \ngives me the result \n[4, 263168, 32, 886743681], which I believe is correct. Does anyone know why the answer still is 3 instead of 4? \nEDIT: Just found out the subarray has to be continuous in the array. I'll leave the comment if anyone else has the same question."
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "[4, 263168, 32, 886743681] bro this is not contiguous in your testcase , look it carefully that\\'swhy he gave u the 3 ans in ur testcase the contiguous subarray is this... \\n      [4, 263168, 32, 573703555 ,886743681]"
                    },
                    {
                        "username": "No-one1",
                        "content": "Someone please help me with this code :\\n\\n```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector& nums) {\\nlong long mask = 0;\\nint res=0;\\nint count = 0;\\nfor(int i=0 ; i<nums.size() ; i++){\\nint x = mask&nums[i];\\nif(x==0){\\nmask = mask|nums[i];\\n\\n            cout<<count<<endl;\\n \\n            count++;\\n            \\n        }\\n        else{\\n            cout<<count<<endl;\\n            res = max(count,res);\\n            mask=nums[i];\\n            count=1;\\n        }\\n    }\\n    res = max(count,res);\\n    return res;\\n}\\n};\\n```\\nI am stuck at the test case : [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\nwhere desired output is 8 but I am getting 7 "
                    },
                    {
                        "username": "moradiya84",
                        "content": "i think i get it what we are doing is if subarray[1...5]is nicearray then adding 6 is not making it nice so we are jumping directly to 6 but it's not necessary what if subarray[3....9] is nice we are not considering so we should keep on decreasing our size untill it became nice once again or i==j."
                    },
                    {
                        "username": "moradiya84",
                        "content": "did you get it? \\nI am also stuck at same test case\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int ans=1;\\n        int x=1;\\n        long long p=v[0];\\n        for(int i=1;i<v.size();i++){\\n            long long z=v[i];\\n            if((p&z)==0){\\n                x++;\\n                ans=max(ans,x);\\n                p=p|z;\\n            }\\n            else{\\n                x=1;\\n                p=(long long)v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere\\'s mt code"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n for this test cases I believe the longest nice subarray is [65552,50331652,1,1048576,16384,544,270532608] and its length is 7 but the answer is 8.\\ncan someone please verify this?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur)[@Darshan Jain](/No-one1) so , instead what we can do is instead of shiffting both left and right pointers to the current index, we can shift left pointer to the index where the fault begin ( i.e. to the last element where OR != 0 \\n \\ni am pasting code here you can refer :\\n\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int mask = 0; \\n\\n        int l = 0 , r= 0; \\n        int max = 0; \\n\\n        while( r < arr.length ){\\n\\n            if( (mask&arr[r]) == 0 ){\\n                mask = mask | arr[r]; \\n                max = Math.max(max,r-l+1); \\n                r++; \\n            }else{\\n                mask = mask^arr[l]; \\n                l++; \\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur) yes bro i think i found where the  mistake is \\nso , the problem is [ a , b , c , d, e, f, g, h , i] suppose this is the given array and we have to find longest Nice subarray and suppose answer is 5 and we are getting 4 according to our code  , and the answer subarrray is [ c , d,e,g,h] , but according to our code if it found that current subbarray is not nice , we directly jump both left and right pointers to the current element. For example [ a , b , c , d] was a nice subarray but  b | e != 0 then according to our code it will directy jump to e . instead our left pointer should point towards c , i.e, to the next element that was creating fault. \\n\\nHope u understand ;>)"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[@No-one1](/No-one1)  still no answer :\\'("
                    },
                    {
                        "username": "No-one1",
                        "content": "Have you got the answer?\\nI am also stuck here can you please explain"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thank you people in the comments for the test cases!"
                    },
                    {
                        "username": "neo_mxn0",
                        "content": "Wrong test case or I\\'m I miss understand?\\n\\nTest case 40/65: [744437702, 379056602, 145555074, 392756761, 560864007, 934981918, 113312475, 1090, 16384, 33, 217313281, 117883195, 978927664]\\n\\nwhich has longest nice sub arr [1090, 16384, 33, 217313281]\\nlen 4\\nbut expected ans is 3"
                    },
                    {
                        "username": "smolsquirrel936",
                        "content": "[@ggcrispim](/ggcrispim) 33 & 217313281 = 1"
                    },
                    {
                        "username": "ggcrispim",
                        "content": " I am having the same issue ... did you discover why?"
                    },
                    {
                        "username": "AmanVerma_1101",
                        "content": "The length of the longest nice subarray cannot exceed 30. Why is that?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because you have only 30 bits left for and to be false of all"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long sum=0;\\n            long long prexor=0;\\n            for(int j=0;j<32;j++){\\n                if(i+j>=nums.size())\\n                break;\\n                sum=sum+nums[i+j];\\n                prexor=prexor^nums[i+j];\\n                if(sum!=prexor)\\n                break;\\n                ans=max(ans,j+1);\\n            }\\n        }\\n        return ans;\\n\\nwhy inner loop is working is constant time i.e 32 because nice array max size is possible of 32\\nnums[i]<pw(2,31)\\nin worst case if there only power of 2 elements are persent because in 32 element any two numbers can have and not eqaul to zero\\npresum and prexor take care these parameter \\n\\nevery code you seen will have some space this code don\\'t have space complexity so do give me a like which will motivate me to pin more solution like this\\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "you didnt explain the main logic of your solution\nwhy using xor and sum , \nwhy sum comparing to prexor"
                    },
                    {
                        "username": "rjkly98",
                        "content": "l: left index\nr: right index\n[l...r]: nice subarray from l to r\nhint: r is nice with [l...r-1]: [l...r-1]&r == 0 \ncan be optimized as : bitwise or (bitor[l...r-1] & r == 0)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hello, Can anyone please tell me. Why the Expected output is 5?\\n\\n`Input\\nnums =\\n[178830999,19325904,844110858,806734874,280746028,64,256,33554432,882197187,104359873,453049214,820924081,624788281,710612132,839991691]\\nOutput\\n5\\nExpected\\n4`"
                    },
                    {
                        "username": "245120733119",
                        "content": "[@2nishantthakur](/2nishantthakur) No the subarray is  806734874,280746028,64,256,33554432 the ans should be 5, may be the test case evaluation was wrong from leetcode"
                    },
                    {
                        "username": "245120733119",
                        "content": "Stuck in Same test case"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[280746028,64,256,33554432] is the longest beautiful subarray in the above test case I believe hence the expected result is 4"
                    }
                ]
            },
            {
                "id": 1793215,
                "content": [
                    {
                        "username": "suck_77",
                        "content": "Since the range of `nums[i]`, the size of sliding windows is guaranteed not larger than 32. As a result, O(n^2) solutions without sliding window are also accepted. I suggest that add zero to the range of `nums[i]` and add test cases like `[0] * 100000`."
                    },
                    {
                        "username": "MiepjeMadelon",
                        "content": "[904163577,321202512,470948612,490925389,550193477,87742556,151890632,655280661,4,263168,32,573703555,886743681,937599702,120293650,725712231,257119393] \ngives me the result \n[4, 263168, 32, 886743681], which I believe is correct. Does anyone know why the answer still is 3 instead of 4? \nEDIT: Just found out the subarray has to be continuous in the array. I'll leave the comment if anyone else has the same question."
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "[4, 263168, 32, 886743681] bro this is not contiguous in your testcase , look it carefully that\\'swhy he gave u the 3 ans in ur testcase the contiguous subarray is this... \\n      [4, 263168, 32, 573703555 ,886743681]"
                    },
                    {
                        "username": "No-one1",
                        "content": "Someone please help me with this code :\\n\\n```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector& nums) {\\nlong long mask = 0;\\nint res=0;\\nint count = 0;\\nfor(int i=0 ; i<nums.size() ; i++){\\nint x = mask&nums[i];\\nif(x==0){\\nmask = mask|nums[i];\\n\\n            cout<<count<<endl;\\n \\n            count++;\\n            \\n        }\\n        else{\\n            cout<<count<<endl;\\n            res = max(count,res);\\n            mask=nums[i];\\n            count=1;\\n        }\\n    }\\n    res = max(count,res);\\n    return res;\\n}\\n};\\n```\\nI am stuck at the test case : [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\nwhere desired output is 8 but I am getting 7 "
                    },
                    {
                        "username": "moradiya84",
                        "content": "i think i get it what we are doing is if subarray[1...5]is nicearray then adding 6 is not making it nice so we are jumping directly to 6 but it's not necessary what if subarray[3....9] is nice we are not considering so we should keep on decreasing our size untill it became nice once again or i==j."
                    },
                    {
                        "username": "moradiya84",
                        "content": "did you get it? \\nI am also stuck at same test case\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int ans=1;\\n        int x=1;\\n        long long p=v[0];\\n        for(int i=1;i<v.size();i++){\\n            long long z=v[i];\\n            if((p&z)==0){\\n                x++;\\n                ans=max(ans,x);\\n                p=p|z;\\n            }\\n            else{\\n                x=1;\\n                p=(long long)v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere\\'s mt code"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n for this test cases I believe the longest nice subarray is [65552,50331652,1,1048576,16384,544,270532608] and its length is 7 but the answer is 8.\\ncan someone please verify this?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur)[@Darshan Jain](/No-one1) so , instead what we can do is instead of shiffting both left and right pointers to the current index, we can shift left pointer to the index where the fault begin ( i.e. to the last element where OR != 0 \\n \\ni am pasting code here you can refer :\\n\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int mask = 0; \\n\\n        int l = 0 , r= 0; \\n        int max = 0; \\n\\n        while( r < arr.length ){\\n\\n            if( (mask&arr[r]) == 0 ){\\n                mask = mask | arr[r]; \\n                max = Math.max(max,r-l+1); \\n                r++; \\n            }else{\\n                mask = mask^arr[l]; \\n                l++; \\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur) yes bro i think i found where the  mistake is \\nso , the problem is [ a , b , c , d, e, f, g, h , i] suppose this is the given array and we have to find longest Nice subarray and suppose answer is 5 and we are getting 4 according to our code  , and the answer subarrray is [ c , d,e,g,h] , but according to our code if it found that current subbarray is not nice , we directly jump both left and right pointers to the current element. For example [ a , b , c , d] was a nice subarray but  b | e != 0 then according to our code it will directy jump to e . instead our left pointer should point towards c , i.e, to the next element that was creating fault. \\n\\nHope u understand ;>)"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[@No-one1](/No-one1)  still no answer :\\'("
                    },
                    {
                        "username": "No-one1",
                        "content": "Have you got the answer?\\nI am also stuck here can you please explain"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thank you people in the comments for the test cases!"
                    },
                    {
                        "username": "neo_mxn0",
                        "content": "Wrong test case or I\\'m I miss understand?\\n\\nTest case 40/65: [744437702, 379056602, 145555074, 392756761, 560864007, 934981918, 113312475, 1090, 16384, 33, 217313281, 117883195, 978927664]\\n\\nwhich has longest nice sub arr [1090, 16384, 33, 217313281]\\nlen 4\\nbut expected ans is 3"
                    },
                    {
                        "username": "smolsquirrel936",
                        "content": "[@ggcrispim](/ggcrispim) 33 & 217313281 = 1"
                    },
                    {
                        "username": "ggcrispim",
                        "content": " I am having the same issue ... did you discover why?"
                    },
                    {
                        "username": "AmanVerma_1101",
                        "content": "The length of the longest nice subarray cannot exceed 30. Why is that?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because you have only 30 bits left for and to be false of all"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long sum=0;\\n            long long prexor=0;\\n            for(int j=0;j<32;j++){\\n                if(i+j>=nums.size())\\n                break;\\n                sum=sum+nums[i+j];\\n                prexor=prexor^nums[i+j];\\n                if(sum!=prexor)\\n                break;\\n                ans=max(ans,j+1);\\n            }\\n        }\\n        return ans;\\n\\nwhy inner loop is working is constant time i.e 32 because nice array max size is possible of 32\\nnums[i]<pw(2,31)\\nin worst case if there only power of 2 elements are persent because in 32 element any two numbers can have and not eqaul to zero\\npresum and prexor take care these parameter \\n\\nevery code you seen will have some space this code don\\'t have space complexity so do give me a like which will motivate me to pin more solution like this\\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "you didnt explain the main logic of your solution\nwhy using xor and sum , \nwhy sum comparing to prexor"
                    },
                    {
                        "username": "rjkly98",
                        "content": "l: left index\nr: right index\n[l...r]: nice subarray from l to r\nhint: r is nice with [l...r-1]: [l...r-1]&r == 0 \ncan be optimized as : bitwise or (bitor[l...r-1] & r == 0)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hello, Can anyone please tell me. Why the Expected output is 5?\\n\\n`Input\\nnums =\\n[178830999,19325904,844110858,806734874,280746028,64,256,33554432,882197187,104359873,453049214,820924081,624788281,710612132,839991691]\\nOutput\\n5\\nExpected\\n4`"
                    },
                    {
                        "username": "245120733119",
                        "content": "[@2nishantthakur](/2nishantthakur) No the subarray is  806734874,280746028,64,256,33554432 the ans should be 5, may be the test case evaluation was wrong from leetcode"
                    },
                    {
                        "username": "245120733119",
                        "content": "Stuck in Same test case"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[280746028,64,256,33554432] is the longest beautiful subarray in the above test case I believe hence the expected result is 4"
                    }
                ]
            },
            {
                "id": 1734473,
                "content": [
                    {
                        "username": "suck_77",
                        "content": "Since the range of `nums[i]`, the size of sliding windows is guaranteed not larger than 32. As a result, O(n^2) solutions without sliding window are also accepted. I suggest that add zero to the range of `nums[i]` and add test cases like `[0] * 100000`."
                    },
                    {
                        "username": "MiepjeMadelon",
                        "content": "[904163577,321202512,470948612,490925389,550193477,87742556,151890632,655280661,4,263168,32,573703555,886743681,937599702,120293650,725712231,257119393] \ngives me the result \n[4, 263168, 32, 886743681], which I believe is correct. Does anyone know why the answer still is 3 instead of 4? \nEDIT: Just found out the subarray has to be continuous in the array. I'll leave the comment if anyone else has the same question."
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "[4, 263168, 32, 886743681] bro this is not contiguous in your testcase , look it carefully that\\'swhy he gave u the 3 ans in ur testcase the contiguous subarray is this... \\n      [4, 263168, 32, 573703555 ,886743681]"
                    },
                    {
                        "username": "No-one1",
                        "content": "Someone please help me with this code :\\n\\n```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector& nums) {\\nlong long mask = 0;\\nint res=0;\\nint count = 0;\\nfor(int i=0 ; i<nums.size() ; i++){\\nint x = mask&nums[i];\\nif(x==0){\\nmask = mask|nums[i];\\n\\n            cout<<count<<endl;\\n \\n            count++;\\n            \\n        }\\n        else{\\n            cout<<count<<endl;\\n            res = max(count,res);\\n            mask=nums[i];\\n            count=1;\\n        }\\n    }\\n    res = max(count,res);\\n    return res;\\n}\\n};\\n```\\nI am stuck at the test case : [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\nwhere desired output is 8 but I am getting 7 "
                    },
                    {
                        "username": "moradiya84",
                        "content": "i think i get it what we are doing is if subarray[1...5]is nicearray then adding 6 is not making it nice so we are jumping directly to 6 but it's not necessary what if subarray[3....9] is nice we are not considering so we should keep on decreasing our size untill it became nice once again or i==j."
                    },
                    {
                        "username": "moradiya84",
                        "content": "did you get it? \\nI am also stuck at same test case\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int ans=1;\\n        int x=1;\\n        long long p=v[0];\\n        for(int i=1;i<v.size();i++){\\n            long long z=v[i];\\n            if((p&z)==0){\\n                x++;\\n                ans=max(ans,x);\\n                p=p|z;\\n            }\\n            else{\\n                x=1;\\n                p=(long long)v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere\\'s mt code"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n for this test cases I believe the longest nice subarray is [65552,50331652,1,1048576,16384,544,270532608] and its length is 7 but the answer is 8.\\ncan someone please verify this?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur)[@Darshan Jain](/No-one1) so , instead what we can do is instead of shiffting both left and right pointers to the current index, we can shift left pointer to the index where the fault begin ( i.e. to the last element where OR != 0 \\n \\ni am pasting code here you can refer :\\n\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int mask = 0; \\n\\n        int l = 0 , r= 0; \\n        int max = 0; \\n\\n        while( r < arr.length ){\\n\\n            if( (mask&arr[r]) == 0 ){\\n                mask = mask | arr[r]; \\n                max = Math.max(max,r-l+1); \\n                r++; \\n            }else{\\n                mask = mask^arr[l]; \\n                l++; \\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur) yes bro i think i found where the  mistake is \\nso , the problem is [ a , b , c , d, e, f, g, h , i] suppose this is the given array and we have to find longest Nice subarray and suppose answer is 5 and we are getting 4 according to our code  , and the answer subarrray is [ c , d,e,g,h] , but according to our code if it found that current subbarray is not nice , we directly jump both left and right pointers to the current element. For example [ a , b , c , d] was a nice subarray but  b | e != 0 then according to our code it will directy jump to e . instead our left pointer should point towards c , i.e, to the next element that was creating fault. \\n\\nHope u understand ;>)"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[@No-one1](/No-one1)  still no answer :\\'("
                    },
                    {
                        "username": "No-one1",
                        "content": "Have you got the answer?\\nI am also stuck here can you please explain"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thank you people in the comments for the test cases!"
                    },
                    {
                        "username": "neo_mxn0",
                        "content": "Wrong test case or I\\'m I miss understand?\\n\\nTest case 40/65: [744437702, 379056602, 145555074, 392756761, 560864007, 934981918, 113312475, 1090, 16384, 33, 217313281, 117883195, 978927664]\\n\\nwhich has longest nice sub arr [1090, 16384, 33, 217313281]\\nlen 4\\nbut expected ans is 3"
                    },
                    {
                        "username": "smolsquirrel936",
                        "content": "[@ggcrispim](/ggcrispim) 33 & 217313281 = 1"
                    },
                    {
                        "username": "ggcrispim",
                        "content": " I am having the same issue ... did you discover why?"
                    },
                    {
                        "username": "AmanVerma_1101",
                        "content": "The length of the longest nice subarray cannot exceed 30. Why is that?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because you have only 30 bits left for and to be false of all"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long sum=0;\\n            long long prexor=0;\\n            for(int j=0;j<32;j++){\\n                if(i+j>=nums.size())\\n                break;\\n                sum=sum+nums[i+j];\\n                prexor=prexor^nums[i+j];\\n                if(sum!=prexor)\\n                break;\\n                ans=max(ans,j+1);\\n            }\\n        }\\n        return ans;\\n\\nwhy inner loop is working is constant time i.e 32 because nice array max size is possible of 32\\nnums[i]<pw(2,31)\\nin worst case if there only power of 2 elements are persent because in 32 element any two numbers can have and not eqaul to zero\\npresum and prexor take care these parameter \\n\\nevery code you seen will have some space this code don\\'t have space complexity so do give me a like which will motivate me to pin more solution like this\\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "you didnt explain the main logic of your solution\nwhy using xor and sum , \nwhy sum comparing to prexor"
                    },
                    {
                        "username": "rjkly98",
                        "content": "l: left index\nr: right index\n[l...r]: nice subarray from l to r\nhint: r is nice with [l...r-1]: [l...r-1]&r == 0 \ncan be optimized as : bitwise or (bitor[l...r-1] & r == 0)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hello, Can anyone please tell me. Why the Expected output is 5?\\n\\n`Input\\nnums =\\n[178830999,19325904,844110858,806734874,280746028,64,256,33554432,882197187,104359873,453049214,820924081,624788281,710612132,839991691]\\nOutput\\n5\\nExpected\\n4`"
                    },
                    {
                        "username": "245120733119",
                        "content": "[@2nishantthakur](/2nishantthakur) No the subarray is  806734874,280746028,64,256,33554432 the ans should be 5, may be the test case evaluation was wrong from leetcode"
                    },
                    {
                        "username": "245120733119",
                        "content": "Stuck in Same test case"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[280746028,64,256,33554432] is the longest beautiful subarray in the above test case I believe hence the expected result is 4"
                    }
                ]
            },
            {
                "id": 2058649,
                "content": [
                    {
                        "username": "suck_77",
                        "content": "Since the range of `nums[i]`, the size of sliding windows is guaranteed not larger than 32. As a result, O(n^2) solutions without sliding window are also accepted. I suggest that add zero to the range of `nums[i]` and add test cases like `[0] * 100000`."
                    },
                    {
                        "username": "MiepjeMadelon",
                        "content": "[904163577,321202512,470948612,490925389,550193477,87742556,151890632,655280661,4,263168,32,573703555,886743681,937599702,120293650,725712231,257119393] \ngives me the result \n[4, 263168, 32, 886743681], which I believe is correct. Does anyone know why the answer still is 3 instead of 4? \nEDIT: Just found out the subarray has to be continuous in the array. I'll leave the comment if anyone else has the same question."
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "[4, 263168, 32, 886743681] bro this is not contiguous in your testcase , look it carefully that\\'swhy he gave u the 3 ans in ur testcase the contiguous subarray is this... \\n      [4, 263168, 32, 573703555 ,886743681]"
                    },
                    {
                        "username": "No-one1",
                        "content": "Someone please help me with this code :\\n\\n```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector& nums) {\\nlong long mask = 0;\\nint res=0;\\nint count = 0;\\nfor(int i=0 ; i<nums.size() ; i++){\\nint x = mask&nums[i];\\nif(x==0){\\nmask = mask|nums[i];\\n\\n            cout<<count<<endl;\\n \\n            count++;\\n            \\n        }\\n        else{\\n            cout<<count<<endl;\\n            res = max(count,res);\\n            mask=nums[i];\\n            count=1;\\n        }\\n    }\\n    res = max(count,res);\\n    return res;\\n}\\n};\\n```\\nI am stuck at the test case : [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\nwhere desired output is 8 but I am getting 7 "
                    },
                    {
                        "username": "moradiya84",
                        "content": "i think i get it what we are doing is if subarray[1...5]is nicearray then adding 6 is not making it nice so we are jumping directly to 6 but it's not necessary what if subarray[3....9] is nice we are not considering so we should keep on decreasing our size untill it became nice once again or i==j."
                    },
                    {
                        "username": "moradiya84",
                        "content": "did you get it? \\nI am also stuck at same test case\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int ans=1;\\n        int x=1;\\n        long long p=v[0];\\n        for(int i=1;i<v.size();i++){\\n            long long z=v[i];\\n            if((p&z)==0){\\n                x++;\\n                ans=max(ans,x);\\n                p=p|z;\\n            }\\n            else{\\n                x=1;\\n                p=(long long)v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere\\'s mt code"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n for this test cases I believe the longest nice subarray is [65552,50331652,1,1048576,16384,544,270532608] and its length is 7 but the answer is 8.\\ncan someone please verify this?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur)[@Darshan Jain](/No-one1) so , instead what we can do is instead of shiffting both left and right pointers to the current index, we can shift left pointer to the index where the fault begin ( i.e. to the last element where OR != 0 \\n \\ni am pasting code here you can refer :\\n\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int mask = 0; \\n\\n        int l = 0 , r= 0; \\n        int max = 0; \\n\\n        while( r < arr.length ){\\n\\n            if( (mask&arr[r]) == 0 ){\\n                mask = mask | arr[r]; \\n                max = Math.max(max,r-l+1); \\n                r++; \\n            }else{\\n                mask = mask^arr[l]; \\n                l++; \\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur) yes bro i think i found where the  mistake is \\nso , the problem is [ a , b , c , d, e, f, g, h , i] suppose this is the given array and we have to find longest Nice subarray and suppose answer is 5 and we are getting 4 according to our code  , and the answer subarrray is [ c , d,e,g,h] , but according to our code if it found that current subbarray is not nice , we directly jump both left and right pointers to the current element. For example [ a , b , c , d] was a nice subarray but  b | e != 0 then according to our code it will directy jump to e . instead our left pointer should point towards c , i.e, to the next element that was creating fault. \\n\\nHope u understand ;>)"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[@No-one1](/No-one1)  still no answer :\\'("
                    },
                    {
                        "username": "No-one1",
                        "content": "Have you got the answer?\\nI am also stuck here can you please explain"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thank you people in the comments for the test cases!"
                    },
                    {
                        "username": "neo_mxn0",
                        "content": "Wrong test case or I\\'m I miss understand?\\n\\nTest case 40/65: [744437702, 379056602, 145555074, 392756761, 560864007, 934981918, 113312475, 1090, 16384, 33, 217313281, 117883195, 978927664]\\n\\nwhich has longest nice sub arr [1090, 16384, 33, 217313281]\\nlen 4\\nbut expected ans is 3"
                    },
                    {
                        "username": "smolsquirrel936",
                        "content": "[@ggcrispim](/ggcrispim) 33 & 217313281 = 1"
                    },
                    {
                        "username": "ggcrispim",
                        "content": " I am having the same issue ... did you discover why?"
                    },
                    {
                        "username": "AmanVerma_1101",
                        "content": "The length of the longest nice subarray cannot exceed 30. Why is that?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because you have only 30 bits left for and to be false of all"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long sum=0;\\n            long long prexor=0;\\n            for(int j=0;j<32;j++){\\n                if(i+j>=nums.size())\\n                break;\\n                sum=sum+nums[i+j];\\n                prexor=prexor^nums[i+j];\\n                if(sum!=prexor)\\n                break;\\n                ans=max(ans,j+1);\\n            }\\n        }\\n        return ans;\\n\\nwhy inner loop is working is constant time i.e 32 because nice array max size is possible of 32\\nnums[i]<pw(2,31)\\nin worst case if there only power of 2 elements are persent because in 32 element any two numbers can have and not eqaul to zero\\npresum and prexor take care these parameter \\n\\nevery code you seen will have some space this code don\\'t have space complexity so do give me a like which will motivate me to pin more solution like this\\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "you didnt explain the main logic of your solution\nwhy using xor and sum , \nwhy sum comparing to prexor"
                    },
                    {
                        "username": "rjkly98",
                        "content": "l: left index\nr: right index\n[l...r]: nice subarray from l to r\nhint: r is nice with [l...r-1]: [l...r-1]&r == 0 \ncan be optimized as : bitwise or (bitor[l...r-1] & r == 0)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hello, Can anyone please tell me. Why the Expected output is 5?\\n\\n`Input\\nnums =\\n[178830999,19325904,844110858,806734874,280746028,64,256,33554432,882197187,104359873,453049214,820924081,624788281,710612132,839991691]\\nOutput\\n5\\nExpected\\n4`"
                    },
                    {
                        "username": "245120733119",
                        "content": "[@2nishantthakur](/2nishantthakur) No the subarray is  806734874,280746028,64,256,33554432 the ans should be 5, may be the test case evaluation was wrong from leetcode"
                    },
                    {
                        "username": "245120733119",
                        "content": "Stuck in Same test case"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[280746028,64,256,33554432] is the longest beautiful subarray in the above test case I believe hence the expected result is 4"
                    }
                ]
            },
            {
                "id": 1871108,
                "content": [
                    {
                        "username": "suck_77",
                        "content": "Since the range of `nums[i]`, the size of sliding windows is guaranteed not larger than 32. As a result, O(n^2) solutions without sliding window are also accepted. I suggest that add zero to the range of `nums[i]` and add test cases like `[0] * 100000`."
                    },
                    {
                        "username": "MiepjeMadelon",
                        "content": "[904163577,321202512,470948612,490925389,550193477,87742556,151890632,655280661,4,263168,32,573703555,886743681,937599702,120293650,725712231,257119393] \ngives me the result \n[4, 263168, 32, 886743681], which I believe is correct. Does anyone know why the answer still is 3 instead of 4? \nEDIT: Just found out the subarray has to be continuous in the array. I'll leave the comment if anyone else has the same question."
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "[4, 263168, 32, 886743681] bro this is not contiguous in your testcase , look it carefully that\\'swhy he gave u the 3 ans in ur testcase the contiguous subarray is this... \\n      [4, 263168, 32, 573703555 ,886743681]"
                    },
                    {
                        "username": "No-one1",
                        "content": "Someone please help me with this code :\\n\\n```\\nclass Solution {\\npublic:\\nint longestNiceSubarray(vector& nums) {\\nlong long mask = 0;\\nint res=0;\\nint count = 0;\\nfor(int i=0 ; i<nums.size() ; i++){\\nint x = mask&nums[i];\\nif(x==0){\\nmask = mask|nums[i];\\n\\n            cout<<count<<endl;\\n \\n            count++;\\n            \\n        }\\n        else{\\n            cout<<count<<endl;\\n            res = max(count,res);\\n            mask=nums[i];\\n            count=1;\\n        }\\n    }\\n    res = max(count,res);\\n    return res;\\n}\\n};\\n```\\nI am stuck at the test case : [84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\nwhere desired output is 8 but I am getting 7 "
                    },
                    {
                        "username": "moradiya84",
                        "content": "i think i get it what we are doing is if subarray[1...5]is nicearray then adding 6 is not making it nice so we are jumping directly to 6 but it's not necessary what if subarray[3....9] is nice we are not considering so we should keep on decreasing our size untill it became nice once again or i==j."
                    },
                    {
                        "username": "moradiya84",
                        "content": "did you get it? \\nI am also stuck at same test case\\n```\\nclass Solution {\\npublic:\\n    int longestNiceSubarray(vector<int>& v) {\\n        int ans=1;\\n        int x=1;\\n        long long p=v[0];\\n        for(int i=1;i<v.size();i++){\\n            long long z=v[i];\\n            if((p&z)==0){\\n                x++;\\n                ans=max(ans,x);\\n                p=p|z;\\n            }\\n            else{\\n                x=1;\\n                p=(long long)v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nhere\\'s mt code"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[84139415,693324769,614626365,497710833,615598711,264,65552,50331652,1,1048576,16384,544,270532608,151813349,221976871,678178917,845710321,751376227,331656525,739558112,267703680]\\n for this test cases I believe the longest nice subarray is [65552,50331652,1,1048576,16384,544,270532608] and its length is 7 but the answer is 8.\\ncan someone please verify this?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur)[@Darshan Jain](/No-one1) so , instead what we can do is instead of shiffting both left and right pointers to the current index, we can shift left pointer to the index where the fault begin ( i.e. to the last element where OR != 0 \\n \\ni am pasting code here you can refer :\\n\\nclass Solution {\\n    public int longestNiceSubarray(int[] arr) {\\n        int mask = 0; \\n\\n        int l = 0 , r= 0; \\n        int max = 0; \\n\\n        while( r < arr.length ){\\n\\n            if( (mask&arr[r]) == 0 ){\\n                mask = mask | arr[r]; \\n                max = Math.max(max,r-l+1); \\n                r++; \\n            }else{\\n                mask = mask^arr[l]; \\n                l++; \\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Nishant](/2nishantthakur) yes bro i think i found where the  mistake is \\nso , the problem is [ a , b , c , d, e, f, g, h , i] suppose this is the given array and we have to find longest Nice subarray and suppose answer is 5 and we are getting 4 according to our code  , and the answer subarrray is [ c , d,e,g,h] , but according to our code if it found that current subbarray is not nice , we directly jump both left and right pointers to the current element. For example [ a , b , c , d] was a nice subarray but  b | e != 0 then according to our code it will directy jump to e . instead our left pointer should point towards c , i.e, to the next element that was creating fault. \\n\\nHope u understand ;>)"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[@No-one1](/No-one1)  still no answer :\\'("
                    },
                    {
                        "username": "No-one1",
                        "content": "Have you got the answer?\\nI am also stuck here can you please explain"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Thank you people in the comments for the test cases!"
                    },
                    {
                        "username": "neo_mxn0",
                        "content": "Wrong test case or I\\'m I miss understand?\\n\\nTest case 40/65: [744437702, 379056602, 145555074, 392756761, 560864007, 934981918, 113312475, 1090, 16384, 33, 217313281, 117883195, 978927664]\\n\\nwhich has longest nice sub arr [1090, 16384, 33, 217313281]\\nlen 4\\nbut expected ans is 3"
                    },
                    {
                        "username": "smolsquirrel936",
                        "content": "[@ggcrispim](/ggcrispim) 33 & 217313281 = 1"
                    },
                    {
                        "username": "ggcrispim",
                        "content": " I am having the same issue ... did you discover why?"
                    },
                    {
                        "username": "AmanVerma_1101",
                        "content": "The length of the longest nice subarray cannot exceed 30. Why is that?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because you have only 30 bits left for and to be false of all"
                    },
                    {
                        "username": "SHUBHANSHU_GUPTA-156",
                        "content": "int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long sum=0;\\n            long long prexor=0;\\n            for(int j=0;j<32;j++){\\n                if(i+j>=nums.size())\\n                break;\\n                sum=sum+nums[i+j];\\n                prexor=prexor^nums[i+j];\\n                if(sum!=prexor)\\n                break;\\n                ans=max(ans,j+1);\\n            }\\n        }\\n        return ans;\\n\\nwhy inner loop is working is constant time i.e 32 because nice array max size is possible of 32\\nnums[i]<pw(2,31)\\nin worst case if there only power of 2 elements are persent because in 32 element any two numbers can have and not eqaul to zero\\npresum and prexor take care these parameter \\n\\nevery code you seen will have some space this code don\\'t have space complexity so do give me a like which will motivate me to pin more solution like this\\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "you didnt explain the main logic of your solution\nwhy using xor and sum , \nwhy sum comparing to prexor"
                    },
                    {
                        "username": "rjkly98",
                        "content": "l: left index\nr: right index\n[l...r]: nice subarray from l to r\nhint: r is nice with [l...r-1]: [l...r-1]&r == 0 \ncan be optimized as : bitwise or (bitor[l...r-1] & r == 0)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hello, Can anyone please tell me. Why the Expected output is 5?\\n\\n`Input\\nnums =\\n[178830999,19325904,844110858,806734874,280746028,64,256,33554432,882197187,104359873,453049214,820924081,624788281,710612132,839991691]\\nOutput\\n5\\nExpected\\n4`"
                    },
                    {
                        "username": "245120733119",
                        "content": "[@2nishantthakur](/2nishantthakur) No the subarray is  806734874,280746028,64,256,33554432 the ans should be 5, may be the test case evaluation was wrong from leetcode"
                    },
                    {
                        "username": "245120733119",
                        "content": "Stuck in Same test case"
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "[280746028,64,256,33554432] is the longest beautiful subarray in the above test case I believe hence the expected result is 4"
                    }
                ]
            }
        ]
    }
]