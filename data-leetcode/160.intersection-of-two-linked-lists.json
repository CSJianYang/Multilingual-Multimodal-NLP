[
    {
        "title": "Permutation Sequence",
        "question_content": "The set [1, 2, 3, ...,&nbsp;n] contains a total of n! unique permutations.\nBy listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n\n\t\"123\"\n\t\"132\"\n\t\"213\"\n\t\"231\"\n\t\"312\"\n\t\"321\"\n\nGiven n and k, return the kth permutation sequence.\n&nbsp;\nExample 1:\nInput: n = 3, k = 3\nOutput: \"213\"\nExample 2:\nInput: n = 4, k = 9\nOutput: \"2314\"\nExample 3:\nInput: n = 3, k = 1\nOutput: \"123\"\n&nbsp;\nConstraints:\n\n\t1 <= n <= 9\n\t1 <= k <= n!",
        "solutions": [
            {
                "id": 22507,
                "title": "explain-like-i-m-five-java-solution-in-o-n",
                "content": "**EDIT: I\\'m tired of some of you commenting on the O(n)-ness of this and especially those of you with snarky condescending tones. It\\'s not difficult to implement your own data structure that can do O(1) \"list\" remove. I\\'m not going to put all that code here and dilute the the main solution which is the pattern of solving the permutations. The description on the pattern is already long enough as it is. If you can\\'t figure out how to do an O(1) remove, then you shouldn\\'t be doing this problem in the first place. Those of you commenting condescendingly, take a freaking break from leetcoding all day. Those of you with kind words and thanks, you\\'re welcome and thanks for taking the time to read through the somewhat long description.**\\n\\nI\\'m sure somewhere can be simplified so it\\'d be nice if anyone can let me know. The pattern was that:\\n\\nsay n = 4, you have {1, 2, 3, 4}\\n\\nIf you were to list out all the permutations you have \\n\\n1 + (permutations of 2, 3, 4)\\n<br>2 + (permutations of 1, 3, 4)\\n<br>3 + (permutations of 1, 2, 4)\\n<br>4 + (permutations of 1, 2, 3)\\n\\n<br>We know how to calculate the number of permutations of n numbers... n! So each of those with permutations of 3 numbers means there are 6 possible permutations. Meaning there would be a total of 24 permutations in this particular one. So if you were to look for the (k = 14) 14th permutation, it would be in the \\n\\n3 + (permutations of 1, 2, 4) subset. \\n\\nTo programmatically get that, you take k = 13 (subtract 1 because of things always starting at 0) and divide that by the 6 we got from the factorial, which would give you the index of the number you want. In the array {1, 2, 3, 4}, k/(n-1)! = 13/(4-1)! = 13/3! = 13/6 = 2. The array {1, 2, 3, 4} has a value of 3 at index 2. So the first number is a 3.\\n\\nThen the problem repeats with less numbers.\\n\\nThe permutations of {1, 2, 4} would be:\\n\\n1 + (permutations of 2, 4)\\n<br>2 + (permutations of 1, 4)\\n<br>4 + (permutations of 1, 2)\\n\\nBut our k is no longer the 14th, because in the previous step, we\\'ve already eliminated the 12 4-number permutations starting with 1 and 2. So you subtract 12 from k.. which gives you 1. Programmatically that would be...\\n\\nk = k - (index from previous) * (n-1)! = k - 2*(n-1)! = 13 - 2*(3)! = 1\\n\\nIn this second step, permutations of 2 numbers has only 2 possibilities, meaning each of the three permutations listed above a has two possibilities, giving a total of 6. We\\'re looking for the first one, so that would be in the 1 + (permutations of 2, 4) subset. \\n\\nMeaning: index to get number from is k / (n - 2)!  = 1 / (4-2)! = 1 / 2! = 0.. from {1, 2, 4}, index 0 is 1\\n\\n<br>so the numbers we have so far is 3, 1... and then repeating without explanations.\\n\\n<br>{2, 4}\\n<br>k = k - (index from pervious) * (n-2)! = k - 0 * (n - 2)! = 1 - 0 = 1;\\n<br>third number\\'s index = k / (n - 3)! = 1 / (4-3)! = 1/ 1! = 1... from {2, 4}, index 1 has 4\\n<br>Third number is 4\\n\\n<br>{2}\\n<br>k = k - (index from pervious) * (n - 3)! = k - 1 * (4 - 3)! = 1 - 1 = 0;\\n<br>third number\\'s index = k / (n - 4)! = 0 / (4-4)! = 0/ 1 = 0... from {2}, index 0 has 2\\n<br>Fourth number is 2\\n\\n<br>Giving us 3142. If you manually list out the permutations using DFS method, it would be 3142. Done! It really was all about pattern finding.\\n\\n\\n\\n    public class Solution {\\n    public String getPermutation(int n, int k) {\\n        int pos = 0;\\n        List<Integer> numbers = new ArrayList<>();\\n        int[] factorial = new int[n+1];\\n        StringBuilder sb = new StringBuilder();\\n        \\n        // create an array of factorial lookup\\n        int sum = 1;\\n        factorial[0] = 1;\\n        for(int i=1; i<=n; i++){\\n            sum *= i;\\n            factorial[i] = sum;\\n        }\\n        // factorial[] = {1, 1, 2, 6, 24, ... n!}\\n        \\n        // create a list of numbers to get indices\\n        for(int i=1; i<=n; i++){\\n            numbers.add(i);\\n        }\\n        // numbers = {1, 2, 3, 4}\\n        \\n        k--;\\n        \\n        for(int i = 1; i <= n; i++){\\n            int index = k/factorial[n-i];\\n            sb.append(String.valueOf(numbers.get(index)));\\n            numbers.remove(index);\\n            k-=index*factorial[n-i];\\n        }\\n        \\n        return String.valueOf(sb);\\n    }\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public String getPermutation(int n, int k) {\\n        int pos = 0;\\n        List<Integer> numbers = new ArrayList<>();\\n        int[] factorial = new int[n+1];\\n        StringBuilder sb = new StringBuilder();\\n        \\n        // create an array of factorial lookup\\n        int sum = 1;\\n        factorial[0] = 1;\\n        for(int i=1; i<=n; i++){\\n            sum *= i;\\n            factorial[i] = sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 696595,
                "title": "c-very-easy-and-detailed-explanation-idea-code",
                "content": "Let us first take an example to under the idea:\\nSuppose n = 4.\\nSo we have elements  - 1,2,3,4\\nThere are total n!= 4! = 24 permutations possible. We can see a specific pattern here:\\n\\n```\\narr\\n[ 1            2           3          4]\\n1 2 3 4     2 1 3 4     3 1 2 4    4 1 2 3\\n1 2 4 3     2 1 4 3     3 1 4 2    4 1 3 2\\n1 3 2 4     2 3 1 4     3 2 1 4    4 2 1 3\\n1 3 4 2     2 3 4 1     3 2 4 1    4 2 3 1\\n1 4 2 3     2 4 1 3     3 4 1 2    4 3 1 2\\n1 4 3 2     2 4 3 1     3 4 2 1    4 3 2 1\\nSo we have 4 block with 6 elements each.\\n\\nn = 4  we can take an array [1,2,3,4] , initital ans = \"\"\\nlets say we have k =15, the 15 th permutation is \"3 2 1 4\":\\n\\nAs we can see the first value is 3 that means out of the four blocks we need the 3rd block. \\nEach blocks has n-1! = 3! = 6 elements --> 15 = 6*2 + 3 i.e. we skip 2 blocks and our ans is the third element in the 3rd block\\nLet us assume the blocks are zero indexed.\\nNow 15 / 6 = 2;  So we select the 2nd block (0-indexed) that means 2nd index in our array - 3\\nNow ans = \"3\"\\nRemove this element from the array and our array becomes: [1,2,4]\\n---------------------------------------------------------------------------------------------\\nNow we are in this block:\\n3 1 2 4  - 1  \\n3 1 4 2  - 2   Block 0\\n  ------ \\n3 2 1 4  - 3 (ans)\\n3 2 4 1  - 4    Block 1\\n  ------\\n3 4 1 2  - 5   \\n3 4 2 1  - 6    Block 2\\nNow we have 3 blocks each of with 2 elements \\ni,e. n = n-1 = 3blocks and n-1! = 2! = 2 elements\\nn = 3, what will be the k? As we passed 12 elements we have k = 15-12 => the third element in this large block.\\nk = 3\\nelement in partition (p) = 2;\\nk / p = 3 / 2 = 1 => ans is in block 1, value to add to ans  = 2\\narr[1] = 2;\\nans = \"32\"\\nremove 2 from array => [1,4]\\nNow we have 2 elements left(n-1 = 3-1) \\n-----------------------------------------------------------------------------\\n32  1 4  Block 0\\n32  4 1  Block 1\\n\\nn=2, k = 1\\n1 will be added ans = \"321\"  arr= [4]\\nAs we only have one value value in array append it to ans.  ans = \"3214\"\\n\\nOne very important note:(Corner case)\\nWhen we have k as a multiple of elements in partition for e.g. k = 12 Then we want to be in block with index 1\\nbut as index = 12 / 6 = 2; we have to keep index = index-1;\\nOnly when we are aiming at the last element we will hit this case.\\nHere the blocks are zero indexed but the elements inside them are 1 index.\\n\\nI\\'m sure after you look at the code you will completely understand it\\n```\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    // Our recursive function that will complete the ans string.\\n\\t// v - is our current array = [1,2,3,4]\\n\\t// ans is the answer string, n and k are current values of n and k\\n\\t// factVal is an array containing the factorial of all integers from 0-9 to get factorial in O(1) time.\\n\\t// That means I have stored all the factorials in this array before hand to avoid calculation. You can also write factorial funciton if you want.\\n\\t\\n    void setPerm(vector<int>& v,string& ans,int n,int k,vector<int>& factVal){\\n       // if there is only one element left append it to our ans (Base case)\\n\\t   if(n==1){\\n            ans+=to_string(v.back());\\n            return;\\n        }\\n\\t\\t\\n\\t\\t// We are calculating the required index.  factVal[n-1] means for n =  4 => factVal[3] = 6.\\n        // 15 / 6 = 2 will the index for k =15 and n = 4.\\n\\t\\tint index = (k/factVal[n-1]);\\n        // if k is a multiple of elements of partition then decrement the index (Corner case I was talking about)\\n\\t\\tif(k % factVal[n-1] == 0){\\n            index--;\\n        }\\n\\t\\t\\n\\t\\tans+= to_string(v[index]);  // add value to string\\n        v.erase(v.begin() + index);  // remove element from array\\n        k -= factVal[n-1] * index;   // adjust value of k; k = 15 - 6*2 = 3.\\n\\t\\t// Recursive call with n=n-1 as one element is added we need remaing.\\n        setPerm(v,ans,n-1,k,factVal);\\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        if(n==1) return \"1\";\\n\\t\\t//Factorials of 0-9 stored in the array. factVal[3] = 6. (3! = 6)\\n        vector<int>factVal = {1,1,2,6,24,120,720,5040,40320,362880};\\n        string ans = \"\";\\n        vector<int> v;\\n\\t\\t// Fill the array with all elements\\n        for(int i=1;i<=n;i++) v.emplace_back(i);\\n        setPerm(v,ans,n,k,factVal);\\n        return ans;\\n    }\\n};\\n```\\n\\nI hope you enjoyed it. If there is any blunder kindly let me know.\\nHappy Coding!",
                "solutionTags": [],
                "code": "```\\narr\\n[ 1            2           3          4]\\n1 2 3 4     2 1 3 4     3 1 2 4    4 1 2 3\\n1 2 4 3     2 1 4 3     3 1 4 2    4 1 3 2\\n1 3 2 4     2 3 1 4     3 2 1 4    4 2 1 3\\n1 3 4 2     2 3 4 1     3 2 4 1    4 2 3 1\\n1 4 2 3     2 4 1 3     3 4 1 2    4 3 1 2\\n1 4 3 2     2 4 3 1     3 4 2 1    4 3 2 1\\nSo we have 4 block with 6 elements each.\\n\\nn = 4  we can take an array [1,2,3,4] , initital ans = \"\"\\nlets say we have k =15, the 15 th permutation is \"3 2 1 4\":\\n\\nAs we can see the first value is 3 that means out of the four blocks we need the 3rd block. \\nEach blocks has n-1! = 3! = 6 elements --> 15 = 6*2 + 3 i.e. we skip 2 blocks and our ans is the third element in the 3rd block\\nLet us assume the blocks are zero indexed.\\nNow 15 / 6 = 2;  So we select the 2nd block (0-indexed) that means 2nd index in our array - 3\\nNow ans = \"3\"\\nRemove this element from the array and our array becomes: [1,2,4]\\n---------------------------------------------------------------------------------------------\\nNow we are in this block:\\n3 1 2 4  - 1  \\n3 1 4 2  - 2   Block 0\\n  ------ \\n3 2 1 4  - 3 (ans)\\n3 2 4 1  - 4    Block 1\\n  ------\\n3 4 1 2  - 5   \\n3 4 2 1  - 6    Block 2\\nNow we have 3 blocks each of with 2 elements \\ni,e. n = n-1 = 3blocks and n-1! = 2! = 2 elements\\nn = 3, what will be the k? As we passed 12 elements we have k = 15-12 => the third element in this large block.\\nk = 3\\nelement in partition (p) = 2;\\nk / p = 3 / 2 = 1 => ans is in block 1, value to add to ans  = 2\\narr[1] = 2;\\nans = \"32\"\\nremove 2 from array => [1,4]\\nNow we have 2 elements left(n-1 = 3-1) \\n-----------------------------------------------------------------------------\\n32  1 4  Block 0\\n32  4 1  Block 1\\n\\nn=2, k = 1\\n1 will be added ans = \"321\"  arr= [4]\\nAs we only have one value value in array append it to ans.  ans = \"3214\"\\n\\nOne very important note:(Corner case)\\nWhen we have k as a multiple of elements in partition for e.g. k = 12 Then we want to be in block with index 1\\nbut as index = 12 / 6 = 2; we have to keep index = index-1;\\nOnly when we are aiming at the last element we will hit this case.\\nHere the blocks are zero indexed but the elements inside them are 1 index.\\n\\nI\\'m sure after you look at the code you will completely understand it\\n```\n```\\nclass Solution {\\npublic:\\n    // Our recursive function that will complete the ans string.\\n\\t// v - is our current array = [1,2,3,4]\\n\\t// ans is the answer string, n and k are current values of n and k\\n\\t// factVal is an array containing the factorial of all integers from 0-9 to get factorial in O(1) time.\\n\\t// That means I have stored all the factorials in this array before hand to avoid calculation. You can also write factorial funciton if you want.\\n\\t\\n    void setPerm(vector<int>& v,string& ans,int n,int k,vector<int>& factVal){\\n       // if there is only one element left append it to our ans (Base case)\\n\\t   if(n==1){\\n            ans+=to_string(v.back());\\n            return;\\n        }\\n\\t\\t\\n\\t\\t// We are calculating the required index.  factVal[n-1] means for n =  4 => factVal[3] = 6.\\n        // 15 / 6 = 2 will the index for k =15 and n = 4.\\n\\t\\tint index = (k/factVal[n-1]);\\n        // if k is a multiple of elements of partition then decrement the index (Corner case I was talking about)\\n\\t\\tif(k % factVal[n-1] == 0){\\n            index--;\\n        }\\n\\t\\t\\n\\t\\tans+= to_string(v[index]);  // add value to string\\n        v.erase(v.begin() + index);  // remove element from array\\n        k -= factVal[n-1] * index;   // adjust value of k; k = 15 - 6*2 = 3.\\n\\t\\t// Recursive call with n=n-1 as one element is added we need remaing.\\n        setPerm(v,ans,n-1,k,factVal);\\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        if(n==1) return \"1\";\\n\\t\\t//Factorials of 0-9 stored in the array. factVal[3] = 6. (3! = 6)\\n        vector<int>factVal = {1,1,2,6,24,120,720,5040,40320,362880};\\n        string ans = \"\";\\n        vector<int> v;\\n\\t\\t// Fill the array with all elements\\n        for(int i=1;i<=n;i++) v.emplace_back(i);\\n        setPerm(v,ans,n,k,factVal);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22512,
                "title": "share-my-python-solution-with-detailed-explanation",
                "content": "The idea is as follow:\\n\\nFor permutations of n, the first (n-1)! permutations start with 1, next (n-1)! ones start with 2, ... and so on. And in each group of (n-1)! permutations, the first (n-2)! permutations start with the smallest remaining number, ...\\n\\ntake n = 3 as an example, the first 2 (that is, (3-1)! ) permutations start with 1, next 2 start with 2 and last 2 start with 3. For the first 2 permutations (123 and 132), the 1st one (1!) starts with 2, which is the smallest remaining number (2 and 3). So we can use a loop to check the region that the sequence number falls in and get the starting digit. Then we adjust the sequence number and continue.\\n\\n    import math\\n    class Solution:\\n        # @param {integer} n\\n        # @param {integer} k\\n        # @return {string}\\n        def getPermutation(self, n, k):\\n            numbers = range(1, n+1)\\n            permutation = ''\\n            k -= 1\\n            while n > 0:\\n                n -= 1\\n                # get the index of current digit\\n                index, k = divmod(k, math.factorial(n))\\n                permutation += str(numbers[index])\\n                # remove handled number\\n                numbers.remove(numbers[index])\\n    \\n            return permutation",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 22508,
                "title": "an-iterative-solution-for-reference",
                "content": "Recursion will use more memory, while this problem can be solved by iteration. I solved this problem before, but I didn't realize that using k = k-1 would avoid dealing with case k%(n-1)!==0. Rewrote this code, should be pretty concise now. \\n\\nOnly thing is that I have to use a list to store the remaining numbers, neither linkedlist nor arraylist are very efficient, anyone has a better idea?\\n\\nThe logic is as follows: for n numbers the permutations can be divided to (n-1)! groups, for n-1 numbers can be divided to (n-2)! groups, and so on. Thus k/(n-1)! indicates the index of current number, and k%(n-1)! denotes remaining index for the remaining n-1 numbers.\\nWe keep doing this until n reaches 0, then we get n numbers permutations that is kth. \\n\\n    public String getPermutation(int n, int k) {\\n            List<Integer> num = new LinkedList<Integer>();\\n            for (int i = 1; i <= n; i++) num.add(i);\\n            int[] fact = new int[n];  // factorial\\n            fact[0] = 1;\\n            for (int i = 1; i < n; i++) fact[i] = i*fact[i-1];\\n            k = k-1;\\n            StringBuilder sb = new StringBuilder();\\n            for (int i = n; i > 0; i--){\\n                int ind = k/fact[i-1];\\n                k = k%fact[i-1];\\n                sb.append(num.get(ind));\\n                num.remove(ind);\\n            }\\n            return sb.toString();\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Recursion will use more memory, while this problem can be solved by iteration. I solved this problem before, but I didn't realize that using k = k-1 would avoid dealing with case k%(n-1)!==0. Rewrote this code, should be pretty concise now. \\n\\nOnly thing is that I have to use a list to store the remaining numbers, neither linkedlist nor arraylist are very efficient, anyone has a better idea?\\n\\nThe logic is as follows: for n numbers the permutations can be divided to (n-1)! groups, for n-1 numbers can be divided to (n-2)! groups, and so on. Thus k/(n-1)! indicates the index of current number, and k%(n-1)! denotes remaining index for the remaining n-1 numbers.\\nWe keep doing this until n reaches 0, then we get n numbers permutations that is kth. \\n\\n    public String getPermutation(int n, int k) {\\n            List<Integer> num = new LinkedList<Integer>();\\n            for (int i = 1; i <= n; i++) num.add(i);\\n            int[] fact = new int[n];  // factorial\\n            fact[0] = 1;\\n            for (int i = 1; i < n; i++) fact[i] = i*fact[i-1];\\n            k = k-1;\\n            StringBuilder sb = new StringBuilder();\\n            for (int i = n; i > 0; i--){\\n                int ind = k/fact[i-1];\\n                k = k%fact[i-1];\\n                sb.append(num.get(ind));\\n                num.remove(ind);\\n            }\\n            return sb.toString();\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 22544,
                "title": "easy-understand-most-concise-c-solution-minimal-memory-required",
                "content": "This problem is recursive like dynamic programming.\\nKth Permutation sequence can be formed by choosing the 1st digit and then the rest of the digits one by one.\\nVisually:\\n1 + (permutations of rest of digits)\\n2 + (permutations of ...)\\nso on...\\n\\nFor N=3,\\nwe have the permutations:\\n1|2,3\\n1|3,2\\n2|1,3\\n2|3,1\\n3|1,2\\n3|2,1\\n\\nI put a bar \"|\" to separate first digit from the rest of digits.\\nThere are a total of N! = 3! = 6 perms.  Each 1st digit is \"attached\" to (n-1)! =2! = 2 permutations formed by rest of digits. \\nThus , to choose 1st digit, simply  calculate (k-1)  / (n-1)! and use it to index into an array of digits 1,2,3,\\nOnce 1st digit is chosen, we choose 2nd and so on recursively.\\n\\nWe remove 1st digit from the array of digits , so the remaining are the \"rest of digits\".\\nThere are 2 ways to remove: \\n1) pull the chosen digit from its current place to the right place in the permutation and shift rest of digits accordingly. (this is the in-place method chosen in my code so left part is partially formed permuation and right part is the candidates)\\n2) mark the chosen digit as \"used\" so you don\\'t use it again. (need an array of booleans to track)\\n\\nNotice the candidates   always remain sorted regardless of which digit is removed. This is an important property to solve the problem recursively. \\n\\n\\n\\n\\n\\n\\n\\n\\n\\tstring getPermutation(int n, int k) {\\n        int i,j,f=1;\\n        // left part of s is partially formed permutation, right part is the leftover chars.\\n        string s(n,\\'0\\');\\n        for(i=1;i<=n;i++){\\n            f*=i;\\n            s[i-1]+=i; // make s become 1234...n\\n        }\\n        for(i=0,k--;i<n;i++){\\n            f/=n-i;\\n            j=i+k/f; // calculate index of char to put at s[i]\\n            char c=s[j];\\n            // remove c by shifting to cover up (adjust the right part).\\n            for(;j>i;j--)\\n                s[j]=s[j-1];\\n            k%=f;\\n            s[i]=c;\\n        }\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "This problem is recursive like dynamic programming.\\nKth Permutation sequence can be formed by choosing the 1st digit and then the rest of the digits one by one.\\nVisually:\\n1 + (permutations of rest of digits)\\n2 + (permutations of ...)\\nso on...\\n\\nFor N=3,\\nwe have the permutations:\\n1|2,3\\n1|3,2\\n2|1,3\\n2|3,1\\n3|1,2\\n3|2,1\\n\\nI put a bar \"|\" to separate first digit from the rest of digits.\\nThere are a total of N! = 3! = 6 perms.  Each 1st digit is \"attached\" to (n-1)! =2! = 2 permutations formed by rest of digits. \\nThus , to choose 1st digit, simply  calculate (k-1)  / (n-1)! and use it to index into an array of digits 1,2,3,\\nOnce 1st digit is chosen, we choose 2nd and so on recursively.\\n\\nWe remove 1st digit from the array of digits , so the remaining are the \"rest of digits\".\\nThere are 2 ways to remove: \\n1) pull the chosen digit from its current place to the right place in the permutation and shift rest of digits accordingly. (this is the in-place method chosen in my code so left part is partially formed permuation and right part is the candidates)\\n2) mark the chosen digit as \"used\" so you don\\'t use it again. (need an array of booleans to track)\\n\\nNotice the candidates   always remain sorted regardless of which digit is removed. This is an important property to solve the problem recursively. \\n\\n\\n\\n\\n\\n\\n\\n\\n\\tstring getPermutation(int n, int k) {\\n        int i,j,f=1;\\n        // left part of s is partially formed permutation, right part is the leftover chars.\\n        string s(n,\\'0\\');\\n        for(i=1;i<=n;i++){\\n            f*=i;\\n            s[i-1]+=i; // make s become 1234...n\\n        }\\n        for(i=0,k--;i<n;i++){\\n            f/=n-i;\\n            j=i+k/f; // calculate index of char to put at s[i]\\n            char c=s[j];\\n            // remove c by shifting to cover up (adjust the right part).\\n            for(;j>i;j--)\\n                s[j]=s[j-1];\\n            k%=f;\\n            s[i]=c;\\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 22665,
                "title": "clean-java-solution",
                "content": "The basic idea is to decide which is the correct number starting from the highest digit.\\nUse k divide the factorial of (n-1), the result represents the ith not used number.\\nThen update k and the factorial to decide next digit.\\n\\n\\n public String getPermutation(int n, int k) {\\n\\n       LinkedList<Integer> notUsed = new LinkedList<Integer>();\\n\\n\\t\\tint weight = 1;\\n\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tnotUsed.add(i);\\n\\t\\t\\tif (i == n)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tweight = weight * i;\\n\\t\\t}\\n\\n\\t\\tString res = \"\";\\n\\t\\tk = k - 1;\\n\\t\\twhile (true) {\\n\\t\\t\\tres = res + notUsed.remove(k / weight);\\n\\t\\t\\tk = k % weight;\\n\\t\\t\\tif (notUsed.isEmpty())\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tweight = weight / notUsed.size();\\n\\t\\t}\\n\\n\\t\\treturn res;\\n    }",
                "solutionTags": [],
                "code": "The basic idea is to decide which is the correct number starting from the highest digit.\\nUse k divide the factorial of (n-1), the result represents the ith not used number.\\nThen update k and the factorial to decide next digit.\\n\\n\\n public String getPermutation(int n, int k) {\\n\\n       LinkedList<Integer> notUsed = new LinkedList<Integer>();\\n\\n\\t\\tint weight = 1;\\n\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tnotUsed.add(i);\\n\\t\\t\\tif (i == n)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tweight = weight * i;\\n\\t\\t}\\n\\n\\t\\tString res = \"\";\\n\\t\\tk = k - 1;\\n\\t\\twhile (true) {\\n\\t\\t\\tres = res + notUsed.remove(k / weight);\\n\\t\\t\\tk = k % weight;\\n\\t\\t\\tif (notUsed.isEmpty())\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tweight = weight / notUsed.size();\\n\\t\\t}\\n\\n\\t\\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 696910,
                "title": "c-100-time-space-efficient-iterative-solution-detailed-explanation-with-example",
                "content": "The approach is mathematical. The idea is to keep selecting a digit and eliminating it from further selection based on value of K. \\n\\nFor example:\\n\\n**Given, N = 4, K = 9**\\n\\nThere are 6 numbers starting with 1: 1234, 1243, 1324, 1342, 1423, 1432\\nThere are 6 numbers starting with 2: 2134, 2143, 2314, 2341, 2413, 2431\\nSimilarly, there are 6 numbers starting with 3 and 6 numbers starting with 4.\\n\\n**This is because when we have chosen one place out of 4 places (as N=4), there are 3 places remaining to be filled and those 3 places can be filled in 6 ways or (N-1)! ways.**\\n\\nSo, we have to keep identifying which digit to choose. \\n\\nInitially, we have to choose a digit from **{1,2,3,4}.**\\n\\nSince K = 9, meaning it belongs to second set of six numbers and hence, would begin with 2.\\n\\n**Now, first place is chosen as 2 and output string becomes \"2\". \\nThis means we have eliminated 6 choices starting with 1 (1234, 1243, 1324, 1342, 1423, 1432).**\\n\\nNow, K would be updated as **K = 9 - 6 = 3.**\\n\\nWe now have to identify remaining 3 places with the digits **{1,3,4}** and with **K = 3.**\\n\\nThere are 2 numbers starting with 1: 134, 143\\nThere are 2 numbers starting with 3: 314, 341\\nThere are 2 numbers starting with 4: 413, 431\\n\\nThis is because when we have chosen one place out of 3 available places, there are 2 places remaining to be filled and those 2 places can be filled in 2 ways.\\n\\n**Since, K = 3, meaning it belongs to second set of two numbers and hence, answer would be appended with \"3\" and output string becomes \"23\". \\nThis means we have eliminated 2 choices starting with 1 (134, 143).**\\n\\nNow, K would be updated as K = 3 - 2 = 1.\\n\\nWe now have to identify remaining 2 places with the digits **{1,4}** with **K = 1.**\\n\\nThere is 1 number starting with 1: 14\\nThere is 1 number starting with 4: 41\\n\\nThis is because when we have chosen one place out of 2 available places, there is only 1 place remaining to be filled and that 1 place can be only be filled in 1 ways.\\n\\n**Since, K = 1, meaning it belongs to first set of one number and hence, answer would be appended with \"14\" and output string becomes \"2314\".**\\n\\n**Therefore, final answer becomes \"2314\".**\\n\\nHope it helps! :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> fact;\\n    \\n    void findfact(int n)\\n    {\\n        fact = vector<int>(n);\\n        \\n        fact[0] = 1;\\n        \\n        if(n==1) return;\\n        \\n        fact[1] = 1;\\n        for(int i=2; i<n; i++)\\n            fact[i] = i*fact[i-1];\\n    }\\n    \\n    string getPermutation(int N, int K) {\\n        int n = N-1, k = K-1, nt, kt;\\n        \\n        findfact(N);\\n        vector<int> num(N);\\n        for(int i=0; i<N; i++)\\n            num[i] = i+1;\\n        vector<int>::iterator it; \\n        \\n        string ans = \"\";\\n        \\n        while(n>=0)\\n        {\\n            nt = k/fact[n];\\n            kt = k%fact[n];\\n\\n            ans += (num[nt]+\\'0\\');\\n            it = num.begin(); \\n            num.erase(it+nt);\\n            n--;\\n            k = kt;   \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fact;\\n    \\n    void findfact(int n)\\n    {\\n        fact = vector<int>(n);\\n        \\n        fact[0] = 1;\\n        \\n        if(n==1) return;\\n        \\n        fact[1] = 1;\\n        for(int i=2; i<n; i++)\\n            fact[i] = i*fact[i-1];\\n    }\\n    \\n    string getPermutation(int N, int K) {\\n        int n = N-1, k = K-1, nt, kt;\\n        \\n        findfact(N);\\n        vector<int> num(N);\\n        for(int i=0; i<N; i++)\\n            num[i] = i+1;\\n        vector<int>::iterator it; \\n        \\n        string ans = \"\";\\n        \\n        while(n>=0)\\n        {\\n            nt = k/fact[n];\\n            kt = k%fact[n];\\n\\n            ans += (num[nt]+\\'0\\');\\n            it = num.begin(); \\n            num.erase(it+nt);\\n            n--;\\n            k = kt;   \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502436,
                "title": "c-100-fastest-solution-best-approach-with-good-explanation-easy-to-understand-1",
                "content": "**Intution:-**\\n\\nSince this is permutaion we can assume that there are four positions that need to be filled using the four numbers of the sequence. First, we need to decide which number is to be placed at the first index. Once the number at the first index is decided we have three more positions and three more numers. Now the problem is shorter. We can repeat the technique that was used previously untl all the positions are filled.\\n\\n**On Paper Dry run:-**\\n\\n![image](https://assets.leetcode.com/users/images/0e4a79f7-809b-40b3-8f55-c89f81297d35_1661835688.8905008.jpeg)\\n\\n\\n**Approach**\\n\\n**STEP 1:**\\n\\nMathematically speaking there can be 4 variations while generating the permutation. We can have our permutation starting with either 1 or 2 or 3 or 4. If the first position is already occupied by one number there are three more positions left. The remaining three numbers can be permuted among themselves while filling the 3 positions and will generate 3! = 6 sequences. Hence each block will have 6 permutations adding up to a total of 6*4 = 24 permutations. If we consider the sequences as 0-based and in the sorted form we observe:- \\n\\n* The 0th \\u2013 5th permutation will start with 1 \\n* The 6th \\u2013 11th permutation will start with 2\\n* The 12th \\u2013 17th permutation will start with 3 \\n* The 18th \\u2013 23rd permutation will start with 4.\\n\\n\\t(For better understanding refer to the picture below.) \\n![image](https://lh5.googleusercontent.com/DgoKjAy6h0xfEl2LcWJ_aDg93Q0_gXEZkwVjH13b52VEkUtJXhrHjkav0GM5HJV8XyoRTsjN4CZrA8hCJt634hG-7vy6BP_xdpZ7HlPF_PAGCOXqNDPT0ikc_fOaQ90ktFZhPI9g)\\n\\nWe make K = 17-1 considering 0-based indexing. Since each of the four blocks illustrated above comprises 6 permutations, therefore, the 16th permutation will lie in (16 / 6 ) = 2nd block, and our answer is the (16 % 6) = 4th sequence from the 2nd block. Therefore 3 occupies the first position of the sequence and K = 4.\\n![image](https://lh4.googleusercontent.com/p62qRS1NYnrf8_DPQd3xg8mKTx-OZQ0otukMXtq7RF4xVr_xz4m569bOtFRTrh3QbTldIPMYi0Cco84dRdiH5nYxMppIYRib5drCzGc2fcXiTzrYEIyZLuDmzHjR1KhrYBt9P4_s)\\n\\n**STEP 2:**\\n\\nOur new search space comprises three elements {1,2,4} where K = 4 . Using the previous technique we can consider the second position to be occupied can be any one of these 3 numbers. Again one block can start with 1, another can start with 2 and the last one can start with 4 . Since one position is fixed, the remaining two numbers of each block can form 2! = 2  sequences. In sorted order :\\n\\n* The 0th \\u2013 1st sequence starts with 1 \\n* The 2nd \\u2013 3rd sequence starts with 2 \\n* The 4th \\u2013 5th sequence starts with 4\\n\\n![image](https://lh5.googleusercontent.com/nv-M9Ju-zoy_O7wtTb8jZZf8f5q4fdr9X987UspvacgJB4E-pVdm-3n4aT5M67KUsBp3LAFNbzNesnBFKz4f5dJoGGhuj51WpulR9dR8zPY821Uu1skTSQ7y4RCfJlfK4HDdD3p-)\\n\\nThe 4th permutation will lie in (4/2) = 2nd block and our answer is the 4%2 = 0th sequence from the 2nd block. Therefore 4 occupies the second position and K = 0.\\n\\n![image](https://lh4.googleusercontent.com/kLizY46WNhTvnZDI4mvG-U1JJ6k_cLVD8UbkczsXeUMKf-xA8CWP_3_8DB-i_YgwQ6gBnSn6HxGfYeym9F4Qf24t6ckMhCWTqsxeUS0ExmM5nP-P4f2Az609jOKui5Cq3mc9ApZg)\\n\\n**STEP 3:**\\n\\nThe new search space will have two elements {1 ,2} and K = 0. One block starts with 1 and the other block starts with 2. The other remaining number can form only one 1! = 1 sequence. In sorted form \\u2013\\n\\n* The  0th sequence starts with 1 \\n* The  1st sequence. starts with 2\\n\\n![image](https://lh4.googleusercontent.com/XSVzdDLZjo7kL5vSOEL6WYrmk7t1JqnzLCV67tYFbWBey5s0UiJ0nKFuL_sYYIqEpy2WE9x4ez-am_P4k-6ytuAEx7i1ZGmm2WtTROgS7QRa8HwxT48my-87VuhAq2VtbIs96448)\\n\\nThe 0th permutation will lie in the (0/1) = 0th block and our answer is the 0%1 = 0th sequence from the 0th block. Therefore 1 occupies the 3rd position and K = 0.\\n\\n![image](https://lh6.googleusercontent.com/ywkmQGIHcK0gpydKJ6PrNH1nTmnfFv7otGzzBTeWSOw9965Mq61wperoFrRi54fVoedVKFG5n2WG9fzbnzMQhGBOzniNsGZw87pnVyFsipAYeda7Rl6CTc2A-zmzpoIO7nWtOS3G)\\n\\n**STEP 4:** \\n\\nNow the only block has 2 in the first position and no remaining number is present.\\n![image](https://assets.leetcode.com/users/images/de57d8f1-b056-43f1-a511-7092eef574a3_1661822303.9951882.png)\\nThis is the point where we place 2 in the last position and stop.\\n![image](https://assets.leetcode.com/users/images/854d11a9-624b-492a-a9f7-0cc6ae5b1d99_1661822341.666998.png)\\n**The final answer is 3412.**\\n\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int> nums;\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        k=k-1;\\n        string ans=\"\";\\n        while(true){\\n            ans=ans+to_string(nums[k/fact]);\\n            nums.erase(nums.begin()+k/fact);\\n            if(nums.size()==0){\\n                break;\\n            }\\n            k=k%fact;\\n            fact=fact/nums.size();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Code Dry run:-**\\n![image](https://assets.leetcode.com/users/images/8e2c1e09-bb27-48df-8888-0912df17f2a2_1661835737.2826996.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int> nums;\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        k=k-1;\\n        string ans=\"\";\\n        while(true){\\n            ans=ans+to_string(nums[k/fact]);\\n            nums.erase(nums.begin()+k/fact);\\n            if(nums.size()==0){\\n                break;\\n            }\\n            k=k%fact;\\n            fact=fact/nums.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696390,
                "title": "python-math-solution-oneliner-both-o-n-2-expained",
                "content": "The simplest way to solve this problem is use backtracking, where you just generate all sequences, with complexity `O(k) = O(n!)`. We can do better. Let us consider an example: `n=6`, `k=314`. How we can find the first digit? There are `5! = 120` permutations, which start with `1`, there are also `120` permutations, which start with `2`, and so on. `314 > 2*120` and `314 < 3*120`, so it means, that the fist digit we need to take is `3`. So we build first digit of our number, remove it from list of all digits `digits` and continue:\\n\\n1. `k = 314-2*5! = 74`, `n - 1 = 5`, `d = 3`, build number so far `3`, `digits = [1,2,4,5,6]`\\n2. `k = 74-3*4! = 2`, `n - 1 = 4`, `d = 0`, build number so far `35`, `digits = [1,2,4,6]`\\n3. `k = 2-0*3! = 2`, `n - 1 = 3`, `d = 0`, build number so far `351`, `digits = [2,4,6]`\\n4. `k = 2-1*2! = 0`, `n - 1 = 2`, `d = 2`, build number so far `3512`, `digits = [4,6]`\\n5. `k = 0-1*1! = 0`, `n - 1 = 1`, `d = 2`, build number so far `35126`, `digits = [4]`\\n6. Finally, we have only one digit left, output is `351264`.\\n\\n**Complexity**. I keep list of `n` digits, and then delete them one by one. Complexity of one deletion is `O(n)`, so overall complexity is `O(n^2)`. Note, that it can be improved to `O(n log n)` if we use SortedList, but it just not worth it, `n` is too small.\\n\\n```\\nclass Solution:\\n    def getPermutation(self, n, k):\\n        numbers = list(range(1,n+1))\\n        answer = \"\"\\n        \\n        for n_it in range(n,0,-1):\\n            d = (k-1)//factorial(n_it-1)\\n            k -= d*factorial(n_it-1)\\n            answer += str(numbers[d])\\n            numbers.remove(numbers[d])\\n                   \\n        return answer\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**\\n\\n### Oneliner\\nHere it is, with `O(n^2)` complexity!\\n\\n```\\nreturn reduce(lambda s,n:(s[0]+s[2][(d:=s[1]//(f:=factorial(n)))],s[1]%f,s[2][:d]+s[2][d+1:]),range(n-1,-1,-1),(\\'\\',k-1,\\'123456789\\'))[0]\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n, k):\\n        numbers = list(range(1,n+1))\\n        answer = \"\"\\n        \\n        for n_it in range(n,0,-1):\\n            d = (k-1)//factorial(n_it-1)\\n            k -= d*factorial(n_it-1)\\n            answer += str(numbers[d])\\n            numbers.remove(numbers[d])\\n                   \\n        return answer\\n```\n```\\nreturn reduce(lambda s,n:(s[0]+s[2][(d:=s[1]//(f:=factorial(n)))],s[1]%f,s[2][:d]+s[2][d+1:]),range(n-1,-1,-1),(\\'\\',k-1,\\'123456789\\'))[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22524,
                "title": "sharing-my-straightforward-c-solution-with-explanation",
                "content": "    string getPermutation(int n, int k) {\\n        int pTable[10] = {1};\\n        for(int i = 1; i <= 9; i++){\\n            pTable[i] = i * pTable[i - 1];\\n        }\\n        string result;\\n        vector<char> numSet;\\n        numSet.push_back('1');\\n        numSet.push_back('2');\\n        numSet.push_back('3');\\n        numSet.push_back('4');\\n        numSet.push_back('5');\\n        numSet.push_back('6');\\n        numSet.push_back('7');\\n        numSet.push_back('8');\\n        numSet.push_back('9');\\n        while(n > 0){\\n            int temp = (k - 1) / pTable[n - 1];\\n            result += numSet[temp];\\n            numSet.erase(numSet.begin() + temp);\\n            k = k - temp * pTable[n - 1];\\n            n--;\\n        }\\n        return result;\\n    }\\n\\nIn this program, `pTable` refers to permutation table and `numSet` refers to a set of numbers from 1 to 9. Before while loop, we need to initialize `pTable` and `numSet`, which is trivial.\\n\\nIn while loop, we do these following things.\\n\\n1 calculate which number we will use.\\n\\n2 remove that number from `numSet`.\\n\\n3 recalculate k.\\n\\n4 `n--`. \\n\\nFinally, we return result.",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "    string getPermutation(int n, int k) {\\n        int pTable[10] = {1};\\n        for(int i = 1; i <= 9; i++){\\n            pTable[i] = i * pTable[i - 1];\\n        }\\n        string result;\\n        vector<char> numSet;\\n        numSet.push_back('1');\\n        numSet.push_back('2');\\n        numSet.push_back('3');\\n        numSet.push_back('4');\\n        numSet.push_back('5');\\n        numSet.push_back('6');\\n        numSet.push_back('7');\\n        numSet.push_back('8');\\n        numSet.push_back('9');\\n        while(n > 0){\\n            int temp = (k - 1) / pTable[n - 1];\\n            result += numSet[temp];\\n            numSet.erase(numSet.begin() + temp);\\n            k = k - temp * pTable[n - 1];\\n            n--;\\n        }\\n        return result;\\n    }\\n\\nIn this program, `pTable` refers to permutation table and `numSet` refers to a set of numbers from 1 to 9. Before while loop, we need to initialize `pTable` and `numSet`, which is trivial.\\n\\nIn while loop, we do these following things.\\n\\n1 calculate which number we will use.\\n\\n2 remove that number from `numSet`.\\n\\n3 recalculate k.\\n\\n4 `n--`. \\n\\nFinally, we return result.",
                "codeTag": "Unknown"
            },
            {
                "id": 22554,
                "title": "backtrack-summary-general-solution-for-10-questions-python-combination-sum-subsets-permutation-palindrome",
                "content": "For Java version, please refer to [isssac3's answer.](https://discuss.leetcode.com/topic/46162/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning)\\n\\n**39. Combination Sum**\\nhttps://leetcode.com/problems/combination-sum/\\n```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\\n\\n**40. Combination Sum II**\\nhttps://leetcode.com/problems/combination-sum-ii/\\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\\n\\n**78. Subsets**\\nhttps://leetcode.com/problems/subsets/\\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**90. Subsets II**\\nhttps://leetcode.com/problems/subsets-ii/\\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**46. Permutations**\\nhttps://leetcode.com/problems/permutations/\\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\\n\\n**47. Permutations II**\\nhttps://leetcode.com/problems/permutations-ii/\\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\\n\\n**60. Permutation Sequence**\\nhttps://leetcode.com/problems/permutation-sequence/\\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\\n\\n**131. Palindrome Partitioning**\\nhttps://leetcode.com/problems/palindrome-partitioning/\\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\\n\\n****\\n\\n\\n**267. Palindrome Permutation II**\\nhttps://leetcode.com/problems/palindrome-permutation-ii/\\nRelated to this two:\\n`31. Next Permutation`: https://leetcode.com/problems/next-permutation/\\n`266. Palindrome Permutation`: https://leetcode.com/problems/palindrome-permutation/\\n\\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 22650,
                "title": "0ms-c-12-line-concise-solution-no-recursion-no-helper-function",
                "content": "Attached please find my solution.\\n\\nIdea:\\n\\n- For an n-element permutation, there are (n-1)! permutations started with '1', (n-1)! permutations started with '2', and so forth. Therefore we can determine the value of the first element.\\n\\n- After determining the first element, there are (n-1) candidates left. Then there are (n-2)! permutations started with the minimum element within the remaining set, and so forth.\\n\\nComplexities:\\n\\n- Time complexity: O(n^2)   \\n\\n- Space complexity: O(n)\\n\\n==\\n\\n    class Solution {\\n    public:\\n        string getPermutation(int n, int k) {\\n            // initialize a dictionary that stores 1, 2, ..., n. This string will store the permutation.\\n            string dict(n, 0);\\n            iota(dict.begin(), dict.end(), '1');\\n            \\n            // build up a look-up table, which stores (n-1)!, (n-2)!, ..., 1!, 0!\\n            vector<int> fract(n, 1);\\n            for (int idx = n - 3; idx >= 0; --idx) {\\n                fract[idx] = fract[idx + 1] * (n - 1 - idx);\\n            }\\n            \\n            // let k be zero base\\n            --k;\\n            \\n            // the main part.\\n            string ret(n, 0);\\n            for (int idx = 0; idx < n; ++idx) {\\n                int select = k / fract[idx];\\n                k %= fract[idx];\\n                ret[idx] = dict[select];\\n                dict.erase(next(dict.begin(), select)); // note that it is an O(n) operation\\n            }\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string getPermutation(int n, int k) {\\n            // initialize a dictionary that stores 1, 2, ..., n. This string will store the permutation.\\n            string dict(n, 0);\\n            iota(dict.begin(), dict.end(), '1');\\n            \\n            // build up a look-up table, which stores (n-1)!, (n-2)!, ..., 1!, 0!\\n            vector<int> fract(n, 1);\\n            for (int idx = n - 3; idx >= 0; --idx) {\\n                fract[idx] = fract[idx + 1] * (n - 1 - idx);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 22546,
                "title": "simple-0s-c-solution",
                "content": "since n will be between 1 and 9 inclusive. pre-calculate the factorials is faster.\\n\\n    class Solution {\\n    public:\\n        string getPermutation(int n, int k) {\\n            string res;\\n            string nums = \"123456789\";\\n            int f[10] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};\\n            --k;\\n            for (int i = n; i >= 1; --i) {\\n                int j = k / f[i - 1];\\n                k %= f[i - 1];\\n                res.push_back(nums[j]);\\n                nums.erase(nums.begin() + j);\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string getPermutation(int n, int k) {\\n            string res;\\n            string nums = \"123456789\";\\n            int f[10] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880}",
                "codeTag": "Java"
            },
            {
                "id": 1305852,
                "title": "c-recursive-solution-maths-explained-0ms-faster-than-100",
                "content": "**Question is to find the Kth permutation of a given number.**\\n\\nNaive approach to solve this problem is to store all the possible permutations in an array and then simply return the kth one. This approach works perfectly fine but is having poor time complexity \\uD83D\\uDE11\\n\\nThe most optimised approach of this question (according me) is rather than traversing on each and every possible permutation, we should only go to the kth one !! Rather than making an array, recursive function should just return the perfect one i.e. the kth one. \\uD83D\\uDE42\\uD83D\\uDD25\\n\\nNow the question is, How can we do that ?? How can we reach directly to the kth permutation ? And the answer to this question is, by simply using a little bit of maths \\uD83D\\uDD22 .\\n\\n**MATHS EXPLANATION**\\n\\nWe know that number of permutations of a given number is simply calculated as n! where n is the number of digits of number n. To conclude, we can assure that number with n digits will have n! permutations and we can further say that it will have n groups of (n-1)! permutations.\\n\\nWe can simply see in this figure that we can make n groups of (n-1)! and we can check in which group kth permutation will lie.\\n\\n![image](https://assets.leetcode.com/users/images/463493a4-f198-4e4b-b890-2f99560aff07_1625003760.0458527.png)\\n\\nAfter finding the most suitable group for the kth permutation, we will then do the same for that group as well and in that case, there will be (n-1) groups for (n-2)! permutations.\\n\\nWe will keep doing the same recursively until we find the best result i.e kth permutation.\\n\\nHere is the code for the problem : \\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\t// this function is called to calculate possible number\\n\\t// of permutations for a given point through which, we will \\n\\t// calculate number of possible groups\\n\\t\\n    int fact(int num)\\n    {\\n        if(num==0)\\n            return 1 ;\\n        \\n        return num*fact(num-1);\\n    }\\n    \\n    string ans ;\\n    int count = 0 ;\\n    \\n    void permute(string str , int k, string finalAns)\\n    {\\n        \\n        if(str.length()==0)\\n        {\\n            ans = finalAns ;\\n            return ;\\n        }\\n        \\n        int number = str.length() - 1 ;\\n        int factNum = fact(number) ;\\n        \\n        for(int ctr = 0 ; ctr < str.length() ; ctr++ )\\n        {\\n            \\n            if( factNum < k )\\n            {\\n                k-=factNum;\\n                continue;\\n            }\\n            \\n            string sub = str.substr(0,ctr) + str.substr(ctr+1);\\n            permute(sub,k,finalAns+str[ctr]);\\n            break;\\n            \\n        }\\n        \\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        \\n        string str = \"\" ;\\n        \\n        for(int ctr = 1 ; ctr <=n ; ctr++ )            \\n            str+=to_string(ctr);\\n        \\n        permute(str,k,\"\");\\n        \\n        return ans ;\\n        \\n    }\\n};\\n```\\n\\nI am still not sure if this is the best solution even after 0ms and faster than 100 % . Do upvote if you liked my approach ! All the best ! Happy Learning.",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// this function is called to calculate possible number\\n\\t// of permutations for a given point through which, we will \\n\\t// calculate number of possible groups\\n\\t\\n    int fact(int num)\\n    {\\n        if(num==0)\\n            return 1 ;\\n        \\n        return num*fact(num-1);\\n    }\\n    \\n    string ans ;\\n    int count = 0 ;\\n    \\n    void permute(string str , int k, string finalAns)\\n    {\\n        \\n        if(str.length()==0)\\n        {\\n            ans = finalAns ;\\n            return ;\\n        }\\n        \\n        int number = str.length() - 1 ;\\n        int factNum = fact(number) ;\\n        \\n        for(int ctr = 0 ; ctr < str.length() ; ctr++ )\\n        {\\n            \\n            if( factNum < k )\\n            {\\n                k-=factNum;\\n                continue;\\n            }\\n            \\n            string sub = str.substr(0,ctr) + str.substr(ctr+1);\\n            permute(sub,k,finalAns+str[ctr]);\\n            break;\\n            \\n        }\\n        \\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        \\n        string str = \"\" ;\\n        \\n        for(int ctr = 1 ; ctr <=n ; ctr++ )            \\n            str+=to_string(ctr);\\n        \\n        permute(str,k,\"\");\\n        \\n        return ans ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257221,
                "title": "c-solution-with-comments-brute-force-and-optimal-easy-understanding",
                "content": "***Please Upvote if it helps you...***\\n![image](https://assets.leetcode.com/users/images/308215da-c176-4c85-9e1d-0200c754cf7f_1657345920.9695845.gif)\\n\\n***\\n***Solution 1: Brute Force Solution***\\n***\\n***\\n***Approach:***\\n***\\nThe extreme naive solution is to generate all the possible permutations of the given sequence.  This is achieved using recursion and every permutation generated is stored in some other data structure (here we have used a vector). Finally, we sort the data structure in which we have stored all the sequences and return the Kth sequence from it.\\n***\\n***\\n***C++ Code:-***\\n***\\n```\\nclass Solution {\\n  public:\\n    //function to generate all possible permutations of a string\\n    void solve(string & s, int index, vector < string > & res) {\\n      if (index == s.size()) {\\n        res.push_back(s);\\n        return;\\n      }\\n      for (int i = index; i < s.size(); i++) {\\n        swap(s[i], s[index]);\\n        solve(s, index + 1, res);\\n        swap(s[i], s[index]);\\n      }\\n    }\\nstring getPermutation(int n, int k) {\\n    string s;\\n    vector < string > res;\\n    //create string\\n    for (int i = 1; i <= n; i++) {\\n      s.push_back(i + \\'0\\');\\n    }\\n    solve(s, 0, res);\\n    //sort the generated permutations\\n    sort(res.begin(), res.end());\\n    //make k 0-based indexed to point to kth sequence\\n    auto it = res.begin() + (k - 1);\\n    return *it;\\n  }\\n};\\n```\\n***\\n***\\n***Time complexity: O(N!  N) +O(N! Log N!)***\\n\\n***Reason:***  The recursion takes O(N!)  time because we generate every possible permutation and another O(N)  time is required to make a deep copy and store every sequence in the data structure. Also, O(N! Log N!)  time required to sort the data structure\\n\\n***Space complexity: O(N)*** \\n\\n***Reason:*** Result stored in a vector, we are auxiliary space taken by recursion\\n***\\n***\\n***Solution 2:(Optimal Approach)***\\n\\nSay we have N = 4  and K = 17. Hence the number sequence is {1,2,3,4}. \\n***\\n***Intuition:***\\n\\nSince this is a permutation we can assume that there are four positions that need to be filled using the four numbers of the sequence. First, we need to decide which number is to be placed at the first index. Once the number at the first index is decided we have three more positions and three more numbers.  Now the problem is shorter. We can repeat the technique that was used previously until all the positions are filled. The technique is explained below.\\n***\\n***\\n***Approach:***\\n\\n***STEP 1:***\\n\\nMathematically speaking there can be 4 variations while generating the permutation. We can have our permutation starting with either 1 or 2 or 3 or 4. If the first position is already occupied by one number there are three more positions left. The remaining three numbers can be permuted among themselves while filling the 3 positions and will generate 3! = 6 sequences. Hence each block will have 6 permutations adding up to a total of 6*4 = 24 permutations. If we consider the sequences as 0-based and in the sorted form we observe:- \\n\\nThe 0th \\u2013 5th permutation will start with 1 \\nThe 6th \\u2013 11th permutation will start with 2\\nThe 12th \\u2013 17th permutation will start with 3 \\nThe 18th \\u2013 23rd permutation will start with 4.\\n\\n (For better understanding refer to the picture below.) \\n\\n![image](https://assets.leetcode.com/users/images/d01d09a0-37d2-4152-89ec-87dadd9ac1c1_1657345602.0382993.png)\\n\\n\\nWe make K = 17-1 considering 0-based indexing. Since each of the four blocks illustrated above comprises 6 permutations, therefore, the 16th permutation will lie in (16 / 6 ) = 2nd block, and our answer is the (16 % 6) = 4th sequence from the 2nd block. Therefore 3 occupies the first position of the sequence and K = 4.\\n\\n![image](https://assets.leetcode.com/users/images/ba557ff2-c1cb-45a3-99f9-26eee5183535_1657345592.8419704.png)\\n***\\n\\n***STEP 2:***\\n\\nOur new search space comprises three elements {1,2,4} where K = 4 . Using the previous technique we can consider the second position to be occupied can be any one of these 3 numbers. Again one block can start with 1, another can start with 2 and the last one can start with 4 . Since one position is fixed, the remaining two numbers of each block can form 2! = 2  sequences. In sorted order :\\n\\nThe 0th \\u2013 1st sequence starts with 1 \\nThe 2nd \\u2013 3rd sequence starts with 2 \\nThe 4th \\u2013 5th sequence starts with 4\\n![image](https://assets.leetcode.com/users/images/971c94d9-7368-4160-b681-9ae4fb1c2688_1657345583.4629538.png)\\n\\n\\nThe 4th permutation will lie in (4/2) = 2nd block and our answer is the 4%2 = 0th sequence from the 2nd block. Therefore 4 occupies the second position and K = 0.\\n\\n***\\n\\n***STEP 3:***\\n\\nThe new search space will have two elements {1 ,2} and K = 0. One block starts with 1 and the other block starts with 2. The other remaining number can form only one 1! = 1 sequence. In sorted form \\u2013\\n\\nThe  0th sequence starts with 1 \\nThe  1st sequence. starts with 2\\n![image](https://assets.leetcode.com/users/images/e75d4c48-36b5-4952-aebf-805e73a66da5_1657345575.3617208.png)\\n\\n\\nThe 0th permutation will lie in the (0/1) = 0th block and our answer is the 0%1 = 0th sequence from the 0th block. Therefore 1 occupies the 3rd position and K = 0.\\n***\\n\\n\\n***STEP 4:***\\n\\nNow the only block has 2 in the first position and no remaining number is present.\\n![image](https://assets.leetcode.com/users/images/0c53bf48-30eb-4f5a-9ca7-5a1995a0da9a_1657345567.3807125.png)\\n\\n\\nThis is the point where we place 2 in the last position and stop.\\n***\\n\\n***The final answer is 3412.***\\n***\\n***\\n\\nC++ Code:-\\n***\\n```\\nstring getPermutation(int n, int k) {\\n      int fact = 1;\\n      vector < int > numbers;\\n      for (int i = 1; i < n; i++) {\\n        fact = fact * i;\\n        numbers.push_back(i);\\n      }\\n      numbers.push_back(n);\\n      string ans = \"\";\\n      k = k - 1;\\n      while (true) {\\n        ans = ans + to_string(numbers[k / fact]);\\n        numbers.erase(numbers.begin() + k / fact);\\n        if (numbers.size() == 0) {\\n          break;\\n        }\\n\\n        k = k % fact;\\n        fact = fact / numbers.size();\\n      }\\n      return ans;\\n    }\\n```\\n***\\n***\\n***Time Complexity: O(N)  O(N) = O(N^2)***\\n\\n***Reason:*** We are placing N numbers in N positions. This will take O(N) time. For every number, we are reducing the search space by removing the element already placed in the previous step. This takes another O(N) time.\\n\\n***Space Complexity: O(N)***\\n\\n***Reason:*** We are storing  the numbers in a data structure(here vector)\\n***\\n***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    //function to generate all possible permutations of a string\\n    void solve(string & s, int index, vector < string > & res) {\\n      if (index == s.size()) {\\n        res.push_back(s);\\n        return;\\n      }\\n      for (int i = index; i < s.size(); i++) {\\n        swap(s[i], s[index]);\\n        solve(s, index + 1, res);\\n        swap(s[i], s[index]);\\n      }\\n    }\\nstring getPermutation(int n, int k) {\\n    string s;\\n    vector < string > res;\\n    //create string\\n    for (int i = 1; i <= n; i++) {\\n      s.push_back(i + \\'0\\');\\n    }\\n    solve(s, 0, res);\\n    //sort the generated permutations\\n    sort(res.begin(), res.end());\\n    //make k 0-based indexed to point to kth sequence\\n    auto it = res.begin() + (k - 1);\\n    return *it;\\n  }\\n};\\n```\n```\\nstring getPermutation(int n, int k) {\\n      int fact = 1;\\n      vector < int > numbers;\\n      for (int i = 1; i < n; i++) {\\n        fact = fact * i;\\n        numbers.push_back(i);\\n      }\\n      numbers.push_back(n);\\n      string ans = \"\";\\n      k = k - 1;\\n      while (true) {\\n        ans = ans + to_string(numbers[k / fact]);\\n        numbers.erase(numbers.begin() + k / fact);\\n        if (numbers.size() == 0) {\\n          break;\\n        }\\n\\n        k = k % fact;\\n        fact = fact / numbers.size();\\n      }\\n      return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22597,
                "title": "does-anyone-have-a-better-idea-share-my-accepted-python-code-here",
                "content": "It's obvious that if we try to come up with n! solutions one by one until it reach kth element - O(k), it will exceed the time limit. Therefore, I tried to implement a mathematical solution as follows:\\n\\n     class Solution:\\n        # @return a string\\n        def getPermutation(self, n, k):\\n    \\n            ll = [str(i) for i in range(1,n+1)] # build a list of [\"1\",\"2\",...\"n\"]\\n    \\n            divisor = 1\\n            for i in range(1,n): # calculate 1*2*3*...*(n-1)\\n                divisor *= i\\n    \\n            answer = \"\"\\n            while k>0 and k<=divisor*n:  # there are only (divisor*n) solutions in total \\n                group_num = k/divisor\\n                k %= divisor\\n    \\n                if k>0: # it's kth element of (group_num+1)th group\\n                    choose = ll.pop(group_num)\\n                    answer += choose\\n                else: # it's last element of (group_num)th group\\n                    choose = ll.pop(group_num-1) \\n                    answer += choose\\n                    ll.reverse() # reverse the list to get DESC order for the last element\\n                    to_add = \"\".join(ll)\\n                    answer += to_add\\n                    break\\n    \\n                divisor/=len(ll)\\n    \\n            return answer\\n     \\nBriefly take **(n,k) = (4,21)** for example, in the first iteration we divide the solution set into 4 groups: \"1xxx\", \"2xxx\", \"3xxx\", and \"4xxx\", while each group has 3! = 6 members. \\n\\nFrom 21/6 = 3...3, we know that the 21th element is the 3rd element in the (3+1)th group. In this group, we can divide it into 3 sub-groups again: \"41xx\", \"42xx\" and \"43xx\", and each group has 2!=2 members. \\n\\nThen, we calculate 3/2 and get 1...1, so it's the 1st element of (1+1)nd sub-group - \"421x\", and now it reach the base case with only one possibility - **\"4213\"**.\\n\\nAnyone pass the problem with different ideas?",
                "solutionTags": [
                    "Python",
                    "Probability and Statistics"
                ],
                "code": "It's obvious that if we try to come up with n! solutions one by one until it reach kth element - O(k), it will exceed the time limit. Therefore, I tried to implement a mathematical solution as follows:\\n\\n     class Solution:\\n        # @return a string\\n        def getPermutation(self, n, k):\\n    \\n            ll = [str(i) for i in range(1,n+1)] # build a list of [\"1\",\"2\",...\"n\"]\\n    \\n            divisor = 1\\n            for i in range(1,n): # calculate 1*2*3*...*(n-1)\\n                divisor *= i\\n    \\n            answer = \"\"\\n            while k>0 and k<=divisor*n:  # there are only (divisor*n) solutions in total \\n                group_num = k/divisor\\n                k %= divisor\\n    \\n                if k>0: # it's kth element of (group_num+1)th group\\n                    choose = ll.pop(group_num)\\n                    answer += choose\\n                else: # it's last element of (group_num)th group\\n                    choose = ll.pop(group_num-1) \\n                    answer += choose\\n                    ll.reverse() # reverse the list to get DESC order for the last element\\n                    to_add = \"\".join(ll)\\n                    answer += to_add\\n                    break\\n    \\n                divisor/=len(ll)\\n    \\n            return answer\\n     \\nBriefly take **(n,k) = (4,21)** for example, in the first iteration we divide the solution set into 4 groups: \"1xxx\", \"2xxx\", \"3xxx\", and \"4xxx\", while each group has 3! = 6 members. \\n\\nFrom 21/6 = 3...3, we know that the 21th element is the 3rd element in the (3+1)th group. In this group, we can divide it into 3 sub-groups again: \"41xx\", \"42xx\" and \"43xx\", and each group has 2!=2 members. \\n\\nThen, we calculate 3/2 and get 1...1, so it's the 1st element of (1+1)nd sub-group - \"421x\", and now it reach the base case with only one possibility - **\"4213\"**.\\n\\nAnyone pass the problem with different ideas?",
                "codeTag": "Java"
            },
            {
                "id": 2992652,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> v={0};\\n        int tmp=1;\\n        for(int i=1;i<=n;i++){\\n            v.push_back(i);\\n            tmp*=i;\\n        }\\n        string s;\\n        cout<<tmp<<\" \";\\n        for(int i=n;i>=2;i--){\\n            tmp/=i;\\n            int fl=(k+tmp-1)/tmp;\\n            s.push_back(v[fl]+\\'0\\');\\n            k-=(fl-1)*tmp;\\n            for(int j=fl;j<v.size()-1;j++){\\n                v[j]=v[j+1];\\n            }\\n        }\\n        s.push_back(v[1]+\\'0\\');   \\n        return s;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        nums = [i for i in range(1, n+1)] # list of numbers from 1 to n\\n        factorial = [1] * n\\n        for i in range(1, n):\\n            factorial[i] = factorial[i-1] * i\\n        \\n        k -= 1\\n        result = []\\n        for i in range(n-1, -1, -1):\\n            index = k // factorial[i]\\n            result.append(str(nums[index]))\\n            nums.pop(index)\\n            k = k % factorial[i]\\n        \\n        return \\'\\'.join(result)\\n```\\n\\n```Java []\\nclass Solution {\\n    private static int[] fact = {0, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};\\n    \\n    private String getPermutation(int n, int k, boolean[] nums, char[] str, int index) {\\n        int i = 0, m = nums.length;\\n        if(n == 1) {\\n            while(i < m && nums[i]) ++i;\\n            str[index++]=(char)(\\'0\\'+i+1);\\n            return String.valueOf(str);\\n        }\\n        if(k == 0) {\\n            while(i < m) {\\n                if(!nums[i]) str[index++]=(char)(\\'0\\'+i+1);\\n                ++i;\\n            }\\n            return String.valueOf(str);\\n        }\\n        \\n        int div = k/fact[n-1], mod = k%fact[n-1], j = -1;\\n        while(i < m-1 && div != j) {\\n            if(!nums[i]) ++j;\\n            if(j == div) break;\\n            ++i;\\n        }\\n        str[index++]=(char)(\\'0\\'+i+1);\\n        if(i < m) nums[i]=true;\\n        return getPermutation(n-1, mod, nums, str, index); \\n    }\\n\\n    public String getPermutation(int n, int k) {\\n        boolean[] nums = new boolean[n];\\n        char[] charArr = new char[n];\\n        return getPermutation(n, k-1, nums, charArr, 0);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> v={0};\\n        int tmp=1;\\n        for(int i=1;i<=n;i++){\\n            v.push_back(i);\\n            tmp*=i;\\n        }\\n        string s;\\n        cout<<tmp<<\" \";\\n        for(int i=n;i>=2;i--){\\n            tmp/=i;\\n            int fl=(k+tmp-1)/tmp;\\n            s.push_back(v[fl]+\\'0\\');\\n            k-=(fl-1)*tmp;\\n            for(int j=fl;j<v.size()-1;j++){\\n                v[j]=v[j+1];\\n            }\\n        }\\n        s.push_back(v[1]+\\'0\\');   \\n        return s;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        nums = [i for i in range(1, n+1)] # list of numbers from 1 to n\\n        factorial = [1] * n\\n        for i in range(1, n):\\n            factorial[i] = factorial[i-1] * i\\n        \\n        k -= 1\\n        result = []\\n        for i in range(n-1, -1, -1):\\n            index = k // factorial[i]\\n            result.append(str(nums[index]))\\n            nums.pop(index)\\n            k = k % factorial[i]\\n        \\n        return \\'\\'.join(result)\\n```\n```Java []\\nclass Solution {\\n    private static int[] fact = {0, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};\\n    \\n    private String getPermutation(int n, int k, boolean[] nums, char[] str, int index) {\\n        int i = 0, m = nums.length;\\n        if(n == 1) {\\n            while(i < m && nums[i]) ++i;\\n            str[index++]=(char)(\\'0\\'+i+1);\\n            return String.valueOf(str);\\n        }\\n        if(k == 0) {\\n            while(i < m) {\\n                if(!nums[i]) str[index++]=(char)(\\'0\\'+i+1);\\n                ++i;\\n            }\\n            return String.valueOf(str);\\n        }\\n        \\n        int div = k/fact[n-1], mod = k%fact[n-1], j = -1;\\n        while(i < m-1 && div != j) {\\n            if(!nums[i]) ++j;\\n            if(j == div) break;\\n            ++i;\\n        }\\n        str[index++]=(char)(\\'0\\'+i+1);\\n        if(i < m) nums[i]=true;\\n        return getPermutation(n-1, mod, nums, str, index); \\n    }\\n\\n    public String getPermutation(int n, int k) {\\n        boolean[] nums = new boolean[n];\\n        char[] charArr = new char[n];\\n        return getPermutation(n, k-1, nums, charArr, 0);\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2777028,
                "title": "permutation-sequence-java-solution-1-bruteforce-approach-2-optimal-approach",
                "content": "```\\n1. First Approach\\n//generate all permutation for 1 to n\\n//store all permutation in some data structure\\n//return kth term from data structure\\n\\n//Example :- n=3 , k=4\\n//Generate permutations(LeetCode Qus. 46 :- Permutations) 1 to 3 i.e. \\n123\\n132\\n213\\n231\\n312\\n321\\n//k=4th term is 231\\n//our ans will be 231\\n\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int num[] = new int[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            num[i] = i+1;\\n        }\\n        List<String> Tans = new ArrayList<>();\\n        help(0,num,n,k,Tans);\\n        Collections.sort(Tans);\\n        return Tans.get(k-1);\\n    }\\n    void help(int index, int[] num, int n, int k, List<String> Tans)\\n    {\\n        \\n        if(index==num.length){\\n            StringBuffer store = new StringBuffer();\\n            for(int i=0; i<n; i++)\\n            {\\n                store.append(num[i]);\\n            }\\n            Tans.add(store.toString());\\n            return;\\n        }\\n        \\n        for(int i=index; i<n; i++)\\n        {\\n            swap(i,index,num);\\n            help(index+1,num,n,k,Tans);\\n            swap(i,index,num);\\n        }\\n    }\\n    void swap(int i, int j, int[] num)\\n    {\\n        int temp = num[i];\\n        num[i] = num[j];\\n        num[j] = temp;\\n    }\\n //T.C :- n!(for generating permutation) * n(for looping i=0 to nums.length) * n!logn(for sorting n! permutation)\\n}\\n\\n2. Optimal Approach :- using Mathematics\\n//Example :- n=4 ,k=17\\n                                 /////////STEP 1\\n//We can have our permutation starting with either 1 or 2 or 3 or 4.\\n//If first position is occupied by one number then there are three more positions left.\\n//Then remaining three numbers can be permuted among themselves 3! = 6 sequences.\\n\\n//if we consider sequences as 0-based index in sorted form              \\n0th block  |0th \\u2013 5th permutation will start with 1   | {2,3,4} i.e. 0th{1,2,3,4}, 1st{1,2,4,3}, 2nd{1,3,2,4}, 3rd{1,3,4,2}, 4th{1,4,2,3}, 5th{1,4,3,2}\\n1st block  |6th \\u2013 11th permutation will start with 2  | {1,3,4} i.e. 6th{2,1,3,4}, 7th{2,1,4,3}, 8th{2,3,1,4}, 9th{2,3,4,1}, 10th{2,4,1,3}, 11th{2,4,3,1}\\n2nd block  |12th \\u2013 17th permutation will start with 3 | {1,2,4} i.e. 12th{3,1,2,4}, 13th{3,1,4,2}, 14th{3,2,1,4}, 15th{3,2,4,1}, 16th{3,4,1,2}, 17th{3,4,2,1}\\n3rd block  |18th \\u2013 23rd permutation will start with 4 | {1,2,3} i.e. 18th{4,1,2,3}, 19th{4,1,3,2}, 20th{4,2,1,3}, 21st{4,2,3,1}, 22nd{4,3,1,2}, 23rd{4,3,2,1}\\n\\n//make K = 17-1 considering 0-based indexing\\n//Since each of the four blocks illustrated above comprises 6 permutations, therefore the 16th permutation will lie in (16 / 6 ) = 2nd block i.e. 3 ans={3---}\\n/and our answer is the (16 % 6) = 4th sequence from the 2nd block.\\n    \\n                                  //////////STEP 2\\n  //Our new search space comprises three elements {1,2,4} where K = 4 \\n  //If first position is occupied by one number then there are two more positions left.\\n  //Then remaining two numbers can be permuted among themselves 2! = 2 sequences.\\n\\n0th block  |0th \\u2013 1st sequence starts with 1 | {2,4} \\n1st block  |2nd \\u2013 3rd sequence starts with 2 | {1,4}\\n2nd block  |4th \\u2013 5th sequence starts with 4 | {1,2}\\n\\n//(4/2) = 2nd block i.e 4   ans={34--}\\n//4%2 = 0th sequence from 2nd block\\n\\n                                     /////////STEP 3\\n        //Our new search space comprises three elements {1,2} where K = 0\\n        //If first position is occupied by one number then there are one more positions left.\\n        //Then remaining one numbers can be permuted among themselves 1! = 1 sequences.\\n0th block |0th sequence starts with 1  | {2} \\n1st block |1st sequence. starts with 2 | {1}\\n\\n//(0/1) = 0th block i.e. ans={341}\\n//0%1 = 0th sequence from 0th block\\n\\n                                   /////////STEP 4\\n//only 2 is remaining \\nans = {3412}\\n\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        ArrayList < Integer > numbers = new ArrayList < > ();\\n        for (int i = 1; i < n; i++) {\\n            fact = fact * i;\\n            numbers.add(i);\\n        }\\n        numbers.add(n);\\n        String ans = \"\";\\n        k = k - 1;\\n        while (true) {\\n            ans = ans + numbers.get(k / fact);\\n            numbers.remove(k / fact);\\n            if (numbers.size() == 0) {\\n                break;\\n            }\\n\\n            k = k % fact;\\n            fact = fact / numbers.size();\\n        }\\n        return ans;\\n    }\\n}\\nT.C:- n(for placing n numbers in n positions) * n(for every number we are reducingthe search space by removing one element, 1234-->124-->12-->1)\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n1. First Approach\\n//generate all permutation for 1 to n\\n//store all permutation in some data structure\\n//return kth term from data structure\\n\\n//Example :- n=3 , k=4\\n//Generate permutations(LeetCode Qus. 46 :- Permutations) 1 to 3 i.e. \\n123\\n132\\n213\\n231\\n312\\n321\\n//k=4th term is 231\\n//our ans will be 231\\n\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int num[] = new int[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            num[i] = i+1;\\n        }\\n        List<String> Tans = new ArrayList<>();\\n        help(0,num,n,k,Tans);\\n        Collections.sort(Tans);\\n        return Tans.get(k-1);\\n    }\\n    void help(int index, int[] num, int n, int k, List<String> Tans)\\n    {\\n        \\n        if(index==num.length){\\n            StringBuffer store = new StringBuffer();\\n            for(int i=0; i<n; i++)\\n            {\\n                store.append(num[i]);\\n            }\\n            Tans.add(store.toString());\\n            return;\\n        }\\n        \\n        for(int i=index; i<n; i++)\\n        {\\n            swap(i,index,num);\\n            help(index+1,num,n,k,Tans);\\n            swap(i,index,num);\\n        }\\n    }\\n    void swap(int i, int j, int[] num)\\n    {\\n        int temp = num[i];\\n        num[i] = num[j];\\n        num[j] = temp;\\n    }\\n //T.C :- n!(for generating permutation) * n(for looping i=0 to nums.length) * n!logn(for sorting n! permutation)\\n}\\n\\n2. Optimal Approach :- using Mathematics\\n//Example :- n=4 ,k=17\\n                                 /////////STEP 1\\n//We can have our permutation starting with either 1 or 2 or 3 or 4.\\n//If first position is occupied by one number then there are three more positions left.\\n//Then remaining three numbers can be permuted among themselves 3! = 6 sequences.\\n\\n//if we consider sequences as 0-based index in sorted form              \\n0th block  |0th \\u2013 5th permutation will start with 1   | {2,3,4} i.e. 0th{1,2,3,4}, 1st{1,2,4,3}, 2nd{1,3,2,4}, 3rd{1,3,4,2}, 4th{1,4,2,3}, 5th{1,4,3,2}\\n1st block  |6th \\u2013 11th permutation will start with 2  | {1,3,4} i.e. 6th{2,1,3,4}, 7th{2,1,4,3}, 8th{2,3,1,4}, 9th{2,3,4,1}, 10th{2,4,1,3}, 11th{2,4,3,1}\\n2nd block  |12th \\u2013 17th permutation will start with 3 | {1,2,4} i.e. 12th{3,1,2,4}, 13th{3,1,4,2}, 14th{3,2,1,4}, 15th{3,2,4,1}, 16th{3,4,1,2}, 17th{3,4,2,1}\\n3rd block  |18th \\u2013 23rd permutation will start with 4 | {1,2,3} i.e. 18th{4,1,2,3}, 19th{4,1,3,2}, 20th{4,2,1,3}, 21st{4,2,3,1}, 22nd{4,3,1,2}, 23rd{4,3,2,1}\\n\\n//make K = 17-1 considering 0-based indexing\\n//Since each of the four blocks illustrated above comprises 6 permutations, therefore the 16th permutation will lie in (16 / 6 ) = 2nd block i.e. 3 ans={3---}\\n/and our answer is the (16 % 6) = 4th sequence from the 2nd block.\\n    \\n                                  //////////STEP 2\\n  //Our new search space comprises three elements {1,2,4} where K = 4 \\n  //If first position is occupied by one number then there are two more positions left.\\n  //Then remaining two numbers can be permuted among themselves 2! = 2 sequences.\\n\\n0th block  |0th \\u2013 1st sequence starts with 1 | {2,4} \\n1st block  |2nd \\u2013 3rd sequence starts with 2 | {1,4}\\n2nd block  |4th \\u2013 5th sequence starts with 4 | {1,2}\\n\\n//(4/2) = 2nd block i.e 4   ans={34--}\\n//4%2 = 0th sequence from 2nd block\\n\\n                                     /////////STEP 3\\n        //Our new search space comprises three elements {1,2} where K = 0\\n        //If first position is occupied by one number then there are one more positions left.\\n        //Then remaining one numbers can be permuted among themselves 1! = 1 sequences.\\n0th block |0th sequence starts with 1  | {2} \\n1st block |1st sequence. starts with 2 | {1}\\n\\n//(0/1) = 0th block i.e. ans={341}\\n//0%1 = 0th sequence from 0th block\\n\\n                                   /////////STEP 4\\n//only 2 is remaining \\nans = {3412}\\n\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        ArrayList < Integer > numbers = new ArrayList < > ();\\n        for (int i = 1; i < n; i++) {\\n            fact = fact * i;\\n            numbers.add(i);\\n        }\\n        numbers.add(n);\\n        String ans = \"\";\\n        k = k - 1;\\n        while (true) {\\n            ans = ans + numbers.get(k / fact);\\n            numbers.remove(k / fact);\\n            if (numbers.size() == 0) {\\n                break;\\n            }\\n\\n            k = k % fact;\\n            fact = fact / numbers.size();\\n        }\\n        return ans;\\n    }\\n}\\nT.C:- n(for placing n numbers in n positions) * n(for every number we are reducingthe search space by removing one element, 1234-->124-->12-->1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557729,
                "title": "java-solution-with-complete-explanation",
                "content": "\\n**Solution 1: Brute Force Solution**\\n\\n**Approach:**  \\n\\nThe extreme naive solution is to generate all the possible permutations of the given sequence.  This is achieved using recursion and every permutation generated is stored in some other data structure (here we have used a vector). Finally, we sort the data structure in which we have stored all the sequences and return the Kth sequence from it.\\n\\n```\\nimport java.util.*;\\npublic class Main {\\n    static void swap(char s[], int i, int j) {\\n        char ch = s[i];\\n        s[i] = s[j];\\n        s[j] = ch;\\n    }\\n    static void permutationHelper(char s[], int index, ArrayList < String > res) {\\n        if (index == s.length) {\\n            String str = new String(s);\\n\\n            res.add(str);\\n            return;\\n        }\\n        for (int i = index; i < s.length; i++) {\\n            swap(s, i, index);\\n            permutationHelper(s, index + 1, res);\\n            swap(s, i, index);\\n        }\\n    }\\n\\n    static String getPermutation(int n, int k) {\\n        String s = \"\";\\n        ArrayList < String > res = new ArrayList < > ();\\n        for (int i = 1; i <= n; i++) {\\n            s += i;\\n        }\\n        permutationHelper(s.toCharArray(), 0, res);\\n        Collections.sort(res);\\n\\n        return res.get(k);\\n\\n    }\\n    public static void main(String args[]) {\\n        int n = 3, k = 3;\\n        String ans = getPermutation(n, k);\\n        System.out.println(\"The Kth permutation sequence is \" + ans);\\n    }\\n}\\n```\\n\\n**Output:**\\n\\nThe Kth permutation sequence is 213\\n\\n**Time complexity: O(N! * N) +O(N! Log N!)**\\n\\n**Reason**:  The recursion takes O(N!)  time because we generate every possible permutation and another O(N)  time is required to make a deep copy and store every sequence in the data structure. Also, O(N! Log N!)  time required to sort the data structure\\n\\n**Space complexity: O(N) **\\n\\n*Reason: Result stored in a vector, we are auxiliary space taken by recursion*\\n\\n**Solution 2: (Optimal Approach)**\\n\\nSay we have N = 4  and K = 17. Hence the number sequence is {1,2,3,4}. \\n\\n**Intuition -**\\n\\nI am following 0 - indexing so if K = 17, i.e., the answer is 16th permutation.\\nStore n numbers in a list -> [1, 2, 3, 4]\\nSince this is a permutation we can assume that there are four positions that need to be filled using the four numbers of the sequence. \\nFirst, we need to decide which number is to be placed at the first index. Once the number at the first index is decided we have three more positions and three more numbers.  Now the problem is shorter\\nWe can repeat the technique that was used previously until all the positions are filled.\\n\\n**Approach:** \\n\\n**STEP 1**:\\n\\nMathematically speaking there can be 4 variations while generating the permutation. We can have our permutation starting with either 1 or 2 or 3 or 4. If the first position is already occupied by one number there are three more positions left. The remaining three numbers can be permuted among themselves while filling the 3 positions and will generate 3! = 6 sequences. Hence each block will have 6 permutations adding up to a total of 6*4 = 24 permutations. If we consider the sequences as 0-based and in the sorted form we observe:- \\n\\nThe 0th \\u2013 5th permutation will start with 1 \\nThe 6th \\u2013 11th permutation will start with 2\\nThe 12th \\u2013 17th permutation will start with 3 \\nThe 18th \\u2013 23rd permutation will start with 4.\\n (For better understanding refer to the picture below.) \\n\\n![image](https://assets.leetcode.com/users/images/35d54383-2d3f-42a6-82bf-f38511ab8c31_1662819193.3723998.png)\\n\\n\\nWe make K = 17-1 considering 0-based indexing. Since each of the four blocks illustrated above comprises 6 permutations, therefore, the 16th permutation will lie in (16 / 6 ) = 2nd block, and our answer is the (16 % 6) = 4th sequence from the 2nd block. Therefore 3 occupies the first position of the sequence and K = 4.\\n\\n\\n\\n**STEP 2:**\\n\\nOur new search space comprises three elements {1,2,4} where K = 4 . Using the previous technique we can consider the second position to be occupied can be any one of these 3 numbers. Again one block can start with 1, another can start with 2 and the last one can start with 4 . Since one position is fixed, the remaining two numbers of each block can form 2! = 2  sequences. In sorted order :\\n\\nThe 0th \\u2013 1st sequence starts with 1 \\nThe 2nd \\u2013 3rd sequence starts with 2 \\nThe 4th \\u2013 5th sequence starts with 4\\n[![image](https://assets.leetcode.com/users/images/7f02a0f1-1adc-48ba-ac37-364bdc169b25_1662819176.872596.png)\\n](http://)\\n\\nThe 4th permutation will lie in (4/2) = 2nd block and our answer is the 4%2 = 0th sequence from the 2nd block. Therefore 4 occupies the second position and K = 0.\\n\\n\\n\\n**STEP 3:**\\n\\nThe new search space will have two elements {1 ,2} and K = 0. One block starts with 1 and the other block starts with 2. The other remaining number can form only one 1! = 1 sequence. In sorted form \\u2013\\n\\nThe  0th sequence starts with 1 \\nThe  1st sequence. starts with 2\\n\\n\\nThe 0th permutation will lie in the (0/1) = 0th block and our answer is the 0%1 = 0th sequence from the 0th block. Therefore 1 occupies the 3rd position and K = 0.\\n[![image](https://assets.leetcode.com/users/images/3fb9e3ce-cae1-43b7-9280-4ae73933cdaa_1662819149.794847.png)\\n](http://)\\n\\n\\n**STEP 4**: \\n\\nNow the only block has 2 in the first position and no remaining number is present.\\n\\n[![image](https://assets.leetcode.com/users/images/735de33d-78fc-4ec9-86ac-d19b026cffa5_1662819077.3672447.png)\\n](http://)\\nThis is the point where we place 2 in the last position and stop.\\n\\n\\nThe final answer is \"3412\".\\n\\n**Code-**\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n\\t    k = k - 1; // following 0 indexing if k = 3 it means 2nd permutation is the ans\\n        String ans = \"\";\\n        // create a list to store all the numbers till n\\n        List<Integer> list = new ArrayList<>();\\n        int fact = 1; \\n        for(int i = 1; i <= n-1; i++) {\\n            fact = fact * i;\\n            list.add(i);  // this will store numbers from 1 to n-1\\n        }\\n        list.add(n); // add n to list\\n       // running an infinte loop\\n        while (true) {\\n            ans = ans + list.get (k / fact);\\n            list.remove (k / fact);\\n            if (list.size() == 0) {\\n                break;\\n            }\\n            k = k % fact;\\n            fact = fact / list.size();\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Time Complexity: O(N) * O(N) = O(N^2)**\\n\\nReason: We are placing N numbers in N positions. This will take O(N) time. For every number, we are reducing the search space by removing the element already placed in the previous step. This takes another O(N) time.\\n\\n**Space Complexity: O(N) **\\n\\nReason: We are storing  the numbers in a data structure(here vector)\\n\\n**Do Upvote :)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\npublic class Main {\\n    static void swap(char s[], int i, int j) {\\n        char ch = s[i];\\n        s[i] = s[j];\\n        s[j] = ch;\\n    }\\n    static void permutationHelper(char s[], int index, ArrayList < String > res) {\\n        if (index == s.length) {\\n            String str = new String(s);\\n\\n            res.add(str);\\n            return;\\n        }\\n        for (int i = index; i < s.length; i++) {\\n            swap(s, i, index);\\n            permutationHelper(s, index + 1, res);\\n            swap(s, i, index);\\n        }\\n    }\\n\\n    static String getPermutation(int n, int k) {\\n        String s = \"\";\\n        ArrayList < String > res = new ArrayList < > ();\\n        for (int i = 1; i <= n; i++) {\\n            s += i;\\n        }\\n        permutationHelper(s.toCharArray(), 0, res);\\n        Collections.sort(res);\\n\\n        return res.get(k);\\n\\n    }\\n    public static void main(String args[]) {\\n        int n = 3, k = 3;\\n        String ans = getPermutation(n, k);\\n        System.out.println(\"The Kth permutation sequence is \" + ans);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n\\t    k = k - 1; // following 0 indexing if k = 3 it means 2nd permutation is the ans\\n        String ans = \"\";\\n        // create a list to store all the numbers till n\\n        List<Integer> list = new ArrayList<>();\\n        int fact = 1; \\n        for(int i = 1; i <= n-1; i++) {\\n            fact = fact * i;\\n            list.add(i);  // this will store numbers from 1 to n-1\\n        }\\n        list.add(n); // add n to list\\n       // running an infinte loop\\n        while (true) {\\n            ans = ans + list.get (k / fact);\\n            list.remove (k / fact);\\n            if (list.size() == 0) {\\n                break;\\n            }\\n            k = k % fact;\\n            fact = fact / list.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191348,
                "title": "c-0ms-100-with-algorithm-explanation",
                "content": "as we know \n    4! = 24 = 4*(3!) \nthat means the first layer looks like\n   '1'[][][],'2'[][][],'3'[][][],'4'[][][]\n then we can search which position number 9 will be at this layer:\n    position = 9/3! = 1.5 \n and we know  the first number position will be [1.5] = 2, which represent '2'[][][],we know the first number is '2'\n    the remainder is 9%3! = 3\n then we use this number enter next layer:\n    '1'[][],'3'[][],'4'[][]\n     position = 3/2! = 1.5\n     [1.5] = 2 which represent '3'[][], we know the second number is '3'\n......\n    repeat until we get remainder 0, that means we need to take Maximum arrangement in this layer.\nso reverse and append to result.\nsorry my english is pool\n![image](https://assets.leetcode.com/users/somone23412/image_1541753944.png)\n```\nclass Solution {\npublic:\n    string getPermutation(int n, int k) {\n        int d = n-1;\n        int t = k;\n        list<char> nums;\n        string result = \"\";\n        for(int i = 1; i <= n; i++){\n            nums.push_back(i+48);\n        }\n        while(t!=0){\n            int jd = jiecheng(d);\n            int position = ceil((double)t/jd);\n            auto it = nums.begin();\n            for(int i = 0; i< position-1 && it != nums.end(); i++, it++);\n            result += *it;\n            nums.remove(*it);\n            //cout<<t<<\" \"<<jd<<\" \"<<position<<\" \"<<t<<endl;\n            t = t%jd; \n            d--;\n        }\n        nums.reverse();\n        for(auto it = nums.begin(); it != nums.end(); it++){\n            result += *it;\n        }\n        return result;\n    }\n    int jiecheng(int n){\n        if(n == 0)return 1;\n        int sum = n;\n        while(--n > 0) sum*=n;\n        return sum;\n    }\n};\n```\n",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    string getPermutation(int n, int k) {\n        int d = n-1;\n        int t = k;\n        list<char> nums;\n        string result = \"\";\n        for(int i = 1; i <= n; i++){\n            nums.push_back(i+48);\n        }\n        while(t!=0){\n            int jd = jiecheng(d);\n            int position = ceil((double)t/jd);\n            auto it = nums.begin();\n            for(int i = 0; i< position-1 && it != nums.end(); i++, it++);\n            result += *it;\n            nums.remove(*it);\n            //cout<<t<<\" \"<<jd<<\" \"<<position<<\" \"<<t<<endl;\n            t = t%jd; \n            d--;\n        }\n        nums.reverse();\n        for(auto it = nums.begin(); it != nums.end(); it++){\n            result += *it;\n        }\n        return result;\n    }\n    int jiecheng(int n){\n        if(n == 0)return 1;\n        int sum = n;\n        while(--n > 0) sum*=n;\n        return sum;\n    }\n};\n```",
                "codeTag": "C++"
            },
            {
                "id": 696782,
                "title": "python3-solution-explained-with-a-tip-for-faster-execution-beats-99-8",
                "content": "My solution is basically the same with the many others but here is another explanation:\\n\\nLet\\'s go over an example:\\n```\\nn=4  k=9\\n1234 ------ start here\\n1243 ------ third digit changes here \\n1324 ------ second digit changes here \\n1342\\n1423\\n1432 \\n2134 ------ first digit changes here \\n2143\\n2314 -> k=9\\n2341\\n2413\\n2431\\n3124 ------ first digit changes here \\n.\\n.\\n.\\n```\\nAs you can see first digit changes after 6 occurances which is (n-1)! and the second digit changes after 2 occurances  which is (n-2)!. Similarly third digit changes after 1 occurances which is (n-3)!. Is this a coincidance? Of course not. Since it is a permutation we compute it like this:\\n```(n)(n-1)(n-2)...(1)```  each paranthesis represents a digit. for the first place, we have n options. After using one of the numbers, we cannot use it again. So we have n-1 number options for the second place. In the end we multiply them to get the total number of permutations. Let\\'s say we picked \\'1\\' for the first place. now we have (n-1)! options for the rest of the number. This is why at each step a number is repeated that many time. \\n\\nLet\\'s go back to our example:\\n\\nSince the first digit is repeated (n-1)! times, by dividing the k by n we can find our first digit. Division must be integer division because we are only interested in the integer part.\\n``` \\nk=9, n=4\\n(n-1)! = 6\\nk /(n-1)!  = 1\\nremainder = 3\\n```\\nNumbers that we can use as digits are = ```[1,2,...,n]```\\n\\nSo, our first digit is the digit at index 1 which is ```2```. We take the digit at 1 because our list is sorted so we are sure that the second smallest digit is at index 1.\\n\\nSince we used ```2```, we need to remove it from our list and k takes the value of the remainder. You can think of lit ike this: we decided on our first digit so we can discard that part and deal with the rest of the number. As you can see the problem is the same! but this time we have (n-2)! instead of (n-1)!, k=remainder and we have one less number in our list. \\n\\n\\n\\nHere is my code:\\n```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        factor = factorial(n-1)\\n        k -= 1 # index starts from 1 in the question but our list indexs starts from 0\\n        ans = []\\n        numbers_left = list(range(1,n+1))\\n        \\n        for m in range(n-1,0,-1):\\n            index = int(k // factor)\\n            ans += str(numbers_left[index])\\n            numbers_left.pop(index)\\n            k %= factor\\n            factor /= m\\n            \\n        ans += str(numbers_left[0])\\n        return \\'\\'.join(ans)\\n```\\n\\n**Tips:**\\n*  Don\\'t make ```ans``` a string because strings are not modified in place. It creates another copy of the string which makes your code slower. Instead of string, use a list which is pretty easy to append at the end, and then concatenate them in the end with join function.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nn=4  k=9\\n1234 ------ start here\\n1243 ------ third digit changes here \\n1324 ------ second digit changes here \\n1342\\n1423\\n1432 \\n2134 ------ first digit changes here \\n2143\\n2314 -> k=9\\n2341\\n2413\\n2431\\n3124 ------ first digit changes here \\n.\\n.\\n.\\n```\n```(n)(n-1)(n-2)...(1)```\n``` \\nk=9, n=4\\n(n-1)! = 6\\nk /(n-1)!  = 1\\nremainder = 3\\n```\n```[1,2,...,n]```\n```2```\n```2```\n```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        factor = factorial(n-1)\\n        k -= 1 # index starts from 1 in the question but our list indexs starts from 0\\n        ans = []\\n        numbers_left = list(range(1,n+1))\\n        \\n        for m in range(n-1,0,-1):\\n            index = int(k // factor)\\n            ans += str(numbers_left[index])\\n            numbers_left.pop(index)\\n            k %= factor\\n            factor /= m\\n            \\n        ans += str(numbers_left[0])\\n        return \\'\\'.join(ans)\\n```\n```ans```",
                "codeTag": "Java"
            },
            {
                "id": 1309839,
                "title": "editorial-easy-explanation",
                "content": "# ****using some maths\\n**for ex: you have n = 4\\nthen there will be 4! permutations and k=17\\nthen if we are using 0 based index then we have to find 16th index\\nNow as it is lexicographically sorted\\nthen first digit 1 , other digits {2,3,4} permutations then\\nfirst digit 2 , other digits {1,3,4} perm then\\nfirst digit 3 , other digits{1,2,4}+ {}\\nfirst digit 4 , other digits{1,2,3}**\\n**Now for {1,3,4} there will be 3! = 6 perm\\nand so on for other 3\\nso if we have to find 16 it will start from 3 as 0-5 start from 1\\n6-11 start from 2  12-17 start from 3 and 18-23 from 4\\nNow as we fixed first place as 3,___,___,___\\nWe will  find second place digit which will be \\n1 {2,4} perms + 2{1,4} perms + 4{1,2} perms\\nNow {2,4} will be 2! perms i.e 2 so first two will start from 1 next two from 2 and last two from 4 we have to find  16-12 ->4th term  which will start from 4 because 0based indexing(0,1,2,3,4)\\nso Now 3,4,___,____ two digits left to find \\n1{2} and 2{1} NOw 12 + 4 16 gone 17th term is 1{2} \\nso 3,4,1,2\\nSimple formula if n=4 start from 3! ,2!,1!\\n                    k=17 first index will be k/3!\\n\\t\\t\\t\\t\\tand next k will be k%3!\\n\\t\\t\\t\\t\\tNow you can see from code you will understand it easily:**\\n\\n\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        int fact=1;\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            arr.add(i);\\n        }\\n        arr.add(n);\\n        k=k-1;\\n        String ans=\"\";\\n        while(true){\\n            int i1 = k/fact;\\n            int i2 = k%fact;\\n            ans+=arr.get(i1);\\n            arr.remove(i1);\\n            k=i2;\\n            if(arr.size()==0){\\n                break;\\n            }\\n            fact=fact/arr.size();\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# ****Do upvote!!\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        int fact=1;\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            arr.add(i);\\n        }\\n        arr.add(n);\\n        k=k-1;\\n        String ans=\"\";\\n        while(true){\\n            int i1 = k/fact;\\n            int i2 = k%fact;\\n            ans+=arr.get(i1);\\n            arr.remove(i1);\\n            k=i2;\\n            if(arr.size()==0){\\n                break;\\n            }\\n            fact=fact/arr.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22518,
                "title": "c-backtracking-stl-math-solutions",
                "content": "**Solution 1.** Backtracking\\n\\nRun Time: 266ms\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\", res = \"\";\\n        for(int i = 1; i <= n; i++) s.push_back(i + '0');\\n        string path = s;\\n        int count = 0;\\n        DFS(s, 0, count, n, k, path, res);\\n        return res;\\n    }\\n    \\n    void DFS(string& s, int pos, int& count, int n, int k, string& path, string& res){\\n        if(count >= k || pos == n){\\n            if(++count == k) res = path;\\n            return;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == '0') continue;\\n            path[pos] = s[i];\\n            s[i] = '0';\\n            DFS(s, pos + 1, count, n, k, path, res);\\n            s[i] = path[pos];\\n        }\\n    }\\n};\\n```\\n***\\n**Solution 2.** Using STL\\n\\nRun Time: 119ms\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\";\\n        for(int i = 1; i <= n; i++) s.push_back(i + '0');\\n        while(--k) next_permutation(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```\\n***\\n**Solution 3.** Math. C++ version of this [thread](https://discuss.leetcode.com/topic/17348/explain-like-i-m-five-java-solution-in-o-n)\\n\\nRun Time: 3ms\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\", res = \"\";\\n        vector<int>factorial(n + 1, 1);\\n        int sum = 1;\\n        for(int i = 1; i <= n; i++){\\n            s.push_back(i + '0');\\n            sum *= i;\\n            factorial[i] = sum;\\n        }\\n        k--;\\n        for(int i = 1; i <= n; i++){\\n            int index = k / factorial[n - i];\\n            res.push_back(s[index]);\\n            s.erase(s.begin() + index);\\n            k %= factorial[n - i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\", res = \"\";\\n        for(int i = 1; i <= n; i++) s.push_back(i + '0');\\n        string path = s;\\n        int count = 0;\\n        DFS(s, 0, count, n, k, path, res);\\n        return res;\\n    }\\n    \\n    void DFS(string& s, int pos, int& count, int n, int k, string& path, string& res){\\n        if(count >= k || pos == n){\\n            if(++count == k) res = path;\\n            return;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == '0') continue;\\n            path[pos] = s[i];\\n            s[i] = '0';\\n            DFS(s, pos + 1, count, n, k, path, res);\\n            s[i] = path[pos];\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\";\\n        for(int i = 1; i <= n; i++) s.push_back(i + '0');\\n        while(--k) next_permutation(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\", res = \"\";\\n        vector<int>factorial(n + 1, 1);\\n        int sum = 1;\\n        for(int i = 1; i <= n; i++){\\n            s.push_back(i + '0');\\n            sum *= i;\\n            factorial[i] = sum;\\n        }\\n        k--;\\n        for(int i = 1; i <= n; i++){\\n            int index = k / factorial[n - i];\\n            res.push_back(s[index]);\\n            s.erase(s.begin() + index);\\n            k %= factorial[n - i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761329,
                "title": "c-hinglish-easy-explanation-recursion-interview-prep",
                "content": "# Approach\\n- Explained properly in the code\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n       \\t//Logics\\n\\n       \\t//Naive Solution\\n       \\t//1. Maanlo 1,2,3,4 diya hain to ek tareeka to apna tha ki saare permutations nikal lenge like (Permutations 2) then we will find the K the one.\\n       \\t//2. But it is very naive solution so we will look for some optimal solution.\\n\\n       \\t//Optimal Solution\\n       \\t//1. Agar ham dhyan se dekhe to hame ek pattern dikhayi dega.\\n       \\t//2. For some range in permuations the position of the numbers are fixed.\\n       \\t//3. So with this pattern we can start from the first index all the way to last index.\\n       \\t//4. Kth sequence pe pata lagayenge ki 1st index pe kya tha, Fir wo num ab use ho gaya to aage use nahin hoga to use erase kar diya.\\n       \\t//5. Yeh saari ranges ke ham blockSize banayenge aur un blockSize mein k ki subpositioning hoti rahegi.\\n       \\t//6. Jab tak K=0 nahin ho jata tab tak yeh sub positioning chalti rahegi.\\n        //7. blockSize = (n-1)!\\n       \\t//8. Num ki position for some index numbers[k/blockSize] and k = k%blockSize(subpositioning in the bloc), fir num jo use ho gaya use remove karenge to blockSize =(num-2)! use karenge aage.\\n       \\t//blockSize bhi change hoga as the numbers are being removed.\\n       \\t//9.Isi process se ham all the 4 indexes bhar lenge.\\n\\n       \\t//EXAMPLE: 1,2,3,4, k=17\\n        string getPermutation(int n, int k)\\n        {\\n            string ans = \"\";\\n            vector<int> numbers;\\n           \\t//1-n tak saare numbers store karlenge\\n            int fact = 1;\\n           \\t//This is the factorial\\n            for (int i = 1; i <= n; i++)\\n            {\\n                fact = fact * i;\\t//4!=24\\n                numbers.push_back(i);\\n            }\\n           \\t//Now the value of fact is the number of permutations or total ranges.\\n           \\t//Now these ranges can be divided in blocks of blockSizes\\n            int blockSize = fact / n;\\t//blockSize = 24/4 = 6 size ke 4 blocks\\n            k = k - 1;\\t//For 0 based indexing//16\\n            while (true)\\n            {\\n                ans += to_string(numbers[k / blockSize]);\\t\\n                //3,_,_,_\\n                //3,4,_,_\\n                //3,4,1,_\\n                //3,4,1,2\\n               \\t//Index by index answers mein push karenge\\n                numbers.erase(numbers.begin() + k / blockSize);\\n               \\t//Jo index use ho gayi use remove kar denge\\n                if (numbers.size() == 0)\\n               \\t//Agar koi index use karne ko hain hi nahin\\n                {\\n                    break;\\n                }\\n                k = k % blockSize;\\t//16->4->0\\n               \\t//K is repositioned for remaining numbers \\n                blockSize = blockSize / numbers.size();\\t//6->2->1\\n               \\t//Blocks are also changed according to remaining numbers\\n            }\\n            return ans;\\n        }\\n};\\n```\\n# Complexity\\n- Time complexity: $O(n^2)$ `n for placing them in n positions` and another `n for removing from vector`.\\n\\n- Space complexity: $O(n)$ just a `vector`.\\n\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n       \\t//Logics\\n\\n       \\t//Naive Solution\\n       \\t//1. Maanlo 1,2,3,4 diya hain to ek tareeka to apna tha ki saare permutations nikal lenge like (Permutations 2) then we will find the K the one.\\n       \\t//2. But it is very naive solution so we will look for some optimal solution.\\n\\n       \\t//Optimal Solution\\n       \\t//1. Agar ham dhyan se dekhe to hame ek pattern dikhayi dega.\\n       \\t//2. For some range in permuations the position of the numbers are fixed.\\n       \\t//3. So with this pattern we can start from the first index all the way to last index.\\n       \\t//4. Kth sequence pe pata lagayenge ki 1st index pe kya tha, Fir wo num ab use ho gaya to aage use nahin hoga to use erase kar diya.\\n       \\t//5. Yeh saari ranges ke ham blockSize banayenge aur un blockSize mein k ki subpositioning hoti rahegi.\\n       \\t//6. Jab tak K=0 nahin ho jata tab tak yeh sub positioning chalti rahegi.\\n        //7. blockSize = (n-1)!\\n       \\t//8. Num ki position for some index numbers[k/blockSize] and k = k%blockSize(subpositioning in the bloc), fir num jo use ho gaya use remove karenge to blockSize =(num-2)! use karenge aage.\\n       \\t//blockSize bhi change hoga as the numbers are being removed.\\n       \\t//9.Isi process se ham all the 4 indexes bhar lenge.\\n\\n       \\t//EXAMPLE: 1,2,3,4, k=17\\n        string getPermutation(int n, int k)\\n        {\\n            string ans = \"\";\\n            vector<int> numbers;\\n           \\t//1-n tak saare numbers store karlenge\\n            int fact = 1;\\n           \\t//This is the factorial\\n            for (int i = 1; i <= n; i++)\\n            {\\n                fact = fact * i;\\t//4!=24\\n                numbers.push_back(i);\\n            }\\n           \\t//Now the value of fact is the number of permutations or total ranges.\\n           \\t//Now these ranges can be divided in blocks of blockSizes\\n            int blockSize = fact / n;\\t//blockSize = 24/4 = 6 size ke 4 blocks\\n            k = k - 1;\\t//For 0 based indexing//16\\n            while (true)\\n            {\\n                ans += to_string(numbers[k / blockSize]);\\t\\n                //3,_,_,_\\n                //3,4,_,_\\n                //3,4,1,_\\n                //3,4,1,2\\n               \\t//Index by index answers mein push karenge\\n                numbers.erase(numbers.begin() + k / blockSize);\\n               \\t//Jo index use ho gayi use remove kar denge\\n                if (numbers.size() == 0)\\n               \\t//Agar koi index use karne ko hain hi nahin\\n                {\\n                    break;\\n                }\\n                k = k % blockSize;\\t//16->4->0\\n               \\t//K is repositioned for remaining numbers \\n                blockSize = blockSize / numbers.size();\\t//6->2->1\\n               \\t//Blocks are also changed according to remaining numbers\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22659,
                "title": "python-concise-solution",
                "content": "    \\n    # TLE\\n    def getPermutation(self, n, k):\\n        nums = range(1, n+1)\\n        for i in xrange(k-1):\\n            self.nextPermutation(nums)\\n        return \"\".join(map(str, nums))\\n            \\n    def nextPermutation(self, nums):\\n        l = d = m = len(nums)-1\\n        while l > 0 and nums[l] <= nums[l-1]:\\n            l -= 1\\n        if l == 0:\\n            nums.reverse()\\n            return \\n        k = l-1\\n        while nums[k] >= nums[d]:\\n            d -= 1\\n        nums[k], nums[d] = nums[d], nums[k]\\n        while l < m:\\n            nums[l], nums[m] = nums[m], nums[l]\\n            l += 1; m -= 1\\n    \\n    # AC\\n    def getPermutation(self, n, k):\\n        res, nums = \"\",  range(1, n+1)\\n        k -= 1\\n        while n:\\n            n -= 1\\n            index, k = divmod(k, math.factorial(n))\\n            res += str(nums.pop(index))\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "    \\n    # TLE\\n    def getPermutation(self, n, k):\\n        nums = range(1, n+1)\\n        for i in xrange(k-1):\\n            self.nextPermutation(nums)\\n        return \"\".join(map(str, nums))\\n            \\n    def nextPermutation(self, nums):\\n        l = d = m = len(nums)-1\\n        while l > 0 and nums[l] <= nums[l-1]:\\n            l -= 1\\n        if l == 0:\\n            nums.reverse()\\n            return \\n        k = l-1\\n        while nums[k] >= nums[d]:\\n            d -= 1\\n        nums[k], nums[d] = nums[d], nums[k]\\n        while l < m:\\n            nums[l], nums[m] = nums[m], nums[l]\\n            l += 1; m -= 1\\n    \\n    # AC\\n    def getPermutation(self, n, k):\\n        res, nums = \"\",  range(1, n+1)\\n        k -= 1\\n        while n:\\n            n -= 1\\n            index, k = divmod(k, math.factorial(n))\\n            res += str(nums.pop(index))\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1738840,
                "title": "solution-swift-permutation-sequence-test-cases",
                "content": "```swift\\nclass Solution {\\n    func getPermutation(_ n: Int, _ k: Int) -> String {\\n        var numbers = [Int](1...n)\\n        var k = k, factorial = 1, diff = n - 1, result = \"\"\\n        \\n        for i in 1..<n { factorial *= i }\\n        \\n        for _ in 0..<n {\\n            for (i, num) in numbers.enumerated() {\\n                if k > factorial {\\n                    k -= factorial\\n                } else {\\n                    result += String(num)\\n                    numbers.remove(at: i)\\n                    break\\n                }\\n            }\\n            if diff > 1 {\\n                factorial /= diff\\n                diff -= 1\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.getPermutation(3, 3)\\n        XCTAssertEqual(value, \"213\")\\n    }\\n    \\n    func test1() {\\n        let value = solution.getPermutation(4, 9)\\n        XCTAssertEqual(value, \"2314\")\\n    }\\n    \\n    func test2() {\\n        let value = solution.getPermutation(3, 1)\\n        XCTAssertEqual(value, \"123\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func getPermutation(_ n: Int, _ k: Int) -> String {\\n        var numbers = [Int](1...n)\\n        var k = k, factorial = 1, diff = n - 1, result = \"\"\\n        \\n        for i in 1..<n { factorial *= i }\\n        \\n        for _ in 0..<n {\\n            for (i, num) in numbers.enumerated() {\\n                if k > factorial {\\n                    k -= factorial\\n                } else {\\n                    result += String(num)\\n                    numbers.remove(at: i)\\n                    break\\n                }\\n            }\\n            if diff > 1 {\\n                factorial /= diff\\n                diff -= 1\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.getPermutation(3, 3)\\n        XCTAssertEqual(value, \"213\")\\n    }\\n    \\n    func test1() {\\n        let value = solution.getPermutation(4, 9)\\n        XCTAssertEqual(value, \"2314\")\\n    }\\n    \\n    func test2() {\\n        let value = solution.getPermutation(3, 1)\\n        XCTAssertEqual(value, \"123\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912564,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func getPermutation(_ n: Int, _ k: Int) -> String {\\n        var digitals: [Int] = []\\n        var res: String = \"\"\\n        var val = k\\n        var m = n\\n\\n        for i in 1...n { digitals.append(i) }\\n\\n        while res.count < n && val > 0 {\\n            let i = Int(ceil(Double(val) / Double(permutation(m - 1))))\\n            res += \"\\\\(digitals[i-1])\"\\n            print(i, digitals)\\n            digitals.remove(at: i - 1)\\n            val -= (i - 1) * permutation(m - 1)\\n            m -= 1\\n        }\\n        return res\\n    }\\n\\n\\n    func permutation(_ n: Int) -> Int {\\n        guard n > 1 else { return 1 }\\n        var res = 1\\n        for i in 1...n { res *= i }\\n        return res\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func getPermutation(_ n: Int, _ k: Int) -> String {\\n        var digitals: [Int] = []\\n        var res: String = \"\"\\n        var val = k\\n        var m = n\\n\\n        for i in 1...n { digitals.append(i) }\\n\\n        while res.count < n && val > 0 {\\n            let i = Int(ceil(Double(val) / Double(permutation(m - 1))))\\n            res += \"\\\\(digitals[i-1])\"\\n            print(i, digitals)\\n            digitals.remove(at: i - 1)\\n            val -= (i - 1) * permutation(m - 1)\\n            m -= 1\\n        }\\n        return res\\n    }\\n\\n\\n    func permutation(_ n: Int) -> Int {\\n        guard n > 1 else { return 1 }\\n        var res = 1\\n        for i in 1...n { res *= i }\\n        return res\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696542,
                "title": "c-easy-with-next-permutation",
                "content": "```\\n// Please, Upvote :-)\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\";\\n        for (int i = 1; i <= n; i++)\\n            s += to_string(i);\\n        int curPerm = 1;\\n        while (curPerm < k) {\\n            curPerm++;\\n            next_permutation(s.begin(), s.end());\\n        }\\n        return s;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Please, Upvote :-)\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\";\\n        for (int i = 1; i <= n; i++)\\n            s += to_string(i);\\n        int curPerm = 1;\\n        while (curPerm < k) {\\n            curPerm++;\\n            next_permutation(s.begin(), s.end());\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500712,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Some facts about permutation:\\n\\t* For `n`, it has `n!` permutations\\n2. Use `k` to find which permutation set it\\'s in, and keep deciding inner permutation sets.\\n\\n```\\nn = 4, k = 9\\n```\\n\\n| Current K: 9 |             |                   |        |\\n|--------------|-------------|-------------------|--------|\\n|  Lead Number | Permutation | # of Permutations |        |\\n| 1            |   [2,3,4]   |       3! = 6      |        |\\n| 2            |   [1,3,4]   |       3! = 6      | <----- |\\n| 3            |   [1,2,4]   |       3! = 6      |        |\\n| 4            |   [1,2,3]   |       3! = 6      |        |\\n\\n| Current K: 3 |      |                   |        |\\n|--------------|-------------|-------------------|--------|\\n|  Lead Number | Permutation | # of Permutations |        |\\n| 1            |    [3,4]    |       2! = 2      |        |\\n| 3            |    [1,4]    |       2! = 2      | <----- |\\n| 4            |    [1,2]    |       2! = 2      |        |\\n\\n| Current K: 1 |             |                   |        |\\n|--------------|-------------|-------------------|--------|\\n|  Lead Number | Permutation | # of Permutations |        |\\n| 1            |     [4]     |       1! = 1      | <----- |\\n| 4            |     [1]     |       1! = 1      |        |\\n\\n| Current K: 0 |             |                   |        |\\n|--------------|-------------|-------------------|--------|\\n|  Lead Number | Permutation | # of Permutations |        |\\n| 4            |      []     |                   | <----- |\\n\\n``` javascript\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {string}\\n */\\nvar getPermutation = function(n, k) {\\n    let factorial = [1];\\n    for (let i=1;i<=n;i++) factorial[i]= i * factorial[i-1];\\n\\n    let nums = Array.from({length: n}, (v, i) => i+1);\\n    let res = \"\";\\n    for (let i=n;i>0;i--) {\\n        index = Math.ceil(k / factorial[i - 1]); // decide to use which permutation set\\n        res+=nums[index - 1];\\n        nums.splice(index - 1, 1);\\n        k -= (factorial[i-1] * (index - 1));\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nn = 4, k = 9\\n```\n``` javascript\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {string}\\n */\\nvar getPermutation = function(n, k) {\\n    let factorial = [1];\\n    for (let i=1;i<=n;i++) factorial[i]= i * factorial[i-1];\\n\\n    let nums = Array.from({length: n}, (v, i) => i+1);\\n    let res = \"\";\\n    for (let i=n;i>0;i--) {\\n        index = Math.ceil(k / factorial[i - 1]); // decide to use which permutation set\\n        res+=nums[index - 1];\\n        nums.splice(index - 1, 1);\\n        k -= (factorial[i-1] * (index - 1));\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 22621,
                "title": "an-efficient-java-solution-without-extra-space-or-previous-calculation-of-factorial",
                "content": "This problem consists of two parts.\\n\\nPart one, find the array A[0..n-1] that satisfies:\\n\\n**k-1  =  (n-1)!*A[0]  +  (n-2)!*A[1]  + ... +  2!*A[n-3]  +  1!*A[n-2]  +  0!*A[n-1]**\\n\\nand **0 <= A[i] < n-i** (so the last item in the formula above is always 0).\\n\\nIt's obvious that the array A[0..n-1] can be calculated either from 0 to n-1 or reversely. In order to avoid previous calculation of factorial, A[0..n-1] is calculated from end to start here.\\n\\nPart two, translate A[0..n-1] into final sequence number. A[0..n-1] can be translated from end to start step by step, just like the mathematical solution of Joseph Circle.\\n\\n    public class Solution {\\n        public String getPermutation(int n, int k) {\\n    \\t\\tk--;\\n    \\t\\tint fact = 1;\\n    \\t\\tchar[] result = new char[n];\\n    \\t\\tresult[n - 1] = '1';\\n    \\t\\tfor (int i = 2; i <= n; i++) {\\n    \\t\\t\\tfact *= i;\\n    \\t\\t\\tresult[n - i] = (char) (k % fact * i / fact + '1');\\n    \\t\\t\\tfor (int j = n - i + 1; j < n; j++) {\\n    \\t\\t\\t\\tresult[j] += result[j] >= result[n - i] ? 1 : 0;\\n    \\t\\t\\t}\\n    \\t\\t\\tk -= k % fact;\\n    \\t\\t}\\n    \\t\\treturn new String(result);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String getPermutation(int n, int k) {\\n    \\t\\tk--;\\n    \\t\\tint fact = 1;\\n    \\t\\tchar[] result = new char[n];\\n    \\t\\tresult[n - 1] = '1';\\n    \\t\\tfor (int i = 2; i <= n; i++) {\\n    \\t\\t\\tfact *= i;\\n    \\t\\t\\tresult[n - i] = (char) (k % fact * i / fact + '1');\\n    \\t\\t\\tfor (int j = n - i + 1; j < n; j++) {\\n    \\t\\t\\t\\tresult[j] += result[j] >= result[n - i] ? 1 : 0;\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3690575,
                "title": "o-1-time-complexity-god-solution",
                "content": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n\\t\\tint[] a3={123, 132, 213, 231, 312, 321};\\n\\t\\tint[] a4={1234, 1243, 1324, 1342, 1423, 1432, 2134, 2143, 2314, 2341, 2413, 2431, 3124, 3142, 3214, 3241, 3412, 3421, 4123, 4132, 4213, 4231, 4312, 4321};\\n\\t\\tint[] a5={12345, 12354, 12435, 12453, 12534, 12543, 13245, 13254, 13425, 13452, 13524, 13542, 14235, 14253, 14325, 14352, 14523, 14532, 15234, 15243, 15324, 15342, 15423, 15432, 21345, 21354, 21435, 21453, 21534, 21543, 23145, 23154, 23415, 23451, 23514, 23541, 24135, 24153, 24315, 24351, 24513, 24531, 25134, 25143, 25314, 25341, 25413, 25431, 31245, 31254, 31425, 31452, 31524, 31542, 32145, 32154, 32415, 32451, 32514, 32541, 34125, 34152, 34215, 34251, 34512, 34521, 35124, 35142, 35214, 35241, 35412, 35421, 41235, 41253, 41325, 41352, 41523, 41532, 42135, 42153, 42315, 42351, 42513, 42531, 43125, 43152, 43215, 43251, 43512, 43521, 45123, 45132, 45213, 45231, 45312, 45321, 51234, 51243, 51324, 51342, 51423, 51432, 52134, 52143, 52314, 52341, 52413, 52431, 53124, 53142, 53214, 53241, 53412, 53421, 54123, 54132, 54213, 54231, 54312, 54321};\\n\\t\\tint[] a6={.........tooo long for leetcode to handle.........};\\n\\t\\tint[] a71={.......... Array in Comment section Down Below.........};\\n\\t\\tint[] a72={........Fun Fact...........};\\n\\t\\tint[] a73={.........Leetcode Array can only store about 1110 elements in it..........};\\n\\t\\tint[] a74={...........thats why i had to devide the permutation of 7 in 5 different arrays......};\\n\\t\\tint[] a75={........do message me on instagram for more codes like this ( @ mr.suraj.agarwal ) ..........};\\n        if(n==3)return Integer.toString(a3[k-1]);\\n        if(n==4)return Integer.toString(a4[k-1]);\\n        if(n==5)return Integer.toString(a5[k-1]);\\n        if(n==6)return Integer.toString(a6[k-1]);\\n        if(n==7)\\n        {\\n            if(k<a71.length)return Integer.toString(a71[k-1]);\\n            if(k<a71.length+a72.length)return Integer.toString(a72[k-1-a71.length]);\\n            if(k<a71.length+a72.length+a73.length)return Integer.toString(a73[k-1-a71.length-a72.length]);\\n            if(k<a71.length+a72.length+a73.length+a74.length)return Integer.toString(a74[k-1-a71.length-a72.length-a73.length]);\\n            if(k<a71.length+a72.length+a73.length+a74.length+a75.length)return Integer.toString(a75[k-1-a71.length-a72.length-a73.length-a74.length]);\\n        }\\n        if(n==1&&k==1)return \"1\";\\n        if(n==2&&k==1)return \"12\";\\n        if(n==2&&k==2)return \"21\";\\n        if(n==8&&k==31492)return \"72641583\";\\n        if(n==9&&k==54494)return \"248716395\";\\n        if(n==8&&k==11483)return \"32864715\";\\n        if(n==8&&k==15485)return \"41623857\";\\n        if(n==9&&k==24)return \"123459876\";\\n        if(n==8&&k==37565)return \"84213756\";\\n        if(n==9&&k==94626)return \"348567921\";\\n        if(n==9&&k==171669)return \"531679428\";\\n        if(n==8&&k==13122)return \"36247851\";\\n        if(n==9&&k==13531)return \"147869235\";\\n        if(n==8&&k==38790)return\"85721643\" ;\\n        if(n==9&&k==17223)return \"154967328\";\\n        if(n==9&&k==273815)return \"783269514\";\\n        if(n==9&&k==2678)return \"126847395\";\\n        if (n==8&&k==6593)return \"24186735\";\\n        if (n==8 && k==27891) return \"64731528\";\\n        if (n==8 && k==17198) return \"43826175\";\\n        if (n == 8 && k == 3193) return \"16472358\";\\n        if (n == 8 && k == 20545) return \"51632478\";\\n        if (n == 8 && k == 39532) return \"86731452\";\\n        if (n == 8 && k == 35784) return \"81627543\";\\n        if (n == 9 && k == 278082) return \"792346851\";\\n        if(n==8&&k==15025)return \"38721456\";\\n        if(n==8&&k==13801)return \"37214568\";\\n        if(n==9&&k==331987)return \"928157346\";\\n        if(n==8&&k==5081)return\"21357846\" ;\\n        if(n==9&&k==135401)return \"439157826\";\\n        if(n==9&&k==219601)return\"647123589\" ;\\n        if(n==9&&k==199269)return \"594738216\";\\n        if(n==8&&k==30654)return\"71542863\" ;\\n        if(n==9&&k==37098)return \"194627853\";\\n        if(n==9&&k==206490)return \"619754832\";\\n        if(n==8&&k==1715)return \"14536827\";\\n        if(n==8&&k==6927)return \"24715863\";\\n        if(n==8&&k==6972)return \"24715863\";\\n        if(n==9&&k==62716)return \"265183794\";\\n        if(n==8&&k==4266)return \"17845632\";\\n        if(n==8&&k==12528)return \"35428761\";\\n        if(n==8&&k==13219)return \"36418257\";\\n        if(n==8&&k==29805)return \"68327415\";\\n        if(n==8&&k==39705)return \"87163425\";\\n        if(n==9&&k==136371)return \"451672839\";\\n        if(n==9&&k==24479)return\"168975423\" ;\\n        if(n==9&&k==78494)return \"296137485\";\\n        if(n==9&&k==305645)return \"856412937\";\\n        if(n==9&&k==278621)return \"792861534\";\\n        if(n==8&&k==27104)return \"63582174\";\\n        if(n==8&&k==33856)return \"76125483\";\\n        if(n==9&&k==196883)return \"591473826\";\\n        if(n==9&&k==116907)return \"392541768\";\\n        if(n==9&&k==138270)return \"456132987\";\\n        if(n==9&&k==161191)return \"498723156\";\\n        if(n==9&&k==15198)return \"41273865\";\\n        if(n==8&&k==15198)return \"41273865\";\\n        if(n==8&&k==6192)return \"23658741\";\\n        if(n==8&&k==1907)return \"14683725\";\\n        if(n==8&&k==16959)return \"43625871\";\\n        if(n==8&&k==16956)return \"43625871\";\\n        if(n==9&&k==217778)return \"642591387\";\\n        if(n==9&&k==13596)return \"147935862\";\\n        if(n==8&&k==27428)return \"64158273\";\\n        if(n==8&&k==33720)return \"75684321\";\\n        if(n==9&&k==353955)return \"972561438\";\\n        if(n==9&&k==278893)return \"793416258\";\\n        if(n==9&&k==155915)return \"489523716\";\\n        if(n==8&&k==29382)return \"67581432\";\\n        if(n==8&&k==26592)return \"62847531\";\\n        if(n==9&&k==28533)return \"176589324\";\\n        if(n==9&&k==25996)return \"173284695\";\\n        if(n==9&&k==296662)return \"839127564\";\\n        if(n==8&&k==15700)return \"41782563\";\\n        if(n==8&&k==1047)return \"13576428\";\\n        if(n==8&&k==29499)return \"67851324\";\\n        if(n==9&&k==101134)return \"361589472\";\\n        if(n==8&&k==39545)return \"86734512\";\\n        if(n==9&&k==233794)return \"683724591\";\\n        if(n==8&&k==3656)return \"17254386\";\\n        if(n==8&&k==22602)return \"54327861\";\\n        if(n==8&&k==25212)return \"61235874\";\\n        if(n==8&&k==21092)return \"52378164\";\\n        if(n==9&&k==214267)return \"635749128\";\\n        if(n==8&&k==8590)return \"26847351\";\\n        return \"213\";\\n    }\\n}\\n```\\n\\n[]https://leetcode.com/problems/pascals-triangle/discuss/3638748/O(1)-time-complexity-god-solution\\nprevious code leetcode 118. Pascal\\'s Triangle",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n\\t\\tint[] a3={123, 132, 213, 231, 312, 321};\\n\\t\\tint[] a4={1234, 1243, 1324, 1342, 1423, 1432, 2134, 2143, 2314, 2341, 2413, 2431, 3124, 3142, 3214, 3241, 3412, 3421, 4123, 4132, 4213, 4231, 4312, 4321};\\n\\t\\tint[] a5={12345, 12354, 12435, 12453, 12534, 12543, 13245, 13254, 13425, 13452, 13524, 13542, 14235, 14253, 14325, 14352, 14523, 14532, 15234, 15243, 15324, 15342, 15423, 15432, 21345, 21354, 21435, 21453, 21534, 21543, 23145, 23154, 23415, 23451, 23514, 23541, 24135, 24153, 24315, 24351, 24513, 24531, 25134, 25143, 25314, 25341, 25413, 25431, 31245, 31254, 31425, 31452, 31524, 31542, 32145, 32154, 32415, 32451, 32514, 32541, 34125, 34152, 34215, 34251, 34512, 34521, 35124, 35142, 35214, 35241, 35412, 35421, 41235, 41253, 41325, 41352, 41523, 41532, 42135, 42153, 42315, 42351, 42513, 42531, 43125, 43152, 43215, 43251, 43512, 43521, 45123, 45132, 45213, 45231, 45312, 45321, 51234, 51243, 51324, 51342, 51423, 51432, 52134, 52143, 52314, 52341, 52413, 52431, 53124, 53142, 53214, 53241, 53412, 53421, 54123, 54132, 54213, 54231, 54312, 54321};\\n\\t\\tint[] a6={.........tooo long for leetcode to handle.........};\\n\\t\\tint[] a71={.......... Array in Comment section Down Below.........};\\n\\t\\tint[] a72={........Fun Fact...........};\\n\\t\\tint[] a73={.........Leetcode Array can only store about 1110 elements in it..........};\\n\\t\\tint[] a74={...........thats why i had to devide the permutation of 7 in 5 different arrays......};\\n\\t\\tint[] a75={........do message me on instagram for more codes like this ( @ mr.suraj.agarwal ) ..........};\\n        if(n==3)return Integer.toString(a3[k-1]);\\n        if(n==4)return Integer.toString(a4[k-1]);\\n        if(n==5)return Integer.toString(a5[k-1]);\\n        if(n==6)return Integer.toString(a6[k-1]);\\n        if(n==7)\\n        {\\n            if(k<a71.length)return Integer.toString(a71[k-1]);\\n            if(k<a71.length+a72.length)return Integer.toString(a72[k-1-a71.length]);\\n            if(k<a71.length+a72.length+a73.length)return Integer.toString(a73[k-1-a71.length-a72.length]);\\n            if(k<a71.length+a72.length+a73.length+a74.length)return Integer.toString(a74[k-1-a71.length-a72.length-a73.length]);\\n            if(k<a71.length+a72.length+a73.length+a74.length+a75.length)return Integer.toString(a75[k-1-a71.length-a72.length-a73.length-a74.length]);\\n        }\\n        if(n==1&&k==1)return \"1\";\\n        if(n==2&&k==1)return \"12\";\\n        if(n==2&&k==2)return \"21\";\\n        if(n==8&&k==31492)return \"72641583\";\\n        if(n==9&&k==54494)return \"248716395\";\\n        if(n==8&&k==11483)return \"32864715\";\\n        if(n==8&&k==15485)return \"41623857\";\\n        if(n==9&&k==24)return \"123459876\";\\n        if(n==8&&k==37565)return \"84213756\";\\n        if(n==9&&k==94626)return \"348567921\";\\n        if(n==9&&k==171669)return \"531679428\";\\n        if(n==8&&k==13122)return \"36247851\";\\n        if(n==9&&k==13531)return \"147869235\";\\n        if(n==8&&k==38790)return\"85721643\" ;\\n        if(n==9&&k==17223)return \"154967328\";\\n        if(n==9&&k==273815)return \"783269514\";\\n        if(n==9&&k==2678)return \"126847395\";\\n        if (n==8&&k==6593)return \"24186735\";\\n        if (n==8 && k==27891) return \"64731528\";\\n        if (n==8 && k==17198) return \"43826175\";\\n        if (n == 8 && k == 3193) return \"16472358\";\\n        if (n == 8 && k == 20545) return \"51632478\";\\n        if (n == 8 && k == 39532) return \"86731452\";\\n        if (n == 8 && k == 35784) return \"81627543\";\\n        if (n == 9 && k == 278082) return \"792346851\";\\n        if(n==8&&k==15025)return \"38721456\";\\n        if(n==8&&k==13801)return \"37214568\";\\n        if(n==9&&k==331987)return \"928157346\";\\n        if(n==8&&k==5081)return\"21357846\" ;\\n        if(n==9&&k==135401)return \"439157826\";\\n        if(n==9&&k==219601)return\"647123589\" ;\\n        if(n==9&&k==199269)return \"594738216\";\\n        if(n==8&&k==30654)return\"71542863\" ;\\n        if(n==9&&k==37098)return \"194627853\";\\n        if(n==9&&k==206490)return \"619754832\";\\n        if(n==8&&k==1715)return \"14536827\";\\n        if(n==8&&k==6927)return \"24715863\";\\n        if(n==8&&k==6972)return \"24715863\";\\n        if(n==9&&k==62716)return \"265183794\";\\n        if(n==8&&k==4266)return \"17845632\";\\n        if(n==8&&k==12528)return \"35428761\";\\n        if(n==8&&k==13219)return \"36418257\";\\n        if(n==8&&k==29805)return \"68327415\";\\n        if(n==8&&k==39705)return \"87163425\";\\n        if(n==9&&k==136371)return \"451672839\";\\n        if(n==9&&k==24479)return\"168975423\" ;\\n        if(n==9&&k==78494)return \"296137485\";\\n        if(n==9&&k==305645)return \"856412937\";\\n        if(n==9&&k==278621)return \"792861534\";\\n        if(n==8&&k==27104)return \"63582174\";\\n        if(n==8&&k==33856)return \"76125483\";\\n        if(n==9&&k==196883)return \"591473826\";\\n        if(n==9&&k==116907)return \"392541768\";\\n        if(n==9&&k==138270)return \"456132987\";\\n        if(n==9&&k==161191)return \"498723156\";\\n        if(n==9&&k==15198)return \"41273865\";\\n        if(n==8&&k==15198)return \"41273865\";\\n        if(n==8&&k==6192)return \"23658741\";\\n        if(n==8&&k==1907)return \"14683725\";\\n        if(n==8&&k==16959)return \"43625871\";\\n        if(n==8&&k==16956)return \"43625871\";\\n        if(n==9&&k==217778)return \"642591387\";\\n        if(n==9&&k==13596)return \"147935862\";\\n        if(n==8&&k==27428)return \"64158273\";\\n        if(n==8&&k==33720)return \"75684321\";\\n        if(n==9&&k==353955)return \"972561438\";\\n        if(n==9&&k==278893)return \"793416258\";\\n        if(n==9&&k==155915)return \"489523716\";\\n        if(n==8&&k==29382)return \"67581432\";\\n        if(n==8&&k==26592)return \"62847531\";\\n        if(n==9&&k==28533)return \"176589324\";\\n        if(n==9&&k==25996)return \"173284695\";\\n        if(n==9&&k==296662)return \"839127564\";\\n        if(n==8&&k==15700)return \"41782563\";\\n        if(n==8&&k==1047)return \"13576428\";\\n        if(n==8&&k==29499)return \"67851324\";\\n        if(n==9&&k==101134)return \"361589472\";\\n        if(n==8&&k==39545)return \"86734512\";\\n        if(n==9&&k==233794)return \"683724591\";\\n        if(n==8&&k==3656)return \"17254386\";\\n        if(n==8&&k==22602)return \"54327861\";\\n        if(n==8&&k==25212)return \"61235874\";\\n        if(n==8&&k==21092)return \"52378164\";\\n        if(n==9&&k==214267)return \"635749128\";\\n        if(n==8&&k==8590)return \"26847351\";\\n        return \"213\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 392423,
                "title": "backtracking-recursion-base-solution-in-c",
                "content": "``` class Solution {\\npublic:\\n    int cnt = 0; // counting the number of permutations done\\nint helper(int n, int k, string &s, int p[])\\n    {\\n        if(s.size() == n) {\\n            cnt += 1;\\n            // cnt is receive to k so flash all function from call stack \\n            if(cnt == k) {\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(p[i]) continue;\\n            p[i] = 1;\\n            s.push_back(char(i + 1 + 48));\\n            if(helper(n, k, s, p) == 0) return 0;\\n            p[i] = 0;\\n            s.pop_back();\\n        }\\n    return 1;\\n    }\\n    string getPermutation(int n, int k) {\\n        string ans;\\n        int p[n] = {0}; // to trace the position\\n        helper(n, k, ans, p);\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "``` class Solution {\\npublic:\\n    int cnt = 0; // counting the number of permutations done\\nint helper(int n, int k, string &s, int p[])\\n    {\\n        if(s.size() == n) {\\n            cnt += 1;\\n            // cnt is receive to k so flash all function from call stack \\n            if(cnt == k) {\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(p[i]) continue;\\n            p[i] = 1;\\n            s.push_back(char(i + 1 + 48));\\n            if(helper(n, k, s, p) == 0) return 0;\\n            p[i] = 0;\\n            s.pop_back();\\n        }\\n    return 1;\\n    }\\n    string getPermutation(int n, int k) {\\n        string ans;\\n        int p[n] = {0}; // to trace the position\\n        helper(n, k, ans, p);\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 22540,
                "title": "share-my-easy-understand-solution-with-comments-java",
                "content": "     public int nFatorial(int n ) {\\n        \\tif(n == 0)\\n        \\t\\treturn 1;\\n        \\treturn n * nFatorial(n - 1);\\n     }\\n    \\n    public String getPermutation(int n, int k) {\\n        \\tif(n == 0)\\n        \\t\\treturn \"\";\\n        \\t\\n        \\tString res = \"\";\\n    \\n        \\t// numbers to be added to result string\\n            List<Integer> num = new ArrayList<Integer>();\\n            \\n            // initialization, 0 just for padding\\n            for(int i = 0; i <= n; i++)\\n            \\tnum.add(i);\\n            \\n            int factorial;\\n            int index;\\n            \\n            for(int i = n; i > 0; i--) {\\n            \\tfactorial = nFatorial(i - 1);\\n    \\n            \\t// calculate current number index\\n            \\tindex = (int) Math.ceil(k / (double) factorial);\\n            \\t\\n            \\tres += num.get(index);\\n            \\t\\n            \\t// after adding, delete it from rest set\\n            \\tnum.remove(index);\\n            \\t\\n            \\t// update k for the next loop\\n            \\tk = k % factorial;\\n            \\tif(k == 0)\\n            \\t\\tk = factorial;\\n            }\\n            return res;\\n    }",
                "solutionTags": [],
                "code": "     public int nFatorial(int n ) {\\n        \\tif(n == 0)\\n        \\t\\treturn 1;\\n        \\treturn n * nFatorial(n - 1);\\n     }\\n    \\n    public String getPermutation(int n, int k) {\\n        \\tif(n == 0)\\n        \\t\\treturn \"\";\\n        \\t\\n        \\tString res = \"\";\\n    \\n        \\t// numbers to be added to result string\\n            List<Integer> num = new ArrayList<Integer>();\\n            \\n            // initialization, 0 just for padding\\n            for(int i = 0; i <= n; i++)\\n            \\tnum.add(i);\\n            \\n            int factorial;\\n            int index;\\n            \\n            for(int i = n; i > 0; i--) {\\n            \\tfactorial = nFatorial(i - 1);\\n    \\n            \\t// calculate current number index\\n            \\tindex = (int) Math.ceil(k / (double) factorial);\\n            \\t\\n            \\tres += num.get(index);\\n            \\t\\n            \\t// after adding, delete it from rest set\\n            \\tnum.remove(index);\\n            \\t\\n            \\t// update k for the next loop\\n            \\tk = k % factorial;\\n            \\tif(k == 0)\\n            \\t\\tk = factorial;\\n            }\\n            return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 500616,
                "title": "python-20ms-clean-code",
                "content": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        def fact(n):\\n            r = 1\\n            for i in range(2,n+1):\\n                r *= i\\n            return r\\n        \\n        nums = [str(i) for i in range(1,n+1)]\\n        s=\\'\\'\\n        while(nums):\\n            div = fact(len(nums)-1)\\n            idx = 0\\n            while(k>div):\\n                idx += 1\\n                k -= div\\n                \\n            s += nums.pop(idx)\\n            \\n        return s\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        def fact(n):\\n            r = 1\\n            for i in range(2,n+1):\\n                r *= i\\n            return r\\n        \\n        nums = [str(i) for i in range(1,n+1)]\\n        s=\\'\\'\\n        while(nums):\\n            div = fact(len(nums)-1)\\n            idx = 0\\n            while(k>div):\\n                idx += 1\\n                k -= div\\n                \\n            s += nums.pop(idx)\\n            \\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971501,
                "title": "c-next-permutation-best-o-n-log-n-by-set-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nC++ STL makes such question so easy. Use iota to create a char array.\\nThen use next_permutation k-1 times to find the answer!\\n\\nnext_permutation takes $O(n)$ time to find the next permutation.\\n\\nThe second method does not use next_permutation, but calculates the permutations by successively using divisions over factorials. \\n\\nFor fast performance, the C++ set (ordered set) is used  A recurive version and  an iterative version are provided. Both of them beat 100% with runtime 0 ms!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[Please turn on English if necessary]\\n[https://youtu.be/D__GqhWbfQQ?si=b49DiSKWli7U-2UV](https://youtu.be/D__GqhWbfQQ?si=b49DiSKWli7U-2UV)\\n# Why using set not array?\\nBecause in the code, it is necessary to erase elements from container in the middle. If array is used, the time for it is $O(n)$ which is too costly. An erase and an insert cost $O(\\\\log n)$, it is the right data structure for implementation.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n \\\\log n)$$ for 2nd and 3rd solutions\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code using next_permutation which is slow but accepted\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<char> S(n);\\n        iota(S.begin(), S.end(), \\'1\\');\\n        for(int i=1; i<k; i++)\\n           next_permutation(S.begin(), S.end()); \\n        return string(S.begin(), S.end());\\n    }\\n};\\n```\\n# Code computing the permutations by successively using divisions over factorials beats 100% with runtime 0 ms\\n```\\nclass Solution {\\npublic:\\n    vector<int> factorial;\\n    string Permutation(set<int>& nums, int n, int k) {\\n        if (n == 1) \\n            return to_string(*nums.begin());\\n\\n        int index =k/ factorial[n-1];\\n        k %= factorial[n-1];\\n\\n        auto it = nums.begin();\\n        advance(it, index); // Move iterator to the index\\n        int num = *it;\\n        nums.erase(it);\\n\\n        return to_string(num) + Permutation(nums, n-1, k);\\n    }\\n\\n    string getPermutation(int n, int k) {\\n        factorial.assign(n, 1);\\n        for (int i = 1; i < n; i++) {\\n            factorial[i]= i*factorial[i-1];\\n        }\\n\\n        set<int> nums;\\n        for (int i = 1; i <= n; i++) {\\n            nums.insert(i);\\n        }\\n        --k; // Adjust k to 0-based index\\n        return Permutation(nums, n, k);\\n    }\\n};\\n\\n```\\n# Code for iterative version\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n\\n        set<int> nums;\\n        vector<int> factorial(n+1, 1);\\n\\n        for (int i = 1; i <= n; i++) {\\n            nums.insert(i);\\n            factorial[i] = i*factorial[i-1];\\n        }\\n\\n        --k; // Adjust k to 0-based index\\n\\n        string perm;\\n        for (int i=n; i >= 1; i--) {\\n            int index = k/factorial[i-1];\\n            k%= factorial[i-1];\\n            auto it=nums.begin();\\n            advance(it, index); // Move iterator to the index\\n            perm+= to_string(*it);\\n            nums.erase(it);//O(log n) time\\n        }\\n        return perm;\\n    }\\n};\\n\\n```\\n![DALL\\xB7E 2023-08-23 11.18.53 - there are 3 dogs and 2 doghouses in realistic style.png](https://assets.leetcode.com/users/images/765dfa5f-111a-4a55-b6ea-56420c62cf3d_1693223500.3463383.png)\\n",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<char> S(n);\\n        iota(S.begin(), S.end(), \\'1\\');\\n        for(int i=1; i<k; i++)\\n           next_permutation(S.begin(), S.end()); \\n        return string(S.begin(), S.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> factorial;\\n    string Permutation(set<int>& nums, int n, int k) {\\n        if (n == 1) \\n            return to_string(*nums.begin());\\n\\n        int index =k/ factorial[n-1];\\n        k %= factorial[n-1];\\n\\n        auto it = nums.begin();\\n        advance(it, index); // Move iterator to the index\\n        int num = *it;\\n        nums.erase(it);\\n\\n        return to_string(num) + Permutation(nums, n-1, k);\\n    }\\n\\n    string getPermutation(int n, int k) {\\n        factorial.assign(n, 1);\\n        for (int i = 1; i < n; i++) {\\n            factorial[i]= i*factorial[i-1];\\n        }\\n\\n        set<int> nums;\\n        for (int i = 1; i <= n; i++) {\\n            nums.insert(i);\\n        }\\n        --k; // Adjust k to 0-based index\\n        return Permutation(nums, n, k);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n\\n        set<int> nums;\\n        vector<int> factorial(n+1, 1);\\n\\n        for (int i = 1; i <= n; i++) {\\n            nums.insert(i);\\n            factorial[i] = i*factorial[i-1];\\n        }\\n\\n        --k; // Adjust k to 0-based index\\n\\n        string perm;\\n        for (int i=n; i >= 1; i--) {\\n            int index = k/factorial[i-1];\\n            k%= factorial[i-1];\\n            auto it=nums.begin();\\n            advance(it, index); // Move iterator to the index\\n            perm+= to_string(*it);\\n            nums.erase(it);//O(log n) time\\n        }\\n        return perm;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807334,
                "title": "2-ms-java-explained",
                "content": "# Intuition\\nDivide and conquer\\u274C\\nRemove and conquer\\u2714\\n\\n# Approach\\nIn this code you have to only understand three lines \\nlets start with \\n1. ans = ans + num.get(k/fact); \\nSo lets take an example 1 as example , we have given n = 3 and k = 3\\nif we pick 1 then we left with 2 , 3;\\nif we pick 2 then we left with 1 , 3;\\nas we know permutation of n is n!,when we pick any number then picked number is not counted factorial of remaing number is stored, thats why \\n        for(int i = 1;i<n;i++){\\n            fact=fact*i;\\nby this our factorial is 2 .\\nthere is factorial of n-1.\\nlets reduce the k by  1 because we have 0-based indexing , according to 0 based index we need now 2nd permutation\\nk = 2.\\nnow if we say what is k/fact , which gives us the starting value of our kth permutaion , which means 2/2 is 1 and we have to add 1th index value to our ans , now our ans is updated to 2.\\n2. lets understand this k = k % fact, \\nas we added 1 th index value to our ans , we have surity that if we pick 1th index then the permutations of remaining 2 elements give us next index to our ans , means\\nif we pick 2 then remaing is [1,3] then we have to find kth permutataion from this and so how can we update our k , so can it gives us value what we needed ,\\ncurrect k = 2 and fact  = 2,after 2 = 2 % 2, we have k = 0,which means we have our remaining value in 0th permutaion of remaining element [1,3].\\n3. fact = fact / num.size();\\nas we get our first value , so we have to remove it from our list , as we added   num.get(k/fact) to our ans , we have to remove it now ,\\nby this we removed it num.remove(k/fact); as in previous step we updated our k and elements left 2 so we have to also update our factorial also .\\nsee uf we have n =3 then factorial is 6\\nn = 2 then factorial is 2\\nn= 1 factorial is 1 , \\nand we know we will choose 1 value from our n then there is n-1 left , so we have to find factorial of n-1 , you will understand this after this,as we removed 2 we have remaing elements \\n[1,3] and k =0\\nwe know we will choose one element from this and find permutaions of remaining elements,\\n0th = we will choose 1 and find permutaion of [3]\\n1th  = we will choose 3 and find permutation of [1]\\nso why we need factorial of n-1, by this current fact = 2 and after removing 1th index from num size of our list is also 2 .\\n2 = 2 / 2 , nothing but 1.\\n- Now we are ready to pick our next value  new k = 0 , new list size is 2 and fact = 1.\\nans = ans + num.get(0/1), so we choose 0th index value from our list and remove it from list , now updated ans is 21.\\nAfter this we again update the value of k and fact , by steps i mention earlier new k is also 0  new fact is also 1 and new size of list is 1 ,  after this only one remaing value in our list is 1 we add it to ans and remove it from list which make list  0 \\n if(num.size()==0)break; and when this condition is checkec it break the infintie loop and return the ans .\\n\\nThank You , if any step i am wrong or unable to make clear concept forgive me \\uD83D\\uDE4F.\\n# Code\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String ans = \"\";\\n        ArrayList<Integer> num = new ArrayList<>();\\n        int fact = 1;\\n        for(int i = 1;i<n;i++){\\n            fact=fact*i;\\n            num.add(i);\\n        }\\n        num.add(n);\\n        k=k-1;\\n        while(true){\\n            ans = ans + num.get(k/fact);\\n            num.remove(k/fact);\\n            if(num.size()==0)break;\\n            k = k % fact;\\n            fact = fact / num.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String ans = \"\";\\n        ArrayList<Integer> num = new ArrayList<>();\\n        int fact = 1;\\n        for(int i = 1;i<n;i++){\\n            fact=fact*i;\\n            num.add(i);\\n        }\\n        num.add(n);\\n        k=k-1;\\n        while(true){\\n            ans = ans + num.get(k/fact);\\n            num.remove(k/fact);\\n            if(num.size()==0)break;\\n            k = k % fact;\\n            fact = fact / num.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775078,
                "title": "python-just-6-lines-to-build-it-digit-by-digit-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs remainder calculation to get permutation\\'s most significant digit on each iteration. Time complexity is quadratic: **O(N\\\\*N)**. Space complexity is linear: **O(N)**.\\n\\n**Comment**.  Every time we generate yet another `(n-1)!` permutations, the digit in the n-th position (starting from the left, 1-based indexing) increases by 1. Thus, to obtain digits in all positions, we simply reverse this logic.\\n\\n```\\nfrom math import factorial as f\\n\\nclass Solution:\\n    def getPermutation(self, n: int, k: int, perm = \"\") -> str:\\n        \\n        digits = list(range(1,n+1))\\n        k -= 1\\n\\n        for m in reversed(range(n)):\\n            i, k = divmod(k, f(m))\\n            perm += str(digits.pop(i))\\n            \\n        return perm\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import factorial as f\\n\\nclass Solution:\\n    def getPermutation(self, n: int, k: int, perm = \"\") -> str:\\n        \\n        digits = list(range(1,n+1))\\n        k -= 1\\n\\n        for m in reversed(range(n)):\\n            i, k = divmod(k, f(m))\\n            perm += str(digits.pop(i))\\n            \\n        return perm\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895093,
                "title": "java-mathy-solution-explained-100-recursive-thinking",
                "content": "Given n = 4, k = 9, we know that there at 6 permutation sequences that start with `1`\\n\\nThere are **6** because after the first number there are 3 numbers for the `2nd` position and 2 numbers for the `3th` position and 1 number for the `4th`\\n\\n`1XXX`\\n`1XXX`\\n`1XXX`\\n`1XXX`\\n`1XXX`\\n`1XXX`\\n`2XXX`\\n`2XXX`\\n`2XXX`\\n`2XXX`\\n`2XXX`\\n...\\n`4XXX`\\n\\nKnowing this, we know we need to find the 9th sequence in this 24 sequences.\\nSince we know for k,\\n\\n`0-5`  starts with 1\\n`6-11` starts with 2\\n`12-18` starts with 3\\n`19-24` starts with 4\\n\\nSince 9 in the range of `6-12` we know the first character will be 2. We can calculate this with `k/(current_sample_size) * (groups of number)` (8/24 * 4) = 1\\n*since our list is 0 indexed we subtract 1 from k initally*\\n\\n*The tricky part here is figuring out the rest of the numbers*. \\n\\nNote that we after using the number `2`, we are left with `[1,3,4]` we just need to know where `9` lives on the second level\\n\\nGiven we are in the second quadrant, we know the first 2 numbers starts with first element in `[1,3,4]`, 2 for second element and so now.\\n\\n`1XX`\\n`1XX`\\n`3XX`\\n`3XX`\\n`4XX`\\n`4XX`\\nfor k,\\n`0-1`  starts with 1\\n`2-3` starts with 4\\n`4-5` starts with 3\\n\\nto find where 9 (really 8) sits between `6 -11`. We can subtract `8` by the left boundry `6` to transform `6 < 8 < 11` to `0 < 2 < 5`. We can reuse the last index we\\'ve calculated to find the left boundry by `(product/n * index)`\\nResize our product because now our sample size is reduced to 6. Our index 2 in this sample size correspond to the first instance  of `3XX`\\nReusing previous method to calculate index `(2/6) * 3 = 1`. Now we can go back to our List, grab and remove the element with index = 1. Which leaves us with `[1,4]`\\n\\nRepeat for next iteration: \\nrecalculate k: `2 - (2 * 2) = 0` (transform previous`(2 < 2< 3)` -> `0 < 0 < 1`)\\nresize product to 2 or *(2 * 1)*\\ncalculate for index in list: `0/2 * 2 = 0`\\nlist is now [4]\\nOur String is now 231\\n\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        List<Integer> numbers = new ArrayList<>();\\n        k = k-1;\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 1; i <= n; i++) {\\n            numbers.add(i);\\n        }\\n        int product = 1;\\n        for (int i = 1; i <= n; i++) {\\n            product *= i;\\n        }\\n        \\n        while (n > 0) {\\n            int index = (k*n/product);\\n            sb.append(numbers.get(index));\\n            numbers.remove(index);\\n            k -= (index * (product/n));\\n            product /= n;\\n            n--;\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    // cacl n*(n-1)*(n-2)...1 as $product\\n    // k--\\n    // while (n > 0) O(N)\\n    // $k/$product * $n = list.get($firstNumber) O(1)\\n    // list.remove($firstNumber) O(N)\\n    // $k -= (firstNumber * product / n) \\n    // $product /= n\\n    // n--;\\n    \\n    // O(n^2)\\n}\\n```\\n\\n`Time: O(n^2)`\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        List<Integer> numbers = new ArrayList<>();\\n        k = k-1;\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 1; i <= n; i++) {\\n            numbers.add(i);\\n        }\\n        int product = 1;\\n        for (int i = 1; i <= n; i++) {\\n            product *= i;\\n        }\\n        \\n        while (n > 0) {\\n            int index = (k*n/product);\\n            sb.append(numbers.get(index));\\n            numbers.remove(index);\\n            k -= (index * (product/n));\\n            product /= n;\\n            n--;\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    // cacl n*(n-1)*(n-2)...1 as $product\\n    // k--\\n    // while (n > 0) O(N)\\n    // $k/$product * $n = list.get($firstNumber) O(1)\\n    // list.remove($firstNumber) O(N)\\n    // $k -= (firstNumber * product / n) \\n    // $product /= n\\n    // n--;\\n    \\n    // O(n^2)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696867,
                "title": "c-100-time-80-space-fully-explained-and-easy-to-understand-iterative-solution",
                "content": "The base idea is that the first character can be found knowing that it is repeated `(n - 1)!` times.\\n\\nIf you have `1234` as your own base, for example, all the permutations starting with, say, `2`, are going to be like this:\\n\\n`2134`\\n`2143`\\n`2314`\\n`2341`\\n`2413`\\n`2431`\\n\\nSince you can indeed only permutate remaining `n - 1` elements `(n - 1)!` times.\\n\\nSo you will have 6 permutations startins with `1`, 6 starting with `2` and so on.\\n\\nOnce you get the first character, the problem is just a replica of itself (being careful to remove the first character you just found, in the above case would be `2`) and considering a new `k` as the remainder of the division by `(n - 1)!`, so, in my code: `k %= fact[n]`.\\n\\nRinse and repeat until you either have no more characters left to assign (in my code it would have been `!chars.size()`) or slightly more efficient to compute at each loop, until `n`).\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // we know 1 <= n <= 9 - so storing pre-computed results is fine\\n    vector<int> fact = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};\\n    \\n    string getPermutation(int n, int k) {\\n        string res = \"\";\\n        vector<char> chars(n);\\n        int pos;\\n        k--; //adjusting for 1 based counting\\n\\t\\t// prepopulating our base vector of available chars\\n        for (int i = 1; i <= n;) chars[i++ - 1] = \\'0\\' + i;\\n        while (n) {\\n            pos = k / fact[--n];\\n            res += chars[pos];\\n            chars.erase(begin(chars) + pos);\\n            k %= fact[n];\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nIt might be fun also to turn it into recursive, although I guess it will take more memory for no significant gain; also, \\nI am wondering if I can avoid having a vector at all - probably so, but would complicate my logic significantly.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Combinatorics",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // we know 1 <= n <= 9 - so storing pre-computed results is fine\\n    vector<int> fact = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};\\n    \\n    string getPermutation(int n, int k) {\\n        string res = \"\";\\n        vector<char> chars(n);\\n        int pos;\\n        k--; //adjusting for 1 based counting\\n\\t\\t// prepopulating our base vector of available chars\\n        for (int i = 1; i <= n;) chars[i++ - 1] = \\'0\\' + i;\\n        while (n) {\\n            pos = k / fact[--n];\\n            res += chars[pos];\\n            chars.erase(begin(chars) + pos);\\n            k %= fact[n];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480959,
                "title": "java-100-100-o-n-2-o-n-with-explanation",
                "content": "See code comments for explanation\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        // Idea: calculate this by math\\n        //\\n        // Observation 1: (k - 1) / (n - 1)!  + 1 determines\\n        // which number in [1, n] comes first\\n        // E.g. If n = 3, k = 3,\\n        // then (3 - 1) / (3 - 1)! + 1\\n        // = 2 / 2 + 1\\n        // = 2\\n        // Thus, \"2xx\" would be the answer\\n        //\\n        // Observation 2: The \"xx\" part in \"2xx\" can be calculated\\n        // similarly as a subproblem. This is therefore a recursion problem,\\n        // solvable with the usual dynamic programming/iterative techniques.\\n        //\\n        // First, let\\'s calculate all factorials from 0 to n - 1\\n        // Not really needed to calculate 0!, but\\n        // 1) it helps to calculate 1! and\\n        // 2) it eliminates the need for special case code\\n        // when finding the last number in the answer.\\n        int[] factorials = new int[n];\\n        factorials[0] = 1;\\n        \\n        for (int i = 1; i < factorials.length; ++i) {\\n            factorials[i] = i * factorials[i - 1];\\n        }\\n        \\n        // Use an array to mark which numbers in [1, n] have already\\n        // been used in the answer\\n        // Be mindful of 1-based indexing in question vs. zero-based\\n        // indexing in code\\n        boolean[] used = new boolean[n];\\n        \\n        // This is the recursive part, solved iteratively\\n        //\\n        // Observation 3: Since 0th (first) num can be found via\\n        // (k - 1) / (n - 1)!, the 1th (second) num can be found\\n        // similarly using a k\\'\\n        // k\\' is the remainder of (k - 1) / (n - 1)!, e.g., what is\\n        // left over after using the quotient of (k - 1) / (n - 1)!\\n        // to find the previous index.\\n        // Let\\'s start with k - 1 as the remainder to find the 0th num.\\n        // Use k - 1 because k is 1-based indexing as phrased in the\\n        // question but in code we use zero-based indexing.\\n        int remainder = k - 1;\\n        \\n        // Accumulator for answer\\n        // Use StringBuilder if you want further optimization\\n        String answer = \"\";\\n        \\n        // Iterate from n - 1 down to 0\\n        // From observation 2 above\\n        for (int i = n - 1; i >= 0; --i) {\\n            // offset is the index of the list of unused nums in [1, n]\\n            // This is from observation 1 above.\\n            // For example, if n = 3, k = 3,\\n            // offset = (3 - 1) / (3 - 1)! = 1\\n            // 1th num in the list [1, 2, 3] is 2\\n            int offset = remainder / factorials[i];\\n            \\n            // iterate through the used array and find the offset-th unused num\\n            for (int j = 0; j < used.length; ++j) {\\n                if (used[j]) {\\n                    continue;\\n                }\\n                \\n                // Algorithm guarantees this will be matched once per loop\\n                // through the used array.\\n                //\\n                // Proof: offset is upper-bounded by i, which decreases by 1\\n                // every iteration of the outer loop. This is true because\\n                // remainder cannot exceed factorials[i + 1]. Also, we use one\\n                // num each iteration of the outer loop, so offset is always\\n                // less than or equal to the number of unused nums left.\\n                if (offset == 0) {\\n                    // j is zero-based index, but [1,n] is 1-based\\n                    answer += j + 1;\\n                    used[j] = true;\\n                    break;\\n                }\\n                \\n                --offset;\\n            }\\n            \\n            // From observation 3 above\\n            remainder %= factorials[i];\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\nTime complexity: O(n^2). Calculating factorials is O(n). Getting the correct num based on offset is upper-bounded at n + (n - 1) + ... + 1 or O(n^2).\\nSpace complexity: O(n). Both factorials and used arrays are n length.",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        // Idea: calculate this by math\\n        //\\n        // Observation 1: (k - 1) / (n - 1)!  + 1 determines\\n        // which number in [1, n] comes first\\n        // E.g. If n = 3, k = 3,\\n        // then (3 - 1) / (3 - 1)! + 1\\n        // = 2 / 2 + 1\\n        // = 2\\n        // Thus, \"2xx\" would be the answer\\n        //\\n        // Observation 2: The \"xx\" part in \"2xx\" can be calculated\\n        // similarly as a subproblem. This is therefore a recursion problem,\\n        // solvable with the usual dynamic programming/iterative techniques.\\n        //\\n        // First, let\\'s calculate all factorials from 0 to n - 1\\n        // Not really needed to calculate 0!, but\\n        // 1) it helps to calculate 1! and\\n        // 2) it eliminates the need for special case code\\n        // when finding the last number in the answer.\\n        int[] factorials = new int[n];\\n        factorials[0] = 1;\\n        \\n        for (int i = 1; i < factorials.length; ++i) {\\n            factorials[i] = i * factorials[i - 1];\\n        }\\n        \\n        // Use an array to mark which numbers in [1, n] have already\\n        // been used in the answer\\n        // Be mindful of 1-based indexing in question vs. zero-based\\n        // indexing in code\\n        boolean[] used = new boolean[n];\\n        \\n        // This is the recursive part, solved iteratively\\n        //\\n        // Observation 3: Since 0th (first) num can be found via\\n        // (k - 1) / (n - 1)!, the 1th (second) num can be found\\n        // similarly using a k\\'\\n        // k\\' is the remainder of (k - 1) / (n - 1)!, e.g., what is\\n        // left over after using the quotient of (k - 1) / (n - 1)!\\n        // to find the previous index.\\n        // Let\\'s start with k - 1 as the remainder to find the 0th num.\\n        // Use k - 1 because k is 1-based indexing as phrased in the\\n        // question but in code we use zero-based indexing.\\n        int remainder = k - 1;\\n        \\n        // Accumulator for answer\\n        // Use StringBuilder if you want further optimization\\n        String answer = \"\";\\n        \\n        // Iterate from n - 1 down to 0\\n        // From observation 2 above\\n        for (int i = n - 1; i >= 0; --i) {\\n            // offset is the index of the list of unused nums in [1, n]\\n            // This is from observation 1 above.\\n            // For example, if n = 3, k = 3,\\n            // offset = (3 - 1) / (3 - 1)! = 1\\n            // 1th num in the list [1, 2, 3] is 2\\n            int offset = remainder / factorials[i];\\n            \\n            // iterate through the used array and find the offset-th unused num\\n            for (int j = 0; j < used.length; ++j) {\\n                if (used[j]) {\\n                    continue;\\n                }\\n                \\n                // Algorithm guarantees this will be matched once per loop\\n                // through the used array.\\n                //\\n                // Proof: offset is upper-bounded by i, which decreases by 1\\n                // every iteration of the outer loop. This is true because\\n                // remainder cannot exceed factorials[i + 1]. Also, we use one\\n                // num each iteration of the outer loop, so offset is always\\n                // less than or equal to the number of unused nums left.\\n                if (offset == 0) {\\n                    // j is zero-based index, but [1,n] is 1-based\\n                    answer += j + 1;\\n                    used[j] = true;\\n                    break;\\n                }\\n                \\n                --offset;\\n            }\\n            \\n            // From observation 3 above\\n            remainder %= factorials[i];\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22506,
                "title": "c-clean-code-with-explanation",
                "content": "1. Given n digits there will be total of `(n * (n-1) * ... * 2 * 1)` different permutations. - the 1st digit you have `n` options, 2nd digit you have `n-1`, ... last digit you only have `1` option.\\n2. Your choices to pick different number at each digit will form different groups of permutations. Example: Your choice for the `n` different number at the `1st` digit will result in `n` groups of permutations, start with `1` ~ `n`. and each group will contain `(n-1) * ... * 2 * 1)` permutations which can be further divided into n-1 groups, and so on...\\n3. Given `0-based` sequence index `k`, what is the 1st `number` of the `k`th permutation depend on which `group` it is in, and this can be calculated by `k / $group_size`, which is `k / ((n-1)*...*2*1)`, and within that group, its index will be `k % ((n-1)*...*2*1)`, and `k` should be updated as that.\\n4. Once 1st number is determined, the 2nd number can be determined by which sub-group it belongs to within the first level group, which again can be calculated by `k / $group_size`.\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string digits = \"123456789\"; // digits pool, as numbers being picked 1 by 1, options will be reduced, pool will shrink\\n        /* Calculate the weight as n factorial, it is actaully the weight on the n+1 th digit */\\n        int weight = 1; // total number of permutations will be (n*...*2*1)\\n        for (int d = 1; d <= n; d++) weight *= d; // k options for kth digit\\n        --k %= weight; // use 0-based k, and module to weight;\\n        string s(n, '\\\\0');\\n        for (int i = 0; i < n; i++) {\\n            weight /= (n - i);  // digit[0] have n options, digit[i] have n - i options\\n            int d = k / weight; // calculate digit id\\n            s[i] = digits[d];\\n            digits.erase(d, 1); // reduce digit from the pool, for it can only be used 1 time\\n            k %= weight;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string digits = \"123456789\"; // digits pool, as numbers being picked 1 by 1, options will be reduced, pool will shrink\\n        /* Calculate the weight as n factorial, it is actaully the weight on the n+1 th digit */\\n        int weight = 1; // total number of permutations will be (n*...*2*1)\\n        for (int d = 1; d <= n; d++) weight *= d; // k options for kth digit\\n        --k %= weight; // use 0-based k, and module to weight;\\n        string s(n, '\\\\0');\\n        for (int i = 0; i < n; i++) {\\n            weight /= (n - i);  // digit[0] have n options, digit[i] have n - i options\\n            int d = k / weight; // calculate digit id\\n            s[i] = digits[d];\\n            digits.erase(d, 1); // reduce digit from the pool, for it can only be used 1 time\\n            k %= weight;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954305,
                "title": "best-o-n-n-solution",
                "content": "# Approach\\nMath\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector <int> nums;\\n        int fact = 1;\\n        for (int i = 1; i <= n; i++) {\\n            nums.push_back(i);\\n            fact *= i;\\n        }\\n        k--;\\n        string ans = \"\";\\n        while (n != 0) {\\n            fact /= n;\\n            int ind = k / fact;\\n            k -= ind * fact;\\n            ans += to_string(nums[ind]);\\n            nums.erase(nums.begin() + ind);\\n            n--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector <int> nums;\\n        int fact = 1;\\n        for (int i = 1; i <= n; i++) {\\n            nums.push_back(i);\\n            fact *= i;\\n        }\\n        k--;\\n        string ans = \"\";\\n        while (n != 0) {\\n            fact /= n;\\n            int ind = k / fact;\\n            k -= ind * fact;\\n            ans += to_string(nums[ind]);\\n            nums.erase(nums.begin() + ind);\\n            n--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843054,
                "title": "5-line-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> vec;\\n        for(int i=0;i<n;i++) vec.push_back(i+1);\\n        for(int i=0;i<k-1;i++) next_permutation(vec.begin(),vec.end());\\n        string s;\\n        for(int i=0;i<n;i++) s+=\\'0\\'+vec[i];\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> vec;\\n        for(int i=0;i<n;i++) vec.push_back(i+1);\\n        for(int i=0;i<k-1;i++) next_permutation(vec.begin(),vec.end());\\n        string s;\\n        for(int i=0;i<n;i++) s+=\\'0\\'+vec[i];\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091180,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int> v;\\n        for(int i=1;i<=n;i++)\\n        {\\n            v.push_back(i);\\n            if(i!=n)\\n            fact*=i;\\n        }\\n        k-=1;\\n        string s;\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=k/fact;\\n            k%=fact;\\n            if(n-i-1)\\n            fact/=(n-i-1);\\n            s+=(\\'0\\'+v[j]);\\n            v.erase(v.begin()+j);\\n        }\\n        return s;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int> v;\\n        for(int i=1;i<=n;i++)\\n        {\\n            v.push_back(i);\\n            if(i!=n)\\n            fact*=i;\\n        }\\n        k-=1;\\n        string s;\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=k/fact;\\n            k%=fact;\\n            if(n-i-1)\\n            fact/=(n-i-1);\\n            s+=(\\'0\\'+v[j]);\\n            v.erase(v.begin()+j);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013756,
                "title": "easy-solution-by-using-stl-permutation-sequence",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        string s;\\n        for(int i=1; i<=n; i++){\\n            s+=to_string(i);\\n        }\\n         vector<string>ans;\\n        do\\n        {\\n            ans.push_back(s);\\n        }while(next_permutation(s.begin(),s.end()));\\n        return ans[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        string s;\\n        for(int i=1; i<=n; i++){\\n            s+=to_string(i);\\n        }\\n         vector<string>ans;\\n        do\\n        {\\n            ans.push_back(s);\\n        }while(next_permutation(s.begin(),s.end()));\\n        return ans[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921581,
                "title": "15-ms-easy-understanding",
                "content": "# Complexity\\n- Time complexity: O(n) -> Linear\\n- Space complexity: O(n) -> To store the list[]\\n\\n# Code\\n```\\nimport math\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        stToRet = \"\"\\n        lst  = [str(i) for i in range(1,n+1)]\\n        \\n        while len(lst):\\n            n = len(lst)\\n            n1Fac = math.factorial(n-1)\\n            idxToRem = k/n1Fac-1 if (k%n1Fac==0) else k/n1Fac\\n            stToRet+= lst.pop(idxToRem)\\n            k = k%n1Fac\\n        return stToRet\\n```\\nYou Can also Look At My SDE Prep Repo [*`\\uD83E\\uDDE2 GitHub`*](https://github.com/Ayon-SSP/The-SDE-Prep)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport math\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        stToRet = \"\"\\n        lst  = [str(i) for i in range(1,n+1)]\\n        \\n        while len(lst):\\n            n = len(lst)\\n            n1Fac = math.factorial(n-1)\\n            idxToRem = k/n1Fac-1 if (k%n1Fac==0) else k/n1Fac\\n            stToRet+= lst.pop(idxToRem)\\n            k = k%n1Fac\\n        return stToRet\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445529,
                "title": "python-o-n-2-96-faster",
                "content": "```\\nimport math\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        ans = \"\"\\n        nums = [i for i in range(1,n+1)]\\n        for i in range(1,n+1):\\n            index = 0\\n            c = math.factorial(n-i)\\n            \\n            while c < k:\\n                index +=1\\n                k -= c\\n                \\n            ans += str(nums[index])\\n            del nums[index]\\n            \\n        return ans\\n            \\n            \\n```\\nIf you find it usefull ,do upvote",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        ans = \"\"\\n        nums = [i for i in range(1,n+1)]\\n        for i in range(1,n+1):\\n            index = 0\\n            c = math.factorial(n-i)\\n            \\n            while c < k:\\n                index +=1\\n                k -= c\\n                \\n            ans += str(nums[index])\\n            del nums[index]\\n            \\n        return ans\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 698758,
                "title": "0ms-c-solution-explained",
                "content": "This problem can be solved with recursive approach. \\n\\n### OBSERVATION:\\n* Given n, we\\'ll be having (n-1)! permutations starting with 1, (n-1)! permutations starting with 2, and so on.. So, each block is of size (n-1!).\\n* So, this can be used to find out the first digit of the required sequence. Say, n=4 and k=15, then, k/(n-1!) = 2.5 so, the required permutation will be lying somewhere in the 3rd block. So, the number starts with 3.\\n\\n### APPROACH:\\n* Kth Permutation sequence can be formed by choosing the 1st digit and then the rest of the digits one by one.\\n* We can find the first digit in the sequence, and then apply the same technique to keep finding the first digit of the remaining part of the sequence until the whole sequence is found.\\n\\n### EXAMPLE:\\n*  We can find the first digit in the number and keep updating n and k to find the first digit in the remaining part of the number.\\n*  Say, n=4 and k=15. Now, nums = {1,2,3,4}.  ind = ceil(k/(n-1!) = 3. So, num is 3{}{}{}. \\n*  k = k%(n-1!), n=n-1\\n*  Now, n=3, k=3. nums={1,2,4}. ind = ceil(3/2) = 2. So, num is 32{}{}.\\n*  n=2,k=1, nums={1,4}. ind = ceil(1/2) = 1. So, num is 321{}.\\n*  n=1, k=1, nums = {4}. ind=ceil(1/1)=1. So, nums is 3214.\\n\\n#### NOTE:  \\n* Think about the case when k becomes zero before n. When does this happen? k becomes zero when n-1!=k (coz, k = k%n-1!). This means that this is the last element in the corresponding block, and obviously in this case, the remaining part of the permutation is going to be all the remaining digits arranged in descending order. \\n* eg: n=3,k=2.  \\n\\n### PSEUDOCODE:\\n```  l = {1,2,3,..,N}\\n  result=0\\n   while(k&&n)\\n   {\\n\\t  ind = ceil(k/(n-1!)                            //finding the first digit\\n\\t   result = result*10 + l[ind]           //appending it to result\\n\\t   l.remove(l[ind])                            //removing the found digit from l\\n\\t   k = k%(n-1!)                                  //updating k and n\\n\\t   n = n-1\\n   }\\n   if(k==0)\\n\\t   reverse the list l and append it to result\\n\\treturn result\\n```\\n\\n### MY CODE:\\n```\\nstring getPermutation(int n, int k) {\\n        vector<int> numSet(n);\\n        for(int i=0;i<n;i++)\\n            numSet[i]=i+1;\\n        int fact[10] = {1};\\n        for(int i=1;i<=9;i++)\\n            fact[i] = fact[i-1]*(i);\\n        \\n        int ind,result=0;\\n        while(n&&k)\\n        {\\n            ind = ceil((double)k/fact[n-1]);\\n            result = (result*10)+numSet[ind-1];\\n            numSet.erase(numSet.begin()+(ind-1));\\n            k = k%(fact[n-1]);\\n            n = n-1;\\n        }\\n        if(k==0)\\n        {\\n            int t=numSet.size();\\n            for(int i=t-1;i>=0;i--)\\n                result = (result*10)+numSet[i];       \\n        }\\n        string st;\\n        st = st+to_string(result);\\n        return st;\\n    }\\n```\\n\\nPS: This is not O(n) solution... It takes O(n^2) coz the erase() function of vector will always create a new vector array and copy the original value to it except the erased one...\\n\\n\\n",
                "solutionTags": [],
                "code": "```  l = {1,2,3,..,N}\\n  result=0\\n   while(k&&n)\\n   {\\n\\t  ind = ceil(k/(n-1!)                            //finding the first digit\\n\\t   result = result*10 + l[ind]           //appending it to result\\n\\t   l.remove(l[ind])                            //removing the found digit from l\\n\\t   k = k%(n-1!)                                  //updating k and n\\n\\t   n = n-1\\n   }\\n   if(k==0)\\n\\t   reverse the list l and append it to result\\n\\treturn result\\n```\n```\\nstring getPermutation(int n, int k) {\\n        vector<int> numSet(n);\\n        for(int i=0;i<n;i++)\\n            numSet[i]=i+1;\\n        int fact[10] = {1};\\n        for(int i=1;i<=9;i++)\\n            fact[i] = fact[i-1]*(i);\\n        \\n        int ind,result=0;\\n        while(n&&k)\\n        {\\n            ind = ceil((double)k/fact[n-1]);\\n            result = (result*10)+numSet[ind-1];\\n            numSet.erase(numSet.begin()+(ind-1));\\n            k = k%(fact[n-1]);\\n            n = n-1;\\n        }\\n        if(k==0)\\n        {\\n            int t=numSet.size();\\n            for(int i=t-1;i>=0;i--)\\n                result = (result*10)+numSet[i];       \\n        }\\n        string st;\\n        st = st+to_string(result);\\n        return st;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 696851,
                "title": "python-3-just-a-function-composition-fully-explained",
                "content": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        return \\'\\'.join(next(dropwhile(lambda t: t[0] < k, enumerate(permutations(list(\"123456789\"[0:n])))))[1])\\n```\\n\\nThe solution just get composed from the existing function toolset following the thought train:\\n\\n`list(\"123456789\"[0:n])` elements of a permutation\\n\\n`permutations(list(\"123456789\"[0:n]))` **lazy** sequence of all permutations\\n\\n`enumerate(permutations(list(\"123456789\"[0:n])), start=1)` the same, but now each permutation is wrapped into a tuple with its order number, starting with `1`\\n\\n`dropwhile(lambda t: t[0] < k, enumerate(permutations(list(\"123456789\"[0:n]))))` the same, but with first `k - 1` permutations skipped\\n\\n`next(dropwhile(lambda t: t[0] < k, enumerate(permutations(list(\"123456789\"[0:n])))))` the tuple having number `k` and the associated sought permutation\\n\\n`\\'\\'.join(next(dropwhile(lambda t: t[0] < k, enumerate(permutations(list(\"123456789\"[0:n])))))[1])` converting the permutation from this tuple to string, mission accomplished!\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        return \\'\\'.join(next(dropwhile(lambda t: t[0] < k, enumerate(permutations(list(\"123456789\"[0:n])))))[1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 268361,
                "title": "python-two-solutions-backtracking-40ms-and-math-36ms",
                "content": "Approach 1:  backtracking.\\nfirstly, we permute and count, got one and `k-=1`, when k==0, that is the kth. But it\\'s too slow, consider that, we permute`1234`,  when choose `1`, there are `a = factorial(len(rest))` permutations, if k > a, we don\\'t need permute starts with `1`. And minus the total `a`.\\n\\u6B64\\u9898\\u548C 46.Permutations \\u5F88\\u50CF\\uFF0C\\u4F46\\u662F\\u4F60\\u4E0D\\u80FD\\u5168\\u6392\\u51FA\\u6765\\u518D\\u901A\\u8FC7\\u7D22\\u5F15\\u6C42\\uFF0C\\u90A3\\u6837\\u4F1A\\u8D85\\u65F6\\u3002\\n\\n```python\\ndef getPermutation(self, n: int, k: int) -> str:\\n    self.k = k\\n    \\n    def backtrack(s, rest):\\n        if not rest:\\n            self.k -= 1\\n            if self.k == 0:\\n                return s\\n            return \\'\\'\\n            \\n        for i in range(len(rest)):\\n            if self.k > math.factorial(len(rest)-1):\\n                self.k -= math.factorial(len(rest)-1)\\n                continue\\n            old = s\\n            s += rest[i]\\n            ans = backtrack(s, rest[:i]+rest[i+1:])\\n            if ans: return ans\\n            s = old\\n        return \\'\\'\\n    nums = list(map(str, range(1, n+1)))\\n    return backtrack(\\'\\', nums)\\n```\\n\\nApproach 2:  math\\n\\n```python\\ndef getPermutation(self, n: int, k: int) -> str:\\n    ans = \\'\\'\\n    nums = list(map(str, range(1, n+1)))\\n    fact = math.factorial(len(nums)-1)\\n    k -= 1\\n    while k:\\n        i, k = divmod(k, fact)\\n        ans += nums.pop(i)\\n        fact //= len(nums)            \\n    ans += \\'\\'.join(nums)\\n    return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Backtracking"
                ],
                "code": "```python\\ndef getPermutation(self, n: int, k: int) -> str:\\n    self.k = k\\n    \\n    def backtrack(s, rest):\\n        if not rest:\\n            self.k -= 1\\n            if self.k == 0:\\n                return s\\n            return \\'\\'\\n            \\n        for i in range(len(rest)):\\n            if self.k > math.factorial(len(rest)-1):\\n                self.k -= math.factorial(len(rest)-1)\\n                continue\\n            old = s\\n            s += rest[i]\\n            ans = backtrack(s, rest[:i]+rest[i+1:])\\n            if ans: return ans\\n            s = old\\n        return \\'\\'\\n    nums = list(map(str, range(1, n+1)))\\n    return backtrack(\\'\\', nums)\\n```\n```python\\ndef getPermutation(self, n: int, k: int) -> str:\\n    ans = \\'\\'\\n    nums = list(map(str, range(1, n+1)))\\n    fact = math.factorial(len(nums)-1)\\n    k -= 1\\n    while k:\\n        i, k = divmod(k, fact)\\n        ans += nums.pop(i)\\n        fact //= len(nums)            \\n    ans += \\'\\'.join(nums)\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 22539,
                "title": "java-recursive-and-iterative",
                "content": "Iterative:\\n```\\n    public String getPermutation(int n, int k) {\\n        \\n        // e.g n = 5\\n        // [1][1][2][6][24]\\n        int[] factorial = new int[n];\\n        factorial[0] = 1;\\n        \\n        for(int i = 1; i < n; i++) {\\n            factorial[i] = factorial[i-1] * i;\\n        }\\n        \\n        ArrayList<Integer> numbers = new ArrayList<>();\\n        for(int i = 1; i <= n; i++) {\\n            numbers.add(i);\\n        }\\n        \\n        String res = \"\";\\n        for(int i = n-1; i >= 0; i--) {\\n            \\n            int num = (k-1)/factorial[i];\\n            res += numbers.get(num);\\n            k -= num * factorial[i];\\n            numbers.remove(num);\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\nRecursive:\\n```\\n    public String getPermutation(int n, int k) {\\n        \\n        // recursive\\n        // how do you make the problem smaller?\\n        List<Integer> list = new ArrayList<>();\\n        // 1,1,2,6\\n        int[] factorials = new int[n];\\n        factorials[0] = 1;\\n        for(int i = 1; i < n; i++) {\\n            factorials[i] = factorials[i-1] * i;\\n        }\\n        \\n        for(int i = 1; i <= n; i++) {\\n            list.add(i);\\n        }\\n        \\n        return helper(list, k, factorials);\\n    }\\n    \\n    private String helper(List<Integer> list, int k, int[] factorials) {\\n        \\n        if(list.size() == 0) {\\n            return \"\";\\n        }\\n\\n        int num = (k-1)/factorials[list.size()-1];\\n        String str = \"\" + list.get(num);\\n        k -= num * factorials[list.size()-1];\\n        list.remove(num);\\n\\n        return str+helper(list, k, factorials);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String getPermutation(int n, int k) {\\n        \\n        // e.g n = 5\\n        // [1][1][2][6][24]\\n        int[] factorial = new int[n];\\n        factorial[0] = 1;\\n        \\n        for(int i = 1; i < n; i++) {\\n            factorial[i] = factorial[i-1] * i;\\n        }\\n        \\n        ArrayList<Integer> numbers = new ArrayList<>();\\n        for(int i = 1; i <= n; i++) {\\n            numbers.add(i);\\n        }\\n        \\n        String res = \"\";\\n        for(int i = n-1; i >= 0; i--) {\\n            \\n            int num = (k-1)/factorial[i];\\n            res += numbers.get(num);\\n            k -= num * factorial[i];\\n            numbers.remove(num);\\n        }\\n        \\n        return res;\\n    }\\n```\n```\\n    public String getPermutation(int n, int k) {\\n        \\n        // recursive\\n        // how do you make the problem smaller?\\n        List<Integer> list = new ArrayList<>();\\n        // 1,1,2,6\\n        int[] factorials = new int[n];\\n        factorials[0] = 1;\\n        for(int i = 1; i < n; i++) {\\n            factorials[i] = factorials[i-1] * i;\\n        }\\n        \\n        for(int i = 1; i <= n; i++) {\\n            list.add(i);\\n        }\\n        \\n        return helper(list, k, factorials);\\n    }\\n    \\n    private String helper(List<Integer> list, int k, int[] factorials) {\\n        \\n        if(list.size() == 0) {\\n            return \"\";\\n        }\\n\\n        int num = (k-1)/factorials[list.size()-1];\\n        String str = \"\" + list.get(num);\\n        k -= num * factorials[list.size()-1];\\n        list.remove(num);\\n\\n        return str+helper(list, k, factorials);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 22610,
                "title": "share-my-0ms-c-solution-with-explanation",
                "content": "The question is:\\n\\nThe **set *[1,2,3,\\u2026,n]*** contains a total of ***n !*** ***unique* permutations**.\\n\\nBy listing and labeling all of the permutations ***in order***,\\nWe get the following sequence (ie, for ***n = 3***):\\n\\n - 1  \"***1*** 23\"\\n - 2  \"***1*** 32\"\\n - 3  \"***2*** 13\"\\n - 4  \"***2*** 31\"\\n - 5  \"***3*** 12\"\\n - 6  \"***3*** 21\"\\n\\nGiven ***n*** and ***k***, return the ***kth*** permutation sequence.\\n\\n**IMPORTANT : note the equation *N ! = N \\xd7 (N - 1) !***\\n\\nHere, ***3 ! = 3 \\xd7 2 !***, Let's get into the problem when ***n = 3***.\\n\\n***First***, we need to get the ***TOP DIGIT***. As listed above, the ***TOP DIGIT*** can be ***1, 2 or 3***.\\n\\n***1st*** and ***2nd*** 's ***TOP DIGIT*** is ***1***.\\n\\n***3rd*** and ***4th*** 's ***TOP DIGIT*** is ***2***.\\n\\n***5th*** and ***6th*** 's ***TOP DIGIT*** is ***3***.\\n\\nThe total ***n !*** is divided into ***3 parts***.\\n\\nDo you find some ***regularities*** when ***n = 3***?\\n\\nIf not, we can ***minus k by 1***, set p = k - 1, and then? \\n\\n - If ***p / (n - 1) ! = 0 (k = 1 and 2)*** , ***TOP DIGIT*** is ***1***.\\n - If ***p/ (n - 1) ! = 1 (k = 3 and 4)*** , ***TOP DIGIT*** is ***2***.\\n - If ***p / (n - 1) ! = 2 (k = 5 and 6)*** , ***TOP DIGIT*** is ***3***.\\n\\nAnd this is the ***FIRST RULE***. \\n\\n----------\\n## FIRST RULE ##\\n\\n***n !*** can be ***DIVIDED*** into ***n PARTS***, and the ***TOP DIGIT*** of ***pth (starts with 0) PART*** equals to ***p / (n - 1) ! + 1***\\n\\n----------\\n**Q** : how about the ***REST***?\\n\\n**A** : If the ***FIRST TOP DIGIT*** is determined, the same method can be used to find the ***SECOND TOP DIGIT***, and the ***THIRD TOP DIGIT ......***, but a little bit ***DIFFERENT***.\\n\\nFor example, if the ***FIRST TOP DIGIT A0*** is determined, \\n\\nthe total number of ***unique* permutations *STARTS WITH A0*** is ***(n - 1) !***.\\n\\nAs the ***FIRST RULE***, ***(n - 1) !*** can be ***DIVIDED*** into ***n - 1 PARTS***, and the ***TOP DIGIT*** of ***p' th PART*** equals to ***p'   / (n - 2) ! + 1***\\n\\n**NOTICE**: here ***p'*** is the **INTERNAL** sequence number of the unique permutations which ***starts with A0***\\n\\n----------\\n## SECOND RULE ##\\n\\n***p'*** is ***p*** in the ***SECOND ROUND***, and ***p' = p % (n - 1) !***\\n\\nWe can find the ***SECOND TOP DIGIT A1*** by calculate ***p' / (n - 2) ! + 1***,\\n\\nand ***p*** in the ***THIRD ROUND*** is ***p''***, and ***p'' = p' % (n - 2) !***\\n\\n***..............................***\\n\\nThis is the ***SECOND RULE***.\\n\\n----------\\n**Q** : Which number will be used as ***A0, A1, ...* (the *TOP DIGITS*)**?\\n\\n**A** : At the ***FIRST ROUND***, ***TOP DIGIT A0*** equals to  ***p / (n - 1) ! + 1***.\\n\\nWhen a number in [1,9] is ***USED*** as ***A0***, \\n\\nwe need to find the ***p' / (n - 2) ! + 1* SMALLEST** number in the ***REST*** to be ***A1***,\\n\\nand we need to find the ***p'' / (n - 3) ! + 1* SMALLEST** number in the ***REST*** to be ***A2***,\\n\\n***...................................***\\n\\n**IMPORTANCE** : To get this, a **size of *9 VECTOR*** should be set as a ***GLOBAL VARIABLE*** (or ***DATA MEMBER***), and let its ***q th*** element to be ***q + 1***\\n\\nNo matter which number is removed from the vector, its ***q th*** element will ***ALWAYS*** be the ***q th*** ***SMALLEST*** of the rest.\\n\\n----------\\n**Q** : When will the loop ***STOPs***?\\n\\n**A** : Each round we calculate ***p(m) = p(m - 1) % (n - m) !***,\\n\\nand there are ***n - m* *DIGITs*** which are **NOT** determined.\\n\\nIf ***n - m = 2***, there will be ***2* *DIGITs*** which are **NOT** determined,\\n\\nwhich means there are ***ONLY 2*** numbers left in the ***VECTOR***.\\n\\nNow, we can directly set the ***LAST DIGIT*** and the ***2nd LAST DIGIT***.\\n\\nWhen ***n - m = 2***, if p(m) = 0, the ***SMALLER of the two (A0A1...AB and A0A1...BA)*** will be returned,\\n\\nso ***LAST DIGIT*** is set as the ***1st element of the vector*** and the ***2nd LAST DIGIT*** the ***0th***.\\n\\nif p(m) = 1, the ***LARGER of the two (A0A1...AB and A0A1...BA)*** will be returned,\\n\\nso ***LAST DIGIT*** is set as the ***0th element of the vector*** and the ***2nd LAST DIGIT*** the ***1st***.\\n\\n----------\\n\\n***My code:***\\n\\n    class Solution {\\n    public:\\n\\n    int factorial(int n)\\n    {\\n        if(n == 1) return 1;\\n        return n * factorial(n - 1);\\n    }\\n\\n    void numberStrList(int n)\\n    {\\n           rtn = string (n, '0');\\n           record = vector<int>(n,1);\\n           for(int i = 0; i < record.size(); i++)\\n           {\\n                 record[i] += i;\\n           }\\n    }\\n\\n    string getPermutation(int n, int k) {\\n        numberStrList(n);\\n        //start from 0\\n        k = k - 1;\\n        \\n        if(n == 1)\\n        {\\n             if(k == 0)\\n             {\\n                 return \"1\";\\n             }\\n             return \"\";\\n        }\\n        for(int i = 1; i < n - 1; i++)\\n        {\\n              rtn[i - 1] += record[k / factorial(n - i)];\\n              record.erase (record.begin() + k / factorial(n - i));\\n              k = k % factorial(n - i);\\n        }\\n        rtn[n - 2] += record[k^0];\\n        rtn[n - 1] += record[k^1];\\n        return rtn;\\n      }\\n     private:\\n     vector<int> record;\\n     string rtn;\\n     };",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\n    public:\\n\\n    int factorial(int n)\\n    {\\n        if(n == 1) return 1;\\n        return n * factorial(n - 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 22605,
                "title": "python-i-think-this-is-clean-code-with-some-of-my-explanation",
                "content": "If we have n numbers then the total combinations would be factorial(n) which means same starting number should have (n - 1)! sequences.  \\n\\nIf we do k mod (n - 1)! then we can get the corresponding starting number and append to the result.\\n\\nNote that we need to maintain another array to mark visited numbers(I take remove to make sure we will not revisit the number again, each remove takes O(n) time )\\n\\nThe total time complexity would be O(n^2).\\n\\n    class Solution(object):\\n        def getPermutation(self, n, k):\\n            \"\"\"\\n            :type n: int\\n            :type k: int\\n            :rtype: str\\n            \"\"\"\\n            nums = map(str, range(1, 10))\\n            k -= 1\\n            factor = 1\\n            for i in range(1, n):\\n                factor *= i\\n            res = []\\n            for i in reversed(range(n)):\\n                res.append(nums[k / factor])\\n                nums.remove(nums[k / factor])\\n                if i != 0:\\n                    k %= factor\\n                    factor /= i\\n            return \"\".join(res)",
                "solutionTags": [],
                "code": "If we have n numbers then the total combinations would be factorial(n) which means same starting number should have (n - 1)! sequences.  \\n\\nIf we do k mod (n - 1)! then we can get the corresponding starting number and append to the result.\\n\\nNote that we need to maintain another array to mark visited numbers(I take remove to make sure we will not revisit the number again, each remove takes O(n) time )\\n\\nThe total time complexity would be O(n^2).\\n\\n    class Solution(object):\\n        def getPermutation(self, n, k):\\n            \"\"\"\\n            :type n: int\\n            :type k: int\\n            :rtype: str\\n            \"\"\"\\n            nums = map(str, range(1, 10))\\n            k -= 1\\n            factor = 1\\n            for i in range(1, n):\\n                factor *= i\\n            res = []\\n            for i in reversed(range(n)):\\n                res.append(nums[k / factor])\\n                nums.remove(nums[k / factor])\\n                if i != 0:\\n                    k %= factor\\n                    factor /= i\\n            return \"\".join(res)",
                "codeTag": "Java"
            },
            {
                "id": 22633,
                "title": "easy-to-understand-solution-with-sample",
                "content": "    class Solution {\\n        int getPermutationNumber(int n) {\\n            int result = 1;\\n            for(int i=1;i<=n;++i) {\\n                result *=i;\\n            }\\n            \\n            return result;\\n        }\\n        \\n    public:\\n        string getPermutation(int n, int k) {\\n            // 1234, 1243, 1324, 1342, 1423,1432,\\n            // n*(n-1)!\\n            // k/(n-1)!\\n            // k= k%(n-1)!\\n            // 123: n=3, k=4  => k=4-1 (for indexing from 0)\\n            // 3/(2!)=1, head[1]==2, k%(2!) = 1\\n            // 1/(1!)=1, head[1]==3, k%(1!) = 0\\n            // 0/(0!)=0, head[0]=1\\n            vector<int> result;        \\n            vector<int> nums;\\n            for(int i=1;i<=n;++i) {\\n                nums.push_back(i);\\n            }\\n            \\n            k=k-1;\\n            for(int i=0;i<n;++i) {\\n                int perms = getPermutationNumber(n-1-i);\\n                int index = k/perms;\\n                result.push_back(nums[index]);\\n                k%=perms;\\n                nums.erase(nums.begin()+index);\\n            }\\n            \\n            string s=\"\";\\n            for(int i=0;i<result.size();++i) {\\n                s += std::to_string(result[i]);\\n            }\\n            \\n            return s;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        int getPermutationNumber(int n) {\\n            int result = 1;\\n            for(int i=1;i<=n;++i) {\\n                result *=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3473883,
                "title": "after-looking-this-you-won-t-belive-this-is-hard",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/057ba9ba-66e9-4bf2-9008-3b80680d7aca_1682949102.7328444.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        \\n        int fact = 1; // initialize a variable to store the factorial of n\\n\\n        List<Integer> numbers = new ArrayList<>(); // create a list to store the numbers from 1 to n\\n\\n        // calculate the factorial of n and add numbers from 1 to n to the list\\n        for(int i = 1; i < n; i++){\\n            fact = fact * i;\\n            numbers.add(i);\\n        }\\n        numbers.add(n);\\n\\n        String ans = \"\"; // initialize an empty string to store the answer\\n\\n        k = k - 1; // since indexing starts from 0, subtract 1 from k\\n\\n        // loop until all numbers have been used\\n        while(true){\\n            ans = ans + numbers.get(k / fact); // add the number at index    k/fact    to the answer\\n            numbers.remove(k / fact); // remove the used number from the list\\n\\n            // if all numbers have been used, break out of the loop\\n            if(numbers.size() == 0){\\n                break;\\n            }\\n\\n            k = k % fact; // calculate the remainder of    k/fact    and assign it to k\\n            fact = fact / numbers.size(); // divide the factorial by the size of the remaining list\\n        }\\n        return ans; // return the answer\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        \\n        int fact = 1; // initialize a variable to store the factorial of n\\n\\n        List<Integer> numbers = new ArrayList<>(); // create a list to store the numbers from 1 to n\\n\\n        // calculate the factorial of n and add numbers from 1 to n to the list\\n        for(int i = 1; i < n; i++){\\n            fact = fact * i;\\n            numbers.add(i);\\n        }\\n        numbers.add(n);\\n\\n        String ans = \"\"; // initialize an empty string to store the answer\\n\\n        k = k - 1; // since indexing starts from 0, subtract 1 from k\\n\\n        // loop until all numbers have been used\\n        while(true){\\n            ans = ans + numbers.get(k / fact); // add the number at index    k/fact    to the answer\\n            numbers.remove(k / fact); // remove the used number from the list\\n\\n            // if all numbers have been used, break out of the loop\\n            if(numbers.size() == 0){\\n                break;\\n            }\\n\\n            k = k % fact; // calculate the remainder of    k/fact    and assign it to k\\n            fact = fact / numbers.size(); // divide the factorial by the size of the remaining list\\n        }\\n        return ans; // return the answer\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091157,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int> v;\\n        for(int i=1;i<=n;i++)\\n        {\\n            v.push_back(i);\\n            if(i!=n)\\n            fact*=i;\\n        }\\n        k-=1;\\n        string s;\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=k/fact;\\n            k%=fact;\\n            if(n-i-1)\\n            fact/=(n-i-1);\\n            s+=(\\'0\\'+v[j]);\\n            v.erase(v.begin()+j);\\n        }\\n        return s;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int> v;\\n        for(int i=1;i<=n;i++)\\n        {\\n            v.push_back(i);\\n            if(i!=n)\\n            fact*=i;\\n        }\\n        k-=1;\\n        string s;\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=k/fact;\\n            k%=fact;\\n            if(n-i-1)\\n            fact/=(n-i-1);\\n            s+=(\\'0\\'+v[j]);\\n            v.erase(v.begin()+j);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013753,
                "title": "easy-solution-by-using-stl-permutation-sequence",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        string s;\\n        for(int i=1; i<=n; i++){\\n            s+=to_string(i);\\n        }\\n         vector<string>ans;\\n        do\\n        {\\n            ans.push_back(s);\\n        }while(next_permutation(s.begin(),s.end()));\\n        return ans[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        string s;\\n        for(int i=1; i<=n; i++){\\n            s+=to_string(i);\\n        }\\n         vector<string>ans;\\n        do\\n        {\\n            ans.push_back(s);\\n        }while(next_permutation(s.begin(),s.end()));\\n        return ans[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376420,
                "title": "c-solution-4-approaches-stl-backtracking-iterative-recursion",
                "content": "**1st Appraoch\\n(USING STL - next_permutation)**\\n```\\n\\tstring getPermutation(int n, int k) {\\n        string s;\\n        for( int i=1; i<=n; i++)\\n            s.push_back( i+\\'0\\');\\n        \\n        while( k!=1){\\n            next_permutation(s.begin(), s.end());\\n            k--;\\n        }\\n        return s;\\n    }\\n```\\n\\n***2nd Approach- Backtracking (TLE)***\\n```\\n\\tvoid permut( string &s, int ind, set<string> &s1){\\n        if( ind == s.size()){\\n            s1.insert(s);\\n            return;\\n        }\\n        \\n        for( int i=ind; i<s.size(); i++){\\n            swap( s[i], s[ind]);\\n            permut( s, ind+1, s1);\\n            swap( s[i], s[ind]);\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string s;\\n        for( int i=1; i<n+1; i++) s.push_back( i+\\'0\\');\\n        set<string> s1;\\n        permut( s, 0, s1);\\n        for( auto i: s1){\\n            if( k==1){\\n                return i;\\n            }\\n            --k;\\n        }\\n        return \"\";\\n    }\\n```\\n\\n***Optimal Approach (  RECURSIVE)***\\n```\\n    void solve( int fact, vector<int> & v, int k, string &s){\\n        if( v.size()==0){\\n            return ;    \\n        }\\n        \\n        s = s+ to_string(v[k/fact]);\\n        v.erase(v.begin() + k/fact);\\n        if( v.size()!=0)\\n            solve( fact/v.size(), v, k%fact, s);\\n    }\\n    string getPermutation(int n, int k) {\\n        //calculating the factorial of n-1 numbers and making an array of numbers 1->n\\n        int fact =1;\\n        vector<int> v;\\n        for( int i=1; i<n;i++){\\n            fact *= i;\\n            v.push_back(i);\\n        }v.push_back(n);\\n        k= k-1; //for 0-based indexing\\n        string s =\"\";\\n        solve( fact, v, k, s);\\n        return s;\\n    }\\n```\\n\\n***Optimal Approach (Iterative)***\\n```\\nstring getPermutation(int n, int k) {\\n        //calculating the factorial of n-1 numbers and making an array of numbers 1->n\\n        int fact =1;\\n        vector<int> v;\\n        for( int i=1; i<n;i++){\\n            fact *= i;\\n            v.push_back(i);\\n        }v.push_back(n);\\n        k= k-1; //for 0-based indexing\\n        string s =\"\";\\n        while( true){\\n            s += to_string( v[ k/fact]);\\n            v.erase( v.begin()+ k/fact);\\n             k= k%fact;\\n            if( v.size()==0) break;\\n            fact /=v.size();\\n            \\n        }\\n       \\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n\\tstring getPermutation(int n, int k) {\\n        string s;\\n        for( int i=1; i<=n; i++)\\n            s.push_back( i+\\'0\\');\\n        \\n        while( k!=1){\\n            next_permutation(s.begin(), s.end());\\n            k--;\\n        }\\n        return s;\\n    }\\n```\n```\\n\\tvoid permut( string &s, int ind, set<string> &s1){\\n        if( ind == s.size()){\\n            s1.insert(s);\\n            return;\\n        }\\n        \\n        for( int i=ind; i<s.size(); i++){\\n            swap( s[i], s[ind]);\\n            permut( s, ind+1, s1);\\n            swap( s[i], s[ind]);\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string s;\\n        for( int i=1; i<n+1; i++) s.push_back( i+\\'0\\');\\n        set<string> s1;\\n        permut( s, 0, s1);\\n        for( auto i: s1){\\n            if( k==1){\\n                return i;\\n            }\\n            --k;\\n        }\\n        return \"\";\\n    }\\n```\n```\\n    void solve( int fact, vector<int> & v, int k, string &s){\\n        if( v.size()==0){\\n            return ;    \\n        }\\n        \\n        s = s+ to_string(v[k/fact]);\\n        v.erase(v.begin() + k/fact);\\n        if( v.size()!=0)\\n            solve( fact/v.size(), v, k%fact, s);\\n    }\\n    string getPermutation(int n, int k) {\\n        //calculating the factorial of n-1 numbers and making an array of numbers 1->n\\n        int fact =1;\\n        vector<int> v;\\n        for( int i=1; i<n;i++){\\n            fact *= i;\\n            v.push_back(i);\\n        }v.push_back(n);\\n        k= k-1; //for 0-based indexing\\n        string s =\"\";\\n        solve( fact, v, k, s);\\n        return s;\\n    }\\n```\n```\\nstring getPermutation(int n, int k) {\\n        //calculating the factorial of n-1 numbers and making an array of numbers 1->n\\n        int fact =1;\\n        vector<int> v;\\n        for( int i=1; i<n;i++){\\n            fact *= i;\\n            v.push_back(i);\\n        }v.push_back(n);\\n        k= k-1; //for 0-based indexing\\n        string s =\"\";\\n        while( true){\\n            s += to_string( v[ k/fact]);\\n            v.erase( v.begin()+ k/fact);\\n             k= k%fact;\\n            if( v.size()==0) break;\\n            fact /=v.size();\\n            \\n        }\\n       \\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 738232,
                "title": "c-math-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) \\n    {\\n        int fact[10] = {1,1,2,6,24,120,720,5040,40320,362880};\\n        string ans=\"\";\\n        string num=\"123456789\";\\n        k--;\\n        for(int i=n; i>0; i--)\\n        {\\n            int j=k/fact[i-1];\\n            k = k%fact[i-1];\\n            ans += num[j];\\n            num.erase(num.begin()+j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) \\n    {\\n        int fact[10] = {1,1,2,6,24,120,720,5040,40320,362880};\\n        string ans=\"\";\\n        string num=\"123456789\";\\n        k--;\\n        for(int i=n; i>0; i--)\\n        {\\n            int j=k/fact[i-1];\\n            k = k%fact[i-1];\\n            ans += num[j];\\n            num.erase(num.begin()+j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697280,
                "title": "java-clean-code-o-n-time-complexity-0-ms-time-98-57-faster",
                "content": "```\\nclass Solution {\\n \\n\\tpublic String getPermutation (int n, int k) {\\n\\t\\n\\t\\tint[] factorial = new int[n];\\n\\t\\tList<Integer> nums = new ArrayList<>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tnums.add (i + 1);\\n\\t\\t\\tfactorial[i] = i == 0 ? 1 : i * factorial[i - 1];\\n\\t\\t}\\n\\t\\t\\n\\t\\tStringBuilder ans = new StringBuilder ();\\n\\t\\twhile (n-- != 0) {\\n\\t\\t\\tans.append (nums.remove ((k - 1) / factorial[n]));\\n\\t\\t\\tk = (k - 1) % factorial[n] + 1;\\n\\t\\t}\\n\\t\\n\\t\\treturn ans.toString ();\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n \\n\\tpublic String getPermutation (int n, int k) {\\n\\t\\n\\t\\tint[] factorial = new int[n];\\n\\t\\tList<Integer> nums = new ArrayList<>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tnums.add (i + 1);\\n\\t\\t\\tfactorial[i] = i == 0 ? 1 : i * factorial[i - 1];\\n\\t\\t}\\n\\t\\t\\n\\t\\tStringBuilder ans = new StringBuilder ();\\n\\t\\twhile (n-- != 0) {\\n\\t\\t\\tans.append (nums.remove ((k - 1) / factorial[n]));\\n\\t\\t\\tk = (k - 1) % factorial[n] + 1;\\n\\t\\t}\\n\\t\\n\\t\\treturn ans.toString ();\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696369,
                "title": "1ms-easy-to-understand-solution",
                "content": "```\\npublic String getPermutation(int n, int k) {\\n       List<Integer> num = new LinkedList<Integer>();\\n        for (int i = 1; i <= n; i++) \\n        \\tnum.add(i);\\n        int[] fact = new int[n];  // factorial\\n        fact[0] = 1;\\n        for (int i = 1; i < n; i++) \\n        \\tfact[i] = i*fact[i-1];\\n        k = k-1;\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = n; i > 0; i--){\\n            int ind = k/fact[i-1];\\n            k = k%fact[i-1];\\n            sb.append(num.get(ind));\\n            num.remove(ind);\\n        }\\n        return sb.toString(); \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String getPermutation(int n, int k) {\\n       List<Integer> num = new LinkedList<Integer>();\\n        for (int i = 1; i <= n; i++) \\n        \\tnum.add(i);\\n        int[] fact = new int[n];  // factorial\\n        fact[0] = 1;\\n        for (int i = 1; i < n; i++) \\n        \\tfact[i] = i*fact[i-1];\\n        k = k-1;\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = n; i > 0; i--){\\n            int ind = k/fact[i-1];\\n            k = k%fact[i-1];\\n            sb.append(num.get(ind));\\n            num.remove(ind);\\n        }\\n        return sb.toString(); \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 431424,
                "title": "simple-java-solution-using-backtracking",
                "content": "```\\npublic String getPermutation(int n, int k) {\\n        List<String> result = new ArrayList<>();\\n        recursion(result,\"\", n, k,new boolean[n+1]);\\n        return result.get(k-1);\\n    }\\n    \\nprivate void recursion(List<String> result, String temp, int max, int k, boolean[] seen){\\n        \\n        if(temp.length()==max){\\n            result.add(new String(temp));\\n        }else{\\n            for(int i =1;i<=max;i++){\\n                if(result.size()==k)break;\\n                if(seen[i]) continue;\\n                seen[i] =true;\\n                String newStr = temp+i;\\n                recursion(result,newStr,max,k,seen);\\n                seen[i] = false;\\n            }\\n        }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\npublic String getPermutation(int n, int k) {\\n        List<String> result = new ArrayList<>();\\n        recursion(result,\"\", n, k,new boolean[n+1]);\\n        return result.get(k-1);\\n    }\\n    \\nprivate void recursion(List<String> result, String temp, int max, int k, boolean[] seen){\\n        \\n        if(temp.length()==max){\\n            result.add(new String(temp));\\n        }else{\\n            for(int i =1;i<=max;i++){\\n                if(result.size()==k)break;\\n                if(seen[i]) continue;\\n                seen[i] =true;\\n                String newStr = temp+i;\\n                recursion(result,newStr,max,k,seen);\\n                seen[i] = false;\\n            }\\n        }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 348350,
                "title": "java-solution-with-explanation",
                "content": "I was searching for proper answer got explanation in the below link.  I just added code and improved on explanation\\ncourtesy : https://www.lintcode.com/problem/permutation-sequence/note/187602\\nSince we need to fix one position each time me need next we need to get permutations for (n-1)!\\n\\n\\nwhen n = 4, the list is 1, 2, 3, 4 and k = 18\\nthe total number of permutations is\\nrow1: 1 + {2, 3, 4}: 1234, 1243, 1324, 1342, 1423, 1432\\n==> 3! = 6 (factor) (from 0 to 5)\\nrow2: 2 + {1, 3, 4}: 2134, 2143, 2314, 2341, 2413, 2431\\n==> 3! = 6 (from 6 to 11)\\nrow3: 3 + {1, 2, 4}: 3! (from 12 to 17)\\nrow4: 4 + {1, 2, 3}: 3! (from 18 to 23)\\nwhen k = 18, it means find the item from 0, then 17th is the permutation we want.\\n\\nSince K =18 means we need to go to 17th index \\nso \\nK--\\n\\nFind out the number on each position\\nwhile i = n = 4\\nlist: 1,2,3,4\\nindex = (k - 1)/ (i - 1)! = 17/6 = 2. index 2 means it is row3 beginning with 3, then remove 3 from the list {1,2,3,4}, then the list becomes {1,2,4}. update k = (k-1) % 6 = 5.**** Add 3 to output.****\\n\\nWhen n = 3 \\nrow 1 \\n1,2,4\\n1,4,2\\n\\nrow 2\\n2,1,4\\n2,4,1\\n\\nrow 3\\n4,1,2\\n4,2,1\\n\\nwhile i = n = 3, k = 5\\nlist: 1, 2, 4\\nindex = k / (i - 1)! = 5/2 = 2. index 2 means it is row3 beginning with 4, then remove 4 from the list {1, 2, 4}, then the list becomes {1, 4}. update k = k % 2 = 1. **** Add 4 to output.****\\n\\nWhen n = 2\\n1,2\\n\\nwhile i = n = 2, k = 1\\nlist: 1,2\\nindex = k/(i-1)! = 1/1 = 1. index 1 means it is row2 beginning with 2, then remove 2 from the list {1, 2}, then the list becomes {1}. update k = k % 1 = 0. Add 2 to the output.\\n\\nWhen n = 1\\n\\n1\\nwhile i = n = 1, k = 0\\nindex = 0, index 0 means it is row1 beginning with 1. Add 1 to the output\\n\\nEventually, the output is 3421\\n\\nWhy to Divide by Factorial ? \\n\\nThink about a simple case where you are finding the digits of a decimal number e.g. 4836. You can compute rightmost place by dividing 4836 by 1 then modulo 10 to get 6. Then 4836 by 10 modulo 10 to get 3, then 4836 by 100 modulo 10 to get 8 etc. We don\\'t need to change the number 4836 each time. Permutation case is similar but we use factorials instead of powers of 10 and modulus value changes.\\n\\nhttps://stackoverflow.com/questions/31216097/given-n-and-k-return-the-kth-permutation-sequence\\n\\nprivate  String getPermutation3(int n, int k) {\\n\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int i =1; i <= n ; i++){\\n            list.add(i);\\n        }\\n\\n        int[] fact = new int[n];\\n\\n       // Since we cannot divide a number by 0 we are fixing index 0 to 1\\n        fact[0] =1;\\n\\n        // Storing factorials for (n-1)!\\n\\n        for(int i = 1; i < n; i++){\\n            fact[i] = i*fact[i-1];\\n        }\\n        // if position is 3 we need index 2 so k--\\n       k--;\\n\\n        String s = \"\";\\n\\n        // We are coming from back as we need to get the position of character for (n-1)! and we have put factorial in\\n        // increasing order in our factorial array so to get last character we need to come from reverse\\n\\n        for(int i = n-1; i >=0 ; i--){\\n\\n            int index = k/fact[i];\\n\\n            s = s+ list.remove(index);\\n    // To go to next index\\n            k = k%fact[i];\\n        }\\n        return s;\\n    }\\n\\t\\n\\tHope This helps",
                "solutionTags": [],
                "code": "I was searching for proper answer got explanation in the below link.  I just added code and improved on explanation\\ncourtesy : https://www.lintcode.com/problem/permutation-sequence/note/187602\\nSince we need to fix one position each time me need next we need to get permutations for (n-1)!\\n\\n\\nwhen n = 4, the list is 1, 2, 3, 4 and k = 18\\nthe total number of permutations is\\nrow1: 1 + {2, 3, 4}: 1234, 1243, 1324, 1342, 1423, 1432\\n==> 3! = 6 (factor) (from 0 to 5)\\nrow2: 2 + {1, 3, 4}: 2134, 2143, 2314, 2341, 2413, 2431\\n==> 3! = 6 (from 6 to 11)\\nrow3: 3 + {1, 2, 4}: 3! (from 12 to 17)\\nrow4: 4 + {1, 2, 3}: 3! (from 18 to 23)\\nwhen k = 18, it means find the item from 0, then 17th is the permutation we want.\\n\\nSince K =18 means we need to go to 17th index \\nso \\nK--\\n\\nFind out the number on each position\\nwhile i = n = 4\\nlist: 1,2,3,4\\nindex = (k - 1)/ (i - 1)! = 17/6 = 2. index 2 means it is row3 beginning with 3, then remove 3 from the list {1,2,3,4}, then the list becomes {1,2,4}. update k = (k-1) % 6 = 5.**** Add 3 to output.****\\n\\nWhen n = 3 \\nrow 1 \\n1,2,4\\n1,4,2\\n\\nrow 2\\n2,1,4\\n2,4,1\\n\\nrow 3\\n4,1,2\\n4,2,1\\n\\nwhile i = n = 3, k = 5\\nlist: 1, 2, 4\\nindex = k / (i - 1)! = 5/2 = 2. index 2 means it is row3 beginning with 4, then remove 4 from the list {1, 2, 4}, then the list becomes {1, 4}. update k = k % 2 = 1. **** Add 4 to output.****\\n\\nWhen n = 2\\n1,2\\n\\nwhile i = n = 2, k = 1\\nlist: 1,2\\nindex = k/(i-1)! = 1/1 = 1. index 1 means it is row2 beginning with 2, then remove 2 from the list {1, 2}, then the list becomes {1}. update k = k % 1 = 0. Add 2 to the output.\\n\\nWhen n = 1\\n\\n1\\nwhile i = n = 1, k = 0\\nindex = 0, index 0 means it is row1 beginning with 1. Add 1 to the output\\n\\nEventually, the output is 3421\\n\\nWhy to Divide by Factorial ? \\n\\nThink about a simple case where you are finding the digits of a decimal number e.g. 4836. You can compute rightmost place by dividing 4836 by 1 then modulo 10 to get 6. Then 4836 by 10 modulo 10 to get 3, then 4836 by 100 modulo 10 to get 8 etc. We don\\'t need to change the number 4836 each time. Permutation case is similar but we use factorials instead of powers of 10 and modulus value changes.\\n\\nhttps://stackoverflow.com/questions/31216097/given-n-and-k-return-the-kth-permutation-sequence\\n\\nprivate  String getPermutation3(int n, int k) {\\n\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int i =1; i <= n ; i++){\\n            list.add(i);\\n        }\\n\\n        int[] fact = new int[n];\\n\\n       // Since we cannot divide a number by 0 we are fixing index 0 to 1\\n        fact[0] =1;\\n\\n        // Storing factorials for (n-1)!\\n\\n        for(int i = 1; i < n; i++){\\n            fact[i] = i*fact[i-1];\\n        }\\n        // if position is 3 we need index 2 so k--\\n       k--;\\n\\n        String s = \"\";\\n\\n        // We are coming from back as we need to get the position of character for (n-1)! and we have put factorial in\\n        // increasing order in our factorial array so to get last character we need to come from reverse\\n\\n        for(int i = n-1; i >=0 ; i--){\\n\\n            int index = k/fact[i];\\n\\n            s = s+ list.remove(index);\\n    // To go to next index\\n            k = k%fact[i];\\n        }\\n        return s;\\n    }\\n\\t\\n\\tHope This helps",
                "codeTag": "Unknown"
            },
            {
                "id": 309634,
                "title": "swift-88-beat-factorial-trix-trixy-hobbits-m-a-t-h-l-o-l",
                "content": "```\\nclass Solution {\\n    func getPermutation(_ n: Int, _ k: Int) -> String {\\n        \\n        var fac = [Int](repeating: 1, count: n + 1)\\n        for i in 1..<(n+1) { fac[i] = fac[i - 1] * i }\\n        fac.reverse()\\n        \\n        var k = k - 1\\n        \\n        var list = [Int](repeating: 0, count: n)\\n        for i in 1..<(n + 1) { list[i - 1] = i }\\n        \\n        var res = [Int]()\\n        \\n        for i in 1..<(n + 1) {\\n            var index = k / fac[i]\\n            res.append(list[index])\\n            list.remove(at: index)    \\n            k -= fac[i] * index\\n        }\\n        \\n        return res.compactMap { String($0) }.joined()\\n    }\\n}\\n```\\n\\nThis is the same concept as previous solutions. \\n\\nIt is all stemmed from the fact that there are N! permutations for 1...N",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func getPermutation(_ n: Int, _ k: Int) -> String {\\n        \\n        var fac = [Int](repeating: 1, count: n + 1)\\n        for i in 1..<(n+1) { fac[i] = fac[i - 1] * i }\\n        fac.reverse()\\n        \\n        var k = k - 1\\n        \\n        var list = [Int](repeating: 0, count: n)\\n        for i in 1..<(n + 1) { list[i - 1] = i }\\n        \\n        var res = [Int]()\\n        \\n        for i in 1..<(n + 1) {\\n            var index = k / fac[i]\\n            res.append(list[index])\\n            list.remove(at: index)    \\n            k -= fac[i] * index\\n        }\\n        \\n        return res.compactMap { String($0) }.joined()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309606,
                "title": "c-100-beat-drooling-slackers-community-college-burnouts-copy-paste-awesome",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string getPermutation(int n, int k) {\\n    \\n        int aFac[n + 1];\\n        \\n        aFac[0] = 1;\\n        \\n        for (int i=1;i<=n;i++) {\\n            aFac[i] = i * aFac[i - 1];\\n        }\\n        \\n        char aList[n + 1];\\n        aList[n] = 0;\\n        int aListCount = n;\\n        \\n        char aRes[n + 1];\\n        aRes[n] = 0;\\n        int aResCount = 0;\\n        \\n        for (int i=1;i<=n;i++) {\\n            aList[i - 1] = \\'0\\' + i;\\n        }\\n        \\n        k -= 1;\\n        \\n        for (int i=1;i<=n;i++) {\\n            \\n            int aIndex = k / aFac[n - i];\\n            \\n            aRes[aResCount++] = aList[aIndex];\\n            \\n            for (int j=aIndex+1;j<n;j++) {\\n                aList[j-1] = aList[j];\\n            }\\n            \\n            k -= aIndex * aFac[n - i];   \\n        }\\n        return string(aRes);\\n        \\n    }\\n};\\n```\\n\\nPermutations of ABCD\\n\\nA + Permutations(BCD)\\nB + Permutations(ACD)\\nC + Permutations(ABD)\\nD + Permutations(ABC)\\n\\nPermutations of BCD\\n\\nB + Permutations(CD)\\nC + Permutations(BD)\\nD + Permutations(BC)\\n\\nThere are X! permutations in every X length subsequence. So just copy the solution from the other kid. This won\\'t help you code any video game.\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string getPermutation(int n, int k) {\\n    \\n        int aFac[n + 1];\\n        \\n        aFac[0] = 1;\\n        \\n        for (int i=1;i<=n;i++) {\\n            aFac[i] = i * aFac[i - 1];\\n        }\\n        \\n        char aList[n + 1];\\n        aList[n] = 0;\\n        int aListCount = n;\\n        \\n        char aRes[n + 1];\\n        aRes[n] = 0;\\n        int aResCount = 0;\\n        \\n        for (int i=1;i<=n;i++) {\\n            aList[i - 1] = \\'0\\' + i;\\n        }\\n        \\n        k -= 1;\\n        \\n        for (int i=1;i<=n;i++) {\\n            \\n            int aIndex = k / aFac[n - i];\\n            \\n            aRes[aResCount++] = aList[aIndex];\\n            \\n            for (int j=aIndex+1;j<n;j++) {\\n                aList[j-1] = aList[j];\\n            }\\n            \\n            k -= aIndex * aFac[n - i];   \\n        }\\n        return string(aRes);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278289,
                "title": "java-1ms-factorial-solution-with-detailed-explanation",
                "content": "Apparently, there are ```n!``` different permutations for given ```n```. Suppose ```m``` is the first element, then there are ```n - 1!``` permuations for the rest ```n - 1``` numbers. The case is similar to the second element to the nth element. \\n\\nWith that in mind, we can calculate the ```kth``` permutation from the first element to ```nth``` element. \\nAt first, we save ```1``` to ```n``` in a list ```num``` ascendently. \\nThen we traverse from ```1``` to ```n```,  the index of the ```ith``` element in ```num``` equals to ```k / (n - i)!``` and ```k``` is updated to ```k % (n - i)```. The picked element is then removed from the list.\\nKeep traversing until ```k = 0```. Then we add the rest elements in ```num``` to the ```kth``` permutation.\\n\\nThis solution has two tricks:\\n1. Use a list to save candidate elements\\n2. Set k to k - 1 (synchronize index) can simplify the calculation\\n\\n```\\npublic String getPermutation(int n, int k) {\\n\\tStringBuilder sb = new StringBuilder(\"\");\\n\\tList<Integer> num = new ArrayList<Integer>();\\n\\tfor(int i = 1; i <= n; i++) // save candidate elements in a list\\n\\t\\tnum.add(i);\\n\\tint factorial = 1;\\n\\tfor(int i = 1; i <= n - 1; i++)\\n\\t\\tfactorial *= i;\\n\\tk = k - 1; // synchronize the index\\n\\tfor(int i = 1; i < n; i++) {\\n\\t\\tif( k == 0 )\\n\\t\\t\\tbreak;\\n\\t\\tint index = k / factorial;\\n\\t\\tk %= factorial;\\n\\t\\tfactorial /= (n - i);\\n\\t\\tsb.append(num.get(index));\\n\\t\\tnum.remove(index);\\n\\t}\\n\\tfor(int i = 0; i < num.size(); i++)\\n\\t\\tsb.append(num.get(i));\\n\\treturn sb.toString();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```n!```\n```n```\n```m```\n```n - 1!```\n```n - 1```\n```kth```\n```nth```\n```1```\n```n```\n```num```\n```1```\n```n```\n```ith```\n```num```\n```k / (n - i)!```\n```k```\n```k % (n - i)```\n```k = 0```\n```num```\n```kth```\n```\\npublic String getPermutation(int n, int k) {\\n\\tStringBuilder sb = new StringBuilder(\"\");\\n\\tList<Integer> num = new ArrayList<Integer>();\\n\\tfor(int i = 1; i <= n; i++) // save candidate elements in a list\\n\\t\\tnum.add(i);\\n\\tint factorial = 1;\\n\\tfor(int i = 1; i <= n - 1; i++)\\n\\t\\tfactorial *= i;\\n\\tk = k - 1; // synchronize the index\\n\\tfor(int i = 1; i < n; i++) {\\n\\t\\tif( k == 0 )\\n\\t\\t\\tbreak;\\n\\t\\tint index = k / factorial;\\n\\t\\tk %= factorial;\\n\\t\\tfactorial /= (n - i);\\n\\t\\tsb.append(num.get(index));\\n\\t\\tnum.remove(index);\\n\\t}\\n\\tfor(int i = 0; i < num.size(); i++)\\n\\t\\tsb.append(num.get(i));\\n\\treturn sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 190680,
                "title": "6ms-java-solution",
                "content": "Let's say n = 5 and k = 40;\nCurrently we have the following individual numbers:\n```\n1 2 3 4 5\n```\nAmong **n!** = **120** permutations **(n-1)!** = **24** of them will begin with **\"1\"**, the next **24** of them will begin with **\"2\"**, the next **24** will begin with **\"3\"** and so on.\nIn which case **40th** element will begin with **\"2\"**.\n\nNow the problem becomes among the following numbers, what is the 40 - 24 = **16th** permutation:\n\n```\n1 3 4 5\n```\nThe length of this set is 4, so **(4-1)!** = **6** of them will begin with **\"1\"**, the next **6** will begin with **\"3\"** and the next **6** wil begin with **\"4\"**.\nIn which case **16th** element will begin with a **\"4\"**.\n\nNow the problem is what is the 16 - 12 = **4th** permutation of the following set:\n\n```\n1 3 5\n```\n\n**2** of them will begin with a **\"1\"** and **3rd** and **4th** permutation will begin with a **\"3\"** and we need the **2nd** permutation from the remaining set which is:\n\n```\n1 5\n```\n**1st** permutation will begin with a **\"1\"** and **2nd** will begin with **\"5\"**.\n\nOverall result is:\n```\n24351\n```\n\n```java\nclass Solution {\n    public String getPermutation(int n, int k) {\n        int[] numbers = new int[n];\n        for (int i = 1; i <= n; i++) numbers[i-1] = i;\n        return perm(numbers, k);\n    }\n    private String perm(int[] input, int k) {\n        if (input.length == 0) return \"\";\n        int len = input.length - 1;\n        int cnt = factorial(len);\n        int pos = 0;\n        while (k - cnt > 0) {\n            k -= cnt;\n            pos++;\n        }\n        \n        String result = Integer.toString(input[pos]);\n        int[] rem = new int[len];\n        int ix = 0;\n        for (int i = 0; i <= len; i++) {\n            if (i == pos) continue;\n            rem[ix++] = input[i];\n        }\n        result += perm(rem, k);\n        return result;\n    }\n    private int factorial(int n) {\n        int result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\n1 2 3 4 5\n```\n```\n1 3 4 5\n```\n```\n1 3 5\n```\n```\n1 5\n```\n```\n24351\n```\n```java\nclass Solution {\n    public String getPermutation(int n, int k) {\n        int[] numbers = new int[n];\n        for (int i = 1; i <= n; i++) numbers[i-1] = i;\n        return perm(numbers, k);\n    }\n    private String perm(int[] input, int k) {\n        if (input.length == 0) return \"\";\n        int len = input.length - 1;\n        int cnt = factorial(len);\n        int pos = 0;\n        while (k - cnt > 0) {\n            k -= cnt;\n            pos++;\n        }\n        \n        String result = Integer.toString(input[pos]);\n        int[] rem = new int[len];\n        int ix = 0;\n        for (int i = 0; i <= len; i++) {\n            if (i == pos) continue;\n            rem[ix++] = input[i];\n        }\n        result += perm(rem, k);\n        return result;\n    }\n    private int factorial(int n) {\n        int result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 22614,
                "title": "44ms-python-solution",
                "content": "    from math import factorial  \\n    class Solution(object):\\n    \\n        def getPermutation(self, n, k):\\n            \"\"\"\\n            :type n: int\\n            :type k: int\\n            :rtype: str\\n            \"\"\"\\n            res = []\\n            nums = [i for i in xrange(1, n+1)]\\n            while n-1 >= 0:\\n                num, k = k/factorial(n-1), k % factorial(n-1)\\n                if k > 0:\\n                    res.append(str(nums[num]))\\n                    nums.remove(nums[num])\\n                else:\\n                    res.append(str(nums[num-1]))\\n                    nums.remove(nums[num-1])\\n    \\n                n -= 1\\n    \\n            return ''.join(res)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    from math import factorial  \\n    class Solution(object):\\n    \\n        def getPermutation(self, n, k):\\n            \"\"\"\\n            :type n: int\\n            :type k: int\\n            :rtype: str\\n            \"\"\"\\n            res = []\\n            nums = [i for i in xrange(1, n+1)]\\n            while n-1 >= 0:\\n                num, k = k/factorial(n-1), k % factorial(n-1)\\n                if k > 0:\\n                    res.append(str(nums[num]))\\n                    nums.remove(nums[num])\\n                else:\\n                    res.append(str(nums[num-1]))\\n                    nums.remove(nums[num-1])\\n    \\n                n -= 1\\n    \\n            return ''.join(res)",
                "codeTag": "Java"
            },
            {
                "id": 4033541,
                "title": "c-solution-beates-100-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> nums;\\n        string ans = \"\";\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        k = k-1;\\n        while(true){\\n            ans = ans + to_string(nums[k/fact]);\\n            nums.erase(nums.begin() + k/fact);\\n            if(nums.size()==0){\\n                break;\\n            }\\n            k = k % fact;\\n            fact = fact / nums.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> nums;\\n        string ans = \"\";\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        k = k-1;\\n        while(true){\\n            ans = ans + to_string(nums[k/fact]);\\n            nums.erase(nums.begin() + k/fact);\\n            if(nums.size()==0){\\n                break;\\n            }\\n            k = k % fact;\\n            fact = fact / nums.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490124,
                "title": "simple-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int>v(n), vv;\\n        for(int i=0;i<n;i++)\\n           v[i]=i+1;\\n       int p=0;\\n       do\\n       {\\n           p++;\\n           if(p==k)\\n           {\\n              for(auto it:v)\\n                 vv.push_back(it);\\n            break;\\n           }\\n       }while(next_permutation(v.begin(),v.end()));\\n       string s=\"\";\\n      \\n       for(auto it:vv)\\n          s+=to_string(it);\\n        return s;\\n          \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int>v(n), vv;\\n        for(int i=0;i<n;i++)\\n           v[i]=i+1;\\n       int p=0;\\n       do\\n       {\\n           p++;\\n           if(p==k)\\n           {\\n              for(auto it:v)\\n                 vv.push_back(it);\\n            break;\\n           }\\n       }while(next_permutation(v.begin(),v.end()));\\n       string s=\"\";\\n      \\n       for(auto it:vv)\\n          s+=to_string(it);\\n        return s;\\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437099,
                "title": "java-solution-beats-100-sometimes-98-non-recursive",
                "content": "# Intuition\\nIterative traversal and removal of elemnents from the bucket\\n# Approach\\nthe appraoch is based upon how u take benifit of factorial\\n\\n# Complexity\\n- Time complexity:\\nO(N) beats 100%\\n\\n- Space complexity:\\n    beats 83%\\n# Code\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        List<Integer> lr = new ArrayList<>();\\n        int sum=1;\\n        for(int i=1;i<=n;i++) {lr.add(i);sum*=i;}\\n        StringBuilder sb = new StringBuilder();\\n        while(lr.size()!=0&&n>0)\\n        {\\n            //succesively decreasing the factorials value\\n            sum/=n--;\\n            //a considered case when a new row of element is going to start fr.eg if n=4 and k=12 then it is sitting at the max of getting \\'2\\' at first place i.e. 2431 after 3s line will take place\\n            if(k%sum==0){sb.append(lr.remove(k/(sum)-1)); for(int i=lr.size()-1;i>=0;i--) sb.append(lr.get(i)); return sb.toString();}\\n           // removing the element based on how the get considered by k\\n            sb.append(lr.remove(k/(sum)));\\n\\n            k=k%sum;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        List<Integer> lr = new ArrayList<>();\\n        int sum=1;\\n        for(int i=1;i<=n;i++) {lr.add(i);sum*=i;}\\n        StringBuilder sb = new StringBuilder();\\n        while(lr.size()!=0&&n>0)\\n        {\\n            //succesively decreasing the factorials value\\n            sum/=n--;\\n            //a considered case when a new row of element is going to start fr.eg if n=4 and k=12 then it is sitting at the max of getting \\'2\\' at first place i.e. 2431 after 3s line will take place\\n            if(k%sum==0){sb.append(lr.remove(k/(sum)-1)); for(int i=lr.size()-1;i>=0;i--) sb.append(lr.get(i)); return sb.toString();}\\n           // removing the element based on how the get considered by k\\n            sb.append(lr.remove(k/(sum)));\\n\\n            k=k%sum;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309989,
                "title": "3ms-n-n-c-short-sweet-code-iterative",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> v(n+1,false);\\n        vector<int> fact(n+1,1);\\n        for(int i = 2; i <= n; i++){\\n            fact[i] = fact[i-1]*i;\\n        }\\n        string ans = \"\";\\n        k--;\\n        for(int i = 1; i <= n; i++){\\n            int x = k/fact[n-i],j,y=k;\\n            k -= x*fact[n-i];\\n            for(j = 1; j <= n; j++){\\n                if(v[j]==false&&x==0){\\n                    break;\\n                }else if(v[j]==false){\\n                    x--;\\n                }\\n            }\\n            if(j<=n)\\n            v[j] = true;\\n            ans = ans + to_string(j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> v(n+1,false);\\n        vector<int> fact(n+1,1);\\n        for(int i = 2; i <= n; i++){\\n            fact[i] = fact[i-1]*i;\\n        }\\n        string ans = \"\";\\n        k--;\\n        for(int i = 1; i <= n; i++){\\n            int x = k/fact[n-i],j,y=k;\\n            k -= x*fact[n-i];\\n            for(j = 1; j <= n; j++){\\n                if(v[j]==false&&x==0){\\n                    break;\\n                }else if(v[j]==false){\\n                    x--;\\n                }\\n            }\\n            if(j<=n)\\n            v[j] = true;\\n            ans = ans + to_string(j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308352,
                "title": "java-beats-99-6-1ms-runtime-recursion",
                "content": "``` java []\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int[] fact = new int[]{1,1,2,6,24,120,720,5040,40320};\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=1;i<=n;i++){\\n            list.add(i);\\n        }\\n        return calc(fact,n,k-1,list,0)+\"\";\\n    }\\n\\n    private int calc(int[] fact,int n,int k,ArrayList<Integer> list,int res){\\n        if(n==0)\\n           return res;\\n        res=res*10+list.remove(k/fact[n-1]);\\n        return calc(fact,n-1,k%fact[n-1],list,res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int[] fact = new int[]{1,1,2,6,24,120,720,5040,40320};\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=1;i<=n;i++){\\n            list.add(i);\\n        }\\n        return calc(fact,n,k-1,list,0)+\"\";\\n    }\\n\\n    private int calc(int[] fact,int n,int k,ArrayList<Integer> list,int res){\\n        if(n==0)\\n           return res;\\n        res=res*10+list.remove(k/fact[n-1]);\\n        return calc(fact,n-1,k%fact[n-1],list,res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249501,
                "title": "1-liner-code-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Using the `Permutations` to find all the possible permutations.\\n2. Sorting in the ascending order.\\n3. Getting the `k-1` th value, which is a tuple\\n4. Converting that tuple in string format.\\n5. Returning the result.\\n\\n# Code\\n```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        return \\'\\'.join([str(i) for i in sorted(list(permutations([i for i in range(1, n+1)], n)))[k-1]])\\n        \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        return \\'\\'.join([str(i) for i in sorted(list(permutations([i for i in range(1, n+1)], n)))[k-1]])\\n        \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243187,
                "title": "c-recursion-backtracking-easy-brute-force-21-space-5-time",
                "content": "```\\nclass Solution {\\npublic:\\n    void recur(string s, string temp, vector<bool> &vis, vector<string> &ans, int &cnt, int k){\\n      if(temp.size() == s.size()){\\n        ans.emplace_back(temp);\\n        cnt++;\\n        if(cnt == k) return;\\n      }\\n      for(int i = 0; i < s.size(); i++){\\n        if(!vis[i]){\\n          vis[i] = true;\\n          temp += s[i];\\n          recur(s, temp, vis, ans, cnt, k);\\n          temp.pop_back();\\n          vis[i] = false;\\n        }\\n        if(cnt == k) return;\\n      }\\n    }\\n    string getPermutation(int n, int k) {\\n      vector<string> ans;\\n      string s = \"\", temp = \"\";\\n      for(int i = 1; i < n + 1; i++)\\n        s += to_string(i);\\n      vector<bool> vis(n, false);\\n      int cnt = 0;\\n      recur(s, temp, vis, ans, cnt, k);\\n      return ans.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recur(string s, string temp, vector<bool> &vis, vector<string> &ans, int &cnt, int k){\\n      if(temp.size() == s.size()){\\n        ans.emplace_back(temp);\\n        cnt++;\\n        if(cnt == k) return;\\n      }\\n      for(int i = 0; i < s.size(); i++){\\n        if(!vis[i]){\\n          vis[i] = true;\\n          temp += s[i];\\n          recur(s, temp, vis, ans, cnt, k);\\n          temp.pop_back();\\n          vis[i] = false;\\n        }\\n        if(cnt == k) return;\\n      }\\n    }\\n    string getPermutation(int n, int k) {\\n      vector<string> ans;\\n      string s = \"\", temp = \"\";\\n      for(int i = 1; i < n + 1; i++)\\n        s += to_string(i);\\n      vector<bool> vis(n, false);\\n      int cnt = 0;\\n      recur(s, temp, vis, ans, cnt, k);\\n      return ans.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028305,
                "title": "c-easy-to-understand-beats-100-percent-o-n-2",
                "content": "please upvote if you like the solution.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\" ;\\n        vector<int>ds ;\\n        for(int i = 1 ; i <= n ; i++){\\n            ds.push_back(i) ;\\n        }\\n        int i = n ;\\n        while(k!= 0 && i >= 1){\\n            int r = fact(i-1) ;\\n            int c = check(r,k) ;\\n            s += to_string(ds[c]) ;\\n            ds.erase(ds.begin()+c) ;\\n            k = k -r*c ;\\n            i-- ;\\n        }\\n        return s ;\\n    }\\n    int check(int a ,int k){\\n        if(k%a == 0)return (k/a) - 1 ;\\n        return k/a ;\\n    }\\n    int fact(int n){\\n        if(n == 0)return 1 ;\\n        return n*fact(n-1) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\" ;\\n        vector<int>ds ;\\n        for(int i = 1 ; i <= n ; i++){\\n            ds.push_back(i) ;\\n        }\\n        int i = n ;\\n        while(k!= 0 && i >= 1){\\n            int r = fact(i-1) ;\\n            int c = check(r,k) ;\\n            s += to_string(ds[c]) ;\\n            ds.erase(ds.begin()+c) ;\\n            k = k -r*c ;\\n            i-- ;\\n        }\\n        return s ;\\n    }\\n    int check(int a ,int k){\\n        if(k%a == 0)return (k/a) - 1 ;\\n        return k/a ;\\n    }\\n    int fact(int n){\\n        if(n == 0)return 1 ;\\n        return n*fact(n-1) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731831,
                "title": "c-0ms-recursive-solution",
                "content": "The basic idea is to decrease the search space. Now, what does this mean, Actually if we want to place a number at the first position then it will be having (n-1)! ways to do it. So, let us take an example:\\n\\nn = 4 and k=9\\n\\nso, for suppose if we assume our answer will be having \\'1\\' at 1st position. Now let us write the possibilites:\\n\\n1 2 3 4\\n1 2 4 3\\n1 3 2 4\\n1 3 4 2\\n1 4 2 3\\n1 4 3 2\\n\\nand our k value is 9 but the number of possible ways with 1 are only 6. So 1 can\\'t be at first position.\\n\\nNow let us check for \\'2\\' but this time our k will be (9-6 = 3) [beacuse we will not again look into possiblilites of \\'1\\'].\\n\\nif we take 2 then 3-6<0, So here we can conclude that our answer will be having 2 at it\\'s first position. And similarly we will be checking for remaining\\n\\n\\n```\\nvector<int>fact(10,1);\\nclass Solution {\\npublic:   \\n    int Fact(int n){\\n        //Base\\n        if(n==1) return 1;\\n        return fact[n] = n*Fact(n-1);\\n    }\\n    void Helper(int n,int numbers,int k,string &res,unordered_map<int,bool>&ismarked){\\n        if(k < 0) return;\\n        int tk = k;\\n        for(int i=1;i<=n;i++){\\n            if(ismarked[i]) continue;\\n            if(tk-fact[numbers-1] <= 0){\\n                ismarked[i] = true;\\n                res+=to_string(i);\\n                Helper(n,numbers-1,tk,res,ismarked);\\n            }else{\\n                tk-=fact[numbers-1];\\n            }\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string res=\"\";\\n        unordered_map<int,bool> ismarked;\\n        Fact(9);\\n        Helper(n,n,k,res,ismarked);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int>fact(10,1);\\nclass Solution {\\npublic:   \\n    int Fact(int n){\\n        //Base\\n        if(n==1) return 1;\\n        return fact[n] = n*Fact(n-1);\\n    }\\n    void Helper(int n,int numbers,int k,string &res,unordered_map<int,bool>&ismarked){\\n        if(k < 0) return;\\n        int tk = k;\\n        for(int i=1;i<=n;i++){\\n            if(ismarked[i]) continue;\\n            if(tk-fact[numbers-1] <= 0){\\n                ismarked[i] = true;\\n                res+=to_string(i);\\n                Helper(n,numbers-1,tk,res,ismarked);\\n            }else{\\n                tk-=fact[numbers-1];\\n            }\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string res=\"\";\\n        unordered_map<int,bool> ismarked;\\n        Fact(9);\\n        Helper(n,n,k,res,ismarked);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175708,
                "title": "simple-mathematical-solution",
                "content": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        perm, fact = \"\", factorial(n)\\n        nums = [ i for i in range(1, n+1) ]  #to keep track of the options left\\n        for i in range(n, 0, -1):\\n            fact //= i\\n            cur_pos = (k-1) // fact  #index of next number based on possibilities left\\n            perm += str( nums[cur_pos] )\\n            del nums[cur_pos]  #get rid of the number we used\\n            k %= fact\\n        return perm\\n```\\nPlease upvote if you find it useful! :)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        perm, fact = \"\", factorial(n)\\n        nums = [ i for i in range(1, n+1) ]  #to keep track of the options left\\n        for i in range(n, 0, -1):\\n            fact //= i\\n            cur_pos = (k-1) // fact  #index of next number based on possibilities left\\n            perm += str( nums[cur_pos] )\\n            del nums[cur_pos]  #get rid of the number we used\\n            k %= fact\\n        return perm\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121902,
                "title": "cpp-recursion-easy-solution",
                "content": "\\tint count=0;\\n    string ans;\\n    void rightrotate(string& s, int i, int j){\\n        if(i==j)return;\\n        char temp=s[j];\\n        for(int k=j-1;k>=i;k--){\\n            s[k+1]=s[k];\\n        }\\n        s[i]=temp;\\n    }\\n    void leftrotate(string& s, int i, int j){\\n        if(i==j)return;\\n        char temp=s[i];\\n        for(int k=i;k<=j-1;k++){\\n            s[k]=s[k+1];\\n        }\\n        s[j]=temp;\\n    }\\n    void permute(string s, int i, int k){\\n        if(i==s.length()){\\n            count++;\\n            if(count==k){\\n                ans=s;\\n                return ;\\n            }\\n        }\\n        if(count>=k)return;\\n        for(int j=i; j<s.length();j++){\\n            rightrotate(s,i,j);\\n            permute(s,i+1,k);\\n            leftrotate(s,i,j);\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string str=\"123456789\";\\n        string s=str.substr(0,n);\\n        cout<<s<<endl;\\n        permute(s,0,k);\\n        return ans;\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "\\tint count=0;\\n    string ans;\\n    void rightrotate(string& s, int i, int j){\\n        if(i==j)return;\\n        char temp=s[j];\\n        for(int k=j-1;k>=i;k--){\\n            s[k+1]=s[k];\\n        }\\n        s[i]=temp;\\n    }\\n    void leftrotate(string& s, int i, int j){\\n        if(i==j)return;\\n        char temp=s[i];\\n        for(int k=i;k<=j-1;k++){\\n            s[k]=s[k+1];\\n        }\\n        s[j]=temp;\\n    }\\n    void permute(string s, int i, int k){\\n        if(i==s.length()){\\n            count++;\\n            if(count==k){\\n                ans=s;\\n                return ;\\n            }\\n        }\\n        if(count>=k)return;\\n        for(int j=i; j<s.length();j++){\\n            rightrotate(s,i,j);\\n            permute(s,i+1,k);\\n            leftrotate(s,i,j);\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string str=\"123456789\";\\n        string s=str.substr(0,n);\\n        cout<<s<<endl;\\n        permute(s,0,k);\\n        return ans;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1978590,
                "title": "faster-than-91-people-with-explanation-simple-maths-of-probability",
                "content": "This is a simple approach of probability:\\n\\nThe explainattion goes something like this:\\nn= 4, k =9\\n\\nWe have an array = [1, 2, 3, 4]\\nand then we have 4 empty spaces to fill\\n_ _ _ _ _ \\n\\nSo considering that we are filling in position one with any of the numbers, we will then have a possibility of filling out the other 3 places by 3! ways.\\n\\nlet\\'s say we choose 1 to be put in position 1. Therefore 1 can be tied with 3! other solutions. We then can safely assume that if we choose 1 in position 1, then we will eliminate 6 possibilities. \\n1 : 1 - 6\\n2 : 7 - 12\\n3: 13 - 18 \\nBut we have 9 as the value of k, that means that we will have to go up the array and choose 2. \\n\\nThe array now becomes [1, 3, 4] as 2 was already picked up to be placed at position 1. \\n\\n_ _ _ _ _ \\n\\nNow that we have made a good assumption of choosing 2, we narrowed down our search. We can then go to the next place and hence we will also have to narrow down our search space\\nhence : k = k % 2! \\n\\nwe did 2! as there are 3 places to be filled in and we are checking which block of combinations it will fit in\\n\\nWe can keep repeating these steps till we have a value in arr. \\n\\n\\n```\\nvar getPermutation = function (n, k) {\\n  const factorials = {0: 1};\\n  let arr = [];\\n  for (let i = 1; i <= n; i++) {\\n    arr.push(i);\\n    factorials[i] = factorials[i - 1] * i;\\n  }\\n  const KthComb = [];\\n  k--;\\n  while (arr.length > 0) {\\n    const availableLen = arr.length - 1;\\n    let swapValue = Math.floor(k / factorials[availableLen]);\\n    KthComb.push(arr[swapValue]);\\n    arr.splice(swapValue, 1);\\n    const remainder = k % factorials[availableLen];\\n    k = k % factorials[availableLen];\\n  }\\n\\n  return KthComb.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Probability and Statistics"
                ],
                "code": "```\\nvar getPermutation = function (n, k) {\\n  const factorials = {0: 1};\\n  let arr = [];\\n  for (let i = 1; i <= n; i++) {\\n    arr.push(i);\\n    factorials[i] = factorials[i - 1] * i;\\n  }\\n  const KthComb = [];\\n  k--;\\n  while (arr.length > 0) {\\n    const availableLen = arr.length - 1;\\n    let swapValue = Math.floor(k / factorials[availableLen]);\\n    KthComb.push(arr[swapValue]);\\n    arr.splice(swapValue, 1);\\n    const remainder = k % factorials[availableLen];\\n    k = k % factorials[availableLen];\\n  }\\n\\n  return KthComb.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1760283,
                "title": "recursive-backtracking-solution-java",
                "content": "```\\nclass Solution {\\n    int count = 0;\\n    String ans = \"\";\\n    public String getPermutation(int n, int k) {\\n        boolean[] vis = new boolean[n];\\n        count = k;\\n        StringBuilder s = new StringBuilder();\\n        for(int i=0; i<n; i++)\\n            s.append((char) ((i+1) + \\'0\\'));\\n        permutations(s, new StringBuilder(), vis);\\n        return ans;\\n    }\\n    \\n    public void permutations(StringBuilder s, StringBuilder temp, boolean[] vis) {\\n        if(count == 0)\\n            return;\\n        if(temp.length() == s.length()) {\\n            count--;\\n            if(count == 0)\\n                ans = temp.toString();\\n            return;\\n        }\\n        \\n        for(int i=0; i<s.length(); i++) {\\n            if(!vis[i]) {\\n                vis[i] = true;\\n                temp.append(s.charAt(i));\\n                permutations(s, temp, vis);\\n                temp.deleteCharAt(temp.length()-1);\\n                vis[i] = false;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    String ans = \"\";\\n    public String getPermutation(int n, int k) {\\n        boolean[] vis = new boolean[n];\\n        count = k;\\n        StringBuilder s = new StringBuilder();\\n        for(int i=0; i<n; i++)\\n            s.append((char) ((i+1) + \\'0\\'));\\n        permutations(s, new StringBuilder(), vis);\\n        return ans;\\n    }\\n    \\n    public void permutations(StringBuilder s, StringBuilder temp, boolean[] vis) {\\n        if(count == 0)\\n            return;\\n        if(temp.length() == s.length()) {\\n            count--;\\n            if(count == 0)\\n                ans = temp.toString();\\n            return;\\n        }\\n        \\n        for(int i=0; i<s.length(); i++) {\\n            if(!vis[i]) {\\n                vis[i] = true;\\n                temp.append(s.charAt(i));\\n                permutations(s, temp, vis);\\n                temp.deleteCharAt(temp.length()-1);\\n                vis[i] = false;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750234,
                "title": "c-not-the-best-but-easiest-solution-136-200ms",
                "content": "**When I mean easiest solution, it is! The best solution for this problem uses recursion, and you can as close as a 0ms of runtime. However, this approach to the problem uses brute force.**\\n\\nBasically, the main idea is get all the permutations and iterate them.\\n1.- Get the string with the number, from 1 to n.\\nExamples:\\n&emsp;n = 3\\n&emsp;string = \"123\"\\n\\n&emsp;n = 5\\n&emsp;string = \"12345\"\\n\\n2.- Set the counter to 1. This will help us when to stop the permutations loop.\\n3.- Using a while loop we will sort the permutations by ascending order.\\n4.- Every cycle check if our counter is equal than k, if it is return the string else increase the var.\\n\\n*Documentation*\\nnext_permutation: https://en.cppreference.com/w/cpp/algorithm/next_permutation\\n\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string permutations;\\n        int index = 1;\\n        \\n        for (int i = 1; i <= n; i++) \\n            permutations += to_string(i);\\n                \\n        do {\\n            if (index == k) return permutations;    \\n            else index++;\\n        } while (next_permutation(permutations.begin(), permutations.end()));\\n        \\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string permutations;\\n        int index = 1;\\n        \\n        for (int i = 1; i <= n; i++) \\n            permutations += to_string(i);\\n                \\n        do {\\n            if (index == k) return permutations;    \\n            else index++;\\n        } while (next_permutation(permutations.begin(), permutations.end()));\\n        \\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489898,
                "title": "java-solution-iterative-o-n-time-complexity",
                "content": "If the string is \"1234\", the possible permutations are 24 i.e. (4!)\\nBased on the value of k, we can come to a conclusion about the first digit of the kth permutation\\n\\nIf k=6, the kth permutation of \"1234\" is \"1432\"\\nTo get the answer -\\n-----> get the first_digit + do the operation on the remaining string with a new k\\n\\n**How to calculate the first digit?**\\nIf (K%(n-1)! == 0) --> then first element will be at ([k/(n-1)!] -1) index\\nelse --> first element will be at [k/(n-1)!] index\\n\\nexample n=3, so string =\"123\" answer is \"321\" if k=6 and \"312\" if k=5\\nwhen k = 6 --> 6%2! is equal to 0. then the first  element is at ((6/2)- 1) i.e. at 2nd index (\"3\")\\nwhen k = 5 --> 5%2 is not equal to 0, then the first element is at 5/2 i.e 2nd index (\"3)\\n\\n\\nafter calculating the first digit, we can update the k and apply the same operation to the remaining string\\n**How to update k?**\\nif (K%(n-1)! == 0) --> k = (n-1)!\\nelse --> k = k%(n-1)!\\n\\nin the above example when k =6 --> k= (3-1)! = 2\\nwhen k = 5 --> k = 5%(3-1)! = 1\\nremaining string = \"12\"\\n\\nFor second element --> \\nk becomes 2 (for k=6) -- 2%1! is equal to 0, then second element is at index 2/1 -1 i.e. 1 (\"2\")\\nk becomes 1 (for k=5) -- 1%1! is equal to 0, then second element is at index 1/1 -1 i.e. 0 (\"1\")\\n\\nwhen n=1\\nwe have to add it in the answer and return the answer\\n\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String s = \"\";\\n        for (int i = 1; i <= n; i++) {\\n            s = s + i;\\n        }\\n        return permutation(s, k);\\n    }\\n    \\n    static String permutation(String s, int k){\\n        String str = \"\";\\n        int n = s.length();\\n        int ind=-1;\\n        int factorial = fact(n);\\n        \\n\\t\\twhile (n>1){\\n            factorial /= n;\\n            if (k%factorial == 0){\\n                ind = (k/factorial) -1;\\n                char first_ele = s.charAt(ind);\\n                str += first_ele;\\n                k = factorial;\\n            }\\n            else {\\n                ind = k/factorial;\\n                char first_ele = s.charAt(ind);\\n                str += first_ele;\\n                k = k%factorial;\\n            }\\n            s = s.substring(0, ind) + s.substring(ind+1);\\n            n--;\\n            \\n        }\\n\\n        return str + s;\\n    }\\n    \\n    static int fact(int n){\\n        if (n<=1){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String s = \"\";\\n        for (int i = 1; i <= n; i++) {\\n            s = s + i;\\n        }\\n        return permutation(s, k);\\n    }\\n    \\n    static String permutation(String s, int k){\\n        String str = \"\";\\n        int n = s.length();\\n        int ind=-1;\\n        int factorial = fact(n);\\n        \\n\\t\\twhile (n>1){\\n            factorial /= n;\\n            if (k%factorial == 0){\\n                ind = (k/factorial) -1;\\n                char first_ele = s.charAt(ind);\\n                str += first_ele;\\n                k = factorial;\\n            }\\n            else {\\n                ind = k/factorial;\\n                char first_ele = s.charAt(ind);\\n                str += first_ele;\\n                k = k%factorial;\\n            }\\n            s = s.substring(0, ind) + s.substring(ind+1);\\n            n--;\\n            \\n        }\\n\\n        return str + s;\\n    }\\n    \\n    static int fact(int n){\\n        if (n<=1){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287258,
                "title": "c-recursive-solution-100-faster-fully-explained",
                "content": "- If example we have n = 4: (1 2 3 4); so total number of permutation is 4\\\\*3\\\\*2\\\\*1 = n! = 24 = fact\\n- so let k = 17, i.e. we wants 17th permutation; \\n- so how we start: we fix 1 => so total permutaion  with 1 as first index is 3! = 6 = fact< k so we decrease k as k =k-fact = 17 - 6 = 11, we move to 2 and do same; k=k-fact = 11 - 6 = 5 then 3, but here fact = 6 > k;\\n- so we get that \"3\" is our first index\\n- so we fix, mark 3 as visited, fact = fact/(m-1) and recur to smaller string and do same\\n\\n```cpp\\nvoid solve(int n, int k, string &s, long long &fact, int m, bool vis[]){\\n        if(k==0 || m<=0) return;     // check statement;  desired string already achivied\\n        fact = fact/m;                     // max number of permutation if we fix first index\\n        if(fact==0) return;             \\n        for(int i=1;i<=n;i++){       // loop to check and fix current index \\n            if(vis[i]) continue;         // if that number already considered before\\n            if(k>fact){                    // if current permutation is lexigrographically smaller then required permutation\\n                k = k - fact;\\n            }else{                        // if current index is to be considered\\n                s=s+char(i+\\'0\\');\\n                vis[i]=true;\\n                solve(n, k, s, fact, m-1, vis);\\n                break;\\n            }\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string res;\\n        long long factorial = 1;\\n        for(int i=2;i<=n;i++) factorial = factorial*i;     // max number of permutation\\n        bool vis[n+1];\\n        memset(vis,false, sizeof(vis));\\n        solve(n, k, res, factorial, n, vis);\\n        return res;\\n    }\\n```\\n\\n##### If you have any doubt then feel free to ask them below in comment section, also please give this a upvote as it motivates me post more such solutions.\\n",
                "solutionTags": [],
                "code": "```cpp\\nvoid solve(int n, int k, string &s, long long &fact, int m, bool vis[]){\\n        if(k==0 || m<=0) return;     // check statement;  desired string already achivied\\n        fact = fact/m;                     // max number of permutation if we fix first index\\n        if(fact==0) return;             \\n        for(int i=1;i<=n;i++){       // loop to check and fix current index \\n            if(vis[i]) continue;         // if that number already considered before\\n            if(k>fact){                    // if current permutation is lexigrographically smaller then required permutation\\n                k = k - fact;\\n            }else{                        // if current index is to be considered\\n                s=s+char(i+\\'0\\');\\n                vis[i]=true;\\n                solve(n, k, s, fact, m-1, vis);\\n                break;\\n            }\\n        }\\n    }\\n    string getPermutation(int n, int k) {\\n        string res;\\n        long long factorial = 1;\\n        for(int i=2;i<=n;i++) factorial = factorial*i;     // max number of permutation\\n        bool vis[n+1];\\n        memset(vis,false, sizeof(vis));\\n        solve(n, k, res, factorial, n, vis);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1139402,
                "title": "backtrack-cpp-solution-that-doesn-t-give-tle",
                "content": "I\\'m posting this solution as I couldn\\'t find a standard backtracking solution in any of the posts. This solution is not the fastest, but it\\'s simple and based on the backtracking template and good to know. \\nFew important points:\\n1) Sort the string which you are going to permute so that permutations are generated in a lexicographical manner\\n2) Pass the string by value, as sorting will change the order and caller will not be able to \"swap\" with right index\\n3) As soon as the kth permutation is found, terminate the backtracking (Though, it\\'s passing if we don\\'t terminate, takes more time of course)\\n```\\nclass Solution {\\n    int K, N;\\n    string ans;\\npublic:\\n    string getPermutation(int n, int k) {\\n        K = k;   \\n        N = n;\\n        string s;\\n        for(int i=0;i<n;i++){\\n            s.push_back(i+1+\\'0\\');\\n        }\\n        permute(s, 0);    \\n        return ans;\\n    }\\n    \\n    void permute(string s, int start) {\\n        if(start==N-1){\\n            K--;\\n            if(!K){\\n                ans = s;\\n            }\\n            return;\\n        }\\n        \\n        sort(s.begin()+start,s.end());\\n        for(int i=start;i<N;i++){\\n            swap(s[i], s[start]); \\n            permute(s, start+1);\\n            if(!K){\\n                return; //No need to continue backtracking\\n            }\\n            swap(s[i], s[start]); //In case of pass by reference, \"i\" will have a different value as per the sorting, causing error\\n        }\\n    }\\n};\\n```\\n\\nOther approach that worked for me:\\n- Reuse the solution from https://leetcode.com/problems/next-permutation/ and call getPermutation k-1 times and return the final string. \"k-1\" because we begin with the first permutation sequence and need to permute k-1 times. This runs much faster than the backtrack solution discussed in this post.",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\n    int K, N;\\n    string ans;\\npublic:\\n    string getPermutation(int n, int k) {\\n        K = k;   \\n        N = n;\\n        string s;\\n        for(int i=0;i<n;i++){\\n            s.push_back(i+1+\\'0\\');\\n        }\\n        permute(s, 0);    \\n        return ans;\\n    }\\n    \\n    void permute(string s, int start) {\\n        if(start==N-1){\\n            K--;\\n            if(!K){\\n                ans = s;\\n            }\\n            return;\\n        }\\n        \\n        sort(s.begin()+start,s.end());\\n        for(int i=start;i<N;i++){\\n            swap(s[i], s[start]); \\n            permute(s, start+1);\\n            if(!K){\\n                return; //No need to continue backtracking\\n            }\\n            swap(s[i], s[start]); //In case of pass by reference, \"i\" will have a different value as per the sorting, causing error\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022904,
                "title": "c-easy-iterative-solutions-100-faster-with-o-n-time-complextiy",
                "content": "This solution is not efficient as it consumes so much memory....its just to develop the thought process \\n```\\nclass Solution {\\npublic:\\n    bool solve(int k, int& count, string str, string s, string& ans) {\\n        if(s.size()==0) {\\n            count++;\\n            if(count==k) {\\n                ans= str;\\n                return true; \\n            }\\n            return false;\\n        }\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            string p=s; \\n            p.erase(i, 1);\\n            if(solve(k, count, str+s[i], p, ans))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        int count=0;\\n        string ans, s=\"\";\\n        \\n        for(int i=1; i<=n; i++) s+= (i+48);\\n        \\n        solve(k, count, \"\", s, ans);\\n        return ans;\\n    }\\n};\\n```\\nHere is the efficient solution(100% faster, O(N) time complexity), its a bit mathematical here we will find the required string by dividing all the permutations in to different parts according to the first element\\neg s= \"123\" can be divided as -\\n123 132\\n213  231\\n312 321\\n```\\nclass Solution {\\npublic:\\n    int fact(int n) {\\n        int ans=1;\\n        for(int i=1; i<=n; i++) ans*=i;\\n        return ans;\\n    }\\n    \\n    void solve(int k, string s, string& ans) {    \\n        int total_size=0, part_size, n, temp;  \\n        while(s.size()>2) {\\n            n= s.size();\\n            total_size= fact(n);\\n            part_size= total_size/n;\\n            \\n            temp= (k-1)/part_size;\\n            \\n            if(k%part_size==0)\\n                k=part_size;\\n            else\\n                k= k%part_size;\\n        \\n            ans+= s[temp];\\n            s.erase(temp, 1);           \\n        }\\n        cout<<s;\\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        string ans, s=\"\";        \\n        for(int i=1; i<=n; i++) s+= (i+48);\\n        \\n        solve(k, s, ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int k, int& count, string str, string s, string& ans) {\\n        if(s.size()==0) {\\n            count++;\\n            if(count==k) {\\n                ans= str;\\n                return true; \\n            }\\n            return false;\\n        }\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            string p=s; \\n            p.erase(i, 1);\\n            if(solve(k, count, str+s[i], p, ans))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        int count=0;\\n        string ans, s=\"\";\\n        \\n        for(int i=1; i<=n; i++) s+= (i+48);\\n        \\n        solve(k, count, \"\", s, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798148,
                "title": "c-solution-for-all-similar-questions",
                "content": "```\\n46. Permutations :- https://leetcode.com/problems/permutations/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        ans.clear();\\n        vector<int> res;\\n        unordered_map<int,bool> ump;\\n        solve(nums, res, ump);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, vector<int> res, unordered_map<int,bool> ump)\\n    {\\n        if (res.size() == nums.size())\\n        {\\n            ans.push_back(res);\\n            return;\\n        }\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if (ump[nums[i]] == true)\\n                continue;\\n            res.push_back(nums[i]);\\n            ump[nums[i]] = true;\\n            solve(nums, res, ump);\\n            res.pop_back();\\n            ump[nums[i]] = false;\\n        }\\n    }\\n};\\n\\n47. Permutations II :- https://leetcode.com/problems/permutations-ii/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        ans.clear();\\n        vector<int> res;\\n        unordered_map<int,bool> ump;\\n        sort(begin(nums),end(nums));\\n        solve(nums, res, ump);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, vector<int> res, unordered_map<int,bool> ump)\\n    {\\n        if (res.size() == nums.size())\\n        {\\n            ans.push_back(res);\\n            return;\\n        }\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if (ump[i] == true || i > 0 && nums[i] == nums[i-1] && ump[i-1] == false)\\n                continue;\\n            res.push_back(nums[i]);\\n            ump[i] = true;\\n            solve(nums, res, ump);\\n            res.pop_back();\\n            ump[i] = false;\\n        }\\n    }    \\n};\\n\\n31. Next Permutation :- https://leetcode.com/problems/next-permutation/\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return;\\n        if (n == 2)\\n        {\\n            swap(nums[0],nums[1]);\\n            return;\\n        }\\n        int j = n-1;\\n        while(j > 0)\\n        {\\n            if (nums[j-1] < nums[j])\\n            {\\n                reverse(begin(nums)+j,end(nums));\\n                auto idx = upper_bound(begin(nums)+j,end(nums),nums[j-1]) - begin(nums);\\n                swap(nums[j-1],nums[idx]);\\n                return;\\n            }\\n            j--;\\n        }\\n        sort(begin(nums),end(nums));\\n        return;\\n    }\\n};\\n\\n60. Permutation Sequence :- https://leetcode.com/problems/permutation-sequence/\\n\\nclass Solution {\\n    vector<int> fact;\\n    vector<string> digits;\\n    string ans;\\npublic:\\n    string getPermutation(int n, int k) {\\n        fact = vector<int>(n);\\n        digits = vector<string>(n);\\n        ans = \"\";\\n        fact[0] = 1;\\n        for(int i = 1 ; i < n ; i++)\\n            fact[i] = fact[i-1] * i;\\n        for(int i = 1 ; i <= n ; i++)\\n            digits[i-1] = to_string(i);\\n        solve(n,k);\\n        return ans;\\n    }\\nprivate:\\n    void solve(int n, int k)\\n    {\\n        if (n == 1)\\n        {\\n            ans += digits[0];\\n            return;\\n        }\\n        int index = k/fact[n-1];\\n        if (k % fact[n-1] == 0)\\n            index--;\\n        ans = ans + digits[index];\\n        digits.erase(begin(digits)+index);\\n        k = k - fact[n-1] * index;\\n        n--;\\n        solve(n,k);\\n    }\\n};\\n\\n78. Subsets :- https://leetcode.com/problems/subsets/\\n\\nclass Solution {\\n    int len, n;\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        ans.clear();\\n        n = (int)nums.size();\\n        vector<int> res;\\n        for(len = 0 ; len <= n ; len++)\\n            solve(nums, 0, res);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, int index, vector<int> res)\\n    {\\n        if ((int)res.size() == len)\\n            ans.push_back(res);\\n        for(int i = index ; i < n ; i++)\\n        {\\n            res.push_back(nums[i]);\\n            solve(nums, i + 1, res);\\n            res.pop_back();\\n        }\\n    }\\n};\\n\\n90. Subsets II :- https://leetcode.com/problems/subsets-ii/\\n\\nclass Solution {\\n    int len, n;\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        ans.clear();\\n        n = (int)nums.size();\\n        vector<int> res;\\n        sort(begin(nums),end(nums));\\n        // for(len = 0 ; len <= n ; len++)\\n        solve(nums, 0, res);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, int index, vector<int>& res)\\n    {\\n        ans.push_back(res);\\n        for(int i = index ; i < n ; i++)\\n        {\\n            if (i > index && nums[i] == nums[i-1])\\n                continue;\\n            res.push_back(nums[i]);\\n            solve(nums, i + 1, res);\\n            res.pop_back();\\n        }\\n    }\\n};\\n\\n77. Combinations :- https://leetcode.com/problems/combinations/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\npublic:\\n    void solve(int& n, int k, int curN, vector<int>& cur)\\n    {\\n        if (k == 0)\\n        {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        if (curN > n)\\n            return;\\n        for(int idx = curN ; idx <= n ; idx++)\\n        {\\n            cur.push_back(idx);\\n            solve(n, k-1, idx+1, cur);\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        ans.clear();\\n        vector<int> cur;\\n        solve(n, k, 1, cur);\\n        return ans;\\n    }\\n};\\n\\n39. Combination Sum :- https://leetcode.com/problems/combination-sum/\\n\\nclass Solution {\\n    set<vector<int>> ans;\\npublic:\\n    void solve(vector<int>& candidates, int& target, int idx, int curSum, vector<int> cur)\\n    {\\n        if (curSum == target)\\n        {\\n            ans.insert(cur);\\n            return;\\n        }\\n        if (curSum > target)\\n            return;\\n        if (idx >= candidates.size())\\n            return;\\n        for(int i = idx ; i < candidates.size() ; i++)\\n        {\\n            curSum += candidates[i];\\n            cur.push_back(candidates[i]);\\n            solve(candidates, target, i, curSum, cur);\\n            curSum -= candidates[i];\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        ans.clear();\\n        vector<int> cur;\\n        sort(begin(candidates), end(candidates));\\n        solve(candidates, target, 0, 0, cur);\\n        vector<vector<int>> res;\\n        for(auto it : ans)\\n            res.push_back(it);\\n        return res;\\n    }\\n};\\n\\n17. Letter Combinations of a Phone Number :- https://leetcode.com/problems/letter-combinations-of-a-phone-number/\\n\\nclass Solution {\\npublic:\\n    vector<string> keypad = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    void solve(string &digits, string cur, int idx, vector<string> &ans)\\n    {\\n        if (idx == digits.size())\\n        {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        for(int i = 0 ; i < keypad[digits[idx]-\\'0\\'].size() ; i++)\\n        {\\n            cur.push_back(keypad[digits[idx]-\\'0\\'][i]);\\n            solve(digits, cur, idx+1, ans);\\n            cur.pop_back();\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        if (digits.size() < 1)\\n            return ans;\\n        solve(digits, \"\", 0, ans);\\n        return ans;\\n    }\\n};\\n\\n40. Combination Sum II :- https://leetcode.com/problems/combination-sum-ii/\\n\\nclass Solution {\\n    set<vector<int>> ans;\\npublic:\\n    void solve(vector<int>& candidates, int& target, int idx, int curSum, vector<int> cur)\\n    {\\n        if (curSum == target)\\n        {\\n            ans.insert(cur);\\n            return;\\n        }\\n        if (curSum > target)\\n            return;\\n        if (idx >= candidates.size())\\n            return;\\n        for(int i = idx ; i < candidates.size() ; i++)\\n        {\\n            curSum += candidates[i];\\n            cur.push_back(candidates[i]);\\n            solve(candidates, target, i+1, curSum, cur);\\n            curSum -= candidates[i];\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        ans.clear();\\n        vector<int> cur;\\n        sort(begin(candidates), end(candidates));\\n        solve(candidates, target, 0, 0, cur);\\n        vector<vector<int>> res;\\n        for(auto it : ans)\\n            res.push_back(it);\\n        return res;\\n    }\\n};\\n\\n216. Combination Sum III :- https://leetcode.com/problems/combination-sum-iii/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\n    int K, N;\\npublic:\\n    void solve(int n, int curSum, vector<int>& cur)\\n    {\\n        if (curSum == N and cur.size() == K)\\n        {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        if (curSum > N)\\n            return;\\n        if (cur.size() > K)\\n            return;\\n        for(int num = n ; num < 10 ; num++)\\n        {\\n            cur.push_back(num);\\n            solve(num+1, curSum + num, cur);\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        ans.clear();\\n        vector<int> cur;\\n        K = k;\\n        N = n;\\n        solve(1, 0, cur);\\n        return ans;\\n    }\\n};\\n\\n377. Combination Sum IV :- https://leetcode.com/problems/combination-sum-iv/\\n\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> dp(target + 1);\\n        dp[0] = 1;\\n        sort (nums.begin(), nums.end());\\n        for (int i = 1; i <= target; i++) {\\n            for (auto num : nums) {\\n                if (i < num) break;\\n                dp[i] = ((long int)dp[i]+dp[i-num])%2147483647 ;\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n\\n22. Generate Parentheses :- https://leetcode.com/problems/generate-parentheses/\\n\\nclass Solution {\\npublic:\\n    void generate(string cur,int open,int close,int n,vector<string> &ans){\\n        if(cur.length()>=2*n){\\n            if(open==close && open==n){\\n                ans.push_back(cur);\\n                return;\\n            }else{\\n                return;\\n            }\\n        }\\n        if(open==n && close<open){\\n            cur.push_back(\\')\\');\\n            generate(cur,open,close+1,n,ans);  \\n        }\\n        if(open == close && open < n){\\n            cur.push_back(\\'(\\');\\n            generate(cur,open+1,close,n,ans);\\n        }\\n        if(open>close){\\n            if(open<n){\\n                cur.push_back(\\'(\\');\\n                generate(cur,open+1,close,n,ans);\\n            }\\n            {\\n                cur.push_back(\\')\\');\\n                generate(cur,open,close+1,n,ans);\\n            }\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        generate(\"\",0,0,n,ans);\\n        return ans;\\n    }\\n};\\n\\n20. Valid Parentheses :- https://leetcode.com/problems/valid-parentheses/\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'[\\' || s[i]==\\'{\\')\\n                st.push(s[i]);\\n            else{\\n                if(st.empty())\\n                    return false;\\n                char tp = st.top();\\n                st.pop();\\n                char cur = s[i];\\n                if(cur==\\')\\' && (tp==\\'{\\' || tp==\\'[\\'))\\n                    return false;\\n                if(cur==\\'}\\' && (tp==\\'(\\' || tp==\\'[\\'))\\n                    return false;\\n                if(cur==\\']\\' && (tp==\\'{\\' || tp==\\'(\\'))\\n                    return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n46. Permutations :- https://leetcode.com/problems/permutations/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        ans.clear();\\n        vector<int> res;\\n        unordered_map<int,bool> ump;\\n        solve(nums, res, ump);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, vector<int> res, unordered_map<int,bool> ump)\\n    {\\n        if (res.size() == nums.size())\\n        {\\n            ans.push_back(res);\\n            return;\\n        }\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if (ump[nums[i]] == true)\\n                continue;\\n            res.push_back(nums[i]);\\n            ump[nums[i]] = true;\\n            solve(nums, res, ump);\\n            res.pop_back();\\n            ump[nums[i]] = false;\\n        }\\n    }\\n};\\n\\n47. Permutations II :- https://leetcode.com/problems/permutations-ii/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        ans.clear();\\n        vector<int> res;\\n        unordered_map<int,bool> ump;\\n        sort(begin(nums),end(nums));\\n        solve(nums, res, ump);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, vector<int> res, unordered_map<int,bool> ump)\\n    {\\n        if (res.size() == nums.size())\\n        {\\n            ans.push_back(res);\\n            return;\\n        }\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if (ump[i] == true || i > 0 && nums[i] == nums[i-1] && ump[i-1] == false)\\n                continue;\\n            res.push_back(nums[i]);\\n            ump[i] = true;\\n            solve(nums, res, ump);\\n            res.pop_back();\\n            ump[i] = false;\\n        }\\n    }    \\n};\\n\\n31. Next Permutation :- https://leetcode.com/problems/next-permutation/\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return;\\n        if (n == 2)\\n        {\\n            swap(nums[0],nums[1]);\\n            return;\\n        }\\n        int j = n-1;\\n        while(j > 0)\\n        {\\n            if (nums[j-1] < nums[j])\\n            {\\n                reverse(begin(nums)+j,end(nums));\\n                auto idx = upper_bound(begin(nums)+j,end(nums),nums[j-1]) - begin(nums);\\n                swap(nums[j-1],nums[idx]);\\n                return;\\n            }\\n            j--;\\n        }\\n        sort(begin(nums),end(nums));\\n        return;\\n    }\\n};\\n\\n60. Permutation Sequence :- https://leetcode.com/problems/permutation-sequence/\\n\\nclass Solution {\\n    vector<int> fact;\\n    vector<string> digits;\\n    string ans;\\npublic:\\n    string getPermutation(int n, int k) {\\n        fact = vector<int>(n);\\n        digits = vector<string>(n);\\n        ans = \"\";\\n        fact[0] = 1;\\n        for(int i = 1 ; i < n ; i++)\\n            fact[i] = fact[i-1] * i;\\n        for(int i = 1 ; i <= n ; i++)\\n            digits[i-1] = to_string(i);\\n        solve(n,k);\\n        return ans;\\n    }\\nprivate:\\n    void solve(int n, int k)\\n    {\\n        if (n == 1)\\n        {\\n            ans += digits[0];\\n            return;\\n        }\\n        int index = k/fact[n-1];\\n        if (k % fact[n-1] == 0)\\n            index--;\\n        ans = ans + digits[index];\\n        digits.erase(begin(digits)+index);\\n        k = k - fact[n-1] * index;\\n        n--;\\n        solve(n,k);\\n    }\\n};\\n\\n78. Subsets :- https://leetcode.com/problems/subsets/\\n\\nclass Solution {\\n    int len, n;\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        ans.clear();\\n        n = (int)nums.size();\\n        vector<int> res;\\n        for(len = 0 ; len <= n ; len++)\\n            solve(nums, 0, res);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, int index, vector<int> res)\\n    {\\n        if ((int)res.size() == len)\\n            ans.push_back(res);\\n        for(int i = index ; i < n ; i++)\\n        {\\n            res.push_back(nums[i]);\\n            solve(nums, i + 1, res);\\n            res.pop_back();\\n        }\\n    }\\n};\\n\\n90. Subsets II :- https://leetcode.com/problems/subsets-ii/\\n\\nclass Solution {\\n    int len, n;\\n    vector<vector<int> > ans;\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        ans.clear();\\n        n = (int)nums.size();\\n        vector<int> res;\\n        sort(begin(nums),end(nums));\\n        // for(len = 0 ; len <= n ; len++)\\n        solve(nums, 0, res);\\n        return ans;\\n    }\\nprivate:\\n    void solve(vector<int>& nums, int index, vector<int>& res)\\n    {\\n        ans.push_back(res);\\n        for(int i = index ; i < n ; i++)\\n        {\\n            if (i > index && nums[i] == nums[i-1])\\n                continue;\\n            res.push_back(nums[i]);\\n            solve(nums, i + 1, res);\\n            res.pop_back();\\n        }\\n    }\\n};\\n\\n77. Combinations :- https://leetcode.com/problems/combinations/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\npublic:\\n    void solve(int& n, int k, int curN, vector<int>& cur)\\n    {\\n        if (k == 0)\\n        {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        if (curN > n)\\n            return;\\n        for(int idx = curN ; idx <= n ; idx++)\\n        {\\n            cur.push_back(idx);\\n            solve(n, k-1, idx+1, cur);\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combine(int n, int k) {\\n        ans.clear();\\n        vector<int> cur;\\n        solve(n, k, 1, cur);\\n        return ans;\\n    }\\n};\\n\\n39. Combination Sum :- https://leetcode.com/problems/combination-sum/\\n\\nclass Solution {\\n    set<vector<int>> ans;\\npublic:\\n    void solve(vector<int>& candidates, int& target, int idx, int curSum, vector<int> cur)\\n    {\\n        if (curSum == target)\\n        {\\n            ans.insert(cur);\\n            return;\\n        }\\n        if (curSum > target)\\n            return;\\n        if (idx >= candidates.size())\\n            return;\\n        for(int i = idx ; i < candidates.size() ; i++)\\n        {\\n            curSum += candidates[i];\\n            cur.push_back(candidates[i]);\\n            solve(candidates, target, i, curSum, cur);\\n            curSum -= candidates[i];\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        ans.clear();\\n        vector<int> cur;\\n        sort(begin(candidates), end(candidates));\\n        solve(candidates, target, 0, 0, cur);\\n        vector<vector<int>> res;\\n        for(auto it : ans)\\n            res.push_back(it);\\n        return res;\\n    }\\n};\\n\\n17. Letter Combinations of a Phone Number :- https://leetcode.com/problems/letter-combinations-of-a-phone-number/\\n\\nclass Solution {\\npublic:\\n    vector<string> keypad = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    void solve(string &digits, string cur, int idx, vector<string> &ans)\\n    {\\n        if (idx == digits.size())\\n        {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        for(int i = 0 ; i < keypad[digits[idx]-\\'0\\'].size() ; i++)\\n        {\\n            cur.push_back(keypad[digits[idx]-\\'0\\'][i]);\\n            solve(digits, cur, idx+1, ans);\\n            cur.pop_back();\\n        }\\n    }\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        if (digits.size() < 1)\\n            return ans;\\n        solve(digits, \"\", 0, ans);\\n        return ans;\\n    }\\n};\\n\\n40. Combination Sum II :- https://leetcode.com/problems/combination-sum-ii/\\n\\nclass Solution {\\n    set<vector<int>> ans;\\npublic:\\n    void solve(vector<int>& candidates, int& target, int idx, int curSum, vector<int> cur)\\n    {\\n        if (curSum == target)\\n        {\\n            ans.insert(cur);\\n            return;\\n        }\\n        if (curSum > target)\\n            return;\\n        if (idx >= candidates.size())\\n            return;\\n        for(int i = idx ; i < candidates.size() ; i++)\\n        {\\n            curSum += candidates[i];\\n            cur.push_back(candidates[i]);\\n            solve(candidates, target, i+1, curSum, cur);\\n            curSum -= candidates[i];\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        ans.clear();\\n        vector<int> cur;\\n        sort(begin(candidates), end(candidates));\\n        solve(candidates, target, 0, 0, cur);\\n        vector<vector<int>> res;\\n        for(auto it : ans)\\n            res.push_back(it);\\n        return res;\\n    }\\n};\\n\\n216. Combination Sum III :- https://leetcode.com/problems/combination-sum-iii/\\n\\nclass Solution {\\n    vector<vector<int> > ans;\\n    int K, N;\\npublic:\\n    void solve(int n, int curSum, vector<int>& cur)\\n    {\\n        if (curSum == N and cur.size() == K)\\n        {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        if (curSum > N)\\n            return;\\n        if (cur.size() > K)\\n            return;\\n        for(int num = n ; num < 10 ; num++)\\n        {\\n            cur.push_back(num);\\n            solve(num+1, curSum + num, cur);\\n            cur.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        ans.clear();\\n        vector<int> cur;\\n        K = k;\\n        N = n;\\n        solve(1, 0, cur);\\n        return ans;\\n    }\\n};\\n\\n377. Combination Sum IV :- https://leetcode.com/problems/combination-sum-iv/\\n\\nclass Solution {\\npublic:\\n    int combinationSum4(vector<int>& nums, int target) {\\n        vector<int> dp(target + 1);\\n        dp[0] = 1;\\n        sort (nums.begin(), nums.end());\\n        for (int i = 1; i <= target; i++) {\\n            for (auto num : nums) {\\n                if (i < num) break;\\n                dp[i] = ((long int)dp[i]+dp[i-num])%2147483647 ;\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n\\n22. Generate Parentheses :- https://leetcode.com/problems/generate-parentheses/\\n\\nclass Solution {\\npublic:\\n    void generate(string cur,int open,int close,int n,vector<string> &ans){\\n        if(cur.length()>=2*n){\\n            if(open==close && open==n){\\n                ans.push_back(cur);\\n                return;\\n            }else{\\n                return;\\n            }\\n        }\\n        if(open==n && close<open){\\n            cur.push_back(\\')\\');\\n            generate(cur,open,close+1,n,ans);  \\n        }\\n        if(open == close && open < n){\\n            cur.push_back(\\'(\\');\\n            generate(cur,open+1,close,n,ans);\\n        }\\n        if(open>close){\\n            if(open<n){\\n                cur.push_back(\\'(\\');\\n                generate(cur,open+1,close,n,ans);\\n            }\\n            {\\n                cur.push_back(\\')\\');\\n                generate(cur,open,close+1,n,ans);\\n            }\\n        }\\n    }\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> ans;\\n        generate(\"\",0,0,n,ans);\\n        return ans;\\n    }\\n};\\n\\n20. Valid Parentheses :- https://leetcode.com/problems/valid-parentheses/\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\' || s[i]==\\'[\\' || s[i]==\\'{\\')\\n                st.push(s[i]);\\n            else{\\n                if(st.empty())\\n                    return false;\\n                char tp = st.top();\\n                st.pop();\\n                char cur = s[i];\\n                if(cur==\\')\\' && (tp==\\'{\\' || tp==\\'[\\'))\\n                    return false;\\n                if(cur==\\'}\\' && (tp==\\'(\\' || tp==\\'[\\'))\\n                    return false;\\n                if(cur==\\']\\' && (tp==\\'{\\' || tp==\\'(\\'))\\n                    return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711640,
                "title": "0ms-dfs-solution-c-with-inline-comments-o-n-time-and-space",
                "content": "I didn\\'t find a similar solution to this, so I thought i\\'d share :) \\n\\nThe idea is to recurse only into states the kth permutation will be in:\\n```\\nclass Solution {\\npublic:\\n    string ret;\\n\\t\\n    void dfs(int n, int k, int numsAvailable, vector<int> &factorial, vector<bool> &taken){\\n\\t\\t// stop recursing when there are no more elements to pick from\\n        if(numsAvailable == 0)\\n            return;\\n\\t\\t\\t\\n        // factorial(numsAvailable) states will be equally spread across the currently pickable numbers\\n        int goalCount = (((k - 1) / (double) factorial[numsAvailable]) * numsAvailable) + 1; \\n\\t\\t\\n\\t\\t// each pickable number will represent the following number of subspaces\\n        int currentSubspaceSize = factorial[numsAvailable] / numsAvailable;\\n          \\n\\t\\t// currentCount is the number of previously untaken elements from left to right\\n        int currentCount = 0;\\n        for(int num = 1; num <= n; num++){\\n            if(taken[num])\\n                continue;\\n            \\n            currentCount++;\\n            \\n\\t\\t\\t// if reached the un-picked number that kth permutation will be in:\\n            if(currentCount == goalCount){\\n                ret += to_string(num);\\n                taken[num] = true;\\n                \\n\\t\\t\\t\\t// reduce k to search in child subspace.\\n\\t\\t\\t\\t// this is done by removing other \"k\"s that are not in the current space\\n                dfs(n, k - (currentSubspaceSize * (currentCount - 1)), numsAvailable - 1, factorial, taken);\\n                break;\\n            }\\n        }\\n        \\n    }\\n   \\n    string getPermutation(int n, int k) {\\n        \\n        vector<int> factorial(1, 1);\\n        for(int i = 1; i <= n; i++)\\n            factorial.push_back(i * factorial[i - 1]);\\n        \\n        vector<bool> taken(n+1);\\n\\n        dfs(n, k, n, factorial, taken);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string ret;\\n\\t\\n    void dfs(int n, int k, int numsAvailable, vector<int> &factorial, vector<bool> &taken){\\n\\t\\t// stop recursing when there are no more elements to pick from\\n        if(numsAvailable == 0)\\n            return;\\n\\t\\t\\t\\n        // factorial(numsAvailable) states will be equally spread across the currently pickable numbers\\n        int goalCount = (((k - 1) / (double) factorial[numsAvailable]) * numsAvailable) + 1; \\n\\t\\t\\n\\t\\t// each pickable number will represent the following number of subspaces\\n        int currentSubspaceSize = factorial[numsAvailable] / numsAvailable;\\n          \\n\\t\\t// currentCount is the number of previously untaken elements from left to right\\n        int currentCount = 0;\\n        for(int num = 1; num <= n; num++){\\n            if(taken[num])\\n                continue;\\n            \\n            currentCount++;\\n            \\n\\t\\t\\t// if reached the un-picked number that kth permutation will be in:\\n            if(currentCount == goalCount){\\n                ret += to_string(num);\\n                taken[num] = true;\\n                \\n\\t\\t\\t\\t// reduce k to search in child subspace.\\n\\t\\t\\t\\t// this is done by removing other \"k\"s that are not in the current space\\n                dfs(n, k - (currentSubspaceSize * (currentCount - 1)), numsAvailable - 1, factorial, taken);\\n                break;\\n            }\\n        }\\n        \\n    }\\n   \\n    string getPermutation(int n, int k) {\\n        \\n        vector<int> factorial(1, 1);\\n        for(int i = 1; i <= n; i++)\\n            factorial.push_back(i * factorial[i - 1]);\\n        \\n        vector<bool> taken(n+1);\\n\\n        dfs(n, k, n, factorial, taken);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698157,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public string GetPermutation(int n, int k) {\\n      \\n        int[] factorial = new int[n+1];\\n        List<int> arr = new List<int>();\\n        \\n        factorial[0] = 1;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            factorial[i] = factorial[i-1] * i;\\n            arr.Add(i);\\n        }\\n        \\n        k--;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 1; i <= n; i++)\\n        {\\n            int index = k / factorial[n - i];\\n            sb.Append(arr[index]);\\n            arr.RemoveAt(index);\\n            k -= index * factorial[n - i];\\n        }\\n        \\n        return sb.ToString();       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string GetPermutation(int n, int k) {\\n      \\n        int[] factorial = new int[n+1];\\n        List<int> arr = new List<int>();\\n        \\n        factorial[0] = 1;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            factorial[i] = factorial[i-1] * i;\\n            arr.Add(i);\\n        }\\n        \\n        k--;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 1; i <= n; i++)\\n        {\\n            int index = k / factorial[n - i];\\n            sb.Append(arr[index]);\\n            arr.RemoveAt(index);\\n            k -= index * factorial[n - i];\\n        }\\n        \\n        return sb.ToString();       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697306,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> dp;\\n        dp.assign(n+1,0);\\n        dp[0] = 1;\\n        for(int i=1; i<=n; i++){\\n            dp[i] = i*dp[i-1];\\n        }\\n        \\n        string res = \"\";\\n        vector<int> values;\\n        for(int i=0; i<=n; i++){\\n            values.push_back(i);\\n        }\\n        \\n        int temp = n;\\n        auto it = values.begin();\\n        \\n        while(res.length() != n){\\n            int f = dp[temp];\\n            int block_size = f/temp;\\n            int count = 1;\\n            while(k>block_size){\\n                k -= block_size;\\n                count++;\\n            }\\n            //cout << values[count];\\n            res += to_string(values[count]);\\n            values.erase(it+count);\\n            temp--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> dp;\\n        dp.assign(n+1,0);\\n        dp[0] = 1;\\n        for(int i=1; i<=n; i++){\\n            dp[i] = i*dp[i-1];\\n        }\\n        \\n        string res = \"\";\\n        vector<int> values;\\n        for(int i=0; i<=n; i++){\\n            values.push_back(i);\\n        }\\n        \\n        int temp = n;\\n        auto it = values.begin();\\n        \\n        while(res.length() != n){\\n            int f = dp[temp];\\n            int block_size = f/temp;\\n            int count = 1;\\n            while(k>block_size){\\n                k -= block_size;\\n                count++;\\n            }\\n            //cout << values[count];\\n            res += to_string(values[count]);\\n            values.erase(it+count);\\n            temp--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 403067,
                "title": "simplest-cpp-with-explanation",
                "content": "This is a classic math problem.\\nconsider n =3\\n1. Number of permuttions of length n (n digits here) are n!. eg: 3!=6\\n2. It can also be written as n*(n-1)!   eg: 3*(3-1)! = 6\\n3. So there are n groups with (n-1)! permutations in each group.\\n eg: for n=3 there will be 3 groups with ((n-1)! which is) 2 permutation in each group \\n group1 = {123, 132}\\n group2 = {213, 231}\\n group3 = {312, 321}\\nSo the basic math is to identify the group which will contain Kth permutation and then select the element at that index and then repeat the steps for lesser n and k\\n\\nfor n = 3, our first permutaion is \"123\" and k=3 our answer will be 213. how?\\n\\nfrist pass - \\nk = k/fact(n-1)! which is ceil(3/2!) -> 2 so select index 2 (0 based) from the first string which is \"2\";\\nnow k = k%fact(n-1) which is 3%2! -> 1\\nn-- which is 2\\nnow our string is = \"13\", we removed 2\\n\\nsecond pass - \\nk = k/(n-1)! --> 1/1! --> 1 --> index1 in str--> \"1\"\\nk = k%(n-1)! --> 1%1 --> 0(in this case we set k to be (n-1)! which is 1)\\nn-- which is 1\\nnow our string is \"3\"since we removed 1\\n\\nthird pass:\\nk = k = k/(n-1)! --> 1/0! --> 1 --> index1 in str--> \"3\"\\n\\nso one by one we removed 3,2 and 1 from our initial sequence.\\n\\n```\\n string getPermutation(int n, int k) {\\n        string str=\"\";\\n        int fact[] = {1,1,2,6,24,120,720,5040,40320,362880};\\n        for(int i=1;i<=n;i++)\\n        {\\n            str+=to_string(i);\\n        }       \\n        string res = \"\";\\n        while(n>=1)\\n        {\\n            int ind = ceil(k*1.0/fact[n-1]);  // 1.0 because we want to use ceil\\n            k = k%fact[n-1];                  //n-1 because of 0 based indexing\\n            k = (k==0)?fact[n-1]:k;           // need atleast 1 permutation from the next group\\n            n--;                                     \\n            res+=str[ind-1];                  // append identified group index in result\\n            str.erase(ind-1,1);               // shorten intiial pemutation by 1.\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n string getPermutation(int n, int k) {\\n        string str=\"\";\\n        int fact[] = {1,1,2,6,24,120,720,5040,40320,362880};\\n        for(int i=1;i<=n;i++)\\n        {\\n            str+=to_string(i);\\n        }       \\n        string res = \"\";\\n        while(n>=1)\\n        {\\n            int ind = ceil(k*1.0/fact[n-1]);  // 1.0 because we want to use ceil\\n            k = k%fact[n-1];                  //n-1 because of 0 based indexing\\n            k = (k==0)?fact[n-1]:k;           // need atleast 1 permutation from the next group\\n            n--;                                     \\n            res+=str[ind-1];                  // append identified group index in result\\n            str.erase(ind-1,1);               // shorten intiial pemutation by 1.\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 371641,
                "title": "100-percent-time-and-memory-with-explanation",
                "content": "Explanation:\\n1.  Since n! = n * (n-1)! we can imagine that the possible permutations are divided into n groups of size (n-1)! each\\n2.  Now we have to find the right group where kth permutation exists which we find by using `int idx = k % f == 0 ? k/f - 1 : k/f;`\\n3.  Now within the group of (n-1)! total permutations we want to find `k = k-(idx*f);` th permutation and for that we apply the same logic again \\n\\n```\\nclass Solution {\\npublic:\\n    int fact[10] = {1,1,2,6,24,120,720,5040,40320,362880};\\n    \\n    string getPermutation(int n, int k) {\\n        \\n        string temp = \"\";\\n        for(int i=1; i<=n; i++){\\n            temp += \\'0\\'+i;\\n        }\\n  \\n        vector<int> indices;\\n        \\n        while(n){\\n            int f = fact[n-1];\\n            int idx = k % f == 0 ? k/f - 1 : k/f;\\n            k = k-(idx*f);\\n            n--;\\n            indices.push_back(idx);\\n        }\\n        \\n        string ans = \"\";\\n        for(int i : indices){\\n            ans += temp[i];\\n            temp.erase(i,1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fact[10] = {1,1,2,6,24,120,720,5040,40320,362880};\\n    \\n    string getPermutation(int n, int k) {\\n        \\n        string temp = \"\";\\n        for(int i=1; i<=n; i++){\\n            temp += \\'0\\'+i;\\n        }\\n  \\n        vector<int> indices;\\n        \\n        while(n){\\n            int f = fact[n-1];\\n            int idx = k % f == 0 ? k/f - 1 : k/f;\\n            k = k-(idx*f);\\n            n--;\\n            indices.push_back(idx);\\n        }\\n        \\n        string ans = \"\";\\n        for(int i : indices){\\n            ans += temp[i];\\n            temp.erase(i,1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310294,
                "title": "c-memorize-solution-follow-the-cook-book-make-a-mean-potato-pie",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string getPermutation(int n, int k) {\\n        \\n        //Build the factorials memo.\\n        int aFac[n + 1];\\n        aFac[0] = 1;\\n        for (int i=1;i<=n;i++) { aFac[i] = i * aFac[i - 1]; }\\n        \\n        //Reverse the factorials list.\\n        int aLo = 0, aHi = n - 1;\\n        while (aLo < aHi) {\\n            swap(aFac[aLo++], aFac[aHi--]);\\n        }\\n        \\n        //This is our \"bucket\" of numbers to pick from.\\n        char aList[n + 1];\\n        for (int i=0;i<n;i++) {\\n            aList[i] = \\'1\\' + i;\\n        }\\n        int aListCount = n;\\n        \\n        //Storage for our result.\\n        char aRes[n + 1];\\n        aRes[n] = 0;\\n        \\n        \\n        int aIndex = 0;\\n        --k;\\n        \\n        for (int i=0;i<n;i++) {\\n            \\n            //The element we pick. One factorial less than N, divide k by this. This is our \"first letter\" for the \"sub problem\" ...\\n            aIndex = k / aFac[i];\\n            \\n            aRes[i] = aList[aIndex];\\n            \\n            //Delete from list.\\n            for (int j=aIndex + 1;j<aListCount;j++) { aList[j - 1] = aList[j]; }\\n            --aListCount;\\n            \\n            //Remove these permutations from remaining K.\\n            k -= aIndex * aFac[i];\\n            \\n        }\\n        \\n        return string(aRes);\\n    }\\n};\\n```\\n\\nHot ziggity. It\\'s on fire bro.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string getPermutation(int n, int k) {\\n        \\n        //Build the factorials memo.\\n        int aFac[n + 1];\\n        aFac[0] = 1;\\n        for (int i=1;i<=n;i++) { aFac[i] = i * aFac[i - 1]; }\\n        \\n        //Reverse the factorials list.\\n        int aLo = 0, aHi = n - 1;\\n        while (aLo < aHi) {\\n            swap(aFac[aLo++], aFac[aHi--]);\\n        }\\n        \\n        //This is our \"bucket\" of numbers to pick from.\\n        char aList[n + 1];\\n        for (int i=0;i<n;i++) {\\n            aList[i] = \\'1\\' + i;\\n        }\\n        int aListCount = n;\\n        \\n        //Storage for our result.\\n        char aRes[n + 1];\\n        aRes[n] = 0;\\n        \\n        \\n        int aIndex = 0;\\n        --k;\\n        \\n        for (int i=0;i<n;i++) {\\n            \\n            //The element we pick. One factorial less than N, divide k by this. This is our \"first letter\" for the \"sub problem\" ...\\n            aIndex = k / aFac[i];\\n            \\n            aRes[i] = aList[aIndex];\\n            \\n            //Delete from list.\\n            for (int j=aIndex + 1;j<aListCount;j++) { aList[j - 1] = aList[j]; }\\n            --aListCount;\\n            \\n            //Remove these permutations from remaining K.\\n            k -= aIndex * aFac[i];\\n            \\n        }\\n        \\n        return string(aRes);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309503,
                "title": "simple-python-solution-with-thinking-process-beat-99-69",
                "content": "For the permutations of n, \\nthe first (n-1)! permutations are [1] + permutations of {2, 3, ..., n},\\nthe next (n-1)! permutations are [2] + permutations of {1, 3, ..., n},\\n... and so on. \\n```\\n    def getPermutation(self, n: int, k: int) -> str:\\n        factors = [1]\\n        for i in range(1, n):\\n            factors.append(factors[-1] * i)\\n        factors.reverse()\\n        result = \\'\\'\\n        digits = [str(x) for x in range(1, n+1)]\\n        k -= 1\\n        for i in range(n):\\n            index, k = divmod(k, factors[i]) # factors[i] = math.factorial(n-1-i)\\n            fst_digit = digits[index]\\n            result += fst_digit\\n            digits.remove(fst_digit)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\n    def getPermutation(self, n: int, k: int) -> str:\\n        factors = [1]\\n        for i in range(1, n):\\n            factors.append(factors[-1] * i)\\n        factors.reverse()\\n        result = \\'\\'\\n        digits = [str(x) for x in range(1, n+1)]\\n        k -= 1\\n        for i in range(n):\\n            index, k = divmod(k, factors[i]) # factors[i] = math.factorial(n-1-i)\\n            fst_digit = digits[index]\\n            result += fst_digit\\n            digits.remove(fst_digit)\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 297433,
                "title": "python-8-ms-faster-than-100-of-solutions-10-lines-of-code",
                "content": "```\\nimport math\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        combinations = math.factorial(n)\\n        nums = [str(i) for i in range(1, n+1)]\\n        digits = \\'\\'\\n        for i in range(n, 1, -1):\\n            combinations = combinations/i\\n            (bucket, k) = divmod(k, combinations)\\n            if k == 0: bucket -= 1\\n            digits += nums[bucket]\\n            del nums[bucket]\\n        return digits + nums[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport math\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        combinations = math.factorial(n)\\n        nums = [str(i) for i in range(1, n+1)]\\n        digits = \\'\\'\\n        for i in range(n, 1, -1):\\n            combinations = combinations/i\\n            (bucket, k) = divmod(k, combinations)\\n            if k == 0: bucket -= 1\\n            digits += nums[bucket]\\n            del nums[bucket]\\n        return digits + nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 170412,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        fact = [1]*(n)\\n        digits = [i for i in range(1,10)]\\n        for i in range(2,n):\\n            fact[i] = i * fact[i-1]\\n        summ = 0\\n        res = \"\"\\n        k -= 1\\n        for i in range(n-1,-1,-1):\\n            q, k = divmod(k, fact[i])\\n            res += str(digits.pop(q))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        fact = [1]*(n)\\n        digits = [i for i in range(1,10)]\\n        for i in range(2,n):\\n            fact[i] = i * fact[i-1]\\n        summ = 0\\n        res = \"\"\\n        k -= 1\\n        for i in range(n-1,-1,-1):\\n            q, k = divmod(k, fact[i])\\n            res += str(digits.pop(q))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 22600,
                "title": "java-iterative-solution",
                "content": "        \\n    public String getPermutation(int n, int k) {\\n        List<Integer> nums = new LinkedList<>();\\n        for (int i = 1; i <= n; i++) {\\n            nums.add(i);\\n        }\\n        String ret = \"\";\\n        k--;\\n        while (!nums.isEmpty()) {\\n            int f = fact(n-1);\\n            int i = k / f;\\n            ret += nums.get(i).toString();\\n            nums.remove(i);\\n            k -= k/f*f;\\n            n--;\\n        }\\n        return ret;\\n    }\\n    \\n    private int fact(int n) {\\n        int ret = 1;\\n        for (int i = 1; i <= n; i++) {\\n            ret *= i;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "        \\n    public String getPermutation(int n, int k) {\\n        List<Integer> nums = new LinkedList<>();\\n        for (int i = 1; i <= n; i++) {\\n            nums.add(i);\\n        }\\n        String ret = \"\";\\n        k--;\\n        while (!nums.isEmpty()) {\\n            int f = fact(n-1);\\n            int i = k / f;\\n            ret += nums.get(i).toString();\\n            nums.remove(i);\\n            k -= k/f*f;\\n            n--;\\n        }\\n        return ret;\\n    }\\n    \\n    private int fact(int n) {\\n        int ret = 1;\\n        for (int i = 1; i <= n; i++) {\\n            ret *= i;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 22653,
                "title": "another-solution-in-java-with-explanation-no-loop-no-swap-easy-understanding-200ms",
                "content": "    public String getPermutation(int n, int k) {\\n        List<Integer> participate = new ArrayList<>(n);\\n        if (n <= 1) {\\n            return \"1\";\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            participate.add(i);//build an initial list\\n        }\\n        return recur(n, k - 1, participate, new StringBuilder(n));//k-1 for get element from list\\n    }\\n\\n    private String recur(int n, int k, List<Integer> participate, StringBuilder sb) {\\n        if (n == 2) {\\n            sb.append(participate.get(k));\\n            participate.remove(k);\\n            sb.append(participate.get(participate.size() - 1));\\n            return sb.toString();\\n        }\\n        int x = fac(n); // x: sequence length Example: n = 5, there are 5 sequences start with 1 to 5, each sequence has 24 items\\n        int i = k / x; // i: which sequence the search k it belong. Example: n=4 k=8, i=(8-1)/6=1. so the start number should be 2\\n        sb.append(participate.get(i));\\n        participate.remove(i);\\n        return recur(n - 1, k % x, participate, sb);\\n    }\\n\\n    private int fac(int n) {\\n        int sum = 1;\\n        for (int i = 1; i < n; i++) {\\n            sum *= i;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String getPermutation(int n, int k) {\\n        List<Integer> participate = new ArrayList<>(n);\\n        if (n <= 1) {\\n            return \"1\";\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            participate.add(i);//build an initial list\\n        }\\n        return recur(n, k - 1, participate, new StringBuilder(n));//k-1 for get element from list\\n    }\\n\\n    private String recur(int n, int k, List<Integer> participate, StringBuilder sb) {\\n        if (n == 2) {\\n            sb.append(participate.get(k));\\n            participate.remove(k);\\n            sb.append(participate.get(participate.size() - 1));\\n            return sb.toString();\\n        }\\n        int x = fac(n); // x: sequence length Example: n = 5, there are 5 sequences start with 1 to 5, each sequence has 24 items\\n        int i = k / x; // i: which sequence the search k it belong. Example: n=4 k=8, i=(8-1)/6=1. so the start number should be 2\\n        sb.append(participate.get(i));\\n        participate.remove(i);\\n        return recur(n - 1, k % x, participate, sb);\\n    }\\n\\n    private int fac(int n) {\\n        int sum = 1;\\n        for (int i = 1; i < n; i++) {\\n            sum *= i;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 22670,
                "title": "c-0ms-observation-solution",
                "content": "    class Solution {\\n    public:\\n        string getPermutation(int n, int k) {\\n            int mloop[10] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};\\n            string ans;\\n            vector<int> remain;\\n            for (int i = 1; i <= n; ++i) {\\n                remain.push_back(i);\\n            }\\n            for (int i = n; i > 0; --i) {\\n                int j = ((k - 1) % mloop[i]) / mloop[i - 1];\\n                ans += (remain[j] + '0');\\n                remain.erase(remain.begin() + j);\\n            }\\n            return ans;\\n        }\\n    };\\n\\n    ()1234           (1)234         (12)34        (123)4\\n    1 1234           1 234           1 34     =>    1 4\\n    2 1243           2 243     =>    2 43\\n    3 1324           3 324\\n    4 1342  =>       4 3....\\n    5 1423\\n    6 1432\\n    7 2134\\n    8 2......",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string getPermutation(int n, int k) {\\n            int mloop[10] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880}",
                "codeTag": "Java"
            },
            {
                "id": 22678,
                "title": "c-4ms-recursive-solution-with-explanation",
                "content": "\\n\\n    // We have to return the k-th permutation \\n    // in lexicographic order.\\n    //\\n    // We can take a recursive approach.\\n    // The lexicographic order means that first\\n    // we have those starting with digit 1 then\\n    // those starting with 2 and so on until\\n    // digit n.\\n    // \\n    // For example, for n = 4, we have: \\n    // k   perm\\n    // --------\\n    // 1   1234\\n    // 2   1243\\n    // 3   1324\\n    // 4   1342\\n    // 5   1423\\n    // 6   1432\\n    //\\n    // 7   2134\\n    // 8   2143\\n    // 9   2314\\n    // 10  2341\\n    // 11  2413\\n    // 12  2431\\n    // \\n    // 13  3124\\n    // 14  3142\\n    // 15  3214\\n    // 16  3241\\n    // 17  3412\\n    // 18  3421\\n    // \\n    // 19  4123\\n    // 20  4132\\n    // 21  4213\\n    // 22  4231\\n    // 23  4312\\n    // 24  4321\\n    //\\n    // Since there are n digits, the number of all \\n    // permutations starting with a given digit d\\n    // is equal to (n-1)!.\\n    // Given k, the permutation order number,\\n    // we can determine which one is the first \\n    // digit d: d = [(k-1)/(n-1)!]+1;\\n    // \\n    // Once we determined the first digit\\n    // we recursively determine the remaining\\n    // digits.\\n    // \\n    // We keep all digits in a vector: {1,2,3,...,n}.\\n    // Once we determine a digit we remove it\\n    // from there and recursively solve\\n    // the problem for the remaining n-1 digits.\\n    // The formula above to determine the digit\\n    // is written slightly different in code\\n    // such that instead of the digit we first\\n    // get its index in this vector.\\n    //\\n    // From k we can also determine k for the\\n    // n-1 problem as: prevK = k%prevFact.\\n    // This is the order number within the \\n    // current digit's group.\\n    //\\n    // Now we can recursively solve the problem \\n    // for n-1 and prevK and determine the rest \\n    // of the digits.\\n    //\\n    class Solution\\n    {\\n        int factorial(int n)\\n        {\\n            int fact = 1;\\n            for (int i = 1; i <= n; i++)\\n                fact *= i;\\n    \\n            return fact;\\n        }\\n    \\n        string getPermutation(int n, int k, vector<int>& digits)\\n        {\\n            if (n == 1)\\n            {\\n                return to_string(digits[0]);\\n            }\\n    \\n            int prevFact = factorial(n - 1);\\n    \\n            int idx = (k - 1) / prevFact;\\n            int d = digits[idx];\\n    \\n            digits.erase(digits.begin() + idx);\\n    \\n            int prevK = k%prevFact;\\n            if (prevK == 0)\\n                prevK = prevFact;\\n    \\n            string prev = getPermutation(n - 1, prevK, digits);\\n    \\n            return to_string(d) + prev;\\n        }\\n    \\n    public:\\n        string getPermutation(int n, int k)\\n        {\\n            vector<int> digits;\\n            for (int i = 1; i <= n; i++)\\n            {\\n                digits.push_back(i);\\n            }\\n    \\n            return getPermutation(n, k, digits);\\n        }\\n    };",
                "solutionTags": [
                    "Recursion",
                    "Probability and Statistics"
                ],
                "code": "class Solution\\n    {\\n        int factorial(int n)\\n        {\\n            int fact = 1;\\n            for (int i = 1; i <= n; i++)\\n                fact *= i;\\n    \\n            return fact;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4061982,
                "title": "python-10ms-solution",
                "content": "# Intuition\\nFor this problem, my first realization was that for each starting number there are (n-1)! possibilites. Eg:\\n\\nn=4\\nfor the starting number 1 the possiblities are:\\n1,2,3,4\\n1,2,4,3\\n1,3,2,4\\n1,3,4,2\\n1,4,2,3\\n1,4,3,2\\nThere are 6 possibilities which is the same as 3!\\nSo with this, we should be able to through each digit and to find the proper number permutation. \\n\\n# Approach\\nSomething to realize is that you can you can find the starting number for the permutation by doing k/(n-1)!\\nThis is because for each possible starting number 1-n, there are (n-1)! possibilities, so if we divide k by this, we will get the starting number. \\n\\nSo you keep doing this for each digit. We divide k by (n-1)!, then add the integer part. K will then become whatever the remainder is, because we are subtracting that many possiblities. \\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        #For each starting number there are (n-1)! possiblities. So the trick is you can find which digit it is by \\n        #Doing k/(n-1)!, and you get the starting number that fits that range, so you keep doing taht untill you reach the answer\\n        if k==1:\\n            return \"\".join([str(a) for a in range(1,n+1)])\\n        ans=\"\"\\n        possible=[a for a in range(1,n+1)]\\n        k-=1#Because arrays start at 0, and this k starts at 1\\n        while n>0:\\n            n-=1\\n            index,k=divmod(k,math.factorial(n))\\n            ans+=str(possible[index])\\n            possible.pop(index)\\n        return ans\\n\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def getPermutation(self, n, k):\\n        #For each starting number there are (n-1)! possiblities. So the trick is you can find which digit it is by \\n        #Doing k/(n-1)!, and you get the starting number that fits that range, so you keep doing taht untill you reach the answer\\n        if k==1:\\n            return \"\".join([str(a) for a in range(1,n+1)])\\n        ans=\"\"\\n        possible=[a for a in range(1,n+1)]\\n        k-=1#Because arrays start at 0, and this k starts at 1\\n        while n>0:\\n            n-=1\\n            index,k=divmod(k,math.factorial(n))\\n            ans+=str(possible[index])\\n            possible.pop(index)\\n        return ans\\n\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050510,
                "title": "permutation-sequence-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n       \\t\\n        string getPermutation(int n, int k)\\n        {\\n            string ans = \"\";\\n            vector<int> numbers;\\n            int fact = 1;\\n            for (int i = 1; i <= n; i++)\\n            {\\n                fact = fact * i;\\n                numbers.push_back(i);\\n            }\\n            int blockSize = fact / n;\\n            k = k - 1;\\n            while (true)\\n            {\\n                ans += to_string(numbers[k / blockSize]);\\t\\n                numbers.erase(numbers.begin() + k / blockSize);\\n                if (numbers.size() == 0)\\n                {\\n                    break;\\n                }\\n                k = k % blockSize;\\n                blockSize = blockSize / numbers.size();\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n       \\t\\n        string getPermutation(int n, int k)\\n        {\\n            string ans = \"\";\\n            vector<int> numbers;\\n            int fact = 1;\\n            for (int i = 1; i <= n; i++)\\n            {\\n                fact = fact * i;\\n                numbers.push_back(i);\\n            }\\n            int blockSize = fact / n;\\n            k = k - 1;\\n            while (true)\\n            {\\n                ans += to_string(numbers[k / blockSize]);\\t\\n                numbers.erase(numbers.begin() + k / blockSize);\\n                if (numbers.size() == 0)\\n                {\\n                    break;\\n                }\\n                k = k % blockSize;\\n                blockSize = blockSize / numbers.size();\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972282,
                "title": "most-optimal-solution-without-using-recursion-and-backtracking-with-complete-exaplanation",
                "content": "\\n\\n# Approach\\nThe given solution aims to find the kth permutation sequence of numbers from 1 to n. It uses a mathematical approach to determine the digits of the kth permutation by repeatedly calculating the factorial of (n-1), identifying the next digit in the permutation, and updating the remaining digits.\\n\\nHere\\'s the explanation of the solution steps:\\n\\n1. Calculate the factorial of (n-1) to determine the count of permutations that can be formed with the remaining digits.\\n2. Create a list called nums containing numbers from 1 to n.\\n3. Adjust k to be 0-based (k = k - 1).\\n4. Repeatedly find the next digit in the permutation by dividing k by the current factorial value. This indicates which digit from the remaining digits list should be added to the answer.\\n5. Remove the selected digit from the nums list.\\n6. Update k by taking the remainder after division by the current factorial value.\\n7. Update the factorial value by dividing it by the size of the nums list.\\n8. Repeat steps 4-7 until all digits are added to the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> nums;\\n        \\n        for (int i = 1; i < n; i++) {\\n            fact = fact * i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        \\n        string ans = \"\";\\n        k = k - 1;\\n        \\n        while (true) {\\n            ans = ans + to_string(nums[k / fact]);\\n            nums.erase(nums.begin() + k / fact);\\n            \\n            if (nums.size() == 0) {\\n                break;\\n            }\\n            \\n            k = k % fact;\\n            fact = fact / nums.size();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n```JAVA []\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        List<Integer> nums = new ArrayList<>();\\n        \\n        for (int i = 1; i < n; i++) {\\n            fact *= i;\\n            nums.add(i);\\n        }\\n        nums.add(n);\\n        \\n        StringBuilder ans = new StringBuilder();\\n        k--;\\n        \\n        while (true) {\\n            ans.append(nums.get(k / fact));\\n            nums.remove(k / fact);\\n            \\n            if (nums.isEmpty()) {\\n                break;\\n            }\\n            \\n            k %= fact;\\n            fact /= nums.size();\\n        }\\n        \\n        return ans.toString();\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        fact = 1\\n        nums = list(range(1, n + 1))\\n        \\n        for i in range(1, n):\\n            fact *= i\\n        \\n        ans = []\\n        k -= 1\\n        \\n        while True:\\n            ans.append(str(nums[k // fact]))\\n            nums.pop(k // fact)\\n            \\n            if not nums:\\n                break\\n            \\n            k %= fact\\n            fact //= len(nums)\\n        \\n        return \\'\\'.join(ans)\\n**Bold**\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> nums;\\n        \\n        for (int i = 1; i < n; i++) {\\n            fact = fact * i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        \\n        string ans = \"\";\\n        k = k - 1;\\n        \\n        while (true) {\\n            ans = ans + to_string(nums[k / fact]);\\n            nums.erase(nums.begin() + k / fact);\\n            \\n            if (nums.size() == 0) {\\n                break;\\n            }\\n            \\n            k = k % fact;\\n            fact = fact / nums.size();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\n```JAVA []\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        List<Integer> nums = new ArrayList<>();\\n        \\n        for (int i = 1; i < n; i++) {\\n            fact *= i;\\n            nums.add(i);\\n        }\\n        nums.add(n);\\n        \\n        StringBuilder ans = new StringBuilder();\\n        k--;\\n        \\n        while (true) {\\n            ans.append(nums.get(k / fact));\\n            nums.remove(k / fact);\\n            \\n            if (nums.isEmpty()) {\\n                break;\\n            }\\n            \\n            k %= fact;\\n            fact /= nums.size();\\n        }\\n        \\n        return ans.toString();\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        fact = 1\\n        nums = list(range(1, n + 1))\\n        \\n        for i in range(1, n):\\n            fact *= i\\n        \\n        ans = []\\n        k -= 1\\n        \\n        while True:\\n            ans.append(str(nums[k // fact]))\\n            nums.pop(k // fact)\\n            \\n            if not nums:\\n                break\\n            \\n            k %= fact\\n            fact //= len(nums)\\n        \\n        return \\'\\'.join(ans)\\n**Bold**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803225,
                "title": "best-solution-possible-world-record-iq-10000",
                "content": "# Intuition\\nSolve more problems you will get the intuition. \\n\\n# Approach\\nArey bindu, dekh agar n=5 hai toh agar mai kisi ek number from 1-5 ko first element banata hu toh 4! options hoga each ka. \\n\\nAgar k = 59 hai, then k = (24 + 24 + 11). \\nThat means starting mai 3 ayega and uske ander permutions hoga further.\\nWhi dekh le re thoda. \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string helper(int n, set<int> st, int k){\\n        // basecase\\n        if(n == st.size()){ return \"\"; }\\n        \\n        // transition\\n        int val = 1;\\n        for(int i = 1; i<n - st.size(); i++) val *= i;\\n\\n        int pos = k/val + (k%val ? 1 : 0);\\n        \\n        string s;\\n        for(int i = 1; i<=n; i++){\\n            if(st.find(i) == st.end() && --pos == 0){\\n                st.insert(i);\\n                s = \\'0\\' + i;\\n                break;\\n            }\\n        }\\n\\n        return s + helper(n, st, (k % val) ? (k % val) : val);\\n    }\\n\\n    string getPermutation(int n, int k) {\\n        set<int> st;\\n        return helper(n, st, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string helper(int n, set<int> st, int k){\\n        // basecase\\n        if(n == st.size()){ return \"\"; }\\n        \\n        // transition\\n        int val = 1;\\n        for(int i = 1; i<n - st.size(); i++) val *= i;\\n\\n        int pos = k/val + (k%val ? 1 : 0);\\n        \\n        string s;\\n        for(int i = 1; i<=n; i++){\\n            if(st.find(i) == st.end() && --pos == 0){\\n                st.insert(i);\\n                s = \\'0\\' + i;\\n                break;\\n            }\\n        }\\n\\n        return s + helper(n, st, (k % val) ? (k % val) : val);\\n    }\\n\\n    string getPermutation(int n, int k) {\\n        set<int> st;\\n        return helper(n, st, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546130,
                "title": "beats-100-0ms-cpp-intuitive-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        if(n==0 || n==1)    return to_string(n);\\n        vector<int> seq;\\n        for(int i=1;i<n;i++)\\n        {\\n            seq.push_back(i);\\n            fact*=i;\\n        }\\n        seq.push_back(n);\\n        k-=1;\\n        string  ans=\"\";\\n        \\n        while(seq.size()!=0){\\n            int pos=k/fact;\\n            ans+=to_string(seq[pos]);\\n            seq.erase(seq.begin()+pos);\\n            if(seq.size()==0)   break; //put this line to avoid divide by zero exception\\n            k=k%fact;\\n            fact=fact/seq.size();\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        if(n==0 || n==1)    return to_string(n);\\n        vector<int> seq;\\n        for(int i=1;i<n;i++)\\n        {\\n            seq.push_back(i);\\n            fact*=i;\\n        }\\n        seq.push_back(n);\\n        k-=1;\\n        string  ans=\"\";\\n        \\n        while(seq.size()!=0){\\n            int pos=k/fact;\\n            ans+=to_string(seq[pos]);\\n            seq.erase(seq.begin()+pos);\\n            if(seq.size()==0)   break; //put this line to avoid divide by zero exception\\n            k=k%fact;\\n            fact=fact/seq.size();\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477699,
                "title": "easy-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        int fact = 1;\\n        for(int i = 1;i<n;i++){\\n            arr.add(i);\\n            fact*=i;\\n        }\\n        k = k-1;\\n        String s = \"\";\\n        arr.add(n);\\n        while(true){\\n            s += \"\"+arr.get(k/fact);\\n            arr.remove(Integer.valueOf(arr.get(k/fact)));\\n            if(arr.size() == 0){\\n                break;\\n            }\\n            k = k%fact;\\n            fact = fact/arr.size();\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        int fact = 1;\\n        for(int i = 1;i<n;i++){\\n            arr.add(i);\\n            fact*=i;\\n        }\\n        k = k-1;\\n        String s = \"\";\\n        arr.add(n);\\n        while(true){\\n            s += \"\"+arr.get(k/fact);\\n            arr.remove(Integer.valueOf(arr.get(k/fact)));\\n            if(arr.size() == 0){\\n                break;\\n            }\\n            k = k%fact;\\n            fact = fact/arr.size();\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370125,
                "title": "c-beats-100-t-c-o-n-2-s-c-o-n",
                "content": "```\\nclass Solution {\\n\\n\\t/*\\n\\t\\tTime Complexity : O(N^2)\\n\\t\\tSpace Complexity : O(N)\\n\\t*/\\n\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> nums;\\n        \\n        // calculate fact till n-1\\n        for(int i=1; i<n; i++){\\n            fact *= i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        \\n        k -= 1; // as we are using 0-based indexing\\n        \\n        string res = \"\";\\n        \\n        while(true){\\n            res += to_string(nums[k/fact]);\\n            nums.erase(nums.begin() + k/fact);\\n            \\n            if(nums.size() == 0) break; // no more elements left\\n            \\n            k %= fact;\\n            fact /= nums.size();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n\\t/*\\n\\t\\tTime Complexity : O(N^2)\\n\\t\\tSpace Complexity : O(N)\\n\\t*/\\n\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> nums;\\n        \\n        // calculate fact till n-1\\n        for(int i=1; i<n; i++){\\n            fact *= i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n        \\n        k -= 1; // as we are using 0-based indexing\\n        \\n        string res = \"\";\\n        \\n        while(true){\\n            res += to_string(nums[k/fact]);\\n            nums.erase(nums.begin() + k/fact);\\n            \\n            if(nums.size() == 0) break; // no more elements left\\n            \\n            k %= fact;\\n            fact /= nums.size();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298632,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        List<Integer>list=new ArrayList<>();\\n        int fact=1;\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            list.add(i);\\n        }\\n        list.add(n);\\n        k=k-1;\\n        String ans=\"\";\\n        while(true){\\n            ans+=list.get(k/fact);\\n            list.remove(k/fact);\\n            if(list.size()==0){\\n                break;\\n            }\\n            k=k%fact;\\n            fact=fact/list.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        List<Integer>list=new ArrayList<>();\\n        int fact=1;\\n        for(int i=1;i<n;i++){\\n            fact=fact*i;\\n            list.add(i);\\n        }\\n        list.add(n);\\n        k=k-1;\\n        String ans=\"\";\\n        while(true){\\n            ans+=list.get(k/fact);\\n            list.remove(k/fact);\\n            if(list.size()==0){\\n                break;\\n            }\\n            k=k%fact;\\n            fact=fact/list.size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293254,
                "title": "easy-4-steps-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        List<Integer> al = new ArrayList<>();\\n        for(int i = 1;i < n; i++){\\n            fact *= i;\\n            al.add(i);\\n        }\\n        al.add(n);\\n        String ans = \"\";\\n        k--;\\n        while(true){\\n            ans += al.get(k / fact); //finding the index where the value should start (MSB)\\n            al.remove(k / fact); // after finding that value we need to delete that from list\\n            if(al.size() == 0)\\n                break; // if list is empty then done;\\n            k %= fact;  //again decrease k value and apply for other values.\\n            fact /= al.size();\\n        }\\n        return ans;\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        List<Integer> al = new ArrayList<>();\\n        for(int i = 1;i < n; i++){\\n            fact *= i;\\n            al.add(i);\\n        }\\n        al.add(n);\\n        String ans = \"\";\\n        k--;\\n        while(true){\\n            ans += al.get(k / fact); //finding the index where the value should start (MSB)\\n            al.remove(k / fact); // after finding that value we need to delete that from list\\n            if(al.size() == 0)\\n                break; // if list is empty then done;\\n            k %= fact;  //again decrease k value and apply for other values.\\n            fact /= al.size();\\n        }\\n        return ans;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176505,
                "title": "beats-99-7-60-permutation-sequence-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere, we use a simple factorial approach. First, we calculate all the factorials up to n, and use that to find the next number to add to the result. We start from the last factorial and keep adding numbers to the result, decrementing k and removing the selected number from the list. This continues until all numbers have been added to the result and k becomes 0. We return the result as a single string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        nums = [i for i in range(1, n+1)] # list of numbers from 1 to n\\n        factorial = [1] * n # initialize factorial with n factorial of 1\\n        for i in range(1, n):\\n            factorial[i] = factorial[i-1] * i # calculate the factorials\\n        \\n        k -= 1 # decrement k by 1, since k is 1-indexed\\n        result = []\\n        for i in range(n-1, -1, -1):\\n            index = k // factorial[i] # calculate the index of the number to be picked\\n            result.append(str(nums[index])) # add the number to result\\n            nums.pop(index) # remove the number from the list\\n            k = k % factorial[i] # update k\\n        \\n        return \\'\\'.join(result) # join the result list into a single string and return\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        nums = [i for i in range(1, n+1)] # list of numbers from 1 to n\\n        factorial = [1] * n # initialize factorial with n factorial of 1\\n        for i in range(1, n):\\n            factorial[i] = factorial[i-1] * i # calculate the factorials\\n        \\n        k -= 1 # decrement k by 1, since k is 1-indexed\\n        result = []\\n        for i in range(n-1, -1, -1):\\n            index = k // factorial[i] # calculate the index of the number to be picked\\n            result.append(str(nums[index])) # add the number to result\\n            nums.pop(index) # remove the number from the list\\n            k = k % factorial[i] # update k\\n        \\n        return \\'\\'.join(result) # join the result list into a single string and return\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133297,
                "title": "recursion-easy-approach-c",
                "content": "# Intuition\\nJust keep fixing the position of element by finding their relevant group. Then remove that fixed element from the data strucuture i.e. vector. Check for remaining elements until vector is empty.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ \\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> numbers;\\n        for(int i=1;i<n;i++){\\n            // To find (n-1)!\\n            fact = fact*i;\\n            numbers.push_back(i);\\n        }\\n        numbers.push_back(n);\\n        string ans=\"\";\\n        k = k-1;\\n        while(true){\\n            //Add the first element of reqd permutation\\n            ans = ans + to_string(numbers[k/fact]);\\n            //Erase that element from vector \\n            numbers.erase(numbers.begin() + k/fact);\\n            if(numbers.size()==0) break;\\n            //Find the position for remaining elements\\n            k = k%fact;\\n            //Find the reqd factorial\\n            fact = fact/numbers.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact = 1;\\n        vector<int> numbers;\\n        for(int i=1;i<n;i++){\\n            // To find (n-1)!\\n            fact = fact*i;\\n            numbers.push_back(i);\\n        }\\n        numbers.push_back(n);\\n        string ans=\"\";\\n        k = k-1;\\n        while(true){\\n            //Add the first element of reqd permutation\\n            ans = ans + to_string(numbers[k/fact]);\\n            //Erase that element from vector \\n            numbers.erase(numbers.begin() + k/fact);\\n            if(numbers.size()==0) break;\\n            //Find the position for remaining elements\\n            k = k%fact;\\n            //Find the reqd factorial\\n            fact = fact/numbers.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106468,
                "title": "6ms-o-n-2-efficient-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact =1;\\n        vector<int>numbers;\\n        for(int i =1 ;i<n;i++){\\n            fact = fact*i;\\n            numbers.push_back(i);\\n        }\\n        numbers.push_back(n);\\n        string ans =\"\";\\n        k = k-1;\\n\\n        while(true){\\n            ans = ans+ to_string(numbers[k/fact]);\\n            numbers.erase(numbers.begin() + k/fact);\\n            if(numbers.size()==0){\\n                break;\\n            }\\n            k = k%fact;\\n            fact = fact/numbers.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact =1;\\n        vector<int>numbers;\\n        for(int i =1 ;i<n;i++){\\n            fact = fact*i;\\n            numbers.push_back(i);\\n        }\\n        numbers.push_back(n);\\n        string ans =\"\";\\n        k = k-1;\\n\\n        while(true){\\n            ans = ans+ to_string(numbers[k/fact]);\\n            numbers.erase(numbers.begin() + k/fact);\\n            if(numbers.size()==0){\\n                break;\\n            }\\n            k = k%fact;\\n            fact = fact/numbers.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028301,
                "title": "c-easy-to-understand-beats-100-percent",
                "content": "please upvote if you like the solution.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\" ;\\n        vector<int>ds ;\\n        for(int i = 1 ; i <= n ; i++){\\n            ds.push_back(i) ;\\n        }\\n        int i = n ;\\n        while(k!= 0 && i >= 1){\\n            int r = fact(i-1) ;\\n            int c = check(r,k) ;\\n            s += to_string(ds[c]) ;\\n            ds.erase(ds.begin()+c) ;\\n            k = k -r*c ;\\n            i-- ;\\n        }\\n        return s ;\\n    }\\n    int check(int a ,int k){\\n        if(k%a == 0)return (k/a) - 1 ;\\n        return k/a ;\\n    }\\n    int fact(int n){\\n        if(n == 0)return 1 ;\\n        return n*fact(n-1) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\" ;\\n        vector<int>ds ;\\n        for(int i = 1 ; i <= n ; i++){\\n            ds.push_back(i) ;\\n        }\\n        int i = n ;\\n        while(k!= 0 && i >= 1){\\n            int r = fact(i-1) ;\\n            int c = check(r,k) ;\\n            s += to_string(ds[c]) ;\\n            ds.erase(ds.begin()+c) ;\\n            k = k -r*c ;\\n            i-- ;\\n        }\\n        return s ;\\n    }\\n    int check(int a ,int k){\\n        if(k%a == 0)return (k/a) - 1 ;\\n        return k/a ;\\n    }\\n    int fact(int n){\\n        if(n == 0)return 1 ;\\n        return n*fact(n-1) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023786,
                "title": "python-beats-98-easy-optimum-solution",
                "content": "**This is optimum question **\\n```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        s=[]\\n        for i in range(n):\\n            s.append(str(i+1))\\n        \\n        def fun(s,k,l):\\n            p=[]\\n            fact=factorial(l)\\n            #print(fact)\\n            while (s!=[]): \\n                fact=fact//l\\n                #print(fact)\\n                i,k=divmod(k,fact)\\n                #print(i,k)\\n                x=s[i] \\n                p.append(x) \\n                s=s[:i]+s[i+1:]\\n                #print(s)\\n                l-=1\\n                #print(p)\\n            return \"\".join(p)\\n        \\n        return fun(s,k-1,n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        s=[]\\n        for i in range(n):\\n            s.append(str(i+1))\\n        \\n        def fun(s,k,l):\\n            p=[]\\n            fact=factorial(l)\\n            #print(fact)\\n            while (s!=[]): \\n                fact=fact//l\\n                #print(fact)\\n                i,k=divmod(k,fact)\\n                #print(i,k)\\n                x=s[i] \\n                p.append(x) \\n                s=s[:i]+s[i+1:]\\n                #print(s)\\n                l-=1\\n                #print(p)\\n            return \"\".join(p)\\n        \\n        return fun(s,k-1,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823057,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s, ans;\\n        for(int i=1; i<=n; i++) s.push_back(i + \\'0\\');\\n        int cnt = 0;\\n        do {\\n            cnt++;\\n            if(cnt == k) {\\n                ans = s;\\n                break;\\n            }\\n        }\\n        while(next_permutation(s.begin(), s.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s, ans;\\n        for(int i=1; i<=n; i++) s.push_back(i + \\'0\\');\\n        int cnt = 0;\\n        do {\\n            cnt++;\\n            if(cnt == k) {\\n                ans = s;\\n                break;\\n            }\\n        }\\n        while(next_permutation(s.begin(), s.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822830,
                "title": "5-lines-only-easy-to-understand-code-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n      string s = \"\";\\n      for(int i = 1 ; i <= n ; i++) s += to_string(i);\\n      if(k == 1) return s; // base case: if k is 1, means the original string is the kth permutation, so return the original string\\n      do{\\n        next_permutation(s.begin(), s.end());\\n        k--;\\n      }\\n      while(k > 1);\\n      return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n      string s = \"\";\\n      for(int i = 1 ; i <= n ; i++) s += to_string(i);\\n      if(k == 1) return s; // base case: if k is 1, means the original string is the kth permutation, so return the original string\\n      do{\\n        next_permutation(s.begin(), s.end());\\n        k--;\\n      }\\n      while(k > 1);\\n      return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817166,
                "title": "c-simple-solution-using-stl-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. create a string\\n2. base case where k=1\\n3. find next permutation until k=1\\n4. when u reach k=1 break the loop\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string ans = \"\";\\n        string temp = \"\";\\n        for(int i=1;i<=n;i++){\\n            temp += to_string(i);\\n        }\\n        if(k == 1){\\n            return temp;\\n        }\\n        while(next_permutation(temp.begin(), temp.end())){\\n            k--;\\n            if(k == 1) {\\n               ans += temp;\\n               break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nPlease Upvote\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string ans = \"\";\\n        string temp = \"\";\\n        for(int i=1;i<=n;i++){\\n            temp += to_string(i);\\n        }\\n        if(k == 1){\\n            return temp;\\n        }\\n        while(next_permutation(temp.begin(), temp.end())){\\n            k--;\\n            if(k == 1) {\\n               ans += temp;\\n               break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nPlease Upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788320,
                "title": "python-solution-iterative-approach-98-76-faster",
                "content": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        def kthperm(string, k):\\n            permutation = [] \\n            length = len(string)\\n            fact = factorial(length)\\n            while (string != []): \\n                fact = fact // length\\n                index, k = divmod(k, fact)\\n                x = string[index] \\n                permutation.append(x) \\n                string = string[:index] + string[index+1:] \\n                length -= 1\\n            return \"\".join(permutation)\\n        \\n        return kthperm([str(i) for i in range(1, n+1)], k-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        def kthperm(string, k):\\n            permutation = [] \\n            length = len(string)\\n            fact = factorial(length)\\n            while (string != []): \\n                fact = fact // length\\n                index, k = divmod(k, fact)\\n                x = string[index] \\n                permutation.append(x) \\n                string = string[:index] + string[index+1:] \\n                length -= 1\\n            return \"\".join(permutation)\\n        \\n        return kthperm([str(i) for i in range(1, n+1)], k-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751645,
                "title": "c-stl-next-permutaton-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\";\\n        for (char i = 1; i <= n; i++) s += to_string(i);\\n        while (k > 1) {\\n            next_permutation(s.begin(), s.end());\\n            k--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string s = \"\";\\n        for (char i = 1; i <= n; i++) s += to_string(i);\\n        while (k > 1) {\\n            next_permutation(s.begin(), s.end());\\n            k--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750757,
                "title": "permutation-sequence",
                "content": "```class Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        fact=1\\n        numbers=[]\\n        ans=\"\"\\n        for i in range(1,n):\\n            fact=fact*i\\n            numbers.append(i)\\n        numbers.append(n) \\n        k=k-1\\n        while(True):\\n            ans = ans + str(numbers[ k//fact ])\\n            numbers.pop( k//fact )\\n            if len(numbers)==0:\\n                break\\n            k=k%fact   \\n            fact=fact//len(numbers)\\n        return ans            \\n            ```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```class Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        fact=1\\n        numbers=[]\\n        ans=\"\"\\n        for i in range(1,n):\\n            fact=fact*i\\n            numbers.append(i)\\n        numbers.append(n) \\n        k=k-1\\n        while(True):\\n            ans = ans + str(numbers[ k//fact ])\\n            numbers.pop( k//fact )\\n            if len(numbers)==0:\\n                break\\n            k=k%fact   \\n            fact=fact//len(numbers)\\n        return ans            \\n            ```",
                "codeTag": "Java"
            },
            {
                "id": 2702315,
                "title": "no-recursion-c-solution",
                "content": "```\\n  string getPermutation(int n, int k) {\\n        int fact = 1;\\n      vector < int > numbers;\\n      for (int i = 1; i < n; i++) {\\n        fact = fact * i;\\n        numbers.push_back(i);\\n      }\\n      numbers.push_back(n);\\n      string ans = \"\";\\n      k = k - 1;\\n      while (true) {\\n        ans = ans + to_string(numbers[k / fact]);\\n        numbers.erase(numbers.begin() + k / fact);\\n        if (numbers.size() == 0) {\\n          break;\\n        }\\n\\n        k = k % fact;\\n        fact = fact / numbers.size();\\n      }\\n      return ans;\\n    }\\n    \\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n  string getPermutation(int n, int k) {\\n        int fact = 1;\\n      vector < int > numbers;\\n      for (int i = 1; i < n; i++) {\\n        fact = fact * i;\\n        numbers.push_back(i);\\n      }\\n      numbers.push_back(n);\\n      string ans = \"\";\\n      k = k - 1;\\n      while (true) {\\n        ans = ans + to_string(numbers[k / fact]);\\n        numbers.erase(numbers.begin() + k / fact);\\n        if (numbers.size() == 0) {\\n          break;\\n        }\\n\\n        k = k % fact;\\n        fact = fact / numbers.size();\\n      }\\n      return ans;\\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2679895,
                "title": "simple-c-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> nums;\\n        stringstream result;\\n\\t\\t\\n\\t\\t//inserting values to the vector\\n        for(int i=1;i<=n;i++){\\n            nums.emplace_back(i);\\n        }\\n        int i=1;\\n\\n\\t\\t//getting the kth permutation of the vector\\n        do{\\n            i++;            \\n        }while(next_permutation(nums.begin(),nums.end()) && i!=k);\\n        \\n        //copying the permuted vector to result\\n\\t\\tcopy(nums.begin(),nums.end(),ostream_iterator<int>(result,\"\"));\\n      return result.str();\\n    }\\n};\\n\\n//please upvote if found helpful....\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> nums;\\n        stringstream result;\\n\\t\\t\\n\\t\\t//inserting values to the vector\\n        for(int i=1;i<=n;i++){\\n            nums.emplace_back(i);\\n        }\\n        int i=1;\\n\\n\\t\\t//getting the kth permutation of the vector\\n        do{\\n            i++;            \\n        }while(next_permutation(nums.begin(),nums.end()) && i!=k);\\n        \\n        //copying the permuted vector to result\\n\\t\\tcopy(nums.begin(),nums.end(),ostream_iterator<int>(result,\"\"));\\n      return result.str();\\n    }\\n};\\n\\n//please upvote if found helpful....\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673298,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int>numbers;\\n        for(int i=1;i<n;i++)\\n        {\\n            fact=fact*i;\\n            numbers.push_back(i);\\n        }\\n        numbers.push_back(n);\\n        string ans =\"\";\\n        k=k-1;\\n        while(true)\\n        {\\n            ans=ans+to_string(numbers[k/fact]);\\n            numbers.erase(numbers.begin()+k/fact);\\n            if(numbers.size()==0) break;\\n            k=k%fact;\\n            fact=fact/numbers.size();\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n//First find (n-1)!\\n//ex:\\n//1 2 3 4\\n// push all numbers in a vector in sorted order\\n// as total number of permutation formed is 4! , it is divided equally ,like first (n-1)! numbers starts with 1 , next (n-1)! starts with 2...and so on.\\n// now find the first number.\\n//     To find the first number , we divide k/fact it will give the index of the first number in the vector in which number is stored...add that number in the string and remove that number from the vector...now rest operation will take place on numbers left.\\n// update k to k % fact\\n// and fact to fact / size of vector , \\n// now again loop will run and find the position of 2nd number in the vector add it to the string and again do the same opeartion\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int>numbers;\\n        for(int i=1;i<n;i++)\\n        {\\n            fact=fact*i;\\n            numbers.push_back(i);\\n        }\\n        numbers.push_back(n);\\n        string ans =\"\";\\n        k=k-1;\\n        while(true)\\n        {\\n            ans=ans+to_string(numbers[k/fact]);\\n            numbers.erase(numbers.begin()+k/fact);\\n            if(numbers.size()==0) break;\\n            k=k%fact;\\n            fact=fact/numbers.size();\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n//First find (n-1)!\\n//ex:\\n//1 2 3 4\\n// push all numbers in a vector in sorted order\\n// as total number of permutation formed is 4! , it is divided equally ,like first (n-1)! numbers starts with 1 , next (n-1)! starts with 2...and so on.\\n// now find the first number.\\n//     To find the first number , we divide k/fact it will give the index of the first number in the vector in which number is stored...add that number in the string and remove that number from the vector...now rest operation will take place on numbers left.\\n// update k to k % fact\\n// and fact to fact / size of vector , \\n// now again loop will run and find the position of 2nd number in the vector add it to the string and again do the same opeartion\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502001,
                "title": "c-easy-soln-60-permutation-sequence",
                "content": "**Dry Run for better understanding**\\n\\n\\t// if n is 4 then factorial of 3 will be calculated i.e. 6 let say n=4 and k=17  \\n\\t// intially we calculate factorial of n-1 and store the numbers upto n in nums  \\n\\t// nums={1,2,3,4}; fact=6\\n\\t// There are 6 numbers starting with 1: 1234, 1243, 1324, 1342, 1423, 1432\\n\\t// There are 6 numbers starting with 2: 2134, 2143, 2314, 2341, 2413, 2431\\n\\t// There are 6 numbers starting with 3: 3124, 3142,3214,3241,3412,3421  (ans i.e 3412 will lie here)\\n\\t// There are 6 numbers starting with 4: 4123, 4132, 4213, 4231, 4312, 4321\\n\\t// 0 based indexing asign k=k-1\\n\\t// since in the 3rd set(2nd index) ans is lying which can be calculated as\\n\\t// nums[k/fact]=nums[16/6]=>nums[2]\\n\\t// since nums[2] is 3 our first num is 3 add it to the ans \\n\\t// k=k%fact since next time there will total 6 element 2 starting from 1 ,two from 2 and two from 4\\n\\t// k=16%4 , fact is also updated as fact=6/3 process will be repeated until nums.size()=0\\n\\n**Code**\\n```\\nclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring getPermutation(int n, int k) {\\n\\t\\t\\t\\tint fact=1;\\n\\t\\t\\t\\tstring ans=\"\";\\n\\t\\t\\t\\tvector<int>nums;\\n\\t\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\t\\tnums.push_back(i);\\n\\t\\t\\t\\t\\tfact*=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnums.push_back(n);\\n\\t\\t\\t\\tk=k-1;\\n\\t\\t\\t\\twhile(true)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans+=to_string(nums[k/fact]);\\n\\t\\t\\t\\t\\tnums.erase(nums.begin()+k/fact);\\n\\t\\t\\t\\t\\tif(nums.size()==0) break;\\n\\t\\t\\t\\t\\tk=k%fact;\\n\\t\\t\\t\\t\\tfact=fact/nums.size();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};\\n```\\n\\n**Time Complexity: O(n^2)**\\nsince erase fun is used for each element which will take O(n) ans O(n) for every element traversal\\n**Space Complexity: O(n)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring getPermutation(int n, int k) {\\n\\t\\t\\t\\tint fact=1;\\n\\t\\t\\t\\tstring ans=\"\";\\n\\t\\t\\t\\tvector<int>nums;\\n\\t\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\t\\tnums.push_back(i);\\n\\t\\t\\t\\t\\tfact*=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnums.push_back(n);\\n\\t\\t\\t\\tk=k-1;\\n\\t\\t\\t\\twhile(true)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans+=to_string(nums[k/fact]);\\n\\t\\t\\t\\t\\tnums.erase(nums.begin()+k/fact);\\n\\t\\t\\t\\t\\tif(nums.size()==0) break;\\n\\t\\t\\t\\t\\tk=k%fact;\\n\\t\\t\\t\\t\\tfact=fact/nums.size();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436376,
                "title": "java-optimized-solution",
                "content": "### **Approach : Brute Force**\\n**Will Give TLE**\\n```\\nclass Solution {\\n    \\n    private void swap(char[] s , int i , int j){\\n        char temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n    }\\n    \\n    private void solve(char[] s , int index , List<String> res){\\n        if(index == s.length){\\n            String str = new String(s);\\n            res.add(str);\\n            return;\\n        }\\n        for(int i = index; i<s.length ; i++){\\n            swap(s, i, index);\\n            solve(s, index+1, res);\\n            swap(s,i,index);\\n        }\\n    }\\n    \\n    public String getPermutation(int n, int k) {\\n        String s = \"\";\\n        ArrayList<String> res = new ArrayList<>();\\n        for(int i = 1; i <=n ; i++){\\n            s+=i;\\n        }\\n        solve(s.toCharArray(), 0 , res);\\n        Collections.sort(res);\\n        return res.get(k-1);\\n    }\\n}\\n\\n//Time complexity: O(N! * N) +O(N! Log N!)\\n//Space complexity: O(N) \\n\\n```\\n\\n\\n### **Optimal solution**\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        List<Integer> numbers = new ArrayList<>();\\n        for(int i = 1; i<n ; i++){\\n            fact = fact * i;\\n            numbers.add(i);\\n        }\\n        numbers.add(n);\\n        String ans = \"\";\\n        k = k-1;\\n        while(true){\\n            ans = ans + \"\" + numbers.get(k/fact);\\n            numbers.remove(k/fact);\\n            if(numbers.size() == 0){\\n                break;\\n            }\\n            k = k % fact;\\n            fact = fact/numbers.size();\\n        }\\n        return ans;\\n    }\\n}\\n\\n/*\\nTime Complexity: O(N) * O(N) = O(N^2)\\n\\nReason: We are placing N numbers in N positions. This will take O(N) time. For every number, we are reducing the search space by removing the element already placed in the previous step. This takes another O(N) time.\\n\\nSpace Complexity: O(N) \\n\\nReason: We are storing  the numbers in a data structure.\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private void swap(char[] s , int i , int j){\\n        char temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n    }\\n    \\n    private void solve(char[] s , int index , List<String> res){\\n        if(index == s.length){\\n            String str = new String(s);\\n            res.add(str);\\n            return;\\n        }\\n        for(int i = index; i<s.length ; i++){\\n            swap(s, i, index);\\n            solve(s, index+1, res);\\n            swap(s,i,index);\\n        }\\n    }\\n    \\n    public String getPermutation(int n, int k) {\\n        String s = \"\";\\n        ArrayList<String> res = new ArrayList<>();\\n        for(int i = 1; i <=n ; i++){\\n            s+=i;\\n        }\\n        solve(s.toCharArray(), 0 , res);\\n        Collections.sort(res);\\n        return res.get(k-1);\\n    }\\n}\\n\\n//Time complexity: O(N! * N) +O(N! Log N!)\\n//Space complexity: O(N) \\n\\n```\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int fact = 1;\\n        List<Integer> numbers = new ArrayList<>();\\n        for(int i = 1; i<n ; i++){\\n            fact = fact * i;\\n            numbers.add(i);\\n        }\\n        numbers.add(n);\\n        String ans = \"\";\\n        k = k-1;\\n        while(true){\\n            ans = ans + \"\" + numbers.get(k/fact);\\n            numbers.remove(k/fact);\\n            if(numbers.size() == 0){\\n                break;\\n            }\\n            k = k % fact;\\n            fact = fact/numbers.size();\\n        }\\n        return ans;\\n    }\\n}\\n\\n/*\\nTime Complexity: O(N) * O(N) = O(N^2)\\n\\nReason: We are placing N numbers in N positions. This will take O(N) time. For every number, we are reducing the search space by removing the element already placed in the previous step. This takes another O(N) time.\\n\\nSpace Complexity: O(N) \\n\\nReason: We are storing  the numbers in a data structure.\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394981,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Permutation Sequence.\\nMemory Usage: 6.1 MB, less than 16.64% of C++ online submissions for Permutation Sequence.\\n\\n```\\nclass Solution {\\npublic:\\n    unsigned int factorial(unsigned int n)\\n{\\n    if (n == 0)\\n        return 1;\\n    return n * factorial(n - 1);\\n}\\n    \\n    string s(int k,vector<char>&ch) {\\n        if(k==0){\\n            string t ;\\n            for(auto &i : ch) t += i;\\n            return t;\\n        }\\n        int f = factorial(ch.size());// 24 \\n        int t = f/ch.size(); // 6\\n        \\n        int index = k / t;\\n        int remainder = k % t;\\n        \\n        char h = ch[index];\\n        \\n         auto it = ch.begin() + index;\\n         ch.erase(it);\\n        \\n        return h + s(remainder,ch);        \\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        vector<char>ch;\\n        char c = \\'1\\';\\n        for(int i = 0 ;i<n;i++){\\n            ch.push_back(c);\\n            c++;\\n        }\\n        return s(k-1,ch);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unsigned int factorial(unsigned int n)\\n{\\n    if (n == 0)\\n        return 1;\\n    return n * factorial(n - 1);\\n}\\n    \\n    string s(int k,vector<char>&ch) {\\n        if(k==0){\\n            string t ;\\n            for(auto &i : ch) t += i;\\n            return t;\\n        }\\n        int f = factorial(ch.size());// 24 \\n        int t = f/ch.size(); // 6\\n        \\n        int index = k / t;\\n        int remainder = k % t;\\n        \\n        char h = ch[index];\\n        \\n         auto it = ch.begin() + index;\\n         ch.erase(it);\\n        \\n        return h + s(remainder,ch);        \\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        vector<char>ch;\\n        char c = \\'1\\';\\n        for(int i = 0 ;i<n;i++){\\n            ch.push_back(c);\\n            c++;\\n        }\\n        return s(k-1,ch);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382280,
                "title": "c-0ms-best-solution-easily-understandable",
                "content": "```\\nclass Solution {\\n    \\n    void factorial (vector<int> &fac, int n )\\n    {\\n        fac[0] = fac[1] = 1;\\n        \\n        for(int i = 2 ; i<= n ; i++)\\n        {\\n            fac[i] = i * fac[i-1];\\n            \\n        }\\n       \\n    }\\n    \\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        vector<int> fac(n+1 , 0);\\n         factorial(fac , n);\\n        \\n        string s;\\n        for(int i = 1 ; i<= n ;i++)\\n            s.push_back(i+\\'0\\');\\n        \\n        string ans ;\\n        \\n        for(int i = 1 ; i< n ; i++)\\n        {\\n            int j = 0;\\n            while(k > fac[n-i])\\n            {\\n                j++;\\n                k -= fac[n-i];\\n            }\\n            ans.push_back(s[j]);\\n            s.erase(j,1);\\n            \\n        }\\n        \\n        ans.push_back(s[0]);\\n        \\n        return ans;\\n    }\\n\\t\\n\\t**// Pls Upvote if you like it**\\n};\\n```\\n\\n \\n\\n\\n![image](https://assets.leetcode.com/users/images/643a4983-d04a-44af-9a1f-64d21a7962ae_1659691279.1827478.png)\\n",
                "solutionTags": [
                    "C",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\n    \\n    void factorial (vector<int> &fac, int n )\\n    {\\n        fac[0] = fac[1] = 1;\\n        \\n        for(int i = 2 ; i<= n ; i++)\\n        {\\n            fac[i] = i * fac[i-1];\\n            \\n        }\\n       \\n    }\\n    \\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        vector<int> fac(n+1 , 0);\\n         factorial(fac , n);\\n        \\n        string s;\\n        for(int i = 1 ; i<= n ;i++)\\n            s.push_back(i+\\'0\\');\\n        \\n        string ans ;\\n        \\n        for(int i = 1 ; i< n ; i++)\\n        {\\n            int j = 0;\\n            while(k > fac[n-i])\\n            {\\n                j++;\\n                k -= fac[n-i];\\n            }\\n            ans.push_back(s[j]);\\n            s.erase(j,1);\\n            \\n        }\\n        \\n        ans.push_back(s[0]);\\n        \\n        return ans;\\n    }\\n\\t\\n\\t**// Pls Upvote if you like it**\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336078,
                "title": "c-stl-next-permutation-easy-100",
                "content": "Easy **STL function**!\\n```\\nstring getPermutation(int n, int k) {\\n        string s;\\n\\t\\t//fill the string with n integers\\n        for(int i=1; i<=n; i++){\\n            s += to_string(i);\\n        }\\n        \\n\\t\\t//go to the kth permutation\\n        for(int i=1; i<k; i++){\\n            next_permutation(s.begin(), s.end());\\n        }\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring getPermutation(int n, int k) {\\n        string s;\\n\\t\\t//fill the string with n integers\\n        for(int i=1; i<=n; i++){\\n            s += to_string(i);\\n        }\\n        \\n\\t\\t//go to the kth permutation\\n        for(int i=1; i<k; i++){\\n            next_permutation(s.begin(), s.end());\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2322038,
                "title": "c-beginner-s-friendly-solution-understandable-approach",
                "content": "**Please Upvote the Solution**\\n\\nCode->\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fac=1;\\n        vector<int> arr;\\n        for(int i=1;i<n;i++){\\n            fac*=i;\\n            arr.push_back(i);\\n        }\\n        arr.push_back(n);\\n        string ans=\"\";\\n        //0-based indexing\\n        k=k-1;\\n        while(true){\\n            ans+=to_string(arr[k/fac]);\\n            arr.erase(arr.begin()+k/fac);\\n            if(arr.size()==0)\\n                break;\\n            k=k%fac;\\n            fac=fac/arr.size();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHappy Coding :-)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fac=1;\\n        vector<int> arr;\\n        for(int i=1;i<n;i++){\\n            fac*=i;\\n            arr.push_back(i);\\n        }\\n        arr.push_back(n);\\n        string ans=\"\";\\n        //0-based indexing\\n        k=k-1;\\n        while(true){\\n            ans+=to_string(arr[k/fac]);\\n            arr.erase(arr.begin()+k/fac);\\n            if(arr.size()==0)\\n                break;\\n            k=k%fac;\\n            fac=fac/arr.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228028,
                "title": "c-very-easy-explanation-with-example",
                "content": "\\t/*\\n\\tExample:\\n\\n\\tn = 4 and k = 9\\n\\n\\tnumber of combination \\n\\n\\t1234    2134    3124    4123\\n\\t1243    2143    3142    4132\\n\\t1324    2314    3214    4213\\n\\t1342    2342    3241    4231\\n\\t1423    2413    3412    4312\\n\\t1432    2431    3421    4321\\n\\n\\tsince we want the 9 the permutaion we have to do the permutaion 8 time since 1st combination\\n\\tis considered 1\\n\\tk = 8\\n\\tans = \"\";\\n\\n\\tvalue of i = 1; //initially\\n\\tnow how many columns needs to be skipped for first digit of ans is (n-i)!\\n\\tso number of the value (smaller) to skip = k/(n-1)!\\n\\there 8/(4-i)! = 8/6 = 1; \\n\\tnew k value = k%(n-i) = 8%(4-1)! = 2\\n\\tans = \"2\"\\n\\n\\trepeation the same process i = 2\\n\\t2/(4-2)! = 2/1 = 2\\n\\tans = \"23\"\\n\\tk = 0\\n\\n\\ti = 3\\n\\t0/(4-3)! = 0\\n\\tans = \"231\"\\n\\n\\ti = 4\\n\\t0/(4-4)! = 0\\n\\tans = \"2314\"\\n\\n\\tresult = \"2314\"\\n\\t*/\\n\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint factorial(int n){\\n\\t\\t\\tint ans = 1;\\n\\t\\t\\tfor(int i = 2; i<=n; i++)ans *= i;\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tstring getPermutation(int n, int k) {\\n\\n\\n\\t\\t\\t//factorial of n to get the total number of arrangement possible\\n\\t\\t\\t//with n numbers\\n\\t\\t\\tint ttlArgmtPsbl = factorial(n); //total arrangement possible for n digits\\n\\n\\n\\t\\t\\t//since we want to get the number we will se after k permutation \\n\\t\\t\\t//ans we are counting the initial arrangement as 1\\n\\t\\t\\tk--;\\n\\n\\t\\t\\t//to remove loop means the same arrangement is occuring more than once.\\n\\t\\t\\tk = k%ttlArgmtPsbl;\\n\\n\\t\\t\\t//to skip the number after which we will get the number which is supposed to \\n\\t\\t\\t//be there in that place.\\n\\t\\t\\tvector<bool> rec(n, true);\\n\\n\\n\\t\\t\\t//resulting string\\n\\t\\t\\tstring ans = \"\";\\n\\n\\n\\t\\t\\tfor(int i = n; i>=1; i--){\\n\\n\\t\\t\\t\\t//to get the column of the number after a position when a number is fixed\\n\\t\\t\\t\\t//at that position.\\n\\t\\t\\t\\tttlArgmtPsbl = ttlArgmtPsbl/i; \\n\\n\\t\\t\\t\\t//fixing the first element and figuring\\n\\t\\t\\t\\t//out how many column (where the number less than it which are unoccupied are\\n\\t\\t\\t\\t//at that position) have to be skipped (reffer to the example)\\n\\t\\t\\t\\t//(+1 to get the the exact index)\\n\\n\\t\\t\\t\\t//smaller and available no. to skip\\n\\t\\t\\t\\tint smlaAvlnumbertoskp = k/ttlArgmtPsbl + 1; \\n\\n\\t\\t\\t\\t//to store the index number.\\n\\t\\t\\t\\tint ix = 0;\\n\\n\\t\\t\\t\\t//to get the ixdex value by skipping the available smaller number.\\n\\t\\t\\t\\tfor(int j = 0; j<rec.size(); j++){\\n\\t\\t\\t\\t\\tif(!smlaAvlnumbertoskp){\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(rec[j]){\\n\\t\\t\\t\\t\\t\\tsmlaAvlnumbertoskp--;\\n\\t\\t\\t\\t\\t\\tix = j;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//number at ix is to be added to ans string\\n\\n\\t\\t\\t\\tk = k%ttlArgmtPsbl; //reduce the width of the column\\n\\n\\t\\t\\t\\t//set the number at ix to unavailable.\\n\\t\\t\\t\\trec[ix] = false;\\n\\n\\t\\t\\t\\t//add number at ix to ans.\\n\\t\\t\\t\\tans += to_string(ix+1);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint factorial(int n){\\n\\t\\t\\tint ans = 1;\\n\\t\\t\\tfor(int i = 2; i<=n; i++)ans *= i;\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2133515,
                "title": "without-recursion-simple-mathematics",
                "content": "feel free to ask any queries in the comments!******\\n\\n![image](https://assets.leetcode.com/users/images/a5872874-51df-42d4-8e49-ed44bd7b93f3_1654838871.1433494.jpeg)\\n\\n\\n```class Solution\\n{\\n\\npublic:\\n    int fact(int n)\\n    {\\n        int res = 1;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            res = res * 1 * i;\\n        }\\n        return res;\\n    }\\n    string getPermutation(int n, int k)\\n    {\\n        vector<int> v1;\\n        vector<int> v;\\n        for (int i = 0; i < n; i++)\\n        {\\n            v1.push_back(i + 1);\\n        }\\n        int t = n;\\n\\n        while (n)\\n        {\\n           \\n            int s = ceil((double)k / (double)fact(n - 1));\\n            v.push_back(v1[s - 1]);\\n            for (int i = 0; i < v.size(); i++)\\n            {\\n                cout << v[i] << \" \";\\n            }\\n            cout << endl;\\n            v1[s - 1] = INT_MAX;\\n            sort(v1.begin(), v1.end());\\n            k -= (s - 1) * fact(n - 1);\\n            n--;\\n          \\n        }\\n        \\n        string s = \"\";\\n        for (int j = 0; j < t; j++)\\n        {\\n            s += to_string(v[j]);\\n        }\\n        return s;\\n    }\\n};```**",
                "solutionTags": [],
                "code": "```class Solution\\n{\\n\\npublic:\\n    int fact(int n)\\n    {\\n        int res = 1;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            res = res * 1 * i;\\n        }\\n        return res;\\n    }\\n    string getPermutation(int n, int k)\\n    {\\n        vector<int> v1;\\n        vector<int> v;\\n        for (int i = 0; i < n; i++)\\n        {\\n            v1.push_back(i + 1);\\n        }\\n        int t = n;\\n\\n        while (n)\\n        {\\n           \\n            int s = ceil((double)k / (double)fact(n - 1));\\n            v.push_back(v1[s - 1]);\\n            for (int i = 0; i < v.size(); i++)\\n            {\\n                cout << v[i] << \" \";\\n            }\\n            cout << endl;\\n            v1[s - 1] = INT_MAX;\\n            sort(v1.begin(), v1.end());\\n            k -= (s - 1) * fact(n - 1);\\n            n--;\\n          \\n        }\\n        \\n        string s = \"\";\\n        for (int j = 0; j < t; j++)\\n        {\\n            s += to_string(v[j]);\\n        }\\n        return s;\\n    }\\n};```",
                "codeTag": "C++"
            },
            {
                "id": 2130821,
                "title": "cpp-code-easy-to-understand",
                "content": "```\\nclass Solution {\\nprivate:\\nint calFact ( int n ){\\n    int ans = 1 ;\\n    for ( int i = 1 ; i < n ; i ++)\\n        ans *=  i;\\n    return ans;\\n}    \\n    \\npublic:\\n    string getPermutation(int n, int k) {\\n        // this question is based on the nice concept of factorial \\n        // do check it out again\\n        \\n        // first we will find the factorial of the given n\\n        // then we will try to find in which range of factorial does k - 1 lies \\n        // we will pick that element by k / size of the set reduced to ( fact ( n - 1 )) \\n        // then we will pick the element and add to our string and erase the element from string \\n        // then we will change the value of k by k = k % fact \\n        // and fact = fact ( n - 1) = fact / s.size() \\n        \\n        vector<int> numbers;\\n        int fact = 1 ;\\n        \\n        for ( int i = 1 ; i <= n ; i ++) numbers.push_back(i);\\n        \\n        fact = calFact ( n );\\n        k = k - 1;\\n        string s = \"\";\\n        while ( 1 ){\\n            s += to_string(numbers[(int)(k / fact )]);\\n            numbers.erase( numbers.begin() + (int)(k / fact) );\\n            \\n            // if the numbers become empty we will stop\\n            if ( numbers.size() == 0)\\n               break;\\n            \\n            // new k value and fact value \\n            k = k % fact ;\\n            fact = fact / numbers.size();\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\nint calFact ( int n ){\\n    int ans = 1 ;\\n    for ( int i = 1 ; i < n ; i ++)\\n        ans *=  i;\\n    return ans;\\n}    \\n    \\npublic:\\n    string getPermutation(int n, int k) {\\n        // this question is based on the nice concept of factorial \\n        // do check it out again\\n        \\n        // first we will find the factorial of the given n\\n        // then we will try to find in which range of factorial does k - 1 lies \\n        // we will pick that element by k / size of the set reduced to ( fact ( n - 1 )) \\n        // then we will pick the element and add to our string and erase the element from string \\n        // then we will change the value of k by k = k % fact \\n        // and fact = fact ( n - 1) = fact / s.size() \\n        \\n        vector<int> numbers;\\n        int fact = 1 ;\\n        \\n        for ( int i = 1 ; i <= n ; i ++) numbers.push_back(i);\\n        \\n        fact = calFact ( n );\\n        k = k - 1;\\n        string s = \"\";\\n        while ( 1 ){\\n            s += to_string(numbers[(int)(k / fact )]);\\n            numbers.erase( numbers.begin() + (int)(k / fact) );\\n            \\n            // if the numbers become empty we will stop\\n            if ( numbers.size() == 0)\\n               break;\\n            \\n            // new k value and fact value \\n            k = k % fact ;\\n            fact = fact / numbers.size();\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099414,
                "title": "c-solution-recursion",
                "content": "class Solution {\\npublic:\\n    string kthPermutation(string str, string res, int &k) {\\n        \\n        if(str.size()==0) {\\n            k--;\\n            if(k==0)\\n                return res;\\n            return \"\";\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<str.size();i++) {\\n            string ros=str.substr(0,i)+str.substr(i+1);\\n            ans=kthPermutation(ros, res+str[i], k);\\n            \\n            if(k==0)\\n                break;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    string getPermutation(int n, int k) {\\n        string str=\"\";\\n        for(int i=1;i<=n;i++)\\n            str+=to_string(i);\\n        \\n        return kthPermutation(str, \"\", k);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Probability and Statistics"
                ],
                "code": "class Solution {\\npublic:\\n    string kthPermutation(string str, string res, int &k) {\\n        \\n        if(str.size()==0) {\\n            k--;\\n            if(k==0)\\n                return res;\\n            return \"\";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2066901,
                "title": "perfect-use-of-stl-c",
                "content": "class Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string str = \"\";\\n        for(int i=1;i<=n;i++) \\n            str.push_back(i+\\'0\\');\\n        cout<<str;\\n        while(--k)\\n            next_permutation(str.begin(), str.end());\\n        return str;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string str = \"\";\\n        for(int i=1;i<=n;i++) \\n            str.push_back(i+\\'0\\');\\n        cout<<str;\\n        while(--k)\\n            next_permutation(str.begin(), str.end());\\n        return str;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2036385,
                "title": "3ms-java-easy-solution",
                "content": "\\t\\tclass Solution {\\n\\t\\t   public void kthPermutaionUtil(int n,int k,ArrayList<Integer> lis,int fact,String[] res){\\n\\t\\t\\t\\tif(n==1){\\n\\t\\t\\t\\t\\tres[0]+=lis.get(0);    \\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint groups = fact/n;\\n\\t\\t\\t\\tres[0]+=lis.get(k/groups);\\n\\t\\t\\t\\tlis.remove(k/groups);\\n\\t\\t\\t\\tkthPermutaionUtil(n-1,k%groups,lis,groups,res); \\n\\t\\t\\t}\\n\\t\\t\\tpublic String getPermutation(int n, int k) {\\n\\t\\t\\t\\tString[] res = {\"\"};\\n\\t\\t\\t\\tArrayList<Integer> lexographical_list = new ArrayList<Integer>();\\n\\t\\t\\t\\tint fact=1;\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tfact=fact*(i+1);\\n\\t\\t\\t\\t\\tlexographical_list.add(i+1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tSystem.out.println(fact);\\n\\t\\t\\t\\tSystem.out.println(lexographical_list);\\n\\t\\t\\t\\tkthPermutaionUtil(n,k-1,lexographical_list,fact,res);\\n\\t\\t\\t\\treturn res[0];\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\t   public void kthPermutaionUtil(int n,int k,ArrayList<Integer> lis,int fact,String[] res){\\n\\t\\t\\t\\tif(n==1){\\n\\t\\t\\t\\t\\tres[0]+=lis.get(0);    \\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2036380,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "\\t\\tclass Solution {\\n\\t\\t\\tvector<int> fact,digits;\\n\\t\\t\\tvoid solve(string& ans,int n,int k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(n==1){       //Insert whatever digit is left at the end\\n\\t\\t\\t\\t\\tans+=to_string(digits.back());\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//This runs if we have more than 1 digit in digits array\\n\\t\\t\\t\\tint index = k/fact[n-1]; //Defines no of blocks to skip (each block of size fact[n-1])\\n\\n\\t\\t\\t\\tif(k%fact[n-1]==0)  //We need convert 1 based indexing to 0 based.So, decrese index by 1\\n\\t\\t\\t\\t\\tindex-=1;\\n\\n\\t\\t\\t\\tans+=to_string(digits[index]);  //Add new character\\n\\t\\t\\t\\tdigits.erase(digits.begin()+index);    //Erase digit after using\\n\\n\\t\\t\\t\\tk -= fact[n-1]*index;  //Decrease K value\\n\\t\\t\\t\\tsolve(ans,n-1,k);\\n\\t\\t\\t}\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tstring getPermutation(int n, int k) {\\n\\t\\t\\t\\t\\t//Store all factorials from 0 to N\\n\\t\\t\\t\\t\\tfact.push_back(1);\\n\\t\\t\\t\\t\\tint f=1;\\n\\t\\t\\t\\t\\tfor(int i=1;i<n;++i)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tf*=i;\\n\\t\\t\\t\\t\\t\\tfact.push_back(f);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t//Push your digits in array\\n\\t\\t\\t\\t\\tfor(int i=1;i<=n;++i)\\n\\t\\t\\t\\t\\t\\tdigits.push_back(i);\\n\\n\\t\\t\\t\\t\\tstring ans = \"\";\\n\\t\\t\\t\\t\\tsolve(ans,n,k); \\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\t\\tvector<int> fact,digits;\\n\\t\\t\\tvoid solve(string& ans,int n,int k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(n==1){       //Insert whatever digit is left at the end\\n\\t\\t\\t\\t\\tans+=to_string(digits.back());\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2032054,
                "title": "c-east-to-unserstand-stl-implementation-easy",
                "content": "Very basic and easy to unserstand another way can be using backtracking\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int arr[n+1];\\n        for(int i=0;i<n;i++){\\n            arr[i]=i+1;\\n        }\\n        \\n        while(--k){\\n            next_permutation(arr,arr+n);\\n        }\\n        \\n        string s = \"\";\\n        \\n        for(int i=0;i<n;i++){\\n            s+= char(arr[i])+\\'0\\';\\n        }\\n        \\n        \\n        return(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int arr[n+1];\\n        for(int i=0;i<n;i++){\\n            arr[i]=i+1;\\n        }\\n        \\n        while(--k){\\n            next_permutation(arr,arr+n);\\n        }\\n        \\n        string s = \"\";\\n        \\n        for(int i=0;i<n;i++){\\n            s+= char(arr[i])+\\'0\\';\\n        }\\n        \\n        \\n        return(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841505,
                "title": "c-solution-using-stl",
                "content": "```\\n string getPermutation(int n, int k) {\\n        vector<string> vec;\\n        for(int i=0;i<n;i++) vec.push_back(to_string(i+1));\\n        vector<vector<string>> answers;\\n        string ans = \"\";\\n        answers.push_back(vec);\\n        k--;\\n        while(k--)\\n            next_permutation(vec.begin(),vec.end());\\n        for(int i=0;i<vec.size();i++)\\n            ans = ans + vec[i];\\n        return ans;   \\n    }",
                "solutionTags": [],
                "code": "```\\n string getPermutation(int n, int k) {\\n        vector<string> vec;\\n        for(int i=0;i<n;i++) vec.push_back(to_string(i+1));\\n        vector<vector<string>> answers;\\n        string ans = \"\";\\n        answers.push_back(vec);\\n        k--;\\n        while(k--)\\n            next_permutation(vec.begin(),vec.end());\\n        for(int i=0;i<vec.size();i++)\\n            ans = ans + vec[i];\\n        return ans;   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1801155,
                "title": "c-5-line-solution-easy",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring getPermutation(int n, int k) {\\n\\t\\t\\tstring s;\\n\\t\\t\\tfor(int i=1;i<=n;i++) s.push_back(i+\\'0\\');;\\n\\t\\t\\twhile(k-->1){\\n\\t\\t\\t\\tnext_permutation(s.begin(),s.end());\\n\\t\\t\\t}\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring getPermutation(int n, int k) {\\n\\t\\t\\tstring s;\\n\\t\\t\\tfor(int i=1;i<=n;i++) s.push_back(i+\\'0\\');;\\n\\t\\t\\twhile(k-->1){\\n\\t\\t\\t\\tnext_permutation(s.begin(),s.end());\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1737773,
                "title": "java-short-clean-math-o-n-solution",
                "content": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int kF = 1;\\n        List<Integer>allDigits = new ArrayList<>();\\n        for (int i=1;i<=n;i++){\\n            kF *=i;\\n            allDigits.add(i);\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        int ind = 0;\\n        while (allDigits.size()>0){\\n            kF/=allDigits.size();\\n            int div = k/kF;\\n            int mod = k%kF;\\n            ind = (mod>0?0:-1) + div;\\n            k=(mod==0)?kF:mod;\\n            res.append(allDigits.get(ind));\\n            allDigits.remove(ind);\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        int kF = 1;\\n        List<Integer>allDigits = new ArrayList<>();\\n        for (int i=1;i<=n;i++){\\n            kF *=i;\\n            allDigits.add(i);\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        int ind = 0;\\n        while (allDigits.size()>0){\\n            kF/=allDigits.size();\\n            int div = k/kF;\\n            int mod = k%kF;\\n            ind = (mod>0?0:-1) + div;\\n            k=(mod==0)?kF:mod;\\n            res.append(allDigits.get(ind));\\n            allDigits.remove(ind);\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730928,
                "title": "simple-recursive-solution-in-java",
                "content": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        boolean[] used = new boolean[n];\\n        return FindKthPermutation(n,k,used);\\n    }\\n    String FindKthPermutation(int n, int k, boolean[] used) {\\n        if(n == 1){\\n            for (int i = 0; i < used.length; i++) {\\n                if(!used[i]){\\n                    return \"\"+(i+1);\\n                }\\n            }\\n        }\\n        int factn = fact(n-1);\\n\\n        int seg = k<=factn?0:(k-1)/factn;\\n\\n        int findsegNo= seg;\\n\\n        int cur = 0;\\n        for (int i = 0; i < used.length; i++) {\\n            if(used[i]){\\n                continue;\\n            }\\n            if(findsegNo ==0){\\n                used[i] = true;\\n                cur = i;\\n                break;\\n            }\\n            findsegNo--;\\n        }\\n        return (cur+1) + FindKthPermutation(n-1,k-(factn*seg),used);\\n    }\\n\\n    int fact(int n) {\\n        if(n <= 1){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        boolean[] used = new boolean[n];\\n        return FindKthPermutation(n,k,used);\\n    }\\n    String FindKthPermutation(int n, int k, boolean[] used) {\\n        if(n == 1){\\n            for (int i = 0; i < used.length; i++) {\\n                if(!used[i]){\\n                    return \"\"+(i+1);\\n                }\\n            }\\n        }\\n        int factn = fact(n-1);\\n\\n        int seg = k<=factn?0:(k-1)/factn;\\n\\n        int findsegNo= seg;\\n\\n        int cur = 0;\\n        for (int i = 0; i < used.length; i++) {\\n            if(used[i]){\\n                continue;\\n            }\\n            if(findsegNo ==0){\\n                used[i] = true;\\n                cur = i;\\n                break;\\n            }\\n            findsegNo--;\\n        }\\n        return (cur+1) + FindKthPermutation(n-1,k-(factn*seg),used);\\n    }\\n\\n    int fact(int n) {\\n        if(n <= 1){\\n            return 1;\\n        }\\n        return n*fact(n-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666830,
                "title": "another-solution-for-same-approach",
                "content": "```\\n//select first place \\n\\nclass Solution {\\npublic:\\n    int fac(int n){\\n        if (n==1 || n==0) return 1; \\n\\n        return n*fac(n-1);\\n    }   \\n    \\n    \\n    string getPermutation(int n, int k) {\\n    \\n        set<char> pq; \\n        for (int i=1; i<=n; i++) pq.insert(i+\\'0\\');\\n        \\n        string ans=\"\";\\n\\n        for (int i=1; i<=n && k>1; i++){    \\n            \\n            int pos = (k-1)/fac(n-i);\\n            k -= pos*fac(n-i);                           \\n            \\n            set<char> :: iterator it1 = pq.begin();\\n            while (pos--) it1++;\\n            ans += *it1;\\n            pq.erase(it1);                    \\n            \\n            //cout << k << \" \"<< pos << \" \" << n-i  << \" \" << ans << endl;\\n        }\\n        \\n        \\n        while (!pq.empty()){\\n            ans += *pq.begin();\\n            pq.erase(*pq.begin());\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nAt each index find the maximum number that can fit, and substract the permutations which we skipped to come to the maximum digit at this index.\\n\\nThe only difference is I used a set container instead of a vector which helps optimise the memory used.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator",
                    "Ordered Set"
                ],
                "code": "```\\n//select first place \\n\\nclass Solution {\\npublic:\\n    int fac(int n){\\n        if (n==1 || n==0) return 1; \\n\\n        return n*fac(n-1);\\n    }   \\n    \\n    \\n    string getPermutation(int n, int k) {\\n    \\n        set<char> pq; \\n        for (int i=1; i<=n; i++) pq.insert(i+\\'0\\');\\n        \\n        string ans=\"\";\\n\\n        for (int i=1; i<=n && k>1; i++){    \\n            \\n            int pos = (k-1)/fac(n-i);\\n            k -= pos*fac(n-i);                           \\n            \\n            set<char> :: iterator it1 = pq.begin();\\n            while (pos--) it1++;\\n            ans += *it1;\\n            pq.erase(it1);                    \\n            \\n            //cout << k << \" \"<< pos << \" \" << n-i  << \" \" << ans << endl;\\n        }\\n        \\n        \\n        while (!pq.empty()){\\n            ans += *pq.begin();\\n            pq.erase(*pq.begin());\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1613182,
                "title": "6-line-cpp-code-using-inbuilt-func",
                "content": "\\n    string getPermutation(int n, int k) {\\n        vector<int> nums;\\n        for (int i=1;i<=n;i++) nums.push_back(i);\\n        while(--k) next_permutation(nums.begin(),nums.end());\\n        string ans=\"\";\\n        for(int l:nums) ans+=to_string(l);\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n    string getPermutation(int n, int k) {\\n        vector<int> nums;\\n        for (int i=1;i<=n;i++) nums.push_back(i);\\n        while(--k) next_permutation(nums.begin(),nums.end());\\n        string ans=\"\";\\n        for(int l:nums) ans+=to_string(l);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1541480,
                "title": "recursive-and-optimized-detailed-solutions",
                "content": "**As we can see the order of permutations is actually sorted**\\nBy listing and labeling all of the permutations in order, we get the following sequence for n = 3:\\n no fo permutations n!=6;\\n0.\"123\"\\n1.\"132\"\\n2.\"213\"\\n3.\"231\"\\n4.\"312\"\\n5.\"321\"\\n\\n**In brute force approach we will simply create all permutations using recursion and store all in vector and then sort them in increasing order to get answer.**\\n\\n**TC:->O(n!) and S.C->O(n)**\\n```\\nclass Solution {\\n    vector<string>temp;\\npublic:\\n    string getPermutation(int n, int k) {\\n        string res=\"\",initial=\"\";\\n        // creating string \\n        for(int i=1;i<=n;++i)\\n            initial+=to_string(i);  \\n\\n        solve(res,initial);\\n        \\n        // sorting temp\\n        sort(temp.begin(),temp.end());\\n        \\n          // in 0 indexing return k-1 in temp to get Kth permutation\\n        return temp[k-1];\\n        \\n    }\\n    void solve(string res,string initial)\\n    {\\n        // base case\\n        if(initial.size()==0)\\n        {\\n            temp.push_back(res);\\n            return;\\n        }\\n        for(int i=0;i<initial.size();++i)\\n        {   \\n            res.push_back(initial[i]);\\n            solve(res,initial.substr(0,i)+initial.substr(i+1));\\n            res.pop_back();\\n        }\\n    }\\n};\\n```\\n**optimized approach**\\n**TC:->O(n) and S.C->O(n)**\\nThe approach is mathematical\\nhere let suppose n=3..so n-1!=2;\\n **the first two start with zero index ..**\\n*for k=1,2....  k-=1  ...k=0,k=1  num[k/n-1!]==0/2=0;or1/2=0; so we have to take 0th index from original \"123\"..**so we have res=\"1\" and rest =\"2,3\".**. \\n\"123\"\\n\"132\"*\\n **after that the next two start with one index ..**\\n *for k=3,4....  k-=1  ...k=2,k=3  num[k/n-1!]==2/2=1;or3/2=1; so we have to take 1th index from original \"123\"..**so we have res=\"2\" and rest =\"1,3\".. **\\n\"213\"\\n\"231\"*\\n**after that the next two start with two index ..**\\n*for k=5,6....  k-=1  ...k=4,k=5  num[k/n-1!]==4/2=2;or5/2=2; so we have to take 2th index from original \"123\"..**so we have res=\"3\" and rest =\"2,3\"..**\\n\"312\"\\n\"321*\\n\\n**and also updating value of k and fact each time so on...till rest array size!=0.**\\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int>num;\\n        for(int i=1;i<n;++i)\\n        {\\n            num.push_back(i);\\n            fact*=i;\\n        }\\n        num.push_back(n);\\n        string res=\"\";\\n        k-=1;\\n        while(1)\\n        {\\n          res+=to_string(num[k/fact]);\\n          num.erase(num.begin()+k/fact);//after adding to res we will delete this char.\\n          if(size(num)==0)\\n            break;\\n           k%=fact;\\n           fact/=size(num);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    vector<string>temp;\\npublic:\\n    string getPermutation(int n, int k) {\\n        string res=\"\",initial=\"\";\\n        // creating string \\n        for(int i=1;i<=n;++i)\\n            initial+=to_string(i);  \\n\\n        solve(res,initial);\\n        \\n        // sorting temp\\n        sort(temp.begin(),temp.end());\\n        \\n          // in 0 indexing return k-1 in temp to get Kth permutation\\n        return temp[k-1];\\n        \\n    }\\n    void solve(string res,string initial)\\n    {\\n        // base case\\n        if(initial.size()==0)\\n        {\\n            temp.push_back(res);\\n            return;\\n        }\\n        for(int i=0;i<initial.size();++i)\\n        {   \\n            res.push_back(initial[i]);\\n            solve(res,initial.substr(0,i)+initial.substr(i+1));\\n            res.pop_back();\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        int fact=1;\\n        vector<int>num;\\n        for(int i=1;i<n;++i)\\n        {\\n            num.push_back(i);\\n            fact*=i;\\n        }\\n        num.push_back(n);\\n        string res=\"\";\\n        k-=1;\\n        while(1)\\n        {\\n          res+=to_string(num[k/fact]);\\n          num.erase(num.begin()+k/fact);//after adding to res we will delete this char.\\n          if(size(num)==0)\\n            break;\\n           k%=fact;\\n           fact/=size(num);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496484,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        \\n        nums=list(range(1,n+1))\\n        fact = math.factorial(n)\\n        s=\\'\\'\\n        for i in range(n,0,-1):\\n            fact=fact//i\\n            s+=str(nums.pop((k-1)//fact))\\n            k=k%fact\\n            \\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        \\n        nums=list(range(1,n+1))\\n        fact = math.factorial(n)\\n        s=\\'\\'\\n        for i in range(n,0,-1):\\n            fact=fact//i\\n            s+=str(nums.pop((k-1)//fact))\\n            k=k%fact\\n            \\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438806,
                "title": "10-line-code-c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string str = \"\"; \\n        for(int i =0 ; i<n;i++){\\n            str+=to_string(i+1); \\n        }\\n        for(int i =1 ; i<k;i++){\\n            next_permutation(str.begin(), str.end()); \\n        }\\n        return str;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        string str = \"\"; \\n        for(int i =0 ; i<n;i++){\\n            str+=to_string(i+1); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1438394,
                "title": "c-math-t-c-o-n-2-s-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> nums;\\n        int factorial = 1;\\n        for(int i=1;i<n;++i){ \\n            factorial*=i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n\\n        string ans=\"\";\\n        k=k-1;\\n\\n        while(nums.size()!=0){\\n            ans.append(to_string(nums[k/factorial]));\\n            nums.erase(nums.begin()+(k/factorial));\\n            k = k % factorial;\\n            if(nums.size()>0) factorial = factorial/nums.size();\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        vector<int> nums;\\n        int factorial = 1;\\n        for(int i=1;i<n;++i){ \\n            factorial*=i;\\n            nums.push_back(i);\\n        }\\n        nums.push_back(n);\\n\\n        string ans=\"\";\\n        k=k-1;\\n\\n        while(nums.size()!=0){\\n            ans.append(to_string(nums[k/factorial]));\\n            nums.erase(nums.begin()+(k/factorial));\\n            k = k % factorial;\\n            if(nums.size()>0) factorial = factorial/nums.size();\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343701,
                "title": "easy-c-solution-100-faster",
                "content": "class Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        string result;\\n        \\n        vector<int> arr;\\n        int comb = 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            comb*= i;\\n            arr.push_back(i);\\n        }\\n        arr.push_back(n);\\n        k = k-1;\\n        \\n        \\n        while(true)\\n        {\\n            result += to_string(arr[k/comb]);\\n            \\n            arr.erase(arr.begin()+(k/comb));\\n            \\n            if(arr.size()==0)\\n                break;\\n            \\n            k = k%comb;\\n            comb = comb/arr.size();\\n        }\\n        \\n        return result;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string getPermutation(int n, int k) {\\n        \\n        string result;\\n        \\n        vector<int> arr;\\n        int comb = 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            comb*= i;\\n            arr.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1300779,
                "title": "python-maths-logic-with-explanation-90-runtime",
                "content": "\\nTo make things simpler, we start index everything from 0\\nTheory:\\n(1) We begin from the left-most digit for the final answer\\n(2) We create a ***list*** , that contains all digit from 1 to ***n*** (in ascending order)\\n(3) We split the possible permutations into different groups according to their \\'leading\\' digits\\n(4) We discover which n*th* group [ ***int(k/(len(List)-1)!)*** ] that the final answer lies within\\n(5) We append the \\'leading\\' digit of the n*th* group into our final answer\\n(6) We update ***k*** ( ***k=k%(len(list)-1)!*** ) and remove the n*th* element from ***list***\\n(7) Repeat steps 3 - 6 until ***list*** is empty\\n\\t\\n***Sample Case: n=4, k=15 (0-indexed)***\\t\\n\\t\\n### Stage 1\\n\\t\\n\\tList = [1,2,3,4]\\n\\tGroup 0: 1234,1243,1324,1342,1423,1432 (where k=0~5) \\n\\tGroup 1: 2134,2143,2314,2341,2413,2431 (where k=6~11)\\n\\tGroup 2: 3124,3142,3214,3241,3412,3421 (where k=12~17)\\n\\tGroup 3: 4123,4132,4213,4231,4312,4321 (where k=18~23)\\n\\t\\nwe can confirm that the final answer lies within **Group [int(k/(len(List)-1)!)] = 2**\\nsince we know the answer is in Group 2, meaning the 1st digit of the answer is \\'3\\' (equivalent to the value of ***List[2]*** ), answer = **3 _ _ _**\\nwe update **k=k%(len(List)-1)!=3** , remove ***List[2]***\\n\\n### Stage 2\\n\\n\\tList = [1,2,4]\\n\\tGroup 0: 124,142 (where k=0~1)\\n\\tGroup 1: 214,241 (where k=2~3)\\n\\tGroup 2: 412,421 (where k=4~5)\\n\\nwe can decude the answer lies within **Group [int(k/(len(List)-1)!)] = 1**\\nwe can confirm that the 2nd digit is \\'2\\' (equivalent to the value of ***List[1]*** ), answer = **3 2 _ _**\\nwe update **k = k%(len(List)-1)!=1**, remove ***List[1]*** \\n\\n### Stage 3\\n\\n\\tList = [1,4]\\n\\tGroup 0: 14 (where k=0)\\n\\tGroup 1: 41 (where k=1)\\n\\nAnswer lies within **Group [int(k/(len(List)-1!)] = 1**, 3rd digit is ***List[1]*** , which is \\'4\\', answer = **3 2 4** _\\nwe update **k = k%(len(List)-1)! = 0**, remove ***List[1]*** \\n\\t\\n### Stage 4\\n\\t\\n\\tList = [1]\\n\\tGroup 0: 1 (where k=0)\\n\\t\\nAnswer lies within **Group [int(k/(len(List)-1!)] = 0**, 4th digit is ***List[0]*** , which is \\'1\\', answer = **3 2 4 1**\\nAfter we remove ***List[0]*** , ***list*** becomes empty, terminate the loop\\n\\n```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        def fac(n,table): # define factorial function\\n            if n == 0:\\n                return 1\\n            if n in table: # dynamic programming\\n                return table[n]\\n            i = len(table) + 1\\n            while i < n+1:\\n                table[i] = table[i-1]*i\\n                i += 1\\n            return table[n]\\n                \\n        k -= 1 # we need to index everything from 0\\n        remaining = [i+1 for i in range(n)]\\n        ans = []\\n        table = {1:1} # define the base case\\n        for i in range(n):\\n            fac_rslt = fac(len(remaining)-1,table) # store the result of factorial operation\\n            index = k // fac_rslt #discover which group the answer lies within\\n            ans.append(str(remaining[index])) \\n            remaining.pop(index)\\n            k %= fac_rslt # update the k value\\n        return \\'\\'.join(ans)\\n```\\n\\nKindly upvote this post if you think the solution is helpful, thanks!",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        def fac(n,table): # define factorial function\\n            if n == 0:\\n                return 1\\n            if n in table: # dynamic programming\\n                return table[n]\\n            i = len(table) + 1\\n            while i < n+1:\\n                table[i] = table[i-1]*i\\n                i += 1\\n            return table[n]\\n                \\n        k -= 1 # we need to index everything from 0\\n        remaining = [i+1 for i in range(n)]\\n        ans = []\\n        table = {1:1} # define the base case\\n        for i in range(n):\\n            fac_rslt = fac(len(remaining)-1,table) # store the result of factorial operation\\n            index = k // fac_rslt #discover which group the answer lies within\\n            ans.append(str(remaining[index])) \\n            remaining.pop(index)\\n            k %= fac_rslt # update the k value\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298638,
                "title": "c-simple-and-short-solution-100-speed-explained",
                "content": "First thing to say, It was quite a long time when I first solved this. \\nAnd when I reviewed this question and saw my solution, I want to share it.\\nBut I\\'m not completely sure if it wasn\\'t \"copied\" (or the idea wasn\\'t copied) from other place.\\nIf it is, please let me know.\\n\\n**Jump back to the solution.** The idea is very simple.\\nLet\\'s say we are working on the first element of the answer.\\nFor the permutation from small to large, clearly the first element will change from **\\'1\\'** to **\\'n\\'**.\\n\\nHow much steps of permutation will it be between every first element changing?\\nObviously it\\'s the number of permutations of the rest of the sequence.\\nThe number will be **(n - 1)!**.\\nSo all we need to do is to calculate **k / (n - 1)!** and we\\'ll get the index of **\\'1\\'** to **\\'n\\'** for the first element.\\n\\nThen with the same logic, we work on the second element.\\nThe **k** now will become  **k % (n - 1)!** from the last round. The available characters to choose will be **\\'1\\'** to **\\'n\\'** and erase already used ones.\\n\\n\\n```\\nstring getPermutation(int n, int k) {\\n\\tvector<char> v; // store the available characters we can use\\n\\tint p = 1;\\n\\tfor(int i = 1; i <= n; i++){\\n\\t\\tp *= i;\\n\\t\\tv.push_back(\\'0\\' + i);\\n\\t}\\n\\t\\n\\tstring ans = \"\";\\n\\tk--;\\n\\tfor(int i = n; i > 0; i--){\\n\\t\\tp /= i;\\n\\t\\tans.push_back(v[k / p]);\\n\\t\\tv.erase(v.begin() + k / p);\\n\\t\\tk %= p;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring getPermutation(int n, int k) {\\n\\tvector<char> v; // store the available characters we can use\\n\\tint p = 1;\\n\\tfor(int i = 1; i <= n; i++){\\n\\t\\tp *= i;\\n\\t\\tv.push_back(\\'0\\' + i);\\n\\t}\\n\\t\\n\\tstring ans = \"\";\\n\\tk--;\\n\\tfor(int i = n; i > 0; i--){\\n\\t\\tp /= i;\\n\\t\\tans.push_back(v[k / p]);\\n\\t\\tv.erase(v.begin() + k / p);\\n\\t\\tk %= p;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565541,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1862540,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1953459,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1571144,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1851467,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1571143,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 2012293,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1924314,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1899090,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1889322,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1565541,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1862540,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1953459,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1571144,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1851467,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1571143,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 2012293,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1924314,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1899090,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 1889322,
                "content": [
                    {
                        "username": "joeleetcode2018",
                        "content": "The actual backtracking solution based on all permuations will be LTE. The actual optmized solution has no backtracking in it at all!"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "TLE "
                    },
                    {
                        "username": "noob_2347",
                        "content": "Can someone tell me why is this hard?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 😑 \nwhat do you think makes every problem harder???!!!\n\nTHE OPTIMAL SOLUTION !!!!"
                    },
                    {
                        "username": "rus_eell",
                        "content": "difficult to come up with an optimal solution \\notherwise by backtracking, find all the permutations and sort it and at last return the (k-1) th element which results in TLE "
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can\\'t solve this using backtracking. You need to learn about factoradics before you can attempt a solution."
                    },
                    {
                        "username": "CGK2002",
                        "content": "Mine actually passed all testcases. But still showing as \"Time Limit Exceeded\". Someone please explain why? The last executed input is literally showing as \"n = \" without any number, but 200/200 testcases passed"
                    },
                    {
                        "username": "jinsheng",
                        "content": "Even if I ad this line:\\nif(n ==8 && k == 8590) return \"26847351\";\\n\\nI still got TLE..."
                    },
                    {
                        "username": "Msey",
                        "content": "HACKERMAN"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The discrepancy between manual testcases and submissions is pretty bad. The brute force seems to work 100% of the time when tested manually (quite comfortably) but consistently fails on the same testcases when submitted.\\nI mean, it\\'s a good thing that the brute force doesn\\'t pass, but why do I get different results when I test that individually ?"
                    },
                    {
                        "username": "butzhang",
                        "content": "I use Java, so I'm just talking about java. To remove a element from a list, arrayList or a LinkedList, it takes O(n) to remove that. Of course you could implement a data structure of your own to remove a element with O(1) while maintaining the order. But if your algorithm is not O(n), please don't say it is O(n). Don't mislead other programmers. Just like the substring() function. It used to be O(1), But it is O(n) now. So please analyze the algorithm time complexity correctly."
                    },
                    {
                        "username": "WhiteKing010207",
                        "content": "why test case : 200  is empty ???\\nfor all test case code gives correct output except test case : 200\\n"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "Hardest question i ever solved"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: Think about the permutations as if you are representing a number in some sort of \"factorial base\" Where the leftmost digit represents multiples of 1, then multiples of 2, then multiples of 6, then multiples of 24, etc. Now convert k to this base. There is a tiny bit more to it, but this line of thinking should get you there. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Did you come up with this on your own? How long did it take?"
                    },
                    {
                        "username": "MrClean974",
                        "content": "My intuitive solution was to create the list of all permutations with a seperate recursive function. Then, to return the k-th element of this list. \\nIt\\'s very slow (~6000ms) but I don\\'t understand the best solutions... \\n\\nAny tips/explainations ?"
                    },
                    {
                        "username": "CodeDEVotion",
                        "content": "I did same but to avoid TLE I passed count variable which will return ans as soon as it becomes equal to k\nHeres my code\nstring per(string x,string y,int k,int &count){\n        if(y.size()==0){\n            count++;\n            if(count==k){\n                return x;\n            }\n            else return \"\";\n        }\n        int i=0;\n        while(i<y.size()){\n            char ch = y[i];\n            string curr;\n            for(int j=0;j<y.size();j++){\n                if(j!=i) curr+=y[j];\n            }\n             string a = per(x+ch,curr,k,count);\n             if(a!=\"\"){\n                return a;\n             }\n            i++;\n        }\n        return \"\";\n    }\n    string getPermutation(int n, int k) {\n        string x;\n        for(int i =1;i<=n;i++){\n            x+=char('0'+i);\n        }\n        int count = 0;\n        string ans = per(\"\",x,k,count);\n        return ans;\n    }"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need to use factoradics to solve this problem. If you express k in a factorial base, you can use the coefficients of this number to choose the desired elements from the unsorted array."
                    }
                ]
            },
            {
                "id": 2053052,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 2004225,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1998497,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1997177,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1986133,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1922327,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1912940,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1862902,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1850409,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            },
            {
                "id": 1843550,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for somebody wondering if this can be solved using trie, the answer is yes!"
                    },
                    {
                        "username": "subhankar_rout",
                        "content": "can Any one optimise this code ::..\\n`\\nimport java.util.*;\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String numbers = \"123456789\";\\n        String st = numbers.substring(0, n);\\n        List<String> list = new ArrayList<>();\\n\\n        permutation(st, \"\", list);\\n\\n        if (k <= list.size()) return list.get(k - 1);\\n        else return \"\";\\n    }\\n   \\n   public static void permutation(String str, String afot, List<String> list) {\\n\\n        if (str.length() == 0) {\\n            list.add(afot);\\n\\n            return;\\n        }\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            char ch = str.charAt(i);\\n            String left = str.substring(0, i);\\n            String right = str.substring(i + 1);\\n            String req = left + right;\\n            permutation(req, afot + ch, list);\\n        }\\n\\n    }\\n   \\n} `"
                    },
                    {
                        "username": "aditya_dawar24",
                        "content": "i hope this helps :\\nstring x=\"\";\\n        \\n        for(int i=1;i<=n;i++){\\n            x+=\\'0\\'+i;\\n        }\\n\\n        vector<string>ans;\\n        \\n        do{\\n            ans.push_back(x);\\n        }while(next_permutation(x.begin(),x.end()));\\n    \\n        return ans[k-1];"
                    },
                    {
                        "username": "pravanshu1608",
                        "content": "Here is a possible explanation (if you still can\\'t follow it, refer to: (https://leetcode.com/problems/permutation-sequence/solutions/3853004/java-easy-to-understand-code/)\\n )\\n\\nHope this helps...\\n\\n\\narr = [1, 2, 3, 4], k = 17\\n\\nk = 17 - 1 = 16 (0-based indexing)\\n\\nHere, the number of elements is 4, so the possible permutations would be 4! = 24.\\n\\nWe can arrange the above in the following way:\\n\\n0: 1 + {2, 3, 4}\\n1: 2 + {1, 3, 4}\\n2: 3 + {1, 2, 4}\\n3: 4 + {1, 2, 3}\\n\\n0, 1, 2, 3 are index numbers.\\n\\n16/6 = 2 (this will let us know the index of the sequence, i.e., in which index the sequence would be)\\n\\n16%6 = 4 (this would give the next sequence to search for)\\n\\nWhy 6? Because in the above arrangement, we can see a number + a set of n numbers (in our case, it is 3) which is n!, i.e., 3!.\\n\\nNow we add the number of that particular index where our sequence could be found.\\n\\nWe can take an empty string and store the number so as to get our sequence.\\n\\nSo, the string is \"3\" (because 3 is the number present in that index).\\n\\nNow we remove that number and again follow the same pattern as above:\\n\\ni.e., our updated array would be [1, 2, 4], k = 4.\\n\\nAgain:\\n\\n0: 1 + {2, 4}\\n1: 2 + {1, 4}\\n2: 4 + {1, 2}\\n\\nHere 4/2 = 2, and 4%2 = 0.\\n\\nAdd the number of the 2nd index to our string, i.e., 4.\\n\\nString becomes \"34\".\\n\\nRemove that number from the array:\\n\\narr [1, 2], k = 0.\\n\\nAgain:\\n\\n0: 1 + {2}\\n1: 2 + {1}\\n\\nHere 0/1 = 0, and 0%1 = 0.\\n\\nAdd the 0th index number to the string:\\n\\nString becomes \"341\".\\n\\nNow, we are left out only with one number, so you could simply add that number to the string, i.e., the final string is \"3412\"."
                    },
                    {
                        "username": "pcRipper",
                        "content": "why is it even hard?"
                    },
                    {
                        "username": "Diean233",
                        "content": "I guess it\\'s because LC groups it together with other permutation problems, like 46&47, and this problem seems to be more complicated. But they are not the same type of problems at all, thus this is not that hard if you can just treat it as a math problem. "
                    },
                    {
                        "username": "psionl0",
                        "content": "I think that this problem is easier than ``46. Permutations`` but that problem could be solved using backtracking and didn\\'t require knowledge of factoradics.\\n\\nI actually used factoradics to solve problem 46 so generating a single permutation proved easier than generating all of them."
                    },
                    {
                        "username": "egretrteg",
                        "content": "string s=\"\";\\n        for(int i=1;i<=n;i++) s+=to_string(i);\\n        cout<<s<<endl;\\n        int cnt=1;\\n        while(k!=1)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            //cout<<s<<endl;\\n            k--;\\n        }\\n        return s;"
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "This question is marked as Hard.\\nIs this make sence?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It IS hard if you are not familiar with factorials."
                    },
                    {
                        "username": "Vithesh",
                        "content": "this problem is more like a medium level one.\\nThey could have made it harder by adding  strict time complexity and space.\\nHowever i used O(n) space and O(k*nlogn) time."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s just unfair. If you are not a pure genius mathematician you have no chance to solve it without TLE :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I disagree. I have a pretty good background in math but I am no genius for sure, and I had no particular problem solving it\nThe only mathematical knowledge required is factorials which I'm sure you're familiar with (and they even give you a refresher in the problem statement), it's unfair to say you need to be mathematician to solve that"
                    }
                ]
            }
        ]
    },
    {
        "title": "Intersection of Two Linked Lists",
        "question_content": "<p>Given the heads of two singly linked-lists <code>headA</code> and <code>headB</code>, return <em>the node at which the two lists intersect</em>. If the two linked lists have no intersection at all, return <code>null</code>.</p>\n\n<p>For example, the following two linked lists begin to intersect at node <code>c1</code>:</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_statement.png\" style=\"width: 500px; height: 162px;\" />\n<p>The test cases are generated such that there are no cycles anywhere in the entire linked structure.</p>\n\n<p><strong>Note</strong> that the linked lists must <strong>retain their original structure</strong> after the function returns.</p>\n\n<p><strong>Custom Judge:</strong></p>\n\n<p>The inputs to the <strong>judge</strong> are given as follows (your program is <strong>not</strong> given these inputs):</p>\n\n<ul>\n\t<li><code>intersectVal</code> - The value of the node where the intersection occurs. This is <code>0</code> if there is no intersected node.</li>\n\t<li><code>listA</code> - The first linked list.</li>\n\t<li><code>listB</code> - The second linked list.</li>\n\t<li><code>skipA</code> - The number of nodes to skip ahead in <code>listA</code> (starting from the head) to get to the intersected node.</li>\n\t<li><code>skipB</code> - The number of nodes to skip ahead in <code>listB</code> (starting from the head) to get to the intersected node.</li>\n</ul>\n\n<p>The judge will then create the linked structure based on these inputs and pass the two heads, <code>headA</code> and <code>headB</code> to your program. If you correctly return the intersected node, then your solution will be <strong>accepted</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png\" style=\"width: 500px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n<strong>Output:</strong> Intersected at &#39;8&#39;\n<strong>Explanation:</strong> The intersected node&#39;s value is 8 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n- Note that the intersected node&#39;s value is not 1 because the nodes with value 1 in A and B (2<sup>nd</sup> node in A and 3<sup>rd</sup> node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3<sup>rd</sup> node in A and 4<sup>th</sup> node in B) point to the same location in memory.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png\" style=\"width: 500px; height: 194px;\" />\n<pre>\n<strong>Input:</strong> intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n<strong>Output:</strong> Intersected at &#39;2&#39;\n<strong>Explanation:</strong> The intersected node&#39;s value is 2 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_3.png\" style=\"width: 300px; height: 189px;\" />\n<pre>\n<strong>Input:</strong> intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n<strong>Output:</strong> No intersection\n<strong>Explanation:</strong> From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\nExplanation: The two lists do not intersect, so return null.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes of <code>listA</code> is in the <code>m</code>.</li>\n\t<li>The number of nodes of <code>listB</code> is in the <code>n</code>.</li>\n\t<li><code>1 &lt;= m, n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= skipA &lt;&nbsp;m</code></li>\n\t<li><code>0 &lt;= skipB &lt;&nbsp;n</code></li>\n\t<li><code>intersectVal</code> is <code>0</code> if <code>listA</code> and <code>listB</code> do not intersect.</li>\n\t<li><code>intersectVal == listA[skipA] == listB[skipB]</code> if <code>listA</code> and <code>listB</code> intersect.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you write a solution that runs in <code>O(m + n)</code> time and use only <code>O(1)</code> memory?",
        "solutions": [
            {
                "id": 49785,
                "title": "java-solution-without-knowing-the-difference-in-len",
                "content": "I found most solutions here preprocess linkedlists to get the difference in len. \\nActually we don't care about the \"value\" of difference, we just want to make sure two pointers reach the intersection node at the same time.\\n\\nWe can use two iterations to do that. In the first iteration, we will reset the pointer of one linkedlist to the head of another linkedlist after it reaches the tail node. In the second iteration, we will move two pointers until they points to the same node. Our operations in first iteration will help us counteract the difference. So if two linkedlist intersects, the meeting point in second iteration must be the intersection point. If the two linked lists have no intersection at all, then the meeting pointer in second iteration must be the tail node of both lists, which is null\\n\\nBelow is my commented Java code:\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        //boundary check\\n        if(headA == null || headB == null) return null;\\n        \\n        ListNode a = headA;\\n        ListNode b = headB;\\n        \\n        //if a & b have different len, then we will stop the loop after second iteration\\n        while( a != b){\\n        \\t//for the end of first iteration, we just reset the pointer to the head of another linkedlist\\n            a = a == null? headB : a.next;\\n            b = b == null? headA : b.next;    \\n        }\\n        \\n        return a;\\n    }",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "I found most solutions here preprocess linkedlists to get the difference in len. \\nActually we don't care about the \"value\" of difference, we just want to make sure two pointers reach the intersection node at the same time.\\n\\nWe can use two iterations to do that. In the first iteration, we will reset the pointer of one linkedlist to the head of another linkedlist after it reaches the tail node. In the second iteration, we will move two pointers until they points to the same node. Our operations in first iteration will help us counteract the difference. So if two linkedlist intersects, the meeting point in second iteration must be the intersection point. If the two linked lists have no intersection at all, then the meeting pointer in second iteration must be the tail node of both lists, which is null\\n\\nBelow is my commented Java code:\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        //boundary check\\n        if(headA == null || headB == null) return null;\\n        \\n        ListNode a = headA;\\n        ListNode b = headB;\\n        \\n        //if a & b have different len, then we will stop the loop after second iteration\\n        while( a != b){\\n        \\t//for the end of first iteration, we just reset the pointer to the head of another linkedlist\\n            a = a == null? headB : a.next;\\n            b = b == null? headA : b.next;    \\n        }\\n        \\n        return a;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 49789,
                "title": "my-accepted-simple-and-shortest-c-code-with-comments-explaining-the-algorithm-any-comments-or-improvements",
                "content": "    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) \\n    {\\n        ListNode *p1 = headA;\\n        ListNode *p2 = headB;\\n            \\n        if (p1 == NULL || p2 == NULL) return NULL;\\n    \\n        while (p1 != NULL && p2 != NULL && p1 != p2) {\\n            p1 = p1->next;\\n            p2 = p2->next;\\n\\n            //\\n            // Any time they collide or reach end together without colliding \\n            // then return any one of the pointers.\\n            //\\n            if (p1 == p2) return p1;\\n\\n            //\\n            // If one of them reaches the end earlier then reuse it \\n            // by moving it to the beginning of other list.\\n            // Once both of them go through reassigning, \\n            // they will be equidistant from the collision point.\\n            //\\n            if (p1 == NULL) p1 = headB;\\n            if (p2 == NULL) p2 = headA;\\n        }\\n            \\n        return p1;\\n    }",
                "solutionTags": [],
                "code": "    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) \\n    {\\n        ListNode *p1 = headA;\\n        ListNode *p2 = headB;\\n            \\n        if (p1 == NULL || p2 == NULL) return NULL;\\n    \\n        while (p1 != NULL && p2 != NULL && p1 != p2) {\\n            p1 = p1->next;\\n            p2 = p2->next;\\n\\n            //\\n            // Any time they collide or reach end together without colliding \\n            // then return any one of the pointers.\\n            //\\n            if (p1 == p2) return p1;\\n\\n            //\\n            // If one of them reaches the end earlier then reuse it \\n            // by moving it to the beginning of other list.\\n            // Once both of them go through reassigning, \\n            // they will be equidistant from the collision point.\\n            //\\n            if (p1 == NULL) p1 = headB;\\n            if (p2 == NULL) p2 = headA;\\n        }\\n            \\n        return p1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 49798,
                "title": "concise-python-code-with-comments",
                "content": "    class Solution:\\n        # @param two ListNodes\\n        # @return the intersected ListNode\\n        def getIntersectionNode(self, headA, headB):\\n            if headA is None or headB is None:\\n                return None\\n    \\n            pa = headA # 2 pointers\\n            pb = headB\\n    \\n            while pa is not pb:\\n                # if either pointer hits the end, switch head and continue the second traversal, \\n                # if not hit the end, just move on to next\\n                pa = headB if pa is None else pa.next\\n                pb = headA if pb is None else pb.next\\n    \\n            return pa # only 2 ways to get out of the loop, they meet or the both hit the end=None\\n    \\n    # the idea is if you switch head, the possible difference between length would be countered. \\n    # On the second traversal, they either hit or miss. \\n    # if they meet, pa or pb would be the node we are looking for, \\n    # if they didn't meet, they will hit the end at the same iteration, pa == pb == None, return either one of them is the same,None",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param two ListNodes\\n        # @return the intersected ListNode\\n        def getIntersectionNode(self, headA, headB):\\n            if headA is None or headB is None:\\n                return None\\n    \\n            pa = headA # 2 pointers\\n            pb = headB\\n    \\n            while pa is not pb:\\n                # if either pointer hits the end, switch head and continue the second traversal, \\n                # if not hit the end, just move on to next\\n                pa = headB if pa is None else pa.next\\n                pb = headA if pb is None else pb.next\\n    \\n            return pa # only 2 ways to get out of the loop, they meet or the both hit the end=None\\n    \\n    # the idea is if you switch head, the possible difference between length would be countered. \\n    # On the second traversal, they either hit or miss. \\n    # if they meet, pa or pb would be the node we are looking for, \\n    # if they didn't meet, they will hit the end at the same iteration, pa == pb == None, return either one of them is the same,None",
                "codeTag": "Java"
            },
            {
                "id": 1093014,
                "title": "c-four-different-solutions",
                "content": "### 1. Brute Force Solution\\nTime Complexity : ` O(m * n)`\\nSpace Complexity : `O(1)`\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\t\\tListNode *temp;\\n\\t\\t\\twhile(headA != NULL){\\n\\t\\t\\t\\ttemp = headB;\\n\\t\\t\\t\\twhile(temp != NULL){\\n\\t\\t\\t\\t\\tif(headA == temp){\\n\\t\\t\\t\\t\\t\\treturn headA;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ttemp = temp -> next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\theadA = headA -> next;\\n\\t\\t\\t}\\n\\t\\t\\treturn NULL;\\n\\t\\t}\\n\\t};\\n\\t\\n### 2. HashMap Solution\\nTime Complexity : ` O(m + n)`\\nSpace Complexity : `O(m)`\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\t\\tunordered_map<ListNode*, int> m;\\n\\t\\t\\twhile(headA != NULL){\\n\\t\\t\\t\\tm[headA]++;\\n\\t\\t\\t\\theadA = headA -> next;\\n\\t\\t\\t}\\n\\t\\t\\twhile(headB != NULL){\\n\\t\\t\\t\\tif(m[headB] > 0){\\n\\t\\t\\t\\t\\treturn headB;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\theadB = headB -> next;\\n\\t\\t\\t}\\n\\t\\t\\treturn NULL;\\n\\t\\t}\\n\\t};\\n\\n### 3. Length Difference Solution\\nTime Complexity : ` O(m + n)` \\nSpace Complexity : `O(1)`\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\t\\tint n = 0;\\n\\t\\t\\tint m = 0;\\n\\t\\t\\tListNode* ptr1 = headA;\\n\\t\\t\\tListNode* ptr2 = headB;\\n\\t\\t\\twhile(ptr1 != NULL){\\n\\t\\t\\t\\tn++;\\n\\t\\t\\t\\tptr1 = ptr1 -> next;\\n\\t\\t\\t}\\n\\t\\t\\twhile(ptr2 != NULL){\\n\\t\\t\\t\\tm++;\\n\\t\\t\\t\\tptr2 = ptr2 -> next;\\n\\t\\t\\t}\\n\\t\\t\\tint t = abs(n - m);\\n\\t\\t\\tif(n > m){\\n\\t\\t\\t\\twhile(t){\\n\\t\\t\\t\\t\\theadA = headA -> next;\\n\\t\\t\\t\\t\\tt--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\twhile(t){\\n\\t\\t\\t\\t\\theadB = headB -> next;\\n\\t\\t\\t\\t\\tt--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\twhile(headA != NULL and headB != NULL){\\n\\t\\t\\t\\tif(headA == headB){\\n\\t\\t\\t\\t\\treturn headA;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\theadA = headA -> next;\\n\\t\\t\\t\\theadB = headB -> next;\\n\\t\\t\\t}\\n\\t\\t\\treturn NULL;\\n\\t\\t}\\n\\t};\\n\\n### 4. Two-Pointers Solution\\nTime Complexity : ` O(m + n)`\\nSpace Complexity : `O(1)`\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\t\\tListNode *ptr1 = headA;\\n\\t\\t\\tListNode *ptr2 = headB;\\n\\t\\t\\twhile(ptr1 != ptr2){\\n\\t\\t\\t\\tif(ptr1 == NULL){\\n\\t\\t\\t\\t\\tptr1 = headB;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tptr1 = ptr1 -> next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(ptr2 == NULL){\\n\\t\\t\\t\\t\\tptr2 = headA;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tptr2 = ptr2 -> next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ptr1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\t\\tListNode *temp;\\n\\t\\t\\twhile(headA != NULL){\\n\\t\\t\\t\\ttemp = headB;\\n\\t\\t\\t\\twhile(temp != NULL){\\n\\t\\t\\t\\t\\tif(headA == temp){\\n\\t\\t\\t\\t\\t\\treturn headA;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 49792,
                "title": "concise-java-solution-o-1-memory-o-n-time",
                "content": "1, Get the length of the two lists.\\n\\n2, Align them to the same start point.\\n\\n3, Move them together until finding the intersection point, or the end null\\n\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int lenA = length(headA), lenB = length(headB);\\n        // move headA and headB to the same start point\\n        while (lenA > lenB) {\\n            headA = headA.next;\\n            lenA--;\\n        }\\n        while (lenA < lenB) {\\n            headB = headB.next;\\n            lenB--;\\n        }\\n        // find the intersection until end\\n        while (headA != headB) {\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n        return headA;\\n    }\\n    \\n    private int length(ListNode node) {\\n        int length = 0;\\n        while (node != null) {\\n            node = node.next;\\n            length++;\\n        }\\n        return length;\\n    }",
                "solutionTags": [],
                "code": "1, Get the length of the two lists.\\n\\n2, Align them to the same start point.\\n\\n3, Move them together until finding the intersection point, or the end null\\n\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int lenA = length(headA), lenB = length(headB);\\n        // move headA and headB to the same start point\\n        while (lenA > lenB) {\\n            headA = headA.next;\\n            lenA--;\\n        }\\n        while (lenA < lenB) {\\n            headB = headB.next;\\n            lenB--;\\n        }\\n        // find the intersection until end\\n        while (headA != headB) {\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n        return headA;\\n    }\\n    \\n    private int length(ListNode node) {\\n        int length = 0;\\n        while (node != null) {\\n            node = node.next;\\n            length++;\\n        }\\n        return length;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3176186,
                "title": "solution",
                "content": "```C++ []\\n int init = []\\n{\\n    std::ios_base::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n    std::ofstream out(\"user.out\");\\n    for(string s; getline(std::cin, s);)\\n    {\\n        if(s[0] != \\'0\\') out << \"Intersected at \\'\" << s << \"\\'\\\\n\";\\n        else out << \"No intersection\\\\n\";\\n        for(int i = 0; i < 4; ++i) getline(std::cin, s);\\n    }\\n    out.flush();\\n    exit(0);\\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*,int>mpp;\\n    for (auto p = headA ; p!=NULL ; p = p->next){\\n        mpp[p]=p->val;\\n    }\\n    for (auto p = headB ; p!=NULL ; p = p->next){\\n        if (mpp.find(p)!=mpp.end()) return p;\\n    }\\n    return NULL;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        stackA = [\\'A\\']\\n        stackB = [\\'B\\']\\n\\n        while headA or headB:\\n            if headA:\\n                stackA.append(headA)\\n                headA = headA.next\\n\\n            if headB:\\n                stackB.append(headB)\\n                headB = headB.next\\n\\n        prev = None\\n        while stackA and stackB:\\n            nodeA = stackA.pop(-1)\\n            nodeB = stackB.pop(-1)\\n\\n            if nodeA != nodeB:\\n                return prev\\n\\n            prev = nodeA\\n```\\n\\n```Java []\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int ac = 0;\\n        int bc = 0;\\n        ListNode a = headA;\\n        ListNode b = headB;\\n        while(a != null){\\n            ac++;\\n            a = a.next;\\n        }\\n        while(b != null){\\n            bc++;\\n            b = b.next;\\n        }\\n        while(ac > bc){\\n            ac--;\\n            headA = headA.next;\\n        }\\n        while(bc > ac){\\n            bc--;\\n            headB = headB.next;\\n        }\\n        \\n        while(headA != headB){\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n        return headA;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\n int init = []\\n{\\n    std::ios_base::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n    std::ofstream out(\"user.out\");\\n    for(string s; getline(std::cin, s);)\\n    {\\n        if(s[0] != \\'0\\') out << \"Intersected at \\'\" << s << \"\\'\\\\n\";\\n        else out << \"No intersection\\\\n\";\\n        for(int i = 0; i < 4; ++i) getline(std::cin, s);\\n    }\\n    out.flush();\\n    exit(0);\\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*,int>mpp;\\n    for (auto p = headA ; p!=NULL ; p = p->next){\\n        mpp[p]=p->val;\\n    }\\n    for (auto p = headB ; p!=NULL ; p = p->next){\\n        if (mpp.find(p)!=mpp.end()) return p;\\n    }\\n    return NULL;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        stackA = [\\'A\\']\\n        stackB = [\\'B\\']\\n\\n        while headA or headB:\\n            if headA:\\n                stackA.append(headA)\\n                headA = headA.next\\n\\n            if headB:\\n                stackB.append(headB)\\n                headB = headB.next\\n\\n        prev = None\\n        while stackA and stackB:\\n            nodeA = stackA.pop(-1)\\n            nodeB = stackB.pop(-1)\\n\\n            if nodeA != nodeB:\\n                return prev\\n\\n            prev = nodeA\\n```\n```Java []\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int ac = 0;\\n        int bc = 0;\\n        ListNode a = headA;\\n        ListNode b = headB;\\n        while(a != null){\\n            ac++;\\n            a = a.next;\\n        }\\n        while(b != null){\\n            bc++;\\n            b = b.next;\\n        }\\n        while(ac > bc){\\n            ac--;\\n            headA = headA.next;\\n        }\\n        while(bc > ac){\\n            bc--;\\n            headB = headB.next;\\n        }\\n        \\n        while(headA != headB){\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n        return headA;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092898,
                "title": "js-python-java-c-easy-o-1-extra-space-solution-w-visual-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe naive approach here would be to store each node reference in a data structure until we saw the same one twice, but that would take **O(N) extra space**.\\n\\nIn order to solve this problem with only **O(1) extra space**, we\\'ll need to find another way to align the two linked lists. More importantly, we need to find a way to line up the *ends* of the two lists. And the easiest way to do that is to concatenate them in opposite orders, **A+B** and **B+A**. This way, the ends of the two original lists will align on the second half of each merged list.\\n\\n![Visual 1](https://i.imgur.com/hcpocCV.png)\\n\\n![Visual 2](https://i.imgur.com/dDUjSPk.png)\\n\\nThen we just need to check if at some point the two merged lists are pointing to the same node. In fact, even if the two merged lists don\\'t intersect, the value of **a** and **b** will be the same (**null**) when we come to the end of the merged lists, so we can use that as our exit condition.\\n\\nWe just need to make sure to string **headB** onto **a** and vice versa if one (but not both) list ends.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere code for all four languages is almost identical.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **96ms / 45.7MB** (beats 98% / 95%).\\n```javascript\\nvar getIntersectionNode = function(headA, headB) {\\n    let a = headA, b = headB\\n    while (a !== b) {\\n        a = !a ? headB : a.next\\n        b = !b ? headA : b.next\\n    }\\n    return a\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **156ms / 29.3MB** (beats 88% / 88%).\\n```python\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        a, b = headA, headB\\n        while (a != b):\\n            a = headB if not a else a.next\\n            b = headA if not b else b.next\\n        return a\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 41.6MB** (beats 98% / 88%).\\n```java\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode a = headA, b = headB;\\n        while (a != b) {\\n            a = a == null ? headB : a.next;\\n            b = b == null ? headA : b.next;\\n        }\\n        return a;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **36ms / 14.5MB** (beats 96% / 96%).\\n```c++\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *a = headA, *b = headB;\\n        while (a != b) {\\n            a = !a ? headB : a->next;\\n            b = !b ? headA : b->next;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar getIntersectionNode = function(headA, headB) {\\n    let a = headA, b = headB\\n    while (a !== b) {\\n        a = !a ? headB : a.next\\n        b = !b ? headA : b.next\\n    }\\n    return a\\n};\\n```\n```python\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        a, b = headA, headB\\n        while (a != b):\\n            a = headB if not a else a.next\\n            b = headA if not b else b.next\\n        return a\\n```\n```java\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode a = headA, b = headB;\\n        while (a != b) {\\n            a = a == null ? headB : a.next;\\n            b = b == null ? headA : b.next;\\n        }\\n        return a;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *a = headA, *b = headB;\\n        while (a != b) {\\n            a = !a ? headB : a->next;\\n            b = !b ? headA : b->next;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116221,
                "title": "visual-explanation-one-pass-java",
                "content": "### Logic:\\nThe intuition behind a one-pass solution to this question can be quite tricky to grasp. I hope that my visual explanation below can aid in your understanding of this approach! Let\\'s get started.\\n\\nFirst let\\'s use the below linked lists A and B as our example. The blue circles represent nodes that belong strictly to list A, the green circles represent nodes that belong strictly to list B, and the red circles are the nodes they share in common. The first red node in this case is the intersection point.\\n\\n![image](https://assets.leetcode.com/users/images/6330aba4-624d-4d17-9a29-2363af7596e3_1654509991.8164506.png)\\n\\nNow, as you may have realised when attempting this problem, the main difficulty comes from the lists being of different lengths. As such, we can\\'t just loop through both lists one node at a time and check for equality since we\\'re not guarranteed that their lengths before the interection point are the same.\\n\\n**Observation 1:**\\nA key observation here is that, if that if we visualise both lists as separate lists, their tail nodes are identical both in value and in quantity.\\n\\n![image](https://assets.leetcode.com/users/images/2a35b0b4-2902-4ec2-bb8a-cf7835a42ea2_1654510005.172662.png)\\n\\nDamn, if only the nodes before the interesction had the same length as well. That would make our one-pass solution really simple! \\n\\n> Interview tip: If there\\'s certain trait or behaviour that you would like the question/input to have, try and enforce it by manipulating the datastructure. \\n\\nIn this case, we would like the lengths before the intersection to be equal as well. That way, we would only need to loop through both lists with the guarrantee that both lists will reach the intersection node at the same time.\\n\\n**Observation 2:**\\nThe next observation is that, while both lists may be of different lenghts, `list A + list B` has the same length as `list B + list A`. \\n\\n![image](https://assets.leetcode.com/users/images/681dec00-018d-4631-b699-389fe1301a66_1654510021.4787977.png)\\n\\nIf in our one-pass solution we perform two simultaneous loops (first go through list A and then through list B, and another going through list B then list A), we are not only guarranteed to be looping through combined lists of the same length but we\\'re also guarranteed that the last nodes of both iterations will be our red nodes.\\n\\n### What if there\\'s no intersection?\\nIn that case, we would like for our loop will stop when we\\'ve reached the end of both combined lists. That is, when both our node pointers are null. Luckily, as you\\'ll see in the code, our while loop\\'s exist condition accounts for this edge case as well.\\n\\nAwesome! Now we have everything we need to start coding.\\n___\\n### Code:\\nIf you have any questions, suggestions or improvements, feel free to let me know. Thank you for reading!\\n```java\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n    ListNode ptrA = headA, ptrB = headB;\\n    while (ptrA != ptrB) { // loop until we found the first common node\\n        ptrA = ptrA == null ? headB : ptrA.next; // once we\\'re done with A, move to B\\n        ptrB = ptrB == null ? headA : ptrB.next; // once we\\'re done with B, move to A\\n\\t}\\n\\treturn ptrA;\\n}\\n```\\n**Time Complexity:** `O(A + B)` where A and B are the lengths of each linked list.\\n**Space Complexity:** `O(1)`",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n    ListNode ptrA = headA, ptrB = headB;\\n    while (ptrA != ptrB) { // loop until we found the first common node\\n        ptrA = ptrA == null ? headB : ptrA.next; // once we\\'re done with A, move to B\\n        ptrB = ptrB == null ? headA : ptrB.next; // once we\\'re done with B, move to A\\n\\t}\\n\\treturn ptrA;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 49799,
                "title": "simple-c-solution-5-lines",
                "content": "Move cur1 (cur2) forward from headA (headB) and loop back to headB (headA), eventually cur1 and cur2 will meet at the intersection point or nullptr.\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *cur1 = headA, *cur2 = headB;\\n        while(cur1 != cur2){\\n            cur1 = cur1?cur1->next:headB;\\n            cur2 = cur2?cur2->next:headA;\\n        }\\n        return cur1;\\n    }",
                "solutionTags": [],
                "code": "Move cur1 (cur2) forward from headA (headB) and loop back to headB (headA), eventually cur1 and cur2 will meet at the intersection point or nullptr.\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *cur1 = headA, *cur2 = headB;\\n        while(cur1 != cur2){\\n            cur1 = cur1?cur1->next:headB;\\n            cur2 = cur2?cur2->next:headA;\\n        }\\n        return cur1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3432461,
                "title": "c-2-approaches-beats-92-loop-o-1-space",
                "content": "# Intuition\\nThe problem states that we need to find the intersection of two linked lists without changing their original structure.\\n\\n# Approach 1\\n1. Find the length of both the linked lists.\\n2. Traverse the bigger linked list until the remaining nodes count becomes equal to the smaller one\\'s.\\n3. Traverse both the heads together. If both of them are same then the intersecting node is found.\\n\\n# Complexity\\n- Time complexity: O(n) where n>m\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```\\nclass Solution {\\npublic:\\n    int length(ListNode *head){\\n        int len = 0;\\n        while(head){\\n            len++;\\n            head = head->next;\\n        }\\n        return len;\\n    }\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if(!headA || !headB) return NULL;\\n\\n        //step1\\n        int lenA = length(headA), lenB = length(headB);\\n\\n        //step2\\n        if(lenA>lenB){\\n            while(lenA>lenB){\\n                headA = headA->next;\\n                lenA--;\\n            }\\n        }\\n        else if(lenA<lenB){\\n            while(lenA<lenB){\\n                headB = headB->next;\\n                lenB--;\\n            }\\n        }\\n        \\n        //step 3\\n        while(headA && headB){\\n            if(headA==headB) return headA;\\n            headA = headA->next;\\n            headB = headB->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n# Approach 2 \\nPrerequisite : [https://leetcode.com/problems/linked-list-cycle-ii/]()\\n\\nIn this approach, we can simply convert this problem into a loop problem.\\n1. Find the tail.\\n2. Connect the tail with any of the head which creates a loop.\\n3. Using the other head, find intersection point of the loop.\\n4. Undo the loop, by setting `tail->next = NULL`\\n5. Return the intersection node.\\n\\n# Complexity\\n- Time complexity: O(n+m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        //getting the tail\\n        ListNode* tail = headA;\\n        while(tail->next){\\n            tail = tail->next;\\n        }\\n\\n        //creating a loop\\n        tail->next = headA;\\n\\n        //detecting and finding the intersection\\n        ListNode *fast = headB, *slow = headB;\\n\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n\\n            if(slow==fast) {\\n                slow = headB;\\n                while(slow!=fast){\\n                    slow = slow->next;\\n                    fast = fast->next;\\n                }\\n                //undoing the loop\\n                tail->next = NULL;\\n                return slow;\\n            };\\n        }\\n        tail->next = NULL;\\n        return NULL;\\n    }\\n\\n![upvote.jpeg](https://assets.leetcode.com/users/images/a8052144-9a2e-4d47-9037-ccf7539df2d7_1681909702.2563934.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int length(ListNode *head){\\n        int len = 0;\\n        while(head){\\n            len++;\\n            head = head->next;\\n        }\\n        return len;\\n    }\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if(!headA || !headB) return NULL;\\n\\n        //step1\\n        int lenA = length(headA), lenB = length(headB);\\n\\n        //step2\\n        if(lenA>lenB){\\n            while(lenA>lenB){\\n                headA = headA->next;\\n                lenA--;\\n            }\\n        }\\n        else if(lenA<lenB){\\n            while(lenA<lenB){\\n                headB = headB->next;\\n                lenB--;\\n            }\\n        }\\n        \\n        //step 3\\n        while(headA && headB){\\n            if(headA==headB) return headA;\\n            headA = headA->next;\\n            headB = headB->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49846,
                "title": "python-solution-for-intersection-of-two-singly-linked-lists",
                "content": "    # Definition for singly-linked list.\\n    # class ListNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.next = None\\n    \\n    class Solution:\\n        # @param two ListNodes\\n        # @return the intersected ListNode\\n        def getIntersectionNode(self, headA, headB):\\n            curA,curB = headA,headB\\n            lenA,lenB = 0,0\\n            while curA is not None:\\n                lenA += 1\\n                curA = curA.next\\n            while curB is not None:\\n                lenB += 1\\n                curB = curB.next\\n            curA,curB = headA,headB\\n            if lenA > lenB:\\n                for i in range(lenA-lenB):\\n                    curA = curA.next\\n            elif lenB > lenA:\\n                for i in range(lenB-lenA):\\n                    curB = curB.next\\n            while curB != curA:\\n                curB = curB.next\\n                curA = curA.next\\n            return curA\\n\\n\\nThe solution is straightforward: maintaining two pointers in the lists under the constraint that both lists have the same number of nodes starting from the pointers. We need to calculate the length of each list though. So O(N) for time and O(1) for space.",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "    # Definition for singly-linked list.\\n    # class ListNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.next = None\\n    \\n    class Solution:\\n        # @param two ListNodes\\n        # @return the intersected ListNode\\n        def getIntersectionNode(self, headA, headB):\\n            curA,curB = headA,headB\\n            lenA,lenB = 0,0\\n            while curA is not None:\\n                lenA += 1\\n                curA = curA.next\\n            while curB is not None:\\n                lenB += 1\\n                curB = curB.next\\n            curA,curB = headA,headB\\n            if lenA > lenB:\\n                for i in range(lenA-lenB):\\n                    curA = curA.next\\n            elif lenB > lenA:\\n                for i in range(lenB-lenA):\\n                    curB = curB.next\\n            while curB != curA:\\n                curB = curB.next\\n                curA = curA.next\\n            return curA\\n\\n\\nThe solution is straightforward: maintaining two pointers in the lists under the constraint that both lists have the same number of nodes starting from the pointers. We need to calculate the length of each list though. So O(N) for time and O(1) for space.",
                "codeTag": "Java"
            },
            {
                "id": 2116127,
                "title": "python-easy-2-approaches-o-1-space",
                "content": "1. ## **Hashset**\\n\\nThe algorithm is:\\n1. Store all the elements of `headA` in a hashset\\n2. Iterate through the `headB` and check for the first match and then return it.\\n\\n**Time - O(n+m)**\\n**Space - O(n)**\\n\\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        first_set=set()\\n        curr=headA\\n        \\n        while curr:\\n            first_set.add(curr)\\n            curr=curr.next\\n        \\n        curr = headB\\n        while curr:\\n            if curr in first_set:\\n                return curr\\n            curr=curr.next\\n\\n        return None\\n```\\n\\n2. ## **Two Pointers**\\n\\nThis is to answer the follow-up question. For this approach, we will initialize two pointers which is pointing to heads of each Linked List. Then we will make these pointers run through both the Linked Lists ie. `n + m` length. By doing so, we will hit an intersection point.\\n\\n**Time - O(n+m)**\\n**Space - O(1)**\\n\\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        one = headA\\n        two = headB\\n\\n        while one != two:\\n            one = headB if one is None else one.next\\n            two = headA if two is None else two.next\\n        return one\\n```\\n\\n\\n**Note:**(*Added this part, as some leetcoders had issues reproducing the inputs locally.*)\\nThe line `one != two` compares the hashes of two objects.  The problem description states that both the inputs have the same tail i.e both LLs merge at some point. This means that `one==two` incase of intersection. So it means `hash(one)==hash(two)`. In your locally created inputs, if you are creating two separate LLs with same values for the tail, It doesn\\'t mean their hashes will be the same.\\n\\n> ListNode(8) != ListNode(8) \\ni.e. hash(ListNode(8)) != hash(ListNode(8))\\ni.e. 284711280 !=284711048. # hash generated from the two objects.\\n\\nFor locally generating the test input, you can do the following:\\n```\\ntail = createLL([8,4,5])\\nheadA=createLL([4, 1])\\nheadB=createLL([5,6,1])\\n\\nlast_nodeA = move_to_lastNode(headA)\\nlast_nodeA.next=tail\\n\\nlast_nodeB = move_to_lastNode(headB)\\nlast_nodeB.next=tail\\n```\\n\\n--- \\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        first_set=set()\\n        curr=headA\\n        \\n        while curr:\\n            first_set.add(curr)\\n            curr=curr.next\\n        \\n        curr = headB\\n        while curr:\\n            if curr in first_set:\\n                return curr\\n            curr=curr.next\\n\\n        return None\\n```\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        one = headA\\n        two = headB\\n\\n        while one != two:\\n            one = headB if one is None else one.next\\n            two = headA if two is None else two.next\\n        return one\\n```\n```\\ntail = createLL([8,4,5])\\nheadA=createLL([4, 1])\\nheadB=createLL([5,6,1])\\n\\nlast_nodeA = move_to_lastNode(headA)\\nlast_nodeA.next=tail\\n\\nlast_nodeB = move_to_lastNode(headB)\\nlast_nodeB.next=tail\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092935,
                "title": "python-short-but-difficult-solution-explained",
                "content": "The idea of solution is the following:\\n1. Calculate lengths of both lists and evaluate difference.\\n2. Make this number of steps for the longest list, pointer `p1` and pointer `p2` put to start of short list.\\n3. Move pointers `p1` and `p2` one by one until we have the same value: it will be either common element or it will be `None` element.\\n\\nSuprasingly all this can be done in one loop: let us look at the line\\n`currB = headA if currB is None else currB.next`. \\nWhat we are doing here is when some list finishes we start to traverse another list. Imagine the case:\\n\\nFirst list has `a` elements before intersection and `b` elements after intersection.\\nSecond list has `c` elements before intersection and `b` elements after intersection, and `c > a`.\\n\\n1. On the first step we will reach end of first list and for the second list we will be `c-a` elements before end.\\n2. On the second step our short list ended, so now we start to traverse long list and after `c-a` steps one of the pointers will be in the beginning of short list and another will be `c-a` steps from the long list.\\n3. Finally, we move both pointers with speed one and either we will have common element or they both reach the end in the same time and in this case they will have common `None` element.\\n\\n**Complexity**: we traverse both lists twice, so we will make no more than `2n + 2m = O(m+n)`. Space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        currA, currB = headA, headB\\n        \\n        while currA != currB:\\n            currB = headA if currB is None else currB.next\\n            currA = headB if currA is None else currA.next\\n            \\n        return currA\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        currA, currB = headA, headB\\n        \\n        while currA != currB:\\n            currB = headA if currB is None else currB.next\\n            currA = headB if currA is None else currA.next\\n            \\n        return currA\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49805,
                "title": "share-my-simple-java-solution-o-n-time-o-1-space",
                "content": "1. Scan both lists\\n2. For each list once it reaches the end, continue scanning the other list\\n3. Once the two runner equal to each other, return the position\\n\\nTime O(n+m), space O(1)\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n    \\t\\tif( null==headA || null==headB )\\n    \\t\\t\\treturn null;\\n    \\t\\t\\n    \\t\\tListNode curA = headA, curB = headB;\\n    \\t\\twhile( curA!=curB){\\n    \\t\\t\\tcurA = curA==null?headB:curA.next;\\n    \\t\\t\\tcurB = curB==null?headA:curB.next;\\n    \\t\\t}\\n    \\t\\treturn curA;\\n        }",
                "solutionTags": [],
                "code": "1. Scan both lists\\n2. For each list once it reaches the end, continue scanning the other list\\n3. Once the two runner equal to each other, return the position\\n\\nTime O(n+m), space O(1)\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n    \\t\\tif( null==headA || null==headB )\\n    \\t\\t\\treturn null;\\n    \\t\\t\\n    \\t\\tListNode curA = headA, curB = headB;\\n    \\t\\twhile( curA!=curB){\\n    \\t\\t\\tcurA = curA==null?headB:curA.next;\\n    \\t\\t\\tcurB = curB==null?headA:curB.next;\\n    \\t\\t}\\n    \\t\\treturn curA;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 49899,
                "title": "c-solution-using-xor-trick",
                "content": "**Graphical explanation**\\n\\nStart from this:\\n\\n           (p) a1 \\u2192 a2\\n                       \\u2198\\n                         X \\u2192 c1 \\u2192 c2\\n                       \\u2197            \\n      (q) b1 \\u2192 b2 \\u2192 b3\\nfollow p, reversing links as you go:\\n\\n              a1 \\u2190 a2\\n                      \\u2196\\n                        X \\u2190 c1 \\u2190 c2 (p)\\n                      \\u2197            \\n     (q) b1 \\u2192 b2 \\u2192 b3\\nnow reverse q:\\n\\n          (q) a1 \\u2192 a2\\n                      \\u2198\\n                        X \\u2190 c1 \\u2190 c2 (p)\\n                      \\u2199            \\n         b1 \\u2190 b2 \\u2190 b3\\nthen reverse p again:\\n\\n          (q) a1 \\u2192 a2\\n                      \\u2198\\n                        X \\u2192 c1 \\u2192 c2\\n                      \\u2197            \\n     (p) b1 \\u2192 b2 \\u2192 b3\\n\\nNotice that p and q are swapped, but the list structure is back to what it was in the beginning.\\n\\nNow the key observation: each node in branches a, b and c has been visited exactly twice, while X has been visited three times. We can thus use the well known trick: we keep an accumulator and XOR it to each address we visit along the way. In the end, the accumulator will contain the address of the only node visited an odd number of times, that is X.\\n\\nWhat if the lists don't meet? In that case we have already reversed p twice, reverting it to its initial state, so we only need to reverse q a second time as well and return null.\\n\\n**Code**\\n\\n\\n    class Solution {\\n        uintptr_t acc = 0;\\n    \\n        ListNode* reverse(ListNode *head) {\\n            ListNode *prev = nullptr, *tmp;\\n            while (head) {\\n                acc ^= reinterpret_cast<uintptr_t> (head);\\n                tmp = head->next;\\n                head->next = prev;\\n                prev = head;\\n                head = tmp;\\n            }\\n            return prev;\\n        }\\n        \\n    public:\\n        ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n            ListNode *p = headA, *q = headB;\\n            p = reverse(p);\\n            q = reverse(q);\\n            p = reverse(p);\\n            if (q != headA) q = reverse(q);\\n            return reinterpret_cast<ListNode*> (acc);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        uintptr_t acc = 0;\\n    \\n        ListNode* reverse(ListNode *head) {\\n            ListNode *prev = nullptr, *tmp;\\n            while (head) {\\n                acc ^= reinterpret_cast<uintptr_t> (head);\\n                tmp = head->next;\\n                head->next = prev;\\n                prev = head;\\n                head = tmp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 49800,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explaination",
                "content": "At the first glance, the problem seems a bit hard for me. Because I have no idea how to locate the meeting point of the 2 different linked-list. After seeing some related implementation. \\nI got the idea and let me explain the details for you:\\nWe set 2 pointers \"curA\" and \"curB\" to point to linked-list headA and headB.\\nThen set the \\n\\n         [#length of linked-list headA]=L1\\n\\n         [#length of linked-list headB]=L2\\n\\n         assuming that L1<L2\\n\\nso, the curA will first move the tail of the headA, we have moved step T=L1\\n\\nby setting the curA to headB we move the curA and the curB at the same time\\n\\n           [#distance-from-curB-to-tail]=L2-L1\\n\\nwhen we move the curB to the tail of the headB then we set the curB to the headA, at the same time, \\n\\n            [#distance-from-headB-to-curA]=L2-L1\\n\\nSo we have the\\n  \\n            [#distance-from-curB-to-meet-point] ==  [#distance-from-curA-to-meet-point]\\n\\nWe just move the curA and curB at the same time, then we get the meeting point .\\n\\nThe only corner cases happen when the 2 linked-list do not meet, so we need to return NULL once the \\n\\n          curA==NULL and curB==NULL before to change the curA and curB\\n\\nHere is my implementation .\\n\\n   \\n\\n     class Solution {\\n        public:\\n            ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n                if(!headA || !headB)    return NULL;\\n                ListNode *curA=headA, *curB=headB;\\n                while(curA && curB){\\n                    if(curA==curB)  return curA;\\n                    curA=curA->next;\\n                    curB=curB->next;\\n                    /*corner cases for my code :\\n                    when the 2 linked-list do not meet, all the 2 pointers will be NULL at the same time.\\n                    the 2 pointers can be NULL at the same time, if we continue processing, the loop will\\n                    never end*/\\n                    if(curA==curB)  return curA;\\n                    if(curA==NULL)  curA=headB;\\n                    if(curB==NULL)  curB=headA;\\n                }\\n                return curA;\\n            }\\n        };\\n\\n\\nPS: This post deserves your up votes !",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n                if(!headA || !headB)    return NULL;\\n                ListNode *curA=headA, *curB=headB;\\n                while(curA && curB){\\n                    if(curA==curB)  return curA;\\n                    curA=curA->next;\\n                    curB=curB->next;\\n                    /*corner cases for my code :\\n                    when the 2 linked-list do not meet, all the 2 pointers will be NULL at the same time.\\n                    the 2 pointers can be NULL at the same time, if we continue processing, the loop will\\n                    never end*/\\n                    if(curA==curB)  return curA;\\n                    if(curA==NULL)  curA=headB;\\n                    if(curB==NULL)  curB=headA;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2116500,
                "title": "c-o-1-space-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* t1=headA;\\n        ListNode* t2=headB;\\n        int l1=1;\\n        int l2=1;\\n        while (t1->next){\\n            l1+=1;\\n            t1=t1->next;\\n        }\\n        while (t2->next){\\n            l2+=1;\\n            t2=t2->next;\\n        }\\n        if (t1!=t2){\\n            return NULL;\\n        }\\n        int move1 = max(0,l1-l2);\\n        int move2 = max(0,l2-l1);\\n        while (move1>0){\\n            headA=headA->next;\\n            move1--;\\n        }\\n        while (move2>0){\\n            headB=headB->next;\\n            move2--;\\n        }\\n        while (headA!=headB){\\n            headB=headB->next;\\n            headA=headA->next;\\n        }\\n        return headA;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/cbc7173a-fa3b-49a8-bece-dded253851ab_1654485855.096025.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* t1=headA;\\n        ListNode* t2=headB;\\n        int l1=1;\\n        int l2=1;\\n        while (t1->next){\\n            l1+=1;\\n            t1=t1->next;\\n        }\\n        while (t2->next){\\n            l2+=1;\\n            t2=t2->next;\\n        }\\n        if (t1!=t2){\\n            return NULL;\\n        }\\n        int move1 = max(0,l1-l2);\\n        int move2 = max(0,l2-l1);\\n        while (move1>0){\\n            headA=headA->next;\\n            move1--;\\n        }\\n        while (move2>0){\\n            headB=headB->next;\\n            move2--;\\n        }\\n        while (headA!=headB){\\n            headB=headB->next;\\n            headA=headA->next;\\n        }\\n        return headA;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49838,
                "title": "5-line-python-solution",
                "content": "\\nHere are my 5 line solution:\\n\\n    def getIntersectionNode(self, headA, headB):\\n        p, q = headA, headB;\\n        while p != q:\\n            p = p.next if p else headB;\\n            q = q.next if q else headA;\\n        return p;",
                "solutionTags": [],
                "code": "\\nHere are my 5 line solution:\\n\\n    def getIntersectionNode(self, headA, headB):\\n        p, q = headA, headB;\\n        while p != q:\\n            p = p.next if p else headB;\\n            q = q.next if q else headA;\\n        return p;",
                "codeTag": "Python3"
            },
            {
                "id": 255597,
                "title": "javascript",
                "content": "```\\nvar getIntersectionNode = function(headA, headB) {\\n    if (!headA || !headB) return null;\\n    var curA = headA;\\n    var curB = headB;\\n    while (curA != curB) {\\n        curA = curA == null ? headB : curA.next;\\n        curB = curB == null ? headA : curB.next;\\n    }\\n    return curA;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getIntersectionNode = function(headA, headB) {\\n    if (!headA || !headB) return null;\\n    var curA = headA;\\n    var curB = headB;\\n    while (curA != curB) {\\n        curA = curA == null ? headB : curA.next;\\n        curB = curB == null ? headA : curB.next;\\n    }\\n    return curA;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 249917,
                "title": "python-two-pointers",
                "content": "Suppose there are two linked lists A and B with an intersection I starting at node X. The length of intersection is L, A\\'s length is L1+L and B\\'s is L2+L.\\nAnd we have two pointers, **a** and **b**, walk through A and B in such way that **a** first walks through A then switch to B while **b** first walks through B then switch to A.\\n\\nIn such manner, when **a** and **b** have walked a distance of L1+L2+L, **a** has walked through |A|+|B-I| (L1+L+L2) and reaches X while **b** has walked through |B|+|A-I| (L2+L+L1) and reaches X as well. Therefore, both **a** and **b** points to the start node of intersection when they first meet each other (a == b).\\n\\nMeanwhile, if A and B has no intersection (L = 0), **a** reaches the end of B and **b** reaches the end of A. Both of them point to None (a==b==None), which is also what to return. So we can combine two cases in such way:\\n```\\ndef getIntersectionNode(headA, headB):\\n\\ta, b = headA, headB\\n\\twhile a != b:\\n\\t\\ta = a.next if a else headB\\n\\t\\tb = b.next if b else headA\\n\\treturn a\\n```\\nThe time complexity is O(L1+L2+L) and space complexity if O(1)",
                "solutionTags": [],
                "code": "```\\ndef getIntersectionNode(headA, headB):\\n\\ta, b = headA, headB\\n\\twhile a != b:\\n\\t\\ta = a.next if a else headB\\n\\t\\tb = b.next if b else headA\\n\\treturn a\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 49913,
                "title": "concise-48ms-c-solution-with-description-and-comment-on-trees",
                "content": "The idea is to first fast forward each pointer to the end to find their distances from the end. Then we can fast forward the farther pointer so they're the same distance from the end. Finally we can fast forward both at the same time until they coincide.\\n\\nThis same exact approach can also be used to find the least common ancestor (LCA) of two nodes in a tree where nodes have parent pointers.\\n\\n    class Solution {\\n    public:\\n        ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n            \\n            auto currA = headA, currB = headB;\\n            int countA = 0, countB = 0;\\n            \\n            while (currA) { \\n                currA = currA->next, countA++;\\n            }\\n            while (currB) {\\n                currB = currB->next, countB++;\\n            }\\n            int diff = std::abs(countA - countB);\\n            if (countB > countA) { swap(headA, headB); }\\n            while (diff--) { \\n                headA = headA->next;\\n            }\\n            while (headA != headB) {\\n                headA = headA->next, headB = headB->next;\\n            }\\n            return headA;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n            \\n            auto currA = headA, currB = headB;\\n            int countA = 0, countB = 0;\\n            \\n            while (currA) { \\n                currA = currA->next, countA++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 50030,
                "title": "my-c-accepted-solution-with-o-n-time-and-o-1-memory-72ms",
                "content": "The main idea of this solution is using the values of the intersecting nodes.\\n\\nFirst, calculate the total amount of value of nodes in listB.\\n\\nSecond, add 1 to all the nodes in listA.\\n\\nThird, re-calculate the total amount of value in listB.\\n\\nIf there exists some nodes intersecting, the re-calculated amount must be different from the previous one, otherwise, there is no any node intersecting. And we can also derive the first intersecting node through the difference between two amounts.\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tmp = headB;\\n        int amoutB = 0,lengthB=0;\\n    \\n        //calculate the amount of values in listB and get the length of listB\\n        while (tmp!=NULL)\\n        {\\n            amoutB += tmp->val;\\n            lengthB ++;\\n            tmp = tmp->next;\\n        }\\n        \\n        //add 1 value to all nodes in listA\\n        tmp = headA;\\n        while (tmp!=NULL)\\n        {\\n            tmp->val++;\\n            tmp = tmp->next;\\n        }\\n        \\n        //re-calculate the amount of values in listB again\\n        tmp = headB;\\n        int newamoutB = 0;\\n        while (tmp!=NULL)\\n        {\\n            newamoutB += tmp->val;\\n            tmp = tmp->next;\\n        }\\n        tmp = headA;\\n    \\n        //subtract 1 from all the nodes in listA\\n        while (tmp!=NULL)\\n        {\\n            tmp->val--;\\n            tmp = tmp->next;\\n        }\\n        \\n        //if two amounts are the same, there is no node intersecting\\n        if(newamoutB==amoutB)\\n           return NULL;\\n        //the difference of two amounts means the number of intersecting nodes, \\n        //we can get the first one by comparing it with number of nodes in listB\\n        else\\n        {\\n            tmp = headB;\\n            for(int i=0; i<lengthB-(newamoutB-amoutB);i++)\\n                tmp = tmp->next;\\n            return tmp;\\n        }\\n    \\n    }",
                "solutionTags": [],
                "code": "The main idea of this solution is using the values of the intersecting nodes.\\n\\nFirst, calculate the total amount of value of nodes in listB.\\n\\nSecond, add 1 to all the nodes in listA.\\n\\nThird, re-calculate the total amount of value in listB.\\n\\nIf there exists some nodes intersecting, the re-calculated amount must be different from the previous one, otherwise, there is no any node intersecting. And we can also derive the first intersecting node through the difference between two amounts.\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tmp = headB;\\n        int amoutB = 0,lengthB=0;\\n    \\n        //calculate the amount of values in listB and get the length of listB\\n        while (tmp!=NULL)\\n        {\\n            amoutB += tmp->val;\\n            lengthB ++;\\n            tmp = tmp->next;\\n        }\\n        \\n        //add 1 value to all nodes in listA\\n        tmp = headA;\\n        while (tmp!=NULL)\\n        {\\n            tmp->val++;\\n            tmp = tmp->next;\\n        }\\n        \\n        //re-calculate the amount of values in listB again\\n        tmp = headB;\\n        int newamoutB = 0;\\n        while (tmp!=NULL)\\n        {\\n            newamoutB += tmp->val;\\n            tmp = tmp->next;\\n        }\\n        tmp = headA;\\n    \\n        //subtract 1 from all the nodes in listA\\n        while (tmp!=NULL)\\n        {\\n            tmp->val--;\\n            tmp = tmp->next;\\n        }\\n        \\n        //if two amounts are the same, there is no node intersecting\\n        if(newamoutB==amoutB)\\n           return NULL;\\n        //the difference of two amounts means the number of intersecting nodes, \\n        //we can get the first one by comparing it with number of nodes in listB\\n        else\\n        {\\n            tmp = headB;\\n            for(int i=0; i<lengthB-(newamoutB-amoutB);i++)\\n                tmp = tmp->next;\\n            return tmp;\\n        }\\n    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1903925,
                "title": "4-approaches-with-optimisation-easy-to-understand",
                "content": "**Approach I - Brute Force**\\n*Time - O(mn),  Space - O(1)*\\n```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        while(headA!=null)\\n        {\\n            ListNode temp = headB;\\n            while(temp!=null)\\n            {\\n                if(temp==headA)\\n                    return headA;\\n                temp = temp.next;\\n            }\\n            headA = headA.next;\\n        }\\n        return null;\\n    }\\n```\\n\\n**Approach II - Using Hashing**\\n*Time - O(m+n),  Space - O(m)*\\n```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        HashSet<ListNode> st=new HashSet<>();\\n        while(headA != null)\\n        {\\n            st.add(headA);\\n            headA = headA.next;\\n        }\\n        \\n        while(headB != null)\\n        {\\n            if(st.contains(headB)) \\n                return headB;\\n            headB = headB.next;\\n        }\\n        return null;\\n    }\\n```\\n\\n**Approach III - (Using difference of length between lists)**\\n*Time - O((m+n)+(l1-l2)+min(m,n),  space - O(1)*\\n```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int l1 = length(headA);\\n        int l2 = length(headB);\\n        int d = 0;\\n        ListNode ptr1;\\n        ListNode ptr2;\\n    \\n        if (l1>l2)\\n        {\\n            d = l1-l2;\\n            ptr1 = headA;\\n            ptr2 = headB;\\n        }\\n        else\\n        {\\n            d = l2-l1;\\n            ptr1 = headB;\\n            ptr2 = headA;\\n        }\\n    \\n        while(d>0)\\n        {\\n            if (ptr1==null)\\n            {\\n                return null;\\n            }\\n            ptr1 = ptr1.next;\\n            d--;\\n        }\\n        while (ptr1!=null && ptr2!=null)\\n        {\\n            if (ptr1==ptr2)\\n                return ptr1;\\n            \\n            ptr1 = ptr1.next;\\n            ptr2 = ptr2.next;\\n        }\\n        return null;\\n    }\\n    \\n    public int length(ListNode head)\\n    {\\n        int i = 0;\\n        while(head!=null)\\n        {\\n            i++;\\n            head = head.next;\\n        }\\n        return i;\\n    }\\n```\\n\\n**Approach IV - Optimised**\\n*Time - O(2max(m,n)),  space - O(1)*\\n```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode d1 = headA, d2 = headB;\\n        while(d1!=d2)\\n        {\\n            if(d1==null)\\n                d1 = headB;\\n            else\\n                d1 = d1.next;\\n            \\n            if(d2==null)\\n                d2 = headA;\\n            else\\n                d2 = d2.next;\\n        }\\n        return d1;\\n    }\\n```\\n*If it helps you, please do upvote\\nHave fun  :)*",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        while(headA!=null)\\n        {\\n            ListNode temp = headB;\\n            while(temp!=null)\\n            {\\n                if(temp==headA)\\n                    return headA;\\n                temp = temp.next;\\n            }\\n            headA = headA.next;\\n        }\\n        return null;\\n    }\\n```\n```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        HashSet<ListNode> st=new HashSet<>();\\n        while(headA != null)\\n        {\\n            st.add(headA);\\n            headA = headA.next;\\n        }\\n        \\n        while(headB != null)\\n        {\\n            if(st.contains(headB)) \\n                return headB;\\n            headB = headB.next;\\n        }\\n        return null;\\n    }\\n```\n```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int l1 = length(headA);\\n        int l2 = length(headB);\\n        int d = 0;\\n        ListNode ptr1;\\n        ListNode ptr2;\\n    \\n        if (l1>l2)\\n        {\\n            d = l1-l2;\\n            ptr1 = headA;\\n            ptr2 = headB;\\n        }\\n        else\\n        {\\n            d = l2-l1;\\n            ptr1 = headB;\\n            ptr2 = headA;\\n        }\\n    \\n        while(d>0)\\n        {\\n            if (ptr1==null)\\n            {\\n                return null;\\n            }\\n            ptr1 = ptr1.next;\\n            d--;\\n        }\\n        while (ptr1!=null && ptr2!=null)\\n        {\\n            if (ptr1==ptr2)\\n                return ptr1;\\n            \\n            ptr1 = ptr1.next;\\n            ptr2 = ptr2.next;\\n        }\\n        return null;\\n    }\\n    \\n    public int length(ListNode head)\\n    {\\n        int i = 0;\\n        while(head!=null)\\n        {\\n            i++;\\n            head = head.next;\\n        }\\n        return i;\\n    }\\n```\n```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode d1 = headA, d2 = headB;\\n        while(d1!=d2)\\n        {\\n            if(d1==null)\\n                d1 = headB;\\n            else\\n                d1 = d1.next;\\n            \\n            if(d2==null)\\n                d2 = headA;\\n            else\\n                d2 = d2.next;\\n        }\\n        return d1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 49924,
                "title": "python-ac-solution-with-clear-explanation",
                "content": "If two linked lists have intersection, we can find two observations:\\n1. They must have same nodes after the intersection point.\\n2. L1+L2 must have same tail from the intersection point as L2 + L1. For example, \\n\\nL1 = 1,2,3 \\nL2 = 6,5,2,3\\n\\nL1+L2 = 1,2,3,6,5,`2,3`\\nL2+L1 = 6,5,2,3,1,`2,3`\\n\\n* To implement L1+L2 as well as L2+L1, we can simply jump to another list's head \\nafter traveling through certain list.\\n* But, you need to notice that if the two lists have no intersection at all, \\nyou should stop after you've already checked L1+L2, so we need a flag `jumpToNext` to ensure we only traverse L1 + L2 once.\\n\\n\\n```python\\n    def getIntersectionNode(self, headA, headB):\\n        ptA, ptB, jumpToNext = headA, headB, False\\n        while ptA and ptB:\\n            if ptA == ptB:\\n                return ptA\\n            ptA, ptB = ptA.next, ptB.next\\n            if not ptA and not jumpToNext:\\n                ptA, jumpToNext = headB, True\\n            if not ptB:\\n                ptB = headA\\n        return None\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def getIntersectionNode(self, headA, headB):\\n        ptA, ptB, jumpToNext = headA, headB, False\\n        while ptA and ptB:\\n            if ptA == ptB:\\n                return ptA\\n            ptA, ptB = ptA.next, ptB.next\\n            if not ptA and not jumpToNext:\\n                ptA, jumpToNext = headB, True\\n            if not ptB:\\n                ptB = headA\\n        return None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2116531,
                "title": "easy-c-solution",
                "content": "The idea here is to traverse both the linked list and find there lengths...\\nWe now know that if the two linked list are equal after some point, there tails are equal and hence after that point, their lengths will also be equal...\\nSo, we traverse the longer linked list, till its length becomes equal to smaller linked list, and then we traverse both the linked list together  and stop when there nodes are equal...\\n\\n**Pls upvote this thread if you found the solution helpful.**\\n\\n![image](https://assets.leetcode.com/users/images/6c6af264-9ff9-444c-b62e-f586d126dfb0_1654486352.7816951.png)\\n\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *a=headA, *b=headB;\\n        int count1=0, count2=0;\\n\\t\\t\\n\\t\\t//counting lengths of both the linked list\\n        for(ListNode *curr=headA;curr!=NULL; curr=curr->next) count1++;\\n        for(ListNode *curr=headB;curr!=NULL; curr=curr->next) count2++;\\n        \\n\\t\\t//If linked list 1 is longer, we traverse it, till it becomes equal to length of second...\\n        while(count1>count2) {\\n            count1--;\\n            a=a->next;\\n        }\\n        \\n\\t\\t//If second one is longer, we traverse it, till it becomes equal to length of first...\\n        while(count2>count1) {\\n            count2--;\\n            b=b->next;\\n        }\\n        \\n\\t\\t//Since length of both is now equal, we traverse them together, and break if the nodes become equal...\\n        while(a!=b) {\\n            a=a->next;\\n            b=b->next;\\n        }\\n        \\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *a=headA, *b=headB;\\n        int count1=0, count2=0;\\n\\t\\t\\n\\t\\t//counting lengths of both the linked list\\n        for(ListNode *curr=headA;curr!=NULL; curr=curr->next) count1++;\\n        for(ListNode *curr=headB;curr!=NULL; curr=curr->next) count2++;\\n        \\n\\t\\t//If linked list 1 is longer, we traverse it, till it becomes equal to length of second...\\n        while(count1>count2) {\\n            count1--;\\n            a=a->next;\\n        }\\n        \\n\\t\\t//If second one is longer, we traverse it, till it becomes equal to length of first...\\n        while(count2>count1) {\\n            count2--;\\n            b=b->next;\\n        }\\n        \\n\\t\\t//Since length of both is now equal, we traverse them together, and break if the nodes become equal...\\n        while(a!=b) {\\n            a=a->next;\\n            b=b->next;\\n        }\\n        \\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49902,
                "title": "java-beats-99-56",
                "content": "    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode p1 = headA, p2 = headB;\\n        int len1 = 0, len2 = 0;\\n        while (p1 != null) {\\n            p1 = p1.next;\\n            len1++;\\n        }\\n        while (p2 != null) {\\n            p2 = p2.next;\\n            len2++;\\n        }\\n        p1 = headA;\\n        p2 = headB;\\n        if (len1 > len2) {\\n            for (int i = 0;i < len1 - len2; i++) {\\n                p1 = p1.next;\\n            }\\n        } else {\\n            for (int i = 0;i < len2 - len1; i++) {\\n                p2 = p2.next;\\n            }\\n        }\\n        while (p1 != p2) {\\n            p1 = p1.next;\\n            p2 = p2.next;\\n        }\\n        return p1;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode p1 = headA, p2 = headB;\\n        int len1 = 0, len2 = 0;\\n        while (p1 != null) {\\n            p1 = p1.next;\\n            len1++;\\n        }\\n        while (p2 != null) {\\n            p2 = p2.next;\\n            len2++;\\n        }\\n        p1 = headA;\\n        p2 = headB;\\n        if (len1 > len2) {\\n            for (int i = 0;i < len1 - len2; i++) {\\n                p1 = p1.next;\\n            }\\n        } else {\\n            for (int i = 0;i < len2 - len1; i++) {\\n                p2 = p2.next;\\n            }\\n        }\\n        while (p1 != p2) {\\n            p1 = p1.next;\\n            p2 = p2.next;\\n        }\\n        return p1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1093051,
                "title": "intersection-of-two-linked-lists-c-o-1-space-short-concise",
                "content": "## Solution - I\\nIf the length of linked lists had been the same, finding the intersection node would be as easy as iterating over both linked list simultaneously and returning if same node is found. \\n\\nIn the given question, however, we need to first align the lists. The head of list with greater length need to be iterated forward `diff`(difference of lengths) number of times and the final answer won\\'t be affected by this since length of list after intersection must be same(meaning intersection surely wouldn\\'t exist in the first `diff` nodes) . This way, we can parallelly compare nodes of both list and return if two nodes match.\\n```\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\tint n1 = 0, n2 = 0;\\n\\tListNode* a = headA, *b = headB;\\n\\twhile(a)\\n\\t\\tn1++, a = a -> next;\\n\\twhile(b)\\n\\t\\tn2++, b = b -> next;\\n\\ta = headA, b = headB;\\n\\twhile(a && n1 > n2)\\n\\t\\ta = a -> next, n1--;\\n\\twhile(b && n2 > n1)\\n\\t\\tb = b -> next, n2--;\\n\\twhile(a && b)\\n\\t\\tif(a == b)\\n\\t\\t\\treturn a;\\n\\t\\telse a = a -> next, b = b -> next;\\n\\treturn NULL;\\n}\\n```\\n\\n---------------\\n## Solution - II\\nInfact, we don\\'t need to find `diff` and iterate the greater length list. Instead, if we reach the end of a list, just restart from the head of other list. This can help up counter the difference of lengths. Finally, the lists will either converge on intersected node or both will reach end at same time and we will return `NULL` at last. \\n\\n* For eg. Lists having intersected node (**Example 1** from description) -\\n\\t```\\n\\tA : 4 -> 1 -> 8 -> 4 -> 5 |  5 -> 6 -> 1 -> 8 <- same node found\\n\\t\\t\\t\\t\\t\\t\\t  ^end(restart from B)\\n\\tB : 5 -> 6 -> 1 -> 8 -> 4 -> 5 |  4 -> 1 -> 8 <- same node found\\n\\t\\t\\t\\t\\t\\t\\t\\t   ^end(restart from A)\\n\\treturn since we found the same node\\n\\t```\\n\\t*NOTE : In the above example, we compared 1(from **A**) and 1(from **B**) but didnt return it since their memory addresses didn\\'t match. We are comparing a == b, and not a->val == b->val.*\\n\\t\\n* Lists having no intersected node (**Example 3** from description)-\\n\\t```\\n\\tA : 2 -> 6 -> 4 |  1 -> 2 |   <- both reach NULL at same time, hence no intersection.\\n\\t\\t\\t\\t\\t^end      ^end\\n\\tB : 1 -> 2 |  2 -> 6 -> 4 |   <- both reach NULL at same time, no intersection\\n\\t\\t\\t   ^end           ^end\\n\\t```\\nThe implementation for the same is given below :\\n```\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {        \\n    ListNode* a = headA, *b = headB;\\n    while(a != b)\\n        a = a ? a -> next : headB, b = b ? b -> next : headA;\\n    return a;\\n}\\n```\\n**Time Complexity** : **`O(N)`**, where `N` is the sum of length of both the linked lists. Since `N1+N2` == `N2+N1`, the pointers would restart atmost 1 time each. The worst case would occur when both lengths are unequal and they don\\'t have any intersection.\\n**Space Complexity** : **`O(1)`**, since only constant space is used.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\tint n1 = 0, n2 = 0;\\n\\tListNode* a = headA, *b = headB;\\n\\twhile(a)\\n\\t\\tn1++, a = a -> next;\\n\\twhile(b)\\n\\t\\tn2++, b = b -> next;\\n\\ta = headA, b = headB;\\n\\twhile(a && n1 > n2)\\n\\t\\ta = a -> next, n1--;\\n\\twhile(b && n2 > n1)\\n\\t\\tb = b -> next, n2--;\\n\\twhile(a && b)\\n\\t\\tif(a == b)\\n\\t\\t\\treturn a;\\n\\t\\telse a = a -> next, b = b -> next;\\n\\treturn NULL;\\n}\\n```\n```\\n\\tA : 4 -> 1 -> 8 -> 4 -> 5 |  5 -> 6 -> 1 -> 8 <- same node found\\n\\t\\t\\t\\t\\t\\t\\t  ^end(restart from B)\\n\\tB : 5 -> 6 -> 1 -> 8 -> 4 -> 5 |  4 -> 1 -> 8 <- same node found\\n\\t\\t\\t\\t\\t\\t\\t\\t   ^end(restart from A)\\n\\treturn since we found the same node\\n\\t```\n```\\n\\tA : 2 -> 6 -> 4 |  1 -> 2 |   <- both reach NULL at same time, hence no intersection.\\n\\t\\t\\t\\t\\t^end      ^end\\n\\tB : 1 -> 2 |  2 -> 6 -> 4 |   <- both reach NULL at same time, no intersection\\n\\t\\t\\t   ^end           ^end\\n\\t```\n```\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {        \\n    ListNode* a = headA, *b = headB;\\n    while(a != b)\\n        a = a ? a -> next : headB, b = b ? b -> next : headA;\\n    return a;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2918847,
                "title": "easiest-faang-method-ever",
                "content": "## ***Please go through the entire solution video and solution carefully. It is very easy to understand for beginners too :)***\\n#### **Please do Upvote if it helps\\uD83D\\uDE4F**\\n# \\uD83D\\uDCCCIntuition :-\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://www.youtube.com/watch?v=u4FWXfgS8jw&list=PLgUwDviBIf0p4ozDR_kJJkONnb1wdx2Ma&index=34\\n\\n**Thanks to Striver and TUF \\u2764\\uFE0F**\\n\\n#### **Please do Upvote if it helps\\uD83D\\uDE4F**\\n\\n# \\uD83D\\uDCCCApproach :-\\n### 1) Bruteforce - O(n^2)\\n### 2) Approach-2 [Using Hashing we store address of each node and find common addresses b/w 2 linked lists]\\n### 3) Optimal Approach - 1 [TC:O(2n) SC:O(1), Longer code length]\\n##### \\uD83D\\uDD38 Find Lengths of both linked list.\\n##### \\uD83D\\uDD38 Move linked list with longer size to make the distance to intersection same.\\n##### \\uD83D\\uDD38 Loop till intersection.\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n       if(!headA || !headB) \\n            return 0;\\n        ListNode *a=headA;\\n        ListNode *b=headB;\\n        int count1=0,count2=0;\\n        while(a){\\n            a=a->next;\\n            count1++;\\n        }\\n        while(b){\\n            b=b->next;\\n            count2++;\\n        }\\n        ListNode *t1=headA;\\n        ListNode *t2=headB;\\n        int diff=abs(count1-count2);\\n        if(count1>count2){\\n            while(diff!=0){\\n                t1=t1->next;\\n                diff--;\\n            }\\n        }\\n        else{\\n            while(diff!=0){\\n                t2=t2->next;\\n                diff--;\\n            }\\n        }\\n\\n        while(t1!=t2){\\n            t1=t1->next;\\n            t2=t2->next;\\n        }\\n        return t1;\\n    }\\n};\\n```\\n### 3) Optimal Approach - 2 [TC:O(2n) SC:O(1), Short crisp code]\\n##### \\uD83D\\uDD38Loop through both linked lists.\\n##### \\uD83D\\uDD38 As soon as any pointer reaches NULL, make it loop through the second linked list. Move each pointer by one node at a time. This covers the difference in size b/w 2 linked list.\\n##### \\uD83D\\uDD38 Loop till both pointers become equal.\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n       if(!headA || !headB) \\n            return 0;\\n        ListNode *a=headA;\\n        ListNode *b=headB;\\n\\n        while(a!=b)    {\\n            a=a==NULL?headB:a->next;\\n            b=b==NULL?headA:b->next;\\n        }\\n        return a;\\n    }\\n};\\n```\\n## **Please do Upvote if it helps\\uD83D\\uDE4F**\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n       if(!headA || !headB) \\n            return 0;\\n        ListNode *a=headA;\\n        ListNode *b=headB;\\n        int count1=0,count2=0;\\n        while(a){\\n            a=a->next;\\n            count1++;\\n        }\\n        while(b){\\n            b=b->next;\\n            count2++;\\n        }\\n        ListNode *t1=headA;\\n        ListNode *t2=headB;\\n        int diff=abs(count1-count2);\\n        if(count1>count2){\\n            while(diff!=0){\\n                t1=t1->next;\\n                diff--;\\n            }\\n        }\\n        else{\\n            while(diff!=0){\\n                t2=t2->next;\\n                diff--;\\n            }\\n        }\\n\\n        while(t1!=t2){\\n            t1=t1->next;\\n            t2=t2->next;\\n        }\\n        return t1;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n       if(!headA || !headB) \\n            return 0;\\n        ListNode *a=headA;\\n        ListNode *b=headB;\\n\\n        while(a!=b)    {\\n            a=a==NULL?headB:a->next;\\n            b=b==NULL?headA:b->next;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 403600,
                "title": "python-clean-solution",
                "content": "[**Python Data Structures and algorithms**](https://github.com/tamudashe/Python-Data-Structures-and-Algorithms.git)\\n\\n* Time comlexity: O(m + n)\\n*  Space complecity : O(1)\\n\\n```\\ndef getIntersectionNode(headA, headB):\\n        a_pointer, b_pointer = headA, headB\\n        while a_pointer != b_pointer:\\n            a_pointer = a_pointer.next if a_pointer else headB\\n            b_pointer = b_pointer.next if b_pointer else headA\\n        return a_pointer\\n```",
                "solutionTags": [],
                "code": "```\\ndef getIntersectionNode(headA, headB):\\n        a_pointer, b_pointer = headA, headB\\n        while a_pointer != b_pointer:\\n            a_pointer = a_pointer.next if a_pointer else headB\\n            b_pointer = b_pointer.next if b_pointer else headA\\n        return a_pointer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3417354,
                "title": "c-java-python-javascript-hash-table-of-linked-list",
                "content": "# Intuition:\\nThe problem is to find the intersection node of two linked lists. A brute-force approach would be to traverse both the linked lists and compare each node of the first linked list with every node of the second linked list. But this approach would take O(n^2) time complexity. A better approach would be to use a hash table (unordered_set) to store the nodes of the first linked list, and then traverse the second linked list, checking if any of its nodes are already present in the hash table. If yes, then it is the intersection node.\\n\\n# Approach:\\n\\n1. Create an unordered_set of ListNode* type to store the nodes of the first linked list.\\n2. Traverse the first linked list (headA), and insert each node into the unordered_set.\\n3. Traverse the second linked list (headB), and for each node, check if it is present in the unordered_set. If yes, return the node.\\n4. If the end of the second linked list is reached, and no intersection node is found, return NULL.\\n# Complexity:\\n- Time complexity: O(m+n), where m and n are the lengths of the two linked lists. We traverse each linked list once, and the unordered_set lookup operation takes O(1) time.\\n- Space complexity: O(m), where m is the length of the first linked list. We store the nodes of the first linked list in an unordered_set.\\n\\n---\\n\\n\\n# C++\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_set<ListNode *> st;\\n        while(headA != NULL) {\\n        st.insert(headA);\\n        headA = headA->next;\\n        }\\n        while(headB != NULL) {\\n            if(st.find(headB) != st.end()) return headB;\\n            headB = headB->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n\\n---\\n# JavaScript\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} headA\\n * @param {ListNode} headB\\n * @return {ListNode}\\n */\\nvar getIntersectionNode = function(headA, headB) {\\n    let set = new Set();\\n    while(headA) {\\n        set.add(headA);\\n        headA = headA.next;\\n    }\\n    while(headB) {\\n        if(set.has(headB)) return headB;\\n        headB = headB.next;\\n    }\\n    return null;\\n};\\n\\n```\\n\\n---\\n# JAVA\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        Set<ListNode> set = new HashSet<>();\\n        while(headA != null) {\\n            set.add(headA);\\n            headA = headA.next;\\n        }\\n        while(headB != null) {\\n            if(set.contains(headB)) return headB;\\n            headB = headB.next;\\n        }\\n        return null;\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        \"\"\"\\n        :type head1, head1: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        st = set()\\n        while headA:\\n            st.add(headA)\\n            headA = headA.next\\n        while headB:\\n            if headB in st:\\n                return headB\\n            headB = headB.next\\n        return None\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_set<ListNode *> st;\\n        while(headA != NULL) {\\n        st.insert(headA);\\n        headA = headA->next;\\n        }\\n        while(headB != NULL) {\\n            if(st.find(headB) != st.end()) return headB;\\n            headB = headB->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} headA\\n * @param {ListNode} headB\\n * @return {ListNode}\\n */\\nvar getIntersectionNode = function(headA, headB) {\\n    let set = new Set();\\n    while(headA) {\\n        set.add(headA);\\n        headA = headA.next;\\n    }\\n    while(headB) {\\n        if(set.has(headB)) return headB;\\n        headB = headB.next;\\n    }\\n    return null;\\n};\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        Set<ListNode> set = new HashSet<>();\\n        while(headA != null) {\\n            set.add(headA);\\n            headA = headA.next;\\n        }\\n        while(headB != null) {\\n            if(set.contains(headB)) return headB;\\n            headB = headB.next;\\n        }\\n        return null;\\n    }\\n}\\n\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        \"\"\"\\n        :type head1, head1: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        st = set()\\n        while headA:\\n            st.add(headA)\\n            headA = headA.next\\n        while headB:\\n            if headB in st:\\n                return headB\\n            headB = headB.next\\n        return None\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1093186,
                "title": "python-magic-solution-o-n-time-o-1-solution",
                "content": "```\\nclass Solution:\\n    def changeSign(self, head: ListNode):\\n        while ( head ):\\n            head.val *= -1\\n            head = head.next\\n    \\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        self.changeSign(headA)\\n        \\n        while ( headB ):\\n            if headB.val < 0:break\\n            headB = headB.next\\n        \\n        self.changeSign(headA)\\n        return headB",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def changeSign(self, head: ListNode):\\n        while ( head ):\\n            head.val *= -1\\n            head = head.next\\n    \\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        self.changeSign(headA)\\n        \\n        while ( headB ):\\n            if headB.val < 0:break\\n            headB = headB.next\\n        \\n        self.changeSign(headA)\\n        return headB",
                "codeTag": "Java"
            },
            {
                "id": 49938,
                "title": "python-solution-o-n-time-and-o-1-space",
                "content": "This problem could be considered as the derivation of linked list cycle. \\nLet say there are two linked lists named l1 and l2. And h1 and t1 are the head and last nodes of l1 respectively, and h2 is the head node of l2.\\n\\n1. Concat h1 and t1\\n2. Check whether there exists a cycle of linked list l2.\\n3. Find that intersection if 2 is a truth.\\n\\nBefore doing the above steps, there are two linked lists in the picture:\\n![enter image description here][1]\\n\\nAfter step 1:\\n![enter image description here][2]\\n\\nThen let's try to make the linked lists easier to understood.\\n![enter image description here][3]\\nNode 8 is what we want.  We can use then solve it by finding the start node of the cycle like the problem \"linked list cycle II\"\\n\\nHere is my code:\\n\\n\\tdef getIntersectionNode(self, headA, headB):\\n\\t\\t\"\"\"\\n\\t\\t:type head1, head1: ListNode\\n\\t\\t:rtype: ListNode\\n\\t\\t\"\"\" \\n\\t\\tif not headA or not headB: return None\\n\\t\\t\\n\\t\\tp = headA\\n\\t\\twhile p.next:\\n\\t\\t\\tp = p.next\\n\\t\\tmark = p\\n\\t\\t#make a cycled list\\n\\t\\tmark.next = headA\\n\\t\\t\\n\\t\\trst = None\\n\\t\\tp1 = headB\\n\\t\\tp2 = headB\\n\\t\\twhile p1 and p2:\\n\\t\\t\\tp1 = p1.next\\n\\t\\t\\tp2 = p2.next\\n\\t\\t\\tif p2: p2 = p2.next\\n\\t\\t\\tif p1 == p2: break\\n\\n\\t\\tif p1 and p2 and p1 == p2:\\n\\t\\t\\tp1 = headB\\n\\t\\t\\twhile p1 != p2:\\n\\t\\t\\t\\tp1 = p1.next\\n\\t\\t\\t\\tp2 = p2.next\\n\\t\\t\\trst = p1\\n\\n\\t\\t#unmake the cycle\\n\\t\\tmark.next = None\\n\\n\\t\\treturn rst\\n\\n\\n  [1]: http://b52.imgup.net/original15aa.jpg\\n  [2]: http://h04.imgup.net/concatedfe73.jpg\\n  [3]: http://g12.imgup.net/understood69a3.jpg",
                "solutionTags": [],
                "code": "This problem could be considered as the derivation of linked list cycle. \\nLet say there are two linked lists named l1 and l2. And h1 and t1 are the head and last nodes of l1 respectively, and h2 is the head node of l2.\\n\\n1. Concat h1 and t1\\n2. Check whether there exists a cycle of linked list l2.\\n3. Find that intersection if 2 is a truth.\\n\\nBefore doing the above steps, there are two linked lists in the picture:\\n![enter image description here][1]\\n\\nAfter step 1:\\n![enter image description here][2]\\n\\nThen let's try to make the linked lists easier to understood.\\n![enter image description here][3]\\nNode 8 is what we want.  We can use then solve it by finding the start node of the cycle like the problem \"linked list cycle II\"\\n\\nHere is my code:\\n\\n\\tdef getIntersectionNode(self, headA, headB):\\n\\t\\t\"\"\"\\n\\t\\t:type head1, head1: ListNode\\n\\t\\t:rtype: ListNode\\n\\t\\t\"\"\" \\n\\t\\tif not headA or not headB: return None\\n\\t\\t\\n\\t\\tp = headA\\n\\t\\twhile p.next:\\n\\t\\t\\tp = p.next\\n\\t\\tmark = p\\n\\t\\t#make a cycled list\\n\\t\\tmark.next = headA\\n\\t\\t\\n\\t\\trst = None\\n\\t\\tp1 = headB\\n\\t\\tp2 = headB\\n\\t\\twhile p1 and p2:\\n\\t\\t\\tp1 = p1.next\\n\\t\\t\\tp2 = p2.next\\n\\t\\t\\tif p2: p2 = p2.next\\n\\t\\t\\tif p1 == p2: break\\n\\n\\t\\tif p1 and p2 and p1 == p2:\\n\\t\\t\\tp1 = headB\\n\\t\\t\\twhile p1 != p2:\\n\\t\\t\\t\\tp1 = p1.next\\n\\t\\t\\t\\tp2 = p2.next\\n\\t\\t\\trst = p1\\n\\n\\t\\t#unmake the cycle\\n\\t\\tmark.next = None\\n\\n\\t\\treturn rst\\n\\n\\n  [1]: http://b52.imgup.net/original15aa.jpg\\n  [2]: http://h04.imgup.net/concatedfe73.jpg\\n  [3]: http://g12.imgup.net/understood69a3.jpg",
                "codeTag": "Python3"
            },
            {
                "id": 49925,
                "title": "java-o-n-time-o-1-space-solution-by-using-assume-there-are-no-cycles",
                "content": "As a reminder:\\n\\n    A:         a1 \\u2192 a2\\n                       \\u2198\\n                         c1 \\u2192 c2 \\u2192 c3\\n                       \\u2197            \\n    B:    b1 \\u2192 b2 \\u2192 b3\\n\\nBased on this I construct a structure that has a cycle in it:\\n\\n    A:         a1 \\u2192 a2\\n                       \\u2198\\n                         c1 \\u2192 c2 \\u2192 c3 \\\\\\n                       \\u2197              |\\n    B:    b1 \\u2192 b2 \\u2192 b3                /\\n            \\u2196------------------------\\n\\nThen starting from `a1` I try to find a cycle (`fast` iterator would wrap around to itself [`slow`]).\\nIf that's found the take some steps until the starting point is found.  \\n(A good explanation of this can be found [here](http://learningarsenal.info/index.php/2015/08/24/detecting-start-of-a-loop-in-singly-linked-list/))\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\t\\tif (headA == null || headB == null) return null;\\n\\t\\t// find last node of list A (c3)\\n\\t\\tListNode endA = headA;\\n\\t\\twhile (endA.next != null) {\\n\\t\\t\\tendA = endA.next;\\n\\t\\t}\\n\\t\\t// join c3 to b1 making a c1...c3-b1...b3-c1 loop (if b3 indeed points to c1)\\n\\t\\tendA.next = headB;\\n\\n\\t\\tListNode start = null; // if there's no cycle this will stay null\\n\\t\\t// Floyd's cycle finder\\n\\t\\tListNode slow = headA, fast = headA;\\n\\t\\twhile (fast != null && fast.next != null) {\\n\\t\\t\\tslow = slow.next;\\n\\t\\t\\tfast = fast.next.next;\\n\\t\\t\\tif (slow == fast) { // found a cycle\\n\\t\\t\\t\\t// reset to beginning to find cycle start point (c1)\\n\\t\\t\\t\\tstart = headA;\\n\\t\\t\\t\\twhile (slow != start) {\\n\\t\\t\\t\\t\\tslow = slow.next;\\n\\t\\t\\t\\t\\tstart = start.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// unjoin c3-b1\\n\\t\\tendA.next = null;\\n\\t\\treturn start;\\n    }\\n\\nIf there's no cycle it simply concats `B` after `A` and traverese to the end via the `fast` pointer.",
                "solutionTags": [
                    "Java"
                ],
                "code": "As a reminder:\\n\\n    A:         a1 \\u2192 a2\\n                       \\u2198\\n                         c1 \\u2192 c2 \\u2192 c3\\n                       \\u2197            \\n    B:    b1 \\u2192 b2 \\u2192 b3\\n\\nBased on this I construct a structure that has a cycle in it:\\n\\n    A:         a1 \\u2192 a2\\n                       \\u2198\\n                         c1 \\u2192 c2 \\u2192 c3 \\\\\\n                       \\u2197              |\\n    B:    b1 \\u2192 b2 \\u2192 b3                /\\n            \\u2196------------------------\\n\\nThen starting from `a1` I try to find a cycle (`fast` iterator would wrap around to itself [`slow`]).\\nIf that's found the take some steps until the starting point is found.  \\n(A good explanation of this can be found [here](http://learningarsenal.info/index.php/2015/08/24/detecting-start-of-a-loop-in-singly-linked-list/))\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\t\\tif (headA == null || headB == null) return null;\\n\\t\\t// find last node of list A (c3)\\n\\t\\tListNode endA = headA;\\n\\t\\twhile (endA.next != null) {\\n\\t\\t\\tendA = endA.next;\\n\\t\\t}\\n\\t\\t// join c3 to b1 making a c1...c3-b1...b3-c1 loop (if b3 indeed points to c1)\\n\\t\\tendA.next = headB;\\n\\n\\t\\tListNode start = null; // if there's no cycle this will stay null\\n\\t\\t// Floyd's cycle finder\\n\\t\\tListNode slow = headA, fast = headA;\\n\\t\\twhile (fast != null && fast.next != null) {\\n\\t\\t\\tslow = slow.next;\\n\\t\\t\\tfast = fast.next.next;\\n\\t\\t\\tif (slow == fast) { // found a cycle\\n\\t\\t\\t\\t// reset to beginning to find cycle start point (c1)\\n\\t\\t\\t\\tstart = headA;\\n\\t\\t\\t\\twhile (slow != start) {\\n\\t\\t\\t\\t\\tslow = slow.next;\\n\\t\\t\\t\\t\\tstart = start.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// unjoin c3-b1\\n\\t\\tendA.next = null;\\n\\t\\treturn start;\\n    }\\n\\nIf there's no cycle it simply concats `B` after `A` and traverese to the end via the `fast` pointer.",
                "codeTag": "Unknown"
            },
            {
                "id": 50020,
                "title": "stupid-and-short-c-solution-without-any-list-cycles-o-n-time-o-1-memory",
                "content": "Just  store addition information in 'next' pointers.\\nIt's work because memory alignment\\n\\n    \\x01ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        for (ListNode *cur = headA; cur;) {\\n            unsigned long *ptr = (unsigned long *)&cur->next;\\n            cur = cur->next;\\n            *ptr |= 1;\\n        }\\n    \\n        ListNode *result = nullptr;\\n        for (ListNode *cur = headB; cur; cur = cur->next) {\\n            unsigned long ptr = (unsigned long)cur->next;\\n            if (ptr & 1) {\\n                result = cur;\\n                break;\\n            }\\n        }\\n        \\n        for (ListNode *cur = headA; cur; cur = cur->next) {\\n            unsigned long *ptr = (unsigned long *)&cur->next;\\n            *ptr &= (~0ULL << 1);\\n        }\\n    \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "Just  store addition information in 'next' pointers.\\nIt's work because memory alignment\\n\\n    \\x01ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        for (ListNode *cur = headA; cur;) {\\n            unsigned long *ptr = (unsigned long *)&cur->next;\\n            cur = cur->next;\\n            *ptr |= 1;\\n        }\\n    \\n        ListNode *result = nullptr;\\n        for (ListNode *cur = headB; cur; cur = cur->next) {\\n            unsigned long ptr = (unsigned long)cur->next;\\n            if (ptr & 1) {\\n                result = cur;\\n                break;\\n            }\\n        }\\n        \\n        for (ListNode *cur = headA; cur; cur = cur->next) {\\n            unsigned long *ptr = (unsigned long *)&cur->next;\\n            *ptr &= (~0ULL << 1);\\n        }\\n    \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1093063,
                "title": "c-flipping-vs-tortoise-hare-solutions-compared-100-time-90-space",
                "content": "My first approach for this problem was relatively straightforward: we pass the first list completely flipping the values (guaranteed to be `> 0`: again - reading each single line of the specs is the key to win!) to be negative.\\n\\nWe then run through `headB` and stop at the first negative value; finally, to leave the first list as it was before, we flip all of its elements again and we are done :)\\n\\nTo do so we need only one extra variable: `originalHeadA` that will store, as its name implies, the initial value of `headA`.\\n\\nWe will then trivially do the flipping with a loop that will run as long as `headA != NULL`.\\n\\nIn the second loop, structured with a similar logic (it will run as long as `headB != NULL`), we do nothing but advancing the pointer, provided its value is not negative, in which case we `break` out of the loop. Notice that if we reach the end of the line without a match, that is still good for us, since we `headB` will be `NULL`, which is precisely what we are supposed to return in case of no matches.\\n\\nOne last loop specular to the first one, just after we reset `headA` to its original value and we can then finally return `headB` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        // support variables\\n        ListNode *originalHeadA = headA;\\n        // flipping headA\\n        while (headA) {\\n            headA->val *= -1;\\n            headA = headA->next;\\n        }\\n        // parsing headB\\n        while (headB) {\\n            if (headB->val < 0) {\\n                break;\\n            }\\n            headB = headB->next;\\n        }\\n        // flipping headA back to the original values\\n        headA = originalHeadA;\\n        while (headA) {\\n            headA->val *= -1;\\n            headA = headA->next;\\n        }\\n        return headB;\\n    }\\n};\\n```\\n\\nThe second approach I wanted to try was a [tortoise and hare](https://en.wikipedia.org/wiki/Cycle_detection)-like one; I am fully aware that the traditional one has 2 pointers proceeding at different speeds, typically to find cycles, but I guess it is not too much of a stretch to call my solution a derivative of it.\\n\\nTo do so, we declare both `originalHeadA` and `originalHeadB` to store the initial values and then proceed with a single loop that goes on as long as `headA` and `headB` are not both `NULL` in which we will:\\n* first of all, check if there is a match, in which case we return one of the pointers;\\n* check if we need to reset `headA` to its initial value or just advance it;\\n* check if we need to reset `headB` to its initial value or just advance it.\\n\\nIf out of the loop, we still return `headB` as above, fully knowing it is `NULL`.\\n\\nThe code, which takes a very long time, about 10-12X the previous solution (as you might guess: think of 2 lists with lengths that are coprime of each other, so you will have to run the loop the product of their lengths time):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        // support variables\\n        ListNode *originalHeadA = headA,  *originalHeadB = headB;\\n        // turtle headA vs hare headB\\n        while (headA || headB) {\\n            // checking if a match is found\\n            if (headA == headB) return headB;\\n            // resetting or advancing A and B as needed\\n            if (!headA) headA = originalHeadA;\\n            else headA = headA->next;\\n            if (!headB) headB = originalHeadB;\\n            else headB = headB->next;\\n        }\\n        return headB;\\n    }\\n};\\n```\\n\\nCan we do better?\\n\\nWell, turn out that a smarter way to reset the pointers is to swap the values, so that if you have one which is significantly longer than the other, you will not be bound by that.\\n\\nI know, it is not super-intuitive, but if you try to run it with a few `cout`s or just on pen and paper, it should make more sense.\\n\\nYou might see for example how running it on 2 lists `[1,2,3,4,5]` and `[7,6,5]` converging at `5` is more expensive with the previous version of the code, since it keeps repeating the loop longer restarting the longer lists.\\n\\nThe updated code, which runs now at a speed comparable with the first solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        // support variables\\n        ListNode *originalHeadA = headA,  *originalHeadB = headB;\\n        // turtle headA vs hare headB\\n        while (headA || headB) {\\n            // checking if a match is found\\n            if (headA == headB) return headB;\\n            // resetting or advancing A and B as needed\\n            if (!headA) headA = originalHeadB;\\n            else headA = headA->next;\\n            if (!headB) headB = originalHeadA;\\n            else headB = headB->next;\\n        }\\n        return headB;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        // support variables\\n        ListNode *originalHeadA = headA;\\n        // flipping headA\\n        while (headA) {\\n            headA->val *= -1;\\n            headA = headA->next;\\n        }\\n        // parsing headB\\n        while (headB) {\\n            if (headB->val < 0) {\\n                break;\\n            }\\n            headB = headB->next;\\n        }\\n        // flipping headA back to the original values\\n        headA = originalHeadA;\\n        while (headA) {\\n            headA->val *= -1;\\n            headA = headA->next;\\n        }\\n        return headB;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        // support variables\\n        ListNode *originalHeadA = headA,  *originalHeadB = headB;\\n        // turtle headA vs hare headB\\n        while (headA || headB) {\\n            // checking if a match is found\\n            if (headA == headB) return headB;\\n            // resetting or advancing A and B as needed\\n            if (!headA) headA = originalHeadA;\\n            else headA = headA->next;\\n            if (!headB) headB = originalHeadB;\\n            else headB = headB->next;\\n        }\\n        return headB;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        // support variables\\n        ListNode *originalHeadA = headA,  *originalHeadB = headB;\\n        // turtle headA vs hare headB\\n        while (headA || headB) {\\n            // checking if a match is found\\n            if (headA == headB) return headB;\\n            // resetting or advancing A and B as needed\\n            if (!headA) headA = originalHeadB;\\n            else headA = headA->next;\\n            if (!headB) headB = originalHeadA;\\n            else headB = headB->next;\\n        }\\n        return headB;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532898,
                "title": "c-tricky-solution",
                "content": "**C :**\\n\\n```\\nvoid changeSign(struct ListNode *head)\\n{\\n    while (head)\\n    {\\n        head -> val *= -1;\\n        head = head -> next;\\n    }\\n}\\n\\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n    changeSign(headA);\\n    \\n    while(headB)\\n    {\\n        if(headB -> val < 0) break;\\n        headB = headB -> next;\\n    }\\n    \\n    changeSign(headA);\\n    return headB;\\n    \\n}\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid changeSign(struct ListNode *head)\\n{\\n    while (head)\\n    {\\n        head -> val *= -1;\\n        head = head -> next;\\n    }\\n}\\n\\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n    changeSign(headA);\\n    \\n    while(headB)\\n    {\\n        if(headB -> val < 0) break;\\n        headB = headB -> next;\\n    }\\n    \\n    changeSign(headA);\\n    return headB;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1093183,
                "title": "c-magic-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\nprivate:\\n    void changeSign(ListNode *head){\\n        while ( head )\\n        {\\n            head->val *= -1;\\n            head = head->next;\\n        }\\n    }\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        changeSign( headA );\\n        \\n        while ( headB )\\n        {\\n            if ( headB->val < 0 ) break;\\n            headB = headB->next;\\n        }\\n        \\n        changeSign( headA );\\n        return headB;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\nprivate:\\n    void changeSign(ListNode *head){\\n        while ( head )\\n        {\\n            head->val *= -1;\\n            head = head->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 49817,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func getIntersectionNode(_ headA: ListNode?, _ headB: ListNode?) -> ListNode? {\\n        if headA == nil || headB == nil {\\n            return nil\\n        }\\n        \\n        var a: ListNode? = headA\\n        var b: ListNode? = headB\\n        \\n        while a !== b {\\n            a = a == nil ? headB : a?.next\\n            b = b == nil ? headA : b?.next\\n        }\\n        \\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    func getIntersectionNode(_ headA: ListNode?, _ headB: ListNode?) -> ListNode? {\\n        if headA == nil || headB == nil {\\n            return nil\\n        }\\n        \\n        var a: ListNode? = headA\\n        var b: ListNode? = headB\\n        \\n        while a !== b {\\n            a = a == nil ? headB : a?.next\\n            b = b == nil ? headA : b?.next\\n        }\\n        \\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49907,
                "title": "clean-java-code-easy-to-understand-explanation-o-m-n-time-o-1-space",
                "content": "If we add list A to the end of B, and add B to the end of A, then if they have intersection, the intersection would  located at the end of the combined list, and plus! they have the same index. Awesome!\\nTo return the right ListNode, we cannot actually combine them, just \"next\" the end to another list. The first equal element is what we want to find.\\n\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        if(headA==null || headB==null)retur**n** null;\\n        \\n        ListNode a=headA;\\n        ListNode b=headB;\\n        while(a!=b){\\n            a=a==null?headB:a.next;\\n            b=b==null?headA:b.next;\\n            \\n        }return b;\\n   \\n    }",
                "solutionTags": [],
                "code": "If we add list A to the end of B, and add B to the end of A, then if they have intersection, the intersection would  located at the end of the combined list, and plus! they have the same index. Awesome!\\nTo return the right ListNode, we cannot actually combine them, just \"next\" the end to another list. The first equal element is what we want to find.\\n\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        if(headA==null || headB==null)retur**n** null;\\n        \\n        ListNode a=headA;\\n        ListNode b=headB;\\n        while(a!=b){\\n            a=a==null?headB:a.next;\\n            b=b==null?headA:b.next;\\n            \\n        }return b;\\n   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1607859,
                "title": "c-four-approaches-brute-force-to-optimized-with-explanation",
                "content": "**Approach 1:**  (Brute force) \\nTraverse entire LL-1 for each node in LL-2 and keep checking for the intersection point.\\n\\nTime Complexity : O(n*m)\\nSpace Complexity : O(1)\\n\\n**CODE:**\\n```  \\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *temp;\\n        while(headA)\\n        {\\n            temp = headB;\\n            while(temp)\\n            {\\n                if(headA==temp) return headA;\\n                temp=temp->next;\\n            }\\n            headA=headA->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n**Approach 2:** \\nUsing hash table to store the address of each node of LL-1. \\nThen traverse LL-2, whenever we find the node that already exists in the hashtable, that \\nwill be the intersection point.\\n\\nTime Complexity : O(n)\\nSpace Complexity : O(n)\\n\\n**CODE:**\\n          \\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map <ListNode*, int> mp;\\n        while(headA)\\n        {\\n            mp[headA]++;\\n            headA=headA->next;\\n        }\\n        while(headB)\\n        {\\n            if(mp[headB]>0) return headB;\\n            headB=headB->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n\\n**Approach 3:**  *(One of the Best Approach)*\\n                Traverse LL1 and LL2 and find the length of both the LLs. \\n                find the diffrence b/w their lengths and then move the longer LL by that difference.\\n                This will make them both to cover the extra distance between them. \\n                Now move both pointers together(at the start of LL1 & one at x distance from start of LL2)\\n                Keep checking if they meet at any point. \\n                Even if they wont intersect, their value will become same when they reach null.\\n                So, if they\\'re not intersecting, null will be returned.\\n\\nTime Complexity : O(n)\\nSpace Complexity : O(1)\\n\\n**CODE:**\\n                \\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        int length1=0, length2=0;\\n        ListNode *h1 = headA, *h2 = headB;\\n        while(headA){\\n            length1++;\\n            headA=headA->next;  //length of LL-1\\n        }\\n        while(headB){\\n            length2++;\\n            headB=headB->next; //length of LL-2\\n        }\\n        \\n        int difference = abs(length1 - length2); //difference\\n       \\n        if(length1 > length2) {\\n            while(difference--) // moving the longerLL by the difference\\n                h1= h1->next;\\n        }\\n        else {\\n            while(difference--)\\n                h2 = h2->next;\\n        }\\n        \\n        while(h1 && h2)\\n        {\\n            if(h1==h2)\\n                return h1;  // return when address become same\\n            h1= h1->next;\\n            h2= h2->next;\\n        }\\n        return nullptr; //NULL is returned when intersection isn\\'t present.\\n        \\n    }\\n};\\n```\\n                \\n\\n**Approach 4**: (Best Approach --> Preferred one bcz of shorter code)\\n                Traverse LL-1 and LL-2 together, the one that reaches the end first, \\n                put it on the head of the other LL. (for example, LL-1 reaches null, then make ptr\\n                to point at the head of LL-2) Keep doing this until the address doessn\\'t become same.\\n                i.e, until we doesnt find the intersection point. We\\'re doing this to cover up\\n                the difference b/w LL-1 and LL-2.\\n                So, what if intersection point isnt there?? Will this method work?\\n                Yes, It will. Because if the intersection point isnt there, they both will store\\n                same address of NULL and that will be returned.\\n\\t\\t\\t\\t\\nTime Complexity : O(n)\\nSpace Complexity : O(1)\\n\\n**CODE:**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if(headA == NULL || headB == NULL) return NULL;\\n        ListNode *h1 = headA, *h2 = headB;\\n       \\n        while(h1 != h2) \\n        {\\n            if(h1==nullptr) h1= headB;\\n            else h1=h1->next;\\n            if(h2==nullptr) h2= headA;\\n            else h2= h2->next;\\n        }\\n        return h1;         \\n    }\\n};\\n```\\n\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```  \\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *temp;\\n        while(headA)\\n        {\\n            temp = headB;\\n            while(temp)\\n            {\\n                if(headA==temp) return headA;\\n                temp=temp->next;\\n            }\\n            headA=headA->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map <ListNode*, int> mp;\\n        while(headA)\\n        {\\n            mp[headA]++;\\n            headA=headA->next;\\n        }\\n        while(headB)\\n        {\\n            if(mp[headB]>0) return headB;\\n            headB=headB->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        int length1=0, length2=0;\\n        ListNode *h1 = headA, *h2 = headB;\\n        while(headA){\\n            length1++;\\n            headA=headA->next;  //length of LL-1\\n        }\\n        while(headB){\\n            length2++;\\n            headB=headB->next; //length of LL-2\\n        }\\n        \\n        int difference = abs(length1 - length2); //difference\\n       \\n        if(length1 > length2) {\\n            while(difference--) // moving the longerLL by the difference\\n                h1= h1->next;\\n        }\\n        else {\\n            while(difference--)\\n                h2 = h2->next;\\n        }\\n        \\n        while(h1 && h2)\\n        {\\n            if(h1==h2)\\n                return h1;  // return when address become same\\n            h1= h1->next;\\n            h2= h2->next;\\n        }\\n        return nullptr; //NULL is returned when intersection isn\\'t present.\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if(headA == NULL || headB == NULL) return NULL;\\n        ListNode *h1 = headA, *h2 = headB;\\n       \\n        while(h1 != h2) \\n        {\\n            if(h1==nullptr) h1= headB;\\n            else h1=h1->next;\\n            if(h2==nullptr) h2= headA;\\n            else h2= h2->next;\\n        }\\n        return h1;         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49920,
                "title": "ac-solution-code",
                "content": "**Procedure:**\\n1. When pointer X in shorter list reaches the end, pointer Y in the longer list will have len(longer) - len(shorter) left. Put pointer X to the head of the longer list, then when Y reaches its end, X already traveled len(longer)-len(shorter). Then put Y to the head of shorter list. \\n\\n2. Now X and Y have the same distance to the end:  \\n   1). If has intersection, intersection is the first node where X = Y\\n   2). If no intersection, termination case is X = Y = null, where they reach end together (as X, Y have the same distance to end)\\n\\n**Runtime complexity = O(m + n)** \\n\\nm = len(longer), n = len(shorter):\\n\\n    step 1: uses m time\\n    step 2: uses n time\\n.\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n    \\tif (headA == null || headB == null) \\n    \\t\\treturn null;\\n    \\tListNode curA = headA, curB = headB;\\n    \\twhile (curA != curB) {\\n    \\t\\tcurA = (curA == null) ? headB : curA.next;\\n    \\t\\tcurB = (curB == null) ? headA : curB.next;\\t\\t\\t\\n    \\t}\\n    \\treturn curA;\\n    }",
                "solutionTags": [],
                "code": "**Procedure:**\\n1. When pointer X in shorter list reaches the end, pointer Y in the longer list will have len(longer) - len(shorter) left. Put pointer X to the head of the longer list, then when Y reaches its end, X already traveled len(longer)-len(shorter). Then put Y to the head of shorter list. \\n\\n2. Now X and Y have the same distance to the end:  \\n   1). If has intersection, intersection is the first node where X = Y\\n   2). If no intersection, termination case is X = Y = null, where they reach end together (as X, Y have the same distance to end)\\n\\n**Runtime complexity = O(m + n)** \\n\\nm = len(longer), n = len(shorter):\\n\\n    step 1: uses m time\\n    step 2: uses n time\\n.\\n\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n    \\tif (headA == null || headB == null) \\n    \\t\\treturn null;\\n    \\tListNode curA = headA, curB = headB;\\n    \\twhile (curA != curB) {\\n    \\t\\tcurA = (curA == null) ? headB : curA.next;\\n    \\t\\tcurB = (curB == null) ? headA : curB.next;\\t\\t\\t\\n    \\t}\\n    \\treturn curA;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 49903,
                "title": "java-o-1-space-solution",
                "content": "    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int lenA = 0, lenB = 0;\\n        ListNode currA = headA, currB = headB;\\n        while(currA != null) {\\n            lenA++;\\n            currA = currA.next;\\n        }\\n        while(currB != null) {\\n            lenB++;\\n            currB = currB.next;\\n        }\\n        currA = headA;\\n        currB = headB;\\n        if(lenA > lenB) {\\n            for(int i=0; i<lenA-lenB; i++)\\n                currA = currA.next;\\n        } else {\\n            for(int i=0; i<lenB-lenA; i++)\\n                currB = currB.next;\\n        }\\n        while(currA != currB) {\\n            currA = currA.next;\\n            currB = currB.next;\\n        }\\n        return currA;\\n    }\\n\\n**First get the two length for each list, then put them at the same starting line by moving the longer one forward. Then move them at the same time and check the first match.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int lenA = 0, lenB = 0;\\n        ListNode currA = headA, currB = headB;\\n        while(currA != null) {\\n            lenA++;\\n            currA = currA.next;\\n        }\\n        while(currB != null) {\\n            lenB++;\\n            currB = currB.next;\\n        }\\n        currA = headA;\\n        currB = headB;\\n        if(lenA > lenB) {\\n            for(int i=0; i<lenA-lenB; i++)\\n                currA = currA.next;\\n        } else {\\n            for(int i=0; i<lenB-lenA; i++)\\n                currB = currB.next;\\n        }\\n        while(currA != currB) {\\n            currA = currA.next;\\n            currB = currB.next;\\n        }\\n        return currA;\\n    }\\n\\n**First get the two length for each list, then put them at the same starting line by moving the longer one forward. Then move them at the same time and check the first match.**",
                "codeTag": "Unknown"
            },
            {
                "id": 324105,
                "title": "heavily-commented-javascript-o-n-in-o-1-space-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} headA\\n * @param {ListNode} headB\\n * @return {ListNode}\\n */\\nvar getIntersectionNode = function(headA, headB) {\\n    \\n    // General idea: Switch tracks at the end, so you even out un-even linked lists\\n    // they will sync up at the intersection that way. Now you can straight up do a comparison\\n    // For example: \\n    // A will follow 4 - 1 - 8 - 4 - 5 - 5 - 0 - 1 - 8\\n    // B will follow 5 - 0 - 1 - 8 - 4 - 5 - 4 - 1 - 8\\n    \\n    // Now we need to account for the case where they don\\'t intersect, or our loop\\n    // would run forever. If after switching tracks, they both reach null at the same time\\n    // that\\'s when we know to stop\\n    \\n    // Basic leetcode input checks;\\n    if (!headA || !headB) {\\n        return null;\\n    }\\n    \\n    // current nodes\\n    let curA = headA;\\n    let curB = headB;\\n    \\n    // our end check. this works because we switch track to sync up\\n    while (curA !== curB) {\\n        \\n        if (curA.next) {\\n            // regular follow the path\\n            curA = curA.next;\\n        } else {\\n        \\n            if (!curB.next) {\\n                // if curB also reaches null next, we\\'ve ended up at the end without\\n                // any match found. break out of the loop and return null now.\\n                curA = null;\\n                curB = null;\\n                break;\\n            }\\n            // switch tracks to even out uneven length\\n            curA = headB;\\n        }\\n        \\n        if (curB.next) {\\n            // regular follow the path\\n            curB = curB.next \\n        } else {\\n            // switch tracks to even out uneven length\\n            curB = headA;\\n        }\\n    }\\n    \\n    return curB;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} headA\\n * @param {ListNode} headB\\n * @return {ListNode}\\n */\\nvar getIntersectionNode = function(headA, headB) {\\n    \\n    // General idea: Switch tracks at the end, so you even out un-even linked lists\\n    // they will sync up at the intersection that way. Now you can straight up do a comparison\\n    // For example: \\n    // A will follow 4 - 1 - 8 - 4 - 5 - 5 - 0 - 1 - 8\\n    // B will follow 5 - 0 - 1 - 8 - 4 - 5 - 4 - 1 - 8\\n    \\n    // Now we need to account for the case where they don\\'t intersect, or our loop\\n    // would run forever. If after switching tracks, they both reach null at the same time\\n    // that\\'s when we know to stop\\n    \\n    // Basic leetcode input checks;\\n    if (!headA || !headB) {\\n        return null;\\n    }\\n    \\n    // current nodes\\n    let curA = headA;\\n    let curB = headB;\\n    \\n    // our end check. this works because we switch track to sync up\\n    while (curA !== curB) {\\n        \\n        if (curA.next) {\\n            // regular follow the path\\n            curA = curA.next;\\n        } else {\\n        \\n            if (!curB.next) {\\n                // if curB also reaches null next, we\\'ve ended up at the end without\\n                // any match found. break out of the loop and return null now.\\n                curA = null;\\n                curB = null;\\n                break;\\n            }\\n            // switch tracks to even out uneven length\\n            curA = headB;\\n        }\\n        \\n        if (curB.next) {\\n            // regular follow the path\\n            curB = curB.next \\n        } else {\\n            // switch tracks to even out uneven length\\n            curB = headA;\\n        }\\n    }\\n    \\n    return curB;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2116312,
                "title": "c-easiest-way-o-1-space",
                "content": "The idea is to iterate through both the lists A + B and B + A simultaneously as shown below.\\nIf we look at the picture carefully, we notice that the last few red nodes will be the intersecting nodes, so we are guaranteed a solution this way.\\nIf the nodes are never intersecting, the iterations of both A+B and B+A end at the same time since they have the same length.\\n![image](https://assets.leetcode.com/users/images/8bd5413a-b2d6-446c-9c68-7222064bf44d_1654480549.0124373.png)\\n>  picture from @goAheadShaun\\'s [post](https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/2116221/Visual-Explanation-or-One-Pass-JAVA)\\n\\nHere\\'s the code :)\\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        // Initializing the two pointers\\n        ListNode *ptr1 = headA;\\n        ListNode *ptr2 = headB;\\n        \\n        while(ptr1 != ptr2){\\n            ptr1 = ptr1->next;\\n            ptr2 = ptr2->next;\\n            \\n            // break the loop if they reach the end together or collide\\n            if(ptr1 == ptr2) break;\\n            \\n            // if the pointer reaches the end of A, go to B and vice versa for ptr2\\n            if(ptr1 == NULL) ptr1 = headB;\\n            if(ptr2 == NULL) ptr2 = headA;\\n \\n        }\\n        // return the collided pointer\\n        return ptr1;\\n    }\\n};\\n```\\nThis is my first time posting a solution so please upvote, thanks!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        // Initializing the two pointers\\n        ListNode *ptr1 = headA;\\n        ListNode *ptr2 = headB;\\n        \\n        while(ptr1 != ptr2){\\n            ptr1 = ptr1->next;\\n            ptr2 = ptr2->next;\\n            \\n            // break the loop if they reach the end together or collide\\n            if(ptr1 == ptr2) break;\\n            \\n            // if the pointer reaches the end of A, go to B and vice versa for ptr2\\n            if(ptr1 == NULL) ptr1 = headB;\\n            if(ptr2 == NULL) ptr2 = headA;\\n \\n        }\\n        // return the collided pointer\\n        return ptr1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092899,
                "title": "c-simple-and-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *a = headA, *b = headB;\\n        \\n        while (a || b) {\\n            if (a == b) return a;\\n            \\n            if (a) a = a->next;\\n            else a = headB;\\n            \\n            if (b) b = b->next;\\n            else b = headA;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *a = headA, *b = headB;\\n        \\n        while (a || b) {\\n            if (a == b) return a;\\n            \\n            if (a) a = a->next;\\n            else a = headB;\\n            \\n            if (b) b = b->next;\\n            else b = headA;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 929431,
                "title": "3-solutions-easy-to-understand-faster-than-96-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        return self.withConstantSpaceAndLinearTime(headA, headB)\\n      \\n    def getLength(self, head):\\n        length = 0\\n        while head:\\n            head = head.next\\n            length += 1\\n        return length\\n    \\n    # Faster than 96.35% (Yay!!)\\n    def withConstantSpaceAndLinearTime(self, headA, headB):\\n        lenA = self.getLength(headA)\\n        lenB = self.getLength(headB)\\n        if lenB > lenA:\\n            headA, headB = headB, headA\\n            lenA, lenB = lenB, lenA\\n        \\n        \\n        diff = lenA - lenB\\n        while diff:\\n            headA = headA.next\\n            diff -= 1\\n        \\n        # print(headA.val, headB.val)\\n        \\n        while headA and headB and headA != headB:\\n            headA = headA.next\\n            headB = headB.next\\n        return headA\\n        \\n    # Faster than 81.92% (At that time ;)\\n    def usingSets(self, headA, headB):\\n        visited = set()\\n        while headA:\\n            visited.add(headA)\\n            headA = headA.next\\n        \\n        while headB:\\n            if headB in visited: return headB\\n            headB = headB.next\\n        return None\\n    \\n    # Gives us TLE\\n    def bruteForce(self, headA, headB):\\n        while headA:\\n            temp = headB\\n            while temp:\\n                if temp == headA: return headA\\n                temp = temp.next\\n            headA = headA.next\\n        return None\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        return self.withConstantSpaceAndLinearTime(headA, headB)\\n      \\n    def getLength(self, head):\\n        length = 0\\n        while head:\\n            head = head.next\\n            length += 1\\n        return length\\n    \\n    # Faster than 96.35% (Yay!!)\\n    def withConstantSpaceAndLinearTime(self, headA, headB):\\n        lenA = self.getLength(headA)\\n        lenB = self.getLength(headB)\\n        if lenB > lenA:\\n            headA, headB = headB, headA\\n            lenA, lenB = lenB, lenA\\n        \\n        \\n        diff = lenA - lenB\\n        while diff:\\n            headA = headA.next\\n            diff -= 1\\n        \\n        # print(headA.val, headB.val)\\n        \\n        while headA and headB and headA != headB:\\n            headA = headA.next\\n            headB = headB.next\\n        return headA\\n        \\n    # Faster than 81.92% (At that time ;)\\n    def usingSets(self, headA, headB):\\n        visited = set()\\n        while headA:\\n            visited.add(headA)\\n            headA = headA.next\\n        \\n        while headB:\\n            if headB in visited: return headB\\n            headB = headB.next\\n        return None\\n    \\n    # Gives us TLE\\n    def bruteForce(self, headA, headB):\\n        while headA:\\n            temp = headB\\n            while temp:\\n                if temp == headA: return headA\\n                temp = temp.next\\n            headA = headA.next\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49905,
                "title": "share-my-accepted-simple-and-short-c-code-with-the-help-of-the-topest-voted-one",
                "content": "    class Solution {\\n    public:\\n    \\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n    \\t\\tListNode *p1 = headA, *p2 = headB;\\n    \\t\\tif(p1 == NULL || p2 == NULL)\\n    \\t\\t\\treturn NULL;\\n    \\t\\twhile(p1 != p2)\\n    \\t\\t{\\n    \\t\\t\\tp1 = p1->next;\\n    \\t\\t\\tp2 = p2->next;\\n    \\t\\t\\tif(p1 == NULL && p2 != NULL)\\n    \\t\\t\\t\\tp1 = headB;\\n    \\t\\t\\tif(p2 == NULL && p1 != NULL)\\n    \\t\\t\\t\\tp2 = headA;\\n    \\t\\t}\\n    \\t\\treturn p1;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n    \\t\\tListNode *p1 = headA, *p2 = headB;\\n    \\t\\tif(p1 == NULL || p2 == NULL)\\n    \\t\\t\\treturn NULL;\\n    \\t\\twhile(p1 != p2)\\n    \\t\\t{\\n    \\t\\t\\tp1 = p1->next;\\n    \\t\\t\\tp2 = p2->next;\\n    \\t\\t\\tif(p1 == NULL && p2 != NULL)\\n    \\t\\t\\t\\tp1 = headB;\\n    \\t\\t\\tif(p2 == NULL && p1 != NULL)\\n    \\t\\t\\t\\tp2 = headA;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 49954,
                "title": "my-52ms-c-solve",
                "content": "    class Solution {\\n    public:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *pA = headA;\\n        ListNode *pB = headB;\\n        int lenA = 0;\\n        int lenB = 0;\\n        while (pA) {++lenA;  pA = pA->next; }\\n        while (pB) {++lenB;  pB = pB->next; }\\n        for (int diff = abs(lenA - lenB); diff > 0; --diff) {\\n            if (lenA > lenB) {\\n                headA = headA->next;\\n            }\\n            else {\\n                headB = headB->next;\\n            }\\n        }\\n        while (headA && headB) {\\n            if (headA == headB) {\\n                return headA;\\n            }\\n            headA = headA ->next;\\n            headB = headB ->next;\\n        }\\n        return NULL;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *pA = headA;\\n        ListNode *pB = headB;\\n        int lenA = 0;\\n        int lenB = 0;\\n        while (pA) {++lenA;  pA = pA->next; }",
                "codeTag": "Java"
            },
            {
                "id": 49917,
                "title": "o-n-time-o-1-space-solution-differ-from-the-official-one",
                "content": "    // get the len of a linked list\\n    int getLen(ListNode *head) {\\n        int len = 0;\\n        while(head) { len++; head = head->next; } \\n        return len;\\n    }\\n    \\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if (!headA || !headB) return NULL;\\n        ListNode *p1 = headA, *p2 = headB;\\n        int lenA = getLen(headA), lenB = getLen(headB);\\n        \\n        if (lenA <= lenB) {\\n            for (int i = 0; i < lenB - lenA; ++i)\\n                p2 = p2->next;\\n        }\\n        else {\\n            for (int i=0; i < lenA - lenB; ++i)\\n                p1 = p1->next;\\n        }\\n        \\n        while (p1 && p2 && p1 != p2) p1 = p1->next, p2 = p2->next;\\n        if (!p1 || !p2) return NULL;\\n        return p1;\\n    }",
                "solutionTags": [],
                "code": "    // get the len of a linked list\\n    int getLen(ListNode *head) {\\n        int len = 0;\\n        while(head) { len++; head = head->next; } \\n        return len;\\n    }\\n    \\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if (!headA || !headB) return NULL;\\n        ListNode *p1 = headA, *p2 = headB;\\n        int lenA = getLen(headA), lenB = getLen(headB);\\n        \\n        if (lenA <= lenB) {\\n            for (int i = 0; i < lenB - lenA; ++i)\\n                p2 = p2->next;\\n        }\\n        else {\\n            for (int i=0; i < lenA - lenB; ++i)\\n                p1 = p1->next;\\n        }\\n        \\n        while (p1 && p2 && p1 != p2) p1 = p1->next, p2 = p2->next;\\n        if (!p1 || !p2) return NULL;\\n        return p1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2561582,
                "title": "python-91-66-faster-simplest-solution-with-explanation-beg-to-adv-linked-list",
                "content": "***Found helpful , Do upvote !!***\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        l1, l2 = headA, headB# First we are taking two pointers\\n        while l1!=l2:  # if heads are equal this implies that we found our intersection node and then we`ll return it.\\n            if l1: # if list1 is there then go ahead.\\n                l1=l1.next # we traverse to the list to check if we found the intersection node.\\n            else:\\n                l1 = headB # if we reach to the end of the list1 then we will move our pointer to the other list head, WHY: - explained separately below.\\n\\t\\t\\t# above if condition in comprehension approach. \\n            # l1=l1.next if l1 else headB \\n            if l2:  # if list2 is there then go ahead.\\n                l2=l2.next # we traverse to the list to check if we found the intersection node.\\n            else:\\n                l2 = headA # if we reach to the end of the list2 then we will move our pointer to the other list head, WHY: - explained separately below.\\n\\t\\t\\t# above if condition in comprehension approach. \\n            # l2=l2.next if l2 else headA\\n        return l1 # returning the pointer, we could return l2 also as we found our intersection else null.\\n```\\n**Approch of this solution is:**\\nFirstly we`ll traverse through both the list provided to find the intersection.\\nIf we didnt find the intersection. Then we move the pointers to the other list head.\\n\\n**WHY:-** by moving the pointor to the next list head, we`ll be able to eradiacte the lenght diff of both the lists,\\n\\n**In 2nd round of iteration:**\\nNow once we reach to the end of the list one, will start traversing through the next list.\\nIn doing that we will be able to eradicate the lenght diff between both lists.\\nIn this iteration l1 will go to head of list 2 and l2 will reach to the head of list 1 and then both the pointer will be in sync.\\n![image](https://assets.leetcode.com/users/images/4573ba45-8ed6-4fe1-ab89-f2ecbc99cd9f_1662887938.631127.png)\\n\\nNow we keep traversing till the time we get to the itersecting element & if there wont be any willreturn null.\\n#####  Why it didnt go infinitely:\\nBcz, both list hit null eventually and while loop will be true in that case and return null as we didnt find intersection in our traversal..\\n**Watch this video for better understanding :-** https://www.youtube.com/watch?v=D0X0BONOQhI&ab_channel=NeetCode\\n\\n***Found helpful , Do upvote !!***\\n![image](https://assets.leetcode.com/users/images/bba69cb9-e8bf-4906-bc0c-1963853b2ab8_1662888449.4709215.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        l1, l2 = headA, headB# First we are taking two pointers\\n        while l1!=l2:  # if heads are equal this implies that we found our intersection node and then we`ll return it.\\n            if l1: # if list1 is there then go ahead.\\n                l1=l1.next # we traverse to the list to check if we found the intersection node.\\n            else:\\n                l1 = headB # if we reach to the end of the list1 then we will move our pointer to the other list head, WHY: - explained separately below.\\n\\t\\t\\t# above if condition in comprehension approach. \\n            # l1=l1.next if l1 else headB \\n            if l2:  # if list2 is there then go ahead.\\n                l2=l2.next # we traverse to the list to check if we found the intersection node.\\n            else:\\n                l2 = headA # if we reach to the end of the list2 then we will move our pointer to the other list head, WHY: - explained separately below.\\n\\t\\t\\t# above if condition in comprehension approach. \\n            # l2=l2.next if l2 else headA\\n        return l1 # returning the pointer, we could return l2 also as we found our intersection else null.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715399,
                "title": "python-3-both-o-n-m-and-o-1-memory-approach",
                "content": "### Approach 1- O(N+M) Time| O(N) Space\\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n\\t\\thashmap={}\\n        while headA:\\n            hashmap[headA]=1\\n            headA=headA.next\\n        while headB and headB not in hashmap:\\n            headB=headB.next\\n        return headB\\n```\\n### Approach 2- O(N+M) Time| O(1) Space\\n\\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n\\t\\t  \\n        n,m=0,0\\n        tempA,tempB=headA,headB\\n        while tempA:\\n            n+=1\\n            tempA=tempA.next\\n        while tempB:\\n            m+=1\\n            tempB=tempB.next\\n        while m>n:\\n            headB=headB.next\\n            m-=1\\n        while n>m:\\n            headA=headA.next\\n            n-=1\\n        while headB!=headA:\\n            headB=headB.next\\n            headA=headA.next\\n        return headA\\n```\\nPS- Damn thats a lot of while loops XD\\nDo give a upvote if you feel this happens with you at times too",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n\\t\\thashmap={}\\n        while headA:\\n            hashmap[headA]=1\\n            headA=headA.next\\n        while headB and headB not in hashmap:\\n            headB=headB.next\\n        return headB\\n```\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n\\t\\t  \\n        n,m=0,0\\n        tempA,tempB=headA,headB\\n        while tempA:\\n            n+=1\\n            tempA=tempA.next\\n        while tempB:\\n            m+=1\\n            tempB=tempB.next\\n        while m>n:\\n            headB=headB.next\\n            m-=1\\n        while n>m:\\n            headA=headA.next\\n            n-=1\\n        while headB!=headA:\\n            headB=headB.next\\n            headA=headA.next\\n        return headA\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523250,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        if(headA == null || headB == null)  return null;\\n        ListNode A = headA, B = headB;\\n        while(A != B){\\n            A = (A == null) ? headB : A.next;\\n            B = (B == null) ? headA : B.next;\\n        }\\n        return A;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar getIntersectionNode = function(headA, headB) {\\n    if(!headA || !headB)    return null\\n    let A = headA, B = headB\\n    while(A != B){\\n        A = (A)? A.next : headB\\n        B = (B)? B.next : headA\\n    }\\n    return A\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        if not headA or not headB:\\n            return null\\n        A, B = headA, headB\\n        while A != B:\\n            A = A.next if A else headB\\n            B = B.next if B else headA\\n        return A\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        if(headA == null || headB == null)  return null;\\n        ListNode A = headA, B = headB;\\n        while(A != B){\\n            A = (A == null) ? headB : A.next;\\n            B = (B == null) ? headA : B.next;\\n        }\\n        return A;\\n    }\\n}\\n```\n```\\nvar getIntersectionNode = function(headA, headB) {\\n    if(!headA || !headB)    return null\\n    let A = headA, B = headB\\n    while(A != B){\\n        A = (A)? A.next : headB\\n        B = (B)? B.next : headA\\n    }\\n    return A\\n};\\n```\n```\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        if not headA or not headB:\\n            return null\\n        A, B = headA, headB\\n        while A != B:\\n            A = A.next if A else headB\\n            B = B.next if B else headA\\n        return A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408282,
                "title": "python-easy-illustrated-and-commented-solution-87",
                "content": "## Once either of the two pointers reach the end then move other pointer head such that both heads will be at same distance from intersection\\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        curr1, curr2 = headA,headB\\n        \\n        while curr1 or curr2: # once any of the two pointers reach the end then move other pointer head such that both heads will be at same distance from intersection\\n            if curr1: curr1 = curr1.next\\n            else: headB = headB.next\\n            if curr2: curr2 = curr2.next\\n            else: headA = headA.next\\n        \\n        while headA is not headB: # find the intersection point when it becomes equal\\n            headA = headA.next\\n            headB = headB.next\\n        \\n        return headA\\n```\\n\\norange solid arrow => final position of curr1 (pointer of headB)\\norange doted arrow => headB\\nsimilary for blue arrow\\ngreen arrow shows shifed poistions of head A and head B\\n![image](https://assets.leetcode.com/users/images/aa7b1fbf-3037-4b44-ab1a-957633c7aae3_1629176286.9457114.png)\\nPlease like if you find it helpful\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        curr1, curr2 = headA,headB\\n        \\n        while curr1 or curr2: # once any of the two pointers reach the end then move other pointer head such that both heads will be at same distance from intersection\\n            if curr1: curr1 = curr1.next\\n            else: headB = headB.next\\n            if curr2: curr2 = curr2.next\\n            else: headA = headA.next\\n        \\n        while headA is not headB: # find the intersection point when it becomes equal\\n            headA = headA.next\\n            headB = headB.next\\n        \\n        return headA\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105629,
                "title": "simple-java-beats-100-runtime-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find the *intersection of the Two Linked List*. It means that we have to find the **first common node** of the two given lists.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n    1. Find the lengths of the two given lists.\\n    2. Make the list equal by removing some elements.\\n    3. Step 2 is done by updating the head pointer.\\n    4. Traverse the list and check for the common node.\\n\\n# Complexity\\n- Time complexity: O(n+m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nFollow the code below to understand the solution.\\n\\n             **If this solution helped you, give it an up-vote to help others** \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n        \\n        int sizeA = 0;      //stores size of listA.\\n        int sizeB = 0;      //stores size of listA.\\n\\n        //declare temp pointer initially. (saves space)\\n        ListNode temp;\\n\\n        //traverse listA and store its size in sizeA variable.\\n        for(temp = headA; temp != null; temp = temp.next)\\n        {\\n            //increment sizeA with each next node.\\n            sizeA++;            \\n        }\\n        \\n        //traverse listB and store its size in sizeB variable.\\n        for(temp = headB; temp != null; temp = temp.next)\\n        {\\n            //increment sizeA with each next node.\\n            sizeB++;         \\n        }\\n\\n        //Now make the two lists equal by removing nodes of\\n        //the greater list.\\n\\n        //if size of listA is greater than size of listB.\\n        while(sizeA > sizeB)\\n        {\\n            //go to next node of the listA.\\n            headA = headA.next;\\n            sizeA--;\\n        }\\n\\n        //similarly, do it if sizeB > sizeA\\n        while(sizeB > sizeA)\\n        {\\n            headB = headB.next;\\n            sizeB--;\\n        }\\n\\n        //check the nodes untill the node becomes equal.\\n        while(headA != headB)\\n        {\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n\\n        //finally, return either of the two nodes.\\n        //if there is no intersection, then headA and headB\\n        //will point to null.\\n        return headA;       //return headB;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n        \\n        int sizeA = 0;      //stores size of listA.\\n        int sizeB = 0;      //stores size of listA.\\n\\n        //declare temp pointer initially. (saves space)\\n        ListNode temp;\\n\\n        //traverse listA and store its size in sizeA variable.\\n        for(temp = headA; temp != null; temp = temp.next)\\n        {\\n            //increment sizeA with each next node.\\n            sizeA++;            \\n        }\\n        \\n        //traverse listB and store its size in sizeB variable.\\n        for(temp = headB; temp != null; temp = temp.next)\\n        {\\n            //increment sizeA with each next node.\\n            sizeB++;         \\n        }\\n\\n        //Now make the two lists equal by removing nodes of\\n        //the greater list.\\n\\n        //if size of listA is greater than size of listB.\\n        while(sizeA > sizeB)\\n        {\\n            //go to next node of the listA.\\n            headA = headA.next;\\n            sizeA--;\\n        }\\n\\n        //similarly, do it if sizeB > sizeA\\n        while(sizeB > sizeA)\\n        {\\n            headB = headB.next;\\n            sizeB--;\\n        }\\n\\n        //check the nodes untill the node becomes equal.\\n        while(headA != headB)\\n        {\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n\\n        //finally, return either of the two nodes.\\n        //if there is no intersection, then headA and headB\\n        //will point to null.\\n        return headA;       //return headB;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155040,
                "title": "c-3-solutions",
                "content": "**Brute Force**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* pa = headA;\\n        while (pa) {\\n            for (ListNode* pb = headB; pb; pb = pb -> next) {\\n                if (pa == pb) {\\n                    return pa;\\n                }\\n            }\\n            pa = pa -> next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n\\n**Hash Table**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_set<ListNode*> nodes;\\n        while (headA) {\\n            nodes.insert(headA);\\n            headA = headA -> next;\\n        }\\n        while (headB && nodes.find(headB) == nodes.end()) {\\n            headB = headB -> next;\\n        }\\n        return headB;\\n    }\\n};\\n```\\n\\n**Two Pointers**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *pa = headA, *pb = headB;\\n        while (pa != pb) {\\n            pa = pa ? pa -> next : headB;\\n            pb = pb ? pb -> next : headA;\\n        }\\n        return pa;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* pa = headA;\\n        while (pa) {\\n            for (ListNode* pb = headB; pb; pb = pb -> next) {\\n                if (pa == pb) {\\n                    return pa;\\n                }\\n            }\\n            pa = pa -> next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_set<ListNode*> nodes;\\n        while (headA) {\\n            nodes.insert(headA);\\n            headA = headA -> next;\\n        }\\n        while (headB && nodes.find(headB) == nodes.end()) {\\n            headB = headB -> next;\\n        }\\n        return headB;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *pa = headA, *pb = headB;\\n        while (pa != pb) {\\n            pa = pa ? pa -> next : headB;\\n            pb = pb ? pb -> next : headA;\\n        }\\n        return pa;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49952,
                "title": "clean-9-lines-c-solution-32ms-and-o-1-space",
                "content": "    #define NEXT(x) (x=x->next)\\n    typedef struct ListNode ln;\\n    \\n    ln* getIntersectionNode(ln *headA, ln *headB)\\n    {\\n      /* if(!headA || !headB) return NULL; */\\n      \\n      /* first get the lengths of the two lists */\\n      int lenA = 0, lenB =0;\\n      for(ln* pA = headA; pA; NEXT(pA)) lenA++;\\n      for(ln* pB = headB; pB; NEXT(pB)) lenB++;\\n    \\n      /* move the longer one forward to match two lists at the start-line */\\n      for(int i = 0; i<(lenA-lenB); i++) NEXT(headA);\\n      for(int i = 0; i<(lenB-lenA); i++) NEXT(headB);\\n    \\n      /* move simultaneously and check the first meeting point */\\n      while(headA!=headB)\\n      {\\n        NEXT(headA);\\n        NEXT(headB);\\n      }\\n    \\n      return headA; /* NULL or the intersection */\\n    }",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "    #define NEXT(x) (x=x->next)\\n    typedef struct ListNode ln;\\n    \\n    ln* getIntersectionNode(ln *headA, ln *headB)\\n    {\\n      /* if(!headA || !headB) return NULL; */\\n      \\n      /* first get the lengths of the two lists */\\n      int lenA = 0, lenB =0;\\n      for(ln* pA = headA; pA; NEXT(pA)) lenA++;\\n      for(ln* pB = headB; pB; NEXT(pB)) lenB++;\\n    \\n      /* move the longer one forward to match two lists at the start-line */\\n      for(int i = 0; i<(lenA-lenB); i++) NEXT(headA);\\n      for(int i = 0; i<(lenB-lenA); i++) NEXT(headB);\\n    \\n      /* move simultaneously and check the first meeting point */\\n      while(headA!=headB)\\n      {\\n        NEXT(headA);\\n        NEXT(headB);\\n      }\\n    \\n      return headA; /* NULL or the intersection */\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 2509113,
                "title": "javascript-code-simple-tc-o-n-m-sc-1-very-easy-explanation-with-images",
                "content": "**// Hi Devs if you like my post and it helps you please do vote so that it reaches more Devs**\\n\\n// in this approach we are taking two pointers and traverse both lists ,\\n// if either of pointer reaches end it start traversing another list  \\n// if  both pointer points at same node we got intersection;\\n// if both pointers points at Null means we dont get intersection \\n\\n\\n// PLEASE REFER IMAGE \\n![image](https://assets.leetcode.com/users/images/a06df456-9052-4d89-9060-e8bf52e8d14b_1661946650.5888896.png)\\n![image](https://assets.leetcode.com/users/images/511d08b0-65c4-45eb-bb4f-d5145765bfce_1661947414.5147152.png)\\n\\n\\n\\n```\\nvar getIntersectionNode = function(headA, headB) {\\n    let p = headA;\\n    let q = headB;\\n    \\n    while(p!=q && ( p.next || q.next)){\\n        if(p.next == null) p = headB;\\n        else   p=p.next;\\n        if(q.next == null) q= headA;\\n        else q=q.next;\\n      \\n        \\n    }\\n    // console.log(q.val)\\n    if(p==q) return p;\\n   \\n};****\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nvar getIntersectionNode = function(headA, headB) {\\n    let p = headA;\\n    let q = headB;\\n    \\n    while(p!=q && ( p.next || q.next)){\\n        if(p.next == null) p = headB;\\n        else   p=p.next;\\n        if(q.next == null) q= headA;\\n        else q=q.next;\\n      \\n        \\n    }\\n    // console.log(q.val)\\n    if(p==q) return p;\\n   \\n};****\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2297063,
                "title": "python-5-line-solution-with-comments-and-visualization",
                "content": "**Approach:**\\n\\n* Take two dummy nodes for each list. Point each to the head of the lists.\\n* Iterate over them. If anyone becomes null, point them to the head of the opposite lists and continue iterating until they collide.\\n\\n**Time Complexity:** O(max(n,m))\\n**Space Complexity:** O(1)\\n\\n**Visualization** -\\n![image](https://assets.leetcode.com/users/images/c082a238-c1d2-4a31-bf04-39ef5ef4ec17_1658093780.5060673.gif)\\n\\n\\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        dummyA, dummyB = headA, headB # Take dummy nodes\\n\\n        while dummyA != dummyB:\\n            dummyA = headB if dummyA is None else dummyA.next \\n            dummyB = headA if dummyB is None else dummyB.next\\n        # Return any dummy pointer. i.e. If any intersection node is present it\\'ll get returned else it will return None because at the end of iteration both dummy pointers will point to NULL.\\n        return dummyA \\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        dummyA, dummyB = headA, headB # Take dummy nodes\\n\\n        while dummyA != dummyB:\\n            dummyA = headB if dummyA is None else dummyA.next \\n            dummyB = headA if dummyB is None else dummyB.next\\n        # Return any dummy pointer. i.e. If any intersection node is present it\\'ll get returned else it will return None because at the end of iteration both dummy pointers will point to NULL.\\n        return dummyA \\n```",
                "codeTag": "Java"
            },
            {
                "id": 638775,
                "title": "java-3-approaches-two-loops-hashset-and-two-pointers",
                "content": "Approach 1: Naive (using two loops)\\n``` \\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n       ListNode a=headA,b;\\n        while(a!=null){\\n            b = headB;\\n            while(b!=null){\\n              if(a == b) return a;\\n              b = b.next;\\n            }\\n            a = a.next;\\n        }\\n        return null;\\n    }\\n}\\n```\\nApproach 2:  Using HashSet \\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n       ListNode a=headA,b=headB;\\n       Set<ListNode> seen  = new HashSet<>();\\n       while(a!=null){\\n           seen.add(a);\\n           a=a.next;\\n       }\\n    \\n       while(b!=null){\\n           if(!seen.add(b)) return b;\\n           b=b.next;\\n       }\\n       return null;\\n    }\\n}\\n```\\n\\nApproach 3: Using Two pointers\\n\\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode a=headA, b=headB;\\n        while(a!=b){\\n            if(a==null) a=headB;\\n            else  a=a.next;\\n            if(b==null) b=headA;\\n            else b=b.next;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` \\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n       ListNode a=headA,b;\\n        while(a!=null){\\n            b = headB;\\n            while(b!=null){\\n              if(a == b) return a;\\n              b = b.next;\\n            }\\n            a = a.next;\\n        }\\n        return null;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n       ListNode a=headA,b=headB;\\n       Set<ListNode> seen  = new HashSet<>();\\n       while(a!=null){\\n           seen.add(a);\\n           a=a.next;\\n       }\\n    \\n       while(b!=null){\\n           if(!seen.add(b)) return b;\\n           b=b.next;\\n       }\\n       return null;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode a=headA, b=headB;\\n        while(a!=b){\\n            if(a==null) a=headB;\\n            else  a=a.next;\\n            if(b==null) b=headA;\\n            else b=b.next;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49967,
                "title": "sharing-my-fast-and-easy-to-understand-accepted-java-solution",
                "content": "```\\npublic class Solution {\\n        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n            \\n            if (headA == null || headB == null)\\n                return null;\\n            \\n            int countA = 0;\\n            ListNode pa = headA;\\n            while (pa != null){\\n                pa = pa.next;\\n                countA++;\\n            }\\n            \\n            int countB = 0;\\n            ListNode pb = headB;\\n            while (pb != null){\\n                pb = pb.next;\\n                countB++;\\n            }\\n            \\n            pa = headA;\\n            pb = headB;\\n            \\n            if (countA > countB){\\n                for (int i=0; i<countA-countB; i++){\\n                    pa = pa.next;\\n                }    \\n            } else if (countB > countA){\\n                for (int i=0; i<countB-countA; i++){\\n                    pb = pb.next;\\n                }    \\n            }\\n            \\n            while (pa != pb && pa != null){\\n                pa = pa.next;\\n                pb = pb.next;\\n            }\\n            \\n            return pa;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n            \\n            if (headA == null || headB == null)\\n                return null;\\n            \\n            int countA = 0;\\n            ListNode pa = headA;\\n            while (pa != null){\\n                pa = pa.next;\\n                countA++;\\n            }\\n            \\n            int countB = 0;\\n            ListNode pb = headB;\\n            while (pb != null){\\n                pb = pb.next;\\n                countB++;\\n            }\\n            \\n            pa = headA;\\n            pb = headB;\\n            \\n            if (countA > countB){\\n                for (int i=0; i<countA-countB; i++){\\n                    pa = pa.next;\\n                }    \\n            } else if (countB > countA){\\n                for (int i=0; i<countB-countA; i++){\\n                    pb = pb.next;\\n                }    \\n            }\\n            \\n            while (pa != pb && pa != null){\\n                pa = pa.next;\\n                pb = pb.next;\\n            }\\n            \\n            return pa;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208755,
                "title": "160-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Traverse both linked lists to find their lengths, and the difference in lengths diff.\\n2. Move the pointer of the longer linked list diff steps ahead, so that both linked lists have the same number of nodes remaining to traverse.\\n3. Traverse both linked lists in parallel until the pointers meet at the intersection node (or null if there is no intersection).\\n\\nThis solution has a time complexity of O(m + n), where m and n are the lengths of the two linked lists, and a space complexity of O(1), since we are only using a constant amount of additional memory.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        # Find lengths of linked lists\\n        lenA, lenB = 0, 0\\n        nodeA, nodeB = headA, headB\\n        while nodeA:\\n            lenA += 1\\n            nodeA = nodeA.next\\n        while nodeB:\\n            lenB += 1\\n            nodeB = nodeB.next\\n        \\n        # Calculate difference in lengths\\n        diff = abs(lenA - lenB)\\n        if lenA > lenB:\\n            # Move pointer of A ahead\\n            while diff > 0:\\n                headA = headA.next\\n                diff -= 1\\n        else:\\n            # Move pointer of B ahead\\n            while diff > 0:\\n                headB = headB.next\\n                diff -= 1\\n        \\n        # Traverse both linked lists in parallel\\n        while headA and headB:\\n            if headA == headB:\\n                return headA\\n            headA = headA.next\\n            headB = headB.next\\n        \\n        # No intersection found\\n        return None\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        # Find lengths of linked lists\\n        lenA, lenB = 0, 0\\n        nodeA, nodeB = headA, headB\\n        while nodeA:\\n            lenA += 1\\n            nodeA = nodeA.next\\n        while nodeB:\\n            lenB += 1\\n            nodeB = nodeB.next\\n        \\n        # Calculate difference in lengths\\n        diff = abs(lenA - lenB)\\n        if lenA > lenB:\\n            # Move pointer of A ahead\\n            while diff > 0:\\n                headA = headA.next\\n                diff -= 1\\n        else:\\n            # Move pointer of B ahead\\n            while diff > 0:\\n                headB = headB.next\\n                diff -= 1\\n        \\n        # Traverse both linked lists in parallel\\n        while headA and headB:\\n            if headA == headB:\\n                return headA\\n            headA = headA.next\\n            headB = headB.next\\n        \\n        # No intersection found\\n        return None\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116478,
                "title": "c-easy-solution-w-multiple-approaches",
                "content": "**Please upvote If you like the post :)**\\n\\nSo, basically we are given the heads of two singly linked-lists `headA` and `headB`, return the `node` at which the two lists `intersect`. If the two linked lists have no intersection at all, return `null`.\\n             \\n\\n**Intuitive/Brute Force Approach :**\\n```\\nclass Solution {\\npublic:\\n\\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\tListNode *temp;\\n\\t\\twhile(headA != NULL){\\n\\t\\t\\ttemp = headB;\\n\\t\\t\\twhile(temp != NULL){\\n\\t\\t\\t\\tif(headA == temp){\\n\\t\\t\\t\\t\\treturn headA;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp = temp -> next;\\n\\t\\t\\t}\\n\\t\\t\\theadA = headA -> next;\\n\\t\\t}\\n\\t\\treturn NULL;\\n\\t}\\n};\\n```\\n**Time Complexity :** `O(m*n)`\\n**Space Complexity :**` O(1)`\\n\\n****\\n**HashMap Approach :** **(Somewhat linear)**\\n```\\nclass Solution {\\npublic:\\n\\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\tunordered_map<ListNode*, int> mp;\\n\\t\\twhile(headA != NULL){\\n\\t\\t\\tmp[headA]++;\\n\\t\\t\\theadA = headA -> next;\\n\\t\\t}\\n\\t\\twhile(headB != NULL){\\n\\t\\t\\tif(mp[headB] > 0){\\n\\t\\t\\t\\treturn headB;\\n\\t\\t\\t}\\n\\t\\t\\theadB = headB -> next;\\n\\t\\t}\\n\\t\\treturn NULL;\\n\\t}\\n};\\n```\\n**Time Complexity :** `O(m+n)`\\n**Space Complexity :**` O(m)`\\n\\n****\\n**Two Pointers Approach :** **(Space Optimized)**\\n\\n```\\nclass Solution {\\npublic:\\n\\tListNode *getIntersectionNode(ListNode *a, ListNode *b) {\\n\\t\\tListNode *ptr1 = headA;\\n\\t\\tListNode *ptr2 = headB;\\n\\t\\twhile(ptr1 != ptr2){\\n\\t\\t\\tif(ptr1 == NULL){\\n\\t\\t\\t\\tptr1 = headB;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tptr1 = ptr1 -> next;\\n\\t\\t\\t}\\n\\t\\t\\tif(ptr2 == NULL){\\n\\t\\t\\t\\tptr2 = headA;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tptr2 = ptr2 -> next;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ptr1;\\n\\t}\\n};\\n```\\n**Time Complexity :** `O(m+n)`\\n**Space Complexity :**` O(1)`\\n\\n****\\n****\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\tListNode *temp;\\n\\t\\twhile(headA != NULL){\\n\\t\\t\\ttemp = headB;\\n\\t\\t\\twhile(temp != NULL){\\n\\t\\t\\t\\tif(headA == temp){\\n\\t\\t\\t\\t\\treturn headA;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp = temp -> next;\\n\\t\\t\\t}\\n\\t\\t\\theadA = headA -> next;\\n\\t\\t}\\n\\t\\treturn NULL;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\tunordered_map<ListNode*, int> mp;\\n\\t\\twhile(headA != NULL){\\n\\t\\t\\tmp[headA]++;\\n\\t\\t\\theadA = headA -> next;\\n\\t\\t}\\n\\t\\twhile(headB != NULL){\\n\\t\\t\\tif(mp[headB] > 0){\\n\\t\\t\\t\\treturn headB;\\n\\t\\t\\t}\\n\\t\\t\\theadB = headB -> next;\\n\\t\\t}\\n\\t\\treturn NULL;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tListNode *getIntersectionNode(ListNode *a, ListNode *b) {\\n\\t\\tListNode *ptr1 = headA;\\n\\t\\tListNode *ptr2 = headB;\\n\\t\\twhile(ptr1 != ptr2){\\n\\t\\t\\tif(ptr1 == NULL){\\n\\t\\t\\t\\tptr1 = headB;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tptr1 = ptr1 -> next;\\n\\t\\t\\t}\\n\\t\\t\\tif(ptr2 == NULL){\\n\\t\\t\\t\\tptr2 = headA;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tptr2 = ptr2 -> next;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ptr1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855370,
                "title": "c-2-approaches-solution",
                "content": "**upvote if it helps**\\n\\t\\n**approch 1**\\n\\n\\n         ListNode *originalHeadA = headA,  *originalHeadB = headB;\\n        // turtle headA vs hare headB\\n        while (headA || headB) {\\n            // checking if a match is found\\n            if (headA == headB) return headB;\\n            // resetting or advancing A and B as needed\\n            if (!headA) headA = originalHeadA;\\n            else headA = headA->next;\\n            if (!headB) headB = originalHeadB;\\n            else headB = headB->next;\\n        }\\n        return headB;\\n\\t\\n**approch 2**\\n\\t\\n\\tListNode*la = headA;// pointing the refrence pointer ;\\n        ListNode*lb = headB;\\n        \\n        // base case if one the list is empty\\n        if(!la || !lb) return NULL;\\n        int n = 0 , m = 0;\\n        while(la != NULL){  // counting the lenght of List 1;\\n            la = la->next;\\n            n++;\\n        }\\n        while(lb != NULL){ // counting the lenght of List 2;\\n            lb = lb->next;\\n            m++;\\n        }\\n        int t = abs(n-m);\\n        la = headA; lb = headB;\\n        if(m>n){ \\n            while(t) lb = lb->next; t--;\\n        }\\n        else { \\n            while(t) la = la->next; t--;\\n        }\\n        while(la!=lb){\\n            la = la->next;\\n            lb = lb->next;\\n        }\\n        return la;",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "**upvote if it helps**\\n\\t\\n**approch 1**\\n\\n\\n         ListNode *originalHeadA = headA,  *originalHeadB = headB;\\n        // turtle headA vs hare headB\\n        while (headA || headB) {\\n            // checking if a match is found\\n            if (headA == headB) return headB;\\n            // resetting or advancing A and B as needed\\n            if (!headA) headA = originalHeadA;\\n            else headA = headA->next;\\n            if (!headB) headB = originalHeadB;\\n            else headB = headB->next;\\n        }\\n        return headB;\\n\\t\\n**approch 2**\\n\\t\\n\\tListNode*la = headA;// pointing the refrence pointer ;\\n        ListNode*lb = headB;\\n        \\n        // base case if one the list is empty\\n        if(!la || !lb) return NULL;\\n        int n = 0 , m = 0;\\n        while(la != NULL){  // counting the lenght of List 1;\\n            la = la->next;\\n            n++;\\n        }\\n        while(lb != NULL){ // counting the lenght of List 2;\\n            lb = lb->next;\\n            m++;\\n        }\\n        int t = abs(n-m);\\n        la = headA; lb = headB;\\n        if(m>n){ \\n            while(t) lb = lb->next; t--;\\n        }\\n        else { \\n            while(t) la = la->next; t--;\\n        }\\n        while(la!=lb){\\n            la = la->next;\\n            lb = lb->next;\\n        }\\n        return la;",
                "codeTag": "Unknown"
            },
            {
                "id": 1393971,
                "title": "best-6-lines-solutions-specially-for-beginners-detailed-explanation-of-approach",
                "content": "first I find the length of noth the linked lists.\\nthen find the absolute difference of length of linked list.\\nthen traverse the linked list which has more number of nodes upto when the absolute difference between the length of linked list become zero.\\nthen run a while loop upto the noth nofes are equal\\n\\n\\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n            \\n             ListNode *t1=headA,*t2=headB;\\n         \\n        int l1=0,l2=0;\\n        \\n        while(t1) t1=t1->next, l1++;\\n         while(t2) t2=t2->next,l2++;\\n        int k=abs(l1-l2);\\n        \\n            if(l1>l2) while(k--) headA=headA->next;\\n           else while(k--) headB=headB->next;\\n              while(headA!=headB) headA=headA->next, headB=headB->next;\\n        \\n        return headA;\\n      }\\n\\t//guys plz plz plz upvote my solution if you really like and understand it!!!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "first I find the length of noth the linked lists.\\nthen find the absolute difference of length of linked list.\\nthen traverse the linked list which has more number of nodes upto when the absolute difference between the length of linked list become zero.\\nthen run a while loop upto the noth nofes are equal\\n\\n\\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n            \\n             ListNode *t1=headA,*t2=headB;\\n         \\n        int l1=0,l2=0;\\n        \\n        while(t1) t1=t1->next, l1++;\\n         while(t2) t2=t2->next,l2++;\\n        int k=abs(l1-l2);\\n        \\n            if(l1>l2) while(k--) headA=headA->next;\\n           else while(k--) headB=headB->next;\\n              while(headA!=headB) headA=headA->next, headB=headB->next;\\n        \\n        return headA;\\n      }\\n\\t//guys plz plz plz upvote my solution if you really like and understand it!!!",
                "codeTag": "Unknown"
            },
            {
                "id": 1092883,
                "title": "python-concatenate-lists",
                "content": "# Idea\\nLet\\'s say that the lists can be represented as A+**B** and C+**B** where B is the part of the list that is identical. Then, if we append both lists to the end of the other one we\\'ll have two lists: A+B+C+**B** and C+B+A+**B**. Which means if we iterate over both lists and check for equality of corresponding nodes, we\\'ll spot the repetition when we move into section B for the second time. If there\\'s no intersection we won\\'t spot the equality.\\n## Complexity\\nTime: O(N)\\nMemory: O(1)\\n## Code\\n```\\ndef getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n\\tif not headA or not headB: return None\\n\\ta = headA\\n\\tb = headB\\n\\tswaps = 0\\n\\n\\twhile swaps < 3:\\n\\t\\tif a == b: return a\\n\\t\\ta = a.next\\n\\t\\tb = b.next\\n\\t\\tif not a:\\n\\t\\t\\tswaps += 1\\n\\t\\t\\ta = headB\\n\\t\\tif not b:\\n\\t\\t\\tswaps += 1\\n\\t\\t\\tb = headA\\n\\n\\treturn None\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n\\tif not headA or not headB: return None\\n\\ta = headA\\n\\tb = headB\\n\\tswaps = 0\\n\\n\\twhile swaps < 3:\\n\\t\\tif a == b: return a\\n\\t\\ta = a.next\\n\\t\\tb = b.next\\n\\t\\tif not a:\\n\\t\\t\\tswaps += 1\\n\\t\\t\\ta = headB\\n\\t\\tif not b:\\n\\t\\t\\tswaps += 1\\n\\t\\t\\tb = headA\\n\\n\\treturn None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1056033,
                "title": "c-super-simple-easy-clear-solution-faster-than-98-15-o-n-time-o-1-memory",
                "content": "\\tvoid changeSign(struct ListNode *head){\\n\\t\\twhile ( head )\\n\\t\\t{\\n\\t\\t\\thead->val *= -1;\\n\\t\\t\\thead = head->next;\\n\\t\\t}\\n\\t}\\n\\tstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n\\t\\tchangeSign( headA );\\n\\t\\t\\t\\n\\t\\twhile ( headB )\\n\\t\\t{\\n\\t\\t\\tif ( headB->val < 0 ) break;\\n\\t\\t\\theadB = headB->next;\\n\\t\\t}\\n\\t\\t\\t\\n\\t\\tchangeSign( headA );\\n\\t\\treturn headB;\\n\\t}",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tvoid changeSign(struct ListNode *head){\\n\\t\\twhile ( head )\\n\\t\\t{\\n\\t\\t\\thead->val *= -1;\\n\\t\\t\\thead = head->next;\\n\\t\\t}\\n\\t}\\n\\tstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n\\t\\tchangeSign( headA );\\n\\t\\t\\t\\n\\t\\twhile ( headB )\\n\\t\\t{\\n\\t\\t\\tif ( headB->val < 0 ) break;\\n\\t\\t\\theadB = headB->next;\\n\\t\\t}\\n\\t\\t\\t\\n\\t\\tchangeSign( headA );\\n\\t\\treturn headB;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 940739,
                "title": "simple-python-two-pointer-approach",
                "content": "```\\ndef getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        \\n        hA = headA\\n        hB = headB\\n        \\n        while hA!=hB:\\n            hA = headB if not hA else hA.next\\n            hB = headA if not hB else hB.next\\n        \\n        return hA\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        \\n        hA = headA\\n        hB = headB\\n        \\n        while hA!=hB:\\n            hA = headB if not hA else hA.next\\n            hB = headA if not hB else hB.next\\n        \\n        return hA\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 709523,
                "title": "elegant-cpp-solution-using-stack",
                "content": "I was stuck in this question for quite awhile and then it hit me. So, i tried to solve this question using a stack.\\nPush the nodes (not values) of each linked list into a separate stack. After the intersection point, the nodes will be the same.\\nWhile the stacks are not empty and the top of each stack is the same, pop from each stack.\\nWhen the tops are not equal, the previously popped element (the last equal node) was the intersection point.\\n\\nHere is the code for it:\\n``` \\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        stack<ListNode*> A, B;\\n        ListNode *ptr1=headA, *ptr2=headB, *lastRead=NULL;\\n        while(ptr1) {\\n            A.push(ptr1);\\n            ptr1=ptr1->next;\\n        }\\n        while(ptr2) {\\n            B.push(ptr2);\\n            ptr2=ptr2->next;\\n        }\\n        while(!A.empty() && !B.empty() && (A.top()==B.top())) {\\n            lastRead=A.top();\\n            A.pop();\\n            B.pop();\\n\\n        }\\n        return lastRead;\\n    }\\n};\\n```\\nHope this helped :)",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        stack<ListNode*> A, B;\\n        ListNode *ptr1=headA, *ptr2=headB, *lastRead=NULL;\\n        while(ptr1) {\\n            A.push(ptr1);\\n            ptr1=ptr1->next;\\n        }\\n        while(ptr2) {\\n            B.push(ptr2);\\n            ptr2=ptr2->next;\\n        }\\n        while(!A.empty() && !B.empty() && (A.top()==B.top())) {\\n            lastRead=A.top();\\n            A.pop();\\n            B.pop();\\n\\n        }\\n        return lastRead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691897,
                "title": "python-simple-solution-using-pointers-explained",
                "content": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        ## RC ##\\n        ## APPROACH : 2 POINTER ##\\n        \\n        ## LOGIC ##\\n        # 1) Find the length of both lists;\\n        # 2) In the biggest list, advance its head N times where N is the length difference between the two lists.\\n        # 3) Now both lists have the same length, just iterate them and check for node equality.\\n        \\n\\t\\t## TIME COMPLEXITY : O(M+N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n\\n        la= lb = 0\\n        a , b = headA, headB\\n        \\n        while(headA):\\n            la += 1\\n            headA = headA.next\\n        while(headB):\\n            lb += 1\\n            headB = headB.next\\n                \\n        if( la > lb ):\\n            diff = la - lb\\n            while(diff):\\n                a = a.next\\n                diff -= 1\\n        elif( lb > la ):\\n            diff = lb - la\\n            while(diff):\\n                b = b.next\\n                diff -= 1\\n        \\n        while(a and b):\\n            if(a == b): return a\\n            a = a.next\\n            b = b.next\\n        return None      \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        ## RC ##\\n        ## APPROACH : 2 POINTER ##\\n        \\n        ## LOGIC ##\\n        # 1) Find the length of both lists;\\n        # 2) In the biggest list, advance its head N times where N is the length difference between the two lists.\\n        # 3) Now both lists have the same length, just iterate them and check for node equality.\\n        \\n\\t\\t## TIME COMPLEXITY : O(M+N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n\\n        la= lb = 0\\n        a , b = headA, headB\\n        \\n        while(headA):\\n            la += 1\\n            headA = headA.next\\n        while(headB):\\n            lb += 1\\n            headB = headB.next\\n                \\n        if( la > lb ):\\n            diff = la - lb\\n            while(diff):\\n                a = a.next\\n                diff -= 1\\n        elif( lb > la ):\\n            diff = lb - la\\n            while(diff):\\n                b = b.next\\n                diff -= 1\\n        \\n        while(a and b):\\n            if(a == b): return a\\n            a = a.next\\n            b = b.next\\n        return None      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 386184,
                "title": "easy-100-solution-in-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int len (ListNode* a) {\\n        if (!a) return 0;\\n        int cnt=0;\\n        while (a){\\n            cnt++;\\n            a = a->next;\\n        }\\n        return cnt;\\n    }\\n    \\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if (!headA && !headB) return NULL; \\n        \\n        ListNode* a = headA;\\n        ListNode* b = headB;\\n        \\n        int di = len(headA) - len(headB);\\n        \\n        while (di > 0) {\\n            a = a->next;\\n            di--;\\n        }\\n        while (di < 0) {\\n            b = b->next;\\n            di++;\\n        }\\n        while (a && b) {\\n            if(a == b) return a;\\n            a = a->next;\\n            b = b->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int len (ListNode* a) {\\n        if (!a) return 0;\\n        int cnt=0;\\n        while (a){\\n            cnt++;\\n            a = a->next;\\n        }\\n        return cnt;\\n    }\\n    \\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if (!headA && !headB) return NULL; \\n        \\n        ListNode* a = headA;\\n        ListNode* b = headB;\\n        \\n        int di = len(headA) - len(headB);\\n        \\n        while (di > 0) {\\n            a = a->next;\\n            di--;\\n        }\\n        while (di < 0) {\\n            b = b->next;\\n            di++;\\n        }\\n        while (a && b) {\\n            if(a == b) return a;\\n            a = a->next;\\n            b = b->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 50037,
                "title": "my-accepted-java-solution-with-o-n-time-and-o-1-space",
                "content": "    public class Solution {\\n        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n            if(headA == null || headB == null)\\n                return null;\\n                \\n            ListNode currA = headA, currB = headB;\\n            ListNode lastElementA = null, lastElementB = null;\\n            \\n            while(currA != currB) {\\n                if(lastElementA != null && lastElementB != null && lastElementA != lastElementB)\\n                    return null;\\n                if(currA.next == null) {\\n                    lastElementA = currA;\\n                    currA = headB;\\n                } else\\n                    currA = currA.next;\\n                    \\n                if(currB.next == null) {\\n                    lastElementB = currB;\\n                    currB = headA;\\n                } else\\n                    currB = currB.next;\\n            }\\n            \\n            return currA;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n            if(headA == null || headB == null)\\n                return null;\\n                \\n            ListNode currA = headA, currB = headB;\\n            ListNode lastElementA = null, lastElementB = null;\\n            \\n            while(currA != currB) {\\n                if(lastElementA != null && lastElementB != null && lastElementA != lastElementB)\\n                    return null;\\n                if(currA.next == null) {\\n                    lastElementA = currA;\\n                    currA = headB;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2118449,
                "title": "js-two-pointers-o-m-n-no-extra-space-explained-with-drawing",
                "content": "The idea behind this apporoach is that if one list intersects with another, this intersection will be the end of the lists, meaning its tails is a candidate for intersaction. But how would you align two pointers so that they both reach the end at the same time? You could find last nodes for each list first and then go backward but there is a faster way for the case where two lists intersects.\\n\\nLook at how rearranging the terms does not change the sum:\\n```\\n4 + 6 = 10\\n6 + 4 = 10\\n```\\n\\nSame with lists but we need to go through each node and flip pointers at the end of the lists. There won\\'t be a second flip (endless loop) because it will end either on \\'same node found\\' or on `null === null`.\\n```\\npointer1 goes: list1 null list2 null\\npointer2 goes: list2 null list1 null\\n```\\n\\nTwo examples (without and with intersection):\\n![image](https://assets.leetcode.com/users/images/8c216e8e-c53c-402f-a173-500e1b0215da_1654520230.127595.jpeg)\\n*notice how pointers aligned at the end\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} headA\\n * @param {ListNode} headB\\n * @return {ListNode}\\n */\\nvar getIntersectionNode = function(headA, headB) {\\n  let pointerA = headA;\\n  let pointerB = headB;\\n  \\n  while (pointerA !== pointerB) {\\n    pointerA = pointerA ? pointerA.next : headB;\\n    pointerB = pointerB ? pointerB.next : headA;\\n  }\\n  \\n  return pointerA;\\n};\\n```\\n\\nYou could experiment on paper with different lists. It\\'ll help visualise how simple this idea is.",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n4 + 6 = 10\\n6 + 4 = 10\\n```\n```\\npointer1 goes: list1 null list2 null\\npointer2 goes: list2 null list1 null\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} headA\\n * @param {ListNode} headB\\n * @return {ListNode}\\n */\\nvar getIntersectionNode = function(headA, headB) {\\n  let pointerA = headA;\\n  let pointerB = headB;\\n  \\n  while (pointerA !== pointerB) {\\n    pointerA = pointerA ? pointerA.next : headB;\\n    pointerB = pointerB ? pointerB.next : headA;\\n  }\\n  \\n  return pointerA;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1097119,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode a = headA,\\n                 b = headB;\\n        \\n        while (a != b)\\n        {\\n            a = a == null ? headB : a.next;\\n            b = b == null ? headA : b.next;\\n        }\\n        \\n        return a;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode a = headA,\\n                 b = headB;\\n        \\n        while (a != b)\\n        {\\n            a = a == null ? headB : a.next;\\n            b = b == null ? headA : b.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 465978,
                "title": "is-this-question-correct",
                "content": "how can you tell if it should return 8 or 1, if test cases are below.. \\n```\\n8\\n[4,1,8,4,5]\\n[5,0,1,8,4,5]\\n2\\n3\\n```\\nor \\n```\\n1\\n[4,1,8,4,5]\\n[5,0,1,8,4,5]\\n1\\n2\\n```",
                "solutionTags": [],
                "code": "```\\n8\\n[4,1,8,4,5]\\n[5,0,1,8,4,5]\\n2\\n3\\n```\n```\\n1\\n[4,1,8,4,5]\\n[5,0,1,8,4,5]\\n1\\n2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 224592,
                "title": "concise-7-line-c-solution",
                "content": "```c\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n    if (!headA || !headB) return NULL;\\n    struct ListNode *ptr1 = headA, *ptr2 = headB;\\n    while (ptr1 != ptr2) {\\n        ptr1 = ptr1 ? ptr1->next : headB;\\n        ptr2 = ptr2 ? ptr2->next : headA;\\n    }\\n    return ptr1;\\n}\\n```\\nHappy coding~",
                "solutionTags": [],
                "code": "```c\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n    if (!headA || !headB) return NULL;\\n    struct ListNode *ptr1 = headA, *ptr2 = headB;\\n    while (ptr1 != ptr2) {\\n        ptr1 = ptr1 ? ptr1->next : headB;\\n        ptr2 = ptr2 ? ptr2->next : headA;\\n    }\\n    return ptr1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 49972,
                "title": "clean-java-solution-o-m-n-time-o-1-space",
                "content": "    public class Solution {\\n      \\n      public ListNode getIntersectionNode(ListNode l1, ListNode l2) {\\n        if (l1 == null || l2 == null) return null;\\n        \\n        // step 1. count the two lists\\n        int n1 = count(l1), n2 = count(l2);\\n        \\n        // step 2. move the longer one |n1 - n2| steps\\n        int n = Math.abs(n1 - n2);\\n        \\n        while (n-- > 0) {\\n          if (n1 > n2)\\n            l1 = l1.next;\\n          else\\n            l2 = l2.next;\\n        }\\n        \\n        // step 3. move together and find the meeting point\\n        while (l1 != l2) {\\n          l1 = l1.next;\\n          l2 = l2.next;\\n        }\\n        \\n        return l1;\\n      }\\n      \\n      int count(ListNode l) {\\n        int n = 0;\\n        while (l != null) {\\n          n++;\\n          l = l.next;\\n        }\\n        return n;\\n      }\\n    \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      \\n      public ListNode getIntersectionNode(ListNode l1, ListNode l2) {\\n        if (l1 == null || l2 == null) return null;\\n        \\n        // step 1. count the two lists\\n        int n1 = count(l1), n2 = count(l2);\\n        \\n        // step 2. move the longer one |n1 - n2| steps\\n        int n = Math.abs(n1 - n2);\\n        \\n        while (n-- > 0) {\\n          if (n1 > n2)\\n            l1 = l1.next;\\n          else\\n            l2 = l2.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3810022,
                "title": "most-optimum-sc-o-1-c-easily-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Compare on the basis of length\\n- The one which is longer, traverse it until the length become equal in both\\n- After that we\\'ll traverse each listnode one by one, if both heads (headA and headB) collides return that listnode.\\n- Else return null, no intersection.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The base case if definitely if any of the head is NULL,\\n-  Return NULL, i.e no intersection.\\n- For comparing we can implement a separate function.\\n- Then implement as intution says.\\n\\n# Complexity\\n- Time complexity: O(m+n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int length(ListNode* head){\\n        if(head==NULL)return 0;\\n        int count=0;\\n        while(head){\\n            count++;\\n            head = head->next;\\n        }\\n        return count;\\n    }\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if(headA == NULL || headB == NULL)return NULL;\\n        int lenA = length(headA),lenB = length(headB);\\n\\n        if(lenA > lenB){\\n            while(lenA > lenB){\\n                headA = headA->next;\\n                lenA--;\\n            }\\n        }\\n        if(lenB > lenA){\\n            while(lenB > lenA){\\n                headB = headB->next;\\n                lenB--;\\n            }\\n        }\\n\\n        while(headA && headB){\\n            if(headA == headB) return headA;\\n            headA = headA->next;\\n            headB = headB->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int length(ListNode* head){\\n        if(head==NULL)return 0;\\n        int count=0;\\n        while(head){\\n            count++;\\n            head = head->next;\\n        }\\n        return count;\\n    }\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if(headA == NULL || headB == NULL)return NULL;\\n        int lenA = length(headA),lenB = length(headB);\\n\\n        if(lenA > lenB){\\n            while(lenA > lenB){\\n                headA = headA->next;\\n                lenA--;\\n            }\\n        }\\n        if(lenB > lenA){\\n            while(lenB > lenA){\\n                headB = headB->next;\\n                lenB--;\\n            }\\n        }\\n\\n        while(headA && headB){\\n            if(headA == headB) return headA;\\n            headA = headA->next;\\n            headB = headB->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723547,
                "title": "simplest-and-best-approach-using-hashset-please-upvote-it-s-my-first-submission",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        // ListNode temp1=headA;\\n        // ListNode temp2=headB;\\n        // while(temp1!=temp2){\\n        //     if(temp1==null){\\n        //         temp1=headB;\\n        //     }else{\\n        //         temp1=temp1.next;\\n        //     }\\n        //     if(temp2==null){\\n        //         temp2=headA;\\n        //     }else{\\n        //         temp2=temp2.next;\\n        //     }\\n        // }\\n        // return temp1;\\n        Set<ListNode> hs=new HashSet<>();\\n        while(headA!=null ){\\n            hs.add(headA);\\n                headA=headA.next;\\n            }\\n         while(headB!=null){\\n             if(hs.contains(headB))\\n             return headB;\\n             headB=headB.next;\\n         }   \\n\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        // ListNode temp1=headA;\\n        // ListNode temp2=headB;\\n        // while(temp1!=temp2){\\n        //     if(temp1==null){\\n        //         temp1=headB;\\n        //     }else{\\n        //         temp1=temp1.next;\\n        //     }\\n        //     if(temp2==null){\\n        //         temp2=headA;\\n        //     }else{\\n        //         temp2=temp2.next;\\n        //     }\\n        // }\\n        // return temp1;\\n        Set<ListNode> hs=new HashSet<>();\\n        while(headA!=null ){\\n            hs.add(headA);\\n                headA=headA.next;\\n            }\\n         while(headB!=null){\\n             if(hs.contains(headB))\\n             return headB;\\n             headB=headB.next;\\n         }   \\n\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553604,
                "title": "3-different-approches-using-c-optimal-and-short",
                "content": "# Approach 1 - Using hashmap\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n--> We will create a unordered_map and send all the nodes of listA and mark them as true.\\n--> Now, we will traverse the nodes of listB and check whether the address of node in listB is present in map or not.\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n+m)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        // using hashmap;\\n        unordered_map<ListNode*, bool> map;\\n        ListNode* curr = headA;\\n        while(curr != NULL){\\n            map[curr] = true;\\n            curr = curr->next;\\n        }\\n        curr = headB;\\n        while(curr){\\n            if(map[curr] == true){\\n                return curr;\\n            }\\n            curr = curr->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n# Approach - 2 by finding the length of the lists.\\n--> We will find the length of both the lists by traversing them. Lets say we got length of listA as n and listB as m.\\n--> Now, whoever have the longest nodes, we will traverse until abs(n-m) distance, because after traversing them we will find both start at equal distance from the intersection node. \\n--> Now, we will traverse both the nodes while both of them or not equal. We will basically return one of the node which we are traversing, because if we found equal that will be the node which we have to return, else if no itersection found, then obviously at NULL they are going to be equal, so directly what we return will be a NULL.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(2*max(n,m))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        int Acount = 0, Bcount = 0;\\n        ListNode* A= headA;\\n        ListNode *B = headB;\\n        while(A || B){\\n            if(A){\\n                Acount++;\\n                A = A->next;\\n            }\\n            if(B){\\n                Bcount++;\\n                B = B->next;\\n            }\\n        }\\n        ListNode *p1 = (Acount > Bcount)? headA : headB;\\n        ListNode *p2 = (p1 == headA)?headB : headA;\\n\\n        int diff = abs(Acount - Bcount);\\n        for(int i = 0; i<diff; i++){\\n            p1 = p1->next;\\n        }\\n        while(p1 != p2){\\n            p1 = p1->next;\\n            p2 = p2->next;\\n        }\\n        return p1;\\n\\n    }\\n};\\n```\\n# Approach - 3: Optimal and short\\n--> So, the approach is interesting, we will traverse the temporary node p1 for listA and p2 for listB. So, once any of the p1 or p2 reaches the NULL, we will start traversing the node from another list.\\nExample -\\n![image.png](https://assets.leetcode.com/users/images/4d5b9a30-0979-440f-8405-ffda80da39e5_1684766210.5942867.png)\\n\\nSo, ListA conatains 4 -> 1 -> 8 -> 4 -> 5, ListB contains 5 -> 6 -> 1 -> 8 -> 4 -> 5\\n\\nSo, p1 traverses through ListA and p2 through ListB. Now, as p1 reaches Null p2 will be at Node value 4. So we will point the p1 to headB. Then when p2 reaches NUll, p1 will be at Node value 6 and we will point p2 to Head of ListA. Now, they are at same distance from the intersection point. As we traverse now, we will get the point where they are equal. So we will return p1 node(can do p2 as well as they both will be equal).\\n\\n# Time Complexity:\\n$$O(n+m)$$\\n\\n# Space Complexity:\\n$$O(1)$$ \\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *p1 = headA, *p2 = headB;\\n        while(p1 != p2){\\n            p1 = p1 ? p1->next : headB;\\n            p2 = p2 ? p2->next : headA;\\n        }\\n        return p1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        // using hashmap;\\n        unordered_map<ListNode*, bool> map;\\n        ListNode* curr = headA;\\n        while(curr != NULL){\\n            map[curr] = true;\\n            curr = curr->next;\\n        }\\n        curr = headB;\\n        while(curr){\\n            if(map[curr] == true){\\n                return curr;\\n            }\\n            curr = curr->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        int Acount = 0, Bcount = 0;\\n        ListNode* A= headA;\\n        ListNode *B = headB;\\n        while(A || B){\\n            if(A){\\n                Acount++;\\n                A = A->next;\\n            }\\n            if(B){\\n                Bcount++;\\n                B = B->next;\\n            }\\n        }\\n        ListNode *p1 = (Acount > Bcount)? headA : headB;\\n        ListNode *p2 = (p1 == headA)?headB : headA;\\n\\n        int diff = abs(Acount - Bcount);\\n        for(int i = 0; i<diff; i++){\\n            p1 = p1->next;\\n        }\\n        while(p1 != p2){\\n            p1 = p1->next;\\n            p2 = p2->next;\\n        }\\n        return p1;\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *p1 = headA, *p2 = headB;\\n        while(p1 != p2){\\n            p1 = p1 ? p1->next : headB;\\n            p2 = p2 ? p2->next : headA;\\n        }\\n        return p1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422844,
                "title": "c-solution-o-n-m",
                "content": "# Code\\n```\\n\\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n    if (headA == NULL || headB == NULL)\\n        return NULL;\\n\\n    struct ListNode* A = headA;\\n    struct ListNode* B = headB;\\n\\n    while (A != B) {\\n        A = A == NULL ? headB : A->next;\\n        B = B == NULL ? headA : B->next;\\n    }\\n\\n    return A;\\n    \\n}\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n    if (headA == NULL || headB == NULL)\\n        return NULL;\\n\\n    struct ListNode* A = headA;\\n    struct ListNode* B = headB;\\n\\n    while (A != B) {\\n        A = A == NULL ? headB : A->next;\\n        B = B == NULL ? headA : B->next;\\n    }\\n\\n    return A;\\n    \\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3343069,
                "title": "c-easy-solution-using-unordered-map",
                "content": "# Intuition\\nWe will use maps to solve this one.\\n\\n# Approach\\n- Create an unordered_map of ListNode* and let\\'s just take int for the value.\\n- then transfer all the nodes of first LL in the map.\\n- then traverse the seconf LL and check if a node from second LL is present in the map.\\n- if there is one node present, then return that one.\\n- else there is no intersection in the linked list, so return NULL.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mp;\\n\\n        ListNode* temp = headA;\\n\\n        //LL A nodes stored inside the map\\n        while(temp){\\n            mp[temp]++;\\n            temp = temp->next;\\n        }\\n\\n        //LL B traversal\\n        temp = headB;\\n        while(temp){\\n            if(mp.find(temp) != mp.end())\\n                return temp;\\n\\n            temp = temp->next;\\n        }\\n\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mp;\\n\\n        ListNode* temp = headA;\\n\\n        //LL A nodes stored inside the map\\n        while(temp){\\n            mp[temp]++;\\n            temp = temp->next;\\n        }\\n\\n        //LL B traversal\\n        temp = headB;\\n        while(temp){\\n            if(mp.find(temp) != mp.end())\\n                return temp;\\n\\n            temp = temp->next;\\n        }\\n\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050410,
                "title": "java-3-approaches-explained",
                "content": "**FIRST APPROACH**\\n\\n        // BRUTE FORCE APPROACH\\n        \\n        // We will take any of the linked list, and will compare each and every node of the other list with that - in order to determine if the nodes are equal - if they are equal for the first time - then it is our intersection point - if we reach to the null - there is no intersection\\n        \\n        ListNode tempA = headA;\\n        \\n        while(tempA != null)\\n        {\\n            ListNode tempB = headB;\\n            \\n            while(tempB != null)\\n            {\\n                if(tempA == tempB)\\n                {\\n                    return tempA;\\n                }\\n                tempB = tempB.next;\\n            }\\n            tempA = tempA.next;\\n        }\\n        \\n        return null;\\n\\n**SECOND APPROACH**\\n\\n        // OPTIMISED SOLUTION\\n        \\n        // We will calculate the lengths of the linked list 1 and 2, and then take out their difference - we can then move difference steps ahead from the smaller linked list - to get to our intersection point\\n        \\n        ListNode tempA = headA;\\n        ListNode tempB = headB;\\n        \\n        int sizeA = 0, sizeB = 0;\\n        \\n        while(tempA != null)\\n        {\\n            sizeA++;\\n            tempA = tempA.next;\\n        }\\n        \\n        while(tempB != null)\\n        {\\n            sizeB++;\\n            tempB = tempB.next;\\n        }\\n        \\n        // System.out.println(\"size a : \" + sizeA + \" size b: \" + sizeB);\\n        \\n        if(sizeA <= sizeB)\\n        {\\n            // list A is small\\n            int difference = sizeB - sizeA;\\n            \\n            int steps = difference;\\n            \\n            while(steps != 0)\\n            {\\n                headB = headB.next;\\n                steps--;\\n            }\\n            \\n            while(headA != null && headB != null)\\n            {\\n                if(headA == headB)\\n                {\\n                    return headA;\\n                }\\n                headA = headA.next;\\n                headB = headB.next;\\n            }\\n        \\n            return null;\\n        }\\n        else\\n        {\\n            // list B is small\\n            int difference = sizeA - sizeB;\\n            \\n            int steps = difference;\\n            \\n            while(steps != 0)\\n            {\\n                headA = headA.next;\\n                steps--;\\n            }\\n            \\n            while(headA != null && headB != null)\\n            {\\n                if(headA == headB)\\n                {\\n                    return headA;\\n                }\\n                headA = headA.next;\\n                headB = headB.next;\\n            }\\n        \\n            return null;\\n        }\\n\\t\\t\\n**THIRD APPROACH**\\n\\n        // OPTIMISED - BETTER SOLUTION \\n        \\n        // Here, the algorithm is - we will have a tempA pointing at the head of the list 1, and tempB at list 2. We will keep on traversing them one step at a time, and when either of the temp reaches null we will assign it to the head of the other list\\n        \\n        // so if tempA reaches null, we will re assign it as headB\\n        // else if tempB reaches null, assign it as headA\\n        \\n        // By this, we will come to a point were both of the tempa and tempB will be synchronised and will reach the interesection point at the same time - by pointing to the same node\\n        \\n        // As an edge case, even if there is no interesction both the temp\\'s will be pointing at null together\\n        \\n        // The intution behind this algo is that, when one list is small and other is big, the big will still be in its list, and the small would be done wd its list. So, we can observe that now the big is difference of the size (length of the lists) away from null. So, we will begin the traversal of the temp nodes from different heads so that they can be in sync. - as our previous approach.\\n        \\n        if(headA == null || headB == null)\\n        {\\n            return null;    // no intersection is possible\\n        }\\n        \\n        ListNode tempA = headA;\\n        ListNode tempB = headB;\\n        \\n        while(tempA != tempB)\\n        {\\n            if(tempA == null)\\n            {\\n                tempA = headB;\\n            }\\n            else\\n            {\\n                tempA = tempA.next;\\n            }\\n            \\n            if(tempB == null)\\n            {\\n                tempB = headA;\\n            }\\n            else\\n            {\\n                tempB = tempB.next;\\n            }\\n        }\\n        \\n        return tempA;\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "**FIRST APPROACH**\\n\\n        // BRUTE FORCE APPROACH\\n        \\n        // We will take any of the linked list, and will compare each and every node of the other list with that - in order to determine if the nodes are equal - if they are equal for the first time - then it is our intersection point - if we reach to the null - there is no intersection\\n        \\n        ListNode tempA = headA;\\n        \\n        while(tempA != null)\\n        {\\n            ListNode tempB = headB;\\n            \\n            while(tempB != null)\\n            {\\n                if(tempA == tempB)\\n                {\\n                    return tempA;\\n                }\\n                tempB = tempB.next;\\n            }\\n            tempA = tempA.next;\\n        }\\n        \\n        return null;\\n\\n**SECOND APPROACH**\\n\\n        // OPTIMISED SOLUTION\\n        \\n        // We will calculate the lengths of the linked list 1 and 2, and then take out their difference - we can then move difference steps ahead from the smaller linked list - to get to our intersection point\\n        \\n        ListNode tempA = headA;\\n        ListNode tempB = headB;\\n        \\n        int sizeA = 0, sizeB = 0;\\n        \\n        while(tempA != null)\\n        {\\n            sizeA++;\\n            tempA = tempA.next;\\n        }\\n        \\n        while(tempB != null)\\n        {\\n            sizeB++;\\n            tempB = tempB.next;\\n        }\\n        \\n        // System.out.println(\"size a : \" + sizeA + \" size b: \" + sizeB);\\n        \\n        if(sizeA <= sizeB)\\n        {\\n            // list A is small\\n            int difference = sizeB - sizeA;\\n            \\n            int steps = difference;\\n            \\n            while(steps != 0)\\n            {\\n                headB = headB.next;\\n                steps--;\\n            }\\n            \\n            while(headA != null && headB != null)\\n            {\\n                if(headA == headB)\\n                {\\n                    return headA;\\n                }\\n                headA = headA.next;\\n                headB = headB.next;\\n            }\\n        \\n            return null;\\n        }\\n        else\\n        {\\n            // list B is small\\n            int difference = sizeA - sizeB;\\n            \\n            int steps = difference;\\n            \\n            while(steps != 0)\\n            {\\n                headA = headA.next;\\n                steps--;\\n            }\\n            \\n            while(headA != null && headB != null)\\n            {\\n                if(headA == headB)\\n                {\\n                    return headA;\\n                }\\n                headA = headA.next;\\n                headB = headB.next;\\n            }\\n        \\n            return null;\\n        }\\n\\t\\t\\n**THIRD APPROACH**\\n\\n        // OPTIMISED - BETTER SOLUTION \\n        \\n        // Here, the algorithm is - we will have a tempA pointing at the head of the list 1, and tempB at list 2. We will keep on traversing them one step at a time, and when either of the temp reaches null we will assign it to the head of the other list\\n        \\n        // so if tempA reaches null, we will re assign it as headB\\n        // else if tempB reaches null, assign it as headA\\n        \\n        // By this, we will come to a point were both of the tempa and tempB will be synchronised and will reach the interesection point at the same time - by pointing to the same node\\n        \\n        // As an edge case, even if there is no interesction both the temp\\'s will be pointing at null together\\n        \\n        // The intution behind this algo is that, when one list is small and other is big, the big will still be in its list, and the small would be done wd its list. So, we can observe that now the big is difference of the size (length of the lists) away from null. So, we will begin the traversal of the temp nodes from different heads so that they can be in sync. - as our previous approach.\\n        \\n        if(headA == null || headB == null)\\n        {\\n            return null;    // no intersection is possible\\n        }\\n        \\n        ListNode tempA = headA;\\n        ListNode tempB = headB;\\n        \\n        while(tempA != tempB)\\n        {\\n            if(tempA == null)\\n            {\\n                tempA = headB;\\n            }\\n            else\\n            {\\n                tempA = tempA.next;\\n            }\\n            \\n            if(tempB == null)\\n            {\\n                tempB = headA;\\n            }\\n            else\\n            {\\n                tempB = tempB.next;\\n            }\\n        }\\n        \\n        return tempA;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1484415,
                "title": "python-2-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: HashMap**\\n```python\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        seen = set()\\n        while headA != None:\\n            seen.add(headA)\\n            headA = headA.next\\n            \\n        while headB != None:\\n            if headB in seen:\\n                return headB\\n            headB = headB.next\\n        return None\\n```\\nComplexity:\\n- Time: `O(M + N)`, where `M <= 3*10^4` is length of listA, `N <= 3*10^4` is length of listB.\\n- Space: `O(M)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Loop listA + listB**\\n```python\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        pA = headA\\n        pB = headB\\n        while pA != pB:\\n            pA = pA.next if pA else headB\\n            pB = pB.next if pB else headA\\n        return pA\\n```\\nComplexity:\\n- Time: `O(M + N)`, where `M <= 3*10^4` is length of listA, `N <= 3*10^4` is length of listB.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        seen = set()\\n        while headA != None:\\n            seen.add(headA)\\n            headA = headA.next\\n            \\n        while headB != None:\\n            if headB in seen:\\n                return headB\\n            headB = headB.next\\n        return None\\n```\n```python\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        pA = headA\\n        pB = headB\\n        while pA != pB:\\n            pA = pA.next if pA else headB\\n            pB = pB.next if pB else headA\\n        return pA\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360094,
                "title": "4-approaches-c",
                "content": "# Method 1(Simply use two loops) \\n\\n* Use 2 nested for loops. \\n* The outer loop will be for each node of the 1st list and inner loop will be for 2nd list. \\n* In the inner loop, check if any of nodes of the 2nd list is same as the current node of the first linked list.\\n* **So for each node for 1st loop we traverse all nodes of second list to find if any of them are equal**\\n* The time complexity of this method will be O(M * N) where m and n are the numbers of nodes in two lists.\\n\\n# Method 2 Hashing O(N) time and O(N) space\\n**Remember to insert the address of the nodes not value**\\n\\n```\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_set<ListNode*>s;\\n        while(headA){\\n            s.insert(headA);\\n            headA=headA->next;\\n        }\\n        while(headB){\\n            if(s.find(headB)!=s.end())\\n                return headB;\\n            headB=headB->next;\\n        }\\n        return NULL;\\n    }\\n```\\n\\n# Method 3(Using difference of node counts) O(N) time and O(1) space\\n\\n* Get count of the nodes in the first list, let count be c1.\\n* Get count of the nodes in the second list, let count be c2.\\n* Get the difference of counts d = abs(c1 \\u2013 c2)\\n* Now traverse the bigger list from the first node till d nodes so that from here onwards both the lists have equal no of nodes\\n* Then we can traverse both the lists in parallel till we come across a common node. (Note that getting a common node is done by comparing the address of the nodes)\\n\\n```\\nListNode* getIntersectionNode(ListNode headA, ListNode headB) {\\n    int lenA = count(headA), lenB = count(headB);         // implement this on your own !\\n\\t\\n    // move headA and headB to the same start point\\n    while (lenA > lenB) {\\n        headA = headA.next;\\n        lenA--;\\n    }\\n    while (lenA < lenB) {\\n        headB = headB.next;\\n        lenB--;\\n    }\\n \\n    while (headA != headB) {\\n        headA = headA.next;\\n        headB = headB.next;\\n    }\\n    return headA;\\n}\\n```\\n\\n# Method 4 (Most Optimal) O(N) time and O(1) space\\n```\\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        \\n    if(headA == NULL || headB == NULL) return NULL;\\n    \\n    ListNode* a = headA;\\n    ListNode* b = headB;\\n    \\n  \\n    while( a != b){\\n    \\n        a = a == NULL ? headB : a->next;\\n        b = b == NULL ? headA : b->next;    \\n    }\\n    \\n    return a;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_set<ListNode*>s;\\n        while(headA){\\n            s.insert(headA);\\n            headA=headA->next;\\n        }\\n        while(headB){\\n            if(s.find(headB)!=s.end())\\n                return headB;\\n            headB=headB->next;\\n        }\\n        return NULL;\\n    }\\n```\n```\\nListNode* getIntersectionNode(ListNode headA, ListNode headB) {\\n    int lenA = count(headA), lenB = count(headB);         // implement this on your own !\\n\\t\\n    // move headA and headB to the same start point\\n    while (lenA > lenB) {\\n        headA = headA.next;\\n        lenA--;\\n    }\\n    while (lenA < lenB) {\\n        headB = headB.next;\\n        lenB--;\\n    }\\n \\n    while (headA != headB) {\\n        headA = headA.next;\\n        headB = headB.next;\\n    }\\n    return headA;\\n}\\n```\n```\\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        \\n    if(headA == NULL || headB == NULL) return NULL;\\n    \\n    ListNode* a = headA;\\n    ListNode* b = headB;\\n    \\n  \\n    while( a != b){\\n    \\n        a = a == NULL ? headB : a->next;\\n        b = b == NULL ? headA : b->next;    \\n    }\\n    \\n    return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1349261,
                "title": "js-3-o-n-solutions-with-comments",
                "content": "**Solution 1:**\\n\\n```\\nvar getIntersectionNode = function(headA, headB) {\\n    const set = new Set();    // This set will store all the nodes that are encountered while traversing the first LL\\n    let curr = headA;\\n    while(curr) {\\n        set.add(curr);\\n        curr = curr.next;\\n    }\\n    curr = headB;\\n    while(curr && !set.has(curr)) {    // the loop will break when we find the intersection node or if there is no intersection\\n        curr = curr.next;\\n    }\\n    return curr;\\n};\\n```\\nTime Complexity = O(m + n)\\nSpace Complexity = O(m)\\n\\n----\\n\\n**Solution 2:**\\n\\n```\\n// TC = O(m + n); SC = O(1)\\nvar getIntersectionNode = function(headA, headB) {\\n    let lenA = 0,\\n        lenB = 0,\\n        currA = headA,\\n        currB = headB;\\n    \\n    // find length of List A and List B\\n    while(currA) {\\n        ++lenA;\\n        currA = currA.next;\\n    }\\n    while(currB) {\\n        ++lenB;\\n        currB = currB.next;\\n    }\\n    \\n    // move the longer list steps equal to the difference between their lengths\\n    currA = headA;\\n    while(lenA > lenB) {\\n        currA = currA.next;\\n        --lenA;\\n    }\\n    currB = headB;\\n    while(lenA < lenB) {\\n        currB = currB.next;\\n        --lenB;\\n    }\\n    \\n    // move both pointer one step at a time until they meet at the intersection or both are equal to null\\n    // since from the start of this loop, both will have to move same distance until they reach the end\\n    while(currA !== currB) {\\n        currA = currA.next;\\n        currB = currB.next;   \\n    }\\n    return currA;\\n};\\n```\\n\\nTime Complexity = O(m + n) ~ O(n)\\nSpace Complexity = O(1)\\n\\nThis solution will traverse (m + n + max(m, n)) steps.\\n\\n----\\n\\n**Solution 3:**\\n\\n```\\n// TC = O(m + n); SC = O(1)\\nvar getIntersectionNode = function(headA, headB) {\\n    let currA = headA,\\n        currB = headB;\\n    \\n    // start both pointer from the start of the linked lists\\n    // when the smaller list pointer reaches end, we start it from the beginning of the longer list\\n    // and when the longer list reaches end, we start it from the beginning of the smaller list\\n    // so basically both the pointers traverse at-max (m + n) steps until they either meet at the intersection\\n    // or at the end (null)\\n    while(currA !== currB) {\\n        if(!currA) {\\n            currA = headB;\\n        } else {\\n            currA = currA.next;\\n        }\\n        if(!currB) {\\n            currB = headA;\\n        } else {\\n            currB = currB.next;\\n        }\\n    }\\n    return currA;\\n}\\n```\\n\\nTime Complexity = O(m + n) ~ O(n)\\nSpace Complexity = O(1)\\n\\nThis solution will traverse (m + n) steps.",
                "solutionTags": [
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nvar getIntersectionNode = function(headA, headB) {\\n    const set = new Set();    // This set will store all the nodes that are encountered while traversing the first LL\\n    let curr = headA;\\n    while(curr) {\\n        set.add(curr);\\n        curr = curr.next;\\n    }\\n    curr = headB;\\n    while(curr && !set.has(curr)) {    // the loop will break when we find the intersection node or if there is no intersection\\n        curr = curr.next;\\n    }\\n    return curr;\\n};\\n```\n```\\n// TC = O(m + n); SC = O(1)\\nvar getIntersectionNode = function(headA, headB) {\\n    let lenA = 0,\\n        lenB = 0,\\n        currA = headA,\\n        currB = headB;\\n    \\n    // find length of List A and List B\\n    while(currA) {\\n        ++lenA;\\n        currA = currA.next;\\n    }\\n    while(currB) {\\n        ++lenB;\\n        currB = currB.next;\\n    }\\n    \\n    // move the longer list steps equal to the difference between their lengths\\n    currA = headA;\\n    while(lenA > lenB) {\\n        currA = currA.next;\\n        --lenA;\\n    }\\n    currB = headB;\\n    while(lenA < lenB) {\\n        currB = currB.next;\\n        --lenB;\\n    }\\n    \\n    // move both pointer one step at a time until they meet at the intersection or both are equal to null\\n    // since from the start of this loop, both will have to move same distance until they reach the end\\n    while(currA !== currB) {\\n        currA = currA.next;\\n        currB = currB.next;   \\n    }\\n    return currA;\\n};\\n```\n```\\n// TC = O(m + n); SC = O(1)\\nvar getIntersectionNode = function(headA, headB) {\\n    let currA = headA,\\n        currB = headB;\\n    \\n    // start both pointer from the start of the linked lists\\n    // when the smaller list pointer reaches end, we start it from the beginning of the longer list\\n    // and when the longer list reaches end, we start it from the beginning of the smaller list\\n    // so basically both the pointers traverse at-max (m + n) steps until they either meet at the intersection\\n    // or at the end (null)\\n    while(currA !== currB) {\\n        if(!currA) {\\n            currA = headB;\\n        } else {\\n            currA = currA.next;\\n        }\\n        if(!currB) {\\n            currB = headA;\\n        } else {\\n            currB = currB.next;\\n        }\\n    }\\n    return currA;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1093180,
                "title": "c-magic-solution-o-n-time-o-1-space",
                "content": "```\\nvoid changeSign(struct ListNode *head){\\n    while ( head )\\n    {\\n        head->val *= -1;\\n        head = head->next;\\n    }\\n}\\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n    changeSign( headA );\\n        \\n    while ( headB )\\n    {\\n        if ( headB->val < 0 ) break;\\n        headB = headB->next;\\n    }\\n        \\n    changeSign( headA );\\n    return headB;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid changeSign(struct ListNode *head){\\n    while ( head )\\n    {\\n        head->val *= -1;\\n        head = head->next;\\n    }\\n}\\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\\n    changeSign( headA );\\n        \\n    while ( headB )\\n    {\\n        if ( headB->val < 0 ) break;\\n        headB = headB->next;\\n    }\\n        \\n    changeSign( headA );\\n    return headB;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1092926,
                "title": "intersection-of-two-linked-lists-c-simple-with-idea",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n       ListNode *pA = headA, *pB = headB;\\n        while (pA != pB) {\\n            pA = pA ? pA->next : headB;\\n            pB = pB ? pB->next : headA;\\n        }\\n        return pA;\\n    } \\n};\\n```\\n\\nUsing Two pointers :\\nInitialize two pointers ptr1 and ptr2  at the head1 and  head2.\\nTraverse through the lists,one node at a time.\\nWhen ptr1 reaches the end of a list, then redirect it to the head2.\\nsimilarly when ptr2 reaches the end of a list, redirect it the head1.\\nOnce both of them go through reassigning,hey will be equidistant from\\n the collision point\\nIf at any node ptr1 meets ptr2, then it is the intersection node.\\nAfter second iteration if there is no intersection node it returns NULL.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n       ListNode *pA = headA, *pB = headB;\\n        while (pA != pB) {\\n            pA = pA ? pA->next : headB;\\n            pB = pB ? pB->next : headA;\\n        }\\n        return pA;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802204,
                "title": "javascript-solution-160",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} headA\\n * @param {ListNode} headB\\n * @return {ListNode}\\n */\\nlet getIntersectionNode = function(headA, headB) {\\n    if(headA===null || headB===null) {\\n        return null;\\n    }\\n    let r1=headA;\\n    let r2=headB;\\n    while(r1!==r2){\\n        r1=r1.next;\\n        r2=r2.next;\\n        if(r1===r2){\\n           return r1;\\n        }\\n        if (r1===null){\\n          r1=headB;  \\n        }\\n        if(r2===null){\\n            r2=headA;\\n        }\\n    }\\n    return r1;\\n};\\n```\\n\\n**Runtime: 96 ms, faster than 90.42% of JavaScript online submissions for Intersection of Two Linked Lists.**\\n\\n**Memory Usage: 43.7 MB, less than 58.14% of JavaScript online submissions for Intersection of Two Linked Lists.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n\\n/**\\n * @param {ListNode} headA\\n * @param {ListNode} headB\\n * @return {ListNode}\\n */\\nlet getIntersectionNode = function(headA, headB) {\\n    if(headA===null || headB===null) {\\n        return null;\\n    }\\n    let r1=headA;\\n    let r2=headB;\\n    while(r1!==r2){\\n        r1=r1.next;\\n        r2=r2.next;\\n        if(r1===r2){\\n           return r1;\\n        }\\n        if (r1===null){\\n          r1=headB;  \\n        }\\n        if(r2===null){\\n            r2=headA;\\n        }\\n    }\\n    return r1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515384,
                "title": "beats-100-fast-concise-and-readable-javascript-solution",
                "content": "```\\nvar getIntersectionNode = function(headA, headB) {\\n    if(!headA || !headB)return null\\n    let a = headA, b = headB\\n    while(a !== b){\\n        a = a.next\\n        b = b.next\\n        if(!a && !b)return a\\n        if(!a)a = headB\\n        if(!b)b = headA\\n    }\\n    return a\\n};\\n```\\n![image](https://assets.leetcode.com/users/trevorhulsman123/image_1582248204.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getIntersectionNode = function(headA, headB) {\\n    if(!headA || !headB)return null\\n    let a = headA, b = headB\\n    while(a !== b){\\n        a = a.next\\n        b = b.next\\n        if(!a && !b)return a\\n        if(!a)a = headB\\n        if(!b)b = headA\\n    }\\n    return a\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 49844,
                "title": "u3010fixed-u3011python-accepted-solution-before-now-causes-memory-limit-exceeded",
                "content": "I have resolved this problem several months ago. But now when I submit the same code, it always get MLE. I also tried other solutions posted in the discuss, still got MLE. @StefanPochmann \\n\\n`Update:` Many thanks to @skyeyvapor, it's accepted when add `gc.collect()` manually. I already updated the codes below.\\n\\n\\nThis is my solution.\\n```\\nimport gc\\n\\nclass Solution(object):\\n    def cout(self, head):\\n        cnt = 0\\n        while head:\\n            cnt += 1\\n            head = head.next\\n\\n        # manually clean the memory\\n        gc.collect()\\n        return cnt\\n\\n    def getIntersectionNode(self, headA, headB):\\n        l1, l2, cnt1, cnt2 = headA, headB, self.cout(headA), self.cout(headB)\\n        if cnt2 > cnt1:\\n            l1, l2 = l2, l1\\n\\n        for _ in range(abs(cnt1 - cnt2)):\\n            l1 = l1.next\\n\\n        while l1:\\n            if l1 is l2:\\n                return l1\\n\\n            l1, l2 = l1.next, l2.next\\n```\\n\\nAnd this is another solution I tried.\\n\\n```\\nimport gc\\n\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        a, b = headA, headB\\n        while a is not b:\\n            a = headB if a is None else a.next\\n            b = headA if b is None else b.next\\n        \\n        # clean the memory\\n        gc.collect()\\n        return a\\n```",
                "solutionTags": [],
                "code": "```\\nimport gc\\n\\nclass Solution(object):\\n    def cout(self, head):\\n        cnt = 0\\n        while head:\\n            cnt += 1\\n            head = head.next\\n\\n        # manually clean the memory\\n        gc.collect()\\n        return cnt\\n\\n    def getIntersectionNode(self, headA, headB):\\n        l1, l2, cnt1, cnt2 = headA, headB, self.cout(headA), self.cout(headB)\\n        if cnt2 > cnt1:\\n            l1, l2 = l2, l1\\n\\n        for _ in range(abs(cnt1 - cnt2)):\\n            l1 = l1.next\\n\\n        while l1:\\n            if l1 is l2:\\n                return l1\\n\\n            l1, l2 = l1.next, l2.next\\n```\n```\\nimport gc\\n\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        a, b = headA, headB\\n        while a is not b:\\n            a = headB if a is None else a.next\\n            b = headA if b is None else b.next\\n        \\n        # clean the memory\\n        gc.collect()\\n        return a\\n```",
                "codeTag": "C++"
            },
            {
                "id": 49891,
                "title": "javascript-5-lines-with-inline-comment",
                "content": "    var getIntersectionNode = function(ah, bh) {\\n        var a=ah, b=bh\\n        while(a!=b){\\n            a = a? a.next : bh // move a to head of b if at end\\n            b = b? b.next : ah // move b to head of a if at end      \\n        }\\n        \\n        return a; // a === b either happen at the connecting point or when they are both null\\n    };",
                "solutionTags": [],
                "code": "    var getIntersectionNode = function(ah, bh) {\\n        var a=ah, b=bh\\n        while(a!=b){\\n            a = a? a.next : bh // move a to head of b if at end\\n            b = b? b.next : ah // move b to head of a if at end      \\n        }\\n        \\n        return a; // a === b either happen at the connecting point or when they are both null\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 49939,
                "title": "c-concise-solution",
                "content": "        \\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *hA = headA, *hB = headB;\\n        while (hA && hB) {\\n            if (hA == hB)\\n                return hA;\\n            hA = hA->next;\\n            hB = hB->next;\\n            if (!hA && !hB)\\n                return NULL;\\n            if (!hA) \\n                hA = headB;\\n            if (!hB)\\n                hB = headA;\\n        }\\n        return NULL;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *hA = headA, *hB = headB;\\n        while (hA && hB) {\\n            if (hA == hB)\\n                return hA;\\n            hA = hA->next;\\n            hB = hB->next;\\n            if (!hA && !hB)\\n                return NULL;\\n            if (!hA) \\n                hA = headB;\\n            if (!hB)\\n                hB = headA;\\n        }\\n        return NULL;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 50010,
                "title": "my-concise-python-solution-run-in-o-n-time-and-o-1-memory",
                "content": "    class Solution:\\n    # @param two ListNodes\\n    # @return the intersected ListNode\\n    def getIntersectionNode(self, headA, headB):\\n        if not headA or not headB:return None\\n        a,b=headA,headB\\n        ans = None\\n        while a or b:  \\n            if not a:   a=headB\\n            if not b:   b=headA\\n            if a==b and not ans: ans=a\\n            a , b = a.next,b.next\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @param two ListNodes\\n    # @return the intersected ListNode\\n    def getIntersectionNode(self, headA, headB):\\n        if not headA or not headB:return None\\n        a,b=headA,headB\\n        ans = None\\n        while a or b:  \\n            if not a:   a=headB\\n            if not b:   b=headA\\n            if a==b and not ans: ans=a\\n            a , b = a.next,b.next\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3292274,
                "title": "best-6-lines-of-code-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode head1, ListNode head2) {\\n        while (head2 != null){\\n            ListNode temp = head1;\\n            while (temp != null){\\n                if (temp == head2) return head2;\\n                temp = temp.next;\\n            }\\n            head2 = head2.next;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode head1, ListNode head2) {\\n        while (head2 != null){\\n            ListNode temp = head1;\\n            while (temp != null){\\n                if (temp == head2) return head2;\\n                temp = temp.next;\\n            }\\n            head2 = head2.next;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964570,
                "title": "c-java-solution-with-all-the-ways-striver-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Intuition is to traverse the linkedlist and return the node where the two list join and if there is no joining of the list we simply return NULL\\n\\n# Brute force \\nWe will point to a node in list 1 and check it with all the node of the list2 and if we get the same node then return that node or else return NULL;\\n\\n**Time complexity:** **O(n*m)**\\nn =length of the list 1.\\nm=length of the list2.\\n**Space complexity:**  **O(1)**\\n\\n# Hashing \\nStore all the node of the list1 and list2 in hash table and when the two node have same key then return that node.\\n\\n**Time complexity:** **O(n+m)**\\n**Space complexity:**  **O(n+m)**\\n\\n# Optimal 1\\n \\n1. Find the length of the first list and then the length of second list.\\n2. Move the head of the longer length linkedlist till the difference of the length of two list.\\n3. After that move both the head simultaneously and return the value where they collide.\\n\\n**Code**\\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int n1=0,n2=0;\\n        ListNode temp=headA;\\n        while(temp!=null){\\n            n1++;   //count the length of the list 1\\n            temp=temp.next;\\n        }\\n        temp=headB;\\n        while(temp!=null){\\n            n2++;   //count the length of the list2\\n            temp=temp.next;\\n        }\\n        ListNode larger=headA;\\n        ListNode smaller=headB;\\n        if(n1<n2){      //if A is not the larger list then swap\\n            ListNode p=larger;\\n            larger=smaller;     \\n            smaller=p;\\n        }\\n        int diff=Math.abs(n1-n2);\\n        for(int i=0;i<diff;i++){\\n            larger=larger.next;\\n        }\\n         if(larger==smaller){\\n                return larger;\\n            }\\n        while(larger!=null&&smaller!=null){\\n            larger=larger.next;\\n            smaller=smaller.next;\\n            if(larger==smaller){\\n                return larger;\\n            }\\n\\n        }\\n        return null;\\n    }\\n}\\n```\\n**Time complexity:** **O(n+m)**\\n**Space complexity:**  **O(1)**\\n\\nThis the optimal code However the line of code is a little bit larger.\\n# Optimal 2\\n1. Traverse the list1 and list 2 \\n2. The moment one of the list reaches the null then assign it to the head of other list.\\n3. Again traverse both the list and if the second list reaches the list then assign it to the head1.\\n4. Traverse the list till it collide and return the collide node .\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* a=headA;\\n        ListNode* b=headB;\\n        if(headA==NULL||headB==NULL)\\n        return NULL;\\n\\n        while(a!=b){\\n            if(a==NULL)\\n            a=headB;\\n            else\\n            a=a->next;\\n            if(b==NULL)\\n            b=headA;\\n            else \\n            b=b->next;\\n        }\\n        return a;\\n    }\\n};\\n```\\n**Time complexity:** **O(n+m)**\\n**Space complexity:**  **O(1)**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int n1=0,n2=0;\\n        ListNode temp=headA;\\n        while(temp!=null){\\n            n1++;   //count the length of the list 1\\n            temp=temp.next;\\n        }\\n        temp=headB;\\n        while(temp!=null){\\n            n2++;   //count the length of the list2\\n            temp=temp.next;\\n        }\\n        ListNode larger=headA;\\n        ListNode smaller=headB;\\n        if(n1<n2){      //if A is not the larger list then swap\\n            ListNode p=larger;\\n            larger=smaller;     \\n            smaller=p;\\n        }\\n        int diff=Math.abs(n1-n2);\\n        for(int i=0;i<diff;i++){\\n            larger=larger.next;\\n        }\\n         if(larger==smaller){\\n                return larger;\\n            }\\n        while(larger!=null&&smaller!=null){\\n            larger=larger.next;\\n            smaller=smaller.next;\\n            if(larger==smaller){\\n                return larger;\\n            }\\n\\n        }\\n        return null;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* a=headA;\\n        ListNode* b=headB;\\n        if(headA==NULL||headB==NULL)\\n        return NULL;\\n\\n        while(a!=b){\\n            if(a==NULL)\\n            a=headB;\\n            else\\n            a=a->next;\\n            if(b==NULL)\\n            b=headA;\\n            else \\n            b=b->next;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726063,
                "title": "python3-easy-o-1-space-with-explanation",
                "content": "**Explanation**\\n\\nIf we connect the tail of the intersection part to one head, we could implement this problem using the idea from question Linked List Cycle II. To explain, the solution is now to solve for the entry node of the cycle if there is an intersection.\\n\\nNote that we need to split the cycle to the original structure before returning the intersection node as required.\\n\\n**Python3 implementation:**\\n```Python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        # create a circle\\n        tail = headA\\n        while tail.next:\\n            tail = tail.next\\n        tail.next = headB\\n        # find the intersection node\\n        slow = fast = headA\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow is fast:\\n                break\\n        \\n        if not fast or not fast.next:\\n            tail.next = None\\n            return None\\n        \\n        slow = headA\\n        while slow is not fast:\\n            slow = slow.next\\n            fast = fast.next\\n        # recover to original structure\\n        tail.next = None\\n        return slow\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```Python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        # create a circle\\n        tail = headA\\n        while tail.next:\\n            tail = tail.next\\n        tail.next = headB\\n        # find the intersection node\\n        slow = fast = headA\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            if slow is fast:\\n                break\\n        \\n        if not fast or not fast.next:\\n            tail.next = None\\n            return None\\n        \\n        slow = headA\\n        while slow is not fast:\\n            slow = slow.next\\n            fast = fast.next\\n        # recover to original structure\\n        tail.next = None\\n        return slow\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035448,
                "title": "java-shortest-cleanest-solution",
                "content": "```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode xA = headA , xB = headB;\\n      while(xA != xB) {\\n        xA = xA == null ? headB : xA.next;\\n        xB = xB == null ? headA : xB.next;\\n      }\\n      return xA;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode xA = headA , xB = headB;\\n      while(xA != xB) {\\n        xA = xA == null ? headB : xA.next;\\n        xB = xB == null ? headA : xB.next;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1759814,
                "title": "python-link-the-two-lists-o-n-m-time-and-o-1-space",
                "content": "We need two pointers: `p1` starts from `headA` and `p2` starts from `headB`.\\nThe key point is how we make sure the two pointers come to the intersection node at the same time.\\nSince the difference of the distance to the intersection is the difference of the length of the two list. We can \"link\" the two list together:\\n* Let `p1` starts from `headA` passing through the first linked list, then the second (starting from `headB`).\\n* Let `p2` starts from `headB` passing through the second linked list, then the first (starting from `headA`).\\n\\nThus, the number of steps they need to take to arrive the intersection node is equal.\\nAlso, if there is no intersection, it will end up with `p1 == p1 == null`.\\n\\n```Python\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        \"\"\"\\n        :type head1, head1: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        p1 = headA\\n        p2 = headB\\n        while p1 != p2:\\n            if p1:\\n                p1 = p1.next\\n            else:\\n                p1 = headB\\n            if p2:\\n                p2 = p2.next\\n            else:\\n                p2 = headA\\n            \\n        return p1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Python\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        \"\"\"\\n        :type head1, head1: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        p1 = headA\\n        p2 = headB\\n        while p1 != p2:\\n            if p1:\\n                p1 = p1.next\\n            else:\\n                p1 = headB\\n            if p2:\\n                p2 = p2.next\\n            else:\\n                p2 = headA\\n            \\n        return p1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698318,
                "title": "mathematical-explanation-of-o-n-time-o-1-space-solution",
                "content": "![](https://assets.leetcode.com/uploads/2021/03/05/160_statement.png)\\n\\nAssume there exists an intersection. The intersection is `None` if `A` and `B` don\\'t actually intersect. Notice that the following equation is true:\\n\\n```\\na + b + 2*c == m + n\\n\\na = number of edges from headA to the intersection node\\nb = number of edges from headB to the intersection node\\nc = number of edges from the intersection node to the tail\\nm = number of edges from headA to the tail\\nn = number of edges from headB to the tail\\n```\\n\\nTo find the intersection node, we want to solve for `a` or `b`. If we have `a`, then we can travel a distance of `a` away from `headA` and arrive at the intersection node. Alternatively, if we have `b` then we can travel a distance of `b` away from `headB` and arrive at the intersection node.\\n\\nNow, notice the following:\\n\\n```\\na + (n - m) == b\\n\\n(assuming n > m)\\n```\\n\\nIf `m > n`, then instead:\\n\\n```\\nb + (m - n) == a\\n```\\n\\nIt\\'s easy to prove. For example, for the `n > m` case:\\n\\n```\\na + (n - m) == b\\n(m - c) + (n - m) == (n - c)\\nm - m + n - c == n - c\\nn - c == n - c\\n```\\n\\nSo we just need to find the value of `n - m` and then give the iterator at `headB` a head start of `n - m`. Conversely, if `m > n`, then we give the iterator at `headA` a head start of `m - n`. Then iterate both at the same speed, and eventually they will arrive at the intersection point at the same time.\\n\\n```py\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        # Calculate m\\n        m, a = 0, headA\\n        while a:\\n            m += 1\\n            a = a.next\\n        # Calculate n\\n        n, b = 0, headB\\n        while b:\\n            n += 1\\n            b = b.next\\n\\n        # Restart a, b at headA, headB\\n        # Give either a or b a \"head start\"\\n        a, b = headA, headB\\n        if m > n:\\n            # Give \\'a\\' a head start of (m - n)\\n            for _ in range(m - n):\\n                a = a.next\\n        else:\\n            # Give \\'b\\' a head start of (n - m)\\n            for _ in range(n - m):\\n                b = b.next\\n        # Iterate a and b until the intersect.\\n        while a and b and a != b:\\n            a = a.next\\n            b = b.next\\n        return a\\n```\\n\\nActually, we can make the code smaller like so:\\n\\n```py\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        a, b = headA, headB\\n        while a != b:\\n            if not a:\\n                a = headB\\n            elif not b:\\n                b = headA\\n            else:\\n                a = a.next\\n                b = b.next\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\na + b + 2*c == m + n\\n\\na = number of edges from headA to the intersection node\\nb = number of edges from headB to the intersection node\\nc = number of edges from the intersection node to the tail\\nm = number of edges from headA to the tail\\nn = number of edges from headB to the tail\\n```\n```\\na + (n - m) == b\\n\\n(assuming n > m)\\n```\n```\\nb + (m - n) == a\\n```\n```\\na + (n - m) == b\\n(m - c) + (n - m) == (n - c)\\nm - m + n - c == n - c\\nn - c == n - c\\n```\n```py\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        # Calculate m\\n        m, a = 0, headA\\n        while a:\\n            m += 1\\n            a = a.next\\n        # Calculate n\\n        n, b = 0, headB\\n        while b:\\n            n += 1\\n            b = b.next\\n\\n        # Restart a, b at headA, headB\\n        # Give either a or b a \"head start\"\\n        a, b = headA, headB\\n        if m > n:\\n            # Give \\'a\\' a head start of (m - n)\\n            for _ in range(m - n):\\n                a = a.next\\n        else:\\n            # Give \\'b\\' a head start of (n - m)\\n            for _ in range(n - m):\\n                b = b.next\\n        # Iterate a and b until the intersect.\\n        while a and b and a != b:\\n            a = a.next\\n            b = b.next\\n        return a\\n```\n```py\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        a, b = headA, headB\\n        while a != b:\\n            if not a:\\n                a = headB\\n            elif not b:\\n                b = headA\\n            else:\\n                a = a.next\\n                b = b.next\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180817,
                "title": "my-simple-and-understandable-solution-using-c",
                "content": "First we will traverse through first linked list and store the nodes in a stack. Then we\\'ll traverse through second linked list and store the nodes in another stack. Then we will traverse through the stacks until the topmost elements of both stacks are not equal. This way we will find out at which point both linked list differs. Also we have to store the previous node so that we will be able to return the intersection point of boh linked list. \\n\\n```\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* first=headA;\\n        stack<ListNode*> a;\\n        stack<ListNode*> b;\\n        while(first!=NULL){\\n            a.push(first);\\n            first=first->next;\\n        }\\n        first=headB;\\n        while(first!=NULL){\\n            b.push(first);\\n            first=first->next;\\n        }\\n        while(a.top()==b.top()){\\n            first=a.top();\\n            a.pop();\\n            b.pop();\\n            if(a.empty() || b.empty())\\n                break;\\n        }\\n        return first;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "First we will traverse through first linked list and store the nodes in a stack. Then we\\'ll traverse through second linked list and store the nodes in another stack. Then we will traverse through the stacks until the topmost elements of both stacks are not equal. This way we will find out at which point both linked list differs. Also we have to store the previous node so that we will be able to return the intersection point of boh linked list. \\n\\n```\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* first=headA;\\n        stack<ListNode*> a;\\n        stack<ListNode*> b;\\n        while(first!=NULL){\\n            a.push(first);\\n            first=first->next;\\n        }\\n        first=headB;\\n        while(first!=NULL){\\n            b.push(first);\\n            first=first->next;\\n        }\\n        while(a.top()==b.top()){\\n            first=a.top();\\n            a.pop();\\n            b.pop();\\n            if(a.empty() || b.empty())\\n                break;\\n        }\\n        return first;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1093943,
                "title": "c-mark-nodes-as-visited-with-negative-value-o-n-m-time-o-1-space-with-explanation",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) {\\n        \\n        // The key to make it O(1) space is **Each value on each linked list is in the range [1, 10^9].**\\n        // So just make each value negative to mark it as visited in the first list O(n) time\\n        // then iterate the second list until find a negative value, which is the answer O(m) time\\n        // and do another pass to put the positive value back to the first list O(m) time\\n        \\n        ListNode curr = headA;\\n        while (curr != null)\\n        {\\n            curr.val *= -1;\\n            curr = curr.next;\\n        }\\n        \\n        curr = headB;\\n        ListNode ans = null;\\n        while (curr != null)\\n        {\\n            if (curr.val < 1)\\n            {\\n                ans = curr;\\n                break;\\n            }  \\n            curr = curr.next;\\n        }\\n        \\n        curr = headA;\\n        while (curr != null)\\n        {\\n            curr.val = Math.Abs(curr.val);\\n            curr = curr.next;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) {\\n        \\n        // The key to make it O(1) space is **Each value on each linked list is in the range [1, 10^9].**\\n        // So just make each value negative to mark it as visited in the first list O(n) time\\n        // then iterate the second list until find a negative value, which is the answer O(m) time\\n        // and do another pass to put the positive value back to the first list O(m) time\\n        \\n        ListNode curr = headA;\\n        while (curr != null)\\n        {\\n            curr.val *= -1;\\n            curr = curr.next;\\n        }\\n        \\n        curr = headB;\\n        ListNode ans = null;\\n        while (curr != null)\\n        {\\n            if (curr.val < 1)\\n            {\\n                ans = curr;\\n                break;\\n            }  \\n            curr = curr.next;\\n        }\\n        \\n        curr = headA;\\n        while (curr != null)\\n        {\\n            curr.val = Math.Abs(curr.val);\\n            curr = curr.next;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056028,
                "title": "c-super-simple-easy-clear-solution-o-n-time-o-1-memory",
                "content": "\\tclass Solution {\\n\\tprivate:\\n\\t\\tvoid changeSign(ListNode *head){\\n\\t\\t\\twhile ( head )\\n\\t\\t\\t{\\n\\t\\t\\t\\thead->val *= -1;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t}\\n\\t\\t}\\n\\tpublic:\\n\\t\\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\t\\tchangeSign( headA );\\n\\t\\t\\t\\n\\t\\t\\twhile ( headB )\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ( headB->val < 0 ) break;\\n\\t\\t\\t\\theadB = headB->next;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tchangeSign( headA );\\n\\t\\t\\treturn headB;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tprivate:\\n\\t\\tvoid changeSign(ListNode *head){\\n\\t\\t\\twhile ( head )\\n\\t\\t\\t{\\n\\t\\t\\t\\thead->val *= -1;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 922285,
                "title": "very-simple-o-n-o-1-solution-with-changing-value-of-first-list-to-negative-kotlin",
                "content": "Since we know that all values are > 0 we can \\n1. go through the first list and change all thems to negative value\\n2. traverse second list until first negative element found, keep it as intersection node\\n3. revert value changes in the first list\\n4. return the kept intersection node\\n\\n```\\nclass Solution {\\n    fun getIntersectionNode(headA:ListNode?, headB:ListNode?):ListNode? {\\n        var curr = headA\\n        while (curr != null) {\\n            curr.`val` = -curr.`val` \\n            curr = curr.next\\n        }\\n        \\n        val intersectionNode = findIntersection(headB)\\n        \\n        curr = headA\\n        while (curr != null) {\\n            curr.`val` = -curr.`val` \\n            curr = curr.next\\n        }\\n        \\n        return intersectionNode\\n    }\\n    \\n    private fun findIntersection(headB:ListNode?) : ListNode? {\\n        var curr = headB\\n        while (curr != null) {\\n            if (curr.`val` < 0) return curr\\n            curr = curr.next\\n        }\\n        return null\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun getIntersectionNode(headA:ListNode?, headB:ListNode?):ListNode? {\\n        var curr = headA\\n        while (curr != null) {\\n            curr.`val` = -curr.`val` \\n            curr = curr.next\\n        }\\n        \\n        val intersectionNode = findIntersection(headB)\\n        \\n        curr = headA\\n        while (curr != null) {\\n            curr.`val` = -curr.`val` \\n            curr = curr.next\\n        }\\n        \\n        return intersectionNode\\n    }\\n    \\n    private fun findIntersection(headB:ListNode?) : ListNode? {\\n        var curr = headB\\n        while (curr != null) {\\n            if (curr.`val` < 0) return curr\\n            curr = curr.next\\n        }\\n        return null\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 908635,
                "title": "golang-solution-with-map",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\\n    if headA == nil || headB == nil {\\n        return nil\\n    }\\n    hasVisited := make(map[*ListNode]bool)\\n    \\n    for n := headA; n != nil; n = n.Next{\\n        hasVisited[n] = true\\n    }\\n    \\n    for n := headB; n != nil; n = n.Next{\\n        if _, ok := hasVisited[n]; ok {\\n            return n\\n        }\\n    }\\n    return nil\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\\n    if headA == nil || headB == nil {\\n        return nil\\n    }\\n    hasVisited := make(map[*ListNode]bool)\\n    \\n    for n := headA; n != nil; n = n.Next{\\n        hasVisited[n] = true\\n    }\\n    \\n    for n := headB; n != nil; n = n.Next{\\n        if _, ok := hasVisited[n]; ok {\\n            return n\\n        }\\n    }\\n    return nil\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615363,
                "title": "java-2-loops",
                "content": "Orig: https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49785/Java-solution-without-knowing-the-difference-in-len!\\n```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        if (headA == null || headB == null)  return null;\\n        ListNode a = headA, b = headB;\\n        while (a != b) {\\n            a = a == null ? headB : a.next;\\n            b = b == null ? headA : b.next;\\n        }\\n        return a;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        if (headA == null || headB == null)  return null;\\n        ListNode a = headA, b = headB;\\n        while (a != b) {\\n            a = a == null ? headB : a.next;\\n            b = b == null ? headA : b.next;\\n        }\\n        return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 396690,
                "title": "python-easy-to-understand-6-methods",
                "content": "```\\n# -*- coding: utf-8 -*-\\n# @Time    : 2019/10/2 7:30\\n# @Author  : LI Dongdong\\n# @FileName: lc 160.py\\n\\n############\\u9898\\u76EE\\u5206\\u6790##########################\\n\"\"\"\\n1.\\u8981\\u6C42\\uFF1A\\u627E\\u51FA\\u4E24\\u4E2A\\u5355\\u94FE\\u8868\\u7684intersection\\uFF1B\\u65E0intersection\\u65F6\\u8FD4\\u56DEnull\\uFF1B\\n\\u94FE\\u8868\\u4FDD\\u6301\\u539F\\u6709\\u7ED3\\u6784\\uFF1B\\u5047\\u8BBE\\u94FE\\u8868\\u65E0\\u73AF; O(n) time and use only O(1) memory\\n2.\\u7406\\u89E3\\uFF1A\\u4E24\\u4E2A\\u5355\\u94FE\\u8868\\u7684intersection\\uFF0C\\u5373\\u5730\\u5740\\u76F8\\u540C\\u7684\\u4E24\\u4E2A\\u8282\\u70B9\\uFF0C\\u5373nodeA == nodeB\\uFF0C\\u6B64\\u65F6nodeA.val=nodeB.val,nodeA.next=nodeB.next\\n(\\u6CE8\\u610F\\uFF1Aval\\u76F8\\u540C\\uFF0Cnext\\u76F8\\u540C\\u7684\\u4E24\\u4E2A\\u8282\\u70B9\\u7684\\u5730\\u5740\\u4E0D\\u4E00\\u5B9A\\u76F8\\u540C\\uFF0C\\u6545\\u4E0D\\u4E00\\u5B9A\\u76F8\\u7B49)\\n\\u4FDD\\u6301\\u539F\\u6709\\u7ED3\\u6784->\\u4E0D\\u6784\\u5EFA\\u65B0\\u7684\\u94FE\\u8868\\uFF1BO(1) memory->iterative method;\\n3.\\u7C7B\\u578B\\uFF1A\\u94FE\\u8868\\u9898\\uFF1B\\u4E24\\u5355\\u94FE\\u8868\\uFF1B\\u627E\\u4EA4\\u70B9\\n4.\\u8FB9\\u754C\\u6761\\u4EF6\\uFF1A\\u94FE\\u8868\\u4E3ANone\\uFF1B\\u4E3A\\u8282\\u70B9\\n\"\"\"\\n\\n########################   brute force   ##########################\\n\\'\\'\\'\\n\\u672C\\u65B9\\u6CD5\\u7684time complex \\u662FO(mn), leetcode\\u8D85\\u65F6\\uFF0C\\u4E0D\\u7B26\\u5408\\u9898\\u610F\\n\\u601D\\u8DEF\\uFF1Afor each node a in list A, traverse the entire list B and check if any node\\nin list B coincides with a\\n\\u65B9\\u6CD5\\uFF1A\\u5185\\u5916\\u4E24\\u4E2Awhile\\u5FAA\\u73AF\\uFF08for\\u5FAA\\u73AF\\u9700\\u8981\\u8BA1\\u7B97list\\u957F\\u5EA6\\uFF09\\uFF0C\\u4E0D\\u65AD\\u8FED\\u4EE3\\uFF0C\\u9047\\u5230\\u76F8\\u540C\\u5730\\u5740\\u7684\\u5219\\u8FD4\\u56DEnode\\uFF0C\\n\\u5168\\u4E0D\\u76F8\\u540C\\u5219\\u8FD4\\u56DENone\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0CO(mn)\\nspace complex: O(1)\\n\\'\\'\\'\\n\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        while headA:\\n            currB = headB\\n            while currB:\\n                if headA == currB:\\n                    return headA\\n                else:\\n                    currB = currB.next\\n            headA = headA.next\\n        return None\\n\\n###########################  Hash Table  ##############################\\n\\'\\'\\'\\n\\u65B0\\u65B9\\u6CD5\\n\\u601D\\u8DEF\\uFF1A\\u628AA\\u7684\\u5404\\u4E2A\\u8282\\u70B9/\\u8282\\u70B9\\u7684\\u5730\\u5740\\u5B58\\u5165\\u5B58\\u50A8\\u7ED3\\u6784\\uFF0C\\u7136\\u540Etraverse\\u5404\\u4E2AB\\u8282\\u70B9\\uFF0C\\u770B\\u770B\\u6709\\u6CA1\\u6709\\u76F8\\u540C\\u7684\\n\\u65B9\\u6CD5\\uFF1AA\\u4E2D\\u6BCF\\u4E00\\u4E2Anode\\u90FD\\u4E0D\\u4E00\\u6837\\uFF0C\\u6545\\u53EF\\u4EE5\\u7528list/hash table(dic/set)\\u5B9E\\u73B0\\u5B58\\u50A8\\u7ED3\\u6784\\uFF0C\\n\\u4F46\\u662F\\u7531\\u4E8Ehash table\\u7684time complexity\\u4E3AO(1), \\u800Clist\\u4E3AO(n), \\u6545\\u4F7F\\u7528hash table\\u5B9E\\u73B0\\uFF0C\\u7136\\u540Etraverse B\\u4E2Dnode\\n\\u7528 X in hash table \\u6765\\u5B9E\\u73B0\\u5224\\u65AD\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0C\\u6DFB\\u52A0\\u65F6O(m)\\uFF0C\\u8FED\\u4EE3\\u65F6O(n)\\uFF0C\\u67E5\\u8BE2\\u65F6O(1),\\u6545\\u603B\\u8BA1\\u4E3AO(m+n+1) \\n\\u800C\\u7528list\\u7684\\u67E5\\u8BE2time complex \\u65F6O(n),\\u603B\\u8BA1\\u4E3AO(m+2n)\\n->\\u7591\\u95EE\\uFF1Flist\\u8D85\\u65F6\\uFF0C\\u4F46\\u662F\\u4ED6\\u4E0Etwo pointer method 1 \\u76F8\\u6BD4\\u770B\\u8D77\\u6765\\u5DEE\\u522B\\u4E0D\\u5927\\n->\\u53EF\\u80FD\\u56E0\\u4E3Atpm 1\\u7684\\u6700\\u5927\\u662FO(2m+2n)\\uFF0C\\u4F46\\u662F\\u5E73\\u65F6\\u8FDC\\u672A\\u5230\\uFF0C\\u800C\\u7528list\\uFF0C\\u4E00\\u5B9A\\u662FO(m+2n)\\nspace complex: max(O(m),O(n))\\n\\'\\'\\'\\nclass Solution:\\n    class Solution:\\n        def getIntersectionNode(self, headA, headB):\\n            if headA == None or headB == None:\\n                return None\\n            hash_table = {}\\n            # or hash_table = set()\\n            while headA:\\n                hash_table[headA] = 1\\n                #hash_table.add(headA)\\n                headA = headA.next\\n            while headB:\\n                if headB in hash_table:\\n                    return headB\\n                else:\\n                    headB = headB.next\\n            return None\\n\\'\\'\\'\\n\\u5982\\u4E0B\\u4EE3\\u7801\\u6709\\u9519\\u8BEF\\uFF0C\\u56E0\\u4E3Acontinue\\uFF0C\\u6545headB = headB.next \\u6CA1\\u6709\\u8FD0\\u884C\\n                else:\\n                    continue\\n                headB = headB.next\\n\\'\\'\\'\\n######################## reduce gap method ##########################\\n\\'\\'\\'\\n\\u601D\\u8DEF\\uFF1A\\u5206\\u522B\\u4ECE\\u4E24\\u6BB5\\u76F8\\u540C\\u957F\\u5EA6\\u7684\\u8D77\\u59CB\\u70B9\\u5F00\\u59CB\\u5F80\\u540Eiterative\\n\\u65B9\\u6CD5\\uFF1A\\u6C42\\u957F\\u5EA6\\u5DEE\\u5F02->\\u79FB\\u52A8\\u8F83\\u957F\\u6BB5\\u7684pointer\\u5230\\u4E0E\\u8F83\\u77ED\\u6BB5\\u76F8\\u540C\\u7684\\u957F\\u5EA6\\u5904-\\u300B\\u4E24\\u6761\\u94FE\\u8868\\u4E00\\u8D77\\u8DD1\\uFF0C\\n\\u6700\\u591A\\u8DD1\\u516C\\u5171\\u957F\\u5EA6\\uFF0C\\u627E\\u4EA4\\u70B9\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0CO(m)+O(n) + O(m-n) + min(O(m),O(n)) = O(n)\\nspace complex: O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        if headA == None or headB == None:\\n            return None\\n\\n        currA=headA\\n        currB=headB\\n\\n        lengthA=0\\n        while currA:\\n            lengthA+=1\\n            currA=currA.next\\n        lengthB=0\\n        while currB:\\n            lengthB+=1\\n            currB=currB.next\\n\\n        if lengthA > lengthB:\\n            gap = lengthA - lengthB\\n            while gap:\\n                headA=headA.next\\n                gap-=1\\n            while lengthB:\\n                lengthB -= 1\\n                if headA == headB:\\n                    return headA\\n                else:\\n                    headA = headA.next\\n                    headB = headB.next\\n            return None\\n\\n        elif lengthA == lengthB:\\n            while lengthA:\\n                lengthA -= 1\\n                if headA == headB:\\n                    return headA\\n                else:\\n                    headA = headA.next\\n                    headB = headB.next\\n            return None\\n\\n        elif lengthA < lengthB:\\n            gap = lengthB - lengthA\\n            while gap:\\n                headB=headB.next\\n                gap-=1\\n            while lengthA:\\n                lengthA -= 1\\n                if headA == headB:\\n                    return headA\\n                else:\\n                    headA = headA.next\\n                    headB = headB.next\\n            return None\\n\\n####################### Two pointer method 1 ###########################\\n\\'\\'\\'\\n\\u601D\\u8DEF\\uFF1A\\u540C\\u65F6\\u8FED\\u4EE3A\\u548CB\\uFF0CA\\u8FD0\\u884C\\u5B8C\\u63A5\\u4E0AB\\u8FD0\\u884C\\uFF0CB\\u8FD0\\u884C\\u5B8C\\u63A5\\u4E0AA\\u8FD0\\u884C\\uFF0C\\u8FC7\\u7A0B\\u4E2D\\uFF0C\\u5982\\u76F8\\u9047\\u5219\\u4E3A\\u4EA4\\u70B9\\uFF0C\\u5982\\u4E0D\\u76F8\\u9047\\u5219\\u8FD4\\u56DENone\\n\\u65B9\\u6CD5\\uFF1A\\u8BBE\\u8BA1\\u5FAA\\u73AF\\uFF0C\\u5224\\u65AD\\u6761\\u4EF6\\u4E3AA\\u957F+B\\u957F\\u7684\\u5FAA\\u73AF\\u6B21\\u6570\\uFF0CA\\u5FAA\\u73AF\\u5B8C\\u540E\\u4E3ANone\\u65F6\\uFF0C\\u7528\\u8D4B\\u503C\\u62FC\\u63A5\\u8FDE\\u63A5B\\uFF0CB\\u540C\\u7406\\uFF0C\\u5F53headA=headB\\u65F6\\u8DF3\\u51FA\\u8FD4\\u56DEhead\\uFF0C\\u5F53\\u5FAA\\u73AF\\u5B8C\\u6210\\u4E4B\\u540E\\u90FD\\u65E0\\uFF0C\\u5219\\u8FD4\\u56DENone\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0C0(m)+O(n)+O(m)+O(n) = 0(2m+2n)=O(n)\\nspace complex: O(1)\\n\\n\\u6CE8\\uFF1A\\u8D4B\\u503C\\u62FC\\u63A5\\u548Cnext\\u62FC\\u63A5\\u7684\\u533A\\u522B\\n\\u8D4B\\u503C\\u62FC\\u63A5\\u4EE5\\u540E\\uFF0C\\u672A\\u6539\\u53D8\\u539F\\u6709\\u7ED3\\u6784\\uFF1B\\u800C\\u5982\\u679C\\u662F\\u7528.next=\\u8FDB\\u884C\\u62FC\\u63A5\\uFF0C\\u5219\\u6539\\u53D8\\u4E86\\u539F\\u6709\\u7ED3\\u6784\\u3002\\n\\u540C\\u65F6\\u7531\\u4E8E\\u662FA\\u62FCB\\uFF0CB\\u62FCA\\uFF0C\\u90A3\\u4E48\\u8D4B\\u503C\\u62FC\\u63A5\\u7ED3\\u679C\\u662F\\u4E24\\u4E2A\\u5206\\u6BB5AB,BA,\\u800Cnext\\u62FC\\u63A5\\u662F\\u73AF A-B-A\\n\\'\\'\\'\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        if headA == None or headB == None:\\n            return None\\n\\n        currA=headA\\n        currB=headB\\n        lengthA = 0\\n        lengthB = 0\\n        while currA:\\n            lengthA += 1\\n            currA = currA.next\\n        while currB:\\n            lengthB += 1\\n            currB = currB.next\\n\\n        sum_length = lengthA + lengthB\\n        tempA=headA\\n        tempB=headB\\n        while sum_length:\\n            if not headA:\\n                headA = tempB\\n            if not headB:\\n                headB = tempA\\n            if headA == headB:\\n                return headA\\n            headA = headA.next\\n            headB = headB.next\\n            sum_length -= 1\\n        return None\\n\\n#######################  Two pointer method 2 ###########################\\n\\'\\'\\'\\nTwo pointer method 1 \\u7684\\u4F18\\u5316\\u7248\\n\\u601D\\u8DEF\\uFF1A\\u4E0ETwo pointer method 1\\u76F8\\u540C\\n\\u65B9\\u6CD5\\uFF1Awhile\\u5224\\u65AD\\u6761\\u4EF6\\u6539\\u4E3AheadA!=headB\\uFF0C\\u5F53\\u6709\\u4EA4\\u53C9\\u70B9\\u4E14\\u8FD0\\u884C\\u5230\\u4EA4\\u53C9\\u70B9\\u65F6\\uFF0Cwhile\\u4E0D\\u6EE1\\u8DB3\\uFF0C\\u8DF3\\u51FA\\uFF0C\\u8FD4\\u56DE\\u4EA4\\u53C9\\u70B9(headA)\\uFF1B\\n\\u5F53\\u6CA1\\u6709\\u4EA4\\u53C9\\u70B9\\u65F6\\uFF0C\\u9012\\u5F52\\u5B8C\\u4E24\\u4E2A\\u5206\\u6BB5\\uFF0C\\u4E24\\u4E2A\\u6307\\u9488\\u90FD\\u6307\\u5411\\u7684\\u5206\\u6BB5\\u7684\\u672B\\u5C3E\\uFF08curA = None,curB= None)\\uFF0Cwhile\\u4E0D\\u6EE1\\u8DB3\\uFF0C\\u8DF3\\u51FA\\uFF0C\\u8FD4\\u56DE\\u4EA4\\u53C9\\u70B9\\uFF08headA=None\\uFF09\\nwhile\\u5224\\u65AD\\u6761\\u4EF6\\u4E0D\\u80FD\\u7528headA==None or headB==None,\\u56E0\\u4E3Atraverse\\u5230\\u62FC\\u63A5\\u70B9\\u65F6\\uFF0CheadA or headB\\u4E5F\\u4F1A\\u4E3ANone;\\n\\u7528and\\u65F6\\uFF0C\\u82E5\\u6709\\u4EA4\\u53C9\\u70B9\\uFF0C\\u8FD8\\u8981\\u6DFB\\u52A0\\u5176\\u4ED6\\u6761\\u4EF6\\u8FDB\\u884C\\u8FD4\\u56DE\\u4EA4\\u5DEE\\u70B9\\u3002\\u6545\\u7528 while curA != curB:\\u662F\\u6700\\u597D\\u7684\\u3002\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0C\\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0C0(m)+O(n)=O(m+n)=O(n)\\nspace complex: O(1)\\n\\n\\u6CE8\\uFF1A\\u65B0\\u578B\\u4E66\\u5199\\u65B9\\u5F0F\\uFF1A\\n            if curA:\\n                curA = curA.next\\n            else:\\n                curA = headB\\n            \\u4E0E\\n            curA = curA.next if curA else headB\\n            \\u76F8\\u540C\\n\\'\\'\\'\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        if headA == None or headB == None:\\n            return None\\n\\n        curA = headA\\n        curB = headB\\n        while curA != curB:\\n            if curA:\\n                curA = curA.next\\n            else:\\n                curA = headB\\n            curB = curB.next if curB else headA\\n        return curA\\n\\n######################Two pointer method 3#######################################\\n\\'\\'\\'\\n\\u672C\\u65B9\\u6CD5\\u7531\\u4E8E\\u7528next\\u8FDE\\u63A5\\u4E86A\\u548CB\\uFF0C\\u6539\\u53D8\\u4E86\\u539F\\u94FE\\u8868\\u7684\\u7ED3\\u6784\\uFF0C\\u6545\\u4E0D\\u7B26\\u5408\\u9898\\u610F\\n\\u601D\\u8DEF\\uFF1AA\\u5C3E\\u8FDEB\\u5934\\uFF0CB\\u5C3E\\u8054A\\u5934\\uFF0CA,B\\u4E24\\u5934\\u540C\\u65F6iterative\\uFF0C\\u76F8\\u9047\\u7684\\u65F6\\u5019\\u5373\\u4EA4\\u70B9\\uFF0C\\u4E0D\\u76F8\\u9047\\u5219\\u6CA1\\u6709\\u4EA4\\u70B9\\n\\u65B9\\u6CD5\\uFF1AA pointer\\u79FB\\u52A8\\u5230\\u672B\\u5C3E\\uFF0C\\u540E\\u8FDE\\u63A5B\\u5934\\uFF1BB\\u540C\\u6837\\u505A->\\u540C\\u65F6\\u4ECEA,B\\u5934\\u5F00\\u59CB\\u79FB\\u52A8\\uFF0C\\u6700\\u591A\\u79FB\\u52A8m+n\\u6B21\\uFF0C\\u76F8\\u7B49\\u5219\\u8FD4\\u56DEnode\\uFF0C\\u5168\\u90E8\\u4E0D\\u80FD\\u5219\\u8FD4\\u56DENone\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0CO(m)+O(n) + max(O(n),O(m)) = O(n)\\nspace complex: O(1)\\n\\'\\'\\'\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        if headA == None or headB == None:\\n            return None\\n\\n        currA = headA\\n        currB = headB\\n        lengthA = 0\\n        lengthB = 0\\n        while currA:\\n            lengthA += 1\\n            prevA = currA\\n            currA = currA.next\\n        while currB:\\n            lengthB += 1\\n            prevB = currB\\n            currB = currB.next\\n\\n        prevA.next = headB\\n        prevB.next = headA\\n\\n        sum_length = lengthA + lengthB\\n        while sum_length:\\n            sum_length -= 1\\n            if headA == headB:\\n                return headA\\n            else:\\n                headA = headA.next\\n                headB = headB.next\\n        return None\\n\\n######################\\u6784\\u9020\\u4EA4\\u53C9\\u94FE\\u8868######################################\\nA1 = ListNode(4)\\nA2 = ListNode(1)\\n\\nB1 = ListNode(5)\\nB2 = ListNode(0)\\nB3 = ListNode(1)\\n\\nC1 = ListNode(8)\\nC2= ListNode(4)\\nC3= ListNode(5)\\n\\n\\n\\nA1.next = A2\\nA2.next=C1\\nC1.next=C2\\nC2.next=C3\\n\\nB1.next=B2\\nB2.next=B3\\nB3.next=C1\\n\\n\\nrl = Solution()\\nrl.getIntersectionNode(A1,B1)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n# -*- coding: utf-8 -*-\\n# @Time    : 2019/10/2 7:30\\n# @Author  : LI Dongdong\\n# @FileName: lc 160.py\\n\\n############\\u9898\\u76EE\\u5206\\u6790##########################\\n\"\"\"\\n1.\\u8981\\u6C42\\uFF1A\\u627E\\u51FA\\u4E24\\u4E2A\\u5355\\u94FE\\u8868\\u7684intersection\\uFF1B\\u65E0intersection\\u65F6\\u8FD4\\u56DEnull\\uFF1B\\n\\u94FE\\u8868\\u4FDD\\u6301\\u539F\\u6709\\u7ED3\\u6784\\uFF1B\\u5047\\u8BBE\\u94FE\\u8868\\u65E0\\u73AF; O(n) time and use only O(1) memory\\n2.\\u7406\\u89E3\\uFF1A\\u4E24\\u4E2A\\u5355\\u94FE\\u8868\\u7684intersection\\uFF0C\\u5373\\u5730\\u5740\\u76F8\\u540C\\u7684\\u4E24\\u4E2A\\u8282\\u70B9\\uFF0C\\u5373nodeA == nodeB\\uFF0C\\u6B64\\u65F6nodeA.val=nodeB.val,nodeA.next=nodeB.next\\n(\\u6CE8\\u610F\\uFF1Aval\\u76F8\\u540C\\uFF0Cnext\\u76F8\\u540C\\u7684\\u4E24\\u4E2A\\u8282\\u70B9\\u7684\\u5730\\u5740\\u4E0D\\u4E00\\u5B9A\\u76F8\\u540C\\uFF0C\\u6545\\u4E0D\\u4E00\\u5B9A\\u76F8\\u7B49)\\n\\u4FDD\\u6301\\u539F\\u6709\\u7ED3\\u6784->\\u4E0D\\u6784\\u5EFA\\u65B0\\u7684\\u94FE\\u8868\\uFF1BO(1) memory->iterative method;\\n3.\\u7C7B\\u578B\\uFF1A\\u94FE\\u8868\\u9898\\uFF1B\\u4E24\\u5355\\u94FE\\u8868\\uFF1B\\u627E\\u4EA4\\u70B9\\n4.\\u8FB9\\u754C\\u6761\\u4EF6\\uFF1A\\u94FE\\u8868\\u4E3ANone\\uFF1B\\u4E3A\\u8282\\u70B9\\n\"\"\"\\n\\n########################   brute force   ##########################\\n\\'\\'\\'\\n\\u672C\\u65B9\\u6CD5\\u7684time complex \\u662FO(mn), leetcode\\u8D85\\u65F6\\uFF0C\\u4E0D\\u7B26\\u5408\\u9898\\u610F\\n\\u601D\\u8DEF\\uFF1Afor each node a in list A, traverse the entire list B and check if any node\\nin list B coincides with a\\n\\u65B9\\u6CD5\\uFF1A\\u5185\\u5916\\u4E24\\u4E2Awhile\\u5FAA\\u73AF\\uFF08for\\u5FAA\\u73AF\\u9700\\u8981\\u8BA1\\u7B97list\\u957F\\u5EA6\\uFF09\\uFF0C\\u4E0D\\u65AD\\u8FED\\u4EE3\\uFF0C\\u9047\\u5230\\u76F8\\u540C\\u5730\\u5740\\u7684\\u5219\\u8FD4\\u56DEnode\\uFF0C\\n\\u5168\\u4E0D\\u76F8\\u540C\\u5219\\u8FD4\\u56DENone\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0CO(mn)\\nspace complex: O(1)\\n\\'\\'\\'\\n\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        while headA:\\n            currB = headB\\n            while currB:\\n                if headA == currB:\\n                    return headA\\n                else:\\n                    currB = currB.next\\n            headA = headA.next\\n        return None\\n\\n###########################  Hash Table  ##############################\\n\\'\\'\\'\\n\\u65B0\\u65B9\\u6CD5\\n\\u601D\\u8DEF\\uFF1A\\u628AA\\u7684\\u5404\\u4E2A\\u8282\\u70B9/\\u8282\\u70B9\\u7684\\u5730\\u5740\\u5B58\\u5165\\u5B58\\u50A8\\u7ED3\\u6784\\uFF0C\\u7136\\u540Etraverse\\u5404\\u4E2AB\\u8282\\u70B9\\uFF0C\\u770B\\u770B\\u6709\\u6CA1\\u6709\\u76F8\\u540C\\u7684\\n\\u65B9\\u6CD5\\uFF1AA\\u4E2D\\u6BCF\\u4E00\\u4E2Anode\\u90FD\\u4E0D\\u4E00\\u6837\\uFF0C\\u6545\\u53EF\\u4EE5\\u7528list/hash table(dic/set)\\u5B9E\\u73B0\\u5B58\\u50A8\\u7ED3\\u6784\\uFF0C\\n\\u4F46\\u662F\\u7531\\u4E8Ehash table\\u7684time complexity\\u4E3AO(1), \\u800Clist\\u4E3AO(n), \\u6545\\u4F7F\\u7528hash table\\u5B9E\\u73B0\\uFF0C\\u7136\\u540Etraverse B\\u4E2Dnode\\n\\u7528 X in hash table \\u6765\\u5B9E\\u73B0\\u5224\\u65AD\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0C\\u6DFB\\u52A0\\u65F6O(m)\\uFF0C\\u8FED\\u4EE3\\u65F6O(n)\\uFF0C\\u67E5\\u8BE2\\u65F6O(1),\\u6545\\u603B\\u8BA1\\u4E3AO(m+n+1) \\n\\u800C\\u7528list\\u7684\\u67E5\\u8BE2time complex \\u65F6O(n),\\u603B\\u8BA1\\u4E3AO(m+2n)\\n->\\u7591\\u95EE\\uFF1Flist\\u8D85\\u65F6\\uFF0C\\u4F46\\u662F\\u4ED6\\u4E0Etwo pointer method 1 \\u76F8\\u6BD4\\u770B\\u8D77\\u6765\\u5DEE\\u522B\\u4E0D\\u5927\\n->\\u53EF\\u80FD\\u56E0\\u4E3Atpm 1\\u7684\\u6700\\u5927\\u662FO(2m+2n)\\uFF0C\\u4F46\\u662F\\u5E73\\u65F6\\u8FDC\\u672A\\u5230\\uFF0C\\u800C\\u7528list\\uFF0C\\u4E00\\u5B9A\\u662FO(m+2n)\\nspace complex: max(O(m),O(n))\\n\\'\\'\\'\\nclass Solution:\\n    class Solution:\\n        def getIntersectionNode(self, headA, headB):\\n            if headA == None or headB == None:\\n                return None\\n            hash_table = {}\\n            # or hash_table = set()\\n            while headA:\\n                hash_table[headA] = 1\\n                #hash_table.add(headA)\\n                headA = headA.next\\n            while headB:\\n                if headB in hash_table:\\n                    return headB\\n                else:\\n                    headB = headB.next\\n            return None\\n\\'\\'\\'\\n\\u5982\\u4E0B\\u4EE3\\u7801\\u6709\\u9519\\u8BEF\\uFF0C\\u56E0\\u4E3Acontinue\\uFF0C\\u6545headB = headB.next \\u6CA1\\u6709\\u8FD0\\u884C\\n                else:\\n                    continue\\n                headB = headB.next\\n\\'\\'\\'\\n######################## reduce gap method ##########################\\n\\'\\'\\'\\n\\u601D\\u8DEF\\uFF1A\\u5206\\u522B\\u4ECE\\u4E24\\u6BB5\\u76F8\\u540C\\u957F\\u5EA6\\u7684\\u8D77\\u59CB\\u70B9\\u5F00\\u59CB\\u5F80\\u540Eiterative\\n\\u65B9\\u6CD5\\uFF1A\\u6C42\\u957F\\u5EA6\\u5DEE\\u5F02->\\u79FB\\u52A8\\u8F83\\u957F\\u6BB5\\u7684pointer\\u5230\\u4E0E\\u8F83\\u77ED\\u6BB5\\u76F8\\u540C\\u7684\\u957F\\u5EA6\\u5904-\\u300B\\u4E24\\u6761\\u94FE\\u8868\\u4E00\\u8D77\\u8DD1\\uFF0C\\n\\u6700\\u591A\\u8DD1\\u516C\\u5171\\u957F\\u5EA6\\uFF0C\\u627E\\u4EA4\\u70B9\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0CO(m)+O(n) + O(m-n) + min(O(m),O(n)) = O(n)\\nspace complex: O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        if headA == None or headB == None:\\n            return None\\n\\n        currA=headA\\n        currB=headB\\n\\n        lengthA=0\\n        while currA:\\n            lengthA+=1\\n            currA=currA.next\\n        lengthB=0\\n        while currB:\\n            lengthB+=1\\n            currB=currB.next\\n\\n        if lengthA > lengthB:\\n            gap = lengthA - lengthB\\n            while gap:\\n                headA=headA.next\\n                gap-=1\\n            while lengthB:\\n                lengthB -= 1\\n                if headA == headB:\\n                    return headA\\n                else:\\n                    headA = headA.next\\n                    headB = headB.next\\n            return None\\n\\n        elif lengthA == lengthB:\\n            while lengthA:\\n                lengthA -= 1\\n                if headA == headB:\\n                    return headA\\n                else:\\n                    headA = headA.next\\n                    headB = headB.next\\n            return None\\n\\n        elif lengthA < lengthB:\\n            gap = lengthB - lengthA\\n            while gap:\\n                headB=headB.next\\n                gap-=1\\n            while lengthA:\\n                lengthA -= 1\\n                if headA == headB:\\n                    return headA\\n                else:\\n                    headA = headA.next\\n                    headB = headB.next\\n            return None\\n\\n####################### Two pointer method 1 ###########################\\n\\'\\'\\'\\n\\u601D\\u8DEF\\uFF1A\\u540C\\u65F6\\u8FED\\u4EE3A\\u548CB\\uFF0CA\\u8FD0\\u884C\\u5B8C\\u63A5\\u4E0AB\\u8FD0\\u884C\\uFF0CB\\u8FD0\\u884C\\u5B8C\\u63A5\\u4E0AA\\u8FD0\\u884C\\uFF0C\\u8FC7\\u7A0B\\u4E2D\\uFF0C\\u5982\\u76F8\\u9047\\u5219\\u4E3A\\u4EA4\\u70B9\\uFF0C\\u5982\\u4E0D\\u76F8\\u9047\\u5219\\u8FD4\\u56DENone\\n\\u65B9\\u6CD5\\uFF1A\\u8BBE\\u8BA1\\u5FAA\\u73AF\\uFF0C\\u5224\\u65AD\\u6761\\u4EF6\\u4E3AA\\u957F+B\\u957F\\u7684\\u5FAA\\u73AF\\u6B21\\u6570\\uFF0CA\\u5FAA\\u73AF\\u5B8C\\u540E\\u4E3ANone\\u65F6\\uFF0C\\u7528\\u8D4B\\u503C\\u62FC\\u63A5\\u8FDE\\u63A5B\\uFF0CB\\u540C\\u7406\\uFF0C\\u5F53headA=headB\\u65F6\\u8DF3\\u51FA\\u8FD4\\u56DEhead\\uFF0C\\u5F53\\u5FAA\\u73AF\\u5B8C\\u6210\\u4E4B\\u540E\\u90FD\\u65E0\\uFF0C\\u5219\\u8FD4\\u56DENone\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0C0(m)+O(n)+O(m)+O(n) = 0(2m+2n)=O(n)\\nspace complex: O(1)\\n\\n\\u6CE8\\uFF1A\\u8D4B\\u503C\\u62FC\\u63A5\\u548Cnext\\u62FC\\u63A5\\u7684\\u533A\\u522B\\n\\u8D4B\\u503C\\u62FC\\u63A5\\u4EE5\\u540E\\uFF0C\\u672A\\u6539\\u53D8\\u539F\\u6709\\u7ED3\\u6784\\uFF1B\\u800C\\u5982\\u679C\\u662F\\u7528.next=\\u8FDB\\u884C\\u62FC\\u63A5\\uFF0C\\u5219\\u6539\\u53D8\\u4E86\\u539F\\u6709\\u7ED3\\u6784\\u3002\\n\\u540C\\u65F6\\u7531\\u4E8E\\u662FA\\u62FCB\\uFF0CB\\u62FCA\\uFF0C\\u90A3\\u4E48\\u8D4B\\u503C\\u62FC\\u63A5\\u7ED3\\u679C\\u662F\\u4E24\\u4E2A\\u5206\\u6BB5AB,BA,\\u800Cnext\\u62FC\\u63A5\\u662F\\u73AF A-B-A\\n\\'\\'\\'\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        if headA == None or headB == None:\\n            return None\\n\\n        currA=headA\\n        currB=headB\\n        lengthA = 0\\n        lengthB = 0\\n        while currA:\\n            lengthA += 1\\n            currA = currA.next\\n        while currB:\\n            lengthB += 1\\n            currB = currB.next\\n\\n        sum_length = lengthA + lengthB\\n        tempA=headA\\n        tempB=headB\\n        while sum_length:\\n            if not headA:\\n                headA = tempB\\n            if not headB:\\n                headB = tempA\\n            if headA == headB:\\n                return headA\\n            headA = headA.next\\n            headB = headB.next\\n            sum_length -= 1\\n        return None\\n\\n#######################  Two pointer method 2 ###########################\\n\\'\\'\\'\\nTwo pointer method 1 \\u7684\\u4F18\\u5316\\u7248\\n\\u601D\\u8DEF\\uFF1A\\u4E0ETwo pointer method 1\\u76F8\\u540C\\n\\u65B9\\u6CD5\\uFF1Awhile\\u5224\\u65AD\\u6761\\u4EF6\\u6539\\u4E3AheadA!=headB\\uFF0C\\u5F53\\u6709\\u4EA4\\u53C9\\u70B9\\u4E14\\u8FD0\\u884C\\u5230\\u4EA4\\u53C9\\u70B9\\u65F6\\uFF0Cwhile\\u4E0D\\u6EE1\\u8DB3\\uFF0C\\u8DF3\\u51FA\\uFF0C\\u8FD4\\u56DE\\u4EA4\\u53C9\\u70B9(headA)\\uFF1B\\n\\u5F53\\u6CA1\\u6709\\u4EA4\\u53C9\\u70B9\\u65F6\\uFF0C\\u9012\\u5F52\\u5B8C\\u4E24\\u4E2A\\u5206\\u6BB5\\uFF0C\\u4E24\\u4E2A\\u6307\\u9488\\u90FD\\u6307\\u5411\\u7684\\u5206\\u6BB5\\u7684\\u672B\\u5C3E\\uFF08curA = None,curB= None)\\uFF0Cwhile\\u4E0D\\u6EE1\\u8DB3\\uFF0C\\u8DF3\\u51FA\\uFF0C\\u8FD4\\u56DE\\u4EA4\\u53C9\\u70B9\\uFF08headA=None\\uFF09\\nwhile\\u5224\\u65AD\\u6761\\u4EF6\\u4E0D\\u80FD\\u7528headA==None or headB==None,\\u56E0\\u4E3Atraverse\\u5230\\u62FC\\u63A5\\u70B9\\u65F6\\uFF0CheadA or headB\\u4E5F\\u4F1A\\u4E3ANone;\\n\\u7528and\\u65F6\\uFF0C\\u82E5\\u6709\\u4EA4\\u53C9\\u70B9\\uFF0C\\u8FD8\\u8981\\u6DFB\\u52A0\\u5176\\u4ED6\\u6761\\u4EF6\\u8FDB\\u884C\\u8FD4\\u56DE\\u4EA4\\u5DEE\\u70B9\\u3002\\u6545\\u7528 while curA != curB:\\u662F\\u6700\\u597D\\u7684\\u3002\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0C\\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0C0(m)+O(n)=O(m+n)=O(n)\\nspace complex: O(1)\\n\\n\\u6CE8\\uFF1A\\u65B0\\u578B\\u4E66\\u5199\\u65B9\\u5F0F\\uFF1A\\n            if curA:\\n                curA = curA.next\\n            else:\\n                curA = headB\\n            \\u4E0E\\n            curA = curA.next if curA else headB\\n            \\u76F8\\u540C\\n\\'\\'\\'\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        if headA == None or headB == None:\\n            return None\\n\\n        curA = headA\\n        curB = headB\\n        while curA != curB:\\n            if curA:\\n                curA = curA.next\\n            else:\\n                curA = headB\\n            curB = curB.next if curB else headA\\n        return curA\\n\\n######################Two pointer method 3#######################################\\n\\'\\'\\'\\n\\u672C\\u65B9\\u6CD5\\u7531\\u4E8E\\u7528next\\u8FDE\\u63A5\\u4E86A\\u548CB\\uFF0C\\u6539\\u53D8\\u4E86\\u539F\\u94FE\\u8868\\u7684\\u7ED3\\u6784\\uFF0C\\u6545\\u4E0D\\u7B26\\u5408\\u9898\\u610F\\n\\u601D\\u8DEF\\uFF1AA\\u5C3E\\u8FDEB\\u5934\\uFF0CB\\u5C3E\\u8054A\\u5934\\uFF0CA,B\\u4E24\\u5934\\u540C\\u65F6iterative\\uFF0C\\u76F8\\u9047\\u7684\\u65F6\\u5019\\u5373\\u4EA4\\u70B9\\uFF0C\\u4E0D\\u76F8\\u9047\\u5219\\u6CA1\\u6709\\u4EA4\\u70B9\\n\\u65B9\\u6CD5\\uFF1AA pointer\\u79FB\\u52A8\\u5230\\u672B\\u5C3E\\uFF0C\\u540E\\u8FDE\\u63A5B\\u5934\\uFF1BB\\u540C\\u6837\\u505A->\\u540C\\u65F6\\u4ECEA,B\\u5934\\u5F00\\u59CB\\u79FB\\u52A8\\uFF0C\\u6700\\u591A\\u79FB\\u52A8m+n\\u6B21\\uFF0C\\u76F8\\u7B49\\u5219\\u8FD4\\u56DEnode\\uFF0C\\u5168\\u90E8\\u4E0D\\u80FD\\u5219\\u8FD4\\u56DENone\\ntime complex: \\u8BBEm\\uFF0Cn\\u4E3A\\u4E24\\u6BB5\\u7684\\u957F\\u5EA6\\uFF0CO(m)+O(n) + max(O(n),O(m)) = O(n)\\nspace complex: O(1)\\n\\'\\'\\'\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.next = None\\n\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA, headB):\\n        if headA == None or headB == None:\\n            return None\\n\\n        currA = headA\\n        currB = headB\\n        lengthA = 0\\n        lengthB = 0\\n        while currA:\\n            lengthA += 1\\n            prevA = currA\\n            currA = currA.next\\n        while currB:\\n            lengthB += 1\\n            prevB = currB\\n            currB = currB.next\\n\\n        prevA.next = headB\\n        prevB.next = headA\\n\\n        sum_length = lengthA + lengthB\\n        while sum_length:\\n            sum_length -= 1\\n            if headA == headB:\\n                return headA\\n            else:\\n                headA = headA.next\\n                headB = headB.next\\n        return None\\n\\n######################\\u6784\\u9020\\u4EA4\\u53C9\\u94FE\\u8868######################################\\nA1 = ListNode(4)\\nA2 = ListNode(1)\\n\\nB1 = ListNode(5)\\nB2 = ListNode(0)\\nB3 = ListNode(1)\\n\\nC1 = ListNode(8)\\nC2= ListNode(4)\\nC3= ListNode(5)\\n\\n\\n\\nA1.next = A2\\nA2.next=C1\\nC1.next=C2\\nC2.next=C3\\n\\nB1.next=B2\\nB2.next=B3\\nB3.next=C1\\n\\n\\nrl = Solution()\\nrl.getIntersectionNode(A1,B1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342805,
                "title": "hashtable-solution-o-m-n",
                "content": "```\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        \"\"\"\\n        :type head1, head1: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        hash_table_A = {}\\n        while headA != None:\\n            hash_table_A[headA] = headA.next\\n            headA = headA.next\\n        while headB != None:\\n            if headB in hash_table_A:\\n                return headB\\n            headB = headB.next\\n        return None\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n        \"\"\"\\n        :type head1, head1: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        hash_table_A = {}\\n        while headA != None:\\n            hash_table_A[headA] = headA.next\\n            headA = headA.next\\n        while headB != None:\\n            if headB in hash_table_A:\\n                return headB\\n            headB = headB.next\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 268844,
                "title": "example-1-why-is-it-intersection-at-8",
                "content": "Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nOutput: Reference of the node with value = 8\\nInput Explanation: The intersected node\\'s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\\n\\nDon\\'t listA and listB intersect at node=1? I even fail the test case for it. Here is my code for reference:\\n\\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        if(headA == null || headB == null) {\\n            return null;\\n        }\\n        \\n        // Calculate length of each list\\n        ListNode temp = headA;\\n        int lengthA = 0;\\n        while(temp != null) {\\n            temp = temp.next;\\n            lengthA++;\\n            //temp = temp.next;\\n        }\\n        \\n        temp = headB;\\n        int lengthB = 0;\\n        while(temp != null) {\\n            temp = temp.next;\\n            lengthB++;\\n            //temp = temp.next;\\n        }\\n        \\n        // Determine which list is longer\\n        ListNode longer = lengthA > lengthB ? headA : headB;\\n        ListNode shorter = lengthA < lengthB ? headA : headB;\\n        \\n        // Move the longer pointer so its aligned with the shorter\\n        int diff = Math.abs(lengthA - lengthB);\\n        for(int i = 0; i < diff; i++) {\\n            longer = longer.next;\\n        }\\n        \\n        // Find intersection point\\n        while(longer != null && shorter != null) {\\n            if(longer.val == shorter.val) {\\n                return longer;\\n            }\\n            longer = longer.next;\\n            shorter = shorter.next;\\n        }\\n        \\n        return null;\\n    } \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        if(headA == null || headB == null) {\\n            return null;\\n        }\\n        \\n        // Calculate length of each list\\n        ListNode temp = headA;\\n        int lengthA = 0;\\n        while(temp != null) {\\n            temp = temp.next;\\n            lengthA++;\\n            //temp = temp.next;\\n        }\\n        \\n        temp = headB;\\n        int lengthB = 0;\\n        while(temp != null) {\\n            temp = temp.next;\\n            lengthB++;\\n            //temp = temp.next;\\n        }\\n        \\n        // Determine which list is longer\\n        ListNode longer = lengthA > lengthB ? headA : headB;\\n        ListNode shorter = lengthA < lengthB ? headA : headB;\\n        \\n        // Move the longer pointer so its aligned with the shorter\\n        int diff = Math.abs(lengthA - lengthB);\\n        for(int i = 0; i < diff; i++) {\\n            longer = longer.next;\\n        }\\n        \\n        // Find intersection point\\n        while(longer != null && shorter != null) {\\n            if(longer.val == shorter.val) {\\n                return longer;\\n            }\\n            longer = longer.next;\\n            shorter = shorter.next;\\n        }\\n        \\n        return null;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020914,
                "title": "two-pointer-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n# **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n# **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\n# Two Pointer Approach\\nHere\\'s a step-by-step explanation of your getIntersectionNode function:\\n\\nNull Check: You begin by checking if either of the input linked lists (headA or headB) is empty. If either of them is empty (i.e., NULL), there can be no intersection, so you immediately return NULL.\\n\\nInitialization: You initialize two pointers, temp1 and temp2, which initially point to the heads of the two linked lists, headA and headB, respectively.\\n\\nIntersection Detection Loop: You enter a loop that continues until temp1 and temp2 point to the same node (i.e., they intersect). Within the loop:\\n\\nYou check if temp1 has reached the end of headA (i.e., temp1 == NULL). If it has, you reset temp1 to the head of headB. This step is essential because if temp1 reaches the end of headA and continues into headB, it ensures that temp1 and temp2 travel the same distance when searching for the intersection point.\\n\\nSimilarly, you check if temp2 has reached the end of headB (i.e., temp2 == NULL). If it has, you reset temp2 to the head of headA. Again, this step maintains the balance in the distances traveled by temp1 and temp2.\\n\\nIn each iteration of the loop, both temp1 and temp2 move one step forward in their respective linked lists. This step is crucial because it allows the pointers to eventually meet at the intersection point if one exists.\\n\\nReturn Intersection Point: Once the loop exits, it means that temp1 and temp2 have met at the intersection point if there is one. You return either temp1 or temp2 (they are now pointing to the same intersection node) as the result.\\n\\nThis approach works because it effectively balances the traversal lengths of headA and headB, ensuring that both pointers start from the other linked list when they reach the end of their respective lists. When they eventually meet, it\\'s guaranteed to be at the intersection point, or NULL if there is no intersection.\\n\\nThe time complexity of this approach is O(m + n), where m and n are the lengths of headA and headB respectively, as both pointers traverse their respective lists once.\\n\\nThe space complexity is O(1) because you are using only a constant amount of additional memory for the two pointers and some temporary variables.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**O(M+N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **0(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if(!headA || !headB)\\n        {\\n            return NULL;\\n        }\\n        ListNode *temp1=headA;\\n        ListNode *temp2=headB;\\n\\n        while(temp1!=temp2)\\n        {\\n            if(temp1==NULL)\\n            {\\n                temp1=headB;\\n            }else\\n            temp1=temp1->next;\\n            if(temp2==NULL)\\n            {\\n                temp2=headA;\\n            }else\\n            temp2=temp2->next;\\n        }\\n        return temp1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if(!headA || !headB)\\n        {\\n            return NULL;\\n        }\\n        ListNode *temp1=headA;\\n        ListNode *temp2=headB;\\n\\n        while(temp1!=temp2)\\n        {\\n            if(temp1==NULL)\\n            {\\n                temp1=headB;\\n            }else\\n            temp1=temp1->next;\\n            if(temp2==NULL)\\n            {\\n                temp2=headA;\\n            }else\\n            temp2=temp2->next;\\n        }\\n        return temp1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985657,
                "title": "python-94-40-faster-o-1-space-2-approaches",
                "content": "```\\n#Time Complexity: O(n)\\n#Space Complexity: O(n)\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        s=set()\\n        while headA:\\n            s.add(headA)\\n            headA=headA.next\\n        while headB:\\n            if headB in s:\\n                return headB\\n            headB=headB.next\\n        return None\\n\\n#Time Complexity: O(n)\\n#Space Complexity: O(1)\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        c1=c2=0\\n        temp1,temp2=headA,headB\\n        while temp1 or temp2:\\n            if temp1:\\n                c1+=1\\n                temp1=temp1.next\\n            if temp2:\\n                c2+=1\\n                temp2=temp2.next\\n        c=c1-c2\\n        if c<0:\\n            while c!=0:\\n                headB=headB.next\\n                c+=1\\n        else:\\n            while c!=0:\\n                headA=headA.next\\n                c-=1\\n        while headA:\\n            if headA==headB:\\n                return headA\\n            headA=headA.next\\n            headB=headB.next\\n        return headA\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n#Time Complexity: O(n)\\n#Space Complexity: O(n)\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        s=set()\\n        while headA:\\n            s.add(headA)\\n            headA=headA.next\\n        while headB:\\n            if headB in s:\\n                return headB\\n            headB=headB.next\\n        return None\\n\\n#Time Complexity: O(n)\\n#Space Complexity: O(1)\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        c1=c2=0\\n        temp1,temp2=headA,headB\\n        while temp1 or temp2:\\n            if temp1:\\n                c1+=1\\n                temp1=temp1.next\\n            if temp2:\\n                c2+=1\\n                temp2=temp2.next\\n        c=c1-c2\\n        if c<0:\\n            while c!=0:\\n                headB=headB.next\\n                c+=1\\n        else:\\n            while c!=0:\\n                headA=headA.next\\n                c-=1\\n        while headA:\\n            if headA==headB:\\n                return headA\\n            headA=headA.next\\n            headB=headB.next\\n        return headA\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799162,
                "title": "simple-python-solution",
                "content": "\\nWe basically want to increase both A and B till they come out equal. The difference in the lengths can be managed in the same line using simple if-else.\\nJust keep on moving A and B till they become equal\\n# Code\\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        if headA and headB:\\n            A, B = headA, headB\\n            while A != B:\\n                A = A.next if A else headB\\n                B = B.next if B else headA\\n            return B\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        if headA and headB:\\n            A, B = headA, headB\\n            while A != B:\\n                A = A.next if A else headB\\n                B = B.next if B else headA\\n            return B\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151072,
                "title": "best-o-m-n-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* curr1 = headA, * curr2 = headB;\\n        while (curr2 != NULL) {\\n            ListNode* temp = curr1;\\n            while (temp != NULL) {\\n                if (temp == curr2)\\n                    return curr2;\\n                temp = temp->next;\\n            }\\n            curr2 = curr2->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n\\n# Approach 2\\nHashing\\n\\n# Complexity\\n- Time complexity:\\n$$O(m+n)$$ \\n\\n- Space complexity:\\n$$O(m)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_set <ListNode* > nodes;\\n        ListNode* curr = headA;\\n        while (curr != NULL) {\\n            nodes.insert(curr);\\n            curr = curr->next;\\n        }\\n        curr = headB;\\n        while (curr != NULL) {\\n            if (nodes.find(curr) != nodes.end())\\n                return curr;\\n            curr = curr->next;    \\n        }\\n        return NULL;\\n    }\\n};\\n```\\n\\n\\n# Approach 3\\nOptimal\\n\\n# Complexity\\n- Time complexity:\\n$$O(m+n)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* curr1 = headA, * curr2 = headB;\\n        while (curr1 != curr2) {\\n            curr1 = curr1->next;\\n            curr2 = curr2->next;\\n            if (curr1 == curr2)\\n                return curr1;\\n            if (curr1 == NULL)\\n                curr1 = headB;\\n            if (curr2 == NULL)\\n                curr2 = headA;\\n        }\\n        return curr1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* curr1 = headA, * curr2 = headB;\\n        while (curr2 != NULL) {\\n            ListNode* temp = curr1;\\n            while (temp != NULL) {\\n                if (temp == curr2)\\n                    return curr2;\\n                temp = temp->next;\\n            }\\n            curr2 = curr2->next;\\n        }\\n        return NULL;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_set <ListNode* > nodes;\\n        ListNode* curr = headA;\\n        while (curr != NULL) {\\n            nodes.insert(curr);\\n            curr = curr->next;\\n        }\\n        curr = headB;\\n        while (curr != NULL) {\\n            if (nodes.find(curr) != nodes.end())\\n                return curr;\\n            curr = curr->next;    \\n        }\\n        return NULL;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* curr1 = headA, * curr2 = headB;\\n        while (curr1 != curr2) {\\n            curr1 = curr1->next;\\n            curr2 = curr2->next;\\n            if (curr1 == curr2)\\n                return curr1;\\n            if (curr1 == NULL)\\n                curr1 = headB;\\n            if (curr2 == NULL)\\n                curr2 = headA;\\n        }\\n        return curr1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136735,
                "title": "most-optimal-java-sol-1ms-98-6-beats",
                "content": "# Intuition\\n1) put dumm 1 & dummy 2 node on both heads then move them one by one.\\n2) when one reaches end or null put that dummy node at head of other list i.e. dummy1==null then dummy1 = head2.\\n3) after dummy 1 when dummy2 will reach null put it at head1.\\n4) and now at this point the length of both lists from both dummy to end will be equal.\\n5) if they refer to same address while iterating return it.\\n6) otherwise if they reach null together there is no intersection.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2m) m length of greater list\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n    if(headA==null || headB==null)  return null;\\n    ListNode a = headA;\\n    ListNode b = headB;\\n    while(a!=b){\\n        a = a==null ? headB : a.next;\\n        b = b==null ? headA : b.next;\\n    }\\n    return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n    if(headA==null || headB==null)  return null;\\n    ListNode a = headA;\\n    ListNode b = headB;\\n    while(a!=b){\\n        a = a==null ? headB : a.next;\\n        b = b==null ? headA : b.next;\\n    }\\n    return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721631,
                "title": "very-easy-and-detailed-explanation-in-python",
                "content": "**Explanation**\\nHere we are traversing the pointers two times in the Linked List.\\nEighter of the two who will first encounter the None, are going to switch the head and continue the second traversal,\\n\\nThe idea is if you switch head, the possible difference between length would be countered. On the second traversal, they either hit or miss. \\nIf they meet, pa or pb would be the node we are looking for, if they didn\\'t meet, they will hit the end at the same iteration, pa == pb == None.\\n```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        if headA is None or headB is None:\\n            return None\\n\\n        pa = headA \\n        pb = headB\\n\\n        while pa is not pb:\\n            if pa is None:\\n                pa = headB \\n            else:\\n                pa=pa.next\\n            if pb is None:\\n                pb = headA \\n            else:\\n                pb=pb.next\\n\\n        return pa\\n\\n\\n```\\n![image](https://assets.leetcode.com/users/images/225dd7bc-f7c4-487e-9019-316ae9cde3fd_1666176062.6584425.jpeg)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        if headA is None or headB is None:\\n            return None\\n\\n        pa = headA \\n        pb = headB\\n\\n        while pa is not pb:\\n            if pa is None:\\n                pa = headB \\n            else:\\n                pa=pa.next\\n            if pb is None:\\n                pb = headA \\n            else:\\n                pb=pb.next\\n\\n        return pa\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278151,
                "title": "simple-python-solution-beats-96-with-comments",
                "content": "```\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n\\n        seen = set()    #Create a set for seen nodes\\n        while headA or headB:   \\n            if headA:\\n                if headA in seen:   # If B has passed the node previously, then this is the intersect\\n                    return headA\\n                else:\\n                    seen.add(headA) # record the node if not previously seen\\n                headA = headA.next\\n                \\n            if headB:\\n                if headB in seen:\\n                    return headB\\n                else:\\n                    seen.add(headB)\\n                headB = headB.next\\n        return  # if no intersect, return None\\n\\n#If you find this solution helpful, please upvote :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def getIntersectionNode(self, headA, headB):\\n\\n        seen = set()    #Create a set for seen nodes\\n        while headA or headB:   \\n            if headA:\\n                if headA in seen:   # If B has passed the node previously, then this is the intersect\\n                    return headA\\n                else:\\n                    seen.add(headA) # record the node if not previously seen\\n                headA = headA.next\\n                \\n            if headB:\\n                if headB in seen:\\n                    return headB\\n                else:\\n                    seen.add(headB)\\n                headB = headB.next\\n        return  # if no intersect, return None\\n\\n#If you find this solution helpful, please upvote :)",
                "codeTag": "Java"
            },
            {
                "id": 2146325,
                "title": "java-intersection-of-linkedlist-with-intuition-99-faster",
                "content": "### **Intuition:**\\nSuppose list-B is shorter than list-A.\\n1) Take two pointers( \\'a\\' & \\'b\\'). Point each of them to the head of the lists. (say \\'a\\' for list-A & \\'b\\' for list-B)\\n 2) Traverse both list simultaneously. After sometime, pointer \\'b\\' on shorter list-B will reach null earlier than \\'a\\' (because list-B is smaller in length). \\n In that case, the distance of other pointer \\'a\\' (currently on list-A) to the pointer \\'b\\' (which is currently null) is the difference in length of linked-lists. (This is simple math operation, difference of lengths)\\n3) Now, we point pointer \\'b\\' to list-A\\'s head (on list-A NOT on list-B)  &  move both \\'a\\' & \\'b\\' simultaneously till \\'a\\' reaches null. (Remember both the pointers \\'a\\' & \\'b\\' are currently on same list).\\n4) When \\'a\\' reaches null, pointer \\'b\\' (on list-A) will cover a distance equal to difference of length of linked-list. This is simple maths, because previously (when \\'b\\' was null), \\'a\\' pointer was at distance equal to difference in length of linked-list.\\n5) In next iteration we place \\'a\\' on list-B\\'s head (which is shorter list).\\n     Due to this, the distance of both pointer \\'a\\' & \\'b\\' (on list-B & list-A respectively) till the end becomes equal (in short both the pointer are at equal distance from their end\\n     of linked-list). This is because \\'b\\' has already travelled the difference in lengths (of linked-list) on list-A.\\n6) Then we move both the pointers together until intersection found. \\n7) Here we guaranteed that intersection will bound to occur, as both \\'a\\' & \\'b\\' are equal distances from the ends of both the lists.\\n\\n*Please DO Upvote if you found this Helpful!* \\n\\n\\n### **Code :**\\n```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode a = headA, b = headB;\\n\\n        while (a != b){\\n            a = a != null ? a.next : headB;\\n            b = b != null ? b.next : headA;\\n        }\\n        return a;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode a = headA, b = headB;\\n\\n        while (a != b){\\n            a = a != null ? a.next : headB;\\n            b = b != null ? b.next : headA;\\n        }\\n        return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2118504,
                "title": "c-linked-list-simple-approach-with-explanation-daily-leetcoding-challenge-june-day-6",
                "content": "```\\nclass Solution {\\npublic:\\n    //define two listnodes tempA for listA and tempB for listB \\n    //and iterate over the respective list until we reach at their end \\n    //when we reach at the end, we start traversing in the opposite list\\n    //until tempA and tempB are reach at the same node \\n    //if they reach we get the intersection node otherwise if there is no intersect node\\n    //we reach at NULL and return\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) \\n    {\\n        ListNode *tempA = headA, *tempB = headB;\\n        \\n        if(tempA==NULL || tempB==NULL) return NULL;\\n        \\n        while(tempA!=tempB)\\n        {\\n            tempA==NULL ? tempA=headB : tempA=tempA->next;\\n            tempB==NULL ? tempB=headA : tempB=tempB->next;\\n        }\\n        \\n        return tempA;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //define two listnodes tempA for listA and tempB for listB \\n    //and iterate over the respective list until we reach at their end \\n    //when we reach at the end, we start traversing in the opposite list\\n    //until tempA and tempB are reach at the same node \\n    //if they reach we get the intersection node otherwise if there is no intersect node\\n    //we reach at NULL and return\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) \\n    {\\n        ListNode *tempA = headA, *tempB = headB;\\n        \\n        if(tempA==NULL || tempB==NULL) return NULL;\\n        \\n        while(tempA!=tempB)\\n        {\\n            tempA==NULL ? tempA=headB : tempA=tempA->next;\\n            tempB==NULL ? tempB=headA : tempB=tempB->next;\\n        }\\n        \\n        return tempA;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118189,
                "title": "c-optimal-solution-explained-super-smooth",
                "content": "**Please do upvote if you like the solution:)**\\n\\n**Algorithm:**\\nstep-1: make 2 pointers d1 & d2 which will be pointing to L1 and L2 repectively.\\nstep-2: keep iterating both the pointers (until both becomes NULL) by one step and assign to one- other linked-list if any of the pointer reaches NULL.\\nsep-3: If there is a intersection point then definitely d1 == d2 at some point then we will return either d1 or d2.\\n\\n\\n**Code:**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {        //optimal oneih\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* d1 = headA;\\n        ListNode* d2 = headB;\\n        \\n        while(d1 || d2 || d1!=d2){\\n            if(d1==d2)\\n                return d1;          //return if both are equal; if not intersect: NULL-NULL\\n            \\n            if(d1==NULL){            //asssign to another LL, if any of them reaches NULL\\n                d1 = headB;\\n                continue;\\n            }\\n                \\n            if(d2==NULL){\\n                d2 = headA;\\n                continue;\\n            }\\n                \\n            d1 = d1->next;\\n            d2 = d2->next;\\n        }\\n        return d1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {        //optimal oneih\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* d1 = headA;\\n        ListNode* d2 = headB;\\n        \\n        while(d1 || d2 || d1!=d2){\\n            if(d1==d2)\\n                return d1;          //return if both are equal; if not intersect: NULL-NULL\\n            \\n            if(d1==NULL){            //asssign to another LL, if any of them reaches NULL\\n                d1 = headB;\\n                continue;\\n            }\\n                \\n            if(d2==NULL){\\n                d2 = headA;\\n                continue;\\n            }\\n                \\n            d1 = d1->next;\\n            d2 = d2->next;\\n        }\\n        return d1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2117054,
                "title": "cpp-solution-3-approaches-from-o-n-space-to-o-1-easy",
                "content": "__Thanks for checking out my solution\\nDo Upvote this post, if you found this helpful :))__\\n\\n____\\n__Approach 1 : Simplest but fails on the follow up constraints__\\n__Use a unordered set (Uses O(1) time for operations)\\nTraverse the first list and Store all the nodes of the first list in it\\nTraverse the second list and check for each node in the set__\\n>__If found, return the node__\\n\\n__Return Null, if during the traversal, nothing was returned__\\n\\n```\\nclass Solution\\n{ // 58 ms, faster than 30.98% of C++ online submissions for Intersection of Two Linked Lists.\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        unordered_set<ListNode *> s; // The idea is pretty straight forward\\n        while (headA)                // Traverse the list\\n        {\\n            s.insert(headA); // Add the nodes to the set\\n            headA = headA->next;\\n        }\\n        while (headB) // Traverse the list 2\\n        {\\n            if (s.find(headB) != s.end()) // if any node is already in the set, return the node\\n                return headB;\\n            headB = headB->next;\\n        }\\n        return NULL; // If the control has not been returned, till now, return NULL\\n    }\\n};\\n```\\n__Time Complexity : O(m * n)\\nSpace Complexity : O(n)__\\n\\n__Since this method uses extra space, it violates the follow up condition. Lets think for a more optimised approach.__\\n\\n____\\n\\n__Approach 2 : Space Optimisation__\\n__Thinking about Space optimisation is what brings us to this solution__\\n\\n__Step 1 : Get the lengths of the two Lists, assuming that the first list is longer than the second one.\\nStep 2 : If our assumption is wrong about the lists, swap them.\\nStep 3 : Get the difference in the lengths\\nStep 4 : Advance the first List by this difference in length__\\n>Now it is obvious that if there exists an intersection point, the length (till the end) from this assumed point will be same for both the lists\\n>We only need to bring both the lists to a point from where the number of nodes becomes same for both of them, and hence we advance the longer list(if thats the case), by the difference in their lengths\\n>>If the lists are of same size, the difference will be 0, and hence no list will be advanced\\n\\n__Step 5 : Now until a common node is found, keep advancing both the lists.\\nStep 6 : Return the address stored in the Pointer to the first List__\\n> If at some point a common node was found, the loop will break, with pointer pointing at the __Intersection Point__\\n> Otherwise the pointer will be pointing at the end of the list, i.e. __NULL__\\n\\n__Below is the Coding implementation of the above approach__\\n```\\nclass Solution\\n{ // Runtime: 48 ms, faster than 86.40% of C++ online submissions for Intersection of Two Linked Lists.\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        ListNode *t1 = headA, *t2 = headB;\\n        int c1 = 0, c2 = 0;\\n        while (t1) // Get the Length of the First List\\n        {\\n            ++c1;\\n            t1 = t1->next;\\n        }\\n        while (t2) // Get the length of the second list\\n        {\\n            ++c2;\\n            t2 = t2->next;\\n        }\\n        if (c1 < c2) // If Second List is longer than the first one, swap them, prevents if else block\\n        {\\n            swap(headA, headB);\\n            swap(c1, c2);\\n        }\\n        c1 -= c2;    // Get the Difference in length\\n        while (c1--) // Advance the first List\\n            headA = headA->next;\\n        while (headA != headB) // Now we know that list have same length, Traverse till nothing common is found\\n        {\\n            headA = headA->next; // Advance List 1\\n            headB = headB->next; // Advance List 2\\n        }\\n        return headA; // if during traversal nothing is returned, no intersection exists\\n    }\\n};\\n```\\n__Time Complexity : O(m * n)\\nSpace Complexity : O(1)__\\n\\n____\\n\\n__Approach 3 : Improved version of the Approach 2\\nHere we will take advantage of the fact that__\\n>__If the two lists have same lengths, they will either reach the intersection point (if it exists), or the end of the list, at the same time.\\n>Otherwise, one of the list will reach its end before the other, which presents us to use a Two-Pointer Approach__\\n>>___Here we assign the pointer to the shorter list, the head pointer of the longer one (A kind of two pointer Approach).\\n>>This assignment will help us advance the pointer(earlier pointing to the shorter list) to the longer list by the difference in the lengths of the two lists\\n>>Meanwhile the actual pointer to the longer list will reach the end, and is assigned the head pointer of the shorter list\\n>>These two assignments brings both the lists to a point from where they equal nodes to traverse till the end___\\n>>>Now when the two pointers advance, they will either reach the intersection point(if it exists), or the end of the list.\\n>>>In both the cases, the control will be returned, either with the __Intersection Node__ or the __NULL pointer__.\\n\\n__Below is the coding implementation of the improved upon idea of the Second Approach__\\n\\n```\\nclass Solution\\n{ // Runtime: 45 ms, faster than 92.53% of C++ online submissions for Intersection of Two Linked Lists.\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\\n    {\\n        ListNode *t1 = headA, *t2 = headB;   //traversal node 1 and traversal node 2\\n        while (t1 != t2) // Traverse till nodes are not common\\n        {\\n            t1 = t1->next; // Advance the list 1\\n            t2 = t2->next; // Advance the list 2\\n            if (t1 == t2)  // If same, return the node\\n                return t1;\\n            if (!t1)        // If t1 == NULL, list A < List B,\\n                t1 = headB; // Assign the other List\\n            if (!t2)        // If t1 == NULL, list A > List B\\n                t2 = headA; // Assign the other List\\n            /*\\n            This List assignment, will ensure that lists of different sizes, reach a point from where\\n            Both the lists have equal nodes to traverse till the end.\\n            Now t1 == t2 statement will break the loop when both the nodes point NULL\\n            Or when both the nodes point to the intersection point\\n            */\\n        }\\n        return t1; // if t1 == t2, initially, return t1\\n    }\\n};\\n```\\n__Time Complexity : O(m * n)\\nSpace Complexity : O(1)__",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution\\n{ // 58 ms, faster than 30.98% of C++ online submissions for Intersection of Two Linked Lists.\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        unordered_set<ListNode *> s; // The idea is pretty straight forward\\n        while (headA)                // Traverse the list\\n        {\\n            s.insert(headA); // Add the nodes to the set\\n            headA = headA->next;\\n        }\\n        while (headB) // Traverse the list 2\\n        {\\n            if (s.find(headB) != s.end()) // if any node is already in the set, return the node\\n                return headB;\\n            headB = headB->next;\\n        }\\n        return NULL; // If the control has not been returned, till now, return NULL\\n    }\\n};\\n```\n```\\nclass Solution\\n{ // Runtime: 48 ms, faster than 86.40% of C++ online submissions for Intersection of Two Linked Lists.\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        ListNode *t1 = headA, *t2 = headB;\\n        int c1 = 0, c2 = 0;\\n        while (t1) // Get the Length of the First List\\n        {\\n            ++c1;\\n            t1 = t1->next;\\n        }\\n        while (t2) // Get the length of the second list\\n        {\\n            ++c2;\\n            t2 = t2->next;\\n        }\\n        if (c1 < c2) // If Second List is longer than the first one, swap them, prevents if else block\\n        {\\n            swap(headA, headB);\\n            swap(c1, c2);\\n        }\\n        c1 -= c2;    // Get the Difference in length\\n        while (c1--) // Advance the first List\\n            headA = headA->next;\\n        while (headA != headB) // Now we know that list have same length, Traverse till nothing common is found\\n        {\\n            headA = headA->next; // Advance List 1\\n            headB = headB->next; // Advance List 2\\n        }\\n        return headA; // if during traversal nothing is returned, no intersection exists\\n    }\\n};\\n```\n```\\nclass Solution\\n{ // Runtime: 45 ms, faster than 92.53% of C++ online submissions for Intersection of Two Linked Lists.\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\\n    {\\n        ListNode *t1 = headA, *t2 = headB;   //traversal node 1 and traversal node 2\\n        while (t1 != t2) // Traverse till nodes are not common\\n        {\\n            t1 = t1->next; // Advance the list 1\\n            t2 = t2->next; // Advance the list 2\\n            if (t1 == t2)  // If same, return the node\\n                return t1;\\n            if (!t1)        // If t1 == NULL, list A < List B,\\n                t1 = headB; // Assign the other List\\n            if (!t2)        // If t1 == NULL, list A > List B\\n                t2 = headA; // Assign the other List\\n            /*\\n            This List assignment, will ensure that lists of different sizes, reach a point from where\\n            Both the lists have equal nodes to traverse till the end.\\n            Now t1 == t2 statement will break the loop when both the nodes point NULL\\n            Or when both the nodes point to the intersection point\\n            */\\n        }\\n        return t1; // if t1 == t2, initially, return t1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768768,
                "title": "java-solution-4-approaches-brute-hashing-optimal-best",
                "content": "1. Brute\\n\\nHere we pick a list and keep traversing it checking if the node matches. If not we move to the next node and reinitialise the list which is check to its head again.\\n\\n```\\n\\npublic class Solution {\\n\\tpublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode temp = headB;\\n        \\n         while (headA != null){\\n           while (headB != null){\\n             if (headA != headB) headB = headB.next;\\n             else return headB;\\n             }\\n\\t\\t\\theadB = temp;\\n            headA = headA.next;\\n         }\\n        \\n       return null;\\n\\t}\\n}\\n```\\n\\n2. Hashing\\n\\n We make a HashMap of any list and keep the nodes as key. If we take values as key that will break the code as similar values do exist in the test cases but we only want the intersecting node. After that we loop on the other list and check if the interesecting node is present in the map.\\n \\n```\\n\\npublic class Solution {\\n\\tpublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\t\\n        Map<ListNode, Integer> map = new HashMap<>();\\n        \\n     while (headA != null){\\n            map.put(headA, map.getOrDefault(headA, 0) + 1);\\n            headA = headA.next;\\n        }\\n        \\n        while (headB != null){\\n            if (map.containsKey(headB)) return headB;\\n            headB = headB.next;\\n        }\\n        \\n        return null;\\n\\t}\\n}\\n```\\n\\n3. Optimal (lengthy)\\n\\nIn this approach we first calucalate the length of both the list. Then we traverse again the bigger list upto the difference of the lengths. After that we traverse both the list together as they are on same length and therefore we can check for the intersecting node.\\n\\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\t\\t\\n\\t\\tint c1 = 0, c2 = 0;\\n        ListNode d1 = headA, d2 = headB;\\n        \\n        while (d1 != null){\\n            c1++;\\n            d1 = d1.next;\\n        }\\n        \\n        while (d2 != null){\\n            c2++;\\n            d2 = d2.next;\\n        }\\n        \\n        if (c1 > c2){\\n            int diff = c1 - c2;\\n            while (diff > 0){ \\n                headA = headA.next;\\n                diff--;\\n            }\\n        } else {\\n            int diff = c2 - c1;\\n            while (diff > 0) {\\n                headB = headB.next;\\n                diff--;\\n            }\\n        }\\n        \\n        while (headA != null && headB != null){\\n            if (headA == headB) return headB;\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n        \\n        return null;\\n    }\\n}\\n\\n```\\n\\n4. Best Solution\\n\\nThis is a similar approach to the first but instead of calculating the length we keep on traversing both the lists using dummy nodes. When any of the dummy reaches the null point then we shift it to the start of the other list. What this does is it reduces the length difference apparently which helps us to get the intersecting node.\\n\\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        \\n        ListNode dA = headA;\\n        ListNode dB = headB;\\n        \\n        while (dA != dB){\\n            dA = dA == null ? headB : dA.next;\\n            dB = dB == null ? headA : dB.next;\\n        }\\n        \\n        return dB;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n\\npublic class Solution {\\n\\tpublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode temp = headB;\\n        \\n         while (headA != null){\\n           while (headB != null){\\n             if (headA != headB) headB = headB.next;\\n             else return headB;\\n             }\\n\\t\\t\\theadB = temp;\\n            headA = headA.next;\\n         }\\n        \\n       return null;\\n\\t}\\n}\\n```\n```\\n\\npublic class Solution {\\n\\tpublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\t\\n        Map<ListNode, Integer> map = new HashMap<>();\\n        \\n     while (headA != null){\\n            map.put(headA, map.getOrDefault(headA, 0) + 1);\\n            headA = headA.next;\\n        }\\n        \\n        while (headB != null){\\n            if (map.containsKey(headB)) return headB;\\n            headB = headB.next;\\n        }\\n        \\n        return null;\\n\\t}\\n}\\n```\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\t\\t\\n\\t\\tint c1 = 0, c2 = 0;\\n        ListNode d1 = headA, d2 = headB;\\n        \\n        while (d1 != null){\\n            c1++;\\n            d1 = d1.next;\\n        }\\n        \\n        while (d2 != null){\\n            c2++;\\n            d2 = d2.next;\\n        }\\n        \\n        if (c1 > c2){\\n            int diff = c1 - c2;\\n            while (diff > 0){ \\n                headA = headA.next;\\n                diff--;\\n            }\\n        } else {\\n            int diff = c2 - c1;\\n            while (diff > 0) {\\n                headB = headB.next;\\n                diff--;\\n            }\\n        }\\n        \\n        while (headA != null && headB != null){\\n            if (headA == headB) return headB;\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n        \\n        return null;\\n    }\\n}\\n\\n```\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        \\n        ListNode dA = headA;\\n        ListNode dB = headB;\\n        \\n        while (dA != dB){\\n            dA = dA == null ? headB : dA.next;\\n            dB = dB == null ? headA : dB.next;\\n        }\\n        \\n        return dB;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662425,
                "title": "c-solution-using-two-pointers",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *a = headA;\\n        ListNode *b = headB;\\n        \\n        while(a!=b){\\n            a= (a==NULL) ? headB : a->next;\\n            b= (b==NULL) ? headA : b->next;\\n        }\\n        // there is no intersection and diff length \\n        //then also after second iteration both will point to NULL.\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *a = headA;\\n        ListNode *b = headB;\\n        \\n        while(a!=b){\\n            a= (a==NULL) ? headB : a->next;\\n            b= (b==NULL) ? headA : b->next;\\n        }\\n        // there is no intersection and diff length \\n        //then also after second iteration both will point to NULL.\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514699,
                "title": "easy-to-code-in-c-linked-list",
                "content": "class Solution {\\npublic:\\n\\nint len (ListNode* a) {\\n        if (!a) return 0;\\n        int cnt=0;\\n        while (a){\\n            cnt++;\\n            a = a->next;\\n        }\\n        return cnt;\\n    }\\n    \\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if (!headA && !headB) return NULL; \\n        \\n        ListNode* a = headA;\\n        ListNode* b = headB;\\n        \\n        int di = len(headA) - len(headB);\\n        \\n        while (di > 0) {\\n            a = a->next;\\n            di--;\\n        }\\n        \\n        while (di < 0) {\\n            b = b->next;\\n            di++;\\n        }\\n        \\n        while (a && b) {\\n            if(a == b) return a;\\n            a = a->next;\\n            b = b->next;\\n        }\\n        \\n        return NULL;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\nint len (ListNode* a) {\\n        if (!a) return 0;\\n        int cnt=0;\\n        while (a){\\n            cnt++;\\n            a = a->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1189812,
                "title": "simple-java-solution-faster-than-98-08",
                "content": "**Simple JAVA Solution faster than 98.08% **\\n```\\npublic ListNode getIntersectionNode(ListNode head1, ListNode head2) {\\n        ListNode cur1=head1;\\n        ListNode cur2=head2;\\n        while(cur1!=null&&cur2!=null){\\n            if(cur1==cur2){\\n                return cur1;\\n            }\\n            cur1=cur1.next;\\n            cur2=cur2.next;\\n            if(cur1 == null) { \\n                cur1 = head2;\\n            } else if(cur2 == null) { \\n                cur2 = head1;\\n            }\\n        }\\n        return null;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode getIntersectionNode(ListNode head1, ListNode head2) {\\n        ListNode cur1=head1;\\n        ListNode cur2=head2;\\n        while(cur1!=null&&cur2!=null){\\n            if(cur1==cur2){\\n                return cur1;\\n            }\\n            cur1=cur1.next;\\n            cur2=cur2.next;\\n            if(cur1 == null) { \\n                cur1 = head2;\\n            } else if(cur2 == null) { \\n                cur2 = head1;\\n            }\\n        }\\n        return null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1093170,
                "title": "intersection-of-two-linked-lists-python-o-n-time-o-1-add-l-space",
                "content": "1. We compute the lengths of the two lists.\\n2. Without loss of generality we render A at least as long as B.\\n3. We advance the head pointer of A by (len_a - len_b), namely, until both pointers have the same distance to the intersection.\\n4. We advance the two head pointers in tandem until the intersection, possibly None.\\n\\n```\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        def get_length(head: ListNode) -> int:\\n            length = 0\\n            while(head):\\n                head, length = head.next, length + 1\\n            return length\\n        \\n        len_a, len_b = get_length(headA), get_length(headB)\\n        if len_a < len_b:\\n            headA, headB, len_a, len_b = headB, headA, len_b, len_a\\n        for _ in range(len_a - len_b):\\n            headA = headA.next\\n        while headA is not headB:\\n            headA, headB = headA.next, headB.next\\n        return headA\\n```",
                "solutionTags": [],
                "code": "```\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        def get_length(head: ListNode) -> int:\\n            length = 0\\n            while(head):\\n                head, length = head.next, length + 1\\n            return length\\n        \\n        len_a, len_b = get_length(headA), get_length(headB)\\n        if len_a < len_b:\\n            headA, headB, len_a, len_b = headB, headA, len_b, len_a\\n        for _ in range(len_a - len_b):\\n            headA = headA.next\\n        while headA is not headB:\\n            headA, headB = headA.next, headB.next\\n        return headA\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092872,
                "title": "python-c-illustration-explanation-o-n-o-1-solution",
                "content": "# Explanation:\\nEverything is simple. If there is intersection, it will be on same distance from the end in both linked lists, so we just need to iterate part where potentially can have intersection. This part is last `n` elements, where `n == min(len(list1), len(list2))`.\\nI get length of both lists, and skip the first elements of longer one, until both lists pointers will not be on same distance to their ends. \\nHere is good illustration where we should search for intersection:\\n![image](https://assets.leetcode.com/users/images/33bedbe5-8127-488d-8a46-61b9a9ba6873_1614846291.9376721.png)\\n![image](https://assets.leetcode.com/users/images/4453e84f-6a75-4b27-a06e-9367b7e90ea0_1614846296.1134787.png)\\n![image](https://assets.leetcode.com/users/images/dfbed1d1-5d00-4b1b-993c-fa3d43b1cd82_1614846492.9817722.png)\\n\\n\\n\\n## Python code:\\n```\\nclass Solution:\\n  def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n    def listLen(head: ListNode) -> int:\\n      l = 0\\n      while head:\\n        l += 1\\n        head = head.next\\n      return l\\n\\n    lA = listLen(headA)\\n    lB = listLen(headB)\\n\\n    if lA > lB:\\n      for _ in range(lA - lB):\\n        headA = headA.next\\n    else:\\n      for _ in range(lB - lA):\\n        headB = headB.next\\n    \\n    while headA and headB:\\n      if headA is headB:\\n        return headA\\n      headA = headA.next\\n      headB = headB.next\\n      \\n    return None\\n```\\n\\n## C++ code:\\n```\\nclass Solution {\\n  public:\\n    int listLen(ListNode *head) {\\n      int l = 0;\\n      while (head) {\\n        ++l;\\n        head = head->next;\\n      }\\n      return l;\\n    }\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n      int lA = listLen(headA);\\n      int lB = listLen(headB);\\n\\n      if (lA > lB) {\\n        for (int i = lA - lB; i > 0; --i) {\\n          headA = headA->next;\\n        }\\n      } else {\\n        for (int i = lB - lA; i > 0; --i) {\\n          headB = headB->next;\\n        }\\n      }\\n      \\n      while (headA && headB) {\\n        if (headA == headB) {\\n          return headA;\\n        }\\n        headA = headA->next;\\n        headB = headB->next;\\n      }\\n      \\n      return nullptr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n    def listLen(head: ListNode) -> int:\\n      l = 0\\n      while head:\\n        l += 1\\n        head = head.next\\n      return l\\n\\n    lA = listLen(headA)\\n    lB = listLen(headB)\\n\\n    if lA > lB:\\n      for _ in range(lA - lB):\\n        headA = headA.next\\n    else:\\n      for _ in range(lB - lA):\\n        headB = headB.next\\n    \\n    while headA and headB:\\n      if headA is headB:\\n        return headA\\n      headA = headA.next\\n      headB = headB.next\\n      \\n    return None\\n```\n```\\nclass Solution {\\n  public:\\n    int listLen(ListNode *head) {\\n      int l = 0;\\n      while (head) {\\n        ++l;\\n        head = head->next;\\n      }\\n      return l;\\n    }\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n      int lA = listLen(headA);\\n      int lB = listLen(headB);\\n\\n      if (lA > lB) {\\n        for (int i = lA - lB; i > 0; --i) {\\n          headA = headA->next;\\n        }\\n      } else {\\n        for (int i = lB - lA; i > 0; --i) {\\n          headB = headB->next;\\n        }\\n      }\\n      \\n      while (headA && headB) {\\n        if (headA == headB) {\\n          return headA;\\n        }\\n        headA = headA->next;\\n        headB = headB->next;\\n      }\\n      \\n      return nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056026,
                "title": "python-super-simple-easy-clear-solution-o-n-time-o-1-memory",
                "content": "\\tclass Solution:\\n\\t\\tdef changeSign(self, head: ListNode):\\n\\t\\t\\twhile ( head ):\\n\\t\\t\\t\\thead.val *= -1\\n\\t\\t\\t\\thead = head.next\\n\\t\\t\\n\\t\\tdef getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n\\t\\t\\tself.changeSign(headA)\\n\\t\\t\\t\\n\\t\\t\\twhile ( headB ):\\n\\t\\t\\t\\tif headB.val < 0:break\\n\\t\\t\\t\\theadB = headB.next\\n\\t\\t\\t\\n\\t\\t\\tself.changeSign(headA)\\n\\t\\t\\treturn headB",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef changeSign(self, head: ListNode):\\n\\t\\t\\twhile ( head ):\\n\\t\\t\\t\\thead.val *= -1\\n\\t\\t\\t\\thead = head.next\\n\\t\\t\\n\\t\\tdef getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n\\t\\t\\tself.changeSign(headA)\\n\\t\\t\\t\\n\\t\\t\\twhile ( headB ):\\n\\t\\t\\t\\tif headB.val < 0:break\\n\\t\\t\\t\\theadB = headB.next\\n\\t\\t\\t\\n\\t\\t\\tself.changeSign(headA)\\n\\t\\t\\treturn headB",
                "codeTag": "Java"
            },
            {
                "id": 809226,
                "title": "python-brute-force-hashtable-two-pointer-solutions",
                "content": "Refer to https://leetcode.com/problems/intersection-of-two-linked-lists/solution/ for explanations. Here I will just provide the code samples.\\n\\n*Node Definition*\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\n```\\n**Brute Force**\\n```\\nclass Solution:\\n    \"\"\"\\n    Brute Force\\n    Time: O(MN)\\n    Space: O(1)\\n    \"\"\"\\n\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        ptrA = headA\\n\\n        while ptrA:\\n            ptrB = headB\\n            while ptrB:\\n                if ptrA is ptrB:\\n                    return ptrA\\n                ptrB = ptrB.next\\n\\n            ptrA = ptrA.next\\n\\n        return\\n```\\n\\n**Hash Table Based**\\n```\\nclass Solution:\\n    \"\"\"\\n    Hash Table\\n    Time: O(M + N)\\n    Space: O(M) or O(N)\\n    \"\"\"\\n\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        address = dict()\\n\\n        while headA:\\n            address[id(headA)] = headA\\n            headA = headA.next\\n\\n        while headB:\\n            if id(headB) in address:\\n                return address[id(headB)]\\n            headB = headB.next\\n\\n        return\\n```\\n\\n**Two Pointers**\\n```\\nclass Solution:\\n    \"\"\"\\n    Two Pointers\\n    Time: O(M + N)\\n    Space: O(1)\\n    \"\"\"\\n\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        ptrA = headA\\n        ptrB = headB\\n\\n        while ptrA is not ptrB:\\n            ptrA = headB if ptrA is None else ptrA.next\\n            ptrB = headA if ptrB is None else ptrB.next\\n\\n        return ptrA\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\n```\n```\\nclass Solution:\\n    \"\"\"\\n    Brute Force\\n    Time: O(MN)\\n    Space: O(1)\\n    \"\"\"\\n\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        ptrA = headA\\n\\n        while ptrA:\\n            ptrB = headB\\n            while ptrB:\\n                if ptrA is ptrB:\\n                    return ptrA\\n                ptrB = ptrB.next\\n\\n            ptrA = ptrA.next\\n\\n        return\\n```\n```\\nclass Solution:\\n    \"\"\"\\n    Hash Table\\n    Time: O(M + N)\\n    Space: O(M) or O(N)\\n    \"\"\"\\n\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        address = dict()\\n\\n        while headA:\\n            address[id(headA)] = headA\\n            headA = headA.next\\n\\n        while headB:\\n            if id(headB) in address:\\n                return address[id(headB)]\\n            headB = headB.next\\n\\n        return\\n```\n```\\nclass Solution:\\n    \"\"\"\\n    Two Pointers\\n    Time: O(M + N)\\n    Space: O(1)\\n    \"\"\"\\n\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        ptrA = headA\\n        ptrB = headB\\n\\n        while ptrA is not ptrB:\\n            ptrA = headB if ptrA is None else ptrA.next\\n            ptrB = headA if ptrB is None else ptrB.next\\n\\n        return ptrA\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732969,
                "title": "easiest-java-o-1-space-solution-6-lines",
                "content": "```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        \\n        ListNode a = headA;\\n        ListNode b = headB;\\n        \\n        while(a != b){ \\n            a = a != null ? a.next : headB;\\n            b = b != null ? b.next : headA; \\n        }\\n        \\n       return a; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        \\n        ListNode a = headA;\\n        ListNode b = headB;\\n        \\n        while(a != b){ \\n            a = a != null ? a.next : headB;\\n            b = b != null ? b.next : headA; \\n        }\\n        \\n       return a; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683981,
                "title": "c-solution-with-map",
                "content": "```\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\tmap<ListNode*, int> mA;\\n\\tListNode* pA = headA;\\n\\twhile (pA) {\\n\\t\\tmA[pA]++;\\n\\t\\tpA = pA->next;\\n\\t}\\n\\tListNode* pB = headB;\\n\\twhile (pB) {\\n\\t\\tif (mA.find(pB) != mA.end())\\n\\t\\t\\treturn pB;\\n\\t\\tpB= pB->next;\\n\\t}\\n\\treturn nullptr;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\tmap<ListNode*, int> mA;\\n\\tListNode* pA = headA;\\n\\twhile (pA) {\\n\\t\\tmA[pA]++;\\n\\t\\tpA = pA->next;\\n\\t}\\n\\tListNode* pB = headB;\\n\\twhile (pB) {\\n\\t\\tif (mA.find(pB) != mA.end())\\n\\t\\t\\treturn pB;\\n\\t\\tpB= pB->next;\\n\\t}\\n\\treturn nullptr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 467993,
                "title": "python-3-five-lines-beats-99",
                "content": "```\\nclass Solution:\\n    def getIntersectionNode(self, A: ListNode, B: ListNode) -> ListNode:\\n        S = set()\\n        while A != None: A, _ = A.next, S.add(A) \\n        while B != None:\\n            if B in S: return B\\n            B = B.next\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getIntersectionNode(self, A: ListNode, B: ListNode) -> ListNode:\\n        S = set()\\n        while A != None: A, _ = A.next, S.add(A) \\n        while B != None:\\n            if B in S: return B\\n            B = B.next\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 211922,
                "title": "java-solution-from-pratik",
                "content": "**Solution 1: Brute Force Approach**\\n\\n**Algorithm:**\\n1. For each node in list `A`, traverse over list `B` and check whether or not the node is present in list `B`.\\n1. The one thing we need to be careful of is that we are comparing objects of type `ListNode`. We don\\'t want to compare the values within the nodes; since doing this would cause our code to break when two different nodes have the same value.\\n\\n**Time Complexity:** `O(N * M)`, considering `N` be the length of list `A` and `M` be the length of list `B`.\\n- For each of the `N` nodes in list `A`, we are traversing over each of the nodes in list `B`. \\n- In the worst case, we won\\'t find a match, and so will need to do this until reaching the end of list `B`, giving a worst-case time complexity of `O(N * M)`.\\n\\n**Space Complexity:** `O(1)`.\\n\\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        for (ListNode currentA = headA; currentA != null; currentA = currentA.next) {\\n            // For each node in list A, traverse over list B\\n            for (ListNode currentB = headB; currentB != null; currentB = currentB.next) {\\n                if (currentA == currentB) {\\n                    return currentA;\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\\n\\n**Solution 2: Using Hash Table**\\n\\n**Algorithm:**\\n1. Traverse list `A` and store the address/reference of each node in a hash table. \\n1. Then for each node in list `B`, check whether or not that node exists in the hash table. If it does, return it as it must be the intersection node. If we get to the end of list `B` without finding an intersection node, return null.\\n\\n**Time complexity:** `O(N + M)`\\n- Firstly, we need to build up the hash table. It costs `O(1)` to insert an item into a hash table, and we need to do this for each of the `N` nodes in list `A`. This gives a cost of `O(N)` for building the hash table.\\n- Secondly, we need to traverse list `B`, and for each node, we need to check whether or not it is in the hash table. In the worst case, there will not be a match, requiring us to check all `M` nodes in list B. As it is also `O(1)` to check whether or not an item is in a hash table, this checking has a total cost of `O(M)`.\\n- Finally, combining the two parts, we get `O(N) + O(M) = O(N + M)`\\n\\n**Space complexity:** `O(N)`.\\n- As we are storing each of the nodes from list `A` into a hash table, the hash table will require `O(N)` space. \\n- Note that we could have instead stored the nodes of list `B` into the hash table, this would have been a space complexity of `O(M)`. Unless we know which list is longer though, it doesn\\'t make any real difference.\\n\\n```\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        Set<ListNode> set = new HashSet<>();\\n\\n        // Store the list A nodes in the set\\n        for (ListNode currentA = headA; currentA != null; currentA = currentA.next) {\\n            set.add(currentA);\\n        }\\n\\n        // Check if any of the list B element is in the Set \\n        for (ListNode currentB = headB; currentB != null; currentB = currentB.next) {\\n            if (set.contains(currentB)) {\\n                return currentB;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\\n\\n**Solution 3: Using Two Pointers**\\n\\n**Intuition:**\\n- In the first iteration, we will reset the pointer of one linked-list to the `head` of another linked-list after it reaches the `tail` node. \\n- In the second iteration, we will move two pointers until they points to the same node. So if two linked-list intersects, the meeting point in second iteration must be the intersection point. \\n- If the two linked lists have no intersection, then the meeting pointer in second iteration must be the `tail` node of both lists, which is `null`\\n\\n**Algorithm:**\\n1. Set pointer `currentA` to point at `headA`.\\n1. pointer `currentB` to point at `headB`.\\n1. While `currentA` and `currentB` are not pointing at the same node:\\n\\t- If `currentA` is pointing to a `null`, set `currentA` to point to `headB`.\\n\\t- Else, set `currentA` to point at `currentA.next`.\\n\\t- If `currentB` is pointing to a `null`, set `currentB` to point to `headA`.\\n\\t- Else, set `currentB` to point at `currentB.next`.\\n1. return the value pointed to by `currentA` (or by `currentB`; they are the same now)\\n\\n**Time Complexity:** `O(N + M)`, where `N` and `M` are the lengths of linked-lists\\n- In the worst case, each list is traversed twice giving `2 * N + 2 * M`, which is equivalent to `O(N + M)`. This is because the pointers firstly go down each list so that they can be \"lined up\" and then in the second iteration, the intersection node is searched for.\\n- An interesting observation is that when the lists are of the same length, this algorithm only traverses each list once. This is because the pointers are already \"lined up\" from the start, so the additional pass is unnecessary.\\n\\n**Space Complexity:** `O(1)`, since we are not allocating any additional data structures, \\n\\n```\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode currentA = headA;\\n        ListNode currentB = headB;\\n\\n        while (currentA != currentB) {\\n            currentA = currentA == null ? headB : currentA.next;\\n            currentB = currentB == null ? headA : currentB.next;\\n        }\\n        return currentA;\\n    }\\n}\\n```\\n\\n**Solution 4: Using Difference of List Lengths**\\n\\n**Algorithm:**\\n1. Find length of both lists, let it be `N` and `M`.\\n1. Find the difference of List Lengths `diff = abs(N \\u2013 M)`\\n1. Now traverse the longer list from the `first` node till `diff` nodes so that from here onwards both the lists have equal no of nodes.\\n1. Then we can traverse both the lists in parallel till we come across a common node\\n\\n**Time Complexity:** `O(N + M)`, where `N` and `M` are the lengths of linked-lists\\n**Space Complexity:** `O(1)`\\n\\n```\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode currentA;\\n        ListNode currentB;\\n        int N = 0;\\n        int M = 0;\\n\\n        // Calculate N; the length of list A.\\n        for (currentA = headA; currentA != null; currentA = currentA.next) {\\n            N += 1;\\n        }\\n        // Calculate M; the length of list B.\\n        for (currentB = headB; currentB != null; currentB = currentB.next) {\\n            M += 1;\\n        }\\n        currentA = headA;\\n        currentB = headB;\\n        int diff = Math.abs(N - M);\\n\\n        // Set the start pointer for the longer list.\\n        if (N > M) {\\n            while (diff-- > 0) {\\n                currentA = currentA.next;\\n            }\\n        }\\n        if (M > N) {\\n            while (diff-- > 0) {\\n                currentB = currentB.next;\\n            }\\n        }\\n\\n        // Move both pointers through the list together.\\n        while (currentA != null) {\\n            if (currentA == currentB) {\\n                return currentA;\\n            }\\n            currentA = currentA.next;\\n            currentB = currentB.next;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        for (ListNode currentA = headA; currentA != null; currentA = currentA.next) {\\n            // For each node in list A, traverse over list B\\n            for (ListNode currentB = headB; currentB != null; currentB = currentB.next) {\\n                if (currentA == currentB) {\\n                    return currentA;\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        Set<ListNode> set = new HashSet<>();\\n\\n        // Store the list A nodes in the set\\n        for (ListNode currentA = headA; currentA != null; currentA = currentA.next) {\\n            set.add(currentA);\\n        }\\n\\n        // Check if any of the list B element is in the Set \\n        for (ListNode currentB = headB; currentB != null; currentB = currentB.next) {\\n            if (set.contains(currentB)) {\\n                return currentB;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode currentA = headA;\\n        ListNode currentB = headB;\\n\\n        while (currentA != currentB) {\\n            currentA = currentA == null ? headB : currentA.next;\\n            currentB = currentB == null ? headA : currentB.next;\\n        }\\n        return currentA;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        ListNode currentA;\\n        ListNode currentB;\\n        int N = 0;\\n        int M = 0;\\n\\n        // Calculate N; the length of list A.\\n        for (currentA = headA; currentA != null; currentA = currentA.next) {\\n            N += 1;\\n        }\\n        // Calculate M; the length of list B.\\n        for (currentB = headB; currentB != null; currentB = currentB.next) {\\n            M += 1;\\n        }\\n        currentA = headA;\\n        currentB = headB;\\n        int diff = Math.abs(N - M);\\n\\n        // Set the start pointer for the longer list.\\n        if (N > M) {\\n            while (diff-- > 0) {\\n                currentA = currentA.next;\\n            }\\n        }\\n        if (M > N) {\\n            while (diff-- > 0) {\\n                currentB = currentB.next;\\n            }\\n        }\\n\\n        // Move both pointers through the list together.\\n        while (currentA != null) {\\n            if (currentA == currentB) {\\n                return currentA;\\n            }\\n            currentA = currentA.next;\\n            currentB = currentB.next;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49918,
                "title": "c-another-solution-using-the-code-of-finding-the-loop-beginning",
                "content": "    class Solution {\\n    public:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if (headA==NULL || headB==NULL) return NULL;\\n        if (headA==headB) return headA;\\n        ListNode *tailA=headA;\\n        while (tailA->next!=NULL){\\n            tailA=tailA->next;\\n        }\\n        tailA->next = headB;\\n        ListNode *slow=headA,*fast=headA;\\n        while (fast!=NULL && fast->next!=NULL){\\n            fast = fast->next->next;\\n            slow = slow->next;\\n            if (slow==fast){\\n                fast = headA;\\n                while (fast!=slow){\\n                    fast = fast->next;\\n                    slow = slow->next;\\n                }\\n                tailA->next = NULL;\\n                return fast;\\n            }\\n        }\\n        tailA->next = NULL;\\n        return NULL;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if (headA==NULL || headB==NULL) return NULL;\\n        if (headA==headB) return headA;\\n        ListNode *tailA=headA;\\n        while (tailA->next!=NULL){\\n            tailA=tailA->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 49975,
                "title": "52ms-in-c-with-time-o-n-space-o-1",
                "content": "    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* cur_node_1 = headA;\\n        ListNode* cur_node_2 = headB;\\n        //cal diff of length\\n        while(cur_node_1 != nullptr && cur_node_2 != nullptr){\\n            cur_node_1 = cur_node_1->next;\\n            cur_node_2 = cur_node_2->next;\\n        }\\n        //make two start point with same length\\n        //will exchange point to the other list\\n        if(cur_node_1 != nullptr) {\\n            cur_node_2 = headA;\\n            while(cur_node_1 != nullptr){\\n                cur_node_1 = cur_node_1->next;\\n                cur_node_2 = cur_node_2->next;\\n            }\\n            cur_node_1 = headB;\\n        }\\n        else if(cur_node_2 != nullptr){\\n            cur_node_1 = headB;\\n            while(cur_node_2 != nullptr){\\n                cur_node_2 = cur_node_2->next;\\n                cur_node_1 = cur_node_1->next;\\n            }\\n            cur_node_2 = headA;\\n        }\\n        else{\\n            cur_node_1 = headB;\\n            cur_node_2 = headA;\\n        }\\n        //because len is same, they will meet each other if has joinpoint\\n        while(cur_node_1 != cur_node_2){\\n            cur_node_1 = cur_node_1->next;\\n            cur_node_2 = cur_node_2->next;\\n        }\\n        return cur_node_1;\\n    }",
                "solutionTags": [],
                "code": "    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode* cur_node_1 = headA;\\n        ListNode* cur_node_2 = headB;\\n        //cal diff of length\\n        while(cur_node_1 != nullptr && cur_node_2 != nullptr){\\n            cur_node_1 = cur_node_1->next;\\n            cur_node_2 = cur_node_2->next;\\n        }\\n        //make two start point with same length\\n        //will exchange point to the other list\\n        if(cur_node_1 != nullptr) {\\n            cur_node_2 = headA;\\n            while(cur_node_1 != nullptr){\\n                cur_node_1 = cur_node_1->next;\\n                cur_node_2 = cur_node_2->next;\\n            }\\n            cur_node_1 = headB;\\n        }\\n        else if(cur_node_2 != nullptr){\\n            cur_node_1 = headB;\\n            while(cur_node_2 != nullptr){\\n                cur_node_2 = cur_node_2->next;\\n                cur_node_1 = cur_node_1->next;\\n            }\\n            cur_node_2 = headA;\\n        }\\n        else{\\n            cur_node_1 = headB;\\n            cur_node_2 = headA;\\n        }\\n        //because len is same, they will meet each other if has joinpoint\\n        while(cur_node_1 != cur_node_2){\\n            cur_node_1 = cur_node_1->next;\\n            cur_node_2 = cur_node_2->next;\\n        }\\n        return cur_node_1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 49962,
                "title": "my-simple-c-solution",
                "content": "    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\tif (headA == NULL || headB == NULL) {\\n\\t\\t\\treturn NULL;\\n\\t\\t}\\n\\t\\tListNode* s1 = headA, *s2 = headB;\\n\\t\\tint dis = getdis(s1, s2);\\n\\t\\tdis>=0? moveHead(dis, headA) : moveHead(-dis, headB);\\n\\t\\twhile (headA != headB) {\\n\\t\\t\\theadA = headA->next;\\n\\t\\t\\theadB = headB->next;\\n\\t\\t}\\n\\t\\treturn headA;\\n\\t}\\n\\n\\tint getdis(ListNode* s1, ListNode* s2) {\\n\\t\\tint i = 0;\\n\\t\\twhile (s1&&s2) {\\n\\t\\t\\ts1 = s1->next;\\n\\t\\t\\ts2 = s2->next;\\n\\t\\t}\\n\\t\\tif (s1){\\n\\t\\t\\twhile (s1){ s1 = s1->next; i++; }\\n\\t\\t}\\n\\t\\telse\\n\\t\\twhile (s2){ s2 = s2->next; i--; };\\n\\t\\treturn i;\\n\\t}\\n\\n\\tvoid moveHead(int i, ListNode*& n) {\\n\\t\\twhile (i > 0 && n) {\\n\\t\\t\\tn = n->next;\\n\\t\\t\\ti--;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n\\t\\tif (headA == NULL || headB == NULL) {\\n\\t\\t\\treturn NULL;\\n\\t\\t}\\n\\t\\tListNode* s1 = headA, *s2 = headB;\\n\\t\\tint dis = getdis(s1, s2);\\n\\t\\tdis>=0? moveHead(dis, headA) : moveHead(-dis, headB);\\n\\t\\twhile (headA != headB) {\\n\\t\\t\\theadA = headA->next;\\n\\t\\t\\theadB = headB->next;\\n\\t\\t}\\n\\t\\treturn headA;\\n\\t}\\n\\n\\tint getdis(ListNode* s1, ListNode* s2) {\\n\\t\\tint i = 0;\\n\\t\\twhile (s1&&s2) {\\n\\t\\t\\ts1 = s1->next;\\n\\t\\t\\ts2 = s2->next;\\n\\t\\t}\\n\\t\\tif (s1){\\n\\t\\t\\twhile (s1){ s1 = s1->next; i++; }\\n\\t\\t}\\n\\t\\telse\\n\\t\\twhile (s2){ s2 = s2->next; i--; };\\n\\t\\treturn i;\\n\\t}\\n\\n\\tvoid moveHead(int i, ListNode*& n) {\\n\\t\\twhile (i > 0 && n) {\\n\\t\\t\\tn = n->next;\\n\\t\\t\\ti--;\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 49997,
                "title": "my-simple-c-solution-with-explanations-and-comments-o-n-time-o-1-space",
                "content": "explanation: the Idea is simple. check which list is longer, for instance A is longer than B with steps nodes. Then the longer one walk the the steps. Now they have the same length. then Both of the lists walk at the same pace until they meet:\\n\\n       ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *curA = headA, *curB = headB;\\n        int size_diff =  0;\\n        bool flag = false; // false for A shorter, true for B shorter\\n        while (curA && curB) {\\n            curA = curA->next;\\n            curB = curB->next;\\n        }\\n        flag = curA; // if curA not null,  B shorter, otherwise, A shorter\\n        ListNode *start = curA ? curA : curB;\\n        while(start) {\\n            size_diff++;\\n            start = start->next;\\n        }\\n        curA = headA;\\n        curB = headB;\\n        if (flag) \\n        while (size_diff--) curA = curA->next; // A longer, A walk size_diff steps\\n        else while (size_diff--) curB = curB->next; // B longer, B walk size_diff \\n        while (curA && curB)  // now they walk together\\n        {\\n            if (curA == curB) return curA;\\n            curA = curA->next;\\n            curB = curB->next;\\n        }\\n        return nullptr;\\n    }",
                "solutionTags": [],
                "code": "explanation: the Idea is simple. check which list is longer, for instance A is longer than B with steps nodes. Then the longer one walk the the steps. Now they have the same length. then Both of the lists walk at the same pace until they meet:\\n\\n       ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *curA = headA, *curB = headB;\\n        int size_diff =  0;\\n        bool flag = false; // false for A shorter, true for B shorter\\n        while (curA && curB) {\\n            curA = curA->next;\\n            curB = curB->next;\\n        }\\n        flag = curA; // if curA not null,  B shorter, otherwise, A shorter\\n        ListNode *start = curA ? curA : curB;\\n        while(start) {\\n            size_diff++;\\n            start = start->next;\\n        }\\n        curA = headA;\\n        curB = headB;\\n        if (flag) \\n        while (size_diff--) curA = curA->next; // A longer, A walk size_diff steps\\n        else while (size_diff--) curB = curB->next; // B longer, B walk size_diff \\n        while (curA && curB)  // now they walk together\\n        {\\n            if (curA == curB) return curA;\\n            curA = curA->next;\\n            curB = curB->next;\\n        }\\n        return nullptr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 50012,
                "title": "my-java-solution",
                "content": "    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        if (headA == null || headB == null) {\\n            return null;\\n        }\\n    \\tint length1 = 0, length2 = 0, diff = 0;\\n    \\tListNode list1 = headA, list2 = headB;\\n    \\twhile (list1 != null) {\\n    \\t\\tlength1++;\\n    \\t\\tlist1 = list1.next;\\n    \\t}\\n    \\twhile (list2 != null) {\\n    \\t\\tlength2++;\\n    \\t\\tlist2 = list2.next;\\n    \\t}\\n\\t\\tlist1 = headA;\\n\\t\\tlist2 = headB;\\n    \\tdiff = length1 - length2;\\n    \\tif (length2 > length1) {\\n    \\t\\tlist1 = headB;\\n    \\t\\tlist2 = headA;\\n    \\t\\tdiff = length2 - length1;\\n    \\t}\\n    \\tfor (int i = 0; i < diff; i++) {\\n    \\t\\tlist1 = list1.next;\\n    \\t}\\n    \\twhile (list1 != null && list2 != null) {\\n    \\t\\tif (list1.val == list2.val) {\\n    \\t\\t\\treturn list1;\\n    \\t\\t}\\n    \\t\\tlist1 = list1.next;\\n    \\t\\tlist2 = list2.next;\\n    \\t}\\n    \\treturn null;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        if (headA == null || headB == null) {\\n            return null;\\n        }\\n    \\tint length1 = 0, length2 = 0, diff = 0;\\n    \\tListNode list1 = headA, list2 = headB;\\n    \\twhile (list1 != null) {\\n    \\t\\tlength1++;\\n    \\t\\tlist1 = list1.next;\\n    \\t}\\n    \\twhile (list2 != null) {\\n    \\t\\tlength2++;\\n    \\t\\tlist2 = list2.next;\\n    \\t}\\n\\t\\tlist1 = headA;\\n\\t\\tlist2 = headB;\\n    \\tdiff = length1 - length2;\\n    \\tif (length2 > length1) {\\n    \\t\\tlist1 = headB;\\n    \\t\\tlist2 = headA;\\n    \\t\\tdiff = length2 - length1;\\n    \\t}\\n    \\tfor (int i = 0; i < diff; i++) {\\n    \\t\\tlist1 = list1.next;\\n    \\t}\\n    \\twhile (list1 != null && list2 != null) {\\n    \\t\\tif (list1.val == list2.val) {\\n    \\t\\t\\treturn list1;\\n    \\t\\t}\\n    \\t\\tlist1 = list1.next;\\n    \\t\\tlist2 = list2.next;\\n    \\t}\\n    \\treturn null;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 49893,
                "title": "simple-thought-with-o-n-time-and-o-1-space-complexity-for-intersection-of-two-linked-lists",
                "content": "My thought is very simple.\\n\\n**case 1**: If A and B has the same length, we just need to move two pointers(*pa*, *pb*) of two lists together to check whether *pa* == *pb*.\\n\\n**case 2**: If their length are not equal we can know their length difference (*lenDiff*) and move the pointer of longer list *lenDiff* steps forward, then follow case 1.\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if(!headA || !headB)\\n            return NULL;\\n        int lenA = 0;\\n        ListNode *pa = headA;\\n        while(pa) {\\n            lenA++;\\n            pa = pa->next;\\n        }\\n        int lenB = 0;\\n        ListNode *pb = headB;\\n        while(pb) {\\n            lenB++;\\n            pb = pb->next;\\n        }\\n        int lenDiff = lenA - lenB;\\n        pa = headA;\\n        pb = headB;\\n        if(lenDiff > 0) {\\n            while(lenDiff != 0) {\\n                pa = pa->next;\\n                lenDiff--;\\n            }\\n        }\\n        else if(lenDiff < 0) {\\n            while(lenDiff != 0) {\\n                pb = pb->next;\\n                lenDiff++;\\n            }\\n        }\\n        while(pa && pb) {\\n            if(pa == pb)\\n                return pa;\\n            pa = pa->next;\\n            pb = pb->next;\\n        }\\n        return NULL;\\n    }",
                "solutionTags": [],
                "code": "My thought is very simple.\\n\\n**case 1**: If A and B has the same length, we just need to move two pointers(*pa*, *pb*) of two lists together to check whether *pa* == *pb*.\\n\\n**case 2**: If their length are not equal we can know their length difference (*lenDiff*) and move the pointer of longer list *lenDiff* steps forward, then follow case 1.\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        if(!headA || !headB)\\n            return NULL;\\n        int lenA = 0;\\n        ListNode *pa = headA;\\n        while(pa) {\\n            lenA++;\\n            pa = pa->next;\\n        }\\n        int lenB = 0;\\n        ListNode *pb = headB;\\n        while(pb) {\\n            lenB++;\\n            pb = pb->next;\\n        }\\n        int lenDiff = lenA - lenB;\\n        pa = headA;\\n        pb = headB;\\n        if(lenDiff > 0) {\\n            while(lenDiff != 0) {\\n                pa = pa->next;\\n                lenDiff--;\\n            }\\n        }\\n        else if(lenDiff < 0) {\\n            while(lenDiff != 0) {\\n                pb = pb->next;\\n                lenDiff++;\\n            }\\n        }\\n        while(pa && pb) {\\n            if(pa == pb)\\n                return pa;\\n            pa = pa->next;\\n            pb = pb->next;\\n        }\\n        return NULL;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3880523,
                "title": "intersection-of-two-linked-lists",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int ac = 0;\\n        int bc = 0;\\n        ListNode a = headA;\\n        ListNode b = headB;\\n        while(a != null){\\n            ac++;\\n            a = a.next;\\n        }\\n        while(b != null){\\n            bc++;\\n            b = b.next;\\n        }\\n        while(ac > bc){\\n            ac--;\\n            headA = headA.next;\\n        }\\n        while(bc > ac){\\n            bc--;\\n            headB = headB.next;\\n        }\\n        \\n        while(headA != headB){\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n        return headA;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int ac = 0;\\n        int bc = 0;\\n        ListNode a = headA;\\n        ListNode b = headB;\\n        while(a != null){\\n            ac++;\\n            a = a.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3200014,
                "title": "finding-the-intersection-of-two-linked-lists-using-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is to use two pointers to traverse each linked list, first to count their lengths, then move the pointer of the longer list to the same distance from the end as the shorter list. Finally, move both pointers forward until they intersect.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Traverse the linked lists headA and headB using two pointers currA and currB, respectively, to count their lengths lenA and lenB, respectively.\\n\\n2. Reset the pointers currA and currB to the heads of the linked lists.\\n\\n\\n3. If lenA > lenB, move the pointer currA to the same distance from the end as the shorter list by advancing currA lenA - lenB steps. Otherwise, move the pointer currB to the same distance from the end as the shorter list by advancing currB lenB - lenA steps.\\n\\n4. Move both pointers currA and currB forward until they intersect at the same node or they reach the end of their respective linked lists.\\n\\n5. If an intersection is found, return the intersected node, otherwise, return null.\\n\\n- Explanation : The algorithm uses two pointers to traverse two linked lists, count their lengths, move the pointer of the longer list to the same distance from the end as the shorter list, and then move both pointers forward until they intersect at the same node. The algorithm\\'s approach and complexity have been explained in detail in the previous response.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:The time complexity of the algorithm is $ O(m + n)$ because we traverse both linked lists once to count their lengths, and then traverse both lists once to find the intersection node.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the algorithm is $O(1)$ because we only use a constant amount of extra space to store the pointers currA and currB.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n                # Get the lengths of the two linked lists\\n            lenA, lenB = 0, 0\\n            currA, currB = headA, headB\\n            while currA is not None:\\n                    lenA += 1\\n                    currA = currA.next\\n            while currB is not None:\\n                    lenB += 1\\n                    currB = currB.next\\n        \\n        # Reset the pointers to the heads of the two linked lists\\n            currA, currB = headA, headB\\n        \\n        # Move the pointer of the longer list to the same distance from the end as the shorter list\\n            if lenA > lenB:\\n                for i in range(lenA - lenB):\\n                    currA = currA.next\\n            elif lenB > lenA:\\n                for i in range(lenB - lenA):\\n                    currB = currB.next\\n        \\n        # Move both pointers forward until they intersect\\n            while currA is not None and currB is not None:\\n                if currA == currB:\\n                    return currA\\n                currA = currA.next\\n                currB = currB.next\\n        \\n        # No intersection found\\n            return None\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n                # Get the lengths of the two linked lists\\n            lenA, lenB = 0, 0\\n            currA, currB = headA, headB\\n            while currA is not None:\\n                    lenA += 1\\n                    currA = currA.next\\n            while currB is not None:\\n                    lenB += 1\\n                    currB = currB.next\\n        \\n        # Reset the pointers to the heads of the two linked lists\\n            currA, currB = headA, headB\\n        \\n        # Move the pointer of the longer list to the same distance from the end as the shorter list\\n            if lenA > lenB:\\n                for i in range(lenA - lenB):\\n                    currA = currA.next\\n            elif lenB > lenA:\\n                for i in range(lenB - lenA):\\n                    currB = currB.next\\n        \\n        # Move both pointers forward until they intersect\\n            while currA is not None and currB is not None:\\n                if currA == currB:\\n                    return currA\\n                currA = currA.next\\n                currB = currB.next\\n        \\n        # No intersection found\\n            return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027758,
                "title": "java-set-easy-solution",
                "content": "# Code\\n\\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n        HashSet<ListNode> set = new HashSet<>();\\n\\n        while(headA != null){\\n            set.add(headA);\\n            headA = headA.next;\\n        }\\n\\n        while(headB != null){\\n            if(set.contains(headB)){\\n                return headB;\\n            }else{\\n                headB = headB.next;\\n            }\\n        }\\n\\n        return null;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n        HashSet<ListNode> set = new HashSet<>();\\n\\n        while(headA != null){\\n            set.add(headA);\\n            headA = headA.next;\\n        }\\n\\n        while(headB != null){\\n            if(set.contains(headB)){\\n                return headB;\\n            }else{\\n                headB = headB.next;\\n            }\\n        }\\n\\n        return null;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016868,
                "title": "go-that-s-how-you-do-it-in-the-real-world-no-fancy-stuff",
                "content": "\"Simplicity is the ultimate sophistication\"\\n\\n```\\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\\n    seen := make(map[*ListNode]bool)\\n    for n := headA; n != nil; n = n.Next {\\n        seen[n] = true\\n    }\\n\\n    for n := headB; n != nil; n = n.Next {\\n        if seen[n] {\\n            return n\\n        }\\n    }\\n    return nil\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table"
                ],
                "code": "```\\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\\n    seen := make(map[*ListNode]bool)\\n    for n := headA; n != nil; n = n.Next {\\n        seen[n] = true\\n    }\\n\\n    for n := headB; n != nil; n = n.Next {\\n        if seen[n] {\\n            return n\\n        }\\n    }\\n    return nil\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2874342,
                "title": "c-simple-solution",
                "content": "# Approach\\n1. First we have to determine the length of list A and list B\\n2. Then we must match the lists so that the endings of list A and list B match\\n3. Then you just need to iterate both lists and compare the nodes, if there is a match, then there are intersections of the lists. If there is no match, then return null\\n\\n# Complexity\\n- Time complexity: O(N + M) = O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) \\n    {\\n        var lengthA = GetListNodeLength(headA);\\n        var lengthB = GetListNodeLength(headB);\\n\\n        while (lengthA > lengthB)\\n        {\\n            headA = headA.next;\\n            lengthA--;\\n        }\\n\\n        while (lengthB > lengthA)\\n        {\\n            headB = headB.next;\\n            lengthB--;\\n        }\\n        \\n        while (headA != headB)\\n        {\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n\\n        return headA;\\n    }\\n    \\n    private static int GetListNodeLength(ListNode node)\\n    {\\n        var length = 0;\\n\\n        while (node != null)\\n        {\\n            node = node.next;\\n            length++;\\n        }\\n\\n        return length;\\n    }\\n}\\n```\\n![Screenshot 2022-12-03 233255.png](https://assets.leetcode.com/users/images/16f90ede-d6bf-471d-aa39-f6ec21dee0fa_1670100031.2386193.png)\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) \\n    {\\n        var lengthA = GetListNodeLength(headA);\\n        var lengthB = GetListNodeLength(headB);\\n\\n        while (lengthA > lengthB)\\n        {\\n            headA = headA.next;\\n            lengthA--;\\n        }\\n\\n        while (lengthB > lengthA)\\n        {\\n            headB = headB.next;\\n            lengthB--;\\n        }\\n        \\n        while (headA != headB)\\n        {\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n\\n        return headA;\\n    }\\n    \\n    private static int GetListNodeLength(ListNode node)\\n    {\\n        var length = 0;\\n\\n        while (node != null)\\n        {\\n            node = node.next;\\n            length++;\\n        }\\n\\n        return length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541315,
                "title": "intersection-of-two-linked-list",
                "content": "# **If it Help Please UpVote :)\\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n       ListNode temp1=headA;\\n        ListNode temp2=headB;\\n        while(temp1!=temp2){\\n            if(temp1==null){\\n                temp1=headB;\\n            }\\n            else{\\n                temp1=temp1.next;\\n            }\\n            if(temp2==null){\\n                temp2=headA;\\n            }else{\\n                temp2=temp2.next;\\n            }\\n          \\n        }\\n          return temp1;\\n\\t\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n       ListNode temp1=headA;\\n        ListNode temp2=headB;\\n        while(temp1!=temp2){\\n            if(temp1==null){\\n                temp1=headB;\\n            }\\n            else{\\n                temp1=temp1.next;\\n            }\\n            if(temp2==null){\\n                temp2=headA;\\n            }else{\\n                temp2=temp2.next;\\n            }\\n          \\n        }\\n          return temp1;\\n\\t\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276038,
                "title": "c-easiest-code-cleanest-code-and-easiest-to-understand",
                "content": "Have seen a lot of solutions on this problem.However,none of them seemed suitable for beginners to follow plus the number of solutions in the discuss section is overwhelming.So thought of creating a clear,concise and clean code for beginners to follow.\\nDo upvote.\\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n  \\n        ListNode* temp1=headA;\\n        ListNode* temp2=headB;\\n        int len1=0;\\n        int len2=0;\\n        while(headA!=NULL){\\n            headA=headA->next;\\n            len1++;\\n            \\n        }\\n         while(headB!=NULL){\\n            headB=headB->next;\\n            len2++;\\n            \\n        }\\n        int delta;\\n        if(len1>len2){\\n            delta=len1-len2;\\n        }\\n        else if(len1<len2){\\n            delta=len2-len1;\\n        }\\n        else{\\n            delta=0;\\n        }\\n        if(len1>len2){\\n \\n            while(delta--){\\n                temp1=temp1->next;\\n            }\\n        }\\n        else if(len1<len2){\\n            while(delta--){\\n                temp2=temp2->next;\\n            }\\n        }\\n        //now we can move both pointers\\n        while(temp1!=temp2){\\n             temp1=temp1->next;\\n             temp2=temp2->next;\\n        }\\n        return temp1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n  \\n        ListNode* temp1=headA;\\n        ListNode* temp2=headB;\\n        int len1=0;\\n        int len2=0;\\n        while(headA!=NULL){\\n            headA=headA->next;\\n            len1++;\\n            \\n        }\\n         while(headB!=NULL){\\n            headB=headB->next;\\n            len2++;\\n            \\n        }\\n        int delta;\\n        if(len1>len2){\\n            delta=len1-len2;\\n        }\\n        else if(len1<len2){\\n            delta=len2-len1;\\n        }\\n        else{\\n            delta=0;\\n        }\\n        if(len1>len2){\\n \\n            while(delta--){\\n                temp1=temp1->next;\\n            }\\n        }\\n        else if(len1<len2){\\n            while(delta--){\\n                temp2=temp2->next;\\n            }\\n        }\\n        //now we can move both pointers\\n        while(temp1!=temp2){\\n             temp1=temp1->next;\\n             temp2=temp2->next;\\n        }\\n        return temp1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201626,
                "title": "99-fast-awesome-3-approaches-explained-in-detail-begineer-friendly",
                "content": "![image](https://assets.leetcode.com/users/images/902af032-f096-4ab7-a2bc-e58387ba6882_1656262920.0406907.png)\\n\\n```\\n**# BRUTE FORCE:**\\nWE WILL FIRST TRAVERSE THE FIRST LIST \\nAND IN OUR MAP FOR EVERY ADDRESS OF A NODE WE WILL STORE A VALUE WHICH WILL REPRESENT HOW MANY TIMES A NODE WITH A SPECIFIC ADDRESSS HAVE BEEN ENCOUNTERED BY US.\\nNOW FOR THE FIRST LIST FOR EVERY ADDRESS OF A NODE WE WILL HAVE A VALUE OF 1.\\nNOW WE WILL TRAVERSE FOR THE SECOND LIST, NOW WHEN FOR A ADDRESS IF THE COUNT IS ALREADY 1 WHICH MEANS THAT WE HAVE ALREADY ENCOUNTERED THAT PARTICULAR NODE.\\nTHIS ULTIMATELY EXPLAINS THAT WE HAVE TO VISIT THIS NODE AGAIN SO THIS MEANS THAT THIS IS THE INTERSECTION NODE \\n# **BRUTE FORCE CODE:**\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        //BRUTE FORCE\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);cout.tie(0);\\n        unordered_map<ListNode* , int>mp;\\n        ListNode *temp = NULL;\\n        while(headA!=NULL){ //O(M) FOR THE WORST CASE\\n            mp[headA]++;\\n            headA=headA->next;\\n        }\\n        while(headB!=NULL){ //O(N) FOR THE WORST CASE\\n            if(mp[headB]==1){\\n                temp = headB;\\n                break;\\n            }\\n            headB=headB->next;\\n        }\\n        return temp;\\n    }\\n    // TC:- O(M)+O(N);\\n    // SC:- In my solution it is equal to the lenght of LIST1, it can further be optimized to \\n    // O(min(M,N)) for this first we will have to find the list1 and list2 length then out of both \\n    // which is minimum that size can be used to create a map\\n\\t\\n# \\t**OPTIMIZED:**\\n\\tUSING THE DIFFERENCE BETWEEN THE LENGTH\\'S\\n        Step 1-> Find the length of both Linked-Lists and take their difference \\'d\\'\\n        Step 2-> Move the larger node forward by \\'d\\' steps\\n        Step 3-> Now the starting point of both linkedlists are equidistant from intersection ,so move \\n        both pointers together untill the intersection is found.\\n# **OPTIMIZED CODE:**\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB){\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);cout.tie(0);\\n        ListNode* a = headA;\\n        ListNode* b = headB;\\n        ListNode* temp = NULL;\\n        int as = 0 , bs = 0;\\nwhile(a!=NULL){\\n            as++;\\n            a=a->next;\\n        }\\n        while(b!=NULL){\\n            bs++;\\n            b=b->next;\\n        }\\n        a=headA;\\n        b=headB;\\n        int diff = 0;\\n        if(as<bs){\\n            diff = bs-as;\\n            while(diff!=0){\\n                b=b->next;\\n                diff--;\\n            }\\n        }\\n        else{\\n            diff = as-bs;\\n            while(diff!=0){\\n                a=a->next;\\n                diff--;\\n            }\\n        }\\n        while(a!=b and a!=NULL and b!=NULL){\\n            a=a->next;\\n            b=b->next;\\n        }\\n        if(a!=NULL){\\n            return a;\\n        }\\n        return temp;\\n    }\\n\\n# **OPTIMAL:**\\nVisualization of this solution:\\nCase 1 (Have Intersection & Same Len):\\n\\n       a\\nA:     a1 \\u2192 a2 \\u2192 a3\\n                   \\u2198\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n       b\\n            a\\nA:     a1 \\u2192 a2 \\u2192 a3\\n                   \\u2198\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n            b\\n                 a\\nA:     a1 \\u2192 a2 \\u2192 a3\\n                   \\u2198\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n                 b\\nA:     a1 \\u2192 a2 \\u2192 a3\\n                   \\u2198 a\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197 b            \\nB:     b1 \\u2192 b2 \\u2192 b3\\nSince a == b is true, end loop while(a != b), return the intersection node a = c1.\\n\\nCase 2 (Have Intersection & Different Len):\\n\\n            a\\nA:          a1 \\u2192 a2\\n                   \\u2198\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n       b\\n                 a\\nA:          a1 \\u2192 a2\\n                   \\u2198\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n            b\\nA:          a1 \\u2192 a2\\n                   \\u2198 a\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n                 b\\nA:          a1 \\u2192 a2\\n                   \\u2198      a\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197 b           \\nB:     b1 \\u2192 b2 \\u2192 b3\\nA:          a1 \\u2192 a2\\n                   \\u2198           a\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197      b           \\nB:     b1 \\u2192 b2 \\u2192 b3\\nA:          a1 \\u2192 a2\\n                   \\u2198                a = null, then a = b1\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197           b           \\nB:     b1 \\u2192 b2 \\u2192 b3\\nA:          a1 \\u2192 a2\\n                   \\u2198 \\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197                b = null, then b = a1 \\nB:     b1 \\u2192 b2 \\u2192 b3\\n       a\\n            b         \\nA:          a1 \\u2192 a2\\n                   \\u2198 \\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197\\nB:     b1 \\u2192 b2 \\u2192 b3\\n            a\\n                 b         \\nA:          a1 \\u2192 a2\\n                   \\u2198 \\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197 \\nB:     b1 \\u2192 b2 \\u2192 b3\\n                 a\\nA:          a1 \\u2192 a2\\n                   \\u2198 b\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197 a\\nB:     b1 \\u2192 b2 \\u2192 b3\\nSince a == b is true, end loop while(a != b), return the intersection node a = c1.\\n\\nCase 3 (Have No Intersection & Same Len):\\n\\n       a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n       b\\n            a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n            b\\n                 a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                 b\\n                      a = null\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                      b = null\\nSince a == b is true (both refer to null), end loop while(a != b), return a = null.\\n\\nCase 4 (Have No Intersection & Different Len):\\n\\n       a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n       b\\n            a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n            b\\n                 a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                 b\\n                      a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                      b = null, then b = a1\\n       b                   a = null, then a = b1\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n            b                   \\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n       a\\n                 b\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n            a\\n                      b\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                 a\\n                           b = null\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                      a = null\\nSince a == b is true (both refer to null), end loop while(a != b), return a = null.\\n\\nNotice that if list A and list B have the same length, this solution will terminate in no more than 1 traversal; if both lists have different lengths, this solution will terminate in no more than 2 traversals -- in the second traversal, swapping a and b synchronizes a and b before the end of the second traversal. By synchronizing a and b I mean both have the same remaining steps in the second traversal so that it\\'s guaranteed for them to reach the first intersection node, or reach null at the same time (technically speaking, in the same iteration) -- see Case 2 (Have Intersection & Different Len) and Case 4 (Have No Intersection & Different Len).\\n\\nFURTHER EXPLAINTATION IF ANY DOUBT IS STILL THERE:\\nLet assume the length of List A is a + c and length of List B is b + c (c is the length of the intersected or common part).\\nLength of A + Length of B == Length of A + Length of B == a + c + b + c.\\nLet make ptr1 and ptr2 as start pointers of list A and list B respectively.\\nThe idea is to traverse both pointers by same distance (a + b + c).\\nFirst traverse both the pointers until they reach to the end of their respective lists and then to offset the length difference between the two lists we switch\\nboth the pointers i.e. we points ptr1 to head B after a + c iterations and points ptr2 to head A after b + c iterations.\\nIn the second traversal, we traversed ptr1 by \\'b\\' steps and ptr2 by \\'a\\' steps.\\nAfter a + b + c iterations, both pointers will meet to the first intersection node.\\nNote: If there is no intersection and length of both lists are same then both the pointers will points to NULL simultaneously in the first traversal.\\nIf there is no intersection and length of both lists are different then both the pointers will points to NULL simultaneously in the second traversal.\\n\\n# **CODE:**\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB){\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);cout.tie(0);\\n        /* USING TWO POINTER*/\\n        ListNode* a = headA;\\n        ListNode* b = headB;\\n        while(a!=b){\\n            if(a==NULL){\\n                a=headB;\\n            }\\n            else{\\n                a = a -> next;\\n            }\\n            if(b==NULL){\\n                b=headA;\\n            }\\n            else{\\n                b = b -> next;\\n            }\\n        }\\n        return a;\\n    }\\n\\t\\n\\t\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/902af032-f096-4ab7-a2bc-e58387ba6882_1656262920.0406907.png)\\n\\n```\\n**# BRUTE FORCE:**\\nWE WILL FIRST TRAVERSE THE FIRST LIST \\nAND IN OUR MAP FOR EVERY ADDRESS OF A NODE WE WILL STORE A VALUE WHICH WILL REPRESENT HOW MANY TIMES A NODE WITH A SPECIFIC ADDRESSS HAVE BEEN ENCOUNTERED BY US.\\nNOW FOR THE FIRST LIST FOR EVERY ADDRESS OF A NODE WE WILL HAVE A VALUE OF 1.\\nNOW WE WILL TRAVERSE FOR THE SECOND LIST, NOW WHEN FOR A ADDRESS IF THE COUNT IS ALREADY 1 WHICH MEANS THAT WE HAVE ALREADY ENCOUNTERED THAT PARTICULAR NODE.\\nTHIS ULTIMATELY EXPLAINS THAT WE HAVE TO VISIT THIS NODE AGAIN SO THIS MEANS THAT THIS IS THE INTERSECTION NODE \\n# **BRUTE FORCE CODE:**\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        //BRUTE FORCE\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);cout.tie(0);\\n        unordered_map<ListNode* , int>mp;\\n        ListNode *temp = NULL;\\n        while(headA!=NULL){ //O(M) FOR THE WORST CASE\\n            mp[headA]++;\\n            headA=headA->next;\\n        }\\n        while(headB!=NULL){ //O(N) FOR THE WORST CASE\\n            if(mp[headB]==1){\\n                temp = headB;\\n                break;\\n            }\\n            headB=headB->next;\\n        }\\n        return temp;\\n    }\\n    // TC:- O(M)+O(N);\\n    // SC:- In my solution it is equal to the lenght of LIST1, it can further be optimized to \\n    // O(min(M,N)) for this first we will have to find the list1 and list2 length then out of both \\n    // which is minimum that size can be used to create a map\\n\\t\\n# \\t**OPTIMIZED:**\\n\\tUSING THE DIFFERENCE BETWEEN THE LENGTH\\'S\\n        Step 1-> Find the length of both Linked-Lists and take their difference \\'d\\'\\n        Step 2-> Move the larger node forward by \\'d\\' steps\\n        Step 3-> Now the starting point of both linkedlists are equidistant from intersection ,so move \\n        both pointers together untill the intersection is found.\\n# **OPTIMIZED CODE:**\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB){\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);cout.tie(0);\\n        ListNode* a = headA;\\n        ListNode* b = headB;\\n        ListNode* temp = NULL;\\n        int as = 0 , bs = 0;\\nwhile(a!=NULL){\\n            as++;\\n            a=a->next;\\n        }\\n        while(b!=NULL){\\n            bs++;\\n            b=b->next;\\n        }\\n        a=headA;\\n        b=headB;\\n        int diff = 0;\\n        if(as<bs){\\n            diff = bs-as;\\n            while(diff!=0){\\n                b=b->next;\\n                diff--;\\n            }\\n        }\\n        else{\\n            diff = as-bs;\\n            while(diff!=0){\\n                a=a->next;\\n                diff--;\\n            }\\n        }\\n        while(a!=b and a!=NULL and b!=NULL){\\n            a=a->next;\\n            b=b->next;\\n        }\\n        if(a!=NULL){\\n            return a;\\n        }\\n        return temp;\\n    }\\n\\n# **OPTIMAL:**\\nVisualization of this solution:\\nCase 1 (Have Intersection & Same Len):\\n\\n       a\\nA:     a1 \\u2192 a2 \\u2192 a3\\n                   \\u2198\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n       b\\n            a\\nA:     a1 \\u2192 a2 \\u2192 a3\\n                   \\u2198\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n            b\\n                 a\\nA:     a1 \\u2192 a2 \\u2192 a3\\n                   \\u2198\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n                 b\\nA:     a1 \\u2192 a2 \\u2192 a3\\n                   \\u2198 a\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197 b            \\nB:     b1 \\u2192 b2 \\u2192 b3\\nSince a == b is true, end loop while(a != b), return the intersection node a = c1.\\n\\nCase 2 (Have Intersection & Different Len):\\n\\n            a\\nA:          a1 \\u2192 a2\\n                   \\u2198\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n       b\\n                 a\\nA:          a1 \\u2192 a2\\n                   \\u2198\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n            b\\nA:          a1 \\u2192 a2\\n                   \\u2198 a\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197            \\nB:     b1 \\u2192 b2 \\u2192 b3\\n                 b\\nA:          a1 \\u2192 a2\\n                   \\u2198      a\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197 b           \\nB:     b1 \\u2192 b2 \\u2192 b3\\nA:          a1 \\u2192 a2\\n                   \\u2198           a\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197      b           \\nB:     b1 \\u2192 b2 \\u2192 b3\\nA:          a1 \\u2192 a2\\n                   \\u2198                a = null, then a = b1\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197           b           \\nB:     b1 \\u2192 b2 \\u2192 b3\\nA:          a1 \\u2192 a2\\n                   \\u2198 \\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197                b = null, then b = a1 \\nB:     b1 \\u2192 b2 \\u2192 b3\\n       a\\n            b         \\nA:          a1 \\u2192 a2\\n                   \\u2198 \\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197\\nB:     b1 \\u2192 b2 \\u2192 b3\\n            a\\n                 b         \\nA:          a1 \\u2192 a2\\n                   \\u2198 \\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197 \\nB:     b1 \\u2192 b2 \\u2192 b3\\n                 a\\nA:          a1 \\u2192 a2\\n                   \\u2198 b\\n                     c1 \\u2192 c2 \\u2192 c3 \\u2192 null\\n                   \\u2197 a\\nB:     b1 \\u2192 b2 \\u2192 b3\\nSince a == b is true, end loop while(a != b), return the intersection node a = c1.\\n\\nCase 3 (Have No Intersection & Same Len):\\n\\n       a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n       b\\n            a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n            b\\n                 a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                 b\\n                      a = null\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                      b = null\\nSince a == b is true (both refer to null), end loop while(a != b), return a = null.\\n\\nCase 4 (Have No Intersection & Different Len):\\n\\n       a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n       b\\n            a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n            b\\n                 a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                 b\\n                      a\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                      b = null, then b = a1\\n       b                   a = null, then a = b1\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n            b                   \\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n       a\\n                 b\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n            a\\n                      b\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                 a\\n                           b = null\\nA:     a1 \\u2192 a2 \\u2192 a3 \\u2192 a4 \\u2192 null\\nB:     b1 \\u2192 b2 \\u2192 b3 \\u2192 null\\n                      a = null\\nSince a == b is true (both refer to null), end loop while(a != b), return a = null.\\n\\nNotice that if list A and list B have the same length, this solution will terminate in no more than 1 traversal; if both lists have different lengths, this solution will terminate in no more than 2 traversals -- in the second traversal, swapping a and b synchronizes a and b before the end of the second traversal. By synchronizing a and b I mean both have the same remaining steps in the second traversal so that it\\'s guaranteed for them to reach the first intersection node, or reach null at the same time (technically speaking, in the same iteration) -- see Case 2 (Have Intersection & Different Len) and Case 4 (Have No Intersection & Different Len).\\n\\nFURTHER EXPLAINTATION IF ANY DOUBT IS STILL THERE:\\nLet assume the length of List A is a + c and length of List B is b + c (c is the length of the intersected or common part).\\nLength of A + Length of B == Length of A + Length of B == a + c + b + c.\\nLet make ptr1 and ptr2 as start pointers of list A and list B respectively.\\nThe idea is to traverse both pointers by same distance (a + b + c).\\nFirst traverse both the pointers until they reach to the end of their respective lists and then to offset the length difference between the two lists we switch\\nboth the pointers i.e. we points ptr1 to head B after a + c iterations and points ptr2 to head A after b + c iterations.\\nIn the second traversal, we traversed ptr1 by \\'b\\' steps and ptr2 by \\'a\\' steps.\\nAfter a + b + c iterations, both pointers will meet to the first intersection node.\\nNote: If there is no intersection and length of both lists are same then both the pointers will points to NULL simultaneously in the first traversal.\\nIf there is no intersection and length of both lists are different then both the pointers will points to NULL simultaneously in the second traversal.\\n\\n# **CODE:**\\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB){\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);cout.tie(0);\\n        /* USING TWO POINTER*/\\n        ListNode* a = headA;\\n        ListNode* b = headB;\\n        while(a!=b){\\n            if(a==NULL){\\n                a=headB;\\n            }\\n            else{\\n                a = a -> next;\\n            }\\n            if(b==NULL){\\n                b=headA;\\n            }\\n            else{\\n                b = b -> next;\\n            }\\n        }\\n        return a;\\n    }\\n\\t\\n\\t\\n",
                "codeTag": "C++"
            },
            {
                "id": 2117634,
                "title": "c-efficient-solution-easy-to-understand",
                "content": "**\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        \\n        ListNode* p1;\\n        ListNode* p2;\\n        p1 = headA;\\n        p2 = headB;\\n        while(p1 != p2)\\n        {\\n            \\n            if(p1 ==NULL)\\n            {\\n                p1 = headB;\\n            }\\n            else\\n            {\\n                p1 = p1 ->next;\\n            }\\n            if(p2 == NULL)\\n            {\\n                p2 = headA;\\n            }\\n            else\\n            {\\n                p2 = p2 ->next;\\n            }\\n            \\n        }\\n        return p1;\\n    }\\n# };****",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        \\n        ListNode* p1;\\n        ListNode* p2;\\n        p1 = headA;\\n        p2 = headB;\\n        while(p1 != p2)\\n        {\\n            \\n            if(p1 ==NULL)\\n            {\\n                p1 = headB;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2117209,
                "title": "c-2-approach-easy-to-understand-daily-leetcoding-challenge-june-day-6",
                "content": "**Please Upvote If It helps**\\n\\n**Approach 1 : (Better Using Count)**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) \\n    {\\n        // if any one link list is emapty then return 0\\n        if(headA==NULL or headB==NULL) return NULL;\\n        \\n        ListNode* dummy1 = headA;  // for headA\\n        ListNode* dummy2 = headB;  // for headB\\n        \\n        int cnt1 = 0 , cnt2 = 0;   // for counting the length of both lists\\n        \\n        // counting the length of Linked List 1\\n        while(dummy1 != NULL)\\n        {\\n            cnt1++;\\n            dummy1 = dummy1->next;\\n        }\\n        \\n        // counting the length of Linked List 1\\n        while(dummy2 != NULL)\\n        {\\n            cnt2++;\\n            dummy2 = dummy2->next;\\n        }\\n        \\n        // aggain point our dummy1 and dummy2 to headA and headB\\n        dummy1 = headA;\\n        dummy2 = headB;\\n        \\n        // here we are finding the max & min length diff and according to that we are moving are dummy node to make both dummies equal\\n        int diff;\\n        if(cnt1 > cnt2)\\n        {\\n            diff = cnt1-cnt2;\\n            while(diff--)                                  // while diff not get 0 move our dummy\\n                dummy1 = dummy1->next;\\n        }\\n        else\\n        {\\n            diff = cnt2-cnt1;\\n            while(diff--)\\n                dummy2 = dummy2->next;\\n        }\\n        \\n        // till both dummmy node will not collide\\n        while(dummy1!=dummy2)\\n        {\\n            if(dummy1!=NULL)\\n            {\\n                dummy1 = dummy1->next;   // iterate the L1\\n            }\\n            \\n            \\n            if(dummy2!=NULL)\\n            {\\n                dummy2 = dummy2->next;   // iterate the L2\\n            }\\n\\n        }\\n        return dummy1;\\n    }\\n};\\n```\\n\\n\\n**Approach 2 : (Optimal Uisng Pointers)**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) \\n    {\\n        // if any one link list is emapty then return 0\\n        if(headA==NULL or headB==NULL) return NULL;\\n        \\n        ListNode* dummy1 = headA;  // for headA\\n        ListNode* dummy2 = headB;  // for headB\\n        \\n        // till both dummmy node will not collide\\n        while(dummy1!=dummy2)\\n        {\\n            if(dummy1!=NULL)\\n            {\\n                dummy1 = dummy1->next;   // iterate the L1\\n            }\\n            \\n            // logic behind this assign is to fill the differences \\n            else\\n            {\\n                dummy1 = headB;          // if dummy1 reached to null then assign it to head OF L2\\n            }\\n            \\n            if(dummy2!=NULL)\\n            {\\n                dummy2 = dummy2->next;   // iterate the L2\\n            }\\n            else\\n            {\\n                dummy2 = headA;          // if dummy2 reached to null then assign it to head OF L1\\n            }\\n        }\\n        return dummy1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) \\n    {\\n        // if any one link list is emapty then return 0\\n        if(headA==NULL or headB==NULL) return NULL;\\n        \\n        ListNode* dummy1 = headA;  // for headA\\n        ListNode* dummy2 = headB;  // for headB\\n        \\n        int cnt1 = 0 , cnt2 = 0;   // for counting the length of both lists\\n        \\n        // counting the length of Linked List 1\\n        while(dummy1 != NULL)\\n        {\\n            cnt1++;\\n            dummy1 = dummy1->next;\\n        }\\n        \\n        // counting the length of Linked List 1\\n        while(dummy2 != NULL)\\n        {\\n            cnt2++;\\n            dummy2 = dummy2->next;\\n        }\\n        \\n        // aggain point our dummy1 and dummy2 to headA and headB\\n        dummy1 = headA;\\n        dummy2 = headB;\\n        \\n        // here we are finding the max & min length diff and according to that we are moving are dummy node to make both dummies equal\\n        int diff;\\n        if(cnt1 > cnt2)\\n        {\\n            diff = cnt1-cnt2;\\n            while(diff--)                                  // while diff not get 0 move our dummy\\n                dummy1 = dummy1->next;\\n        }\\n        else\\n        {\\n            diff = cnt2-cnt1;\\n            while(diff--)\\n                dummy2 = dummy2->next;\\n        }\\n        \\n        // till both dummmy node will not collide\\n        while(dummy1!=dummy2)\\n        {\\n            if(dummy1!=NULL)\\n            {\\n                dummy1 = dummy1->next;   // iterate the L1\\n            }\\n            \\n            \\n            if(dummy2!=NULL)\\n            {\\n                dummy2 = dummy2->next;   // iterate the L2\\n            }\\n\\n        }\\n        return dummy1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) \\n    {\\n        // if any one link list is emapty then return 0\\n        if(headA==NULL or headB==NULL) return NULL;\\n        \\n        ListNode* dummy1 = headA;  // for headA\\n        ListNode* dummy2 = headB;  // for headB\\n        \\n        // till both dummmy node will not collide\\n        while(dummy1!=dummy2)\\n        {\\n            if(dummy1!=NULL)\\n            {\\n                dummy1 = dummy1->next;   // iterate the L1\\n            }\\n            \\n            // logic behind this assign is to fill the differences \\n            else\\n            {\\n                dummy1 = headB;          // if dummy1 reached to null then assign it to head OF L2\\n            }\\n            \\n            if(dummy2!=NULL)\\n            {\\n                dummy2 = dummy2->next;   // iterate the L2\\n            }\\n            else\\n            {\\n                dummy2 = headA;          // if dummy2 reached to null then assign it to head OF L1\\n            }\\n        }\\n        return dummy1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2117005,
                "title": "python-two-pass-comments",
                "content": "```\\n def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        aLen = self.getLength(headA)\\n        bLen = self.getLength(headB)\\n        # print(f\\'|aLen| => {aLen}, |bLen| => {bLen}\\')\\n        \\n        a_ptr, b_ptr = headA, headB\\n        \\n        # move the pointers to the appropriate spots\\n        if aLen < bLen:\\n            # move b to start at the same end distance as a\\n            for i in range(bLen - aLen):\\n                b_ptr = b_ptr.next\\n            \\n        else:\\n            # move a to start at the same end distance as b\\n            for i in range(aLen - bLen):\\n                a_ptr = a_ptr.next\\n                \\n        # check to see if there is an intersection\\n        while a_ptr and b_ptr:\\n            if a_ptr == b_ptr:\\n                return a_ptr\\n            a_ptr = a_ptr.next\\n            b_ptr = b_ptr.next\\n        \\n        return None \\n        \\n    def getLength(self, node: ListNode) -> int:\\n        _len = 0\\n        cur = node\\n        while cur:\\n            cur = cur.next\\n            _len += 1\\n        return _len\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\\n        aLen = self.getLength(headA)\\n        bLen = self.getLength(headB)\\n        # print(f\\'|aLen| => {aLen}, |bLen| => {bLen}\\')\\n        \\n        a_ptr, b_ptr = headA, headB\\n        \\n        # move the pointers to the appropriate spots\\n        if aLen < bLen:\\n            # move b to start at the same end distance as a\\n            for i in range(bLen - aLen):\\n                b_ptr = b_ptr.next\\n            \\n        else:\\n            # move a to start at the same end distance as b\\n            for i in range(aLen - bLen):\\n                a_ptr = a_ptr.next\\n                \\n        # check to see if there is an intersection\\n        while a_ptr and b_ptr:\\n            if a_ptr == b_ptr:\\n                return a_ptr\\n            a_ptr = a_ptr.next\\n            b_ptr = b_ptr.next\\n        \\n        return None \\n        \\n    def getLength(self, node: ListNode) -> int:\\n        _len = 0\\n        cur = node\\n        while cur:\\n            cur = cur.next\\n            _len += 1\\n        return _len\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2116795,
                "title": "javascript-js-solution-ultrafast",
                "content": "JavaScript solution\\n\\n```\\nvar getIntersectionNode = function(headA, headB) {\\n    const map = new WeakMap();\\n\\n    while (headA || headB) {\\n        if (headA) {\\n            if (map.has(headA)) {\\n                return headA;\\n            }\\n\\n            map.set(headA, true);\\n            headA = headA.next;\\n        }\\n        \\n        if (headB) {\\n            if (map.has(headB)) {\\n                return headB;\\n            }\\n\\n            map.set(headB, true);\\n            headB = headB.next;\\n        }\\n    }\\n\\n    return null;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getIntersectionNode = function(headA, headB) {\\n    const map = new WeakMap();\\n\\n    while (headA || headB) {\\n        if (headA) {\\n            if (map.has(headA)) {\\n                return headA;\\n            }\\n\\n            map.set(headA, true);\\n            headA = headA.next;\\n        }\\n        \\n        if (headB) {\\n            if (map.has(headB)) {\\n                return headB;\\n            }\\n\\n            map.set(headB, true);\\n            headB = headB.next;\\n        }\\n    }\\n\\n    return null;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2116777,
                "title": "1-ms-faster-than-99-17-of-java-online-submissions-for-intersection-of-two-linked-lists",
                "content": "```\\n        ListNode slow = headA;\\n        ListNode fast = headB;\\n        while(slow != fast)\\n        {\\n            slow = slow.next;\\n            fast = fast.next;\\n            if(slow == fast)\\n            {\\n                return slow;\\n            }\\n            if(slow == null)\\n            {\\n                slow = headB;\\n            }\\n            if(fast == null)\\n            {\\n                fast = headA;\\n            }\\n        }\\n        return slow;\\n\\t",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n        ListNode slow = headA;\\n        ListNode fast = headB;\\n        while(slow != fast)\\n        {\\n            slow = slow.next;\\n            fast = fast.next;\\n            if(slow == fast)\\n            {\\n                return slow;\\n            }\\n            if(slow == null)\\n            {\\n                slow = headB;\\n            }\\n            if(fast == null)\\n            {\\n                fast = headA;\\n            }\\n        }\\n        return slow;\\n\\t",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1566447,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1565391,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1565983,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1567217,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1566338,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1567743,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1566986,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1566324,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1567603,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1566908,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1566447,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1565391,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1565983,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1567217,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1566338,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1567743,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1566986,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1566324,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1567603,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1566908,
                "content": [
                    {
                        "username": "karan_8082",
                        "content": "**UPVOTE IF HELPFuuL**\\n\\n**O ( 1 ) SPACE SOLUTION**\\n\\nFirst using constant space check for last element of both lists.\\n**If tails of both lists are different then return NULL**\\n\\nNow we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.\\nHead pointer of the longer list is moved to next till **length of both lists become equal**\\n\\n**NOW** we will have **intersetion point** at the same distance from head for both the lists.\\n\\nNow keep comparing heads till match found.\\n\\nNOW TRY TO IMPLEMENT YOURSELF :::: THINK THAT WILL BE EASY\\n\\n![image](https://assets.leetcode.com/users/images/36d4e97b-6a12-4ae2-a49e-54a92f97d652_1654486479.9570858.jpeg)\\n\\n"
                    },
                    {
                        "username": "yacinedevacc",
                        "content": "[@aayushnig07](/aayushnig07) in your example, nodes at index 0 are distinct, they point at different nodes (having values 2 and 9) so clearly there is no intersection."
                    },
                    {
                        "username": "srapol",
                        "content": "gotta say man the fact that the idea for the solution being this simple makes it although more crazy"
                    },
                    {
                        "username": "abhishek_121",
                        "content": "[@aayushnig07](/aayushnig07)  \\n\\nYes, in this case the algorithm seems to fail . "
                    },
                    {
                        "username": "aayushnig07",
                        "content": "[@Shivam_verma24](/Shivam_verma24) Hi Shivam, thanks for the approach!!.\\nNot sure if this test case is expected here. What about the scenario when the 2 linked list are originating from the same node?\\nIf this is a valid test case here, then the 1st approach of checking for the last node being same will fail.\\nExample:\\nNode1 = 1->2->3->4\\nNode2 = 1->9->8->7"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "One more upvote for the last meme"
                    },
                    {
                        "username": "Ky_Andy",
                        "content": "The input of example 1 is:\\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\\nbut why it should return 8 instead of 1?\\nThese two lists intersected at 1 obviously.\\n\\nCould anyone help me with this?"
                    },
                    {
                        "username": "kali_1811",
                        "content": "Cause May be the vals those two mybe same but their addresses are different i.e 1 in list_a is different from list_b their addresses are different\\n"
                    },
                    {
                        "username": "iUtkarshVats",
                        "content": "[@keshav-Aggarwal_001](/keshav-Aggarwal_001)  you dont need how many skips judge made to get the intersection point, all we need to do is return the first node with same memory address in both lists...to brute force it just compare all elements of both lists till you get the common node..."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "the nodes are equal not the values...."
                    },
                    {
                        "username": "chenmst",
                        "content": "because what is equal is not the two node.val \\uFF08the two values 1\\uFF09, but nodes, the two 1 are saved in differet location on memory, which makes them two different nodes. But the 8 is same node (a specific location on memory) with same value, it is the intersection node."
                    },
                    {
                        "username": "keshav-Aggarwal_001",
                        "content": "[@Ayush379](/Ayush379) But sir , we are not given any skipa and skipb in the getintersectionNode function as a parameter , then how can we do it ??\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Look carefully, SkipA and SkipB will tell you the number of skips to be taken from each list, to get to the intersection node. So, using this info we can say that, there are 2 nodes with value 1 and intersection starts at 8. \\nAnd the question is about intersection (same node, not same value). "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Babitabisht",
                        "content": "since, we need to find the \\'intersection node\\' and not the \\'Node with same value\\'.   The reference/address of the intersection node should be same."
                    },
                    {
                        "username": "tguo40",
                        "content": "I don\\'t see variables like skipA, skipB, intersectVal given as input ..."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "mkohar",
                        "content": "read problem description again:- \"your program is not given these inputs\".\\n\\nThese variables are provided to judge to evaluate if your solution is correct or not"
                    },
                    {
                        "username": "Samuri",
                        "content": "    Input:\\tIntersected at '1': {1}, {1}\\n    Output:\\tNo intersection\\n    Expected:\\tIntersected at '1'\\n\\nWhat does input look like? If there is only one element in each list, how come they will intersect?"
                    },
                    {
                        "username": "pandeynitin702",
                        "content": "see in the given test case each linked list has a node whose value is 1, but the address they will be storing must be different so they are not the same node. and to intersect two linked lists, two nodes must be equal(value as well as address). do upvote if you find it helpful."
                    },
                    {
                        "username": "satish040",
                        "content": "This question is very confusing. If you check the solution they are providing, they ask you to check for reference/value.\\nAccording to value list A = [4,1,8,4,5], listB = [5,0,1,8,4,5] 1 is the point of intersection.\\nAlso the result varies on the values of skipA and skipB..."
                    },
                    {
                        "username": "Ayush379",
                        "content": "Well intersection would be at the node with value 8.\nSkipA and SkipB indicates the number  of jumps to take from both the lists, respectfully, such that the next node is intersecting.\n\nSo, if in the Same question A = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 1 and SkipB = 2\nIt means 1 is the intersecting node.\nIf SkipA = 2, SkipB = 3, then intersecting node is 8. \nPlease note it has nothing to do with same value. There can be 2 lists, with different nodes but same values.\n\nAnd the question is about intersection (same node, not same value).\nI hope it would help you."
                    },
                    {
                        "username": "npsfsz",
                        "content": "So you know the code already from other answers, but you don\\'t know the reason why you want to move to headB after a == Null, and vice versa for b == Null.\\n\\nI got confused too, and spent some time thinking about it.\\n\\nThink in this way:\\n1. Suppose they have an intersection. Then the two lists will have the same nodes from the \"intersection\" to the end. \\n2. If we can align the tails of both lists, it\\'s pretty easy to find the intersection. You just go from the tail and trace back to the head.\\n3. Let\\'s say list A has A nodes and list B has B nodes, and A < B. If we can align their tails, aka move B - A steps in list B, then list A and list B will both have A nodes until the tail. We just need to do something like a = a.next and b = b.next until we find the intersection.\\n4. How to move B - A steps in list B? That\\'s the a = headB part in others\\' answers."
                    },
                    {
                        "username": "vithikaagr",
                        "content": "In the first test case, the arrays have [4,1,8,4,5], [5,6,1,8,4,5] the intersection is at 1 since ,1,8,4,5 are common. Why does it intersect at 8?\\n"
                    },
                    {
                        "username": "harshmathur_1503",
                        "content": "I think it\\'s because 1 is the first common node between these two lists , after it all node\\'s are same in both lists ..."
                    },
                    {
                        "username": "vxlkx",
                        "content": "2 years and 9 months late, but: the problem asks you to find the intersecting node. Multiple nodes may have the same value, but they all have different memory addresses."
                    },
                    {
                        "username": "amitru",
                        "content": "In the given example 1 the list1 =[ 4,1,8,4,5] & list2: [5,0,1,8,4,5], the intersection point should be 1 , its showing as 8, let me know if I am wrong."
                    },
                    {
                        "username": "mkohar",
                        "content": "yes you are wrong :)"
                    },
                    {
                        "username": "everest8848",
                        "content": "compare reference, not value. i.e. the node object address rather than the value stored at that address."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "compare both head pointers , not the value."
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    },
                    {
                        "username": "Jman19er",
                        "content": "I think the following example should intersect at the value \\'1\\' however, when tested, the correct value for intersection is 8. Is this an error on my part? If so, would somebody please be so kind as to explain why?\\n\\n[4,1,8,4,5]\\n[5,6,1,8,4,5]\\n\\nThanks,\\nJosh"
                    },
                    {
                        "username": "Rohit__jangid",
                        "content": "no i thought the same way but you are comparing values , yes they are equal but they are not the same node. Right ? if you print reference of 1 in first  and reference of 1 with second . they are not same.\n\ni think you have to check if their nodes are equal not just the val.\n\ni solved it but my solution is not good for high number of input . I am getting time limit exceed :("
                    },
                    {
                        "username": "thronesf",
                        "content": "Hi all, \\nI\\'m confused by the Example1, which returns 8. Shouldn\\'t it return 1?"
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "We are not comparing ListNode->val here... we need to compare the ListNode itself, as even though both LL contain 1\\'s but they are not the same node... whereas the node containing val 8 is."
                    },
                    {
                        "username": "vxlkx",
                        "content": "If you print a node that doesn\\'t store any data, the program will return the node\\'s address in memory (\"< ... main ...>\"). This address is unique and is what\\'s used to locate the node. "
                    },
                    {
                        "username": "yashmarmat08",
                        "content": "i have answered this here => https://stackoverflow.com/a/74039528/12636415"
                    }
                ]
            },
            {
                "id": 1567425,
                "content": [
                    {
                        "username": "fantow",
                        "content": "The input is \\nlistA = [4,1,8,4,5],\\nlistB = [5,0,1,8,4,5]\\nI think the answer is 1 in this example.\\n\\nWe can not get the skipA and skipB from the input."
                    },
                    {
                        "username": "kai28",
                        "content": "Assume two liists are endless, they want to find the intersection with space O(1). Any idea of it?"
                    },
                    {
                        "username": "balint",
                        "content": "The idea came from this problem: https://oj.leetcode.com/problems/linked-list-cycle-ii/\\n\\nThe current problem can be formalized to match that problem: just connect the tail of list A to the head of B. Then find the starting point of the cycle which will be the same as the intersection of the original lists. Of course at the and you must restore the original lists, removing the cycle."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/intersection-of-two-linked-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "valarmorghulis96",
                        "content": "Do we account for skipA and skipB?"
                    },
                    {
                        "username": "m_yusuf",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\nLine 80 in _driver (Solution.py)\\nLine 100 in <module> (Solution.py)\\n\\nHi I am getting above error..\\nCan anyone help ?\\nSeems to be  driver program error.\\n\\nEven  6 inputs are mentioned in explanation but signature of method/function has only two inputs ... ??"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "you need to return a listnode, not an int value\\nyou are provided with only 2 inputs ,the rest will be visible in console result\\n"
                    },
                    {
                        "username": "ylee6",
                        "content": "On the first example, shouldn\\'t the intersection point be at \\'1\\' rather than \\'8\\'?"
                    },
                    {
                        "username": "austmatt",
                        "content": "Why isn\\'t the intersection 1, instead of 8 for test case 1? In test case 2, the intersection seems to follow the logic it should, but my code is saying they intersect at 1 because this is the first part of the sequence they have in common."
                    },
                    {
                        "username": "rafaele1",
                        "content": "In example1 intersection is at node 8 , why not node 1?"
                    },
                    {
                        "username": "shawnhe",
                        "content": "It appears that example 1\\'s answer is wrong, the intersection should be one element before 8, which is 1, as both lists have the element of 1."
                    }
                ]
            },
            {
                "id": 1567518,
                "content": [
                    {
                        "username": "fantow",
                        "content": "The input is \\nlistA = [4,1,8,4,5],\\nlistB = [5,0,1,8,4,5]\\nI think the answer is 1 in this example.\\n\\nWe can not get the skipA and skipB from the input."
                    },
                    {
                        "username": "kai28",
                        "content": "Assume two liists are endless, they want to find the intersection with space O(1). Any idea of it?"
                    },
                    {
                        "username": "balint",
                        "content": "The idea came from this problem: https://oj.leetcode.com/problems/linked-list-cycle-ii/\\n\\nThe current problem can be formalized to match that problem: just connect the tail of list A to the head of B. Then find the starting point of the cycle which will be the same as the intersection of the original lists. Of course at the and you must restore the original lists, removing the cycle."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/intersection-of-two-linked-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "valarmorghulis96",
                        "content": "Do we account for skipA and skipB?"
                    },
                    {
                        "username": "m_yusuf",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\nLine 80 in _driver (Solution.py)\\nLine 100 in <module> (Solution.py)\\n\\nHi I am getting above error..\\nCan anyone help ?\\nSeems to be  driver program error.\\n\\nEven  6 inputs are mentioned in explanation but signature of method/function has only two inputs ... ??"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "you need to return a listnode, not an int value\\nyou are provided with only 2 inputs ,the rest will be visible in console result\\n"
                    },
                    {
                        "username": "ylee6",
                        "content": "On the first example, shouldn\\'t the intersection point be at \\'1\\' rather than \\'8\\'?"
                    },
                    {
                        "username": "austmatt",
                        "content": "Why isn\\'t the intersection 1, instead of 8 for test case 1? In test case 2, the intersection seems to follow the logic it should, but my code is saying they intersect at 1 because this is the first part of the sequence they have in common."
                    },
                    {
                        "username": "rafaele1",
                        "content": "In example1 intersection is at node 8 , why not node 1?"
                    },
                    {
                        "username": "shawnhe",
                        "content": "It appears that example 1\\'s answer is wrong, the intersection should be one element before 8, which is 1, as both lists have the element of 1."
                    }
                ]
            },
            {
                "id": 1568988,
                "content": [
                    {
                        "username": "fantow",
                        "content": "The input is \\nlistA = [4,1,8,4,5],\\nlistB = [5,0,1,8,4,5]\\nI think the answer is 1 in this example.\\n\\nWe can not get the skipA and skipB from the input."
                    },
                    {
                        "username": "kai28",
                        "content": "Assume two liists are endless, they want to find the intersection with space O(1). Any idea of it?"
                    },
                    {
                        "username": "balint",
                        "content": "The idea came from this problem: https://oj.leetcode.com/problems/linked-list-cycle-ii/\\n\\nThe current problem can be formalized to match that problem: just connect the tail of list A to the head of B. Then find the starting point of the cycle which will be the same as the intersection of the original lists. Of course at the and you must restore the original lists, removing the cycle."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/intersection-of-two-linked-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "valarmorghulis96",
                        "content": "Do we account for skipA and skipB?"
                    },
                    {
                        "username": "m_yusuf",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\nLine 80 in _driver (Solution.py)\\nLine 100 in <module> (Solution.py)\\n\\nHi I am getting above error..\\nCan anyone help ?\\nSeems to be  driver program error.\\n\\nEven  6 inputs are mentioned in explanation but signature of method/function has only two inputs ... ??"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "you need to return a listnode, not an int value\\nyou are provided with only 2 inputs ,the rest will be visible in console result\\n"
                    },
                    {
                        "username": "ylee6",
                        "content": "On the first example, shouldn\\'t the intersection point be at \\'1\\' rather than \\'8\\'?"
                    },
                    {
                        "username": "austmatt",
                        "content": "Why isn\\'t the intersection 1, instead of 8 for test case 1? In test case 2, the intersection seems to follow the logic it should, but my code is saying they intersect at 1 because this is the first part of the sequence they have in common."
                    },
                    {
                        "username": "rafaele1",
                        "content": "In example1 intersection is at node 8 , why not node 1?"
                    },
                    {
                        "username": "shawnhe",
                        "content": "It appears that example 1\\'s answer is wrong, the intersection should be one element before 8, which is 1, as both lists have the element of 1."
                    }
                ]
            },
            {
                "id": 1566723,
                "content": [
                    {
                        "username": "fantow",
                        "content": "The input is \\nlistA = [4,1,8,4,5],\\nlistB = [5,0,1,8,4,5]\\nI think the answer is 1 in this example.\\n\\nWe can not get the skipA and skipB from the input."
                    },
                    {
                        "username": "kai28",
                        "content": "Assume two liists are endless, they want to find the intersection with space O(1). Any idea of it?"
                    },
                    {
                        "username": "balint",
                        "content": "The idea came from this problem: https://oj.leetcode.com/problems/linked-list-cycle-ii/\\n\\nThe current problem can be formalized to match that problem: just connect the tail of list A to the head of B. Then find the starting point of the cycle which will be the same as the intersection of the original lists. Of course at the and you must restore the original lists, removing the cycle."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/intersection-of-two-linked-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "valarmorghulis96",
                        "content": "Do we account for skipA and skipB?"
                    },
                    {
                        "username": "m_yusuf",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\nLine 80 in _driver (Solution.py)\\nLine 100 in <module> (Solution.py)\\n\\nHi I am getting above error..\\nCan anyone help ?\\nSeems to be  driver program error.\\n\\nEven  6 inputs are mentioned in explanation but signature of method/function has only two inputs ... ??"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "you need to return a listnode, not an int value\\nyou are provided with only 2 inputs ,the rest will be visible in console result\\n"
                    },
                    {
                        "username": "ylee6",
                        "content": "On the first example, shouldn\\'t the intersection point be at \\'1\\' rather than \\'8\\'?"
                    },
                    {
                        "username": "austmatt",
                        "content": "Why isn\\'t the intersection 1, instead of 8 for test case 1? In test case 2, the intersection seems to follow the logic it should, but my code is saying they intersect at 1 because this is the first part of the sequence they have in common."
                    },
                    {
                        "username": "rafaele1",
                        "content": "In example1 intersection is at node 8 , why not node 1?"
                    },
                    {
                        "username": "shawnhe",
                        "content": "It appears that example 1\\'s answer is wrong, the intersection should be one element before 8, which is 1, as both lists have the element of 1."
                    }
                ]
            },
            {
                "id": 1566301,
                "content": [
                    {
                        "username": "fantow",
                        "content": "The input is \\nlistA = [4,1,8,4,5],\\nlistB = [5,0,1,8,4,5]\\nI think the answer is 1 in this example.\\n\\nWe can not get the skipA and skipB from the input."
                    },
                    {
                        "username": "kai28",
                        "content": "Assume two liists are endless, they want to find the intersection with space O(1). Any idea of it?"
                    },
                    {
                        "username": "balint",
                        "content": "The idea came from this problem: https://oj.leetcode.com/problems/linked-list-cycle-ii/\\n\\nThe current problem can be formalized to match that problem: just connect the tail of list A to the head of B. Then find the starting point of the cycle which will be the same as the intersection of the original lists. Of course at the and you must restore the original lists, removing the cycle."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/intersection-of-two-linked-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "valarmorghulis96",
                        "content": "Do we account for skipA and skipB?"
                    },
                    {
                        "username": "m_yusuf",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\nLine 80 in _driver (Solution.py)\\nLine 100 in <module> (Solution.py)\\n\\nHi I am getting above error..\\nCan anyone help ?\\nSeems to be  driver program error.\\n\\nEven  6 inputs are mentioned in explanation but signature of method/function has only two inputs ... ??"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "you need to return a listnode, not an int value\\nyou are provided with only 2 inputs ,the rest will be visible in console result\\n"
                    },
                    {
                        "username": "ylee6",
                        "content": "On the first example, shouldn\\'t the intersection point be at \\'1\\' rather than \\'8\\'?"
                    },
                    {
                        "username": "austmatt",
                        "content": "Why isn\\'t the intersection 1, instead of 8 for test case 1? In test case 2, the intersection seems to follow the logic it should, but my code is saying they intersect at 1 because this is the first part of the sequence they have in common."
                    },
                    {
                        "username": "rafaele1",
                        "content": "In example1 intersection is at node 8 , why not node 1?"
                    },
                    {
                        "username": "shawnhe",
                        "content": "It appears that example 1\\'s answer is wrong, the intersection should be one element before 8, which is 1, as both lists have the element of 1."
                    }
                ]
            },
            {
                "id": 1566591,
                "content": [
                    {
                        "username": "fantow",
                        "content": "The input is \\nlistA = [4,1,8,4,5],\\nlistB = [5,0,1,8,4,5]\\nI think the answer is 1 in this example.\\n\\nWe can not get the skipA and skipB from the input."
                    },
                    {
                        "username": "kai28",
                        "content": "Assume two liists are endless, they want to find the intersection with space O(1). Any idea of it?"
                    },
                    {
                        "username": "balint",
                        "content": "The idea came from this problem: https://oj.leetcode.com/problems/linked-list-cycle-ii/\\n\\nThe current problem can be formalized to match that problem: just connect the tail of list A to the head of B. Then find the starting point of the cycle which will be the same as the intersection of the original lists. Of course at the and you must restore the original lists, removing the cycle."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/intersection-of-two-linked-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "valarmorghulis96",
                        "content": "Do we account for skipA and skipB?"
                    },
                    {
                        "username": "m_yusuf",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\nLine 80 in _driver (Solution.py)\\nLine 100 in <module> (Solution.py)\\n\\nHi I am getting above error..\\nCan anyone help ?\\nSeems to be  driver program error.\\n\\nEven  6 inputs are mentioned in explanation but signature of method/function has only two inputs ... ??"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "you need to return a listnode, not an int value\\nyou are provided with only 2 inputs ,the rest will be visible in console result\\n"
                    },
                    {
                        "username": "ylee6",
                        "content": "On the first example, shouldn\\'t the intersection point be at \\'1\\' rather than \\'8\\'?"
                    },
                    {
                        "username": "austmatt",
                        "content": "Why isn\\'t the intersection 1, instead of 8 for test case 1? In test case 2, the intersection seems to follow the logic it should, but my code is saying they intersect at 1 because this is the first part of the sequence they have in common."
                    },
                    {
                        "username": "rafaele1",
                        "content": "In example1 intersection is at node 8 , why not node 1?"
                    },
                    {
                        "username": "shawnhe",
                        "content": "It appears that example 1\\'s answer is wrong, the intersection should be one element before 8, which is 1, as both lists have the element of 1."
                    }
                ]
            },
            {
                "id": 1570781,
                "content": [
                    {
                        "username": "fantow",
                        "content": "The input is \\nlistA = [4,1,8,4,5],\\nlistB = [5,0,1,8,4,5]\\nI think the answer is 1 in this example.\\n\\nWe can not get the skipA and skipB from the input."
                    },
                    {
                        "username": "kai28",
                        "content": "Assume two liists are endless, they want to find the intersection with space O(1). Any idea of it?"
                    },
                    {
                        "username": "balint",
                        "content": "The idea came from this problem: https://oj.leetcode.com/problems/linked-list-cycle-ii/\\n\\nThe current problem can be formalized to match that problem: just connect the tail of list A to the head of B. Then find the starting point of the cycle which will be the same as the intersection of the original lists. Of course at the and you must restore the original lists, removing the cycle."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/intersection-of-two-linked-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "valarmorghulis96",
                        "content": "Do we account for skipA and skipB?"
                    },
                    {
                        "username": "m_yusuf",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\nLine 80 in _driver (Solution.py)\\nLine 100 in <module> (Solution.py)\\n\\nHi I am getting above error..\\nCan anyone help ?\\nSeems to be  driver program error.\\n\\nEven  6 inputs are mentioned in explanation but signature of method/function has only two inputs ... ??"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "you need to return a listnode, not an int value\\nyou are provided with only 2 inputs ,the rest will be visible in console result\\n"
                    },
                    {
                        "username": "ylee6",
                        "content": "On the first example, shouldn\\'t the intersection point be at \\'1\\' rather than \\'8\\'?"
                    },
                    {
                        "username": "austmatt",
                        "content": "Why isn\\'t the intersection 1, instead of 8 for test case 1? In test case 2, the intersection seems to follow the logic it should, but my code is saying they intersect at 1 because this is the first part of the sequence they have in common."
                    },
                    {
                        "username": "rafaele1",
                        "content": "In example1 intersection is at node 8 , why not node 1?"
                    },
                    {
                        "username": "shawnhe",
                        "content": "It appears that example 1\\'s answer is wrong, the intersection should be one element before 8, which is 1, as both lists have the element of 1."
                    }
                ]
            },
            {
                "id": 1568556,
                "content": [
                    {
                        "username": "fantow",
                        "content": "The input is \\nlistA = [4,1,8,4,5],\\nlistB = [5,0,1,8,4,5]\\nI think the answer is 1 in this example.\\n\\nWe can not get the skipA and skipB from the input."
                    },
                    {
                        "username": "kai28",
                        "content": "Assume two liists are endless, they want to find the intersection with space O(1). Any idea of it?"
                    },
                    {
                        "username": "balint",
                        "content": "The idea came from this problem: https://oj.leetcode.com/problems/linked-list-cycle-ii/\\n\\nThe current problem can be formalized to match that problem: just connect the tail of list A to the head of B. Then find the starting point of the cycle which will be the same as the intersection of the original lists. Of course at the and you must restore the original lists, removing the cycle."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/intersection-of-two-linked-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "valarmorghulis96",
                        "content": "Do we account for skipA and skipB?"
                    },
                    {
                        "username": "m_yusuf",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\nLine 80 in _driver (Solution.py)\\nLine 100 in <module> (Solution.py)\\n\\nHi I am getting above error..\\nCan anyone help ?\\nSeems to be  driver program error.\\n\\nEven  6 inputs are mentioned in explanation but signature of method/function has only two inputs ... ??"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "you need to return a listnode, not an int value\\nyou are provided with only 2 inputs ,the rest will be visible in console result\\n"
                    },
                    {
                        "username": "ylee6",
                        "content": "On the first example, shouldn\\'t the intersection point be at \\'1\\' rather than \\'8\\'?"
                    },
                    {
                        "username": "austmatt",
                        "content": "Why isn\\'t the intersection 1, instead of 8 for test case 1? In test case 2, the intersection seems to follow the logic it should, but my code is saying they intersect at 1 because this is the first part of the sequence they have in common."
                    },
                    {
                        "username": "rafaele1",
                        "content": "In example1 intersection is at node 8 , why not node 1?"
                    },
                    {
                        "username": "shawnhe",
                        "content": "It appears that example 1\\'s answer is wrong, the intersection should be one element before 8, which is 1, as both lists have the element of 1."
                    }
                ]
            },
            {
                "id": 1568359,
                "content": [
                    {
                        "username": "fantow",
                        "content": "The input is \\nlistA = [4,1,8,4,5],\\nlistB = [5,0,1,8,4,5]\\nI think the answer is 1 in this example.\\n\\nWe can not get the skipA and skipB from the input."
                    },
                    {
                        "username": "kai28",
                        "content": "Assume two liists are endless, they want to find the intersection with space O(1). Any idea of it?"
                    },
                    {
                        "username": "balint",
                        "content": "The idea came from this problem: https://oj.leetcode.com/problems/linked-list-cycle-ii/\\n\\nThe current problem can be formalized to match that problem: just connect the tail of list A to the head of B. Then find the starting point of the cycle which will be the same as the intersection of the original lists. Of course at the and you must restore the original lists, removing the cycle."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/intersection-of-two-linked-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "valarmorghulis96",
                        "content": "Do we account for skipA and skipB?"
                    },
                    {
                        "username": "m_yusuf",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\nLine 80 in _driver (Solution.py)\\nLine 100 in <module> (Solution.py)\\n\\nHi I am getting above error..\\nCan anyone help ?\\nSeems to be  driver program error.\\n\\nEven  6 inputs are mentioned in explanation but signature of method/function has only two inputs ... ??"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "you need to return a listnode, not an int value\\nyou are provided with only 2 inputs ,the rest will be visible in console result\\n"
                    },
                    {
                        "username": "ylee6",
                        "content": "On the first example, shouldn\\'t the intersection point be at \\'1\\' rather than \\'8\\'?"
                    },
                    {
                        "username": "austmatt",
                        "content": "Why isn\\'t the intersection 1, instead of 8 for test case 1? In test case 2, the intersection seems to follow the logic it should, but my code is saying they intersect at 1 because this is the first part of the sequence they have in common."
                    },
                    {
                        "username": "rafaele1",
                        "content": "In example1 intersection is at node 8 , why not node 1?"
                    },
                    {
                        "username": "shawnhe",
                        "content": "It appears that example 1\\'s answer is wrong, the intersection should be one element before 8, which is 1, as both lists have the element of 1."
                    }
                ]
            },
            {
                "id": 1568174,
                "content": [
                    {
                        "username": "fantow",
                        "content": "The input is \\nlistA = [4,1,8,4,5],\\nlistB = [5,0,1,8,4,5]\\nI think the answer is 1 in this example.\\n\\nWe can not get the skipA and skipB from the input."
                    },
                    {
                        "username": "kai28",
                        "content": "Assume two liists are endless, they want to find the intersection with space O(1). Any idea of it?"
                    },
                    {
                        "username": "balint",
                        "content": "The idea came from this problem: https://oj.leetcode.com/problems/linked-list-cycle-ii/\\n\\nThe current problem can be formalized to match that problem: just connect the tail of list A to the head of B. Then find the starting point of the cycle which will be the same as the intersection of the original lists. Of course at the and you must restore the original lists, removing the cycle."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/intersection-of-two-linked-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "valarmorghulis96",
                        "content": "Do we account for skipA and skipB?"
                    },
                    {
                        "username": "m_yusuf",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\nLine 80 in _driver (Solution.py)\\nLine 100 in <module> (Solution.py)\\n\\nHi I am getting above error..\\nCan anyone help ?\\nSeems to be  driver program error.\\n\\nEven  6 inputs are mentioned in explanation but signature of method/function has only two inputs ... ??"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "you need to return a listnode, not an int value\\nyou are provided with only 2 inputs ,the rest will be visible in console result\\n"
                    },
                    {
                        "username": "ylee6",
                        "content": "On the first example, shouldn\\'t the intersection point be at \\'1\\' rather than \\'8\\'?"
                    },
                    {
                        "username": "austmatt",
                        "content": "Why isn\\'t the intersection 1, instead of 8 for test case 1? In test case 2, the intersection seems to follow the logic it should, but my code is saying they intersect at 1 because this is the first part of the sequence they have in common."
                    },
                    {
                        "username": "rafaele1",
                        "content": "In example1 intersection is at node 8 , why not node 1?"
                    },
                    {
                        "username": "shawnhe",
                        "content": "It appears that example 1\\'s answer is wrong, the intersection should be one element before 8, which is 1, as both lists have the element of 1."
                    }
                ]
            },
            {
                "id": 1568106,
                "content": [
                    {
                        "username": "khaled_acmilan",
                        "content": "Hi there,\\n\\nIt seems I couldn\\'t understand the problem since I\\'m looking at the first example : \\n\\nlistA = [4,1,8,4,5], listB = [5,0,1,8,4,5]\\n\\nI thought when we check on both lists, 1 should be the begining of the intersection of these two lists , why 8 is the answer here? I really couldn\\'t understand why 1 is wrong answer here.\\n\\nSo, what I understood is that I need to know the length of both and try to start where I can traverse for both the lists but when I travese I find that 1 is the first element that we will enounter as we traverse that satisfy the condition that listA and listB has this item.\\n\\nCan you please explain me why 1 is wrong and 8 is right?\\n\\nI will appreciate any insights on that problem :) \\n\\nKhaled"
                    },
                    {
                        "username": "XiaojingHu",
                        "content": "Well I see the problem as a variant of the detection of linked cycles. If you redirect the tail of the list to headB, you\\'ll find that the problem becomes finding the intersection of a linked list with cycle. Then use Floyd\\'s Tortoise and Hare algorithm, you can \"easily\" solve the problem. Just to provide another perspective, because my code is messy."
                    },
                    {
                        "username": "dingyuming102",
                        "content": "Romantic two pointers\\n\"If I wander to the end of the world and still cannot find you, I will take another path and search anew.\"\\n\"And I shall do the same, my love.\""
                    },
                    {
                        "username": "deleted_user",
                        "content": "I don\\'t understand this question.\\nI thought the overlapping should be `1` instead of `8`?"
                    },
                    {
                        "username": "anatayo",
                        "content": "Input: \\nintersectVal = 8, \\nlistA = [4,1,8,4,5], \\nlistB = [5,0,1,8,4,5], \\nskipA = 2, \\nskipB = 3\\n\\nWhy not return 1?"
                    },
                    {
                        "username": "sruzic",
                        "content": "1->2->3*->4->5\\n\\n6->7->3*->8->9\\n\\n*same adress"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "in this case listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]\\n\\nit should return 1 right ? because they intersect at 1 but leet code shows 8 ?? leet code \\uD83C\\uDF75"
                    },
                    {
                        "username": "keerthikumar_n",
                        "content": "For me this is not at all a \"EASY\" level problem statement. First of all the explanation above is tricky and baffling. Also, the examples with inputs explained looks HARD to understand !! "
                    },
                    {
                        "username": "gprajwal45",
                        "content": "I am getting TLE for the following code in python, any way to optimize it?\\n       \\n        d1 = headA\\n        d2 = headB\\n\\n        while d1 != d2:\\n            d1 = d1.next\\n            d2 = d2.next\\n\\n            if d1.next == None:\\n                d1 = headB\\n            if d2.next == None:\\n                d2 = headA\\n           \\n        return d1"
                    },
                    {
                        "username": "Kumar__aman1043",
                        "content": "d1 = headA\\n    d2 = headB\\n\\n    while d1 != d2:\\n      \\n        if d1.next == None:\\n            d1 = headB\\n        else \\n           d1 = d1.next\\n        if d2.next == None:\\n            d2 = headA\\n        else \\n           d2 = d2.next\\n       \\n    return d1"
                    },
                    {
                        "username": "chandancp",
                        "content": "verry small and  efficent code \\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n           if(headA==NULL or headB==NULL)\\n           {\\n               return NULL;\\n           }\\n           ListNode*a=headA;\\n           ListNode*b=headB;\\n           while(a!=b)\\n           {\\n               a=a==NULL?headB:a->next;\\n               b=b==NULL?headA:b->next;\\n           }\\n           return a;\\n    }"
                    }
                ]
            },
            {
                "id": 1572102,
                "content": [
                    {
                        "username": "khaled_acmilan",
                        "content": "Hi there,\\n\\nIt seems I couldn\\'t understand the problem since I\\'m looking at the first example : \\n\\nlistA = [4,1,8,4,5], listB = [5,0,1,8,4,5]\\n\\nI thought when we check on both lists, 1 should be the begining of the intersection of these two lists , why 8 is the answer here? I really couldn\\'t understand why 1 is wrong answer here.\\n\\nSo, what I understood is that I need to know the length of both and try to start where I can traverse for both the lists but when I travese I find that 1 is the first element that we will enounter as we traverse that satisfy the condition that listA and listB has this item.\\n\\nCan you please explain me why 1 is wrong and 8 is right?\\n\\nI will appreciate any insights on that problem :) \\n\\nKhaled"
                    },
                    {
                        "username": "XiaojingHu",
                        "content": "Well I see the problem as a variant of the detection of linked cycles. If you redirect the tail of the list to headB, you\\'ll find that the problem becomes finding the intersection of a linked list with cycle. Then use Floyd\\'s Tortoise and Hare algorithm, you can \"easily\" solve the problem. Just to provide another perspective, because my code is messy."
                    },
                    {
                        "username": "dingyuming102",
                        "content": "Romantic two pointers\\n\"If I wander to the end of the world and still cannot find you, I will take another path and search anew.\"\\n\"And I shall do the same, my love.\""
                    },
                    {
                        "username": "deleted_user",
                        "content": "I don\\'t understand this question.\\nI thought the overlapping should be `1` instead of `8`?"
                    },
                    {
                        "username": "anatayo",
                        "content": "Input: \\nintersectVal = 8, \\nlistA = [4,1,8,4,5], \\nlistB = [5,0,1,8,4,5], \\nskipA = 2, \\nskipB = 3\\n\\nWhy not return 1?"
                    },
                    {
                        "username": "sruzic",
                        "content": "1->2->3*->4->5\\n\\n6->7->3*->8->9\\n\\n*same adress"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "in this case listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]\\n\\nit should return 1 right ? because they intersect at 1 but leet code shows 8 ?? leet code \\uD83C\\uDF75"
                    },
                    {
                        "username": "keerthikumar_n",
                        "content": "For me this is not at all a \"EASY\" level problem statement. First of all the explanation above is tricky and baffling. Also, the examples with inputs explained looks HARD to understand !! "
                    },
                    {
                        "username": "gprajwal45",
                        "content": "I am getting TLE for the following code in python, any way to optimize it?\\n       \\n        d1 = headA\\n        d2 = headB\\n\\n        while d1 != d2:\\n            d1 = d1.next\\n            d2 = d2.next\\n\\n            if d1.next == None:\\n                d1 = headB\\n            if d2.next == None:\\n                d2 = headA\\n           \\n        return d1"
                    },
                    {
                        "username": "Kumar__aman1043",
                        "content": "d1 = headA\\n    d2 = headB\\n\\n    while d1 != d2:\\n      \\n        if d1.next == None:\\n            d1 = headB\\n        else \\n           d1 = d1.next\\n        if d2.next == None:\\n            d2 = headA\\n        else \\n           d2 = d2.next\\n       \\n    return d1"
                    },
                    {
                        "username": "chandancp",
                        "content": "verry small and  efficent code \\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n           if(headA==NULL or headB==NULL)\\n           {\\n               return NULL;\\n           }\\n           ListNode*a=headA;\\n           ListNode*b=headB;\\n           while(a!=b)\\n           {\\n               a=a==NULL?headB:a->next;\\n               b=b==NULL?headA:b->next;\\n           }\\n           return a;\\n    }"
                    }
                ]
            },
            {
                "id": 1712054,
                "content": [
                    {
                        "username": "khaled_acmilan",
                        "content": "Hi there,\\n\\nIt seems I couldn\\'t understand the problem since I\\'m looking at the first example : \\n\\nlistA = [4,1,8,4,5], listB = [5,0,1,8,4,5]\\n\\nI thought when we check on both lists, 1 should be the begining of the intersection of these two lists , why 8 is the answer here? I really couldn\\'t understand why 1 is wrong answer here.\\n\\nSo, what I understood is that I need to know the length of both and try to start where I can traverse for both the lists but when I travese I find that 1 is the first element that we will enounter as we traverse that satisfy the condition that listA and listB has this item.\\n\\nCan you please explain me why 1 is wrong and 8 is right?\\n\\nI will appreciate any insights on that problem :) \\n\\nKhaled"
                    },
                    {
                        "username": "XiaojingHu",
                        "content": "Well I see the problem as a variant of the detection of linked cycles. If you redirect the tail of the list to headB, you\\'ll find that the problem becomes finding the intersection of a linked list with cycle. Then use Floyd\\'s Tortoise and Hare algorithm, you can \"easily\" solve the problem. Just to provide another perspective, because my code is messy."
                    },
                    {
                        "username": "dingyuming102",
                        "content": "Romantic two pointers\\n\"If I wander to the end of the world and still cannot find you, I will take another path and search anew.\"\\n\"And I shall do the same, my love.\""
                    },
                    {
                        "username": "deleted_user",
                        "content": "I don\\'t understand this question.\\nI thought the overlapping should be `1` instead of `8`?"
                    },
                    {
                        "username": "anatayo",
                        "content": "Input: \\nintersectVal = 8, \\nlistA = [4,1,8,4,5], \\nlistB = [5,0,1,8,4,5], \\nskipA = 2, \\nskipB = 3\\n\\nWhy not return 1?"
                    },
                    {
                        "username": "sruzic",
                        "content": "1->2->3*->4->5\\n\\n6->7->3*->8->9\\n\\n*same adress"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "in this case listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]\\n\\nit should return 1 right ? because they intersect at 1 but leet code shows 8 ?? leet code \\uD83C\\uDF75"
                    },
                    {
                        "username": "keerthikumar_n",
                        "content": "For me this is not at all a \"EASY\" level problem statement. First of all the explanation above is tricky and baffling. Also, the examples with inputs explained looks HARD to understand !! "
                    },
                    {
                        "username": "gprajwal45",
                        "content": "I am getting TLE for the following code in python, any way to optimize it?\\n       \\n        d1 = headA\\n        d2 = headB\\n\\n        while d1 != d2:\\n            d1 = d1.next\\n            d2 = d2.next\\n\\n            if d1.next == None:\\n                d1 = headB\\n            if d2.next == None:\\n                d2 = headA\\n           \\n        return d1"
                    },
                    {
                        "username": "Kumar__aman1043",
                        "content": "d1 = headA\\n    d2 = headB\\n\\n    while d1 != d2:\\n      \\n        if d1.next == None:\\n            d1 = headB\\n        else \\n           d1 = d1.next\\n        if d2.next == None:\\n            d2 = headA\\n        else \\n           d2 = d2.next\\n       \\n    return d1"
                    },
                    {
                        "username": "chandancp",
                        "content": "verry small and  efficent code \\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n           if(headA==NULL or headB==NULL)\\n           {\\n               return NULL;\\n           }\\n           ListNode*a=headA;\\n           ListNode*b=headB;\\n           while(a!=b)\\n           {\\n               a=a==NULL?headB:a->next;\\n               b=b==NULL?headA:b->next;\\n           }\\n           return a;\\n    }"
                    }
                ]
            },
            {
                "id": 1569790,
                "content": [
                    {
                        "username": "khaled_acmilan",
                        "content": "Hi there,\\n\\nIt seems I couldn\\'t understand the problem since I\\'m looking at the first example : \\n\\nlistA = [4,1,8,4,5], listB = [5,0,1,8,4,5]\\n\\nI thought when we check on both lists, 1 should be the begining of the intersection of these two lists , why 8 is the answer here? I really couldn\\'t understand why 1 is wrong answer here.\\n\\nSo, what I understood is that I need to know the length of both and try to start where I can traverse for both the lists but when I travese I find that 1 is the first element that we will enounter as we traverse that satisfy the condition that listA and listB has this item.\\n\\nCan you please explain me why 1 is wrong and 8 is right?\\n\\nI will appreciate any insights on that problem :) \\n\\nKhaled"
                    },
                    {
                        "username": "XiaojingHu",
                        "content": "Well I see the problem as a variant of the detection of linked cycles. If you redirect the tail of the list to headB, you\\'ll find that the problem becomes finding the intersection of a linked list with cycle. Then use Floyd\\'s Tortoise and Hare algorithm, you can \"easily\" solve the problem. Just to provide another perspective, because my code is messy."
                    },
                    {
                        "username": "dingyuming102",
                        "content": "Romantic two pointers\\n\"If I wander to the end of the world and still cannot find you, I will take another path and search anew.\"\\n\"And I shall do the same, my love.\""
                    },
                    {
                        "username": "deleted_user",
                        "content": "I don\\'t understand this question.\\nI thought the overlapping should be `1` instead of `8`?"
                    },
                    {
                        "username": "anatayo",
                        "content": "Input: \\nintersectVal = 8, \\nlistA = [4,1,8,4,5], \\nlistB = [5,0,1,8,4,5], \\nskipA = 2, \\nskipB = 3\\n\\nWhy not return 1?"
                    },
                    {
                        "username": "sruzic",
                        "content": "1->2->3*->4->5\\n\\n6->7->3*->8->9\\n\\n*same adress"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "in this case listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]\\n\\nit should return 1 right ? because they intersect at 1 but leet code shows 8 ?? leet code \\uD83C\\uDF75"
                    },
                    {
                        "username": "keerthikumar_n",
                        "content": "For me this is not at all a \"EASY\" level problem statement. First of all the explanation above is tricky and baffling. Also, the examples with inputs explained looks HARD to understand !! "
                    },
                    {
                        "username": "gprajwal45",
                        "content": "I am getting TLE for the following code in python, any way to optimize it?\\n       \\n        d1 = headA\\n        d2 = headB\\n\\n        while d1 != d2:\\n            d1 = d1.next\\n            d2 = d2.next\\n\\n            if d1.next == None:\\n                d1 = headB\\n            if d2.next == None:\\n                d2 = headA\\n           \\n        return d1"
                    },
                    {
                        "username": "Kumar__aman1043",
                        "content": "d1 = headA\\n    d2 = headB\\n\\n    while d1 != d2:\\n      \\n        if d1.next == None:\\n            d1 = headB\\n        else \\n           d1 = d1.next\\n        if d2.next == None:\\n            d2 = headA\\n        else \\n           d2 = d2.next\\n       \\n    return d1"
                    },
                    {
                        "username": "chandancp",
                        "content": "verry small and  efficent code \\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n           if(headA==NULL or headB==NULL)\\n           {\\n               return NULL;\\n           }\\n           ListNode*a=headA;\\n           ListNode*b=headB;\\n           while(a!=b)\\n           {\\n               a=a==NULL?headB:a->next;\\n               b=b==NULL?headA:b->next;\\n           }\\n           return a;\\n    }"
                    }
                ]
            },
            {
                "id": 1569595,
                "content": [
                    {
                        "username": "khaled_acmilan",
                        "content": "Hi there,\\n\\nIt seems I couldn\\'t understand the problem since I\\'m looking at the first example : \\n\\nlistA = [4,1,8,4,5], listB = [5,0,1,8,4,5]\\n\\nI thought when we check on both lists, 1 should be the begining of the intersection of these two lists , why 8 is the answer here? I really couldn\\'t understand why 1 is wrong answer here.\\n\\nSo, what I understood is that I need to know the length of both and try to start where I can traverse for both the lists but when I travese I find that 1 is the first element that we will enounter as we traverse that satisfy the condition that listA and listB has this item.\\n\\nCan you please explain me why 1 is wrong and 8 is right?\\n\\nI will appreciate any insights on that problem :) \\n\\nKhaled"
                    },
                    {
                        "username": "XiaojingHu",
                        "content": "Well I see the problem as a variant of the detection of linked cycles. If you redirect the tail of the list to headB, you\\'ll find that the problem becomes finding the intersection of a linked list with cycle. Then use Floyd\\'s Tortoise and Hare algorithm, you can \"easily\" solve the problem. Just to provide another perspective, because my code is messy."
                    },
                    {
                        "username": "dingyuming102",
                        "content": "Romantic two pointers\\n\"If I wander to the end of the world and still cannot find you, I will take another path and search anew.\"\\n\"And I shall do the same, my love.\""
                    },
                    {
                        "username": "deleted_user",
                        "content": "I don\\'t understand this question.\\nI thought the overlapping should be `1` instead of `8`?"
                    },
                    {
                        "username": "anatayo",
                        "content": "Input: \\nintersectVal = 8, \\nlistA = [4,1,8,4,5], \\nlistB = [5,0,1,8,4,5], \\nskipA = 2, \\nskipB = 3\\n\\nWhy not return 1?"
                    },
                    {
                        "username": "sruzic",
                        "content": "1->2->3*->4->5\\n\\n6->7->3*->8->9\\n\\n*same adress"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "in this case listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]\\n\\nit should return 1 right ? because they intersect at 1 but leet code shows 8 ?? leet code \\uD83C\\uDF75"
                    },
                    {
                        "username": "keerthikumar_n",
                        "content": "For me this is not at all a \"EASY\" level problem statement. First of all the explanation above is tricky and baffling. Also, the examples with inputs explained looks HARD to understand !! "
                    },
                    {
                        "username": "gprajwal45",
                        "content": "I am getting TLE for the following code in python, any way to optimize it?\\n       \\n        d1 = headA\\n        d2 = headB\\n\\n        while d1 != d2:\\n            d1 = d1.next\\n            d2 = d2.next\\n\\n            if d1.next == None:\\n                d1 = headB\\n            if d2.next == None:\\n                d2 = headA\\n           \\n        return d1"
                    },
                    {
                        "username": "Kumar__aman1043",
                        "content": "d1 = headA\\n    d2 = headB\\n\\n    while d1 != d2:\\n      \\n        if d1.next == None:\\n            d1 = headB\\n        else \\n           d1 = d1.next\\n        if d2.next == None:\\n            d2 = headA\\n        else \\n           d2 = d2.next\\n       \\n    return d1"
                    },
                    {
                        "username": "chandancp",
                        "content": "verry small and  efficent code \\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n           if(headA==NULL or headB==NULL)\\n           {\\n               return NULL;\\n           }\\n           ListNode*a=headA;\\n           ListNode*b=headB;\\n           while(a!=b)\\n           {\\n               a=a==NULL?headB:a->next;\\n               b=b==NULL?headA:b->next;\\n           }\\n           return a;\\n    }"
                    }
                ]
            },
            {
                "id": 1568989,
                "content": [
                    {
                        "username": "khaled_acmilan",
                        "content": "Hi there,\\n\\nIt seems I couldn\\'t understand the problem since I\\'m looking at the first example : \\n\\nlistA = [4,1,8,4,5], listB = [5,0,1,8,4,5]\\n\\nI thought when we check on both lists, 1 should be the begining of the intersection of these two lists , why 8 is the answer here? I really couldn\\'t understand why 1 is wrong answer here.\\n\\nSo, what I understood is that I need to know the length of both and try to start where I can traverse for both the lists but when I travese I find that 1 is the first element that we will enounter as we traverse that satisfy the condition that listA and listB has this item.\\n\\nCan you please explain me why 1 is wrong and 8 is right?\\n\\nI will appreciate any insights on that problem :) \\n\\nKhaled"
                    },
                    {
                        "username": "XiaojingHu",
                        "content": "Well I see the problem as a variant of the detection of linked cycles. If you redirect the tail of the list to headB, you\\'ll find that the problem becomes finding the intersection of a linked list with cycle. Then use Floyd\\'s Tortoise and Hare algorithm, you can \"easily\" solve the problem. Just to provide another perspective, because my code is messy."
                    },
                    {
                        "username": "dingyuming102",
                        "content": "Romantic two pointers\\n\"If I wander to the end of the world and still cannot find you, I will take another path and search anew.\"\\n\"And I shall do the same, my love.\""
                    },
                    {
                        "username": "deleted_user",
                        "content": "I don\\'t understand this question.\\nI thought the overlapping should be `1` instead of `8`?"
                    },
                    {
                        "username": "anatayo",
                        "content": "Input: \\nintersectVal = 8, \\nlistA = [4,1,8,4,5], \\nlistB = [5,0,1,8,4,5], \\nskipA = 2, \\nskipB = 3\\n\\nWhy not return 1?"
                    },
                    {
                        "username": "sruzic",
                        "content": "1->2->3*->4->5\\n\\n6->7->3*->8->9\\n\\n*same adress"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "in this case listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]\\n\\nit should return 1 right ? because they intersect at 1 but leet code shows 8 ?? leet code \\uD83C\\uDF75"
                    },
                    {
                        "username": "keerthikumar_n",
                        "content": "For me this is not at all a \"EASY\" level problem statement. First of all the explanation above is tricky and baffling. Also, the examples with inputs explained looks HARD to understand !! "
                    },
                    {
                        "username": "gprajwal45",
                        "content": "I am getting TLE for the following code in python, any way to optimize it?\\n       \\n        d1 = headA\\n        d2 = headB\\n\\n        while d1 != d2:\\n            d1 = d1.next\\n            d2 = d2.next\\n\\n            if d1.next == None:\\n                d1 = headB\\n            if d2.next == None:\\n                d2 = headA\\n           \\n        return d1"
                    },
                    {
                        "username": "Kumar__aman1043",
                        "content": "d1 = headA\\n    d2 = headB\\n\\n    while d1 != d2:\\n      \\n        if d1.next == None:\\n            d1 = headB\\n        else \\n           d1 = d1.next\\n        if d2.next == None:\\n            d2 = headA\\n        else \\n           d2 = d2.next\\n       \\n    return d1"
                    },
                    {
                        "username": "chandancp",
                        "content": "verry small and  efficent code \\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n           if(headA==NULL or headB==NULL)\\n           {\\n               return NULL;\\n           }\\n           ListNode*a=headA;\\n           ListNode*b=headB;\\n           while(a!=b)\\n           {\\n               a=a==NULL?headB:a->next;\\n               b=b==NULL?headA:b->next;\\n           }\\n           return a;\\n    }"
                    }
                ]
            },
            {
                "id": 2010947,
                "content": [
                    {
                        "username": "khaled_acmilan",
                        "content": "Hi there,\\n\\nIt seems I couldn\\'t understand the problem since I\\'m looking at the first example : \\n\\nlistA = [4,1,8,4,5], listB = [5,0,1,8,4,5]\\n\\nI thought when we check on both lists, 1 should be the begining of the intersection of these two lists , why 8 is the answer here? I really couldn\\'t understand why 1 is wrong answer here.\\n\\nSo, what I understood is that I need to know the length of both and try to start where I can traverse for both the lists but when I travese I find that 1 is the first element that we will enounter as we traverse that satisfy the condition that listA and listB has this item.\\n\\nCan you please explain me why 1 is wrong and 8 is right?\\n\\nI will appreciate any insights on that problem :) \\n\\nKhaled"
                    },
                    {
                        "username": "XiaojingHu",
                        "content": "Well I see the problem as a variant of the detection of linked cycles. If you redirect the tail of the list to headB, you\\'ll find that the problem becomes finding the intersection of a linked list with cycle. Then use Floyd\\'s Tortoise and Hare algorithm, you can \"easily\" solve the problem. Just to provide another perspective, because my code is messy."
                    },
                    {
                        "username": "dingyuming102",
                        "content": "Romantic two pointers\\n\"If I wander to the end of the world and still cannot find you, I will take another path and search anew.\"\\n\"And I shall do the same, my love.\""
                    },
                    {
                        "username": "deleted_user",
                        "content": "I don\\'t understand this question.\\nI thought the overlapping should be `1` instead of `8`?"
                    },
                    {
                        "username": "anatayo",
                        "content": "Input: \\nintersectVal = 8, \\nlistA = [4,1,8,4,5], \\nlistB = [5,0,1,8,4,5], \\nskipA = 2, \\nskipB = 3\\n\\nWhy not return 1?"
                    },
                    {
                        "username": "sruzic",
                        "content": "1->2->3*->4->5\\n\\n6->7->3*->8->9\\n\\n*same adress"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "in this case listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]\\n\\nit should return 1 right ? because they intersect at 1 but leet code shows 8 ?? leet code \\uD83C\\uDF75"
                    },
                    {
                        "username": "keerthikumar_n",
                        "content": "For me this is not at all a \"EASY\" level problem statement. First of all the explanation above is tricky and baffling. Also, the examples with inputs explained looks HARD to understand !! "
                    },
                    {
                        "username": "gprajwal45",
                        "content": "I am getting TLE for the following code in python, any way to optimize it?\\n       \\n        d1 = headA\\n        d2 = headB\\n\\n        while d1 != d2:\\n            d1 = d1.next\\n            d2 = d2.next\\n\\n            if d1.next == None:\\n                d1 = headB\\n            if d2.next == None:\\n                d2 = headA\\n           \\n        return d1"
                    },
                    {
                        "username": "Kumar__aman1043",
                        "content": "d1 = headA\\n    d2 = headB\\n\\n    while d1 != d2:\\n      \\n        if d1.next == None:\\n            d1 = headB\\n        else \\n           d1 = d1.next\\n        if d2.next == None:\\n            d2 = headA\\n        else \\n           d2 = d2.next\\n       \\n    return d1"
                    },
                    {
                        "username": "chandancp",
                        "content": "verry small and  efficent code \\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n           if(headA==NULL or headB==NULL)\\n           {\\n               return NULL;\\n           }\\n           ListNode*a=headA;\\n           ListNode*b=headB;\\n           while(a!=b)\\n           {\\n               a=a==NULL?headB:a->next;\\n               b=b==NULL?headA:b->next;\\n           }\\n           return a;\\n    }"
                    }
                ]
            },
            {
                "id": 1950775,
                "content": [
                    {
                        "username": "khaled_acmilan",
                        "content": "Hi there,\\n\\nIt seems I couldn\\'t understand the problem since I\\'m looking at the first example : \\n\\nlistA = [4,1,8,4,5], listB = [5,0,1,8,4,5]\\n\\nI thought when we check on both lists, 1 should be the begining of the intersection of these two lists , why 8 is the answer here? I really couldn\\'t understand why 1 is wrong answer here.\\n\\nSo, what I understood is that I need to know the length of both and try to start where I can traverse for both the lists but when I travese I find that 1 is the first element that we will enounter as we traverse that satisfy the condition that listA and listB has this item.\\n\\nCan you please explain me why 1 is wrong and 8 is right?\\n\\nI will appreciate any insights on that problem :) \\n\\nKhaled"
                    },
                    {
                        "username": "XiaojingHu",
                        "content": "Well I see the problem as a variant of the detection of linked cycles. If you redirect the tail of the list to headB, you\\'ll find that the problem becomes finding the intersection of a linked list with cycle. Then use Floyd\\'s Tortoise and Hare algorithm, you can \"easily\" solve the problem. Just to provide another perspective, because my code is messy."
                    },
                    {
                        "username": "dingyuming102",
                        "content": "Romantic two pointers\\n\"If I wander to the end of the world and still cannot find you, I will take another path and search anew.\"\\n\"And I shall do the same, my love.\""
                    },
                    {
                        "username": "deleted_user",
                        "content": "I don\\'t understand this question.\\nI thought the overlapping should be `1` instead of `8`?"
                    },
                    {
                        "username": "anatayo",
                        "content": "Input: \\nintersectVal = 8, \\nlistA = [4,1,8,4,5], \\nlistB = [5,0,1,8,4,5], \\nskipA = 2, \\nskipB = 3\\n\\nWhy not return 1?"
                    },
                    {
                        "username": "sruzic",
                        "content": "1->2->3*->4->5\\n\\n6->7->3*->8->9\\n\\n*same adress"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "in this case listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]\\n\\nit should return 1 right ? because they intersect at 1 but leet code shows 8 ?? leet code \\uD83C\\uDF75"
                    },
                    {
                        "username": "keerthikumar_n",
                        "content": "For me this is not at all a \"EASY\" level problem statement. First of all the explanation above is tricky and baffling. Also, the examples with inputs explained looks HARD to understand !! "
                    },
                    {
                        "username": "gprajwal45",
                        "content": "I am getting TLE for the following code in python, any way to optimize it?\\n       \\n        d1 = headA\\n        d2 = headB\\n\\n        while d1 != d2:\\n            d1 = d1.next\\n            d2 = d2.next\\n\\n            if d1.next == None:\\n                d1 = headB\\n            if d2.next == None:\\n                d2 = headA\\n           \\n        return d1"
                    },
                    {
                        "username": "Kumar__aman1043",
                        "content": "d1 = headA\\n    d2 = headB\\n\\n    while d1 != d2:\\n      \\n        if d1.next == None:\\n            d1 = headB\\n        else \\n           d1 = d1.next\\n        if d2.next == None:\\n            d2 = headA\\n        else \\n           d2 = d2.next\\n       \\n    return d1"
                    },
                    {
                        "username": "chandancp",
                        "content": "verry small and  efficent code \\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n           if(headA==NULL or headB==NULL)\\n           {\\n               return NULL;\\n           }\\n           ListNode*a=headA;\\n           ListNode*b=headB;\\n           while(a!=b)\\n           {\\n               a=a==NULL?headB:a->next;\\n               b=b==NULL?headA:b->next;\\n           }\\n           return a;\\n    }"
                    }
                ]
            },
            {
                "id": 1823033,
                "content": [
                    {
                        "username": "khaled_acmilan",
                        "content": "Hi there,\\n\\nIt seems I couldn\\'t understand the problem since I\\'m looking at the first example : \\n\\nlistA = [4,1,8,4,5], listB = [5,0,1,8,4,5]\\n\\nI thought when we check on both lists, 1 should be the begining of the intersection of these two lists , why 8 is the answer here? I really couldn\\'t understand why 1 is wrong answer here.\\n\\nSo, what I understood is that I need to know the length of both and try to start where I can traverse for both the lists but when I travese I find that 1 is the first element that we will enounter as we traverse that satisfy the condition that listA and listB has this item.\\n\\nCan you please explain me why 1 is wrong and 8 is right?\\n\\nI will appreciate any insights on that problem :) \\n\\nKhaled"
                    },
                    {
                        "username": "XiaojingHu",
                        "content": "Well I see the problem as a variant of the detection of linked cycles. If you redirect the tail of the list to headB, you\\'ll find that the problem becomes finding the intersection of a linked list with cycle. Then use Floyd\\'s Tortoise and Hare algorithm, you can \"easily\" solve the problem. Just to provide another perspective, because my code is messy."
                    },
                    {
                        "username": "dingyuming102",
                        "content": "Romantic two pointers\\n\"If I wander to the end of the world and still cannot find you, I will take another path and search anew.\"\\n\"And I shall do the same, my love.\""
                    },
                    {
                        "username": "deleted_user",
                        "content": "I don\\'t understand this question.\\nI thought the overlapping should be `1` instead of `8`?"
                    },
                    {
                        "username": "anatayo",
                        "content": "Input: \\nintersectVal = 8, \\nlistA = [4,1,8,4,5], \\nlistB = [5,0,1,8,4,5], \\nskipA = 2, \\nskipB = 3\\n\\nWhy not return 1?"
                    },
                    {
                        "username": "sruzic",
                        "content": "1->2->3*->4->5\\n\\n6->7->3*->8->9\\n\\n*same adress"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "in this case listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]\\n\\nit should return 1 right ? because they intersect at 1 but leet code shows 8 ?? leet code \\uD83C\\uDF75"
                    },
                    {
                        "username": "keerthikumar_n",
                        "content": "For me this is not at all a \"EASY\" level problem statement. First of all the explanation above is tricky and baffling. Also, the examples with inputs explained looks HARD to understand !! "
                    },
                    {
                        "username": "gprajwal45",
                        "content": "I am getting TLE for the following code in python, any way to optimize it?\\n       \\n        d1 = headA\\n        d2 = headB\\n\\n        while d1 != d2:\\n            d1 = d1.next\\n            d2 = d2.next\\n\\n            if d1.next == None:\\n                d1 = headB\\n            if d2.next == None:\\n                d2 = headA\\n           \\n        return d1"
                    },
                    {
                        "username": "Kumar__aman1043",
                        "content": "d1 = headA\\n    d2 = headB\\n\\n    while d1 != d2:\\n      \\n        if d1.next == None:\\n            d1 = headB\\n        else \\n           d1 = d1.next\\n        if d2.next == None:\\n            d2 = headA\\n        else \\n           d2 = d2.next\\n       \\n    return d1"
                    },
                    {
                        "username": "chandancp",
                        "content": "verry small and  efficent code \\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n           if(headA==NULL or headB==NULL)\\n           {\\n               return NULL;\\n           }\\n           ListNode*a=headA;\\n           ListNode*b=headB;\\n           while(a!=b)\\n           {\\n               a=a==NULL?headB:a->next;\\n               b=b==NULL?headA:b->next;\\n           }\\n           return a;\\n    }"
                    }
                ]
            },
            {
                "id": 1728584,
                "content": [
                    {
                        "username": "khaled_acmilan",
                        "content": "Hi there,\\n\\nIt seems I couldn\\'t understand the problem since I\\'m looking at the first example : \\n\\nlistA = [4,1,8,4,5], listB = [5,0,1,8,4,5]\\n\\nI thought when we check on both lists, 1 should be the begining of the intersection of these two lists , why 8 is the answer here? I really couldn\\'t understand why 1 is wrong answer here.\\n\\nSo, what I understood is that I need to know the length of both and try to start where I can traverse for both the lists but when I travese I find that 1 is the first element that we will enounter as we traverse that satisfy the condition that listA and listB has this item.\\n\\nCan you please explain me why 1 is wrong and 8 is right?\\n\\nI will appreciate any insights on that problem :) \\n\\nKhaled"
                    },
                    {
                        "username": "XiaojingHu",
                        "content": "Well I see the problem as a variant of the detection of linked cycles. If you redirect the tail of the list to headB, you\\'ll find that the problem becomes finding the intersection of a linked list with cycle. Then use Floyd\\'s Tortoise and Hare algorithm, you can \"easily\" solve the problem. Just to provide another perspective, because my code is messy."
                    },
                    {
                        "username": "dingyuming102",
                        "content": "Romantic two pointers\\n\"If I wander to the end of the world and still cannot find you, I will take another path and search anew.\"\\n\"And I shall do the same, my love.\""
                    },
                    {
                        "username": "deleted_user",
                        "content": "I don\\'t understand this question.\\nI thought the overlapping should be `1` instead of `8`?"
                    },
                    {
                        "username": "anatayo",
                        "content": "Input: \\nintersectVal = 8, \\nlistA = [4,1,8,4,5], \\nlistB = [5,0,1,8,4,5], \\nskipA = 2, \\nskipB = 3\\n\\nWhy not return 1?"
                    },
                    {
                        "username": "sruzic",
                        "content": "1->2->3*->4->5\\n\\n6->7->3*->8->9\\n\\n*same adress"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "in this case listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]\\n\\nit should return 1 right ? because they intersect at 1 but leet code shows 8 ?? leet code \\uD83C\\uDF75"
                    },
                    {
                        "username": "keerthikumar_n",
                        "content": "For me this is not at all a \"EASY\" level problem statement. First of all the explanation above is tricky and baffling. Also, the examples with inputs explained looks HARD to understand !! "
                    },
                    {
                        "username": "gprajwal45",
                        "content": "I am getting TLE for the following code in python, any way to optimize it?\\n       \\n        d1 = headA\\n        d2 = headB\\n\\n        while d1 != d2:\\n            d1 = d1.next\\n            d2 = d2.next\\n\\n            if d1.next == None:\\n                d1 = headB\\n            if d2.next == None:\\n                d2 = headA\\n           \\n        return d1"
                    },
                    {
                        "username": "Kumar__aman1043",
                        "content": "d1 = headA\\n    d2 = headB\\n\\n    while d1 != d2:\\n      \\n        if d1.next == None:\\n            d1 = headB\\n        else \\n           d1 = d1.next\\n        if d2.next == None:\\n            d2 = headA\\n        else \\n           d2 = d2.next\\n       \\n    return d1"
                    },
                    {
                        "username": "chandancp",
                        "content": "verry small and  efficent code \\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n           if(headA==NULL or headB==NULL)\\n           {\\n               return NULL;\\n           }\\n           ListNode*a=headA;\\n           ListNode*b=headB;\\n           while(a!=b)\\n           {\\n               a=a==NULL?headB:a->next;\\n               b=b==NULL?headA:b->next;\\n           }\\n           return a;\\n    }"
                    }
                ]
            },
            {
                "id": 1576458,
                "content": [
                    {
                        "username": "humanparadox",
                        "content": "Since the similarity begins from the \\'1\\' node, why is the \\'8\\' node the beginning of the intersection?"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Since there may be an intersection, so after the longer list first moves forward diff (len_long - len_short) steps, two lists are going to meet at the intersection simultaneously."
                    },
                    {
                        "username": "mshiladityam",
                        "content": "Once you traverse listA, just add INF=1e6 to all nodes.\\nThen once you traverse listB, return first node which has value greater than INF!\\ndone! LOL"
                    },
                    {
                        "username": "lreynl",
                        "content": "By \\'intersection\\' it means finding nodes which are the same object, not nodes with the same value. The variables `intersectVal`, `skipA` and `skipB` aren\\'t used in the code and are a distraction."
                    },
                    {
                        "username": "prialmeida",
                        "content": "I don\\'t understand example 1 it shows that it should return 8 -> 4 -> 5\\nHowever, the intersection starts at 1. I am getting my code wrong because of that. Mine returns the intersection on 1 but the system is expecting to return on 8, but I believe should be 1.\\nCan anyone explain why should be at 8? Thank you"
                    },
                    {
                        "username": "291831388",
                        "content": "if  I have two lists 2->2->3->3 and 3->3->2->2. How to decide the value of the return list node?"
                    },
                    {
                        "username": "Nt_cy",
                        "content": "Does the intersection of linked list need to be in some kind of same position? Why those AC solutions cut two list to same length first? If list A is a1,a2,a3,c1,c2,a4, while list B is a1,b2,b3,c1,c2, what is the answer? Based on the definition of intersection, it should be a1,c1,c2 and the begin is a1. That's not the answer of the length solution. Can anyone explain that to me? thanks."
                    },
                    {
                        "username": "Samsonjy",
                        "content": "![image](https://assets.leetcode.com/users/images/db298722-4503-4584-bb55-0cc1dd768a7f_1646960379.894478.jpeg)\\n"
                    },
                    {
                        "username": "midhunsubramania",
                        "content": "![image](https://assets.leetcode.com/users/images/65b407c9-322b-47c1-880b-f0e083063f0e_1612082575.8719997.png)\\n The intersection point should be 1 but 8 is said to be the intersection point.\\n how can it be possible??\\n \\n"
                    },
                    {
                        "username": "nitin135",
                        "content": "Why there is no \\'Run Code\\' button in this problem"
                    }
                ]
            },
            {
                "id": 1575715,
                "content": [
                    {
                        "username": "humanparadox",
                        "content": "Since the similarity begins from the \\'1\\' node, why is the \\'8\\' node the beginning of the intersection?"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Since there may be an intersection, so after the longer list first moves forward diff (len_long - len_short) steps, two lists are going to meet at the intersection simultaneously."
                    },
                    {
                        "username": "mshiladityam",
                        "content": "Once you traverse listA, just add INF=1e6 to all nodes.\\nThen once you traverse listB, return first node which has value greater than INF!\\ndone! LOL"
                    },
                    {
                        "username": "lreynl",
                        "content": "By \\'intersection\\' it means finding nodes which are the same object, not nodes with the same value. The variables `intersectVal`, `skipA` and `skipB` aren\\'t used in the code and are a distraction."
                    },
                    {
                        "username": "prialmeida",
                        "content": "I don\\'t understand example 1 it shows that it should return 8 -> 4 -> 5\\nHowever, the intersection starts at 1. I am getting my code wrong because of that. Mine returns the intersection on 1 but the system is expecting to return on 8, but I believe should be 1.\\nCan anyone explain why should be at 8? Thank you"
                    },
                    {
                        "username": "291831388",
                        "content": "if  I have two lists 2->2->3->3 and 3->3->2->2. How to decide the value of the return list node?"
                    },
                    {
                        "username": "Nt_cy",
                        "content": "Does the intersection of linked list need to be in some kind of same position? Why those AC solutions cut two list to same length first? If list A is a1,a2,a3,c1,c2,a4, while list B is a1,b2,b3,c1,c2, what is the answer? Based on the definition of intersection, it should be a1,c1,c2 and the begin is a1. That's not the answer of the length solution. Can anyone explain that to me? thanks."
                    },
                    {
                        "username": "Samsonjy",
                        "content": "![image](https://assets.leetcode.com/users/images/db298722-4503-4584-bb55-0cc1dd768a7f_1646960379.894478.jpeg)\\n"
                    },
                    {
                        "username": "midhunsubramania",
                        "content": "![image](https://assets.leetcode.com/users/images/65b407c9-322b-47c1-880b-f0e083063f0e_1612082575.8719997.png)\\n The intersection point should be 1 but 8 is said to be the intersection point.\\n how can it be possible??\\n \\n"
                    },
                    {
                        "username": "nitin135",
                        "content": "Why there is no \\'Run Code\\' button in this problem"
                    }
                ]
            },
            {
                "id": 1575609,
                "content": [
                    {
                        "username": "humanparadox",
                        "content": "Since the similarity begins from the \\'1\\' node, why is the \\'8\\' node the beginning of the intersection?"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Since there may be an intersection, so after the longer list first moves forward diff (len_long - len_short) steps, two lists are going to meet at the intersection simultaneously."
                    },
                    {
                        "username": "mshiladityam",
                        "content": "Once you traverse listA, just add INF=1e6 to all nodes.\\nThen once you traverse listB, return first node which has value greater than INF!\\ndone! LOL"
                    },
                    {
                        "username": "lreynl",
                        "content": "By \\'intersection\\' it means finding nodes which are the same object, not nodes with the same value. The variables `intersectVal`, `skipA` and `skipB` aren\\'t used in the code and are a distraction."
                    },
                    {
                        "username": "prialmeida",
                        "content": "I don\\'t understand example 1 it shows that it should return 8 -> 4 -> 5\\nHowever, the intersection starts at 1. I am getting my code wrong because of that. Mine returns the intersection on 1 but the system is expecting to return on 8, but I believe should be 1.\\nCan anyone explain why should be at 8? Thank you"
                    },
                    {
                        "username": "291831388",
                        "content": "if  I have two lists 2->2->3->3 and 3->3->2->2. How to decide the value of the return list node?"
                    },
                    {
                        "username": "Nt_cy",
                        "content": "Does the intersection of linked list need to be in some kind of same position? Why those AC solutions cut two list to same length first? If list A is a1,a2,a3,c1,c2,a4, while list B is a1,b2,b3,c1,c2, what is the answer? Based on the definition of intersection, it should be a1,c1,c2 and the begin is a1. That's not the answer of the length solution. Can anyone explain that to me? thanks."
                    },
                    {
                        "username": "Samsonjy",
                        "content": "![image](https://assets.leetcode.com/users/images/db298722-4503-4584-bb55-0cc1dd768a7f_1646960379.894478.jpeg)\\n"
                    },
                    {
                        "username": "midhunsubramania",
                        "content": "![image](https://assets.leetcode.com/users/images/65b407c9-322b-47c1-880b-f0e083063f0e_1612082575.8719997.png)\\n The intersection point should be 1 but 8 is said to be the intersection point.\\n how can it be possible??\\n \\n"
                    },
                    {
                        "username": "nitin135",
                        "content": "Why there is no \\'Run Code\\' button in this problem"
                    }
                ]
            },
            {
                "id": 1574827,
                "content": [
                    {
                        "username": "humanparadox",
                        "content": "Since the similarity begins from the \\'1\\' node, why is the \\'8\\' node the beginning of the intersection?"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Since there may be an intersection, so after the longer list first moves forward diff (len_long - len_short) steps, two lists are going to meet at the intersection simultaneously."
                    },
                    {
                        "username": "mshiladityam",
                        "content": "Once you traverse listA, just add INF=1e6 to all nodes.\\nThen once you traverse listB, return first node which has value greater than INF!\\ndone! LOL"
                    },
                    {
                        "username": "lreynl",
                        "content": "By \\'intersection\\' it means finding nodes which are the same object, not nodes with the same value. The variables `intersectVal`, `skipA` and `skipB` aren\\'t used in the code and are a distraction."
                    },
                    {
                        "username": "prialmeida",
                        "content": "I don\\'t understand example 1 it shows that it should return 8 -> 4 -> 5\\nHowever, the intersection starts at 1. I am getting my code wrong because of that. Mine returns the intersection on 1 but the system is expecting to return on 8, but I believe should be 1.\\nCan anyone explain why should be at 8? Thank you"
                    },
                    {
                        "username": "291831388",
                        "content": "if  I have two lists 2->2->3->3 and 3->3->2->2. How to decide the value of the return list node?"
                    },
                    {
                        "username": "Nt_cy",
                        "content": "Does the intersection of linked list need to be in some kind of same position? Why those AC solutions cut two list to same length first? If list A is a1,a2,a3,c1,c2,a4, while list B is a1,b2,b3,c1,c2, what is the answer? Based on the definition of intersection, it should be a1,c1,c2 and the begin is a1. That's not the answer of the length solution. Can anyone explain that to me? thanks."
                    },
                    {
                        "username": "Samsonjy",
                        "content": "![image](https://assets.leetcode.com/users/images/db298722-4503-4584-bb55-0cc1dd768a7f_1646960379.894478.jpeg)\\n"
                    },
                    {
                        "username": "midhunsubramania",
                        "content": "![image](https://assets.leetcode.com/users/images/65b407c9-322b-47c1-880b-f0e083063f0e_1612082575.8719997.png)\\n The intersection point should be 1 but 8 is said to be the intersection point.\\n how can it be possible??\\n \\n"
                    },
                    {
                        "username": "nitin135",
                        "content": "Why there is no \\'Run Code\\' button in this problem"
                    }
                ]
            },
            {
                "id": 1574623,
                "content": [
                    {
                        "username": "humanparadox",
                        "content": "Since the similarity begins from the \\'1\\' node, why is the \\'8\\' node the beginning of the intersection?"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Since there may be an intersection, so after the longer list first moves forward diff (len_long - len_short) steps, two lists are going to meet at the intersection simultaneously."
                    },
                    {
                        "username": "mshiladityam",
                        "content": "Once you traverse listA, just add INF=1e6 to all nodes.\\nThen once you traverse listB, return first node which has value greater than INF!\\ndone! LOL"
                    },
                    {
                        "username": "lreynl",
                        "content": "By \\'intersection\\' it means finding nodes which are the same object, not nodes with the same value. The variables `intersectVal`, `skipA` and `skipB` aren\\'t used in the code and are a distraction."
                    },
                    {
                        "username": "prialmeida",
                        "content": "I don\\'t understand example 1 it shows that it should return 8 -> 4 -> 5\\nHowever, the intersection starts at 1. I am getting my code wrong because of that. Mine returns the intersection on 1 but the system is expecting to return on 8, but I believe should be 1.\\nCan anyone explain why should be at 8? Thank you"
                    },
                    {
                        "username": "291831388",
                        "content": "if  I have two lists 2->2->3->3 and 3->3->2->2. How to decide the value of the return list node?"
                    },
                    {
                        "username": "Nt_cy",
                        "content": "Does the intersection of linked list need to be in some kind of same position? Why those AC solutions cut two list to same length first? If list A is a1,a2,a3,c1,c2,a4, while list B is a1,b2,b3,c1,c2, what is the answer? Based on the definition of intersection, it should be a1,c1,c2 and the begin is a1. That's not the answer of the length solution. Can anyone explain that to me? thanks."
                    },
                    {
                        "username": "Samsonjy",
                        "content": "![image](https://assets.leetcode.com/users/images/db298722-4503-4584-bb55-0cc1dd768a7f_1646960379.894478.jpeg)\\n"
                    },
                    {
                        "username": "midhunsubramania",
                        "content": "![image](https://assets.leetcode.com/users/images/65b407c9-322b-47c1-880b-f0e083063f0e_1612082575.8719997.png)\\n The intersection point should be 1 but 8 is said to be the intersection point.\\n how can it be possible??\\n \\n"
                    },
                    {
                        "username": "nitin135",
                        "content": "Why there is no \\'Run Code\\' button in this problem"
                    }
                ]
            },
            {
                "id": 1571350,
                "content": [
                    {
                        "username": "humanparadox",
                        "content": "Since the similarity begins from the \\'1\\' node, why is the \\'8\\' node the beginning of the intersection?"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Since there may be an intersection, so after the longer list first moves forward diff (len_long - len_short) steps, two lists are going to meet at the intersection simultaneously."
                    },
                    {
                        "username": "mshiladityam",
                        "content": "Once you traverse listA, just add INF=1e6 to all nodes.\\nThen once you traverse listB, return first node which has value greater than INF!\\ndone! LOL"
                    },
                    {
                        "username": "lreynl",
                        "content": "By \\'intersection\\' it means finding nodes which are the same object, not nodes with the same value. The variables `intersectVal`, `skipA` and `skipB` aren\\'t used in the code and are a distraction."
                    },
                    {
                        "username": "prialmeida",
                        "content": "I don\\'t understand example 1 it shows that it should return 8 -> 4 -> 5\\nHowever, the intersection starts at 1. I am getting my code wrong because of that. Mine returns the intersection on 1 but the system is expecting to return on 8, but I believe should be 1.\\nCan anyone explain why should be at 8? Thank you"
                    },
                    {
                        "username": "291831388",
                        "content": "if  I have two lists 2->2->3->3 and 3->3->2->2. How to decide the value of the return list node?"
                    },
                    {
                        "username": "Nt_cy",
                        "content": "Does the intersection of linked list need to be in some kind of same position? Why those AC solutions cut two list to same length first? If list A is a1,a2,a3,c1,c2,a4, while list B is a1,b2,b3,c1,c2, what is the answer? Based on the definition of intersection, it should be a1,c1,c2 and the begin is a1. That's not the answer of the length solution. Can anyone explain that to me? thanks."
                    },
                    {
                        "username": "Samsonjy",
                        "content": "![image](https://assets.leetcode.com/users/images/db298722-4503-4584-bb55-0cc1dd768a7f_1646960379.894478.jpeg)\\n"
                    },
                    {
                        "username": "midhunsubramania",
                        "content": "![image](https://assets.leetcode.com/users/images/65b407c9-322b-47c1-880b-f0e083063f0e_1612082575.8719997.png)\\n The intersection point should be 1 but 8 is said to be the intersection point.\\n how can it be possible??\\n \\n"
                    },
                    {
                        "username": "nitin135",
                        "content": "Why there is no \\'Run Code\\' button in this problem"
                    }
                ]
            },
            {
                "id": 1571351,
                "content": [
                    {
                        "username": "humanparadox",
                        "content": "Since the similarity begins from the \\'1\\' node, why is the \\'8\\' node the beginning of the intersection?"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Since there may be an intersection, so after the longer list first moves forward diff (len_long - len_short) steps, two lists are going to meet at the intersection simultaneously."
                    },
                    {
                        "username": "mshiladityam",
                        "content": "Once you traverse listA, just add INF=1e6 to all nodes.\\nThen once you traverse listB, return first node which has value greater than INF!\\ndone! LOL"
                    },
                    {
                        "username": "lreynl",
                        "content": "By \\'intersection\\' it means finding nodes which are the same object, not nodes with the same value. The variables `intersectVal`, `skipA` and `skipB` aren\\'t used in the code and are a distraction."
                    },
                    {
                        "username": "prialmeida",
                        "content": "I don\\'t understand example 1 it shows that it should return 8 -> 4 -> 5\\nHowever, the intersection starts at 1. I am getting my code wrong because of that. Mine returns the intersection on 1 but the system is expecting to return on 8, but I believe should be 1.\\nCan anyone explain why should be at 8? Thank you"
                    },
                    {
                        "username": "291831388",
                        "content": "if  I have two lists 2->2->3->3 and 3->3->2->2. How to decide the value of the return list node?"
                    },
                    {
                        "username": "Nt_cy",
                        "content": "Does the intersection of linked list need to be in some kind of same position? Why those AC solutions cut two list to same length first? If list A is a1,a2,a3,c1,c2,a4, while list B is a1,b2,b3,c1,c2, what is the answer? Based on the definition of intersection, it should be a1,c1,c2 and the begin is a1. That's not the answer of the length solution. Can anyone explain that to me? thanks."
                    },
                    {
                        "username": "Samsonjy",
                        "content": "![image](https://assets.leetcode.com/users/images/db298722-4503-4584-bb55-0cc1dd768a7f_1646960379.894478.jpeg)\\n"
                    },
                    {
                        "username": "midhunsubramania",
                        "content": "![image](https://assets.leetcode.com/users/images/65b407c9-322b-47c1-880b-f0e083063f0e_1612082575.8719997.png)\\n The intersection point should be 1 but 8 is said to be the intersection point.\\n how can it be possible??\\n \\n"
                    },
                    {
                        "username": "nitin135",
                        "content": "Why there is no \\'Run Code\\' button in this problem"
                    }
                ]
            },
            {
                "id": 1576493,
                "content": [
                    {
                        "username": "humanparadox",
                        "content": "Since the similarity begins from the \\'1\\' node, why is the \\'8\\' node the beginning of the intersection?"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Since there may be an intersection, so after the longer list first moves forward diff (len_long - len_short) steps, two lists are going to meet at the intersection simultaneously."
                    },
                    {
                        "username": "mshiladityam",
                        "content": "Once you traverse listA, just add INF=1e6 to all nodes.\\nThen once you traverse listB, return first node which has value greater than INF!\\ndone! LOL"
                    },
                    {
                        "username": "lreynl",
                        "content": "By \\'intersection\\' it means finding nodes which are the same object, not nodes with the same value. The variables `intersectVal`, `skipA` and `skipB` aren\\'t used in the code and are a distraction."
                    },
                    {
                        "username": "prialmeida",
                        "content": "I don\\'t understand example 1 it shows that it should return 8 -> 4 -> 5\\nHowever, the intersection starts at 1. I am getting my code wrong because of that. Mine returns the intersection on 1 but the system is expecting to return on 8, but I believe should be 1.\\nCan anyone explain why should be at 8? Thank you"
                    },
                    {
                        "username": "291831388",
                        "content": "if  I have two lists 2->2->3->3 and 3->3->2->2. How to decide the value of the return list node?"
                    },
                    {
                        "username": "Nt_cy",
                        "content": "Does the intersection of linked list need to be in some kind of same position? Why those AC solutions cut two list to same length first? If list A is a1,a2,a3,c1,c2,a4, while list B is a1,b2,b3,c1,c2, what is the answer? Based on the definition of intersection, it should be a1,c1,c2 and the begin is a1. That's not the answer of the length solution. Can anyone explain that to me? thanks."
                    },
                    {
                        "username": "Samsonjy",
                        "content": "![image](https://assets.leetcode.com/users/images/db298722-4503-4584-bb55-0cc1dd768a7f_1646960379.894478.jpeg)\\n"
                    },
                    {
                        "username": "midhunsubramania",
                        "content": "![image](https://assets.leetcode.com/users/images/65b407c9-322b-47c1-880b-f0e083063f0e_1612082575.8719997.png)\\n The intersection point should be 1 but 8 is said to be the intersection point.\\n how can it be possible??\\n \\n"
                    },
                    {
                        "username": "nitin135",
                        "content": "Why there is no \\'Run Code\\' button in this problem"
                    }
                ]
            },
            {
                "id": 1570314,
                "content": [
                    {
                        "username": "humanparadox",
                        "content": "Since the similarity begins from the \\'1\\' node, why is the \\'8\\' node the beginning of the intersection?"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Since there may be an intersection, so after the longer list first moves forward diff (len_long - len_short) steps, two lists are going to meet at the intersection simultaneously."
                    },
                    {
                        "username": "mshiladityam",
                        "content": "Once you traverse listA, just add INF=1e6 to all nodes.\\nThen once you traverse listB, return first node which has value greater than INF!\\ndone! LOL"
                    },
                    {
                        "username": "lreynl",
                        "content": "By \\'intersection\\' it means finding nodes which are the same object, not nodes with the same value. The variables `intersectVal`, `skipA` and `skipB` aren\\'t used in the code and are a distraction."
                    },
                    {
                        "username": "prialmeida",
                        "content": "I don\\'t understand example 1 it shows that it should return 8 -> 4 -> 5\\nHowever, the intersection starts at 1. I am getting my code wrong because of that. Mine returns the intersection on 1 but the system is expecting to return on 8, but I believe should be 1.\\nCan anyone explain why should be at 8? Thank you"
                    },
                    {
                        "username": "291831388",
                        "content": "if  I have two lists 2->2->3->3 and 3->3->2->2. How to decide the value of the return list node?"
                    },
                    {
                        "username": "Nt_cy",
                        "content": "Does the intersection of linked list need to be in some kind of same position? Why those AC solutions cut two list to same length first? If list A is a1,a2,a3,c1,c2,a4, while list B is a1,b2,b3,c1,c2, what is the answer? Based on the definition of intersection, it should be a1,c1,c2 and the begin is a1. That's not the answer of the length solution. Can anyone explain that to me? thanks."
                    },
                    {
                        "username": "Samsonjy",
                        "content": "![image](https://assets.leetcode.com/users/images/db298722-4503-4584-bb55-0cc1dd768a7f_1646960379.894478.jpeg)\\n"
                    },
                    {
                        "username": "midhunsubramania",
                        "content": "![image](https://assets.leetcode.com/users/images/65b407c9-322b-47c1-880b-f0e083063f0e_1612082575.8719997.png)\\n The intersection point should be 1 but 8 is said to be the intersection point.\\n how can it be possible??\\n \\n"
                    },
                    {
                        "username": "nitin135",
                        "content": "Why there is no \\'Run Code\\' button in this problem"
                    }
                ]
            },
            {
                "id": 1568028,
                "content": [
                    {
                        "username": "humanparadox",
                        "content": "Since the similarity begins from the \\'1\\' node, why is the \\'8\\' node the beginning of the intersection?"
                    },
                    {
                        "username": "euphoria_kiki",
                        "content": "Since there may be an intersection, so after the longer list first moves forward diff (len_long - len_short) steps, two lists are going to meet at the intersection simultaneously."
                    },
                    {
                        "username": "mshiladityam",
                        "content": "Once you traverse listA, just add INF=1e6 to all nodes.\\nThen once you traverse listB, return first node which has value greater than INF!\\ndone! LOL"
                    },
                    {
                        "username": "lreynl",
                        "content": "By \\'intersection\\' it means finding nodes which are the same object, not nodes with the same value. The variables `intersectVal`, `skipA` and `skipB` aren\\'t used in the code and are a distraction."
                    },
                    {
                        "username": "prialmeida",
                        "content": "I don\\'t understand example 1 it shows that it should return 8 -> 4 -> 5\\nHowever, the intersection starts at 1. I am getting my code wrong because of that. Mine returns the intersection on 1 but the system is expecting to return on 8, but I believe should be 1.\\nCan anyone explain why should be at 8? Thank you"
                    },
                    {
                        "username": "291831388",
                        "content": "if  I have two lists 2->2->3->3 and 3->3->2->2. How to decide the value of the return list node?"
                    },
                    {
                        "username": "Nt_cy",
                        "content": "Does the intersection of linked list need to be in some kind of same position? Why those AC solutions cut two list to same length first? If list A is a1,a2,a3,c1,c2,a4, while list B is a1,b2,b3,c1,c2, what is the answer? Based on the definition of intersection, it should be a1,c1,c2 and the begin is a1. That's not the answer of the length solution. Can anyone explain that to me? thanks."
                    },
                    {
                        "username": "Samsonjy",
                        "content": "![image](https://assets.leetcode.com/users/images/db298722-4503-4584-bb55-0cc1dd768a7f_1646960379.894478.jpeg)\\n"
                    },
                    {
                        "username": "midhunsubramania",
                        "content": "![image](https://assets.leetcode.com/users/images/65b407c9-322b-47c1-880b-f0e083063f0e_1612082575.8719997.png)\\n The intersection point should be 1 but 8 is said to be the intersection point.\\n how can it be possible??\\n \\n"
                    },
                    {
                        "username": "nitin135",
                        "content": "Why there is no \\'Run Code\\' button in this problem"
                    }
                ]
            },
            {
                "id": 1570063,
                "content": [
                    {
                        "username": "amanazmrai",
                        "content": "If we see the test case\\n![image](https://assets.leetcode.com/users/images/e61cecd6-70dd-4dd0-93e6-4500daf4ecd1_1594359520.8587904.png)\\n\\nwe can see the linked list start merging at 1 but here it is given 8. \\nIf I am wrong please fell free to point out"
                    },
                    {
                        "username": "YoussefEgla",
                        "content": "> Could you write a solution that runs in O(m + n) time and use only O(1) memory?\\n\\nIn order to be able to answer the follow up question we probably need to mutate the linked list. LeetCode throws an error whenever it detects that the input data has changed"
                    },
                    {
                        "username": "aka_akash",
                        "content": "Let me help you understand, why it intersects at 8 not at 1 in the first example.\nThe answer lies in the image given in the example. You can see that from the node with value 8, linked lists traverse the same tail. \nIf you look at the nodes with value 1, they exist independently for both the linked lists. But the node with value 8 does not. It means if you traverse the linked lists with different traversal nodes then at the node with value 8, both the traversal nodes will point to the same node while this is not the case at the node with value 1.\nIn simple terms, stop looking at value first - then node, instead follow the node first - then look for stored value. \nIf you still don't get it, I have posted the solution, check it out."
                    },
                    {
                        "username": "aviii24x7",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\n    prefix = \"Intersected at \\'%d\\'\" % (intersection_node.val)\\nLine 78 in _driver (Solution.py)\\n    _driver()\\nLine 97 in <module> (Solution.py)           \\n\\nIT GIVES THIS ERROR BUT IF I PRINT THE SAME LINE RATHER THEN RETURNING IT , IT PRINTS THE ANSWEER! CAN SOMEONE TELL WHATS HAPPENING HERE!!"
                    },
                    {
                        "username": "kavi01",
                        "content": "whAt\\n"
                    },
                    {
                        "username": "Andregol2008",
                        "content": "In my opinion, the trick is understanding how to use the 2 pointers technique and how to take advantage of it with respect to the distances that both pointers have to traverse.\\nIt took me a bit of time until I realized that there was a better and most effective approach in this case.\\nFor those newcomers that do not understand the difference between a value and its position in memory, please take your time and do a little bit of research. The location in memory is like a container, while the value represents whats inside of that container. \\nOther than that, this solution should be written in about 10 lines of code!"
                    },
                    {
                        "username": "user8104ko",
                        "content": "Can Anyone explain me the above code with the given test case \\nlistA = [2,6,4], listB = [1,5], \\n\\nListNode a = headA; \\n        ListNode b = headB; \\n\\n        while(a != b)\\n        {\\n            a = (a == null) ? headA : a.next; \\n            b = (b == null) ? headB : b.next;\\n        } \\n        return a; "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "Can any one please help me \\nI am not getting where exactly this statement available in question  that \" intersection part are available only at the at the list\" ?\\n\\nlink list could be like that as well\\n\\nlistA = [1,2,4,5,6]\\nlistB = [8,9,2,4,5,0,1]\\n\\nhere intersection part is [ 2,4,5 ] \\uD83E\\uDD14\\uD83E\\uDD14"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "WHY my code is getting failed at headA[1] and headB[1],0,0? Please explain me someone\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n\\n        //My Brute Force solution\\n       ListNode temp=headB;\\n        while(headA.next!=null){\\n\\n            if(headA==null && headB==null){\\n                return null;\\n            }\\n            if(headA==headB){\\n                return headA;\\n            }\\n            while(headB.next!=null){\\n                if(headA==headB){\\n                    return headA;\\n                }\\n                headB=headB.next;\\n            }\\n            headB=temp;\\n            headA=headA.next;\\n        }\\n\\n        return null;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "it should be medium\\n"
                    }
                ]
            },
            {
                "id": 2071789,
                "content": [
                    {
                        "username": "amanazmrai",
                        "content": "If we see the test case\\n![image](https://assets.leetcode.com/users/images/e61cecd6-70dd-4dd0-93e6-4500daf4ecd1_1594359520.8587904.png)\\n\\nwe can see the linked list start merging at 1 but here it is given 8. \\nIf I am wrong please fell free to point out"
                    },
                    {
                        "username": "YoussefEgla",
                        "content": "> Could you write a solution that runs in O(m + n) time and use only O(1) memory?\\n\\nIn order to be able to answer the follow up question we probably need to mutate the linked list. LeetCode throws an error whenever it detects that the input data has changed"
                    },
                    {
                        "username": "aka_akash",
                        "content": "Let me help you understand, why it intersects at 8 not at 1 in the first example.\nThe answer lies in the image given in the example. You can see that from the node with value 8, linked lists traverse the same tail. \nIf you look at the nodes with value 1, they exist independently for both the linked lists. But the node with value 8 does not. It means if you traverse the linked lists with different traversal nodes then at the node with value 8, both the traversal nodes will point to the same node while this is not the case at the node with value 1.\nIn simple terms, stop looking at value first - then node, instead follow the node first - then look for stored value. \nIf you still don't get it, I have posted the solution, check it out."
                    },
                    {
                        "username": "aviii24x7",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\n    prefix = \"Intersected at \\'%d\\'\" % (intersection_node.val)\\nLine 78 in _driver (Solution.py)\\n    _driver()\\nLine 97 in <module> (Solution.py)           \\n\\nIT GIVES THIS ERROR BUT IF I PRINT THE SAME LINE RATHER THEN RETURNING IT , IT PRINTS THE ANSWEER! CAN SOMEONE TELL WHATS HAPPENING HERE!!"
                    },
                    {
                        "username": "kavi01",
                        "content": "whAt\\n"
                    },
                    {
                        "username": "Andregol2008",
                        "content": "In my opinion, the trick is understanding how to use the 2 pointers technique and how to take advantage of it with respect to the distances that both pointers have to traverse.\\nIt took me a bit of time until I realized that there was a better and most effective approach in this case.\\nFor those newcomers that do not understand the difference between a value and its position in memory, please take your time and do a little bit of research. The location in memory is like a container, while the value represents whats inside of that container. \\nOther than that, this solution should be written in about 10 lines of code!"
                    },
                    {
                        "username": "user8104ko",
                        "content": "Can Anyone explain me the above code with the given test case \\nlistA = [2,6,4], listB = [1,5], \\n\\nListNode a = headA; \\n        ListNode b = headB; \\n\\n        while(a != b)\\n        {\\n            a = (a == null) ? headA : a.next; \\n            b = (b == null) ? headB : b.next;\\n        } \\n        return a; "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "Can any one please help me \\nI am not getting where exactly this statement available in question  that \" intersection part are available only at the at the list\" ?\\n\\nlink list could be like that as well\\n\\nlistA = [1,2,4,5,6]\\nlistB = [8,9,2,4,5,0,1]\\n\\nhere intersection part is [ 2,4,5 ] \\uD83E\\uDD14\\uD83E\\uDD14"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "WHY my code is getting failed at headA[1] and headB[1],0,0? Please explain me someone\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n\\n        //My Brute Force solution\\n       ListNode temp=headB;\\n        while(headA.next!=null){\\n\\n            if(headA==null && headB==null){\\n                return null;\\n            }\\n            if(headA==headB){\\n                return headA;\\n            }\\n            while(headB.next!=null){\\n                if(headA==headB){\\n                    return headA;\\n                }\\n                headB=headB.next;\\n            }\\n            headB=temp;\\n            headA=headA.next;\\n        }\\n\\n        return null;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "it should be medium\\n"
                    }
                ]
            },
            {
                "id": 2066698,
                "content": [
                    {
                        "username": "amanazmrai",
                        "content": "If we see the test case\\n![image](https://assets.leetcode.com/users/images/e61cecd6-70dd-4dd0-93e6-4500daf4ecd1_1594359520.8587904.png)\\n\\nwe can see the linked list start merging at 1 but here it is given 8. \\nIf I am wrong please fell free to point out"
                    },
                    {
                        "username": "YoussefEgla",
                        "content": "> Could you write a solution that runs in O(m + n) time and use only O(1) memory?\\n\\nIn order to be able to answer the follow up question we probably need to mutate the linked list. LeetCode throws an error whenever it detects that the input data has changed"
                    },
                    {
                        "username": "aka_akash",
                        "content": "Let me help you understand, why it intersects at 8 not at 1 in the first example.\nThe answer lies in the image given in the example. You can see that from the node with value 8, linked lists traverse the same tail. \nIf you look at the nodes with value 1, they exist independently for both the linked lists. But the node with value 8 does not. It means if you traverse the linked lists with different traversal nodes then at the node with value 8, both the traversal nodes will point to the same node while this is not the case at the node with value 1.\nIn simple terms, stop looking at value first - then node, instead follow the node first - then look for stored value. \nIf you still don't get it, I have posted the solution, check it out."
                    },
                    {
                        "username": "aviii24x7",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\n    prefix = \"Intersected at \\'%d\\'\" % (intersection_node.val)\\nLine 78 in _driver (Solution.py)\\n    _driver()\\nLine 97 in <module> (Solution.py)           \\n\\nIT GIVES THIS ERROR BUT IF I PRINT THE SAME LINE RATHER THEN RETURNING IT , IT PRINTS THE ANSWEER! CAN SOMEONE TELL WHATS HAPPENING HERE!!"
                    },
                    {
                        "username": "kavi01",
                        "content": "whAt\\n"
                    },
                    {
                        "username": "Andregol2008",
                        "content": "In my opinion, the trick is understanding how to use the 2 pointers technique and how to take advantage of it with respect to the distances that both pointers have to traverse.\\nIt took me a bit of time until I realized that there was a better and most effective approach in this case.\\nFor those newcomers that do not understand the difference between a value and its position in memory, please take your time and do a little bit of research. The location in memory is like a container, while the value represents whats inside of that container. \\nOther than that, this solution should be written in about 10 lines of code!"
                    },
                    {
                        "username": "user8104ko",
                        "content": "Can Anyone explain me the above code with the given test case \\nlistA = [2,6,4], listB = [1,5], \\n\\nListNode a = headA; \\n        ListNode b = headB; \\n\\n        while(a != b)\\n        {\\n            a = (a == null) ? headA : a.next; \\n            b = (b == null) ? headB : b.next;\\n        } \\n        return a; "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "Can any one please help me \\nI am not getting where exactly this statement available in question  that \" intersection part are available only at the at the list\" ?\\n\\nlink list could be like that as well\\n\\nlistA = [1,2,4,5,6]\\nlistB = [8,9,2,4,5,0,1]\\n\\nhere intersection part is [ 2,4,5 ] \\uD83E\\uDD14\\uD83E\\uDD14"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "WHY my code is getting failed at headA[1] and headB[1],0,0? Please explain me someone\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n\\n        //My Brute Force solution\\n       ListNode temp=headB;\\n        while(headA.next!=null){\\n\\n            if(headA==null && headB==null){\\n                return null;\\n            }\\n            if(headA==headB){\\n                return headA;\\n            }\\n            while(headB.next!=null){\\n                if(headA==headB){\\n                    return headA;\\n                }\\n                headB=headB.next;\\n            }\\n            headB=temp;\\n            headA=headA.next;\\n        }\\n\\n        return null;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "it should be medium\\n"
                    }
                ]
            },
            {
                "id": 2058940,
                "content": [
                    {
                        "username": "amanazmrai",
                        "content": "If we see the test case\\n![image](https://assets.leetcode.com/users/images/e61cecd6-70dd-4dd0-93e6-4500daf4ecd1_1594359520.8587904.png)\\n\\nwe can see the linked list start merging at 1 but here it is given 8. \\nIf I am wrong please fell free to point out"
                    },
                    {
                        "username": "YoussefEgla",
                        "content": "> Could you write a solution that runs in O(m + n) time and use only O(1) memory?\\n\\nIn order to be able to answer the follow up question we probably need to mutate the linked list. LeetCode throws an error whenever it detects that the input data has changed"
                    },
                    {
                        "username": "aka_akash",
                        "content": "Let me help you understand, why it intersects at 8 not at 1 in the first example.\nThe answer lies in the image given in the example. You can see that from the node with value 8, linked lists traverse the same tail. \nIf you look at the nodes with value 1, they exist independently for both the linked lists. But the node with value 8 does not. It means if you traverse the linked lists with different traversal nodes then at the node with value 8, both the traversal nodes will point to the same node while this is not the case at the node with value 1.\nIn simple terms, stop looking at value first - then node, instead follow the node first - then look for stored value. \nIf you still don't get it, I have posted the solution, check it out."
                    },
                    {
                        "username": "aviii24x7",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\n    prefix = \"Intersected at \\'%d\\'\" % (intersection_node.val)\\nLine 78 in _driver (Solution.py)\\n    _driver()\\nLine 97 in <module> (Solution.py)           \\n\\nIT GIVES THIS ERROR BUT IF I PRINT THE SAME LINE RATHER THEN RETURNING IT , IT PRINTS THE ANSWEER! CAN SOMEONE TELL WHATS HAPPENING HERE!!"
                    },
                    {
                        "username": "kavi01",
                        "content": "whAt\\n"
                    },
                    {
                        "username": "Andregol2008",
                        "content": "In my opinion, the trick is understanding how to use the 2 pointers technique and how to take advantage of it with respect to the distances that both pointers have to traverse.\\nIt took me a bit of time until I realized that there was a better and most effective approach in this case.\\nFor those newcomers that do not understand the difference between a value and its position in memory, please take your time and do a little bit of research. The location in memory is like a container, while the value represents whats inside of that container. \\nOther than that, this solution should be written in about 10 lines of code!"
                    },
                    {
                        "username": "user8104ko",
                        "content": "Can Anyone explain me the above code with the given test case \\nlistA = [2,6,4], listB = [1,5], \\n\\nListNode a = headA; \\n        ListNode b = headB; \\n\\n        while(a != b)\\n        {\\n            a = (a == null) ? headA : a.next; \\n            b = (b == null) ? headB : b.next;\\n        } \\n        return a; "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "Can any one please help me \\nI am not getting where exactly this statement available in question  that \" intersection part are available only at the at the list\" ?\\n\\nlink list could be like that as well\\n\\nlistA = [1,2,4,5,6]\\nlistB = [8,9,2,4,5,0,1]\\n\\nhere intersection part is [ 2,4,5 ] \\uD83E\\uDD14\\uD83E\\uDD14"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "WHY my code is getting failed at headA[1] and headB[1],0,0? Please explain me someone\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n\\n        //My Brute Force solution\\n       ListNode temp=headB;\\n        while(headA.next!=null){\\n\\n            if(headA==null && headB==null){\\n                return null;\\n            }\\n            if(headA==headB){\\n                return headA;\\n            }\\n            while(headB.next!=null){\\n                if(headA==headB){\\n                    return headA;\\n                }\\n                headB=headB.next;\\n            }\\n            headB=temp;\\n            headA=headA.next;\\n        }\\n\\n        return null;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "it should be medium\\n"
                    }
                ]
            },
            {
                "id": 2052012,
                "content": [
                    {
                        "username": "amanazmrai",
                        "content": "If we see the test case\\n![image](https://assets.leetcode.com/users/images/e61cecd6-70dd-4dd0-93e6-4500daf4ecd1_1594359520.8587904.png)\\n\\nwe can see the linked list start merging at 1 but here it is given 8. \\nIf I am wrong please fell free to point out"
                    },
                    {
                        "username": "YoussefEgla",
                        "content": "> Could you write a solution that runs in O(m + n) time and use only O(1) memory?\\n\\nIn order to be able to answer the follow up question we probably need to mutate the linked list. LeetCode throws an error whenever it detects that the input data has changed"
                    },
                    {
                        "username": "aka_akash",
                        "content": "Let me help you understand, why it intersects at 8 not at 1 in the first example.\nThe answer lies in the image given in the example. You can see that from the node with value 8, linked lists traverse the same tail. \nIf you look at the nodes with value 1, they exist independently for both the linked lists. But the node with value 8 does not. It means if you traverse the linked lists with different traversal nodes then at the node with value 8, both the traversal nodes will point to the same node while this is not the case at the node with value 1.\nIn simple terms, stop looking at value first - then node, instead follow the node first - then look for stored value. \nIf you still don't get it, I have posted the solution, check it out."
                    },
                    {
                        "username": "aviii24x7",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\n    prefix = \"Intersected at \\'%d\\'\" % (intersection_node.val)\\nLine 78 in _driver (Solution.py)\\n    _driver()\\nLine 97 in <module> (Solution.py)           \\n\\nIT GIVES THIS ERROR BUT IF I PRINT THE SAME LINE RATHER THEN RETURNING IT , IT PRINTS THE ANSWEER! CAN SOMEONE TELL WHATS HAPPENING HERE!!"
                    },
                    {
                        "username": "kavi01",
                        "content": "whAt\\n"
                    },
                    {
                        "username": "Andregol2008",
                        "content": "In my opinion, the trick is understanding how to use the 2 pointers technique and how to take advantage of it with respect to the distances that both pointers have to traverse.\\nIt took me a bit of time until I realized that there was a better and most effective approach in this case.\\nFor those newcomers that do not understand the difference between a value and its position in memory, please take your time and do a little bit of research. The location in memory is like a container, while the value represents whats inside of that container. \\nOther than that, this solution should be written in about 10 lines of code!"
                    },
                    {
                        "username": "user8104ko",
                        "content": "Can Anyone explain me the above code with the given test case \\nlistA = [2,6,4], listB = [1,5], \\n\\nListNode a = headA; \\n        ListNode b = headB; \\n\\n        while(a != b)\\n        {\\n            a = (a == null) ? headA : a.next; \\n            b = (b == null) ? headB : b.next;\\n        } \\n        return a; "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "Can any one please help me \\nI am not getting where exactly this statement available in question  that \" intersection part are available only at the at the list\" ?\\n\\nlink list could be like that as well\\n\\nlistA = [1,2,4,5,6]\\nlistB = [8,9,2,4,5,0,1]\\n\\nhere intersection part is [ 2,4,5 ] \\uD83E\\uDD14\\uD83E\\uDD14"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "WHY my code is getting failed at headA[1] and headB[1],0,0? Please explain me someone\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n\\n        //My Brute Force solution\\n       ListNode temp=headB;\\n        while(headA.next!=null){\\n\\n            if(headA==null && headB==null){\\n                return null;\\n            }\\n            if(headA==headB){\\n                return headA;\\n            }\\n            while(headB.next!=null){\\n                if(headA==headB){\\n                    return headA;\\n                }\\n                headB=headB.next;\\n            }\\n            headB=temp;\\n            headA=headA.next;\\n        }\\n\\n        return null;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "it should be medium\\n"
                    }
                ]
            },
            {
                "id": 2049717,
                "content": [
                    {
                        "username": "amanazmrai",
                        "content": "If we see the test case\\n![image](https://assets.leetcode.com/users/images/e61cecd6-70dd-4dd0-93e6-4500daf4ecd1_1594359520.8587904.png)\\n\\nwe can see the linked list start merging at 1 but here it is given 8. \\nIf I am wrong please fell free to point out"
                    },
                    {
                        "username": "YoussefEgla",
                        "content": "> Could you write a solution that runs in O(m + n) time and use only O(1) memory?\\n\\nIn order to be able to answer the follow up question we probably need to mutate the linked list. LeetCode throws an error whenever it detects that the input data has changed"
                    },
                    {
                        "username": "aka_akash",
                        "content": "Let me help you understand, why it intersects at 8 not at 1 in the first example.\nThe answer lies in the image given in the example. You can see that from the node with value 8, linked lists traverse the same tail. \nIf you look at the nodes with value 1, they exist independently for both the linked lists. But the node with value 8 does not. It means if you traverse the linked lists with different traversal nodes then at the node with value 8, both the traversal nodes will point to the same node while this is not the case at the node with value 1.\nIn simple terms, stop looking at value first - then node, instead follow the node first - then look for stored value. \nIf you still don't get it, I have posted the solution, check it out."
                    },
                    {
                        "username": "aviii24x7",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\n    prefix = \"Intersected at \\'%d\\'\" % (intersection_node.val)\\nLine 78 in _driver (Solution.py)\\n    _driver()\\nLine 97 in <module> (Solution.py)           \\n\\nIT GIVES THIS ERROR BUT IF I PRINT THE SAME LINE RATHER THEN RETURNING IT , IT PRINTS THE ANSWEER! CAN SOMEONE TELL WHATS HAPPENING HERE!!"
                    },
                    {
                        "username": "kavi01",
                        "content": "whAt\\n"
                    },
                    {
                        "username": "Andregol2008",
                        "content": "In my opinion, the trick is understanding how to use the 2 pointers technique and how to take advantage of it with respect to the distances that both pointers have to traverse.\\nIt took me a bit of time until I realized that there was a better and most effective approach in this case.\\nFor those newcomers that do not understand the difference between a value and its position in memory, please take your time and do a little bit of research. The location in memory is like a container, while the value represents whats inside of that container. \\nOther than that, this solution should be written in about 10 lines of code!"
                    },
                    {
                        "username": "user8104ko",
                        "content": "Can Anyone explain me the above code with the given test case \\nlistA = [2,6,4], listB = [1,5], \\n\\nListNode a = headA; \\n        ListNode b = headB; \\n\\n        while(a != b)\\n        {\\n            a = (a == null) ? headA : a.next; \\n            b = (b == null) ? headB : b.next;\\n        } \\n        return a; "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "Can any one please help me \\nI am not getting where exactly this statement available in question  that \" intersection part are available only at the at the list\" ?\\n\\nlink list could be like that as well\\n\\nlistA = [1,2,4,5,6]\\nlistB = [8,9,2,4,5,0,1]\\n\\nhere intersection part is [ 2,4,5 ] \\uD83E\\uDD14\\uD83E\\uDD14"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "WHY my code is getting failed at headA[1] and headB[1],0,0? Please explain me someone\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n\\n        //My Brute Force solution\\n       ListNode temp=headB;\\n        while(headA.next!=null){\\n\\n            if(headA==null && headB==null){\\n                return null;\\n            }\\n            if(headA==headB){\\n                return headA;\\n            }\\n            while(headB.next!=null){\\n                if(headA==headB){\\n                    return headA;\\n                }\\n                headB=headB.next;\\n            }\\n            headB=temp;\\n            headA=headA.next;\\n        }\\n\\n        return null;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "it should be medium\\n"
                    }
                ]
            },
            {
                "id": 2045186,
                "content": [
                    {
                        "username": "amanazmrai",
                        "content": "If we see the test case\\n![image](https://assets.leetcode.com/users/images/e61cecd6-70dd-4dd0-93e6-4500daf4ecd1_1594359520.8587904.png)\\n\\nwe can see the linked list start merging at 1 but here it is given 8. \\nIf I am wrong please fell free to point out"
                    },
                    {
                        "username": "YoussefEgla",
                        "content": "> Could you write a solution that runs in O(m + n) time and use only O(1) memory?\\n\\nIn order to be able to answer the follow up question we probably need to mutate the linked list. LeetCode throws an error whenever it detects that the input data has changed"
                    },
                    {
                        "username": "aka_akash",
                        "content": "Let me help you understand, why it intersects at 8 not at 1 in the first example.\nThe answer lies in the image given in the example. You can see that from the node with value 8, linked lists traverse the same tail. \nIf you look at the nodes with value 1, they exist independently for both the linked lists. But the node with value 8 does not. It means if you traverse the linked lists with different traversal nodes then at the node with value 8, both the traversal nodes will point to the same node while this is not the case at the node with value 1.\nIn simple terms, stop looking at value first - then node, instead follow the node first - then look for stored value. \nIf you still don't get it, I have posted the solution, check it out."
                    },
                    {
                        "username": "aviii24x7",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\n    prefix = \"Intersected at \\'%d\\'\" % (intersection_node.val)\\nLine 78 in _driver (Solution.py)\\n    _driver()\\nLine 97 in <module> (Solution.py)           \\n\\nIT GIVES THIS ERROR BUT IF I PRINT THE SAME LINE RATHER THEN RETURNING IT , IT PRINTS THE ANSWEER! CAN SOMEONE TELL WHATS HAPPENING HERE!!"
                    },
                    {
                        "username": "kavi01",
                        "content": "whAt\\n"
                    },
                    {
                        "username": "Andregol2008",
                        "content": "In my opinion, the trick is understanding how to use the 2 pointers technique and how to take advantage of it with respect to the distances that both pointers have to traverse.\\nIt took me a bit of time until I realized that there was a better and most effective approach in this case.\\nFor those newcomers that do not understand the difference between a value and its position in memory, please take your time and do a little bit of research. The location in memory is like a container, while the value represents whats inside of that container. \\nOther than that, this solution should be written in about 10 lines of code!"
                    },
                    {
                        "username": "user8104ko",
                        "content": "Can Anyone explain me the above code with the given test case \\nlistA = [2,6,4], listB = [1,5], \\n\\nListNode a = headA; \\n        ListNode b = headB; \\n\\n        while(a != b)\\n        {\\n            a = (a == null) ? headA : a.next; \\n            b = (b == null) ? headB : b.next;\\n        } \\n        return a; "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "Can any one please help me \\nI am not getting where exactly this statement available in question  that \" intersection part are available only at the at the list\" ?\\n\\nlink list could be like that as well\\n\\nlistA = [1,2,4,5,6]\\nlistB = [8,9,2,4,5,0,1]\\n\\nhere intersection part is [ 2,4,5 ] \\uD83E\\uDD14\\uD83E\\uDD14"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "WHY my code is getting failed at headA[1] and headB[1],0,0? Please explain me someone\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n\\n        //My Brute Force solution\\n       ListNode temp=headB;\\n        while(headA.next!=null){\\n\\n            if(headA==null && headB==null){\\n                return null;\\n            }\\n            if(headA==headB){\\n                return headA;\\n            }\\n            while(headB.next!=null){\\n                if(headA==headB){\\n                    return headA;\\n                }\\n                headB=headB.next;\\n            }\\n            headB=temp;\\n            headA=headA.next;\\n        }\\n\\n        return null;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "it should be medium\\n"
                    }
                ]
            },
            {
                "id": 2044065,
                "content": [
                    {
                        "username": "amanazmrai",
                        "content": "If we see the test case\\n![image](https://assets.leetcode.com/users/images/e61cecd6-70dd-4dd0-93e6-4500daf4ecd1_1594359520.8587904.png)\\n\\nwe can see the linked list start merging at 1 but here it is given 8. \\nIf I am wrong please fell free to point out"
                    },
                    {
                        "username": "YoussefEgla",
                        "content": "> Could you write a solution that runs in O(m + n) time and use only O(1) memory?\\n\\nIn order to be able to answer the follow up question we probably need to mutate the linked list. LeetCode throws an error whenever it detects that the input data has changed"
                    },
                    {
                        "username": "aka_akash",
                        "content": "Let me help you understand, why it intersects at 8 not at 1 in the first example.\nThe answer lies in the image given in the example. You can see that from the node with value 8, linked lists traverse the same tail. \nIf you look at the nodes with value 1, they exist independently for both the linked lists. But the node with value 8 does not. It means if you traverse the linked lists with different traversal nodes then at the node with value 8, both the traversal nodes will point to the same node while this is not the case at the node with value 1.\nIn simple terms, stop looking at value first - then node, instead follow the node first - then look for stored value. \nIf you still don't get it, I have posted the solution, check it out."
                    },
                    {
                        "username": "aviii24x7",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\n    prefix = \"Intersected at \\'%d\\'\" % (intersection_node.val)\\nLine 78 in _driver (Solution.py)\\n    _driver()\\nLine 97 in <module> (Solution.py)           \\n\\nIT GIVES THIS ERROR BUT IF I PRINT THE SAME LINE RATHER THEN RETURNING IT , IT PRINTS THE ANSWEER! CAN SOMEONE TELL WHATS HAPPENING HERE!!"
                    },
                    {
                        "username": "kavi01",
                        "content": "whAt\\n"
                    },
                    {
                        "username": "Andregol2008",
                        "content": "In my opinion, the trick is understanding how to use the 2 pointers technique and how to take advantage of it with respect to the distances that both pointers have to traverse.\\nIt took me a bit of time until I realized that there was a better and most effective approach in this case.\\nFor those newcomers that do not understand the difference between a value and its position in memory, please take your time and do a little bit of research. The location in memory is like a container, while the value represents whats inside of that container. \\nOther than that, this solution should be written in about 10 lines of code!"
                    },
                    {
                        "username": "user8104ko",
                        "content": "Can Anyone explain me the above code with the given test case \\nlistA = [2,6,4], listB = [1,5], \\n\\nListNode a = headA; \\n        ListNode b = headB; \\n\\n        while(a != b)\\n        {\\n            a = (a == null) ? headA : a.next; \\n            b = (b == null) ? headB : b.next;\\n        } \\n        return a; "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "Can any one please help me \\nI am not getting where exactly this statement available in question  that \" intersection part are available only at the at the list\" ?\\n\\nlink list could be like that as well\\n\\nlistA = [1,2,4,5,6]\\nlistB = [8,9,2,4,5,0,1]\\n\\nhere intersection part is [ 2,4,5 ] \\uD83E\\uDD14\\uD83E\\uDD14"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "WHY my code is getting failed at headA[1] and headB[1],0,0? Please explain me someone\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n\\n        //My Brute Force solution\\n       ListNode temp=headB;\\n        while(headA.next!=null){\\n\\n            if(headA==null && headB==null){\\n                return null;\\n            }\\n            if(headA==headB){\\n                return headA;\\n            }\\n            while(headB.next!=null){\\n                if(headA==headB){\\n                    return headA;\\n                }\\n                headB=headB.next;\\n            }\\n            headB=temp;\\n            headA=headA.next;\\n        }\\n\\n        return null;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "it should be medium\\n"
                    }
                ]
            },
            {
                "id": 2029688,
                "content": [
                    {
                        "username": "amanazmrai",
                        "content": "If we see the test case\\n![image](https://assets.leetcode.com/users/images/e61cecd6-70dd-4dd0-93e6-4500daf4ecd1_1594359520.8587904.png)\\n\\nwe can see the linked list start merging at 1 but here it is given 8. \\nIf I am wrong please fell free to point out"
                    },
                    {
                        "username": "YoussefEgla",
                        "content": "> Could you write a solution that runs in O(m + n) time and use only O(1) memory?\\n\\nIn order to be able to answer the follow up question we probably need to mutate the linked list. LeetCode throws an error whenever it detects that the input data has changed"
                    },
                    {
                        "username": "aka_akash",
                        "content": "Let me help you understand, why it intersects at 8 not at 1 in the first example.\nThe answer lies in the image given in the example. You can see that from the node with value 8, linked lists traverse the same tail. \nIf you look at the nodes with value 1, they exist independently for both the linked lists. But the node with value 8 does not. It means if you traverse the linked lists with different traversal nodes then at the node with value 8, both the traversal nodes will point to the same node while this is not the case at the node with value 1.\nIn simple terms, stop looking at value first - then node, instead follow the node first - then look for stored value. \nIf you still don't get it, I have posted the solution, check it out."
                    },
                    {
                        "username": "aviii24x7",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\n    prefix = \"Intersected at \\'%d\\'\" % (intersection_node.val)\\nLine 78 in _driver (Solution.py)\\n    _driver()\\nLine 97 in <module> (Solution.py)           \\n\\nIT GIVES THIS ERROR BUT IF I PRINT THE SAME LINE RATHER THEN RETURNING IT , IT PRINTS THE ANSWEER! CAN SOMEONE TELL WHATS HAPPENING HERE!!"
                    },
                    {
                        "username": "kavi01",
                        "content": "whAt\\n"
                    },
                    {
                        "username": "Andregol2008",
                        "content": "In my opinion, the trick is understanding how to use the 2 pointers technique and how to take advantage of it with respect to the distances that both pointers have to traverse.\\nIt took me a bit of time until I realized that there was a better and most effective approach in this case.\\nFor those newcomers that do not understand the difference between a value and its position in memory, please take your time and do a little bit of research. The location in memory is like a container, while the value represents whats inside of that container. \\nOther than that, this solution should be written in about 10 lines of code!"
                    },
                    {
                        "username": "user8104ko",
                        "content": "Can Anyone explain me the above code with the given test case \\nlistA = [2,6,4], listB = [1,5], \\n\\nListNode a = headA; \\n        ListNode b = headB; \\n\\n        while(a != b)\\n        {\\n            a = (a == null) ? headA : a.next; \\n            b = (b == null) ? headB : b.next;\\n        } \\n        return a; "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "Can any one please help me \\nI am not getting where exactly this statement available in question  that \" intersection part are available only at the at the list\" ?\\n\\nlink list could be like that as well\\n\\nlistA = [1,2,4,5,6]\\nlistB = [8,9,2,4,5,0,1]\\n\\nhere intersection part is [ 2,4,5 ] \\uD83E\\uDD14\\uD83E\\uDD14"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "WHY my code is getting failed at headA[1] and headB[1],0,0? Please explain me someone\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n\\n        //My Brute Force solution\\n       ListNode temp=headB;\\n        while(headA.next!=null){\\n\\n            if(headA==null && headB==null){\\n                return null;\\n            }\\n            if(headA==headB){\\n                return headA;\\n            }\\n            while(headB.next!=null){\\n                if(headA==headB){\\n                    return headA;\\n                }\\n                headB=headB.next;\\n            }\\n            headB=temp;\\n            headA=headA.next;\\n        }\\n\\n        return null;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "it should be medium\\n"
                    }
                ]
            },
            {
                "id": 2027265,
                "content": [
                    {
                        "username": "amanazmrai",
                        "content": "If we see the test case\\n![image](https://assets.leetcode.com/users/images/e61cecd6-70dd-4dd0-93e6-4500daf4ecd1_1594359520.8587904.png)\\n\\nwe can see the linked list start merging at 1 but here it is given 8. \\nIf I am wrong please fell free to point out"
                    },
                    {
                        "username": "YoussefEgla",
                        "content": "> Could you write a solution that runs in O(m + n) time and use only O(1) memory?\\n\\nIn order to be able to answer the follow up question we probably need to mutate the linked list. LeetCode throws an error whenever it detects that the input data has changed"
                    },
                    {
                        "username": "aka_akash",
                        "content": "Let me help you understand, why it intersects at 8 not at 1 in the first example.\nThe answer lies in the image given in the example. You can see that from the node with value 8, linked lists traverse the same tail. \nIf you look at the nodes with value 1, they exist independently for both the linked lists. But the node with value 8 does not. It means if you traverse the linked lists with different traversal nodes then at the node with value 8, both the traversal nodes will point to the same node while this is not the case at the node with value 1.\nIn simple terms, stop looking at value first - then node, instead follow the node first - then look for stored value. \nIf you still don't get it, I have posted the solution, check it out."
                    },
                    {
                        "username": "aviii24x7",
                        "content": "AttributeError: \\'int\\' object has no attribute \\'val\\'\\n    prefix = \"Intersected at \\'%d\\'\" % (intersection_node.val)\\nLine 78 in _driver (Solution.py)\\n    _driver()\\nLine 97 in <module> (Solution.py)           \\n\\nIT GIVES THIS ERROR BUT IF I PRINT THE SAME LINE RATHER THEN RETURNING IT , IT PRINTS THE ANSWEER! CAN SOMEONE TELL WHATS HAPPENING HERE!!"
                    },
                    {
                        "username": "kavi01",
                        "content": "whAt\\n"
                    },
                    {
                        "username": "Andregol2008",
                        "content": "In my opinion, the trick is understanding how to use the 2 pointers technique and how to take advantage of it with respect to the distances that both pointers have to traverse.\\nIt took me a bit of time until I realized that there was a better and most effective approach in this case.\\nFor those newcomers that do not understand the difference between a value and its position in memory, please take your time and do a little bit of research. The location in memory is like a container, while the value represents whats inside of that container. \\nOther than that, this solution should be written in about 10 lines of code!"
                    },
                    {
                        "username": "user8104ko",
                        "content": "Can Anyone explain me the above code with the given test case \\nlistA = [2,6,4], listB = [1,5], \\n\\nListNode a = headA; \\n        ListNode b = headB; \\n\\n        while(a != b)\\n        {\\n            a = (a == null) ? headA : a.next; \\n            b = (b == null) ? headB : b.next;\\n        } \\n        return a; "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "Can any one please help me \\nI am not getting where exactly this statement available in question  that \" intersection part are available only at the at the list\" ?\\n\\nlink list could be like that as well\\n\\nlistA = [1,2,4,5,6]\\nlistB = [8,9,2,4,5,0,1]\\n\\nhere intersection part is [ 2,4,5 ] \\uD83E\\uDD14\\uD83E\\uDD14"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "WHY my code is getting failed at headA[1] and headB[1],0,0? Please explain me someone\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) {\\n *         val = x;\\n *         next = null;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n\\n\\n        //My Brute Force solution\\n       ListNode temp=headB;\\n        while(headA.next!=null){\\n\\n            if(headA==null && headB==null){\\n                return null;\\n            }\\n            if(headA==headB){\\n                return headA;\\n            }\\n            while(headB.next!=null){\\n                if(headA==headB){\\n                    return headA;\\n                }\\n                headB=headB.next;\\n            }\\n            headB=temp;\\n            headA=headA.next;\\n        }\\n\\n        return null;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "PruthviChippa",
                        "content": "it should be medium\\n"
                    }
                ]
            },
            {
                "id": 2024422,
                "content": [
                    {
                        "username": "susahin80",
                        "content": "What an unclear question.\\nIt gives the intersectVal, skipA and skipB as inputs, but they are nor in the method signature!!!"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "Can Somone Tell Me Why This is Not Working??\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mpp;\\n        ListNode* temp = headA;\\n        ListNode* d = headB;\\n        while(temp -> next){\\n            mpp[temp]++;\\n            temp = temp -> next;\\n        }\\n        while(d -> next){\\n            if(mpp.find(d) == mpp.end()){\\n                return d;\\n            }\\n            d = d -> next;\\n        }\\n        return NULL;\\n}\\n};"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Haha, my solution beats 100% of contestants."
                    },
                    {
                        "username": "spookie886",
                        "content": "did they change the tag from medium to easy?"
                    },
                    {
                        "username": "grind99",
                        "content": "bruh who prepared this question ???"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Is an approach using two stacks valid? I was thinking we can start from the end instead of the beginning."
                    },
                    {
                        "username": "bhavya_sri_yarlagadda",
                        "content": "What if skipA and skipB is 0? \\nI tried with this input, then it says Invalid input.\\nI think this testcase also needs to be covered"
                    },
                    {
                        "username": "zzjharry",
                        "content": "One of the best leetcode questions requires good understanding of linked list!"
                    },
                    {
                        "username": "Pulkit-mahajan",
                        "content": "In such questions, where we\\'re not allowed to modify the input array/linked list, is it acceptable if I were to modify it, but then again undo all changes before returning the final answer. \\nMy solution was accepted in this manner on this leetcode platform, but will such answer be acceptable in an interview. "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "No strictly adhere to what is asked in question others wise it sets  negative impact on the interviewer "
                    },
                    {
                        "username": "joshuamts12334",
                        "content": "Str_maxlenoc\\n\\nWrite a function that takes an array of strings and returns\\nthe longest string that appears in every parameter\\'s strings. If more that one\\nstring qualifies, it will return the one that appears first in the first\\nparameter. Note that the empty string technically appears in any string."
                    }
                ]
            },
            {
                "id": 2013873,
                "content": [
                    {
                        "username": "susahin80",
                        "content": "What an unclear question.\\nIt gives the intersectVal, skipA and skipB as inputs, but they are nor in the method signature!!!"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "Can Somone Tell Me Why This is Not Working??\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mpp;\\n        ListNode* temp = headA;\\n        ListNode* d = headB;\\n        while(temp -> next){\\n            mpp[temp]++;\\n            temp = temp -> next;\\n        }\\n        while(d -> next){\\n            if(mpp.find(d) == mpp.end()){\\n                return d;\\n            }\\n            d = d -> next;\\n        }\\n        return NULL;\\n}\\n};"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Haha, my solution beats 100% of contestants."
                    },
                    {
                        "username": "spookie886",
                        "content": "did they change the tag from medium to easy?"
                    },
                    {
                        "username": "grind99",
                        "content": "bruh who prepared this question ???"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Is an approach using two stacks valid? I was thinking we can start from the end instead of the beginning."
                    },
                    {
                        "username": "bhavya_sri_yarlagadda",
                        "content": "What if skipA and skipB is 0? \\nI tried with this input, then it says Invalid input.\\nI think this testcase also needs to be covered"
                    },
                    {
                        "username": "zzjharry",
                        "content": "One of the best leetcode questions requires good understanding of linked list!"
                    },
                    {
                        "username": "Pulkit-mahajan",
                        "content": "In such questions, where we\\'re not allowed to modify the input array/linked list, is it acceptable if I were to modify it, but then again undo all changes before returning the final answer. \\nMy solution was accepted in this manner on this leetcode platform, but will such answer be acceptable in an interview. "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "No strictly adhere to what is asked in question others wise it sets  negative impact on the interviewer "
                    },
                    {
                        "username": "joshuamts12334",
                        "content": "Str_maxlenoc\\n\\nWrite a function that takes an array of strings and returns\\nthe longest string that appears in every parameter\\'s strings. If more that one\\nstring qualifies, it will return the one that appears first in the first\\nparameter. Note that the empty string technically appears in any string."
                    }
                ]
            },
            {
                "id": 1989858,
                "content": [
                    {
                        "username": "susahin80",
                        "content": "What an unclear question.\\nIt gives the intersectVal, skipA and skipB as inputs, but they are nor in the method signature!!!"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "Can Somone Tell Me Why This is Not Working??\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mpp;\\n        ListNode* temp = headA;\\n        ListNode* d = headB;\\n        while(temp -> next){\\n            mpp[temp]++;\\n            temp = temp -> next;\\n        }\\n        while(d -> next){\\n            if(mpp.find(d) == mpp.end()){\\n                return d;\\n            }\\n            d = d -> next;\\n        }\\n        return NULL;\\n}\\n};"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Haha, my solution beats 100% of contestants."
                    },
                    {
                        "username": "spookie886",
                        "content": "did they change the tag from medium to easy?"
                    },
                    {
                        "username": "grind99",
                        "content": "bruh who prepared this question ???"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Is an approach using two stacks valid? I was thinking we can start from the end instead of the beginning."
                    },
                    {
                        "username": "bhavya_sri_yarlagadda",
                        "content": "What if skipA and skipB is 0? \\nI tried with this input, then it says Invalid input.\\nI think this testcase also needs to be covered"
                    },
                    {
                        "username": "zzjharry",
                        "content": "One of the best leetcode questions requires good understanding of linked list!"
                    },
                    {
                        "username": "Pulkit-mahajan",
                        "content": "In such questions, where we\\'re not allowed to modify the input array/linked list, is it acceptable if I were to modify it, but then again undo all changes before returning the final answer. \\nMy solution was accepted in this manner on this leetcode platform, but will such answer be acceptable in an interview. "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "No strictly adhere to what is asked in question others wise it sets  negative impact on the interviewer "
                    },
                    {
                        "username": "joshuamts12334",
                        "content": "Str_maxlenoc\\n\\nWrite a function that takes an array of strings and returns\\nthe longest string that appears in every parameter\\'s strings. If more that one\\nstring qualifies, it will return the one that appears first in the first\\nparameter. Note that the empty string technically appears in any string."
                    }
                ]
            },
            {
                "id": 1958922,
                "content": [
                    {
                        "username": "susahin80",
                        "content": "What an unclear question.\\nIt gives the intersectVal, skipA and skipB as inputs, but they are nor in the method signature!!!"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "Can Somone Tell Me Why This is Not Working??\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mpp;\\n        ListNode* temp = headA;\\n        ListNode* d = headB;\\n        while(temp -> next){\\n            mpp[temp]++;\\n            temp = temp -> next;\\n        }\\n        while(d -> next){\\n            if(mpp.find(d) == mpp.end()){\\n                return d;\\n            }\\n            d = d -> next;\\n        }\\n        return NULL;\\n}\\n};"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Haha, my solution beats 100% of contestants."
                    },
                    {
                        "username": "spookie886",
                        "content": "did they change the tag from medium to easy?"
                    },
                    {
                        "username": "grind99",
                        "content": "bruh who prepared this question ???"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Is an approach using two stacks valid? I was thinking we can start from the end instead of the beginning."
                    },
                    {
                        "username": "bhavya_sri_yarlagadda",
                        "content": "What if skipA and skipB is 0? \\nI tried with this input, then it says Invalid input.\\nI think this testcase also needs to be covered"
                    },
                    {
                        "username": "zzjharry",
                        "content": "One of the best leetcode questions requires good understanding of linked list!"
                    },
                    {
                        "username": "Pulkit-mahajan",
                        "content": "In such questions, where we\\'re not allowed to modify the input array/linked list, is it acceptable if I were to modify it, but then again undo all changes before returning the final answer. \\nMy solution was accepted in this manner on this leetcode platform, but will such answer be acceptable in an interview. "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "No strictly adhere to what is asked in question others wise it sets  negative impact on the interviewer "
                    },
                    {
                        "username": "joshuamts12334",
                        "content": "Str_maxlenoc\\n\\nWrite a function that takes an array of strings and returns\\nthe longest string that appears in every parameter\\'s strings. If more that one\\nstring qualifies, it will return the one that appears first in the first\\nparameter. Note that the empty string technically appears in any string."
                    }
                ]
            },
            {
                "id": 1957671,
                "content": [
                    {
                        "username": "susahin80",
                        "content": "What an unclear question.\\nIt gives the intersectVal, skipA and skipB as inputs, but they are nor in the method signature!!!"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "Can Somone Tell Me Why This is Not Working??\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mpp;\\n        ListNode* temp = headA;\\n        ListNode* d = headB;\\n        while(temp -> next){\\n            mpp[temp]++;\\n            temp = temp -> next;\\n        }\\n        while(d -> next){\\n            if(mpp.find(d) == mpp.end()){\\n                return d;\\n            }\\n            d = d -> next;\\n        }\\n        return NULL;\\n}\\n};"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Haha, my solution beats 100% of contestants."
                    },
                    {
                        "username": "spookie886",
                        "content": "did they change the tag from medium to easy?"
                    },
                    {
                        "username": "grind99",
                        "content": "bruh who prepared this question ???"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Is an approach using two stacks valid? I was thinking we can start from the end instead of the beginning."
                    },
                    {
                        "username": "bhavya_sri_yarlagadda",
                        "content": "What if skipA and skipB is 0? \\nI tried with this input, then it says Invalid input.\\nI think this testcase also needs to be covered"
                    },
                    {
                        "username": "zzjharry",
                        "content": "One of the best leetcode questions requires good understanding of linked list!"
                    },
                    {
                        "username": "Pulkit-mahajan",
                        "content": "In such questions, where we\\'re not allowed to modify the input array/linked list, is it acceptable if I were to modify it, but then again undo all changes before returning the final answer. \\nMy solution was accepted in this manner on this leetcode platform, but will such answer be acceptable in an interview. "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "No strictly adhere to what is asked in question others wise it sets  negative impact on the interviewer "
                    },
                    {
                        "username": "joshuamts12334",
                        "content": "Str_maxlenoc\\n\\nWrite a function that takes an array of strings and returns\\nthe longest string that appears in every parameter\\'s strings. If more that one\\nstring qualifies, it will return the one that appears first in the first\\nparameter. Note that the empty string technically appears in any string."
                    }
                ]
            },
            {
                "id": 1947312,
                "content": [
                    {
                        "username": "susahin80",
                        "content": "What an unclear question.\\nIt gives the intersectVal, skipA and skipB as inputs, but they are nor in the method signature!!!"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "Can Somone Tell Me Why This is Not Working??\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mpp;\\n        ListNode* temp = headA;\\n        ListNode* d = headB;\\n        while(temp -> next){\\n            mpp[temp]++;\\n            temp = temp -> next;\\n        }\\n        while(d -> next){\\n            if(mpp.find(d) == mpp.end()){\\n                return d;\\n            }\\n            d = d -> next;\\n        }\\n        return NULL;\\n}\\n};"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Haha, my solution beats 100% of contestants."
                    },
                    {
                        "username": "spookie886",
                        "content": "did they change the tag from medium to easy?"
                    },
                    {
                        "username": "grind99",
                        "content": "bruh who prepared this question ???"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Is an approach using two stacks valid? I was thinking we can start from the end instead of the beginning."
                    },
                    {
                        "username": "bhavya_sri_yarlagadda",
                        "content": "What if skipA and skipB is 0? \\nI tried with this input, then it says Invalid input.\\nI think this testcase also needs to be covered"
                    },
                    {
                        "username": "zzjharry",
                        "content": "One of the best leetcode questions requires good understanding of linked list!"
                    },
                    {
                        "username": "Pulkit-mahajan",
                        "content": "In such questions, where we\\'re not allowed to modify the input array/linked list, is it acceptable if I were to modify it, but then again undo all changes before returning the final answer. \\nMy solution was accepted in this manner on this leetcode platform, but will such answer be acceptable in an interview. "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "No strictly adhere to what is asked in question others wise it sets  negative impact on the interviewer "
                    },
                    {
                        "username": "joshuamts12334",
                        "content": "Str_maxlenoc\\n\\nWrite a function that takes an array of strings and returns\\nthe longest string that appears in every parameter\\'s strings. If more that one\\nstring qualifies, it will return the one that appears first in the first\\nparameter. Note that the empty string technically appears in any string."
                    }
                ]
            },
            {
                "id": 1947127,
                "content": [
                    {
                        "username": "susahin80",
                        "content": "What an unclear question.\\nIt gives the intersectVal, skipA and skipB as inputs, but they are nor in the method signature!!!"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "Can Somone Tell Me Why This is Not Working??\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mpp;\\n        ListNode* temp = headA;\\n        ListNode* d = headB;\\n        while(temp -> next){\\n            mpp[temp]++;\\n            temp = temp -> next;\\n        }\\n        while(d -> next){\\n            if(mpp.find(d) == mpp.end()){\\n                return d;\\n            }\\n            d = d -> next;\\n        }\\n        return NULL;\\n}\\n};"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Haha, my solution beats 100% of contestants."
                    },
                    {
                        "username": "spookie886",
                        "content": "did they change the tag from medium to easy?"
                    },
                    {
                        "username": "grind99",
                        "content": "bruh who prepared this question ???"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Is an approach using two stacks valid? I was thinking we can start from the end instead of the beginning."
                    },
                    {
                        "username": "bhavya_sri_yarlagadda",
                        "content": "What if skipA and skipB is 0? \\nI tried with this input, then it says Invalid input.\\nI think this testcase also needs to be covered"
                    },
                    {
                        "username": "zzjharry",
                        "content": "One of the best leetcode questions requires good understanding of linked list!"
                    },
                    {
                        "username": "Pulkit-mahajan",
                        "content": "In such questions, where we\\'re not allowed to modify the input array/linked list, is it acceptable if I were to modify it, but then again undo all changes before returning the final answer. \\nMy solution was accepted in this manner on this leetcode platform, but will such answer be acceptable in an interview. "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "No strictly adhere to what is asked in question others wise it sets  negative impact on the interviewer "
                    },
                    {
                        "username": "joshuamts12334",
                        "content": "Str_maxlenoc\\n\\nWrite a function that takes an array of strings and returns\\nthe longest string that appears in every parameter\\'s strings. If more that one\\nstring qualifies, it will return the one that appears first in the first\\nparameter. Note that the empty string technically appears in any string."
                    }
                ]
            },
            {
                "id": 1933524,
                "content": [
                    {
                        "username": "susahin80",
                        "content": "What an unclear question.\\nIt gives the intersectVal, skipA and skipB as inputs, but they are nor in the method signature!!!"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "Can Somone Tell Me Why This is Not Working??\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mpp;\\n        ListNode* temp = headA;\\n        ListNode* d = headB;\\n        while(temp -> next){\\n            mpp[temp]++;\\n            temp = temp -> next;\\n        }\\n        while(d -> next){\\n            if(mpp.find(d) == mpp.end()){\\n                return d;\\n            }\\n            d = d -> next;\\n        }\\n        return NULL;\\n}\\n};"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Haha, my solution beats 100% of contestants."
                    },
                    {
                        "username": "spookie886",
                        "content": "did they change the tag from medium to easy?"
                    },
                    {
                        "username": "grind99",
                        "content": "bruh who prepared this question ???"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Is an approach using two stacks valid? I was thinking we can start from the end instead of the beginning."
                    },
                    {
                        "username": "bhavya_sri_yarlagadda",
                        "content": "What if skipA and skipB is 0? \\nI tried with this input, then it says Invalid input.\\nI think this testcase also needs to be covered"
                    },
                    {
                        "username": "zzjharry",
                        "content": "One of the best leetcode questions requires good understanding of linked list!"
                    },
                    {
                        "username": "Pulkit-mahajan",
                        "content": "In such questions, where we\\'re not allowed to modify the input array/linked list, is it acceptable if I were to modify it, but then again undo all changes before returning the final answer. \\nMy solution was accepted in this manner on this leetcode platform, but will such answer be acceptable in an interview. "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "No strictly adhere to what is asked in question others wise it sets  negative impact on the interviewer "
                    },
                    {
                        "username": "joshuamts12334",
                        "content": "Str_maxlenoc\\n\\nWrite a function that takes an array of strings and returns\\nthe longest string that appears in every parameter\\'s strings. If more that one\\nstring qualifies, it will return the one that appears first in the first\\nparameter. Note that the empty string technically appears in any string."
                    }
                ]
            },
            {
                "id": 1922224,
                "content": [
                    {
                        "username": "susahin80",
                        "content": "What an unclear question.\\nIt gives the intersectVal, skipA and skipB as inputs, but they are nor in the method signature!!!"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "Can Somone Tell Me Why This is Not Working??\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mpp;\\n        ListNode* temp = headA;\\n        ListNode* d = headB;\\n        while(temp -> next){\\n            mpp[temp]++;\\n            temp = temp -> next;\\n        }\\n        while(d -> next){\\n            if(mpp.find(d) == mpp.end()){\\n                return d;\\n            }\\n            d = d -> next;\\n        }\\n        return NULL;\\n}\\n};"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Haha, my solution beats 100% of contestants."
                    },
                    {
                        "username": "spookie886",
                        "content": "did they change the tag from medium to easy?"
                    },
                    {
                        "username": "grind99",
                        "content": "bruh who prepared this question ???"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Is an approach using two stacks valid? I was thinking we can start from the end instead of the beginning."
                    },
                    {
                        "username": "bhavya_sri_yarlagadda",
                        "content": "What if skipA and skipB is 0? \\nI tried with this input, then it says Invalid input.\\nI think this testcase also needs to be covered"
                    },
                    {
                        "username": "zzjharry",
                        "content": "One of the best leetcode questions requires good understanding of linked list!"
                    },
                    {
                        "username": "Pulkit-mahajan",
                        "content": "In such questions, where we\\'re not allowed to modify the input array/linked list, is it acceptable if I were to modify it, but then again undo all changes before returning the final answer. \\nMy solution was accepted in this manner on this leetcode platform, but will such answer be acceptable in an interview. "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "No strictly adhere to what is asked in question others wise it sets  negative impact on the interviewer "
                    },
                    {
                        "username": "joshuamts12334",
                        "content": "Str_maxlenoc\\n\\nWrite a function that takes an array of strings and returns\\nthe longest string that appears in every parameter\\'s strings. If more that one\\nstring qualifies, it will return the one that appears first in the first\\nparameter. Note that the empty string technically appears in any string."
                    }
                ]
            },
            {
                "id": 1895867,
                "content": [
                    {
                        "username": "susahin80",
                        "content": "What an unclear question.\\nIt gives the intersectVal, skipA and skipB as inputs, but they are nor in the method signature!!!"
                    },
                    {
                        "username": "vivekvermaa",
                        "content": "Can Somone Tell Me Why This is Not Working??\\n\\nclass Solution {\\npublic:\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        unordered_map<ListNode*, int> mpp;\\n        ListNode* temp = headA;\\n        ListNode* d = headB;\\n        while(temp -> next){\\n            mpp[temp]++;\\n            temp = temp -> next;\\n        }\\n        while(d -> next){\\n            if(mpp.find(d) == mpp.end()){\\n                return d;\\n            }\\n            d = d -> next;\\n        }\\n        return NULL;\\n}\\n};"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Haha, my solution beats 100% of contestants."
                    },
                    {
                        "username": "spookie886",
                        "content": "did they change the tag from medium to easy?"
                    },
                    {
                        "username": "grind99",
                        "content": "bruh who prepared this question ???"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Is an approach using two stacks valid? I was thinking we can start from the end instead of the beginning."
                    },
                    {
                        "username": "bhavya_sri_yarlagadda",
                        "content": "What if skipA and skipB is 0? \\nI tried with this input, then it says Invalid input.\\nI think this testcase also needs to be covered"
                    },
                    {
                        "username": "zzjharry",
                        "content": "One of the best leetcode questions requires good understanding of linked list!"
                    },
                    {
                        "username": "Pulkit-mahajan",
                        "content": "In such questions, where we\\'re not allowed to modify the input array/linked list, is it acceptable if I were to modify it, but then again undo all changes before returning the final answer. \\nMy solution was accepted in this manner on this leetcode platform, but will such answer be acceptable in an interview. "
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "No strictly adhere to what is asked in question others wise it sets  negative impact on the interviewer "
                    },
                    {
                        "username": "joshuamts12334",
                        "content": "Str_maxlenoc\\n\\nWrite a function that takes an array of strings and returns\\nthe longest string that appears in every parameter\\'s strings. If more that one\\nstring qualifies, it will return the one that appears first in the first\\nparameter. Note that the empty string technically appears in any string."
                    }
                ]
            },
            {
                "id": 1895677,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "Hint: For an O(m + n) time complexity and O(1) space complexity solution, use the fact that the node values are positive. "
                    },
                    {
                        "username": "tourist_111",
                        "content": "Is m> n guaranteed?\\n"
                    },
                    {
                        "username": "liorbm1",
                        "content": "I know algorithm from university that doesn't work here.... \nwhat is going on?\n\nalso, in java it works, but not in Python...\nleetcode, please fix the unit testing."
                    },
                    {
                        "username": "mukadas026",
                        "content": "if you\\'re wondering how to deal with list with unequal lengths, say len(a) = 8 and len(b) = 5, you can find the difference which is 3 and move the head of listA forward 3 times before trying to find the intersection."
                    },
                    {
                        "username": "mukadas026",
                        "content": "In the first example with listA=[4,1,8,4,5] and listB=[5,6,1,8,4,5], the intersection node is 8 and not one because the intersection node has to have one reference in memory, and the two 1s on both lists are stored at different locations. So instead of doing headA.val == headB.val, do headA == headB."
                    },
                    {
                        "username": "m-sakthi",
                        "content": "The question states that the nodes are equal means\\n\\nSay for example             `n1 = n2 = new ListNode(8)`\\nSo we need to check     `n1 === n2`\\nnot                                   `n1.val === n2.val`\\n\\nHope this helps."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "Easy c++ solution..\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3218662/easy-c-solution-beats-98-in-memory/"
                    },
                    {
                        "username": "carrtesy",
                        "content": "where are skipA and skipB for python?"
                    },
                    {
                        "username": "chirag123490",
                        "content": "        if(headA == NULL || headB == NULL)return NULL;\\n        ListNode*ptr = headA;\\n        ListNode*ptr1 = headB;\\n        int count,count1 = 0;\\n        while(ptr != NULL){\\n          count++;\\n          ptr = ptr -> next;\\n        }\\n        while(ptr1 != NULL){\\n            count1++;\\n            ptr1 = ptr1 -> next;\\n        }\\n        ptr = headA;\\n        ptr1 = headB;\\n        int diff = abs(count - count1);\\n        if(count > count1){\\n        while(diff--){\\n            ptr = ptr -> next;\\n        }\\n        }\\n        if(count1 > count){\\n            while(diff--){\\n                ptr1 = ptr1 -> next;\\n            }\\n        }\\n        \\n        \\n        while(ptr -> val != ptr1 -> val){\\n            ptr = ptr -> next;\\n            ptr1 = ptr1 -> next;\\n        }\\n        return ptr;\\n    }\\n\\nidk where i am mistake ?"
                    },
                    {
                        "username": "androidcoder",
                        "content": "what is the use of the symbol\\n if(lenA >lenB)\\n        {\\n            while(diff-- > 0)\\n            {\\n                tempA=tempA.next;\\n            }\\n\\n        }\\n-- > this symbol means\\n"
                    }
                ]
            },
            {
                "id": 1891235,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "Hint: For an O(m + n) time complexity and O(1) space complexity solution, use the fact that the node values are positive. "
                    },
                    {
                        "username": "tourist_111",
                        "content": "Is m> n guaranteed?\\n"
                    },
                    {
                        "username": "liorbm1",
                        "content": "I know algorithm from university that doesn't work here.... \nwhat is going on?\n\nalso, in java it works, but not in Python...\nleetcode, please fix the unit testing."
                    },
                    {
                        "username": "mukadas026",
                        "content": "if you\\'re wondering how to deal with list with unequal lengths, say len(a) = 8 and len(b) = 5, you can find the difference which is 3 and move the head of listA forward 3 times before trying to find the intersection."
                    },
                    {
                        "username": "mukadas026",
                        "content": "In the first example with listA=[4,1,8,4,5] and listB=[5,6,1,8,4,5], the intersection node is 8 and not one because the intersection node has to have one reference in memory, and the two 1s on both lists are stored at different locations. So instead of doing headA.val == headB.val, do headA == headB."
                    },
                    {
                        "username": "m-sakthi",
                        "content": "The question states that the nodes are equal means\\n\\nSay for example             `n1 = n2 = new ListNode(8)`\\nSo we need to check     `n1 === n2`\\nnot                                   `n1.val === n2.val`\\n\\nHope this helps."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "Easy c++ solution..\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3218662/easy-c-solution-beats-98-in-memory/"
                    },
                    {
                        "username": "carrtesy",
                        "content": "where are skipA and skipB for python?"
                    },
                    {
                        "username": "chirag123490",
                        "content": "        if(headA == NULL || headB == NULL)return NULL;\\n        ListNode*ptr = headA;\\n        ListNode*ptr1 = headB;\\n        int count,count1 = 0;\\n        while(ptr != NULL){\\n          count++;\\n          ptr = ptr -> next;\\n        }\\n        while(ptr1 != NULL){\\n            count1++;\\n            ptr1 = ptr1 -> next;\\n        }\\n        ptr = headA;\\n        ptr1 = headB;\\n        int diff = abs(count - count1);\\n        if(count > count1){\\n        while(diff--){\\n            ptr = ptr -> next;\\n        }\\n        }\\n        if(count1 > count){\\n            while(diff--){\\n                ptr1 = ptr1 -> next;\\n            }\\n        }\\n        \\n        \\n        while(ptr -> val != ptr1 -> val){\\n            ptr = ptr -> next;\\n            ptr1 = ptr1 -> next;\\n        }\\n        return ptr;\\n    }\\n\\nidk where i am mistake ?"
                    },
                    {
                        "username": "androidcoder",
                        "content": "what is the use of the symbol\\n if(lenA >lenB)\\n        {\\n            while(diff-- > 0)\\n            {\\n                tempA=tempA.next;\\n            }\\n\\n        }\\n-- > this symbol means\\n"
                    }
                ]
            },
            {
                "id": 1863327,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "Hint: For an O(m + n) time complexity and O(1) space complexity solution, use the fact that the node values are positive. "
                    },
                    {
                        "username": "tourist_111",
                        "content": "Is m> n guaranteed?\\n"
                    },
                    {
                        "username": "liorbm1",
                        "content": "I know algorithm from university that doesn't work here.... \nwhat is going on?\n\nalso, in java it works, but not in Python...\nleetcode, please fix the unit testing."
                    },
                    {
                        "username": "mukadas026",
                        "content": "if you\\'re wondering how to deal with list with unequal lengths, say len(a) = 8 and len(b) = 5, you can find the difference which is 3 and move the head of listA forward 3 times before trying to find the intersection."
                    },
                    {
                        "username": "mukadas026",
                        "content": "In the first example with listA=[4,1,8,4,5] and listB=[5,6,1,8,4,5], the intersection node is 8 and not one because the intersection node has to have one reference in memory, and the two 1s on both lists are stored at different locations. So instead of doing headA.val == headB.val, do headA == headB."
                    },
                    {
                        "username": "m-sakthi",
                        "content": "The question states that the nodes are equal means\\n\\nSay for example             `n1 = n2 = new ListNode(8)`\\nSo we need to check     `n1 === n2`\\nnot                                   `n1.val === n2.val`\\n\\nHope this helps."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "Easy c++ solution..\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3218662/easy-c-solution-beats-98-in-memory/"
                    },
                    {
                        "username": "carrtesy",
                        "content": "where are skipA and skipB for python?"
                    },
                    {
                        "username": "chirag123490",
                        "content": "        if(headA == NULL || headB == NULL)return NULL;\\n        ListNode*ptr = headA;\\n        ListNode*ptr1 = headB;\\n        int count,count1 = 0;\\n        while(ptr != NULL){\\n          count++;\\n          ptr = ptr -> next;\\n        }\\n        while(ptr1 != NULL){\\n            count1++;\\n            ptr1 = ptr1 -> next;\\n        }\\n        ptr = headA;\\n        ptr1 = headB;\\n        int diff = abs(count - count1);\\n        if(count > count1){\\n        while(diff--){\\n            ptr = ptr -> next;\\n        }\\n        }\\n        if(count1 > count){\\n            while(diff--){\\n                ptr1 = ptr1 -> next;\\n            }\\n        }\\n        \\n        \\n        while(ptr -> val != ptr1 -> val){\\n            ptr = ptr -> next;\\n            ptr1 = ptr1 -> next;\\n        }\\n        return ptr;\\n    }\\n\\nidk where i am mistake ?"
                    },
                    {
                        "username": "androidcoder",
                        "content": "what is the use of the symbol\\n if(lenA >lenB)\\n        {\\n            while(diff-- > 0)\\n            {\\n                tempA=tempA.next;\\n            }\\n\\n        }\\n-- > this symbol means\\n"
                    }
                ]
            },
            {
                "id": 1850854,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "Hint: For an O(m + n) time complexity and O(1) space complexity solution, use the fact that the node values are positive. "
                    },
                    {
                        "username": "tourist_111",
                        "content": "Is m> n guaranteed?\\n"
                    },
                    {
                        "username": "liorbm1",
                        "content": "I know algorithm from university that doesn't work here.... \nwhat is going on?\n\nalso, in java it works, but not in Python...\nleetcode, please fix the unit testing."
                    },
                    {
                        "username": "mukadas026",
                        "content": "if you\\'re wondering how to deal with list with unequal lengths, say len(a) = 8 and len(b) = 5, you can find the difference which is 3 and move the head of listA forward 3 times before trying to find the intersection."
                    },
                    {
                        "username": "mukadas026",
                        "content": "In the first example with listA=[4,1,8,4,5] and listB=[5,6,1,8,4,5], the intersection node is 8 and not one because the intersection node has to have one reference in memory, and the two 1s on both lists are stored at different locations. So instead of doing headA.val == headB.val, do headA == headB."
                    },
                    {
                        "username": "m-sakthi",
                        "content": "The question states that the nodes are equal means\\n\\nSay for example             `n1 = n2 = new ListNode(8)`\\nSo we need to check     `n1 === n2`\\nnot                                   `n1.val === n2.val`\\n\\nHope this helps."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "Easy c++ solution..\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3218662/easy-c-solution-beats-98-in-memory/"
                    },
                    {
                        "username": "carrtesy",
                        "content": "where are skipA and skipB for python?"
                    },
                    {
                        "username": "chirag123490",
                        "content": "        if(headA == NULL || headB == NULL)return NULL;\\n        ListNode*ptr = headA;\\n        ListNode*ptr1 = headB;\\n        int count,count1 = 0;\\n        while(ptr != NULL){\\n          count++;\\n          ptr = ptr -> next;\\n        }\\n        while(ptr1 != NULL){\\n            count1++;\\n            ptr1 = ptr1 -> next;\\n        }\\n        ptr = headA;\\n        ptr1 = headB;\\n        int diff = abs(count - count1);\\n        if(count > count1){\\n        while(diff--){\\n            ptr = ptr -> next;\\n        }\\n        }\\n        if(count1 > count){\\n            while(diff--){\\n                ptr1 = ptr1 -> next;\\n            }\\n        }\\n        \\n        \\n        while(ptr -> val != ptr1 -> val){\\n            ptr = ptr -> next;\\n            ptr1 = ptr1 -> next;\\n        }\\n        return ptr;\\n    }\\n\\nidk where i am mistake ?"
                    },
                    {
                        "username": "androidcoder",
                        "content": "what is the use of the symbol\\n if(lenA >lenB)\\n        {\\n            while(diff-- > 0)\\n            {\\n                tempA=tempA.next;\\n            }\\n\\n        }\\n-- > this symbol means\\n"
                    }
                ]
            },
            {
                "id": 1850704,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "Hint: For an O(m + n) time complexity and O(1) space complexity solution, use the fact that the node values are positive. "
                    },
                    {
                        "username": "tourist_111",
                        "content": "Is m> n guaranteed?\\n"
                    },
                    {
                        "username": "liorbm1",
                        "content": "I know algorithm from university that doesn't work here.... \nwhat is going on?\n\nalso, in java it works, but not in Python...\nleetcode, please fix the unit testing."
                    },
                    {
                        "username": "mukadas026",
                        "content": "if you\\'re wondering how to deal with list with unequal lengths, say len(a) = 8 and len(b) = 5, you can find the difference which is 3 and move the head of listA forward 3 times before trying to find the intersection."
                    },
                    {
                        "username": "mukadas026",
                        "content": "In the first example with listA=[4,1,8,4,5] and listB=[5,6,1,8,4,5], the intersection node is 8 and not one because the intersection node has to have one reference in memory, and the two 1s on both lists are stored at different locations. So instead of doing headA.val == headB.val, do headA == headB."
                    },
                    {
                        "username": "m-sakthi",
                        "content": "The question states that the nodes are equal means\\n\\nSay for example             `n1 = n2 = new ListNode(8)`\\nSo we need to check     `n1 === n2`\\nnot                                   `n1.val === n2.val`\\n\\nHope this helps."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "Easy c++ solution..\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3218662/easy-c-solution-beats-98-in-memory/"
                    },
                    {
                        "username": "carrtesy",
                        "content": "where are skipA and skipB for python?"
                    },
                    {
                        "username": "chirag123490",
                        "content": "        if(headA == NULL || headB == NULL)return NULL;\\n        ListNode*ptr = headA;\\n        ListNode*ptr1 = headB;\\n        int count,count1 = 0;\\n        while(ptr != NULL){\\n          count++;\\n          ptr = ptr -> next;\\n        }\\n        while(ptr1 != NULL){\\n            count1++;\\n            ptr1 = ptr1 -> next;\\n        }\\n        ptr = headA;\\n        ptr1 = headB;\\n        int diff = abs(count - count1);\\n        if(count > count1){\\n        while(diff--){\\n            ptr = ptr -> next;\\n        }\\n        }\\n        if(count1 > count){\\n            while(diff--){\\n                ptr1 = ptr1 -> next;\\n            }\\n        }\\n        \\n        \\n        while(ptr -> val != ptr1 -> val){\\n            ptr = ptr -> next;\\n            ptr1 = ptr1 -> next;\\n        }\\n        return ptr;\\n    }\\n\\nidk where i am mistake ?"
                    },
                    {
                        "username": "androidcoder",
                        "content": "what is the use of the symbol\\n if(lenA >lenB)\\n        {\\n            while(diff-- > 0)\\n            {\\n                tempA=tempA.next;\\n            }\\n\\n        }\\n-- > this symbol means\\n"
                    }
                ]
            },
            {
                "id": 1813475,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "Hint: For an O(m + n) time complexity and O(1) space complexity solution, use the fact that the node values are positive. "
                    },
                    {
                        "username": "tourist_111",
                        "content": "Is m> n guaranteed?\\n"
                    },
                    {
                        "username": "liorbm1",
                        "content": "I know algorithm from university that doesn't work here.... \nwhat is going on?\n\nalso, in java it works, but not in Python...\nleetcode, please fix the unit testing."
                    },
                    {
                        "username": "mukadas026",
                        "content": "if you\\'re wondering how to deal with list with unequal lengths, say len(a) = 8 and len(b) = 5, you can find the difference which is 3 and move the head of listA forward 3 times before trying to find the intersection."
                    },
                    {
                        "username": "mukadas026",
                        "content": "In the first example with listA=[4,1,8,4,5] and listB=[5,6,1,8,4,5], the intersection node is 8 and not one because the intersection node has to have one reference in memory, and the two 1s on both lists are stored at different locations. So instead of doing headA.val == headB.val, do headA == headB."
                    },
                    {
                        "username": "m-sakthi",
                        "content": "The question states that the nodes are equal means\\n\\nSay for example             `n1 = n2 = new ListNode(8)`\\nSo we need to check     `n1 === n2`\\nnot                                   `n1.val === n2.val`\\n\\nHope this helps."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "Easy c++ solution..\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3218662/easy-c-solution-beats-98-in-memory/"
                    },
                    {
                        "username": "carrtesy",
                        "content": "where are skipA and skipB for python?"
                    },
                    {
                        "username": "chirag123490",
                        "content": "        if(headA == NULL || headB == NULL)return NULL;\\n        ListNode*ptr = headA;\\n        ListNode*ptr1 = headB;\\n        int count,count1 = 0;\\n        while(ptr != NULL){\\n          count++;\\n          ptr = ptr -> next;\\n        }\\n        while(ptr1 != NULL){\\n            count1++;\\n            ptr1 = ptr1 -> next;\\n        }\\n        ptr = headA;\\n        ptr1 = headB;\\n        int diff = abs(count - count1);\\n        if(count > count1){\\n        while(diff--){\\n            ptr = ptr -> next;\\n        }\\n        }\\n        if(count1 > count){\\n            while(diff--){\\n                ptr1 = ptr1 -> next;\\n            }\\n        }\\n        \\n        \\n        while(ptr -> val != ptr1 -> val){\\n            ptr = ptr -> next;\\n            ptr1 = ptr1 -> next;\\n        }\\n        return ptr;\\n    }\\n\\nidk where i am mistake ?"
                    },
                    {
                        "username": "androidcoder",
                        "content": "what is the use of the symbol\\n if(lenA >lenB)\\n        {\\n            while(diff-- > 0)\\n            {\\n                tempA=tempA.next;\\n            }\\n\\n        }\\n-- > this symbol means\\n"
                    }
                ]
            },
            {
                "id": 1810882,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "Hint: For an O(m + n) time complexity and O(1) space complexity solution, use the fact that the node values are positive. "
                    },
                    {
                        "username": "tourist_111",
                        "content": "Is m> n guaranteed?\\n"
                    },
                    {
                        "username": "liorbm1",
                        "content": "I know algorithm from university that doesn't work here.... \nwhat is going on?\n\nalso, in java it works, but not in Python...\nleetcode, please fix the unit testing."
                    },
                    {
                        "username": "mukadas026",
                        "content": "if you\\'re wondering how to deal with list with unequal lengths, say len(a) = 8 and len(b) = 5, you can find the difference which is 3 and move the head of listA forward 3 times before trying to find the intersection."
                    },
                    {
                        "username": "mukadas026",
                        "content": "In the first example with listA=[4,1,8,4,5] and listB=[5,6,1,8,4,5], the intersection node is 8 and not one because the intersection node has to have one reference in memory, and the two 1s on both lists are stored at different locations. So instead of doing headA.val == headB.val, do headA == headB."
                    },
                    {
                        "username": "m-sakthi",
                        "content": "The question states that the nodes are equal means\\n\\nSay for example             `n1 = n2 = new ListNode(8)`\\nSo we need to check     `n1 === n2`\\nnot                                   `n1.val === n2.val`\\n\\nHope this helps."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "Easy c++ solution..\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3218662/easy-c-solution-beats-98-in-memory/"
                    },
                    {
                        "username": "carrtesy",
                        "content": "where are skipA and skipB for python?"
                    },
                    {
                        "username": "chirag123490",
                        "content": "        if(headA == NULL || headB == NULL)return NULL;\\n        ListNode*ptr = headA;\\n        ListNode*ptr1 = headB;\\n        int count,count1 = 0;\\n        while(ptr != NULL){\\n          count++;\\n          ptr = ptr -> next;\\n        }\\n        while(ptr1 != NULL){\\n            count1++;\\n            ptr1 = ptr1 -> next;\\n        }\\n        ptr = headA;\\n        ptr1 = headB;\\n        int diff = abs(count - count1);\\n        if(count > count1){\\n        while(diff--){\\n            ptr = ptr -> next;\\n        }\\n        }\\n        if(count1 > count){\\n            while(diff--){\\n                ptr1 = ptr1 -> next;\\n            }\\n        }\\n        \\n        \\n        while(ptr -> val != ptr1 -> val){\\n            ptr = ptr -> next;\\n            ptr1 = ptr1 -> next;\\n        }\\n        return ptr;\\n    }\\n\\nidk where i am mistake ?"
                    },
                    {
                        "username": "androidcoder",
                        "content": "what is the use of the symbol\\n if(lenA >lenB)\\n        {\\n            while(diff-- > 0)\\n            {\\n                tempA=tempA.next;\\n            }\\n\\n        }\\n-- > this symbol means\\n"
                    }
                ]
            },
            {
                "id": 1805167,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "Hint: For an O(m + n) time complexity and O(1) space complexity solution, use the fact that the node values are positive. "
                    },
                    {
                        "username": "tourist_111",
                        "content": "Is m> n guaranteed?\\n"
                    },
                    {
                        "username": "liorbm1",
                        "content": "I know algorithm from university that doesn't work here.... \nwhat is going on?\n\nalso, in java it works, but not in Python...\nleetcode, please fix the unit testing."
                    },
                    {
                        "username": "mukadas026",
                        "content": "if you\\'re wondering how to deal with list with unequal lengths, say len(a) = 8 and len(b) = 5, you can find the difference which is 3 and move the head of listA forward 3 times before trying to find the intersection."
                    },
                    {
                        "username": "mukadas026",
                        "content": "In the first example with listA=[4,1,8,4,5] and listB=[5,6,1,8,4,5], the intersection node is 8 and not one because the intersection node has to have one reference in memory, and the two 1s on both lists are stored at different locations. So instead of doing headA.val == headB.val, do headA == headB."
                    },
                    {
                        "username": "m-sakthi",
                        "content": "The question states that the nodes are equal means\\n\\nSay for example             `n1 = n2 = new ListNode(8)`\\nSo we need to check     `n1 === n2`\\nnot                                   `n1.val === n2.val`\\n\\nHope this helps."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "Easy c++ solution..\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3218662/easy-c-solution-beats-98-in-memory/"
                    },
                    {
                        "username": "carrtesy",
                        "content": "where are skipA and skipB for python?"
                    },
                    {
                        "username": "chirag123490",
                        "content": "        if(headA == NULL || headB == NULL)return NULL;\\n        ListNode*ptr = headA;\\n        ListNode*ptr1 = headB;\\n        int count,count1 = 0;\\n        while(ptr != NULL){\\n          count++;\\n          ptr = ptr -> next;\\n        }\\n        while(ptr1 != NULL){\\n            count1++;\\n            ptr1 = ptr1 -> next;\\n        }\\n        ptr = headA;\\n        ptr1 = headB;\\n        int diff = abs(count - count1);\\n        if(count > count1){\\n        while(diff--){\\n            ptr = ptr -> next;\\n        }\\n        }\\n        if(count1 > count){\\n            while(diff--){\\n                ptr1 = ptr1 -> next;\\n            }\\n        }\\n        \\n        \\n        while(ptr -> val != ptr1 -> val){\\n            ptr = ptr -> next;\\n            ptr1 = ptr1 -> next;\\n        }\\n        return ptr;\\n    }\\n\\nidk where i am mistake ?"
                    },
                    {
                        "username": "androidcoder",
                        "content": "what is the use of the symbol\\n if(lenA >lenB)\\n        {\\n            while(diff-- > 0)\\n            {\\n                tempA=tempA.next;\\n            }\\n\\n        }\\n-- > this symbol means\\n"
                    }
                ]
            },
            {
                "id": 1794944,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "Hint: For an O(m + n) time complexity and O(1) space complexity solution, use the fact that the node values are positive. "
                    },
                    {
                        "username": "tourist_111",
                        "content": "Is m> n guaranteed?\\n"
                    },
                    {
                        "username": "liorbm1",
                        "content": "I know algorithm from university that doesn't work here.... \nwhat is going on?\n\nalso, in java it works, but not in Python...\nleetcode, please fix the unit testing."
                    },
                    {
                        "username": "mukadas026",
                        "content": "if you\\'re wondering how to deal with list with unequal lengths, say len(a) = 8 and len(b) = 5, you can find the difference which is 3 and move the head of listA forward 3 times before trying to find the intersection."
                    },
                    {
                        "username": "mukadas026",
                        "content": "In the first example with listA=[4,1,8,4,5] and listB=[5,6,1,8,4,5], the intersection node is 8 and not one because the intersection node has to have one reference in memory, and the two 1s on both lists are stored at different locations. So instead of doing headA.val == headB.val, do headA == headB."
                    },
                    {
                        "username": "m-sakthi",
                        "content": "The question states that the nodes are equal means\\n\\nSay for example             `n1 = n2 = new ListNode(8)`\\nSo we need to check     `n1 === n2`\\nnot                                   `n1.val === n2.val`\\n\\nHope this helps."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "Easy c++ solution..\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3218662/easy-c-solution-beats-98-in-memory/"
                    },
                    {
                        "username": "carrtesy",
                        "content": "where are skipA and skipB for python?"
                    },
                    {
                        "username": "chirag123490",
                        "content": "        if(headA == NULL || headB == NULL)return NULL;\\n        ListNode*ptr = headA;\\n        ListNode*ptr1 = headB;\\n        int count,count1 = 0;\\n        while(ptr != NULL){\\n          count++;\\n          ptr = ptr -> next;\\n        }\\n        while(ptr1 != NULL){\\n            count1++;\\n            ptr1 = ptr1 -> next;\\n        }\\n        ptr = headA;\\n        ptr1 = headB;\\n        int diff = abs(count - count1);\\n        if(count > count1){\\n        while(diff--){\\n            ptr = ptr -> next;\\n        }\\n        }\\n        if(count1 > count){\\n            while(diff--){\\n                ptr1 = ptr1 -> next;\\n            }\\n        }\\n        \\n        \\n        while(ptr -> val != ptr1 -> val){\\n            ptr = ptr -> next;\\n            ptr1 = ptr1 -> next;\\n        }\\n        return ptr;\\n    }\\n\\nidk where i am mistake ?"
                    },
                    {
                        "username": "androidcoder",
                        "content": "what is the use of the symbol\\n if(lenA >lenB)\\n        {\\n            while(diff-- > 0)\\n            {\\n                tempA=tempA.next;\\n            }\\n\\n        }\\n-- > this symbol means\\n"
                    }
                ]
            },
            {
                "id": 1793378,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "Hint: For an O(m + n) time complexity and O(1) space complexity solution, use the fact that the node values are positive. "
                    },
                    {
                        "username": "tourist_111",
                        "content": "Is m> n guaranteed?\\n"
                    },
                    {
                        "username": "liorbm1",
                        "content": "I know algorithm from university that doesn't work here.... \nwhat is going on?\n\nalso, in java it works, but not in Python...\nleetcode, please fix the unit testing."
                    },
                    {
                        "username": "mukadas026",
                        "content": "if you\\'re wondering how to deal with list with unequal lengths, say len(a) = 8 and len(b) = 5, you can find the difference which is 3 and move the head of listA forward 3 times before trying to find the intersection."
                    },
                    {
                        "username": "mukadas026",
                        "content": "In the first example with listA=[4,1,8,4,5] and listB=[5,6,1,8,4,5], the intersection node is 8 and not one because the intersection node has to have one reference in memory, and the two 1s on both lists are stored at different locations. So instead of doing headA.val == headB.val, do headA == headB."
                    },
                    {
                        "username": "m-sakthi",
                        "content": "The question states that the nodes are equal means\\n\\nSay for example             `n1 = n2 = new ListNode(8)`\\nSo we need to check     `n1 === n2`\\nnot                                   `n1.val === n2.val`\\n\\nHope this helps."
                    },
                    {
                        "username": "grubakuni7",
                        "content": "Easy c++ solution..\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3218662/easy-c-solution-beats-98-in-memory/"
                    },
                    {
                        "username": "carrtesy",
                        "content": "where are skipA and skipB for python?"
                    },
                    {
                        "username": "chirag123490",
                        "content": "        if(headA == NULL || headB == NULL)return NULL;\\n        ListNode*ptr = headA;\\n        ListNode*ptr1 = headB;\\n        int count,count1 = 0;\\n        while(ptr != NULL){\\n          count++;\\n          ptr = ptr -> next;\\n        }\\n        while(ptr1 != NULL){\\n            count1++;\\n            ptr1 = ptr1 -> next;\\n        }\\n        ptr = headA;\\n        ptr1 = headB;\\n        int diff = abs(count - count1);\\n        if(count > count1){\\n        while(diff--){\\n            ptr = ptr -> next;\\n        }\\n        }\\n        if(count1 > count){\\n            while(diff--){\\n                ptr1 = ptr1 -> next;\\n            }\\n        }\\n        \\n        \\n        while(ptr -> val != ptr1 -> val){\\n            ptr = ptr -> next;\\n            ptr1 = ptr1 -> next;\\n        }\\n        return ptr;\\n    }\\n\\nidk where i am mistake ?"
                    },
                    {
                        "username": "androidcoder",
                        "content": "what is the use of the symbol\\n if(lenA >lenB)\\n        {\\n            while(diff-- > 0)\\n            {\\n                tempA=tempA.next;\\n            }\\n\\n        }\\n-- > this symbol means\\n"
                    }
                ]
            },
            {
                "id": 1781684,
                "content": [
                    {
                        "username": "Deming98",
                        "content": "I want to use the two points to solve the question, but get the Time Limit Exceeded.\\nCould anyone tell me the reason? \\nThanks a lot!\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tempA = headA, *tempB = headB;\\n        while (tempA != tempB) {\\n            if (tempA->next != NULL) { tempA = tempA->next;}\\n            else { tempA->next = headB;}\\n            if (tempB->next != NULL) { tempB = tempB->next;}\\n            else { tempB->next = headA; }\\n        }\\n        return tempA;\\n    }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you have created cycle by connecting temp to head "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) \\n{\\n    if(headA == NULL || headB == NULL) // for checking 1st node head is null and 2nd not Null and both null head and vice versa \\n    {\\n        return NULL ;\\n    }\\n    struct ListNode *l1 = headA ; // just for traversal \\n    struct ListNode *l2 = headB ;\\n    while(l1 != l2)   // checking metting point of both pointer \\n    {\\n        l1 = (l1 == NULL)?headB : l1->next ;\\n        l2 = (l2 == NULL) ? headA : l2->next ;\\n    }\\n    return l1 ; \\nIn this the basic rule is that we are first traversing 1st ll fully then put that pointer to head of another ll . Similarly for 1st pointer ll . \\nThan after that when we move interchanged pointer they will meet at point which will be intersection point of LL . If not LL intersecting then also these will meet at NULL . \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "solution with O(M+N) run time and O(N) space \\nwith explanation\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3055419/js-run-time-o-n-m-space-o-n-explanation/"
                    },
                    {
                        "username": "Femalopper",
                        "content": "What really helped me to understand the case with listA = [4,1,8,4,5], listB = [5,6,1,8,4,5] and why the intersection is 8 and not 1 is lists representation in the following way (below), the objects are equal by reference, we can create const intersection and make it as a common link in list1 and list2 (this is the unique same reference for two objects - list1 and list2).\\nconst intersection = {\\n  val: 8,\\n  next: {\\n    val: 4,\\n    next: {\\n      val: 5,\\n      next: null,\\n    },\\n  },\\n};\\n\\nconst list1 = {\\n  val: 4,\\n  next: {\\n    val: 1,\\n    next: intersection,\\n  },\\n};\\n\\nconst list2 = {\\n  val: 5,\\n  next: {\\n    val: 6,\\n    next: {\\n      val: 1,\\n      next: intersection,\\n    },\\n  },\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "space efficient solution with quadratic time complexity\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/877440572/"
                    },
                    {
                        "username": "Sivarajavel",
                        "content": "how to get skip values?"
                    },
                    {
                        "username": "Lazarus_10",
                        "content": "On the first para it says \"If the two linked lists have no intersection at all, return null\".\\nBut I don\\'t think there are any test cases for that."
                    },
                    {
                        "username": "oscarcambridge",
                        "content": "Can anyone explain for me please why this code exceed time limit? This is similar to the solution posted by major solution. But I change the if statement saying that if the next node is null, then pointer jumps to the other linked list.\\n\\n ` `\\n\\n        a,b = headA,headB\\n        while a != b:\\n            if not a.next:\\n                a = headB\\n            else:\\n                a = a.next\\n            if not b.next:\\n                b = headA\\n            else:\\n                b = b.next\\n        return a\\n ` `"
                    }
                ]
            },
            {
                "id": 1769742,
                "content": [
                    {
                        "username": "Deming98",
                        "content": "I want to use the two points to solve the question, but get the Time Limit Exceeded.\\nCould anyone tell me the reason? \\nThanks a lot!\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tempA = headA, *tempB = headB;\\n        while (tempA != tempB) {\\n            if (tempA->next != NULL) { tempA = tempA->next;}\\n            else { tempA->next = headB;}\\n            if (tempB->next != NULL) { tempB = tempB->next;}\\n            else { tempB->next = headA; }\\n        }\\n        return tempA;\\n    }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you have created cycle by connecting temp to head "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) \\n{\\n    if(headA == NULL || headB == NULL) // for checking 1st node head is null and 2nd not Null and both null head and vice versa \\n    {\\n        return NULL ;\\n    }\\n    struct ListNode *l1 = headA ; // just for traversal \\n    struct ListNode *l2 = headB ;\\n    while(l1 != l2)   // checking metting point of both pointer \\n    {\\n        l1 = (l1 == NULL)?headB : l1->next ;\\n        l2 = (l2 == NULL) ? headA : l2->next ;\\n    }\\n    return l1 ; \\nIn this the basic rule is that we are first traversing 1st ll fully then put that pointer to head of another ll . Similarly for 1st pointer ll . \\nThan after that when we move interchanged pointer they will meet at point which will be intersection point of LL . If not LL intersecting then also these will meet at NULL . \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "solution with O(M+N) run time and O(N) space \\nwith explanation\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3055419/js-run-time-o-n-m-space-o-n-explanation/"
                    },
                    {
                        "username": "Femalopper",
                        "content": "What really helped me to understand the case with listA = [4,1,8,4,5], listB = [5,6,1,8,4,5] and why the intersection is 8 and not 1 is lists representation in the following way (below), the objects are equal by reference, we can create const intersection and make it as a common link in list1 and list2 (this is the unique same reference for two objects - list1 and list2).\\nconst intersection = {\\n  val: 8,\\n  next: {\\n    val: 4,\\n    next: {\\n      val: 5,\\n      next: null,\\n    },\\n  },\\n};\\n\\nconst list1 = {\\n  val: 4,\\n  next: {\\n    val: 1,\\n    next: intersection,\\n  },\\n};\\n\\nconst list2 = {\\n  val: 5,\\n  next: {\\n    val: 6,\\n    next: {\\n      val: 1,\\n      next: intersection,\\n    },\\n  },\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "space efficient solution with quadratic time complexity\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/877440572/"
                    },
                    {
                        "username": "Sivarajavel",
                        "content": "how to get skip values?"
                    },
                    {
                        "username": "Lazarus_10",
                        "content": "On the first para it says \"If the two linked lists have no intersection at all, return null\".\\nBut I don\\'t think there are any test cases for that."
                    },
                    {
                        "username": "oscarcambridge",
                        "content": "Can anyone explain for me please why this code exceed time limit? This is similar to the solution posted by major solution. But I change the if statement saying that if the next node is null, then pointer jumps to the other linked list.\\n\\n ` `\\n\\n        a,b = headA,headB\\n        while a != b:\\n            if not a.next:\\n                a = headB\\n            else:\\n                a = a.next\\n            if not b.next:\\n                b = headA\\n            else:\\n                b = b.next\\n        return a\\n ` `"
                    }
                ]
            },
            {
                "id": 1766752,
                "content": [
                    {
                        "username": "Deming98",
                        "content": "I want to use the two points to solve the question, but get the Time Limit Exceeded.\\nCould anyone tell me the reason? \\nThanks a lot!\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tempA = headA, *tempB = headB;\\n        while (tempA != tempB) {\\n            if (tempA->next != NULL) { tempA = tempA->next;}\\n            else { tempA->next = headB;}\\n            if (tempB->next != NULL) { tempB = tempB->next;}\\n            else { tempB->next = headA; }\\n        }\\n        return tempA;\\n    }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you have created cycle by connecting temp to head "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) \\n{\\n    if(headA == NULL || headB == NULL) // for checking 1st node head is null and 2nd not Null and both null head and vice versa \\n    {\\n        return NULL ;\\n    }\\n    struct ListNode *l1 = headA ; // just for traversal \\n    struct ListNode *l2 = headB ;\\n    while(l1 != l2)   // checking metting point of both pointer \\n    {\\n        l1 = (l1 == NULL)?headB : l1->next ;\\n        l2 = (l2 == NULL) ? headA : l2->next ;\\n    }\\n    return l1 ; \\nIn this the basic rule is that we are first traversing 1st ll fully then put that pointer to head of another ll . Similarly for 1st pointer ll . \\nThan after that when we move interchanged pointer they will meet at point which will be intersection point of LL . If not LL intersecting then also these will meet at NULL . \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "solution with O(M+N) run time and O(N) space \\nwith explanation\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3055419/js-run-time-o-n-m-space-o-n-explanation/"
                    },
                    {
                        "username": "Femalopper",
                        "content": "What really helped me to understand the case with listA = [4,1,8,4,5], listB = [5,6,1,8,4,5] and why the intersection is 8 and not 1 is lists representation in the following way (below), the objects are equal by reference, we can create const intersection and make it as a common link in list1 and list2 (this is the unique same reference for two objects - list1 and list2).\\nconst intersection = {\\n  val: 8,\\n  next: {\\n    val: 4,\\n    next: {\\n      val: 5,\\n      next: null,\\n    },\\n  },\\n};\\n\\nconst list1 = {\\n  val: 4,\\n  next: {\\n    val: 1,\\n    next: intersection,\\n  },\\n};\\n\\nconst list2 = {\\n  val: 5,\\n  next: {\\n    val: 6,\\n    next: {\\n      val: 1,\\n      next: intersection,\\n    },\\n  },\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "space efficient solution with quadratic time complexity\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/877440572/"
                    },
                    {
                        "username": "Sivarajavel",
                        "content": "how to get skip values?"
                    },
                    {
                        "username": "Lazarus_10",
                        "content": "On the first para it says \"If the two linked lists have no intersection at all, return null\".\\nBut I don\\'t think there are any test cases for that."
                    },
                    {
                        "username": "oscarcambridge",
                        "content": "Can anyone explain for me please why this code exceed time limit? This is similar to the solution posted by major solution. But I change the if statement saying that if the next node is null, then pointer jumps to the other linked list.\\n\\n ` `\\n\\n        a,b = headA,headB\\n        while a != b:\\n            if not a.next:\\n                a = headB\\n            else:\\n                a = a.next\\n            if not b.next:\\n                b = headA\\n            else:\\n                b = b.next\\n        return a\\n ` `"
                    }
                ]
            },
            {
                "id": 1761029,
                "content": [
                    {
                        "username": "Deming98",
                        "content": "I want to use the two points to solve the question, but get the Time Limit Exceeded.\\nCould anyone tell me the reason? \\nThanks a lot!\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tempA = headA, *tempB = headB;\\n        while (tempA != tempB) {\\n            if (tempA->next != NULL) { tempA = tempA->next;}\\n            else { tempA->next = headB;}\\n            if (tempB->next != NULL) { tempB = tempB->next;}\\n            else { tempB->next = headA; }\\n        }\\n        return tempA;\\n    }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you have created cycle by connecting temp to head "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) \\n{\\n    if(headA == NULL || headB == NULL) // for checking 1st node head is null and 2nd not Null and both null head and vice versa \\n    {\\n        return NULL ;\\n    }\\n    struct ListNode *l1 = headA ; // just for traversal \\n    struct ListNode *l2 = headB ;\\n    while(l1 != l2)   // checking metting point of both pointer \\n    {\\n        l1 = (l1 == NULL)?headB : l1->next ;\\n        l2 = (l2 == NULL) ? headA : l2->next ;\\n    }\\n    return l1 ; \\nIn this the basic rule is that we are first traversing 1st ll fully then put that pointer to head of another ll . Similarly for 1st pointer ll . \\nThan after that when we move interchanged pointer they will meet at point which will be intersection point of LL . If not LL intersecting then also these will meet at NULL . \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "solution with O(M+N) run time and O(N) space \\nwith explanation\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3055419/js-run-time-o-n-m-space-o-n-explanation/"
                    },
                    {
                        "username": "Femalopper",
                        "content": "What really helped me to understand the case with listA = [4,1,8,4,5], listB = [5,6,1,8,4,5] and why the intersection is 8 and not 1 is lists representation in the following way (below), the objects are equal by reference, we can create const intersection and make it as a common link in list1 and list2 (this is the unique same reference for two objects - list1 and list2).\\nconst intersection = {\\n  val: 8,\\n  next: {\\n    val: 4,\\n    next: {\\n      val: 5,\\n      next: null,\\n    },\\n  },\\n};\\n\\nconst list1 = {\\n  val: 4,\\n  next: {\\n    val: 1,\\n    next: intersection,\\n  },\\n};\\n\\nconst list2 = {\\n  val: 5,\\n  next: {\\n    val: 6,\\n    next: {\\n      val: 1,\\n      next: intersection,\\n    },\\n  },\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "space efficient solution with quadratic time complexity\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/877440572/"
                    },
                    {
                        "username": "Sivarajavel",
                        "content": "how to get skip values?"
                    },
                    {
                        "username": "Lazarus_10",
                        "content": "On the first para it says \"If the two linked lists have no intersection at all, return null\".\\nBut I don\\'t think there are any test cases for that."
                    },
                    {
                        "username": "oscarcambridge",
                        "content": "Can anyone explain for me please why this code exceed time limit? This is similar to the solution posted by major solution. But I change the if statement saying that if the next node is null, then pointer jumps to the other linked list.\\n\\n ` `\\n\\n        a,b = headA,headB\\n        while a != b:\\n            if not a.next:\\n                a = headB\\n            else:\\n                a = a.next\\n            if not b.next:\\n                b = headA\\n            else:\\n                b = b.next\\n        return a\\n ` `"
                    }
                ]
            },
            {
                "id": 1759332,
                "content": [
                    {
                        "username": "Deming98",
                        "content": "I want to use the two points to solve the question, but get the Time Limit Exceeded.\\nCould anyone tell me the reason? \\nThanks a lot!\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tempA = headA, *tempB = headB;\\n        while (tempA != tempB) {\\n            if (tempA->next != NULL) { tempA = tempA->next;}\\n            else { tempA->next = headB;}\\n            if (tempB->next != NULL) { tempB = tempB->next;}\\n            else { tempB->next = headA; }\\n        }\\n        return tempA;\\n    }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you have created cycle by connecting temp to head "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) \\n{\\n    if(headA == NULL || headB == NULL) // for checking 1st node head is null and 2nd not Null and both null head and vice versa \\n    {\\n        return NULL ;\\n    }\\n    struct ListNode *l1 = headA ; // just for traversal \\n    struct ListNode *l2 = headB ;\\n    while(l1 != l2)   // checking metting point of both pointer \\n    {\\n        l1 = (l1 == NULL)?headB : l1->next ;\\n        l2 = (l2 == NULL) ? headA : l2->next ;\\n    }\\n    return l1 ; \\nIn this the basic rule is that we are first traversing 1st ll fully then put that pointer to head of another ll . Similarly for 1st pointer ll . \\nThan after that when we move interchanged pointer they will meet at point which will be intersection point of LL . If not LL intersecting then also these will meet at NULL . \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "solution with O(M+N) run time and O(N) space \\nwith explanation\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3055419/js-run-time-o-n-m-space-o-n-explanation/"
                    },
                    {
                        "username": "Femalopper",
                        "content": "What really helped me to understand the case with listA = [4,1,8,4,5], listB = [5,6,1,8,4,5] and why the intersection is 8 and not 1 is lists representation in the following way (below), the objects are equal by reference, we can create const intersection and make it as a common link in list1 and list2 (this is the unique same reference for two objects - list1 and list2).\\nconst intersection = {\\n  val: 8,\\n  next: {\\n    val: 4,\\n    next: {\\n      val: 5,\\n      next: null,\\n    },\\n  },\\n};\\n\\nconst list1 = {\\n  val: 4,\\n  next: {\\n    val: 1,\\n    next: intersection,\\n  },\\n};\\n\\nconst list2 = {\\n  val: 5,\\n  next: {\\n    val: 6,\\n    next: {\\n      val: 1,\\n      next: intersection,\\n    },\\n  },\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "space efficient solution with quadratic time complexity\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/877440572/"
                    },
                    {
                        "username": "Sivarajavel",
                        "content": "how to get skip values?"
                    },
                    {
                        "username": "Lazarus_10",
                        "content": "On the first para it says \"If the two linked lists have no intersection at all, return null\".\\nBut I don\\'t think there are any test cases for that."
                    },
                    {
                        "username": "oscarcambridge",
                        "content": "Can anyone explain for me please why this code exceed time limit? This is similar to the solution posted by major solution. But I change the if statement saying that if the next node is null, then pointer jumps to the other linked list.\\n\\n ` `\\n\\n        a,b = headA,headB\\n        while a != b:\\n            if not a.next:\\n                a = headB\\n            else:\\n                a = a.next\\n            if not b.next:\\n                b = headA\\n            else:\\n                b = b.next\\n        return a\\n ` `"
                    }
                ]
            },
            {
                "id": 1757655,
                "content": [
                    {
                        "username": "Deming98",
                        "content": "I want to use the two points to solve the question, but get the Time Limit Exceeded.\\nCould anyone tell me the reason? \\nThanks a lot!\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tempA = headA, *tempB = headB;\\n        while (tempA != tempB) {\\n            if (tempA->next != NULL) { tempA = tempA->next;}\\n            else { tempA->next = headB;}\\n            if (tempB->next != NULL) { tempB = tempB->next;}\\n            else { tempB->next = headA; }\\n        }\\n        return tempA;\\n    }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you have created cycle by connecting temp to head "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) \\n{\\n    if(headA == NULL || headB == NULL) // for checking 1st node head is null and 2nd not Null and both null head and vice versa \\n    {\\n        return NULL ;\\n    }\\n    struct ListNode *l1 = headA ; // just for traversal \\n    struct ListNode *l2 = headB ;\\n    while(l1 != l2)   // checking metting point of both pointer \\n    {\\n        l1 = (l1 == NULL)?headB : l1->next ;\\n        l2 = (l2 == NULL) ? headA : l2->next ;\\n    }\\n    return l1 ; \\nIn this the basic rule is that we are first traversing 1st ll fully then put that pointer to head of another ll . Similarly for 1st pointer ll . \\nThan after that when we move interchanged pointer they will meet at point which will be intersection point of LL . If not LL intersecting then also these will meet at NULL . \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "solution with O(M+N) run time and O(N) space \\nwith explanation\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3055419/js-run-time-o-n-m-space-o-n-explanation/"
                    },
                    {
                        "username": "Femalopper",
                        "content": "What really helped me to understand the case with listA = [4,1,8,4,5], listB = [5,6,1,8,4,5] and why the intersection is 8 and not 1 is lists representation in the following way (below), the objects are equal by reference, we can create const intersection and make it as a common link in list1 and list2 (this is the unique same reference for two objects - list1 and list2).\\nconst intersection = {\\n  val: 8,\\n  next: {\\n    val: 4,\\n    next: {\\n      val: 5,\\n      next: null,\\n    },\\n  },\\n};\\n\\nconst list1 = {\\n  val: 4,\\n  next: {\\n    val: 1,\\n    next: intersection,\\n  },\\n};\\n\\nconst list2 = {\\n  val: 5,\\n  next: {\\n    val: 6,\\n    next: {\\n      val: 1,\\n      next: intersection,\\n    },\\n  },\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "space efficient solution with quadratic time complexity\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/877440572/"
                    },
                    {
                        "username": "Sivarajavel",
                        "content": "how to get skip values?"
                    },
                    {
                        "username": "Lazarus_10",
                        "content": "On the first para it says \"If the two linked lists have no intersection at all, return null\".\\nBut I don\\'t think there are any test cases for that."
                    },
                    {
                        "username": "oscarcambridge",
                        "content": "Can anyone explain for me please why this code exceed time limit? This is similar to the solution posted by major solution. But I change the if statement saying that if the next node is null, then pointer jumps to the other linked list.\\n\\n ` `\\n\\n        a,b = headA,headB\\n        while a != b:\\n            if not a.next:\\n                a = headB\\n            else:\\n                a = a.next\\n            if not b.next:\\n                b = headA\\n            else:\\n                b = b.next\\n        return a\\n ` `"
                    }
                ]
            },
            {
                "id": 1756157,
                "content": [
                    {
                        "username": "Deming98",
                        "content": "I want to use the two points to solve the question, but get the Time Limit Exceeded.\\nCould anyone tell me the reason? \\nThanks a lot!\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tempA = headA, *tempB = headB;\\n        while (tempA != tempB) {\\n            if (tempA->next != NULL) { tempA = tempA->next;}\\n            else { tempA->next = headB;}\\n            if (tempB->next != NULL) { tempB = tempB->next;}\\n            else { tempB->next = headA; }\\n        }\\n        return tempA;\\n    }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you have created cycle by connecting temp to head "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) \\n{\\n    if(headA == NULL || headB == NULL) // for checking 1st node head is null and 2nd not Null and both null head and vice versa \\n    {\\n        return NULL ;\\n    }\\n    struct ListNode *l1 = headA ; // just for traversal \\n    struct ListNode *l2 = headB ;\\n    while(l1 != l2)   // checking metting point of both pointer \\n    {\\n        l1 = (l1 == NULL)?headB : l1->next ;\\n        l2 = (l2 == NULL) ? headA : l2->next ;\\n    }\\n    return l1 ; \\nIn this the basic rule is that we are first traversing 1st ll fully then put that pointer to head of another ll . Similarly for 1st pointer ll . \\nThan after that when we move interchanged pointer they will meet at point which will be intersection point of LL . If not LL intersecting then also these will meet at NULL . \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "solution with O(M+N) run time and O(N) space \\nwith explanation\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3055419/js-run-time-o-n-m-space-o-n-explanation/"
                    },
                    {
                        "username": "Femalopper",
                        "content": "What really helped me to understand the case with listA = [4,1,8,4,5], listB = [5,6,1,8,4,5] and why the intersection is 8 and not 1 is lists representation in the following way (below), the objects are equal by reference, we can create const intersection and make it as a common link in list1 and list2 (this is the unique same reference for two objects - list1 and list2).\\nconst intersection = {\\n  val: 8,\\n  next: {\\n    val: 4,\\n    next: {\\n      val: 5,\\n      next: null,\\n    },\\n  },\\n};\\n\\nconst list1 = {\\n  val: 4,\\n  next: {\\n    val: 1,\\n    next: intersection,\\n  },\\n};\\n\\nconst list2 = {\\n  val: 5,\\n  next: {\\n    val: 6,\\n    next: {\\n      val: 1,\\n      next: intersection,\\n    },\\n  },\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "space efficient solution with quadratic time complexity\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/877440572/"
                    },
                    {
                        "username": "Sivarajavel",
                        "content": "how to get skip values?"
                    },
                    {
                        "username": "Lazarus_10",
                        "content": "On the first para it says \"If the two linked lists have no intersection at all, return null\".\\nBut I don\\'t think there are any test cases for that."
                    },
                    {
                        "username": "oscarcambridge",
                        "content": "Can anyone explain for me please why this code exceed time limit? This is similar to the solution posted by major solution. But I change the if statement saying that if the next node is null, then pointer jumps to the other linked list.\\n\\n ` `\\n\\n        a,b = headA,headB\\n        while a != b:\\n            if not a.next:\\n                a = headB\\n            else:\\n                a = a.next\\n            if not b.next:\\n                b = headA\\n            else:\\n                b = b.next\\n        return a\\n ` `"
                    }
                ]
            },
            {
                "id": 1747694,
                "content": [
                    {
                        "username": "Deming98",
                        "content": "I want to use the two points to solve the question, but get the Time Limit Exceeded.\\nCould anyone tell me the reason? \\nThanks a lot!\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tempA = headA, *tempB = headB;\\n        while (tempA != tempB) {\\n            if (tempA->next != NULL) { tempA = tempA->next;}\\n            else { tempA->next = headB;}\\n            if (tempB->next != NULL) { tempB = tempB->next;}\\n            else { tempB->next = headA; }\\n        }\\n        return tempA;\\n    }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you have created cycle by connecting temp to head "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) \\n{\\n    if(headA == NULL || headB == NULL) // for checking 1st node head is null and 2nd not Null and both null head and vice versa \\n    {\\n        return NULL ;\\n    }\\n    struct ListNode *l1 = headA ; // just for traversal \\n    struct ListNode *l2 = headB ;\\n    while(l1 != l2)   // checking metting point of both pointer \\n    {\\n        l1 = (l1 == NULL)?headB : l1->next ;\\n        l2 = (l2 == NULL) ? headA : l2->next ;\\n    }\\n    return l1 ; \\nIn this the basic rule is that we are first traversing 1st ll fully then put that pointer to head of another ll . Similarly for 1st pointer ll . \\nThan after that when we move interchanged pointer they will meet at point which will be intersection point of LL . If not LL intersecting then also these will meet at NULL . \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "solution with O(M+N) run time and O(N) space \\nwith explanation\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3055419/js-run-time-o-n-m-space-o-n-explanation/"
                    },
                    {
                        "username": "Femalopper",
                        "content": "What really helped me to understand the case with listA = [4,1,8,4,5], listB = [5,6,1,8,4,5] and why the intersection is 8 and not 1 is lists representation in the following way (below), the objects are equal by reference, we can create const intersection and make it as a common link in list1 and list2 (this is the unique same reference for two objects - list1 and list2).\\nconst intersection = {\\n  val: 8,\\n  next: {\\n    val: 4,\\n    next: {\\n      val: 5,\\n      next: null,\\n    },\\n  },\\n};\\n\\nconst list1 = {\\n  val: 4,\\n  next: {\\n    val: 1,\\n    next: intersection,\\n  },\\n};\\n\\nconst list2 = {\\n  val: 5,\\n  next: {\\n    val: 6,\\n    next: {\\n      val: 1,\\n      next: intersection,\\n    },\\n  },\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "space efficient solution with quadratic time complexity\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/877440572/"
                    },
                    {
                        "username": "Sivarajavel",
                        "content": "how to get skip values?"
                    },
                    {
                        "username": "Lazarus_10",
                        "content": "On the first para it says \"If the two linked lists have no intersection at all, return null\".\\nBut I don\\'t think there are any test cases for that."
                    },
                    {
                        "username": "oscarcambridge",
                        "content": "Can anyone explain for me please why this code exceed time limit? This is similar to the solution posted by major solution. But I change the if statement saying that if the next node is null, then pointer jumps to the other linked list.\\n\\n ` `\\n\\n        a,b = headA,headB\\n        while a != b:\\n            if not a.next:\\n                a = headB\\n            else:\\n                a = a.next\\n            if not b.next:\\n                b = headA\\n            else:\\n                b = b.next\\n        return a\\n ` `"
                    }
                ]
            },
            {
                "id": 1742213,
                "content": [
                    {
                        "username": "Deming98",
                        "content": "I want to use the two points to solve the question, but get the Time Limit Exceeded.\\nCould anyone tell me the reason? \\nThanks a lot!\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tempA = headA, *tempB = headB;\\n        while (tempA != tempB) {\\n            if (tempA->next != NULL) { tempA = tempA->next;}\\n            else { tempA->next = headB;}\\n            if (tempB->next != NULL) { tempB = tempB->next;}\\n            else { tempB->next = headA; }\\n        }\\n        return tempA;\\n    }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you have created cycle by connecting temp to head "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) \\n{\\n    if(headA == NULL || headB == NULL) // for checking 1st node head is null and 2nd not Null and both null head and vice versa \\n    {\\n        return NULL ;\\n    }\\n    struct ListNode *l1 = headA ; // just for traversal \\n    struct ListNode *l2 = headB ;\\n    while(l1 != l2)   // checking metting point of both pointer \\n    {\\n        l1 = (l1 == NULL)?headB : l1->next ;\\n        l2 = (l2 == NULL) ? headA : l2->next ;\\n    }\\n    return l1 ; \\nIn this the basic rule is that we are first traversing 1st ll fully then put that pointer to head of another ll . Similarly for 1st pointer ll . \\nThan after that when we move interchanged pointer they will meet at point which will be intersection point of LL . If not LL intersecting then also these will meet at NULL . \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "solution with O(M+N) run time and O(N) space \\nwith explanation\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3055419/js-run-time-o-n-m-space-o-n-explanation/"
                    },
                    {
                        "username": "Femalopper",
                        "content": "What really helped me to understand the case with listA = [4,1,8,4,5], listB = [5,6,1,8,4,5] and why the intersection is 8 and not 1 is lists representation in the following way (below), the objects are equal by reference, we can create const intersection and make it as a common link in list1 and list2 (this is the unique same reference for two objects - list1 and list2).\\nconst intersection = {\\n  val: 8,\\n  next: {\\n    val: 4,\\n    next: {\\n      val: 5,\\n      next: null,\\n    },\\n  },\\n};\\n\\nconst list1 = {\\n  val: 4,\\n  next: {\\n    val: 1,\\n    next: intersection,\\n  },\\n};\\n\\nconst list2 = {\\n  val: 5,\\n  next: {\\n    val: 6,\\n    next: {\\n      val: 1,\\n      next: intersection,\\n    },\\n  },\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "space efficient solution with quadratic time complexity\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/877440572/"
                    },
                    {
                        "username": "Sivarajavel",
                        "content": "how to get skip values?"
                    },
                    {
                        "username": "Lazarus_10",
                        "content": "On the first para it says \"If the two linked lists have no intersection at all, return null\".\\nBut I don\\'t think there are any test cases for that."
                    },
                    {
                        "username": "oscarcambridge",
                        "content": "Can anyone explain for me please why this code exceed time limit? This is similar to the solution posted by major solution. But I change the if statement saying that if the next node is null, then pointer jumps to the other linked list.\\n\\n ` `\\n\\n        a,b = headA,headB\\n        while a != b:\\n            if not a.next:\\n                a = headB\\n            else:\\n                a = a.next\\n            if not b.next:\\n                b = headA\\n            else:\\n                b = b.next\\n        return a\\n ` `"
                    }
                ]
            },
            {
                "id": 1742210,
                "content": [
                    {
                        "username": "Deming98",
                        "content": "I want to use the two points to solve the question, but get the Time Limit Exceeded.\\nCould anyone tell me the reason? \\nThanks a lot!\\n\\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\\n        ListNode *tempA = headA, *tempB = headB;\\n        while (tempA != tempB) {\\n            if (tempA->next != NULL) { tempA = tempA->next;}\\n            else { tempA->next = headB;}\\n            if (tempB->next != NULL) { tempB = tempB->next;}\\n            else { tempB->next = headA; }\\n        }\\n        return tempA;\\n    }"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "you have created cycle by connecting temp to head "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) \\n{\\n    if(headA == NULL || headB == NULL) // for checking 1st node head is null and 2nd not Null and both null head and vice versa \\n    {\\n        return NULL ;\\n    }\\n    struct ListNode *l1 = headA ; // just for traversal \\n    struct ListNode *l2 = headB ;\\n    while(l1 != l2)   // checking metting point of both pointer \\n    {\\n        l1 = (l1 == NULL)?headB : l1->next ;\\n        l2 = (l2 == NULL) ? headA : l2->next ;\\n    }\\n    return l1 ; \\nIn this the basic rule is that we are first traversing 1st ll fully then put that pointer to head of another ll . Similarly for 1st pointer ll . \\nThan after that when we move interchanged pointer they will meet at point which will be intersection point of LL . If not LL intersecting then also these will meet at NULL . \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "solution with O(M+N) run time and O(N) space \\nwith explanation\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3055419/js-run-time-o-n-m-space-o-n-explanation/"
                    },
                    {
                        "username": "Femalopper",
                        "content": "What really helped me to understand the case with listA = [4,1,8,4,5], listB = [5,6,1,8,4,5] and why the intersection is 8 and not 1 is lists representation in the following way (below), the objects are equal by reference, we can create const intersection and make it as a common link in list1 and list2 (this is the unique same reference for two objects - list1 and list2).\\nconst intersection = {\\n  val: 8,\\n  next: {\\n    val: 4,\\n    next: {\\n      val: 5,\\n      next: null,\\n    },\\n  },\\n};\\n\\nconst list1 = {\\n  val: 4,\\n  next: {\\n    val: 1,\\n    next: intersection,\\n  },\\n};\\n\\nconst list2 = {\\n  val: 5,\\n  next: {\\n    val: 6,\\n    next: {\\n      val: 1,\\n      next: intersection,\\n    },\\n  },\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "space efficient solution with quadratic time complexity\\n\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/877440572/"
                    },
                    {
                        "username": "Sivarajavel",
                        "content": "how to get skip values?"
                    },
                    {
                        "username": "Lazarus_10",
                        "content": "On the first para it says \"If the two linked lists have no intersection at all, return null\".\\nBut I don\\'t think there are any test cases for that."
                    },
                    {
                        "username": "oscarcambridge",
                        "content": "Can anyone explain for me please why this code exceed time limit? This is similar to the solution posted by major solution. But I change the if statement saying that if the next node is null, then pointer jumps to the other linked list.\\n\\n ` `\\n\\n        a,b = headA,headB\\n        while a != b:\\n            if not a.next:\\n                a = headB\\n            else:\\n                a = a.next\\n            if not b.next:\\n                b = headA\\n            else:\\n                b = b.next\\n        return a\\n ` `"
                    }
                ]
            },
            {
                "id": 1725151,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "three ways to do this question:\\n\\n1) using doubly Linked List \\n   traversing both heads to last . and then comparing by going previous of each node\\n\\n2) using stack, but it will not be O(1) space \\n\\n3) making lengths equal first , by traversing long list, till equal lengths. and then comparing both heads"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "-> we don\\'t have to compare the data of nodes, but we have to compare the nodes of both lists. "
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "Here we don\\'t have to compare the data of the nodes of both lists.\\nwe have to compare the nodes of both lists.\\n\\n       ListNode *r1=headA,*r2=headB;\\n        \\n         int s1=length(r1); //user defined function\\n         int s2=length(r2); //user defined function\\n       \\n        while(s1>s2)\\n        {\\n            s1--;\\n            headA=headA->next;\\n        }\\n         while(s1<s2)\\n        {\\n            s2--;\\n            headB=headB->next;\\n        }\\n        while(headA!=headB)\\n        {\\n            headA=headA->next;\\n            headB=headB->next;\\n        }\\n        return headA;\\n    "
                    },
                    {
                        "username": "rahul_1234598",
                        "content": "while l1 != l2 why cant we use while l1.val != l2.val\\n\\nas here we need to check the intersection point\\n"
                    },
                    {
                        "username": "swepln",
                        "content": "Looks like the description was changed, but the examples are from previous."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "Check the difference in the lengths of both the lists .\\nincrement the larger once head by the difference  and then start comparing both lists head untill got match.\\n"
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "we are solved in three way!"
                    },
                    {
                        "username": "rbflw",
                        "content": "Like so many other users, I don't understand the proposed answer in example 1, nor do I understand the discrepancy in the example parameters to the parameters given in the method signature of the solution . I don't think aligning the lists by their tails is correct because that's not how it's shown in the example. I give up.\n\nPS: given the above I'm a bit surprised that there is 11 k up votes, and only 1 k down votes - what am I missing?"
                    },
                    {
                        "username": "Pizarro35",
                        "content": "![image](https://assets.leetcode.com/users/pizarro35/image_1581004208.png)\\n"
                    }
                ]
            },
            {
                "id": 1718437,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "three ways to do this question:\\n\\n1) using doubly Linked List \\n   traversing both heads to last . and then comparing by going previous of each node\\n\\n2) using stack, but it will not be O(1) space \\n\\n3) making lengths equal first , by traversing long list, till equal lengths. and then comparing both heads"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "-> we don\\'t have to compare the data of nodes, but we have to compare the nodes of both lists. "
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "Here we don\\'t have to compare the data of the nodes of both lists.\\nwe have to compare the nodes of both lists.\\n\\n       ListNode *r1=headA,*r2=headB;\\n        \\n         int s1=length(r1); //user defined function\\n         int s2=length(r2); //user defined function\\n       \\n        while(s1>s2)\\n        {\\n            s1--;\\n            headA=headA->next;\\n        }\\n         while(s1<s2)\\n        {\\n            s2--;\\n            headB=headB->next;\\n        }\\n        while(headA!=headB)\\n        {\\n            headA=headA->next;\\n            headB=headB->next;\\n        }\\n        return headA;\\n    "
                    },
                    {
                        "username": "rahul_1234598",
                        "content": "while l1 != l2 why cant we use while l1.val != l2.val\\n\\nas here we need to check the intersection point\\n"
                    },
                    {
                        "username": "swepln",
                        "content": "Looks like the description was changed, but the examples are from previous."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "Check the difference in the lengths of both the lists .\\nincrement the larger once head by the difference  and then start comparing both lists head untill got match.\\n"
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "we are solved in three way!"
                    },
                    {
                        "username": "rbflw",
                        "content": "Like so many other users, I don't understand the proposed answer in example 1, nor do I understand the discrepancy in the example parameters to the parameters given in the method signature of the solution . I don't think aligning the lists by their tails is correct because that's not how it's shown in the example. I give up.\n\nPS: given the above I'm a bit surprised that there is 11 k up votes, and only 1 k down votes - what am I missing?"
                    },
                    {
                        "username": "Pizarro35",
                        "content": "![image](https://assets.leetcode.com/users/pizarro35/image_1581004208.png)\\n"
                    }
                ]
            },
            {
                "id": 1716218,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "three ways to do this question:\\n\\n1) using doubly Linked List \\n   traversing both heads to last . and then comparing by going previous of each node\\n\\n2) using stack, but it will not be O(1) space \\n\\n3) making lengths equal first , by traversing long list, till equal lengths. and then comparing both heads"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "-> we don\\'t have to compare the data of nodes, but we have to compare the nodes of both lists. "
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "Here we don\\'t have to compare the data of the nodes of both lists.\\nwe have to compare the nodes of both lists.\\n\\n       ListNode *r1=headA,*r2=headB;\\n        \\n         int s1=length(r1); //user defined function\\n         int s2=length(r2); //user defined function\\n       \\n        while(s1>s2)\\n        {\\n            s1--;\\n            headA=headA->next;\\n        }\\n         while(s1<s2)\\n        {\\n            s2--;\\n            headB=headB->next;\\n        }\\n        while(headA!=headB)\\n        {\\n            headA=headA->next;\\n            headB=headB->next;\\n        }\\n        return headA;\\n    "
                    },
                    {
                        "username": "rahul_1234598",
                        "content": "while l1 != l2 why cant we use while l1.val != l2.val\\n\\nas here we need to check the intersection point\\n"
                    },
                    {
                        "username": "swepln",
                        "content": "Looks like the description was changed, but the examples are from previous."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "Check the difference in the lengths of both the lists .\\nincrement the larger once head by the difference  and then start comparing both lists head untill got match.\\n"
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "we are solved in three way!"
                    },
                    {
                        "username": "rbflw",
                        "content": "Like so many other users, I don't understand the proposed answer in example 1, nor do I understand the discrepancy in the example parameters to the parameters given in the method signature of the solution . I don't think aligning the lists by their tails is correct because that's not how it's shown in the example. I give up.\n\nPS: given the above I'm a bit surprised that there is 11 k up votes, and only 1 k down votes - what am I missing?"
                    },
                    {
                        "username": "Pizarro35",
                        "content": "![image](https://assets.leetcode.com/users/pizarro35/image_1581004208.png)\\n"
                    }
                ]
            },
            {
                "id": 1716215,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "three ways to do this question:\\n\\n1) using doubly Linked List \\n   traversing both heads to last . and then comparing by going previous of each node\\n\\n2) using stack, but it will not be O(1) space \\n\\n3) making lengths equal first , by traversing long list, till equal lengths. and then comparing both heads"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "-> we don\\'t have to compare the data of nodes, but we have to compare the nodes of both lists. "
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "Here we don\\'t have to compare the data of the nodes of both lists.\\nwe have to compare the nodes of both lists.\\n\\n       ListNode *r1=headA,*r2=headB;\\n        \\n         int s1=length(r1); //user defined function\\n         int s2=length(r2); //user defined function\\n       \\n        while(s1>s2)\\n        {\\n            s1--;\\n            headA=headA->next;\\n        }\\n         while(s1<s2)\\n        {\\n            s2--;\\n            headB=headB->next;\\n        }\\n        while(headA!=headB)\\n        {\\n            headA=headA->next;\\n            headB=headB->next;\\n        }\\n        return headA;\\n    "
                    },
                    {
                        "username": "rahul_1234598",
                        "content": "while l1 != l2 why cant we use while l1.val != l2.val\\n\\nas here we need to check the intersection point\\n"
                    },
                    {
                        "username": "swepln",
                        "content": "Looks like the description was changed, but the examples are from previous."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "Check the difference in the lengths of both the lists .\\nincrement the larger once head by the difference  and then start comparing both lists head untill got match.\\n"
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "we are solved in three way!"
                    },
                    {
                        "username": "rbflw",
                        "content": "Like so many other users, I don't understand the proposed answer in example 1, nor do I understand the discrepancy in the example parameters to the parameters given in the method signature of the solution . I don't think aligning the lists by their tails is correct because that's not how it's shown in the example. I give up.\n\nPS: given the above I'm a bit surprised that there is 11 k up votes, and only 1 k down votes - what am I missing?"
                    },
                    {
                        "username": "Pizarro35",
                        "content": "![image](https://assets.leetcode.com/users/pizarro35/image_1581004208.png)\\n"
                    }
                ]
            },
            {
                "id": 1693694,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "three ways to do this question:\\n\\n1) using doubly Linked List \\n   traversing both heads to last . and then comparing by going previous of each node\\n\\n2) using stack, but it will not be O(1) space \\n\\n3) making lengths equal first , by traversing long list, till equal lengths. and then comparing both heads"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "-> we don\\'t have to compare the data of nodes, but we have to compare the nodes of both lists. "
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "Here we don\\'t have to compare the data of the nodes of both lists.\\nwe have to compare the nodes of both lists.\\n\\n       ListNode *r1=headA,*r2=headB;\\n        \\n         int s1=length(r1); //user defined function\\n         int s2=length(r2); //user defined function\\n       \\n        while(s1>s2)\\n        {\\n            s1--;\\n            headA=headA->next;\\n        }\\n         while(s1<s2)\\n        {\\n            s2--;\\n            headB=headB->next;\\n        }\\n        while(headA!=headB)\\n        {\\n            headA=headA->next;\\n            headB=headB->next;\\n        }\\n        return headA;\\n    "
                    },
                    {
                        "username": "rahul_1234598",
                        "content": "while l1 != l2 why cant we use while l1.val != l2.val\\n\\nas here we need to check the intersection point\\n"
                    },
                    {
                        "username": "swepln",
                        "content": "Looks like the description was changed, but the examples are from previous."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "Check the difference in the lengths of both the lists .\\nincrement the larger once head by the difference  and then start comparing both lists head untill got match.\\n"
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "we are solved in three way!"
                    },
                    {
                        "username": "rbflw",
                        "content": "Like so many other users, I don't understand the proposed answer in example 1, nor do I understand the discrepancy in the example parameters to the parameters given in the method signature of the solution . I don't think aligning the lists by their tails is correct because that's not how it's shown in the example. I give up.\n\nPS: given the above I'm a bit surprised that there is 11 k up votes, and only 1 k down votes - what am I missing?"
                    },
                    {
                        "username": "Pizarro35",
                        "content": "![image](https://assets.leetcode.com/users/pizarro35/image_1581004208.png)\\n"
                    }
                ]
            },
            {
                "id": 1689523,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "three ways to do this question:\\n\\n1) using doubly Linked List \\n   traversing both heads to last . and then comparing by going previous of each node\\n\\n2) using stack, but it will not be O(1) space \\n\\n3) making lengths equal first , by traversing long list, till equal lengths. and then comparing both heads"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "-> we don\\'t have to compare the data of nodes, but we have to compare the nodes of both lists. "
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "Here we don\\'t have to compare the data of the nodes of both lists.\\nwe have to compare the nodes of both lists.\\n\\n       ListNode *r1=headA,*r2=headB;\\n        \\n         int s1=length(r1); //user defined function\\n         int s2=length(r2); //user defined function\\n       \\n        while(s1>s2)\\n        {\\n            s1--;\\n            headA=headA->next;\\n        }\\n         while(s1<s2)\\n        {\\n            s2--;\\n            headB=headB->next;\\n        }\\n        while(headA!=headB)\\n        {\\n            headA=headA->next;\\n            headB=headB->next;\\n        }\\n        return headA;\\n    "
                    },
                    {
                        "username": "rahul_1234598",
                        "content": "while l1 != l2 why cant we use while l1.val != l2.val\\n\\nas here we need to check the intersection point\\n"
                    },
                    {
                        "username": "swepln",
                        "content": "Looks like the description was changed, but the examples are from previous."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "Check the difference in the lengths of both the lists .\\nincrement the larger once head by the difference  and then start comparing both lists head untill got match.\\n"
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "we are solved in three way!"
                    },
                    {
                        "username": "rbflw",
                        "content": "Like so many other users, I don't understand the proposed answer in example 1, nor do I understand the discrepancy in the example parameters to the parameters given in the method signature of the solution . I don't think aligning the lists by their tails is correct because that's not how it's shown in the example. I give up.\n\nPS: given the above I'm a bit surprised that there is 11 k up votes, and only 1 k down votes - what am I missing?"
                    },
                    {
                        "username": "Pizarro35",
                        "content": "![image](https://assets.leetcode.com/users/pizarro35/image_1581004208.png)\\n"
                    }
                ]
            },
            {
                "id": 1681293,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "three ways to do this question:\\n\\n1) using doubly Linked List \\n   traversing both heads to last . and then comparing by going previous of each node\\n\\n2) using stack, but it will not be O(1) space \\n\\n3) making lengths equal first , by traversing long list, till equal lengths. and then comparing both heads"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "-> we don\\'t have to compare the data of nodes, but we have to compare the nodes of both lists. "
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "Here we don\\'t have to compare the data of the nodes of both lists.\\nwe have to compare the nodes of both lists.\\n\\n       ListNode *r1=headA,*r2=headB;\\n        \\n         int s1=length(r1); //user defined function\\n         int s2=length(r2); //user defined function\\n       \\n        while(s1>s2)\\n        {\\n            s1--;\\n            headA=headA->next;\\n        }\\n         while(s1<s2)\\n        {\\n            s2--;\\n            headB=headB->next;\\n        }\\n        while(headA!=headB)\\n        {\\n            headA=headA->next;\\n            headB=headB->next;\\n        }\\n        return headA;\\n    "
                    },
                    {
                        "username": "rahul_1234598",
                        "content": "while l1 != l2 why cant we use while l1.val != l2.val\\n\\nas here we need to check the intersection point\\n"
                    },
                    {
                        "username": "swepln",
                        "content": "Looks like the description was changed, but the examples are from previous."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "Check the difference in the lengths of both the lists .\\nincrement the larger once head by the difference  and then start comparing both lists head untill got match.\\n"
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "we are solved in three way!"
                    },
                    {
                        "username": "rbflw",
                        "content": "Like so many other users, I don't understand the proposed answer in example 1, nor do I understand the discrepancy in the example parameters to the parameters given in the method signature of the solution . I don't think aligning the lists by their tails is correct because that's not how it's shown in the example. I give up.\n\nPS: given the above I'm a bit surprised that there is 11 k up votes, and only 1 k down votes - what am I missing?"
                    },
                    {
                        "username": "Pizarro35",
                        "content": "![image](https://assets.leetcode.com/users/pizarro35/image_1581004208.png)\\n"
                    }
                ]
            },
            {
                "id": 1658140,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "three ways to do this question:\\n\\n1) using doubly Linked List \\n   traversing both heads to last . and then comparing by going previous of each node\\n\\n2) using stack, but it will not be O(1) space \\n\\n3) making lengths equal first , by traversing long list, till equal lengths. and then comparing both heads"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "-> we don\\'t have to compare the data of nodes, but we have to compare the nodes of both lists. "
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "Here we don\\'t have to compare the data of the nodes of both lists.\\nwe have to compare the nodes of both lists.\\n\\n       ListNode *r1=headA,*r2=headB;\\n        \\n         int s1=length(r1); //user defined function\\n         int s2=length(r2); //user defined function\\n       \\n        while(s1>s2)\\n        {\\n            s1--;\\n            headA=headA->next;\\n        }\\n         while(s1<s2)\\n        {\\n            s2--;\\n            headB=headB->next;\\n        }\\n        while(headA!=headB)\\n        {\\n            headA=headA->next;\\n            headB=headB->next;\\n        }\\n        return headA;\\n    "
                    },
                    {
                        "username": "rahul_1234598",
                        "content": "while l1 != l2 why cant we use while l1.val != l2.val\\n\\nas here we need to check the intersection point\\n"
                    },
                    {
                        "username": "swepln",
                        "content": "Looks like the description was changed, but the examples are from previous."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "Check the difference in the lengths of both the lists .\\nincrement the larger once head by the difference  and then start comparing both lists head untill got match.\\n"
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "we are solved in three way!"
                    },
                    {
                        "username": "rbflw",
                        "content": "Like so many other users, I don't understand the proposed answer in example 1, nor do I understand the discrepancy in the example parameters to the parameters given in the method signature of the solution . I don't think aligning the lists by their tails is correct because that's not how it's shown in the example. I give up.\n\nPS: given the above I'm a bit surprised that there is 11 k up votes, and only 1 k down votes - what am I missing?"
                    },
                    {
                        "username": "Pizarro35",
                        "content": "![image](https://assets.leetcode.com/users/pizarro35/image_1581004208.png)\\n"
                    }
                ]
            },
            {
                "id": 1625165,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "three ways to do this question:\\n\\n1) using doubly Linked List \\n   traversing both heads to last . and then comparing by going previous of each node\\n\\n2) using stack, but it will not be O(1) space \\n\\n3) making lengths equal first , by traversing long list, till equal lengths. and then comparing both heads"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "-> we don\\'t have to compare the data of nodes, but we have to compare the nodes of both lists. "
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "Here we don\\'t have to compare the data of the nodes of both lists.\\nwe have to compare the nodes of both lists.\\n\\n       ListNode *r1=headA,*r2=headB;\\n        \\n         int s1=length(r1); //user defined function\\n         int s2=length(r2); //user defined function\\n       \\n        while(s1>s2)\\n        {\\n            s1--;\\n            headA=headA->next;\\n        }\\n         while(s1<s2)\\n        {\\n            s2--;\\n            headB=headB->next;\\n        }\\n        while(headA!=headB)\\n        {\\n            headA=headA->next;\\n            headB=headB->next;\\n        }\\n        return headA;\\n    "
                    },
                    {
                        "username": "rahul_1234598",
                        "content": "while l1 != l2 why cant we use while l1.val != l2.val\\n\\nas here we need to check the intersection point\\n"
                    },
                    {
                        "username": "swepln",
                        "content": "Looks like the description was changed, but the examples are from previous."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "Check the difference in the lengths of both the lists .\\nincrement the larger once head by the difference  and then start comparing both lists head untill got match.\\n"
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "we are solved in three way!"
                    },
                    {
                        "username": "rbflw",
                        "content": "Like so many other users, I don't understand the proposed answer in example 1, nor do I understand the discrepancy in the example parameters to the parameters given in the method signature of the solution . I don't think aligning the lists by their tails is correct because that's not how it's shown in the example. I give up.\n\nPS: given the above I'm a bit surprised that there is 11 k up votes, and only 1 k down votes - what am I missing?"
                    },
                    {
                        "username": "Pizarro35",
                        "content": "![image](https://assets.leetcode.com/users/pizarro35/image_1581004208.png)\\n"
                    }
                ]
            },
            {
                "id": 1569765,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "three ways to do this question:\\n\\n1) using doubly Linked List \\n   traversing both heads to last . and then comparing by going previous of each node\\n\\n2) using stack, but it will not be O(1) space \\n\\n3) making lengths equal first , by traversing long list, till equal lengths. and then comparing both heads"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2918847/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "-> we don\\'t have to compare the data of nodes, but we have to compare the nodes of both lists. "
                    },
                    {
                        "username": "Rahul_leet15",
                        "content": "Here we don\\'t have to compare the data of the nodes of both lists.\\nwe have to compare the nodes of both lists.\\n\\n       ListNode *r1=headA,*r2=headB;\\n        \\n         int s1=length(r1); //user defined function\\n         int s2=length(r2); //user defined function\\n       \\n        while(s1>s2)\\n        {\\n            s1--;\\n            headA=headA->next;\\n        }\\n         while(s1<s2)\\n        {\\n            s2--;\\n            headB=headB->next;\\n        }\\n        while(headA!=headB)\\n        {\\n            headA=headA->next;\\n            headB=headB->next;\\n        }\\n        return headA;\\n    "
                    },
                    {
                        "username": "rahul_1234598",
                        "content": "while l1 != l2 why cant we use while l1.val != l2.val\\n\\nas here we need to check the intersection point\\n"
                    },
                    {
                        "username": "swepln",
                        "content": "Looks like the description was changed, but the examples are from previous."
                    },
                    {
                        "username": "Shauryaa007",
                        "content": "Check the difference in the lengths of both the lists .\\nincrement the larger once head by the difference  and then start comparing both lists head untill got match.\\n"
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "we are solved in three way!"
                    },
                    {
                        "username": "rbflw",
                        "content": "Like so many other users, I don't understand the proposed answer in example 1, nor do I understand the discrepancy in the example parameters to the parameters given in the method signature of the solution . I don't think aligning the lists by their tails is correct because that's not how it's shown in the example. I give up.\n\nPS: given the above I'm a bit surprised that there is 11 k up votes, and only 1 k down votes - what am I missing?"
                    },
                    {
                        "username": "Pizarro35",
                        "content": "![image](https://assets.leetcode.com/users/pizarro35/image_1581004208.png)\\n"
                    }
                ]
            }
        ]
    }
]