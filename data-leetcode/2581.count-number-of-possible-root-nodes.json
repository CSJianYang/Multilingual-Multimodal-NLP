[
    {
        "title": "Count Number of Possible Root Nodes",
        "question_content": "Alice has an undirected tree with n nodes labeled from 0 to n - 1. The tree is represented as a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nAlice wants Bob to find the root of the tree. She allows Bob to make several guesses about her tree. In one guess, he does the following:\n\n\tChooses two distinct integers u and v such that there exists an edge [u, v] in the tree.\n\tHe tells Alice that u is the parent of v in the tree.\n\nBob's guesses are represented by a 2D integer array guesses where guesses[j] = [uj, vj] indicates Bob guessed uj to be the parent of vj.\nAlice being lazy, does not reply to each of Bob's guesses, but just says that at least k of his guesses are true.\nGiven the 2D integer arrays edges, guesses and the integer k, return the number of possible nodes that can be the root of Alice's tree. If there is no such tree, return 0.\n&nbsp;\nExample 1:\n\n\nInput: edges = [[0,1],[1,2],[1,3],[4,2]], guesses = [[1,3],[0,1],[1,0],[2,4]], k = 3\nOutput: 3\nExplanation: \nRoot = 0, correct guesses = [1,3], [0,1], [2,4]\nRoot = 1, correct guesses = [1,3], [1,0], [2,4]\nRoot = 2, correct guesses = [1,3], [1,0], [2,4]\nRoot = 3, correct guesses = [1,0], [2,4]\nRoot = 4, correct guesses = [1,3], [1,0]\nConsidering 0, 1, or 2 as root node leads to 3 correct guesses.\n\nExample 2:\n\n\nInput: edges = [[0,1],[1,2],[2,3],[3,4]], guesses = [[1,0],[3,4],[2,1],[3,2]], k = 1\nOutput: 5\nExplanation: \nRoot = 0, correct guesses = [3,4]\nRoot = 1, correct guesses = [1,0], [3,4]\nRoot = 2, correct guesses = [1,0], [2,1], [3,4]\nRoot = 3, correct guesses = [1,0], [2,1], [3,2], [3,4]\nRoot = 4, correct guesses = [1,0], [2,1], [3,2]\nConsidering any node as root will give at least 1 correct guess. \n\n&nbsp;\nConstraints:\n\n\tedges.length == n - 1\n\t2 <= n <= 105\n\t1 <= guesses.length <= 105\n\t0 <= ai, bi, uj, vj <= n - 1\n\tai != bi\n\tuj != vj\n\tedges represents a valid tree.\n\tguesses[j] is an edge of the tree.\n\tguesses is unique.\n\t0 <= k <= guesses.length",
        "solutions": [
            {
                "id": 3256065,
                "title": "re-rooting-o-n-explained",
                "content": "# Rerooting\\n*It is a technique where we solve a given problem for all roots.*\\nThis is a similiar template to my previous post [Solution of LC 2583](https://leetcode.com/problems/difference-between-maximum-and-minimum-price-sum/discuss/3052596/Re-rooting-or-O(N)-or-Explained)\\n\\n**Steps**\\n1.  Arbitrary root the tree, lets take `node 0` for explanation.\\n2.  Solve the given problem as if it was rooted at `node 0`.\\n3.  Similarily solve the problem for all nodes\\n\\nEven if you have never heard of this term before, no problem it just **DFS**. In this post I will explain how to solve this particular question even if you have never done rerooting before. \\n\\nIf you want proper resources for learning/reading about re-rooting then refer these. \\n1. \\t[Re rooting](https://usaco.guide/gold/all-roots?lang=java)\\n2. \\t[Re rooting section of this book](https://dp-book.com/Dynamic_Programming.pdf)\\n\\n\\n\\nFirstly lets solve a **simpler** task.\\n`Given a rooted tree (root 0) find the number of guesses which are correct`. \\n\\n\\n1. run a dfs storing parent of each node in  `parents` array. \\n2. count the number of guesses which are correct. \\n\\nLets consider this tree as int the first example. \\n![image](https://assets.leetcode.com/users/images/00cd26aa-8253-4421-8c3b-d2082615a4fd_1677943850.0044782.png)\\n\\nThe correct_guesses are 3, (see the first example for more)\\n\\nNow what if we root the tree at node 1.  Atmost how many correct_guesses will change\\n**key observation**: atmost correct guesses changes by  **1**.\\n1. if 0->1 and 1->0 both are present in  guesses array\\n\\t\\t0->1 gets removed as 1 is parent of 0. But due to presence of 1->0 the number of correct guesses is preserved.\\n2. if 0->1 present \\n        number of correct gusses decreases by one\\n3.  if 1->0 present\\n       number of corrext guessed increases by one\\n4. else no changes\\n\\nSo simply run another dfs with correct_guesses from parent as a parameter and update the number of required nodes.\\n\\n```\\nclass Solution {\\n    private int[] parents; //parents[i] => parent of vertex i if tree was rooted at vertex 0.\\n    int answer=0;      //required answer\\n    int k;\\n    List<List<Integer>> tree;\\n    List<HashSet<Integer>> guess_graph;\\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\\n        this.tree = new ArrayList<>();\\n        this.guess_graph = new ArrayList<>();\\n        this.k = k;\\n        int n = edges.length+1;\\n        for(int i=0;i<n;i++) {\\n            tree.add(new ArrayList<>());   //Initialize tree and guesses\\n            guess_graph.add(new HashSet<>());\\n        }\\n        for(int[] edge: edges){\\n            tree.get(edge[0]).add(edge[1]);  //Fill the tree\\n            tree.get(edge[1]).add(edge[0]);\\n        }\\n        for(int[] g: guesses){\\n            guess_graph.get(g[0]).add(g[1]); //Fill guesses\\n        }\\n        parents = new int[n];\\n        int correct_guesses = 0;\\n        fill_parent(0,-1);  //Fill the parents array\\n        for(int i=1;i<n;i++){\\n            int p = parents[i];\\n            if(guess_graph.get(p).contains(i)) correct_guesses++;  //If its a correct guess increase the number of guesses\\n        }\\n        if(correct_guesses >= k) answer++;  //If 0 is a possible node increase answer\\n        for(int c: tree.get(0)) dfs(c,0, correct_guesses); //Second dfs\\n        return answer;\\n    }\\n    private void fill_parent(int node,int parent){\\n        parents[node] = parent;\\n        for(int child: tree.get(node)){\\n            if(child==parent) continue;\\n            fill_parent(child,node);\\n        }\\n    }\\n    private void dfs(int node, int parent,int correct_guesses){\\n        int cur = correct_guesses;\\n        if(guess_graph.get(parent).contains(node)) cur--;\\n        if(guess_graph.get(node).contains(parent)) cur++;\\n        if(cur>=k) answer++;\\n        for(int child: tree.get(node)){\\n            if(child!=parent) dfs(child,node,cur);\\n        }\\n    }\\n}\\n```\\n\\nSpace Complexity -> O(N)    \\nTime Complexity  -> O(N)    \\n\\n**Follow up** question? \\nWhat if `ancestors` were given in guesses and not parents, how would you solve this problem, (`with n<=1000 and guesses.length<=1000`) ?? \\nFollow up discussion [comment 1](https://leetcode.com/problems/count-number-of-possible-root-nodes/discuss/3256065/Re-rooting-or-O(N)-or-Explained/1832466)    ,   [comment 2](https://leetcode.com/problems/count-number-of-possible-root-nodes/discuss/3256065/Re-rooting-or-O(N)-or-Explained/1833981)\\n\\nOther rerooting questions from leetcode->\\n1. [2583](https://leetcode.com/problems/difference-between-maximum-and-minimum-price-sum/)\\n2. [834](https://leetcode.com/problems/sum-of-distances-in-tree/)\\n\\nMore rerooting problems [Enjoy!](https://leetcode.com/problems/difference-between-maximum-and-minimum-price-sum/discuss/3052596/Re-rooting-or-O(N)-or-Explained/1760014)\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[] parents; //parents[i] => parent of vertex i if tree was rooted at vertex 0.\\n    int answer=0;      //required answer\\n    int k;\\n    List<List<Integer>> tree;\\n    List<HashSet<Integer>> guess_graph;\\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\\n        this.tree = new ArrayList<>();\\n        this.guess_graph = new ArrayList<>();\\n        this.k = k;\\n        int n = edges.length+1;\\n        for(int i=0;i<n;i++) {\\n            tree.add(new ArrayList<>());   //Initialize tree and guesses\\n            guess_graph.add(new HashSet<>());\\n        }\\n        for(int[] edge: edges){\\n            tree.get(edge[0]).add(edge[1]);  //Fill the tree\\n            tree.get(edge[1]).add(edge[0]);\\n        }\\n        for(int[] g: guesses){\\n            guess_graph.get(g[0]).add(g[1]); //Fill guesses\\n        }\\n        parents = new int[n];\\n        int correct_guesses = 0;\\n        fill_parent(0,-1);  //Fill the parents array\\n        for(int i=1;i<n;i++){\\n            int p = parents[i];\\n            if(guess_graph.get(p).contains(i)) correct_guesses++;  //If its a correct guess increase the number of guesses\\n        }\\n        if(correct_guesses >= k) answer++;  //If 0 is a possible node increase answer\\n        for(int c: tree.get(0)) dfs(c,0, correct_guesses); //Second dfs\\n        return answer;\\n    }\\n    private void fill_parent(int node,int parent){\\n        parents[node] = parent;\\n        for(int child: tree.get(node)){\\n            if(child==parent) continue;\\n            fill_parent(child,node);\\n        }\\n    }\\n    private void dfs(int node, int parent,int correct_guesses){\\n        int cur = correct_guesses;\\n        if(guess_graph.get(parent).contains(node)) cur--;\\n        if(guess_graph.get(node).contains(parent)) cur++;\\n        if(cur>=k) answer++;\\n        for(int child: tree.get(node)){\\n            if(child!=parent) dfs(child,node,cur);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256127,
                "title": "c-dfs-easy-to-understand-o-n-o-nlogn-intuition-illustration",
                "content": "## Approach\\n<hr>\\n\\nThis problem can be divided into following subproblems:\\n\\n1. If the node is rooted at `0`, are >= `k` edges of the tree present in `guesses`?\\n2. If the node is rooted at `1`, are >= `k` edges of the tree present in `guesses`?\\n3. ... for all nodes `n`\\n\\nHow do we do this efficiently?\\n\\nSay you have a tree rooted at node `0`, and it has child node `1`.\\nTo get the tree rooted at `1`, you only need to reverse the edge `(0, 1)`.\\n\\nIf you have the answer for node `0`, you can simply:\\n- subtract 1 if edge `(0, 1)` is present in `guesses`.\\n- Add 1 if edge `(1, 0)` is present in `guesses`.\\n\\nThe below figure illustrates this:\\n![null (1).png](https://assets.leetcode.com/users/images/6e0c52d4-c334-4a3d-85dc-f02162aca306_1677945696.526142.png)\\n\\n\\n\\nAlgorithm:\\n1. Store the edges in a `map` or `unordered_map`, I am using `map` here.\\n1. Get the answer if the tree is rooted at node `0`.\\n2. Start a DFS at node `0` and perform the above described procedure.\\n\\nTime Complexity: `O(nlogn)`\\n\\nNote: You can reduce the time complexity to `O(n)` if you hash the edges appropriately, and store in `unordered_map`.\\n\\n## Code\\n<hr>\\n\\n```cpp\\nclass Solution {\\npublic:\\n    //used to hash edges\\n    map<pair<int, int>, bool> mp;\\n\\n    //get answer for node 0\\n    int get_ans(unordered_map<int, list<int>>& adj, int src, vector<bool>& vis){\\n        vis[src] = 1;\\n        int ans = 0;\\n        for(auto i: adj[src]){\\n            if(!vis[i]){\\n                ans += (mp.count({src, i}) + get_ans(adj, i, vis));\\n            }\\n        }\\n        return ans;\\n    }\\n    //stores the number of nodes where edges in guesses >= k\\n    int anss = 0;\\n    \\n    void dfs(unordered_map<int, list<int>>& adj, vector<bool>& vis, int k, int src, int ans){\\n        if(ans >= k) anss++;\\n        vis[src] = 1;\\n        for(auto i: adj[src]){\\n            if(!vis[i]){\\n                dfs(adj, vis, k, i, ans - mp.count({src, i}) + mp.count({i, src}));\\n            }\\n        }\\n    }\\n    \\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        unordered_map<int, list<int>> adj;\\n        for(auto i: edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        for(auto i: guesses){\\n            mp[{i[0], i[1]}] = 1;\\n        }\\n        int n = edges.size()+1;\\n        vector<bool> vis(n, 0);\\n        int ans = get_ans(adj, 0, vis);\\n        fill(vis.begin(), vis.end(), 0);\\n        dfs(adj, vis, k, 0, ans);\\n        return anss;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search",
                    "Ordered Map"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    //used to hash edges\\n    map<pair<int, int>, bool> mp;\\n\\n    //get answer for node 0\\n    int get_ans(unordered_map<int, list<int>>& adj, int src, vector<bool>& vis){\\n        vis[src] = 1;\\n        int ans = 0;\\n        for(auto i: adj[src]){\\n            if(!vis[i]){\\n                ans += (mp.count({src, i}) + get_ans(adj, i, vis));\\n            }\\n        }\\n        return ans;\\n    }\\n    //stores the number of nodes where edges in guesses >= k\\n    int anss = 0;\\n    \\n    void dfs(unordered_map<int, list<int>>& adj, vector<bool>& vis, int k, int src, int ans){\\n        if(ans >= k) anss++;\\n        vis[src] = 1;\\n        for(auto i: adj[src]){\\n            if(!vis[i]){\\n                dfs(adj, vis, k, i, ans - mp.count({src, i}) + mp.count({i, src}));\\n            }\\n        }\\n    }\\n    \\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        unordered_map<int, list<int>> adj;\\n        for(auto i: edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        for(auto i: guesses){\\n            mp[{i[0], i[1]}] = 1;\\n        }\\n        int n = edges.size()+1;\\n        vector<bool> vis(n, 0);\\n        int ans = get_ans(adj, 0, vis);\\n        fill(vis.begin(), vis.end(), 0);\\n        dfs(adj, vis, k, 0, ans);\\n        return anss;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256280,
                "title": "dynamic-programming-o-n-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt can be solved using dynamic programming by using `{parent,node}` as state.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Instead of using a vector to store memoization cases we use **map of type pair<int,int>** that store the pair `(parent,node)` as a state.\\n*  Now assume a $$node$$  as the root and count all the guesses that are correct if $$node$$ is the root.\\n*  we use dfs to count total number of guesses that are correct at this point we are doing dfs but if we clearly observe there is repetition of cases in the form `{par,node}` hence we can do dynamic programming\\n\\n* When we travel from par->node we should store all the guess that are correct in that subtree in our memoization state.\\n\\n* Why `O(n)` is the total memory space?\\nReason:\\nSince there can be two possibility for any two nodes of the tree\\nfor example if there is edge between x and y, 2 states are possible between them that is `{x,y}` and `{y,x}` therefore for a total of `n-1 edges` there will be around `2n` cases.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int>visited;\\n    map<pair<int,int>,int>g;\\n    \\n    int dp(vector<vector<int>>&adj,int node,int par){\\n        if(visited.count(make_pair(par,node)))\\n            return visited[make_pair(par,node)];\\n        \\n        int guess=g.count(make_pair(par,node));\\n        \\n        for(int i=0;i<adj[node].size();i++){\\n            if(adj[node][i]!=par){\\n                guess+=dp(adj,adj[node][i],node);\\n            }\\n        }\\n        return visited[make_pair(par,node)]=guess;\\n    }\\n    \\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) \\n    {\\n        \\n        int n=edges.size();\\n        for(int i=0;i<guesses.size();i++){\\n            g[make_pair(guesses[i][0],guesses[i][1])]=1;\\n            \\n        }\\n        vector<vector<int>>adj(n+1);\\n        for(int i=0;i<n;i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int count=0;\\n        for(int i=0;i<n+1;i++) {\\n            int guess=dp(adj,i,-1);\\n            if(guess>=k)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int>visited;\\n    map<pair<int,int>,int>g;\\n    \\n    int dp(vector<vector<int>>&adj,int node,int par){\\n        if(visited.count(make_pair(par,node)))\\n            return visited[make_pair(par,node)];\\n        \\n        int guess=g.count(make_pair(par,node));\\n        \\n        for(int i=0;i<adj[node].size();i++){\\n            if(adj[node][i]!=par){\\n                guess+=dp(adj,adj[node][i],node);\\n            }\\n        }\\n        return visited[make_pair(par,node)]=guess;\\n    }\\n    \\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) \\n    {\\n        \\n        int n=edges.size();\\n        for(int i=0;i<guesses.size();i++){\\n            g[make_pair(guesses[i][0],guesses[i][1])]=1;\\n            \\n        }\\n        vector<vector<int>>adj(n+1);\\n        for(int i=0;i<n;i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int count=0;\\n        for(int i=0;i<n+1;i++) {\\n            int guess=dp(adj,i,-1);\\n            if(guess>=k)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256266,
                "title": "python-dfs-dp-o-n-trivial-solution",
                "content": "# Intuition\\nlet n = len(edges)\\nand # of correct witrh guesses is fixed if we explore from i->j (since it\\'s a tree, which means there always only one path between nodes)\\n\\nthus we will only have 2n possible values (i->j, j<-i)\\n\\nand finally let we set each i as root, check how many root  align with guesses >= k\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code  - Version 1 (Mar 05, 2023 Ver)\\nthis version only when tree is linked-list will be time O(n)\\nif there are a node as center and every other node link to center it will be O(n^2)\\n\\n\\n```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        # n memory\\n        # build graph\\n        graph = defaultdict(list)\\n        for i, j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n        \\n        gt = set((i, j) for i, j in guesses)\\n\\n        # dfs traverse from parent -> i\\n        @cache\\n        def get_correct_pairs(i, parent):\\n            next_nodes = graph[i]\\n            n_correct = 0\\n            for next_node in next_nodes:\\n                if next_node == parent:\\n                    continue\\n                if (i, next_node) in gt:\\n                    n_correct += 1\\n                n_correct += get_correct_pairs(next_node, i)\\n            return n_correct\\n        \\n        ans = 0\\n        for i in graph:\\n            if get_correct_pairs(i, None) >= k:\\n                ans += 1\\n        return ans\\n            \\n```\\n\\n\\n# Code  - Version 2 (Sep 25, 2023 Ver)\\nthanks for @cy171\\'s patiently explain I finally realize the blindspot I meet.\\n\\nthe optimization idea is that\\n```\\nf(i, next) = f_sum_out(next) - f(next, i)\\nf_sum_out(j) = sum(f(j, i) for all i in graph[j]) \\n```\\n\\nthe only change is add a map `graph_out_sum` used to calculate the out direction sum.\\n\\n```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        # build graph\\n        graph = defaultdict(list)\\n        for i, j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n        \\n        gt = set((i, j) for i, j in guesses)\\n\\n        graph_added = defaultdict(set)\\n        graph_out_sum = defaultdict(int)\\n\\n        # random traverse        \\n        @cache\\n        def get_correct_pairs(i, parent):\\n            next_nodes = graph[i]\\n            if len(graph_added[i]) == next_nodes:\\n                return graph_out_sum[i] - get_correct_pairs(i, parent)\\n            else:\\n                n_correct = 0\\n                for next_node in next_nodes:\\n                    if next_node == parent:\\n                        continue\\n                    if (i, next_node) in gt:\\n                        graph_out_sum[i] += 1\\n                        n_correct += 1\\n\\n                    n_correct += get_correct_pairs(next_node, i)\\n                    graph_out_sum[i] += get_correct_pairs(next_node, i)\\n                    graph_added[i].add((next_node, i))\\n                    \\n                return n_correct\\n        \\n        ans = 0\\n        for i in graph:\\n            if get_correct_pairs(i, None) >= k:\\n                ans += 1\\n        return ans\\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        # n memory\\n        # build graph\\n        graph = defaultdict(list)\\n        for i, j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n        \\n        gt = set((i, j) for i, j in guesses)\\n\\n        # dfs traverse from parent -> i\\n        @cache\\n        def get_correct_pairs(i, parent):\\n            next_nodes = graph[i]\\n            n_correct = 0\\n            for next_node in next_nodes:\\n                if next_node == parent:\\n                    continue\\n                if (i, next_node) in gt:\\n                    n_correct += 1\\n                n_correct += get_correct_pairs(next_node, i)\\n            return n_correct\\n        \\n        ans = 0\\n        for i in graph:\\n            if get_correct_pairs(i, None) >= k:\\n                ans += 1\\n        return ans\\n            \\n```\n```\\nf(i, next) = f_sum_out(next) - f(next, i)\\nf_sum_out(j) = sum(f(j, i) for all i in graph[j]) \\n```\n```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        # build graph\\n        graph = defaultdict(list)\\n        for i, j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n        \\n        gt = set((i, j) for i, j in guesses)\\n\\n        graph_added = defaultdict(set)\\n        graph_out_sum = defaultdict(int)\\n\\n        # random traverse        \\n        @cache\\n        def get_correct_pairs(i, parent):\\n            next_nodes = graph[i]\\n            if len(graph_added[i]) == next_nodes:\\n                return graph_out_sum[i] - get_correct_pairs(i, parent)\\n            else:\\n                n_correct = 0\\n                for next_node in next_nodes:\\n                    if next_node == parent:\\n                        continue\\n                    if (i, next_node) in gt:\\n                        graph_out_sum[i] += 1\\n                        n_correct += 1\\n\\n                    n_correct += get_correct_pairs(next_node, i)\\n                    graph_out_sum[i] += get_correct_pairs(next_node, i)\\n                    graph_added[i].add((next_node, i))\\n                    \\n                return n_correct\\n        \\n        ans = 0\\n        for i in graph:\\n            if get_correct_pairs(i, None) >= k:\\n                ans += 1\\n        return ans\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267188,
                "title": "traverse-with-memoisation",
                "content": "We use an adjacency list (undirected), tracking weight of each edge (initially zero).\\n\\nFor directed edges from `guesses`, we set weight to be `1`.\\n\\nThen, we pick a node as a root node, and traverse from that node and sum the weights. The result is the number of correct guesses for that node.\\n\\nWe repeat this for each node. For O(n) solution, we memoise the result for each directed edge `u` -> `v`.\\n\\nFinally, we count nodes that have `k` or more correct guesses.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        @cache\\n        def dfs(u: int, v: int) -> int:\\n            res = 0\\n            for w, score in al[v].items():\\n                res += score + dfs(v, w) if w != u else 0\\n            return res\\n        al = [{} for _ in range(len(edges) + 1)]\\n        for a, b in edges:\\n            al[a][b] = al[b][a] = 0\\n        for u, v in guesses:\\n            al[u][v] = 1\\n        return sum(1 if dfs(-1, u) >= k else 0 for u in range(len(edges) + 1))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        @cache\\n        def dfs(u: int, v: int) -> int:\\n            res = 0\\n            for w, score in al[v].items():\\n                res += score + dfs(v, w) if w != u else 0\\n            return res\\n        al = [{} for _ in range(len(edges) + 1)]\\n        for a, b in edges:\\n            al[a][b] = al[b][a] = 0\\n        for u, v in guesses:\\n            al[u][v] = 1\\n        return sum(1 if dfs(-1, u) >= k else 0 for u in range(len(edges) + 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256072,
                "title": "short-python-template-for-tree-based-dp-problems",
                "content": "if you dont know rerooting or do not want to write two dfs, you can try the template below. \\n\\nit is not always O(n). e.g. it is O(n^2) for LC 2538 in the worst case with star graph. But it seems enough for general interviews and contests here\\n\\n\\t    adj, g =defaultdict(set), Counter(map(tuple,guesses))\\n        for i,j in edges:\\n            adj[i].add(j)\\n            adj[j].add(i)\\n              \\n        @cache\\n        def t(cur,prev):\\n            return g[prev,cur]+sum(t(kid,cur) for kid in adj[cur]-{prev})\\n\\n        return sum(t(i,-1)>=k for i in adj)\\n\\nFor tree-based dp problems that give you edges as inputs, below is the template\\n\\n1. store edges into an adjancent list\\n\\n2. define a dfs function with two key parameters (cur, prev) to control the direction we will move along an edge between cur and prev\\n\\n3. within dfs(cur,prev), the recursion is to call t(nxt,cur) for nxt in adj[cur]-{prev}\\n\\n4. we add memorization (@cache) so that each edge between cur and prev will only be visited twice: one from cur to prev, one from prev to cur\\n\\n5. we call dfs(i,-1) for i in range(n). -1 denotes no prev for i, so i is the root.\\n\\nUsing this template, we can solve all the following problems with minor edits.\\nhttps://leetcode.com/problems/difference-between-maximum-and-minimum-price-sum/discuss/3052569/template-for-tree-based-dp-problems-with-edges-inputs\\n\\nhttps://leetcode.com/discuss/interview-question/2751188/Lucid-OA-new-grad-SWE\\n\\nhttps://leetcode.com/discuss/interview-question/1463104/Media.net-or-OA-or-Minimum-cost-to-buy-oranges\\n\\nhttps://leetcode.com/discuss/interview-question/2639890/Media.Net(Directi)-OA-On-campus-Questions-%3A)\\n\\nhttps://leetcode.com/problems/minimum-score-after-removals-on-a-tree/\\n\\nhttps://leetcode.com/discuss/interview-question/2788156/OA-2022-or-Pythagorean-Triplets",
                "solutionTags": [
                    "Python"
                ],
                "code": "if you dont know rerooting or do not want to write two dfs, you can try the template below. \\n\\nit is not always O(n). e.g. it is O(n^2) for LC 2538 in the worst case with star graph. But it seems enough for general interviews and contests here\\n\\n\\t    adj, g =defaultdict(set), Counter(map(tuple,guesses))\\n        for i,j in edges:\\n            adj[i].add(j)\\n            adj[j].add(i)\\n              \\n        @cache\\n        def t(cur,prev):\\n            return g[prev,cur]+sum(t(kid,cur) for kid in adj[cur]-{prev})\\n\\n        return sum(t(i,-1)>=k for i in adj)\\n\\nFor tree-based dp problems that give you edges as inputs, below is the template\\n\\n1. store edges into an adjancent list\\n\\n2. define a dfs function with two key parameters (cur, prev) to control the direction we will move along an edge between cur and prev\\n\\n3. within dfs(cur,prev), the recursion is to call t(nxt,cur) for nxt in adj[cur]-{prev}\\n\\n4. we add memorization (@cache) so that each edge between cur and prev will only be visited twice: one from cur to prev, one from prev to cur\\n\\n5. we call dfs(i,-1) for i in range(n). -1 denotes no prev for i, so i is the root.\\n\\nUsing this template, we can solve all the following problems with minor edits.\\nhttps://leetcode.com/problems/difference-between-maximum-and-minimum-price-sum/discuss/3052569/template-for-tree-based-dp-problems-with-edges-inputs\\n\\nhttps://leetcode.com/discuss/interview-question/2751188/Lucid-OA-new-grad-SWE\\n\\nhttps://leetcode.com/discuss/interview-question/1463104/Media.net-or-OA-or-Minimum-cost-to-buy-oranges\\n\\nhttps://leetcode.com/discuss/interview-question/2639890/Media.Net(Directi)-OA-On-campus-Questions-%3A)\\n\\nhttps://leetcode.com/problems/minimum-score-after-removals-on-a-tree/\\n\\nhttps://leetcode.com/discuss/interview-question/2788156/OA-2022-or-Pythagorean-Triplets",
                "codeTag": "Python3"
            },
            {
                "id": 3257554,
                "title": "c-python-once-dfs",
                "content": "> **I know almost nothing about English, pointing out the mistakes in my article would be much appreciated.**\\n\\n> **In addition, I\\'m too weak, please be critical of my ideas.**\\n---\\n\\n# Intuition\\n1. Think about these 2 questions:\\n    - What happens if we point a special vertex as the root?\\n    - How does the situation change when we select another vertex from the root\\'s children as the new root?\\n2. For the first question, we can use a dfs to count correct pairs in `guesses` and determine the father-child relationship of the tree.\\n3. For the second question, once we reroot from $x$ to its child $c$, we can easily find the only change is edge from $x$ to $c$. It will change the correct count.\\n    - **If there is a right guess from $x$ to $c$, the change will break this correctness. So the correct count should be decremented by 1.**\\n    - **If there is a wrong guess from $x$ to $c$, the change will fix this wrong. So the correct count should be incremented by 1.**\\n    ![image.png](https://assets.leetcode.com/users/images/96c005b7-f4d0-4f51-98f7-a4a6621ca071_1677963854.0925817.png)\\n4. Travel from father to its children, record and update $d$ as the difference between the $0$-rooted tree and $x$-rooted tree. \\n    Suppose the $0$-rooted tree has $cnt$ right pairs, so the $x$-rooted tree has $cnt+d$ right pairs. \\n    All the $cnt+d \\\\geq k$ will be the answer.\\n\\n# Approach\\n- Notice that in the first dfs, we don\\'t know the $cnt$. So we consider to record the count of $d$ for every $x$-rooted tree in a $mp$, and calculate the $cnt$ in one dfs.\\n\\n- After dfs, we enumerate $mp$ and count the answer. So that we can use one dfs to solve the problem.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        vector<vector<int>> g(edges.size() + 1);\\n        for (auto &e: edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        vector<unordered_map<int, int>> gu(edges.size() + 1);\\n        for (auto &e: guesses)\\n            gu[e[0]][e[1]]++;\\n        unordered_map<int, int> mp;\\n        // cnt is the correct pairs of guesses on 0-rooted tree\\n        int cnt = 0;\\n        // fa is father of x, d is the difference from the 0-rooted \\n        function<void(int, int, int)> dfs = [&](int x, int fa, int d) -> void {\\n            mp[d]++;\\n            for (int c: g[x]) {\\n                if (c == fa) continue;\\n                cnt += gu[x][c];\\n                dfs(c, x, d + gu[c][x] - gu[x][c]);\\n            }\\n        };\\n        dfs(0, -1, 0);\\n        return accumulate(mp.begin(), mp.end(), 0, [&](int s, auto p) -> int {\\n            return s + p.second * (p.first + cnt >= k);\\n        });\\n    }\\n};\\n```\\n``` Python []\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        g = [set() for i in range(len(edges) + 1)]\\n        for e in edges:\\n            g[e[0]].add(e[1])\\n            g[e[1]].add(e[0])\\n        gu = [defaultdict(int) for i in range(len(edges) + 1)]\\n        for e in guesses:\\n            gu[e[0]][e[1]] += 1\\n        mp = defaultdict(int)\\n        # cnt is the correct pairs of guesses on 0-rooted tree\\n        cnt = 0\\n        # fa is father of x, d is the difference from the 0-rooted \\n        def dfs(x, fa, d):\\n            nonlocal cnt\\n            mp[d] += 1\\n            for c in g[x] - {fa}:\\n                cnt += gu[x][c]\\n                dfs(c, x, d + gu[c][x] - gu[x][c])\\n        dfs(0, -1, 0)\\n        return sum(v * (d + cnt >= k) for d,v in mp.items())\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        vector<vector<int>> g(edges.size() + 1);\\n        for (auto &e: edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        vector<unordered_map<int, int>> gu(edges.size() + 1);\\n        for (auto &e: guesses)\\n            gu[e[0]][e[1]]++;\\n        unordered_map<int, int> mp;\\n        // cnt is the correct pairs of guesses on 0-rooted tree\\n        int cnt = 0;\\n        // fa is father of x, d is the difference from the 0-rooted \\n        function<void(int, int, int)> dfs = [&](int x, int fa, int d) -> void {\\n            mp[d]++;\\n            for (int c: g[x]) {\\n                if (c == fa) continue;\\n                cnt += gu[x][c];\\n                dfs(c, x, d + gu[c][x] - gu[x][c]);\\n            }\\n        };\\n        dfs(0, -1, 0);\\n        return accumulate(mp.begin(), mp.end(), 0, [&](int s, auto p) -> int {\\n            return s + p.second * (p.first + cnt >= k);\\n        });\\n    }\\n};\\n```\n``` Python []\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        g = [set() for i in range(len(edges) + 1)]\\n        for e in edges:\\n            g[e[0]].add(e[1])\\n            g[e[1]].add(e[0])\\n        gu = [defaultdict(int) for i in range(len(edges) + 1)]\\n        for e in guesses:\\n            gu[e[0]][e[1]] += 1\\n        mp = defaultdict(int)\\n        # cnt is the correct pairs of guesses on 0-rooted tree\\n        cnt = 0\\n        # fa is father of x, d is the difference from the 0-rooted \\n        def dfs(x, fa, d):\\n            nonlocal cnt\\n            mp[d] += 1\\n            for c in g[x] - {fa}:\\n                cnt += gu[x][c]\\n                dfs(c, x, d + gu[c][x] - gu[x][c])\\n        dfs(0, -1, 0)\\n        return sum(v * (d + cnt >= k) for d,v in mp.items())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256889,
                "title": "video-explanation-with-intuition-of-every-step",
                "content": "# Explanation\\n\\nhttps://youtu.be/k4PNslLoQTY\\n\\n[Click here if the preview above doesn\\'t works](https://youtu.be/k4PNslLoQTY)\\n\\nVideo is being processed and will be public today at 11:45PM IST.\\n\\n# Code\\n```\\nstruct SegTree {\\n    vector<int> tree, lazy;\\n    int n;\\n    \\n    SegTree (int _n) : n (_n) {\\n        tree.resize(4*n, 0);\\n        lazy.resize(4*n, 0);\\n    }\\n    \\n    void pushLazyUpdates (int l, int r, int i) {\\n        if (l != r) {\\n            lazy[i*2+1] += lazy[i];\\n            lazy[i*2+2] += lazy[i];\\n        }\\n        else {\\n            tree[i] += lazy[i];\\n        }\\n        lazy[i]  = 0;\\n    }\\n    \\n    int query (int ind, int l = 0, int r = -1, int i = 0) {\\n        if (r == -1) r += n;\\n        pushLazyUpdates (l, r, i);\\n        \\n        if (l == r) return tree[i];\\n        \\n        int m = (l+r) >> 1;\\n        int result = (ind <= m)? query (ind, l, m, i*2+1) : query (ind, m+1, r, i*2+2);\\n        return result;\\n    }\\n    \\n    void rangeAddition (int x, int y, int val, int l = 0, int r = -1, int i = 0) {\\n        if (r == -1) r += n;\\n        pushLazyUpdates (l, r, i);\\n        \\n        if (r < x || l > y) return;\\n        if (l >= x && r <= y) {\\n            lazy[i] += val;\\n            pushLazyUpdates (l, r, i);\\n            return;\\n        }\\n        \\n        int m = (l+r) >> 1;\\n        rangeAddition (x, y, val, l, m, i*2+1);\\n        rangeAddition (x, y, val, m+1, r, i*2+2);        \\n    }\\n};\\n\\nclass Solution {\\n    \\n    vector<vector<int>> g;\\n    vector<int> lft, rgt, cur_parent;\\n    \\n    void EulerTour (int src, int par, int& cnt) {\\n        lft[src] = cnt;\\n        cur_parent[src] = par;\\n        \\n        for (auto i : g[src]) {\\n            if (i == par) continue;\\n            cnt ++;\\n            EulerTour (i, src, cnt);\\n        }\\n        rgt[src] = cnt;\\n    }\\n    \\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int nodes = edges.size() + 1;\\n        \\n        lft.clear(), rgt.clear(), g.clear(), cur_parent.clear();\\n        lft.resize(nodes), rgt.resize(nodes), g.resize(nodes), cur_parent.resize(nodes);\\n        \\n        for (auto e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        int cnt = 0;\\n        EulerTour (0, -1, cnt);\\n                \\n        SegTree seg_tree (nodes);\\n        for (auto g : guesses) {\\n            int u = g[0], v = g[1];\\n            \\n            if (cur_parent[u] == v) {\\n                seg_tree.rangeAddition (lft[u], rgt[u], 1);\\n            }\\n            else {\\n                assert (cur_parent[v] == u);\\n                \\n                seg_tree.rangeAddition (lft[v], rgt[v], -1);\\n                seg_tree.rangeAddition (0, nodes-1, 1);\\n            }\\n        }\\n        \\n        int result = 0;\\n        for (int j = 0; j < nodes; j ++) \\n            if (seg_tree.query(j) >= k) result ++;\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct SegTree {\\n    vector<int> tree, lazy;\\n    int n;\\n    \\n    SegTree (int _n) : n (_n) {\\n        tree.resize(4*n, 0);\\n        lazy.resize(4*n, 0);\\n    }\\n    \\n    void pushLazyUpdates (int l, int r, int i) {\\n        if (l != r) {\\n            lazy[i*2+1] += lazy[i];\\n            lazy[i*2+2] += lazy[i];\\n        }\\n        else {\\n            tree[i] += lazy[i];\\n        }\\n        lazy[i]  = 0;\\n    }\\n    \\n    int query (int ind, int l = 0, int r = -1, int i = 0) {\\n        if (r == -1) r += n;\\n        pushLazyUpdates (l, r, i);\\n        \\n        if (l == r) return tree[i];\\n        \\n        int m = (l+r) >> 1;\\n        int result = (ind <= m)? query (ind, l, m, i*2+1) : query (ind, m+1, r, i*2+2);\\n        return result;\\n    }\\n    \\n    void rangeAddition (int x, int y, int val, int l = 0, int r = -1, int i = 0) {\\n        if (r == -1) r += n;\\n        pushLazyUpdates (l, r, i);\\n        \\n        if (r < x || l > y) return;\\n        if (l >= x && r <= y) {\\n            lazy[i] += val;\\n            pushLazyUpdates (l, r, i);\\n            return;\\n        }\\n        \\n        int m = (l+r) >> 1;\\n        rangeAddition (x, y, val, l, m, i*2+1);\\n        rangeAddition (x, y, val, m+1, r, i*2+2);        \\n    }\\n};\\n\\nclass Solution {\\n    \\n    vector<vector<int>> g;\\n    vector<int> lft, rgt, cur_parent;\\n    \\n    void EulerTour (int src, int par, int& cnt) {\\n        lft[src] = cnt;\\n        cur_parent[src] = par;\\n        \\n        for (auto i : g[src]) {\\n            if (i == par) continue;\\n            cnt ++;\\n            EulerTour (i, src, cnt);\\n        }\\n        rgt[src] = cnt;\\n    }\\n    \\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int nodes = edges.size() + 1;\\n        \\n        lft.clear(), rgt.clear(), g.clear(), cur_parent.clear();\\n        lft.resize(nodes), rgt.resize(nodes), g.resize(nodes), cur_parent.resize(nodes);\\n        \\n        for (auto e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        int cnt = 0;\\n        EulerTour (0, -1, cnt);\\n                \\n        SegTree seg_tree (nodes);\\n        for (auto g : guesses) {\\n            int u = g[0], v = g[1];\\n            \\n            if (cur_parent[u] == v) {\\n                seg_tree.rangeAddition (lft[u], rgt[u], 1);\\n            }\\n            else {\\n                assert (cur_parent[v] == u);\\n                \\n                seg_tree.rangeAddition (lft[v], rgt[v], -1);\\n                seg_tree.rangeAddition (0, nodes-1, 1);\\n            }\\n        }\\n        \\n        int result = 0;\\n        for (int j = 0; j < nodes; j ++) \\n            if (seg_tree.query(j) >= k) result ++;\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256069,
                "title": "python-flip-parent-child-relation-by-dfs-explanation",
                "content": "Consider the figure of Example 1, we can find if we first consider the parent-child relation of the view of given root `0`:\\n- If we use node `1` as the root, the parent-child relation of `(0, 1)` is reversed to be `(1, 0)`\\n- If we use node `2` as the root, the parent-child relation of `(0, 1)` and `(1, 2)` is reversed. Other relations like `(1, 3)` still remain the same.\\n- If we use node `3` as the root, the parent-child relation of `(0, 1)` and `(1, 3)` is reversed.\\n- If we use node `4` as the root, the parent-child relation of `(0, 1)`, `(1, 2)` and `(2, 4)` is reversed.\\n\\nSo, we can conclude that, for a given new root `node`, all the parent-child relation of all edges from `0` to `node` will be reversed.\\nHere\\'s the steps to solve this question:\\n1. Count the correct guesses if given `0` as the root.\\n2. DFS through the tree with root `0`, flip edge of `(node_prev, node_next)` and count new correct guesses:\\n    - Correct guesses minus 1 if `(node_prev, node_next)` exist in guesses\\n    - Correct guesses plus 1 if `(node_next, node_prev)` exist in guesses\\n\\nThe answer can be count through the DFS process.\\n\\n```\\nclass Solution(object):\\n    def rootCount(self, edges, guesses, k):\\n        \"\"\"\\n        :type edges: List[List[int]]\\n        :type guesses: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        self.k = k\\n        g = set(map(tuple,guesses))\\n        uag = defaultdict(list)\\n        for a, b in edges:\\n            uag[a].append(b)\\n            uag[b].append(a)\\n        been = set([0])\\n        self.crr = 0\\n        def dfs(node):\\n            for n in uag[node]:\\n                if n in been:\\n                    continue\\n                been.add(n)\\n                self.crr += (node, n) in g\\n                dfs(n)\\n        def rev(node):\\n            for n in uag[node]:\\n                if n in been:\\n                    continue\\n                been.add(n)\\n                self.crr -= (node, n) in g\\n                self.crr += (n, node) in g\\n                if self.crr >= self.k:\\n                    self.ans += 1\\n                rev(n)\\n                self.crr -= (n, node) in g\\n                self.crr += (node, n) in g\\n        dfs(0)\\n        been = set([0])\\n        self.ans = int(self.crr >= k)\\n        rev(0)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def rootCount(self, edges, guesses, k):\\n        \"\"\"\\n        :type edges: List[List[int]]\\n        :type guesses: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        self.k = k\\n        g = set(map(tuple,guesses))\\n        uag = defaultdict(list)\\n        for a, b in edges:\\n            uag[a].append(b)\\n            uag[b].append(a)\\n        been = set([0])\\n        self.crr = 0\\n        def dfs(node):\\n            for n in uag[node]:\\n                if n in been:\\n                    continue\\n                been.add(n)\\n                self.crr += (node, n) in g\\n                dfs(n)\\n        def rev(node):\\n            for n in uag[node]:\\n                if n in been:\\n                    continue\\n                been.add(n)\\n                self.crr -= (node, n) in g\\n                self.crr += (n, node) in g\\n                if self.crr >= self.k:\\n                    self.ans += 1\\n                rev(n)\\n                self.crr -= (n, node) in g\\n                self.crr += (node, n) in g\\n        dfs(0)\\n        been = set([0])\\n        self.ans = int(self.crr >= k)\\n        rev(0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256068,
                "title": "dp-on-trees-intuition-re-rooting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Let\\'s consider \"0\" as the root of the tree \\n\\n![trees.jpg](https://assets.leetcode.com/users/images/d6bbc0a1-ed7c-4fd5-8122-650552adc3aa_1677943687.2807734.jpeg)\\n\\n- The ticked edges exist in guesses and the crossed ones do not, for zero we have a total of 3 correct guesses.\\n- Now, let\\'s say we want to calculate the answer considering \"1\" as the root. \\n- **What changed?** If you observe closely other than the edge between the 0 & 1, nothing else has changed. \\n- Thats the key to this problem, whenever we \"shift roots\" we just about the edge in which we traversed and nothing else changes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Calculate the answer considering \"0\" as the root, this is a standard dfs.\\n- Now, create another function for re-rooting, again let\\'s start from \"0\"\\n- If the node has no parent, then the contribution is same as the previously calculated guesses.\\n- Otherwise, we are re-rooting our tree from node \"A\" to \"B\" then the score for \"B\" is same as its parent \"A\" minus the previous guess i.e since the relationship has reversed, we must subtract the previous guess point (guess[\"A\"][\"B\"]) and add the point for the current guess point (guess[\"B\"][\"A\"])\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n> We visit every node twice, once during dfs calculation and once during the re-rooting.\\n\\n$$O(|vertices|+|edges|)$$\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> Standard adjacency list space complexity\\n\\n$$O(|vertices|+|edges|)$$\\n\\n# Similar problems\\n\\n- [Sum of distances in a tree](https://leetcode.com/problems/sum-of-distances-in-tree/description/\\n)\\n- [Road Improvement](https://codeforces.com/problemset/problem/543/D)\\n# Code\\n```\\n\\nint dfs(int root, vector<vector<int>> &adj,  map<int,map<int,int>> &guess, vector<int> &dp, int parent) {\\n        int correctlyGuessed = 0;\\n        vis[root]=1;\\n        for(auto &ch: adj[root]){\\n            if(ch == parent) continue;\\n            if(guess[root][ch]) correctlyGuessed++;\\n            correctlyGuessed += dfs(ch, adj, guess, dp, root);\\n        }\\n        return dp[root] = correctlyGuessed;\\n    }\\n    \\nint dp2(int root,  vector<vector<int>> &adj, map<int,map<int,int>> &guess, int k, vector<int> &dp, int parent) {\\n    int possibleRoots = 0;\\n    int correctlyGuessed = 0; //answer considering the current node as root\\n    if(parent != -1) {\\n        correctlyGuessed = dp[parent]\\n                    - guess[parent][root] //subtract previous edge guess\\n                    + guess[root][parent]; //add current edge guess\\n    } else {\\n        correctlyGuessed = dp[root];\\n    }\\n    dp[root] = correctlyGuessed; //update dp\\n    if(correct>=k) possibleRoots++; //possible root\\n    for(auto &ch: adj[root]){ //update children\\n        if(ch == parent) continue;\\n        possibleRoots += dp2(ch, adj, guess, k, dp, root);\\n    }\\n    return possibleRoots;\\n}\\n\\nint rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n    const int n = edges.size()+1;\\n    vector<int> dp(n);\\n    map<int,map<int,int>> guess;\\n    for(auto &x:guesses) {\\n        guess[x[0]][x[1]] = 1;\\n    }\\n    vector<vector<int>> adj(n);\\n    for(auto &x:edges){\\n        adj[x[0]].push_back(x[1]);\\n        adj[x[1]].push_back(x[0]);\\n    }\\n    dfs(0, adj, guess, k, dp, -1);\\n    return dp2(0, adj, guess, k, dp, -1);\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nint dfs(int root, vector<vector<int>> &adj,  map<int,map<int,int>> &guess, vector<int> &dp, int parent) {\\n        int correctlyGuessed = 0;\\n        vis[root]=1;\\n        for(auto &ch: adj[root]){\\n            if(ch == parent) continue;\\n            if(guess[root][ch]) correctlyGuessed++;\\n            correctlyGuessed += dfs(ch, adj, guess, dp, root);\\n        }\\n        return dp[root] = correctlyGuessed;\\n    }\\n    \\nint dp2(int root,  vector<vector<int>> &adj, map<int,map<int,int>> &guess, int k, vector<int> &dp, int parent) {\\n    int possibleRoots = 0;\\n    int correctlyGuessed = 0; //answer considering the current node as root\\n    if(parent != -1) {\\n        correctlyGuessed = dp[parent]\\n                    - guess[parent][root] //subtract previous edge guess\\n                    + guess[root][parent]; //add current edge guess\\n    } else {\\n        correctlyGuessed = dp[root];\\n    }\\n    dp[root] = correctlyGuessed; //update dp\\n    if(correct>=k) possibleRoots++; //possible root\\n    for(auto &ch: adj[root]){ //update children\\n        if(ch == parent) continue;\\n        possibleRoots += dp2(ch, adj, guess, k, dp, root);\\n    }\\n    return possibleRoots;\\n}\\n\\nint rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n    const int n = edges.size()+1;\\n    vector<int> dp(n);\\n    map<int,map<int,int>> guess;\\n    for(auto &x:guesses) {\\n        guess[x[0]][x[1]] = 1;\\n    }\\n    vector<vector<int>> adj(n);\\n    for(auto &x:edges){\\n        adj[x[0]].push_back(x[1]);\\n        adj[x[1]].push_back(x[0]);\\n    }\\n    dfs(0, adj, guess, k, dp, -1);\\n    return dp2(0, adj, guess, k, dp, -1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3256777,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>dp[100005];\\n    set<pair<int,int>>s;\\n    int k;\\n    int  find(int node,int p=-1)\\n    {\\n        int count=0;\\n        for(auto it:dp[node])\\n        {\\n            if(it!=p)\\n            {\\n                count+=s.count({node,it})+find(it,node);\\n            }\\n        }\\n        return count;\\n    }\\n    void find1(int node,int value,int &total,int p=-1)\\n    {\\n        if(value>=k)\\n        {\\n            total++;\\n        }\\n        for(auto it:dp[node])\\n        {\\n            if(it!=p)\\n            {\\n                find1(it,value-s.count({node,it})+s.count({it,node}),total,node);\\n            }\\n        }\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& g, int K) \\n    {\\n        k=K;\\n        for(auto it:g)\\n        {\\n            s.insert({it[0],it[1]});\\n        }\\n        for(auto it:edges)\\n        {\\n            dp[it[0]].push_back(it[1]);\\n            dp[it[1]].push_back(it[0]);\\n        }\\n        int total=0;\\n        int value=find(0);\\n        find1(0,value,total);\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dp[100005];\\n    set<pair<int,int>>s;\\n    int k;\\n    int  find(int node,int p=-1)\\n    {\\n        int count=0;\\n        for(auto it:dp[node])\\n        {\\n            if(it!=p)\\n            {\\n                count+=s.count({node,it})+find(it,node);\\n            }\\n        }\\n        return count;\\n    }\\n    void find1(int node,int value,int &total,int p=-1)\\n    {\\n        if(value>=k)\\n        {\\n            total++;\\n        }\\n        for(auto it:dp[node])\\n        {\\n            if(it!=p)\\n            {\\n                find1(it,value-s.count({node,it})+s.count({it,node}),total,node);\\n            }\\n        }\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& g, int K) \\n    {\\n        k=K;\\n        for(auto it:g)\\n        {\\n            s.insert({it[0],it[1]});\\n        }\\n        for(auto it:edges)\\n        {\\n            dp[it[0]].push_back(it[1]);\\n            dp[it[1]].push_back(it[0]);\\n        }\\n        int total=0;\\n        int value=find(0);\\n        find1(0,value,total);\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256575,
                "title": "greedy-solution-no-dp-hashing-dfs-bfs-string-concatenation",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA simple observation : like if I have ith node as a parent and jth node is its immediate chlid then all the relationships for jth node is exactly same as ith except iparentOfj and jparentOfi\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution{\\n    HashSet<String> ans=new HashSet<>();\\n\\n    public  void DFS(ArrayList<Integer>[]arr,HashSet<String> h)\\n    {\\n        boolean []bool=new boolean[arr.length+1];\\n\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            if(bool[i])\\n                continue;\\n            {\\n                // dfs.add(i);\\n\\n                DFS(arr,bool,i,h);\\n            }\\n\\n\\n        }\\n\\n    }\\n    public  void DFS(ArrayList<Integer> []arr,boolean []vst,int i,HashSet<String> h) {\\n        if (vst[i]) {\\n\\n            return;\\n        }\\n        vst[i] = true;\\n        // cc++;;\\n        ArrayList<Integer> anss = arr[i];\\n        if (anss != null) {\\n            for (Integer an : anss) {\\n                {\\n                    if (vst[an]) {\\n\\n                        continue;\\n                    }\\n                    // dfs.add(an);\\n                    String s = \"\";\\n                    s += i + \"#\" + an;\\n\\n                    if (h.contains(s))\\n                        ans.add(s);\\n                    DFS(arr, vst, an, h);\\n                }\\n            }\\n        }\\n    }\\n\\n\\n\\n\\n    public int rootCount(int[][] edges, int[][] gs, int k) {\\n        if(k==0)\\n        {\\n            return edges.length+1;\\n        }\\n        int m=edges.length;\\n        int n=m+1;\\n        int [][]gp=new int[m][2];\\n        ans=new HashSet<>();\\n//        for(int i=0;i<=n;i++)ans[i]=new HashSet<>();\\n\\n        ArrayList<Integer>[]arr=new ArrayList[n+1];\\n        for(int i=0;i<m;i++)\\n        {\\n            gp[i][0]= edges[i][0]+1;\\n            gp[i][1]= edges[i][1]+1;\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n\\n            ArrayList<Integer> ans=new ArrayList<>();\\n            if(arr[gp[i][0]]!=null)\\n            {\\n                ans=arr[gp[i][0]];\\n\\n            }\\n            ans.add(gp[i][1]);\\n            arr[gp[i][0]]=ans;\\n            ArrayList<Integer> bns=new ArrayList<>();\\n            if(arr[gp[i][1]]!=null)\\n            {\\n                bns=arr[gp[i][1]];\\n\\n            }\\n            bns.add(gp[i][0]);\\n            arr[gp[i][1]]=bns;\\n\\n\\n        }\\n        HashSet<String> h=new HashSet<>();\\n        for (int[] g : gs) {\\n            String a = \"\" + (g[0] + 1) + \"#\" + (g[1] + 1);\\n            h.add(a);\\n\\n        }\\n        // System.out.println(h+\"----\");\\n\\n        DFS(arr,h);\\n        return BFS(arr,h,k,n);\\n        // for(int i=1;i<ans.length;i++)\\n        //             System.out.println(ans[i]);\\n\\n\\n\\n\\n    }\\n\\n\\n\\n\\n    public  int  BFS(ArrayList<Integer>[]arr,HashSet<String> h,int k,int n)\\n    {\\n        Queue<Integer> q=new LinkedList<>();\\n\\n        boolean []vst=new boolean[arr.length];\\n        int sizer[]=new int[arr.length];\\n        sizer[1]=ans.size();\\n\\n        q.offer(1);\\n\\n        while(!q.isEmpty())\\n        {\\n            int x=q.poll();\\n            if(!vst[x]) {\\n                // bfs.add(x);\\n                vst[x]=true;\\n                ArrayList<Integer> anss=arr[x];\\n\\n                for (Integer an : anss) {\\n                    if(!vst[an])\\n                    {\\n//                        ans[an]=new HashSet<>(ans[x]);\\n                        sizer[an]=sizer[x];\\n                        String torem=\"\",toadd=\"\";\\n                        torem+=x+\"#\"+an;\\n\\n\\n                        if(h.contains(torem))\\n                            sizer[an]--;\\n                        toadd+=an+\"#\"+x;\\n\\n                        if(h.contains(toadd))\\n                            sizer[an]++;\\n                        // System.out.println(torem+\"---\"+toadd);\\n\\n                        q.offer(an);\\n                    }\\n                }\\n            }\\n\\n\\n\\n        }\\n        int ak=0;\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            if(sizer[i]>=k)\\n                ak++;\\n        }\\n        return ak;\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution{\\n    HashSet<String> ans=new HashSet<>();\\n\\n    public  void DFS(ArrayList<Integer>[]arr,HashSet<String> h)\\n    {\\n        boolean []bool=new boolean[arr.length+1];\\n\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            if(bool[i])\\n                continue;\\n            {\\n                // dfs.add(i);\\n\\n                DFS(arr,bool,i,h);\\n            }\\n\\n\\n        }\\n\\n    }\\n    public  void DFS(ArrayList<Integer> []arr,boolean []vst,int i,HashSet<String> h) {\\n        if (vst[i]) {\\n\\n            return;\\n        }\\n        vst[i] = true;\\n        // cc++;;\\n        ArrayList<Integer> anss = arr[i];\\n        if (anss != null) {\\n            for (Integer an : anss) {\\n                {\\n                    if (vst[an]) {\\n\\n                        continue;\\n                    }\\n                    // dfs.add(an);\\n                    String s = \"\";\\n                    s += i + \"#\" + an;\\n\\n                    if (h.contains(s))\\n                        ans.add(s);\\n                    DFS(arr, vst, an, h);\\n                }\\n            }\\n        }\\n    }\\n\\n\\n\\n\\n    public int rootCount(int[][] edges, int[][] gs, int k) {\\n        if(k==0)\\n        {\\n            return edges.length+1;\\n        }\\n        int m=edges.length;\\n        int n=m+1;\\n        int [][]gp=new int[m][2];\\n        ans=new HashSet<>();\\n//        for(int i=0;i<=n;i++)ans[i]=new HashSet<>();\\n\\n        ArrayList<Integer>[]arr=new ArrayList[n+1];\\n        for(int i=0;i<m;i++)\\n        {\\n            gp[i][0]= edges[i][0]+1;\\n            gp[i][1]= edges[i][1]+1;\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n\\n            ArrayList<Integer> ans=new ArrayList<>();\\n            if(arr[gp[i][0]]!=null)\\n            {\\n                ans=arr[gp[i][0]];\\n\\n            }\\n            ans.add(gp[i][1]);\\n            arr[gp[i][0]]=ans;\\n            ArrayList<Integer> bns=new ArrayList<>();\\n            if(arr[gp[i][1]]!=null)\\n            {\\n                bns=arr[gp[i][1]];\\n\\n            }\\n            bns.add(gp[i][0]);\\n            arr[gp[i][1]]=bns;\\n\\n\\n        }\\n        HashSet<String> h=new HashSet<>();\\n        for (int[] g : gs) {\\n            String a = \"\" + (g[0] + 1) + \"#\" + (g[1] + 1);\\n            h.add(a);\\n\\n        }\\n        // System.out.println(h+\"----\");\\n\\n        DFS(arr,h);\\n        return BFS(arr,h,k,n);\\n        // for(int i=1;i<ans.length;i++)\\n        //             System.out.println(ans[i]);\\n\\n\\n\\n\\n    }\\n\\n\\n\\n\\n    public  int  BFS(ArrayList<Integer>[]arr,HashSet<String> h,int k,int n)\\n    {\\n        Queue<Integer> q=new LinkedList<>();\\n\\n        boolean []vst=new boolean[arr.length];\\n        int sizer[]=new int[arr.length];\\n        sizer[1]=ans.size();\\n\\n        q.offer(1);\\n\\n        while(!q.isEmpty())\\n        {\\n            int x=q.poll();\\n            if(!vst[x]) {\\n                // bfs.add(x);\\n                vst[x]=true;\\n                ArrayList<Integer> anss=arr[x];\\n\\n                for (Integer an : anss) {\\n                    if(!vst[an])\\n                    {\\n//                        ans[an]=new HashSet<>(ans[x]);\\n                        sizer[an]=sizer[x];\\n                        String torem=\"\",toadd=\"\";\\n                        torem+=x+\"#\"+an;\\n\\n\\n                        if(h.contains(torem))\\n                            sizer[an]--;\\n                        toadd+=an+\"#\"+x;\\n\\n                        if(h.contains(toadd))\\n                            sizer[an]++;\\n                        // System.out.println(torem+\"---\"+toadd);\\n\\n                        q.offer(an);\\n                    }\\n                }\\n            }\\n\\n\\n\\n        }\\n        int ak=0;\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            if(sizer[i]>=k)\\n                ak++;\\n        }\\n        return ak;\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256327,
                "title": "python-simple-dfs-with-cache-5-steps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n## - Step 1 build the Graph\\nDICT of Node to List of Nodes\\nSET of Nodes\\n\\n## - Step 2 build a set of Guesses for fast access\\nSET of Tuple Edges\\n\\n## - Step 3 DFS \\n\\ninput: Node and Previous node\\noutput: The number of right guesses\\n\\ncache all the results in order to avoid computing again\\n\\n## - Step 4 Try all the roots \\nTry all the roots and if the returned number of guesses is greater than k. Add 1 to the total.\\n\\n## - Step 5 Return the Result\\nReturn the total\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N + E) where N is the number of nodes, E is the number of edges\\n\\nWe only visit each node and edge a constant number of times\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n\\n        \\n        \\n\\n        # Step 1 build the graph\\n\\n        #contains all the edges\\n        # 0 -> 1,2,3 Node to list of Nodes\\n        GRAPH = defaultdict(list)\\n\\n        #contains all the nodes\\n        NODES = set()\\n\\n        for e in edges:\\n\\n            NODES.add(e[0])\\n            NODES.add(e[1])\\n\\n            GRAPH[e[0]].append(e[1])\\n            GRAPH[e[1]].append(e[0])\\n\\n        ## Step 2 build a set of Guesses for fast access\\n\\n        #contains all the guesses\\n        GUESSES = set()\\n\\n        #contains all the edges of the nodes\\n        for e in guesses:\\n            GUESSES.add((e[0],e[1]))\\n\\n\\n        #visited set\\n        visited = set()\\n\\n        # Step 3 DFS\\n        #cache the result with the node and previous\\n        @cache\\n        def dfs(node:int, previous:int) -> int:\\n\\n            # count the number of right guesses\\n            guess_count = 0\\n\\n            if (previous,node) in GUESSES:\\n                guess_count+=1\\n\\n            # add node to visited set\\n            visited.add(node)\\n\\n            for next_node in GRAPH[node]:\\n\\n                if next_node not in visited:\\n                    guess_count += dfs(next_node,node)\\n\\n            return guess_count\\n        \\n        # Step 4 Try all  the  roots\\n\\n        result = 0\\n\\n        for node in NODES:\\n            #if the root has k guesses, add 1 to the result\\n            if dfs(node,-1) >= k:\\n                result+=1\\n            visited = set()\\n\\n        # Step 5 Return the result\\n        return result\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n\\n        \\n        \\n\\n        # Step 1 build the graph\\n\\n        #contains all the edges\\n        # 0 -> 1,2,3 Node to list of Nodes\\n        GRAPH = defaultdict(list)\\n\\n        #contains all the nodes\\n        NODES = set()\\n\\n        for e in edges:\\n\\n            NODES.add(e[0])\\n            NODES.add(e[1])\\n\\n            GRAPH[e[0]].append(e[1])\\n            GRAPH[e[1]].append(e[0])\\n\\n        ## Step 2 build a set of Guesses for fast access\\n\\n        #contains all the guesses\\n        GUESSES = set()\\n\\n        #contains all the edges of the nodes\\n        for e in guesses:\\n            GUESSES.add((e[0],e[1]))\\n\\n\\n        #visited set\\n        visited = set()\\n\\n        # Step 3 DFS\\n        #cache the result with the node and previous\\n        @cache\\n        def dfs(node:int, previous:int) -> int:\\n\\n            # count the number of right guesses\\n            guess_count = 0\\n\\n            if (previous,node) in GUESSES:\\n                guess_count+=1\\n\\n            # add node to visited set\\n            visited.add(node)\\n\\n            for next_node in GRAPH[node]:\\n\\n                if next_node not in visited:\\n                    guess_count += dfs(next_node,node)\\n\\n            return guess_count\\n        \\n        # Step 4 Try all  the  roots\\n\\n        result = 0\\n\\n        for node in NODES:\\n            #if the root has k guesses, add 1 to the result\\n            if dfs(node,-1) >= k:\\n                result+=1\\n            visited = set()\\n\\n        # Step 5 Return the result\\n        return result\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256791,
                "title": "bfs-o-nlogn-complexity-detailed-explanation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thought for this question is the naive approach where we check each node as the root and for each node we check the number of guesses to be true. This will be a solution of O(N*N). This is not feasible.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo to minimise this, we can approach it as:\\n1. Firstly calculate the number of correct guesses assuming any one of the nodes to be the root.\\n2. Now, the thing to observe is that when you traverse to the next node at max 2 guesses can be reversed ,i.e, [parent,child] and [child,parent].\\n3. Based on this the count value of the parent can be used for the \\nchild.\\n\\nNow the use of the data structures used:\\n1. Graph - creating the tree\\n2. Vis - keeping check which node has been visited before\\n3. parent - this array is used to check the number of guesses to be true for the first root node.\\n4. mp_check - maintains which guess is correct and which guess is incorrect\\n5. guess - this set is created to check whether a particular guess exists in the given guesses\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n = edges.size();\\n        int m = guesses.size();\\n        vector <int> graph[n+1];\\n        for(int i = 0; i  <n; i ++)\\n        {\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        ++n;        \\n        int parent[n];\\n        parent[0]=-1;\\n        \\n        int vis[n];\\n        for(int i = 0; i < n; i ++)\\n            vis[i]=0;\\n        vis[0]=1;\\n        /* This block of code is to find the parent of each node \\n            with 0 as the root of the tree */\\n        queue <int> q;\\n        q.push(0);\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            for(auto it : graph[node])   \\n            {\\n                if(!vis[it])\\n                {\\n                    vis[it]=1;\\n                    q.push(it);\\n                    parent[it]=node;\\n                }\\n            }\\n        }\\n        \\n        /*Here we insert all the guesses into a set to find \\n            a particular guess in log(N) complexity*/\\n        map <pair<int,int>,int> mp_check;\\n        set <pair<int,int>> guess;\\n        for(auto it : guesses)\\n            guess.insert({it[0],it[1]});\\n        \\n        /*Here we assign each guess to be true or false for\\n             root node as 0*/\\n        int correct = 0;\\n        int ans = 0;\\n        for(int i = 0; i < m; i++)\\n        {\\n            if(parent[guesses[i][1]]==guesses[i][0])\\n            {\\n                mp_check[{guesses[i][0],guesses[i][1]}]=1;\\n                ++correct;\\n            }\\n            else\\n                mp_check[{guesses[i][0],guesses[i][1]}]=0;\\n        }\\n        // reassigning the visited array\\n        for(int i = 0; i < n; i ++)\\n            vis[i]=0;\\n        vis[0]=1;\\n        \\n        queue <pair<int,int>> qu;\\n        qu.push({0,correct});\\n        while(!qu.empty())\\n        {\\n            int node = qu.front().first;\\n            int number_of_correct = qu.front().second;\\n            if(number_of_correct>=k)\\n                ans++;\\n            qu.pop();\\n            for(auto child : graph[node])   \\n            {\\n                int current_correct = number_of_correct;\\n                if(!vis[child])\\n                {\\n                    vis[child]=1;\\n/*Checking if the guess({child,node}) exists, if it does then */\\n/*finding whether the guess was false for the parent, if it is false\\nthen incrementing the current number of correct guesses for the child*/\\n                    auto iter = guess.find({child,node});\\n                    if(iter!=guess.end())\\n                    {\\n                        if(mp_check[{child,node}]==0)\\n                        {\\n                            mp_check[{child,node}]=1;\\n                            ++current_correct;\\n                        }\\n                    }\\n/*Checking if the guess({node,child}) exists, if it does then */\\n/*finding whether the guess was true for the parent, if it is true\\nthen decrementing the current number of correct guesses for the child*/\\n                    iter = guess.find({node,child});\\n                    if(iter!=guess.end())\\n                    {\\n                        if(mp_check[{node,child}]==1)\\n                        {\\n                            mp_check[{node,child}]=0;\\n                            --current_correct;\\n                        }\\n                    }\\n                    qu.push({child,current_correct});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n = edges.size();\\n        int m = guesses.size();\\n        vector <int> graph[n+1];\\n        for(int i = 0; i  <n; i ++)\\n        {\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        ++n;        \\n        int parent[n];\\n        parent[0]=-1;\\n        \\n        int vis[n];\\n        for(int i = 0; i < n; i ++)\\n            vis[i]=0;\\n        vis[0]=1;\\n        /* This block of code is to find the parent of each node \\n            with 0 as the root of the tree */\\n        queue <int> q;\\n        q.push(0);\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            for(auto it : graph[node])   \\n            {\\n                if(!vis[it])\\n                {\\n                    vis[it]=1;\\n                    q.push(it);\\n                    parent[it]=node;\\n                }\\n            }\\n        }\\n        \\n        /*Here we insert all the guesses into a set to find \\n            a particular guess in log(N) complexity*/\\n        map <pair<int,int>,int> mp_check;\\n        set <pair<int,int>> guess;\\n        for(auto it : guesses)\\n            guess.insert({it[0],it[1]});\\n        \\n        /*Here we assign each guess to be true or false for\\n             root node as 0*/\\n        int correct = 0;\\n        int ans = 0;\\n        for(int i = 0; i < m; i++)\\n        {\\n            if(parent[guesses[i][1]]==guesses[i][0])\\n            {\\n                mp_check[{guesses[i][0],guesses[i][1]}]=1;\\n                ++correct;\\n            }\\n            else\\n                mp_check[{guesses[i][0],guesses[i][1]}]=0;\\n        }\\n        // reassigning the visited array\\n        for(int i = 0; i < n; i ++)\\n            vis[i]=0;\\n        vis[0]=1;\\n        \\n        queue <pair<int,int>> qu;\\n        qu.push({0,correct});\\n        while(!qu.empty())\\n        {\\n            int node = qu.front().first;\\n            int number_of_correct = qu.front().second;\\n            if(number_of_correct>=k)\\n                ans++;\\n            qu.pop();\\n            for(auto child : graph[node])   \\n            {\\n                int current_correct = number_of_correct;\\n                if(!vis[child])\\n                {\\n                    vis[child]=1;\\n/*Checking if the guess({child,node}) exists, if it does then */\\n/*finding whether the guess was false for the parent, if it is false\\nthen incrementing the current number of correct guesses for the child*/\\n                    auto iter = guess.find({child,node});\\n                    if(iter!=guess.end())\\n                    {\\n                        if(mp_check[{child,node}]==0)\\n                        {\\n                            mp_check[{child,node}]=1;\\n                            ++current_correct;\\n                        }\\n                    }\\n/*Checking if the guess({node,child}) exists, if it does then */\\n/*finding whether the guess was true for the parent, if it is true\\nthen decrementing the current number of correct guesses for the child*/\\n                    iter = guess.find({node,child});\\n                    if(iter!=guess.end())\\n                    {\\n                        if(mp_check[{node,child}]==1)\\n                        {\\n                            mp_check[{node,child}]=0;\\n                            --current_correct;\\n                        }\\n                    }\\n                    qu.push({child,current_correct});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260028,
                "title": "c-dfs-solution-with-explantion",
                "content": "Initially assume the tree to be rooted at some arbitrary node, say **0**. Let `total` be the count of all the edges which are present in the guesses for this initial tree rooted at 0. Whenever the root of the tree is changed we can see that all of the edges in the initial tree remains same, except the ancestors of the new root. So we can maintain 2 count arrays `cnt1` and `cnt2` which store the number of guesses and number of guesses after reversing the edges upto the current node. \\n\\nThis can be clearly seen from the images in the sample. When the root is changed to 3, the direction of all the edges above it changes it, but it remains same for 4, which is below it. \\n\\nAfter finding the cnt1 and cnt2 for each node we can check the new total in the following way: \\n`newtotal = total - cnt1[i] + cnt2[i]`\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/91d99644-acf1-4f17-bf19-4899fab6f189_1678015764.1255121.png)\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj; \\n    vector<int> cnt1, cnt2; \\n    int total;\\n    map<pair<int, int>, bool> isGuess; \\n\\n    void dfs(int node, int par) {\\n        if(isGuess[{par, node}]) {\\n            total++;\\n            cnt1[node]++;\\n        }\\n        if(isGuess[{node, par}]) {\\n            cnt2[node]++;\\n        }\\n        \\n        for(auto nbr: adj[node]) {\\n            if(nbr==par) continue;\\n            cnt1[nbr] += cnt1[node];\\n            cnt2[nbr] += cnt2[node];\\n            dfs(nbr, node); \\n        }\\n    }\\n    \\n    \\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        isGuess.clear();\\n        for(auto e: guesses) {\\n            isGuess[{e[0], e[1]}] = 1;    \\n        }\\n        \\n        int n = edges.size(); \\n        adj.assign(n+1, {});\\n        cnt1.assign(n+1, 0);\\n        cnt2.assign(n+1, 0);\\n        \\n        total = 0;\\n        for(int i=0; i<n; i++) {\\n            int u = edges[i][0], v = edges[i][1];\\n            adj[u].push_back(v); \\n            adj[v].push_back(u);\\n        }\\n        \\n        dfs(0, -1); \\n        \\n        int res = 0; \\n        for(int i=0; i<=n; i++) {\\n            int count = total - cnt1[i] + cnt2[i];\\n            if(count>=k) {\\n                res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj; \\n    vector<int> cnt1, cnt2; \\n    int total;\\n    map<pair<int, int>, bool> isGuess; \\n\\n    void dfs(int node, int par) {\\n        if(isGuess[{par, node}]) {\\n            total++;\\n            cnt1[node]++;\\n        }\\n        if(isGuess[{node, par}]) {\\n            cnt2[node]++;\\n        }\\n        \\n        for(auto nbr: adj[node]) {\\n            if(nbr==par) continue;\\n            cnt1[nbr] += cnt1[node];\\n            cnt2[nbr] += cnt2[node];\\n            dfs(nbr, node); \\n        }\\n    }\\n    \\n    \\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        isGuess.clear();\\n        for(auto e: guesses) {\\n            isGuess[{e[0], e[1]}] = 1;    \\n        }\\n        \\n        int n = edges.size(); \\n        adj.assign(n+1, {});\\n        cnt1.assign(n+1, 0);\\n        cnt2.assign(n+1, 0);\\n        \\n        total = 0;\\n        for(int i=0; i<n; i++) {\\n            int u = edges[i][0], v = edges[i][1];\\n            adj[u].push_back(v); \\n            adj[v].push_back(u);\\n        }\\n        \\n        dfs(0, -1); \\n        \\n        int res = 0; \\n        for(int i=0; i<=n; i++) {\\n            int count = total - cnt1[i] + cnt2[i];\\n            if(count>=k) {\\n                res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309465,
                "title": "python3-solution-dfs-clean-concise",
                "content": "# Approach\\nLet assume an arrow which is from child to parent (v -> u), now if you traverse from a node (let say root) to every node and encounter k incoming arrows (->) then the root is possible else not.\\nFor optimizing, we count the incoming arrows for 0 (call it value), and then apply dfs, if encounter incoming arrows (which now will be out going) subtract 1 and similarly for outgoing arrows(which now will be ingoing) add 1, if the value >= k, then the current node can be root else not.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def rootCount(self, E, G, k):\\n        n = len(E)\\n        G = set(map(tuple, G))\\n        graph = [[] for _ in range(n + 1)]\\n        for a, b  in E:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        def count(node, parent):\\n            val = 0\\n            for i in graph[node]:\\n                if i == parent: continue\\n                if (node, i) in G: val += 1\\n                val += count(i, node)\\n            return val\\n        def dfs(node, parent, val):\\n            ans = 0\\n            if val >= k: ans += 1\\n            for i in graph[node]:\\n                if i == parent: continue\\n                cur = val - (1 if (node, i) in G else 0) + (1 if (i, node) in G else 0)\\n                ans += dfs(i, node, cur)\\n            return ans\\n        return dfs(0, -1, count(0, -1))\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def rootCount(self, E, G, k):\\n        n = len(E)\\n        G = set(map(tuple, G))\\n        graph = [[] for _ in range(n + 1)]\\n        for a, b  in E:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        def count(node, parent):\\n            val = 0\\n            for i in graph[node]:\\n                if i == parent: continue\\n                if (node, i) in G: val += 1\\n                val += count(i, node)\\n            return val\\n        def dfs(node, parent, val):\\n            ans = 0\\n            if val >= k: ans += 1\\n            for i in graph[node]:\\n                if i == parent: continue\\n                cur = val - (1 if (node, i) in G else 0) + (1 if (i, node) in G else 0)\\n                ans += dfs(i, node, cur)\\n            return ans\\n        return dfs(0, -1, count(0, -1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256210,
                "title": "c-dfs-dp-memoization-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a graph problem, we can try using every node as root , then traverse it , find how many correct guess , if >=k, this is a valid node.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- using edges to build an undirected graph\\n- using guesses to build a directed graph\\n- For each node i, using it as root, then traverse the graph to find all correct guesses, if >=k, then i is a possible one\\n- Must avoid duplicate traversal, we using memo to cache the result of [parent-node, child-node] , so we only need to traverse the whole graph(all edges) twice.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n         public int RootCount(int[][] edges, int[][] guesses, int k)\\n        {\\n            int res = 0;\\n            int n = edges.Length+1;\\n            //build undirect graph by edges\\n            List<int>[] graph = new List<int>[n];\\n            for (int i = 0; i<n; i++)\\n                graph[i]=new List<int>();\\n\\n            foreach(var e in edges)\\n            {\\n                graph[e[0]].Add(e[1]);\\n                graph[e[1]].Add(e[0]);\\n            }\\n\\n            //build direct graph by guesses\\n            HashSet<int>[] directGraph = new HashSet<int>[n];\\n            for (int i = 0; i<n; i++)\\n                directGraph[i]=new HashSet<int>();\\n\\n            foreach (var e in guesses)\\n            {\\n                directGraph[e[0]].Add(e[1]);\\n            }\\n\\n            //memo is {parent, {child, count}}, count is all valid guesses traverse from parent to all childs\\n            var memo =new Dictionary<int, Dictionary<int,int>>();\\n            for(int i = 0; i<n; i++)\\n            {\\n                int count = RootCount(i, -1, graph, directGraph, memo);\\n                if (count>=k)\\n                    res++;\\n            }\\n            return res;\\n        }\\n\\n        private int RootCount(int curr, int parent, List<int>[] graph, HashSet<int>[] set, Dictionary<int, Dictionary<int, int>> memo)\\n        {\\n            if (!memo.ContainsKey(parent))\\n                memo.Add(parent, new Dictionary<int, int>());\\n            //already traversed from\\n            if (memo[parent].ContainsKey(curr))\\n                return memo[parent][curr];\\n            else\\n            {\\n                int res = 0;\\n                foreach (var next in graph[curr])\\n                {\\n                    if (next == parent) continue;\\n                    if (set[curr].Contains(next)) res++;//{curr,next} is existed in guesses\\n                    res+=RootCount(next, curr, graph, set, memo);//DFS\\n                }\\n                memo[parent].Add(curr, res);\\n                return memo[parent][curr];\\n            }\\n        }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n         public int RootCount(int[][] edges, int[][] guesses, int k)\\n        {\\n            int res = 0;\\n            int n = edges.Length+1;\\n            //build undirect graph by edges\\n            List<int>[] graph = new List<int>[n];\\n            for (int i = 0; i<n; i++)\\n                graph[i]=new List<int>();\\n\\n            foreach(var e in edges)\\n            {\\n                graph[e[0]].Add(e[1]);\\n                graph[e[1]].Add(e[0]);\\n            }\\n\\n            //build direct graph by guesses\\n            HashSet<int>[] directGraph = new HashSet<int>[n];\\n            for (int i = 0; i<n; i++)\\n                directGraph[i]=new HashSet<int>();\\n\\n            foreach (var e in guesses)\\n            {\\n                directGraph[e[0]].Add(e[1]);\\n            }\\n\\n            //memo is {parent, {child, count}}, count is all valid guesses traverse from parent to all childs\\n            var memo =new Dictionary<int, Dictionary<int,int>>();\\n            for(int i = 0; i<n; i++)\\n            {\\n                int count = RootCount(i, -1, graph, directGraph, memo);\\n                if (count>=k)\\n                    res++;\\n            }\\n            return res;\\n        }\\n\\n        private int RootCount(int curr, int parent, List<int>[] graph, HashSet<int>[] set, Dictionary<int, Dictionary<int, int>> memo)\\n        {\\n            if (!memo.ContainsKey(parent))\\n                memo.Add(parent, new Dictionary<int, int>());\\n            //already traversed from\\n            if (memo[parent].ContainsKey(curr))\\n                return memo[parent][curr];\\n            else\\n            {\\n                int res = 0;\\n                foreach (var next in graph[curr])\\n                {\\n                    if (next == parent) continue;\\n                    if (set[curr].Contains(next)) res++;//{curr,next} is existed in guesses\\n                    res+=RootCount(next, curr, graph, set, memo);//DFS\\n                }\\n                memo[parent].Add(curr, res);\\n                return memo[parent][curr];\\n            }\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486266,
                "title": "count-number-of-possible-root-nodes",
                "content": "Since we don\\'t have tuples in JS, we just gotta figure out how to identify matching edges as we traverse over them. The constraints are small enough that we can encode an edge in a number - given ```\\nnodeA and nodeB\\n```, `nodeA` -> `nodeB = nodeA * 1_000_000 + nodeB.`\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} edges\\n * @param {number[][]} guesses\\n * @param {number} k\\n * @return {number}\\n */\\nvar rootCount = function (edges, guesses, k) {\\n  const lookup = new Set(guesses.map(([a, b]) => a * 1_000_000 + b));\\n  const adjList = edges.reduce((adjList, [a, b]) => {\\n    adjList[a].push(b);\\n    adjList[b].push(a);\\n    return adjList;\\n  }, new Array(edges.length + 1).fill(0).map(() => []));\\n\\n  const guessed = (a, b) => lookup.has(a * 1_000_000 + b) ? 1 : 0;\\n\\n  const getCorrect = (node, parent) =>\\n    adjList[node].reduce((total, child) =>\\n      child === parent\\n        ? total\\n        : total + guessed(node, child) + getCorrect(child, node),\\n      0);\\n\\n  const getTotal = (node, parent, correct) => (\\n    (correct >= k ? 1 : 0) +\\n    adjList[node].reduce((total, child) =>\\n      child === parent\\n        ? total\\n        : total + getTotal(child, node, correct - guessed(node, child) + guessed(child, node)),\\n      0)\\n  );\\n\\n  return getTotal(0, -1, getCorrect(0, -1));\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nnodeA and nodeB\\n```\n```\\n/**\\n * @param {number[][]} edges\\n * @param {number[][]} guesses\\n * @param {number} k\\n * @return {number}\\n */\\nvar rootCount = function (edges, guesses, k) {\\n  const lookup = new Set(guesses.map(([a, b]) => a * 1_000_000 + b));\\n  const adjList = edges.reduce((adjList, [a, b]) => {\\n    adjList[a].push(b);\\n    adjList[b].push(a);\\n    return adjList;\\n  }, new Array(edges.length + 1).fill(0).map(() => []));\\n\\n  const guessed = (a, b) => lookup.has(a * 1_000_000 + b) ? 1 : 0;\\n\\n  const getCorrect = (node, parent) =>\\n    adjList[node].reduce((total, child) =>\\n      child === parent\\n        ? total\\n        : total + guessed(node, child) + getCorrect(child, node),\\n      0);\\n\\n  const getTotal = (node, parent, correct) => (\\n    (correct >= k ? 1 : 0) +\\n    adjList[node].reduce((total, child) =>\\n      child === parent\\n        ? total\\n        : total + getTotal(child, node, correct - guessed(node, child) + guessed(child, node)),\\n      0)\\n  );\\n\\n  return getTotal(0, -1, getCorrect(0, -1));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3261219,
                "title": "c-solution-based-on-re-rooting-using-parent-node",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nInitialize val to store the count of possible roots of the Tree after re-rooting.\\n\\n- Firstly run a DFS to find the count of correct guesses in the subtree of each node x with parent p (while running dfs) and store the count in **sub[x]**.\\n- Run a Dfs to Re-root the tree for every node **x** using the solution of re-rooting obtained for parent **p** node using the relation:\\n    - guesses correct for tree rooted at x = sub[p] -1(if **p is parent of x** is one of the provided guess) +1(if **x is parent of p** is one of the provided guess).\\n    - If the calculated value for x is greater than or equal to k then increment the val by one.\\n\\n**Val** gives the the count of possible roots.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Sincere Request\\n- Please **upvote** this solution post\\n\\n# Code\\n```\\nclass Solution {\\n    int g;\\npublic:\\n    void dfs(int root,int par, unordered_map<string,bool>& mp, vector<int>& sub, vector<vector<int>>&adj){\\n        for(int i:adj[root]){\\n            if(i==par)continue;\\n            if(mp[to_string(root)+\\'-\\'+to_string(i)])sub[root]++;\\n            dfs(i,root,mp,sub,adj);\\n            sub[root]+=sub[i];\\n        }\\n    }\\n\\n    void sfd(int r,int p, vector<int>&sub, unordered_map<string,bool>& mp, vector<vector<int>>&adj, int& k, int& val ){\\n        int num=p==-1?sub[r]:sub[p];\\n        if(mp[to_string(p)+\\'-\\'+to_string(r)])num--;\\n        if(mp[to_string(r)+\\'-\\'+to_string(p)])num++;\\n        if(num>=k)val++;\\n        sub[r]=num;\\n        for(auto i:adj[r]){\\n            if(i==p)continue;\\n            sfd(i,r,sub,mp,adj,k,val);\\n        }\\n    }\\n\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        g=guesses.size();\\n        int n=edges.size(),m=guesses.size();\\n        n++;\\n        vector<vector<int>>adj(n);\\n        vector<int>sub(n);\\n        for(auto i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        unordered_map<string,bool>mp;\\n        for(auto i:guesses){\\n            mp[to_string(i[0])+\\'-\\'+to_string(i[1])]=1;\\n        }\\n        dfs(0,-1,mp,sub,adj);\\n        int val=0;\";\\n        sfd(0,-1,sub,mp,adj,k,val);\\n        return val;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int g;\\npublic:\\n    void dfs(int root,int par, unordered_map<string,bool>& mp, vector<int>& sub, vector<vector<int>>&adj){\\n        for(int i:adj[root]){\\n            if(i==par)continue;\\n            if(mp[to_string(root)+\\'-\\'+to_string(i)])sub[root]++;\\n            dfs(i,root,mp,sub,adj);\\n            sub[root]+=sub[i];\\n        }\\n    }\\n\\n    void sfd(int r,int p, vector<int>&sub, unordered_map<string,bool>& mp, vector<vector<int>>&adj, int& k, int& val ){\\n        int num=p==-1?sub[r]:sub[p];\\n        if(mp[to_string(p)+\\'-\\'+to_string(r)])num--;\\n        if(mp[to_string(r)+\\'-\\'+to_string(p)])num++;\\n        if(num>=k)val++;\\n        sub[r]=num;\\n        for(auto i:adj[r]){\\n            if(i==p)continue;\\n            sfd(i,r,sub,mp,adj,k,val);\\n        }\\n    }\\n\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        g=guesses.size();\\n        int n=edges.size(),m=guesses.size();\\n        n++;\\n        vector<vector<int>>adj(n);\\n        vector<int>sub(n);\\n        for(auto i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        unordered_map<string,bool>mp;\\n        for(auto i:guesses){\\n            mp[to_string(i[0])+\\'-\\'+to_string(i[1])]=1;\\n        }\\n        dfs(0,-1,mp,sub,adj);\\n        int val=0;\";\\n        sfd(0,-1,sub,mp,adj,k,val);\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257653,
                "title": "intuitive-dfs-o-n-space-and-time-beats-100-time-and-100-memory",
                "content": "# Intuition\\nFor each guess u and v, all nodes x that would work if rooted at x would work if and only if the path from x to u does not contain v. This means if we remove the edge from u to v, it would only work for every node that is on the u side of the tree, not the v side.\\n\\n# Approach\\nThis means that we can add 1 to every node that is on the u side of the graph, and to check if a certain node works, we can just check if the counter for that node is >= k. We can add one to every node in a subtree by adding one to the root of the subtree, and using dfs to add each parents node to its children. To add one to everything outside a subtree, we can subtract 1 from the subtree and add 1 to an outside counter that we can add to every node at the end. We use another dfs to check weather each node is lower or higher than another node, by calculating the parent node.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int rootCount(int[][] eg, int[][] gu, int k) {\\n        // number of nodes\\n        int n = eg.length+1;\\n        // graph\\n        List<Integer>[] g = new List[n];\\n        for(int i = 0; i<n; i++) g[i] = new LinkedList<>();\\n        for(int[] a: eg){\\n            g[a[0]].add(a[1]);\\n            g[a[1]].add(a[0]);\\n        }\\n        // counter for outside the subtree\\n        int all = 0;\\n        // counter for inside the subtree and parent list\\n        int[] add = new int[n], par = new int[n];\\n        // calculate parents\\n        dfs1(g, 0, -1, par);\\n        for(int[] a: gu) if(par[a[1]] == a[0]){\\n            // add one to outside the subtree\\n            all++;\\n            add[a[1]]--;\\n        }else // add one to inside the subtree\\n        add[a[0]]++;\\n        // calculate total sums\\n        dfs2(g, 0, -1, add);\\n        int ans = 0;\\n        for(int i: add) if(i+all >= k) ans++;\\n        return ans;\\n    }\\n    private void dfs1(List<Integer>[] g, int s, int p, int[] par){\\n        par[s] = p;\\n        for(int i: g[s]) if(i != p) dfs1(g, i, s, par);\\n    }\\n    private void dfs2(List<Integer>[] g, int s, int p, int[] add){\\n        for(int i: g[s]) if(i != p){\\n            // sum of everything above it, to calculate total sums\\n            add[i]+=add[s];\\n            dfs2(g, i, s, add);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rootCount(int[][] eg, int[][] gu, int k) {\\n        // number of nodes\\n        int n = eg.length+1;\\n        // graph\\n        List<Integer>[] g = new List[n];\\n        for(int i = 0; i<n; i++) g[i] = new LinkedList<>();\\n        for(int[] a: eg){\\n            g[a[0]].add(a[1]);\\n            g[a[1]].add(a[0]);\\n        }\\n        // counter for outside the subtree\\n        int all = 0;\\n        // counter for inside the subtree and parent list\\n        int[] add = new int[n], par = new int[n];\\n        // calculate parents\\n        dfs1(g, 0, -1, par);\\n        for(int[] a: gu) if(par[a[1]] == a[0]){\\n            // add one to outside the subtree\\n            all++;\\n            add[a[1]]--;\\n        }else // add one to inside the subtree\\n        add[a[0]]++;\\n        // calculate total sums\\n        dfs2(g, 0, -1, add);\\n        int ans = 0;\\n        for(int i: add) if(i+all >= k) ans++;\\n        return ans;\\n    }\\n    private void dfs1(List<Integer>[] g, int s, int p, int[] par){\\n        par[s] = p;\\n        for(int i: g[s]) if(i != p) dfs1(g, i, s, par);\\n    }\\n    private void dfs2(List<Integer>[] g, int s, int p, int[] add){\\n        for(int i: g[s]) if(i != p){\\n            // sum of everything above it, to calculate total sums\\n            add[i]+=add[s];\\n            dfs2(g, i, s, add);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257639,
                "title": "easy-solution-o-n-dfs-memo-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to run dfs from each node and count the guesses\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\\n        int n = edges.length + 1;\\n        \\n        List<Integer>[] graph = new ArrayList[n];\\n        Set<Integer>[] guessesGraph = new HashSet[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n            guessesGraph[i] = new HashSet<>();\\n        }\\n        for (int[] edge : edges) {\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        for (int[] guess : guesses) {\\n            guessesGraph[guess[0]].add(guess[1]);\\n        }\\n\\n        int res = 0;\\n        Map<Long, Integer> memo = new HashMap<>();\\n        for (int i = 0; i<n; i++) {\\n            if (dfs(graph, guessesGraph, memo, i, -1) >= k) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    int dfs(List<Integer>[] graph, Set<Integer>[] guessesGraph, Map<Long, Integer> memo, int current, int prev) {\\n        long key = (long)current * 1000000 + prev;\\n        if (memo.containsKey(key)) return memo.get(key);\\n        int count = prev != -1 && guessesGraph[prev].contains(current) ? 1 : 0;\\n        for (int next : graph[current]) {\\n            if (next != prev) {\\n                count += dfs(graph, guessesGraph, memo, next, current);\\n            }\\n        }\\n        memo.put(key, count);\\n        return count;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\\n        int n = edges.length + 1;\\n        \\n        List<Integer>[] graph = new ArrayList[n];\\n        Set<Integer>[] guessesGraph = new HashSet[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n            guessesGraph[i] = new HashSet<>();\\n        }\\n        for (int[] edge : edges) {\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        for (int[] guess : guesses) {\\n            guessesGraph[guess[0]].add(guess[1]);\\n        }\\n\\n        int res = 0;\\n        Map<Long, Integer> memo = new HashMap<>();\\n        for (int i = 0; i<n; i++) {\\n            if (dfs(graph, guessesGraph, memo, i, -1) >= k) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    int dfs(List<Integer>[] graph, Set<Integer>[] guessesGraph, Map<Long, Integer> memo, int current, int prev) {\\n        long key = (long)current * 1000000 + prev;\\n        if (memo.containsKey(key)) return memo.get(key);\\n        int count = prev != -1 && guessesGraph[prev].contains(current) ? 1 : 0;\\n        for (int next : graph[current]) {\\n            if (next != prev) {\\n                count += dfs(graph, guessesGraph, memo, next, current);\\n            }\\n        }\\n        memo.put(key, count);\\n        return count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257583,
                "title": "c-100-fast-o-n-dfs-solution-with-detailed-explanation",
                "content": "# Intuition\\nSuppose [a,b] is an edge and a is the root of the tree. Now suppose we want to evaluate b as the root of the tree. The only guess that were previously correct and now incorrect would be [a,b]. Similarly the only guess that was previously incorrect but now correct is [b,a].\\n\\n# Approach\\nCreate an adjacency list of the graph ->***tree***. Suppose 0 is the root of the tree. Apply bfs (I used bfs but dfs can be used as well) to evaluate all the guesses that are now correct ->***ans***. Create another array of size n -> ***possible*** that stores if the current node is capable of being the root of the tree. possible[0] = 1 if ans>=k, else possible[0]=0;\\n\\nNow try to evaluate the ans if one of the neighbours of 0 is the root. Suppose [0,b] is an edge in guesses. We will know that since b is now parent, [0,b] guess would now be false. So decrement ans by 1 in this case. Similarly suppose [b,0] was a guess. This guess is now correct. Increment ans by 1 in this case. Again see if ans>=k. If yes, possible[b]=1, else possible[b]=0;\\n\\nContinue this for all the edges in the tree in a dfs manner. Finally return the number of indexes where possible array entry is equal to 1. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> mp;\\n    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)\\n    {\\n        for(auto& a:tree[cur])\\n        {\\n            if(possible[a]==-1)\\n            {\\n                int new_ans=ans;\\n                bool a1=false,a2=false;\\n                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )\\n                {\\n                    mp[{a,cur}]=1;\\n                    new_ans++;\\n                    a1=true;\\n                }\\n                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )\\n                {\\n                    mp[{cur,a}]=0;\\n                    new_ans--;\\n                    a2=true;\\n                }\\n                possible[a]=0;\\n                if(new_ans>=k)\\n                {\\n                    possible[a]=1;\\n                }\\n                dfs(tree,possible,a,new_ans,k);\\n                if(a1)\\n                {\\n                    mp[{a,cur}]=0;\\n                }\\n                if(a2)\\n                {\\n                    mp[{cur,a}]=1;\\n                }\\n            }\\n        }\\n\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        \\n        for(auto&e : guesses)\\n        {\\n            mp[ {e[0],e[1]}]=0;\\n        }\\n        int n=edges.size()+1;\\n        vector<vector<int>> tree(n);\\n        for(auto& e:edges)\\n        {\\n            tree[e[0]].push_back(e[1]);\\n            tree[e[1]].push_back(e[0]);\\n        }\\n        queue<int> q;\\n        q.push(0);\\n        vector<bool> visited(n,false);\\n        visited[0]=true;\\n        int ans=0;\\n        while(q.size()>0)\\n        {\\n            int a=q.front();\\n            q.pop();\\n            for(int i=0;i<tree[a].size();i++)\\n            {\\n                if(visited[tree[a][i]])\\n                    continue;\\n                visited[tree[a][i]]=true;\\n                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )\\n                {\\n                    mp[{a,tree[a][i]}]=1;\\n                    ans++;\\n                }\\n                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )\\n                {\\n                    mp[{tree[a][i],a}]=0;\\n                    ans--;\\n                }\\n                q.push(tree[a][i]);\\n            }\\n        }\\n        vector<int> possible(n,-1);\\n        possible[0]= (1?ans>=k:0);\\n        dfs(tree,possible,0,ans,k);\\n        int sum=accumulate(possible.begin(),possible.end(),0);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> mp;\\n    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)\\n    {\\n        for(auto& a:tree[cur])\\n        {\\n            if(possible[a]==-1)\\n            {\\n                int new_ans=ans;\\n                bool a1=false,a2=false;\\n                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )\\n                {\\n                    mp[{a,cur}]=1;\\n                    new_ans++;\\n                    a1=true;\\n                }\\n                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )\\n                {\\n                    mp[{cur,a}]=0;\\n                    new_ans--;\\n                    a2=true;\\n                }\\n                possible[a]=0;\\n                if(new_ans>=k)\\n                {\\n                    possible[a]=1;\\n                }\\n                dfs(tree,possible,a,new_ans,k);\\n                if(a1)\\n                {\\n                    mp[{a,cur}]=0;\\n                }\\n                if(a2)\\n                {\\n                    mp[{cur,a}]=1;\\n                }\\n            }\\n        }\\n\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        \\n        for(auto&e : guesses)\\n        {\\n            mp[ {e[0],e[1]}]=0;\\n        }\\n        int n=edges.size()+1;\\n        vector<vector<int>> tree(n);\\n        for(auto& e:edges)\\n        {\\n            tree[e[0]].push_back(e[1]);\\n            tree[e[1]].push_back(e[0]);\\n        }\\n        queue<int> q;\\n        q.push(0);\\n        vector<bool> visited(n,false);\\n        visited[0]=true;\\n        int ans=0;\\n        while(q.size()>0)\\n        {\\n            int a=q.front();\\n            q.pop();\\n            for(int i=0;i<tree[a].size();i++)\\n            {\\n                if(visited[tree[a][i]])\\n                    continue;\\n                visited[tree[a][i]]=true;\\n                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )\\n                {\\n                    mp[{a,tree[a][i]}]=1;\\n                    ans++;\\n                }\\n                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )\\n                {\\n                    mp[{tree[a][i],a}]=0;\\n                    ans--;\\n                }\\n                q.push(tree[a][i]);\\n            }\\n        }\\n        vector<int> possible(n,-1);\\n        possible[0]= (1?ans>=k:0);\\n        dfs(tree,possible,0,ans,k);\\n        int sum=accumulate(possible.begin(),possible.end(),0);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256473,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    const int N = (int)1e5 + 1, M = N * 2;\\n    int[] h = new int[N], ne = new int[M], e = new int[M], w = new int[N];\\n    int[] son = new int[M], father = new int[M], ans = new int[M];\\n    int[] fa_son = new int[N];\\n    Dictionary<int, Dictionary<int, int>> d = new();\\n    int idx = 0;\\n    public int RootCount(int[][] edges, int[][] guesses, int k) {\\n        Array.Fill(h, -1);\\n        foreach(var g in guesses){\\n            if(!d.ContainsKey(g[0]))\\n                d[g[0]] = new Dictionary<int, int>();\\n            d[g[0]][g[1]] = 1;\\n        }\\n        foreach(var edge in edges){\\n            int u = edge[0], v = edge[1];\\n            e[idx] = v; ne[idx] = h[u]; h[u] = idx++;\\n            e[idx] = u; ne[idx] = h[v]; h[v] = idx++;\\n        }\\n        Dfs1(0, -1);\\n        Dfs2(0, -1);\\n        Dfs3(0, -1);\\n        int cnt = 0;\\n        for(int i = 0; i <= edges.Length; i++){\\n            Console.WriteLine(son[i] + \" \" + father[i] + \" \" + fa_son[i] + \" \" + ans[i]);\\n            if(ans[i] >= k) \\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    public void Dfs1(int u, int fa){\\n        for(int i = h[u]; i != -1; i = ne[i]){\\n            int j = e[i];\\n            if(j == fa) continue;\\n            else Dfs1(j, u);\\n        }\\n        if(fa != -1) son[fa] += son[u] + (d.ContainsKey(fa) && d[fa].ContainsKey(u) ? 1 : 0);\\n    }\\n    \\n    public void Dfs2(int u, int fa){\\n        father[u] += (fa == -1 ? 0 : father[fa]) + (d.ContainsKey(u) && d[u].ContainsKey(fa) ? 1 : 0);\\n        if(fa != -1) fa_son[u] += son[fa] - son[u] + fa_son[fa] - (d.ContainsKey(fa) && d[fa].ContainsKey(u) ? 1 : 0); \\n        for(int i = h[u]; i != -1; i = ne[i]){\\n            int j = e[i];\\n            if(j == fa) continue;\\n            else Dfs2(j, u);\\n        }\\n    }\\n    \\n    public void Dfs3(int u, int fa){\\n        ans[u] = (fa == -1 ? son[0]: son[u]) + father[u] + fa_son[u];\\n        for(int i = h[u]; i != -1; i = ne[i]){\\n            int j = e[i];\\n            if(j == fa) continue;\\n            else Dfs3(j, u);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    const int N = (int)1e5 + 1, M = N * 2;\\n    int[] h = new int[N], ne = new int[M], e = new int[M], w = new int[N];\\n    int[] son = new int[M], father = new int[M], ans = new int[M];\\n    int[] fa_son = new int[N];\\n    Dictionary<int, Dictionary<int, int>> d = new();\\n    int idx = 0;\\n    public int RootCount(int[][] edges, int[][] guesses, int k) {\\n        Array.Fill(h, -1);\\n        foreach(var g in guesses){\\n            if(!d.ContainsKey(g[0]))\\n                d[g[0]] = new Dictionary<int, int>();\\n            d[g[0]][g[1]] = 1;\\n        }\\n        foreach(var edge in edges){\\n            int u = edge[0], v = edge[1];\\n            e[idx] = v; ne[idx] = h[u]; h[u] = idx++;\\n            e[idx] = u; ne[idx] = h[v]; h[v] = idx++;\\n        }\\n        Dfs1(0, -1);\\n        Dfs2(0, -1);\\n        Dfs3(0, -1);\\n        int cnt = 0;\\n        for(int i = 0; i <= edges.Length; i++){\\n            Console.WriteLine(son[i] + \" \" + father[i] + \" \" + fa_son[i] + \" \" + ans[i]);\\n            if(ans[i] >= k) \\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    public void Dfs1(int u, int fa){\\n        for(int i = h[u]; i != -1; i = ne[i]){\\n            int j = e[i];\\n            if(j == fa) continue;\\n            else Dfs1(j, u);\\n        }\\n        if(fa != -1) son[fa] += son[u] + (d.ContainsKey(fa) && d[fa].ContainsKey(u) ? 1 : 0);\\n    }\\n    \\n    public void Dfs2(int u, int fa){\\n        father[u] += (fa == -1 ? 0 : father[fa]) + (d.ContainsKey(u) && d[u].ContainsKey(fa) ? 1 : 0);\\n        if(fa != -1) fa_son[u] += son[fa] - son[u] + fa_son[fa] - (d.ContainsKey(fa) && d[fa].ContainsKey(u) ? 1 : 0); \\n        for(int i = h[u]; i != -1; i = ne[i]){\\n            int j = e[i];\\n            if(j == fa) continue;\\n            else Dfs2(j, u);\\n        }\\n    }\\n    \\n    public void Dfs3(int u, int fa){\\n        ans[u] = (fa == -1 ? son[0]: son[u]) + father[u] + fa_son[u];\\n        for(int i = h[u]; i != -1; i = ne[i]){\\n            int j = e[i];\\n            if(j == fa) continue;\\n            else Dfs3(j, u);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256354,
                "title": "c-easy-rerooting-similar-problems",
                "content": "\\n# Approach\\n**1:** Traverse down the tree (from any node) and store the number of guessed edges it encounters. Store it in an array depth.\\n\\n**2:** Now we know how many guesses edges it uses to traverse downwards.\\nTo traverse upwards it needs to know how many guessed edges its parent uses. \\nTo pass that value to its child subtract its answer that from number of guesses used to traverse to current child. Say that value is par_ans.\\n**3:** Now ans of any node=1(if it needs guessed edge to go to its parent) + depth (guessed edges it needs to traverse downwards) + par_ans(guessed edges it needs to traverse upwards).\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN) (logN for checking existence of an edge in set)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    set <vector<int>> s;\\n    int res;\\n    int k;\\n    vector <int> depth;\\n    vector <int> ans;\\n    int dfs(int src,vector <int> adj[],int par=-1){\\n        int count=0;\\n        for(auto child:adj[src]){\\n            if(child!=par){\\n                if(s.count({src,child}))++count;\\n                count+=dfs(child,adj,src);\\n            }\\n        }\\n        return depth[src]=count;\\n    }\\n    void dfs3(int src, int par_ans,vector <int> adj[],int par=-1)\\n    {\\n        ans[src]=depth[src]+par_ans;\\n        for(auto child:adj[src]){\\n            if(child!=par){\\n                int temp=ans[src]-depth[child];\\n                \\n                if(s.count({src,child}))--temp;\\n                if(s.count({child,src}))++temp;\\n                dfs3(child,temp,adj,src);\\n            }\\n        }\\n    }\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n=edges.size()+1;\\n        vector<int> adj[n];\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        set <vector<int>> s(begin(guesses),end(guesses));\\n        \\n        this->s=s;\\n        this->k=k;\\n        depth.resize(n,0);\\n        ans.resize(n,0);\\n        \\n        res=0;\\n        dfs(0,adj);\\n        dfs3(0,0,adj);\\n        \\n        for(auto &i:ans){\\n            if(i>=k)++res;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n# Similar Problems:\\n**1.** Tree Distance 1 and Tree Distance 2 from CSES problemset.\\n**2.** [2538. Difference Between Maximum and Minimum Price Sum](https://leetcode.com/problems/difference-between-maximum-and-minimum-price-sum/) (Variation of Tree Distance 1)\\n\\n# Sources to Study:\\nKarthik arora\\'s Playlist on DP on Trees(on Youtube)",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    set <vector<int>> s;\\n    int res;\\n    int k;\\n    vector <int> depth;\\n    vector <int> ans;\\n    int dfs(int src,vector <int> adj[],int par=-1){\\n        int count=0;\\n        for(auto child:adj[src]){\\n            if(child!=par){\\n                if(s.count({src,child}))++count;\\n                count+=dfs(child,adj,src);\\n            }\\n        }\\n        return depth[src]=count;\\n    }\\n    void dfs3(int src, int par_ans,vector <int> adj[],int par=-1)\\n    {\\n        ans[src]=depth[src]+par_ans;\\n        for(auto child:adj[src]){\\n            if(child!=par){\\n                int temp=ans[src]-depth[child];\\n                \\n                if(s.count({src,child}))--temp;\\n                if(s.count({child,src}))++temp;\\n                dfs3(child,temp,adj,src);\\n            }\\n        }\\n    }\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n=edges.size()+1;\\n        vector<int> adj[n];\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        set <vector<int>> s(begin(guesses),end(guesses));\\n        \\n        this->s=s;\\n        this->k=k;\\n        depth.resize(n,0);\\n        ans.resize(n,0);\\n        \\n        res=0;\\n        dfs(0,adj);\\n        dfs3(0,0,adj);\\n        \\n        for(auto &i:ans){\\n            if(i>=k)++res;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256195,
                "title": "top-down-dp",
                "content": "**Intuition**\\n\\n1. Given a sub-tree, we can count how many edges are in `guesses`, which means how many guesses are correct for this sub-tree.\\n\\t* `guesses` should be put into a hash so that we can achieve `O(1)` for each edge to find out if it is in `guesses`.\\n2. The answer for each sub-tree can be memorized.\\n\\t* That implies each edge will be visited only twice (forward and backward).  Given that each edge costs `O(1)`, so it would cost `O(n)` as a total.\\n\\t* Remember, a sub-tree is defined by not only the sub-root node but the also its parent node, because the given graph is undirected.\\n\\n**Step by step**\\n\\nFirst, we put `guesses` into a hash, and we build the graph:\\n```\\n\\t\\tn = len(edges) + 1\\n\\t\\th = set(tuple(x) for x in guesses)\\n        g = [[] for _ in range(n)]\\n        for a, b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n```\\nAnd then we make a recursive function to count the correct guesses in each sub-tree:\\n```\\n        @cache\\n        def rec(p, pp):\\n\\t\\t\\t# p: sub-root, pp: parent of p\\n            r = 0\\n            for q in g[p]:\\n                if q == pp: continue\\n                if (p, q) in h:\\n                    r += 1\\n                r += rec(q, p)\\n            return r\\n```\\nAnd finally, we try to make each node as the root and check the correct guess count:\\n```\\n        r = 0\\n        for i in range(n):\\n            if rec(i, i) >= k:\\n                r += 1\\n        return r\\n```\\nWe got the answer.\\n\\n**Complete code**\\n\\t\\t\\n```\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        n = len(edges) + 1\\n        \\n        h = set(tuple(x) for x in guesses)\\n        \\n        g = [[] for _ in range(n)]\\n        for a, b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n            \\n        @cache\\n        def rec(p, pp):\\n            r = 0\\n            for q in g[p]:\\n                if q == pp: continue\\n                if (p, q) in h:\\n                    r += 1\\n                r += rec(q, p)\\n            return r\\n        \\n        r = 0\\n        for i in range(n):\\n            if rec(i, i) >= k:\\n                r += 1\\n        return r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\t\\tn = len(edges) + 1\\n\\t\\th = set(tuple(x) for x in guesses)\\n        g = [[] for _ in range(n)]\\n        for a, b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n```\n```\\n        @cache\\n        def rec(p, pp):\\n\\t\\t\\t# p: sub-root, pp: parent of p\\n            r = 0\\n            for q in g[p]:\\n                if q == pp: continue\\n                if (p, q) in h:\\n                    r += 1\\n                r += rec(q, p)\\n            return r\\n```\n```\\n        r = 0\\n        for i in range(n):\\n            if rec(i, i) >= k:\\n                r += 1\\n        return r\\n```\n```\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        n = len(edges) + 1\\n        \\n        h = set(tuple(x) for x in guesses)\\n        \\n        g = [[] for _ in range(n)]\\n        for a, b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n            \\n        @cache\\n        def rec(p, pp):\\n            r = 0\\n            for q in g[p]:\\n                if q == pp: continue\\n                if (p, q) in h:\\n                    r += 1\\n                r += rec(q, p)\\n            return r\\n        \\n        r = 0\\n        for i in range(n):\\n            if rec(i, i) >= k:\\n                r += 1\\n        return r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3256108,
                "title": "python3-2-bfs",
                "content": "First, if both `[i, j]` and `[j, i]` are in `guesses`, in any case, they contribute to 1 correct guess. So, apart from these pairs, we use `s` to represent all the other guesses. We define `cnt` to be the number of correct guesses when the root is `0`.\\nLet `dp[i]` be the number of correct guesses when the root is `i`. We do BFS from node `0`. Consider a parent-child pair `(i, j)`, if we change the root from `i` to `j`, only the relation between `i` and `j` changes. Then we can get the `dp[j]` from `dp[i]`.\\n```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        n = len(edges)\\n        if k == 0:\\n            return n + 1\\n        s = set()\\n        cnt = 0\\n        for i, j in guesses:\\n            if (j, i) not in s:\\n                s.add((i, j))\\n            else:\\n                s.remove((j, i))\\n                cnt += 1\\n        \\n        g = [[] for _ in range(n + 1)]\\n        for i, j in edges:\\n            g[i].append(j)\\n            g[j].append(i)\\n        ans = 0\\n        q = deque([0])\\n        visited = [True] * (n + 1)\\n        visited[0] = False\\n        while q:\\n            i = q.popleft()\\n            for j in g[i]:\\n                if visited[j]:\\n                    q.append(j)\\n                    visited[j] = False\\n                    if (i, j) in s:\\n                        cnt += 1\\n        if cnt >= k:\\n            ans += 1\\n            \\n        q = deque([0])\\n        dp = [-1] * (n + 1)\\n        dp[0] = cnt\\n        while q:\\n            i = q.popleft()\\n            for j in g[i]:\\n                if dp[j] == -1:\\n                    q.append(j)\\n                    if (i, j) in s:\\n                        dp[j] = dp[i] - 1\\n                    elif (j, i) in s:\\n                        dp[j] = dp[i] + 1\\n                    else:\\n                        dp[j] = dp[i]\\n                    if dp[j] >= k:\\n                        ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        n = len(edges)\\n        if k == 0:\\n            return n + 1\\n        s = set()\\n        cnt = 0\\n        for i, j in guesses:\\n            if (j, i) not in s:\\n                s.add((i, j))\\n            else:\\n                s.remove((j, i))\\n                cnt += 1\\n        \\n        g = [[] for _ in range(n + 1)]\\n        for i, j in edges:\\n            g[i].append(j)\\n            g[j].append(i)\\n        ans = 0\\n        q = deque([0])\\n        visited = [True] * (n + 1)\\n        visited[0] = False\\n        while q:\\n            i = q.popleft()\\n            for j in g[i]:\\n                if visited[j]:\\n                    q.append(j)\\n                    visited[j] = False\\n                    if (i, j) in s:\\n                        cnt += 1\\n        if cnt >= k:\\n            ans += 1\\n            \\n        q = deque([0])\\n        dp = [-1] * (n + 1)\\n        dp[0] = cnt\\n        while q:\\n            i = q.popleft()\\n            for j in g[i]:\\n                if dp[j] == -1:\\n                    q.append(j)\\n                    if (i, j) in s:\\n                        dp[j] = dp[i] - 1\\n                    elif (j, i) in s:\\n                        dp[j] = dp[i] + 1\\n                    else:\\n                        dp[j] = dp[i]\\n                    if dp[j] >= k:\\n                        ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256073,
                "title": "c-classic-tree-dfs",
                "content": "The hardest part of this problem is coming up with the idea. My thought process was as follows: \\n- Wrote the naive n^2 solution to make sure I understood the problem statement and had something to work with (traverse the tree each time and count how many good guesses)\\n- Thought about how I can optimize this n^2 solution\\n- Realized that if I change the root from one node to an adjacent node, then the number of correct guesses can only increase/decrease by 1 (so a LOT of work can be saved)\\n- Store all guesses in a map to quickly check if they exist \\n- Arbitrarily root the tree at 0 and count how many guesses are correct\\n- If guesses >= k, ans must be increased by 1\\n- Now DFS all neighbors and simulate changing the root to them, decreasing correct guesses by 1 if {root, neighbor} was a guess and increasing correct guesses by 1 if {neighbor, root} was a guess\\n- If guesses >= k, ans must be increased by 1\\n- DFS entire tree and return final answer!\\n\\n```\\nclass Solution {\\npublic:\\n    typedef array<int, 2> ai;\\n    map<ai, int> mp;\\n    int ans = 0;\\n    int vis[200001] = {};\\n    int trav(vector<vector<int>>& adj, int pos){\\n        if(vis[pos]++) return 0;\\n        int ans = 0;\\n        for(auto i : adj[pos]){\\n            ai t = {pos, i};\\n            if(mp.count(t) && !vis[i]) ans++; \\n            ans += trav(adj, i);\\n        }\\n        return ans;\\n    }\\n    int vis2[200001] = {};\\n    int dfs(vector<vector<int>>& adj, int pos, int guesses, int k){\\n        if(vis2[pos]++) return 0;\\n        int ans = guesses>=k; \\n        for(auto i : adj[pos]){\\n            bool bad = false;\\n            bool good = false;\\n            ai t = {pos, i};\\n            ai t2 = {i, pos};\\n            if(mp.count(t)) bad = true; // now {i, pos} is how the tree is arranged so if we counted this guess it is now wrong\\n            if(mp.count(t2)) good = true; // if {i, pos} is a guess, then we can include it now\\n            ans += dfs(adj, i, guesses-bad+good, k); // new guess count is therefore guess count - the one we unlinked + the new one if it exists \\n        }\\n        return ans;\\n    }\\n\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        vector<vector<int>> adj(edges.size()+1);\\n        for(auto & i : edges){ // create adjacency list\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        for(auto & i : guesses){ // put guesses in a map for log n queries\\n            ai t = {i[0], i[1]};\\n            mp[t]++;\\n        }\\n        int ans = 0;\\n        int ok = trav(adj, 0); // count correct guesses rooted at 0 \\n        ans = dfs(adj, 0, ok, k); // perform dfs on entire tree rooted at 0 using method described\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    typedef array<int, 2> ai;\\n    map<ai, int> mp;\\n    int ans = 0;\\n    int vis[200001] = {}",
                "codeTag": "Java"
            },
            {
                "id": 4034287,
                "title": "re-rooting-o-n-explained",
                "content": "# AUTHOR: JAYESH BADGUJAR\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int src,map<int,vector<int>>& mp,int& total,set<pair<int,int>>& st,int par){\\n        for(auto it:mp[src]){\\n            if(it!=par){\\n                if(st.find({src,it})!=st.end()){\\n                    total++;                   \\n                }\\n                dfs(it,mp,total,st,src);\\n            }\\n        }\\n    }\\n    void find(int src,map<int,vector<int>>& mp,int total,set<pair<int,int>>& st,int par,int& ans,int& k){\\n        if(total>=k){\\n            ans++;\\n        }\\n        for(auto it:mp[src]){\\n            if(it!=par){\\n                if(st.find({src,it})!=st.end()){\\n                    total--;\\n                }\\n                if(st.find({it,src})!=st.end()){\\n                    total++;\\n                }\\n                find(it,mp,total,st,src,ans,k);\\n                if(st.find({src,it})!=st.end()){\\n                    total++;\\n                }\\n                if(st.find({it,src})!=st.end()){\\n                    total--;\\n                }\\n            }\\n        }\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int total=0;\\n        map<int,vector<int>> mp;\\n        set<pair<int,int>> st;\\n        for(int i=0;i<guesses.size();i++){\\n            st.insert({guesses[i][0],guesses[i][1]});\\n        }\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i][0]].push_back(edges[i][1]);\\n            mp[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        dfs(0,mp,total,st,-1);\\n        int ans=0;\\n        find(0,mp,total,st,-1,ans,k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int src,map<int,vector<int>>& mp,int& total,set<pair<int,int>>& st,int par){\\n        for(auto it:mp[src]){\\n            if(it!=par){\\n                if(st.find({src,it})!=st.end()){\\n                    total++;                   \\n                }\\n                dfs(it,mp,total,st,src);\\n            }\\n        }\\n    }\\n    void find(int src,map<int,vector<int>>& mp,int total,set<pair<int,int>>& st,int par,int& ans,int& k){\\n        if(total>=k){\\n            ans++;\\n        }\\n        for(auto it:mp[src]){\\n            if(it!=par){\\n                if(st.find({src,it})!=st.end()){\\n                    total--;\\n                }\\n                if(st.find({it,src})!=st.end()){\\n                    total++;\\n                }\\n                find(it,mp,total,st,src,ans,k);\\n                if(st.find({src,it})!=st.end()){\\n                    total++;\\n                }\\n                if(st.find({it,src})!=st.end()){\\n                    total--;\\n                }\\n            }\\n        }\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int total=0;\\n        map<int,vector<int>> mp;\\n        set<pair<int,int>> st;\\n        for(int i=0;i<guesses.size();i++){\\n            st.insert({guesses[i][0],guesses[i][1]});\\n        }\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i][0]].push_back(edges[i][1]);\\n            mp[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        dfs(0,mp,total,st,-1);\\n        int ans=0;\\n        find(0,mp,total,st,-1,ans,k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016916,
                "title": "simple-easy-dfs",
                "content": "run dfs from each node assuming it as a root and count correct guesses if it >= k then that node can be a valid root so count such nodes\\n\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>, int> vis;\\n    map<pair<int,int>,int> guess;\\n    vector<vector<int>> g;\\n    int solve(int node , int par)\\n    {\\n        if(vis.find({par,node})!=vis.end()) return vis[{par,node}];\\n        \\n        int t=guess.count({par,node});\\n        for(auto i: g[node])\\n        {\\n            if(i!=par)\\n            t+=solve(i,node);\\n        }\\n        return vis[{par,node}]=t;\\n    }\\n    \\n    \\n    int rootCount(vector<vector<int>>& e, vector<vector<int>>& guesses, int k) \\n    {\\n        int n=e.size();\\n        g.resize(n+1);\\n        for(int i=0; i<n; i++)\\n        {\\n            g[e[i][0]].push_back(e[i][1]);\\n            g[e[i][1]].push_back(e[i][0]);\\n            \\n        }\\n        \\n        for(auto i: guesses)\\n        {\\n            guess[{i[0],i[1]}]=1;\\n        }\\n        int count=0;\\n        for(int i=0; i<n+1; i++)\\n        {\\n            int t=solve(i,-1);\\n            if(t>=k) count++;\\n        }\\n        return count;\\n        \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>, int> vis;\\n    map<pair<int,int>,int> guess;\\n    vector<vector<int>> g;\\n    int solve(int node , int par)\\n    {\\n        if(vis.find({par,node})!=vis.end()) return vis[{par,node}];\\n        \\n        int t=guess.count({par,node});\\n        for(auto i: g[node])\\n        {\\n            if(i!=par)\\n            t+=solve(i,node);\\n        }\\n        return vis[{par,node}]=t;\\n    }\\n    \\n    \\n    int rootCount(vector<vector<int>>& e, vector<vector<int>>& guesses, int k) \\n    {\\n        int n=e.size();\\n        g.resize(n+1);\\n        for(int i=0; i<n; i++)\\n        {\\n            g[e[i][0]].push_back(e[i][1]);\\n            g[e[i][1]].push_back(e[i][0]);\\n            \\n        }\\n        \\n        for(auto i: guesses)\\n        {\\n            guess[{i[0],i[1]}]=1;\\n        }\\n        int count=0;\\n        for(int i=0; i<n+1; i++)\\n        {\\n            int t=solve(i,-1);\\n            if(t>=k) count++;\\n        }\\n        return count;\\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984518,
                "title": "dfs-traversal-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& e, vector<vector<int>>& g, int k) {\\n        int n=e.size();\\n        vector<vector<int>>v(n+1);\\n        for(int i=0;i<e.size();i++){\\n            v[e[i][0]].push_back(e[i][1]);\\n            v[e[i][1]].push_back(e[i][0]);\\n        }\\n        unordered_map<string,int>m;\\n        vector<int>vis_u(n+1,0);\\n        vector<int>vis(n+1,0);\\n        for(int i=0;i<g.size();i++){\\n            string s=to_string(g[i][0])+\" \"+to_string(g[i][1]);\\n            m[s]=1;\\n        }\\n        int res=0;\\n        int count=0;\\n        vis[0]=1;\\n        vis_u[0]=1;\\n        queue<int>q;\\n        q.push(0);\\n        while(!q.empty()){\\n            int t=q.front();\\n            q.pop();\\n            for(int i=0;i<v[t].size();i++){\\n                if(!vis[v[t][i]]){\\n                    string key=to_string(t)+\" \"+to_string(v[t][i]);\\n                    if(m.count(key)) count++;\\n                    vis[v[t][i]]=1;\\n                    q.push(v[t][i]);\\n                }\\n            }\\n        }\\n        queue<vector<int>>q1;\\n        q1.push({0,count});\\n        while(!q1.empty()){\\n            auto w=q1.front();\\n            q1.pop();\\n            int t=w[0];\\n            int c=w[1];\\n            if(c>=k) res++;\\n            for(int i=0;i<v[t].size();i++){\\n                int c1=c;\\n                if(!vis_u[v[t][i]]){\\n                    string key=to_string(t)+\" \"+to_string(v[t][i]);\\n                    if(m.count(key)) c1--;\\n                    key=to_string(v[t][i])+\" \"+to_string(t);\\n                    if(m.count(key)) c1++;\\n                    vis_u[v[t][i]]=1;\\n                    q1.push({v[t][i],c1});\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& e, vector<vector<int>>& g, int k) {\\n        int n=e.size();\\n        vector<vector<int>>v(n+1);\\n        for(int i=0;i<e.size();i++){\\n            v[e[i][0]].push_back(e[i][1]);\\n            v[e[i][1]].push_back(e[i][0]);\\n        }\\n        unordered_map<string,int>m;\\n        vector<int>vis_u(n+1,0);\\n        vector<int>vis(n+1,0);\\n        for(int i=0;i<g.size();i++){\\n            string s=to_string(g[i][0])+\" \"+to_string(g[i][1]);\\n            m[s]=1;\\n        }\\n        int res=0;\\n        int count=0;\\n        vis[0]=1;\\n        vis_u[0]=1;\\n        queue<int>q;\\n        q.push(0);\\n        while(!q.empty()){\\n            int t=q.front();\\n            q.pop();\\n            for(int i=0;i<v[t].size();i++){\\n                if(!vis[v[t][i]]){\\n                    string key=to_string(t)+\" \"+to_string(v[t][i]);\\n                    if(m.count(key)) count++;\\n                    vis[v[t][i]]=1;\\n                    q.push(v[t][i]);\\n                }\\n            }\\n        }\\n        queue<vector<int>>q1;\\n        q1.push({0,count});\\n        while(!q1.empty()){\\n            auto w=q1.front();\\n            q1.pop();\\n            int t=w[0];\\n            int c=w[1];\\n            if(c>=k) res++;\\n            for(int i=0;i<v[t].size();i++){\\n                int c1=c;\\n                if(!vis_u[v[t][i]]){\\n                    string key=to_string(t)+\" \"+to_string(v[t][i]);\\n                    if(m.count(key)) c1--;\\n                    key=to_string(v[t][i])+\" \"+to_string(t);\\n                    if(m.count(key)) c1++;\\n                    vis_u[v[t][i]]=1;\\n                    q1.push({v[t][i],c1});\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853217,
                "title": "python-hard",
                "content": "```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        lookup = defaultdict(list)\\n\\n        N = len(edges) + 1\\n\\n        for start, end in edges:\\n            lookup[start] += [end]\\n            lookup[end] += [start]\\n\\n\\n        guess = set()\\n\\n        for start, end in guesses:\\n            guess.add((start, end))\\n\\n        g = [0] * N\\n\\n        def go(node, parent):\\n\\n            best = 0\\n\\n            arr = lookup[node]\\n\\n            for nxt in arr:\\n                if nxt == parent:\\n                    continue\\n\\n                if (node, nxt) in guess:\\n                    best += 1\\n\\n                best += go(nxt, node)\\n\\n            g[node] += best\\n\\n            return best\\n\\n        \\n        go(0, -1)\\n\\n        # count -> number of edges against the grain of node\\n        def go2(node, parent, count):\\n            \\n            arr = lookup[node]\\n\\n            for nxt in arr:\\n                if nxt == parent:\\n                    continue\\n\\n                c = count\\n\\n                if (nxt, node) in guess:\\n                    c += 1\\n\\n                if (node, nxt) in guess:\\n                    c -= 1\\n                \\n\\n                go2(nxt, node, c - g[nxt] + g[node])\\n\\n            g[node] += count\\n \\n        go2(0, -1, 0)\\n\\n        ans = 0\\n\\n        for val in g:\\n            ans += (val >= k)\\n\\n        return ans\\n\\n                \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        lookup = defaultdict(list)\\n\\n        N = len(edges) + 1\\n\\n        for start, end in edges:\\n            lookup[start] += [end]\\n            lookup[end] += [start]\\n\\n\\n        guess = set()\\n\\n        for start, end in guesses:\\n            guess.add((start, end))\\n\\n        g = [0] * N\\n\\n        def go(node, parent):\\n\\n            best = 0\\n\\n            arr = lookup[node]\\n\\n            for nxt in arr:\\n                if nxt == parent:\\n                    continue\\n\\n                if (node, nxt) in guess:\\n                    best += 1\\n\\n                best += go(nxt, node)\\n\\n            g[node] += best\\n\\n            return best\\n\\n        \\n        go(0, -1)\\n\\n        # count -> number of edges against the grain of node\\n        def go2(node, parent, count):\\n            \\n            arr = lookup[node]\\n\\n            for nxt in arr:\\n                if nxt == parent:\\n                    continue\\n\\n                c = count\\n\\n                if (nxt, node) in guess:\\n                    c += 1\\n\\n                if (node, nxt) in guess:\\n                    c -= 1\\n                \\n\\n                go2(nxt, node, c - g[nxt] + g[node])\\n\\n            g[node] += count\\n \\n        go2(0, -1, 0)\\n\\n        ans = 0\\n\\n        for val in g:\\n            ans += (val >= k)\\n\\n        return ans\\n\\n                \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800618,
                "title": "java-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int output = 0;\\n    Map<Integer, Set<Integer>> map;\\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\\n        int n = edges.length + 1;\\n\\n        map = new HashMap<>();\\n\\n        for (int[] guess : guesses) {\\n            Set<Integer> hashSet = map.getOrDefault(guess[0], new HashSet<Integer>());\\n            hashSet.add(guess[1]);\\n            map.put(guess[0], hashSet);\\n        }\\n        \\n        List<List<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        for (int[] edge : edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n\\n        Set<Integer> set = new HashSet<>();\\n        int start = 0;\\n        int ans = dfs(adj, start, set);\\n        if (ans >= k)\\n            output++;\\n\\n        solve(adj, new HashSet<Integer>(), 0, ans, k);\\n\\n        return output;\\n\\n    }\\n\\n    void solve(List<List<Integer>> adj, Set<Integer> set, int cur, int ans, int k) {\\n\\n        set.add(cur);\\n\\n        for (int val : adj.get(cur)) {\\n            int temp = ans;\\n            if (!set.contains(val)) {\\n\\n                if (map.containsKey(cur)) {\\n                    if (map.get(cur).contains(val)) {\\n                        temp--;\\n                    }\\n                }\\n\\n                if (map.containsKey(val)) {\\n                    if (map.get(val).contains(cur)) {\\n                        temp++;\\n                    }\\n                }\\n                if (temp >= k) {\\n                    output++;\\n                }\\n\\n                solve(adj, set, val, temp, k);\\n            }\\n        }\\n    }\\n\\n    \\n\\n    int dfs(List<List<Integer>> adj, int cur, Set<Integer> set) {\\n\\n        set.add(cur);\\n        int count = 0;\\n        for (int val : adj.get(cur)) {\\n            if (!set.contains(val)) {\\n\\n                if (map.containsKey(cur)) {\\n                    if (map.get(cur).contains(val)) {\\n                        count += 1 + dfs(adj, val, set);\\n                    }\\n                    else {\\n                        count += dfs(adj, val, set);\\n                    }\\n                }\\n                else {\\n                    count += dfs(adj, val, set);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int output = 0;\\n    Map<Integer, Set<Integer>> map;\\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\\n        int n = edges.length + 1;\\n\\n        map = new HashMap<>();\\n\\n        for (int[] guess : guesses) {\\n            Set<Integer> hashSet = map.getOrDefault(guess[0], new HashSet<Integer>());\\n            hashSet.add(guess[1]);\\n            map.put(guess[0], hashSet);\\n        }\\n        \\n        List<List<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        for (int[] edge : edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n\\n        Set<Integer> set = new HashSet<>();\\n        int start = 0;\\n        int ans = dfs(adj, start, set);\\n        if (ans >= k)\\n            output++;\\n\\n        solve(adj, new HashSet<Integer>(), 0, ans, k);\\n\\n        return output;\\n\\n    }\\n\\n    void solve(List<List<Integer>> adj, Set<Integer> set, int cur, int ans, int k) {\\n\\n        set.add(cur);\\n\\n        for (int val : adj.get(cur)) {\\n            int temp = ans;\\n            if (!set.contains(val)) {\\n\\n                if (map.containsKey(cur)) {\\n                    if (map.get(cur).contains(val)) {\\n                        temp--;\\n                    }\\n                }\\n\\n                if (map.containsKey(val)) {\\n                    if (map.get(val).contains(cur)) {\\n                        temp++;\\n                    }\\n                }\\n                if (temp >= k) {\\n                    output++;\\n                }\\n\\n                solve(adj, set, val, temp, k);\\n            }\\n        }\\n    }\\n\\n    \\n\\n    int dfs(List<List<Integer>> adj, int cur, Set<Integer> set) {\\n\\n        set.add(cur);\\n        int count = 0;\\n        for (int val : adj.get(cur)) {\\n            if (!set.contains(val)) {\\n\\n                if (map.containsKey(cur)) {\\n                    if (map.get(cur).contains(val)) {\\n                        count += 1 + dfs(adj, val, set);\\n                    }\\n                    else {\\n                        count += dfs(adj, val, set);\\n                    }\\n                }\\n                else {\\n                    count += dfs(adj, val, set);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712287,
                "title": "memorization-beats-93-5-c",
                "content": "# Intuition\\ntry this , this question is similar \\nhttps://leetcode.com/problems/sum-of-distances-in-tree/editorial/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int count = 0 ;\\n    int countz = 0;\\n    void dfs(vector<vector<int>>&g, int st, int p, map<pair<int,int>, bool>&m ){\\n          for(auto x : g[st]){\\n              if( x == p){\\n                  continue;\\n              }\\n              dfs(g, x, st, m);\\n              if(m.find({st, x }) != m.end()){\\n                  countz ++ ;\\n              }\\n          }\\n    }\\n\\n    void dfs2(vector<vector<int>>& g, vector<int>&counti ,map<pair<int,int>, bool>&m,\\n     int st, int p ,int & k ){\\n\\n         \\n         for(auto x : g[st]){\\n             if( x == p ){\\n                 continue;\\n             }\\n             int val = 0;\\n             if(m.find({st, x }) != m.end()){\\n                 val -= 1;\\n             }\\n             if(m.find({x, st}) != m.end()){\\n                 val += 1;\\n             }\\n             counti[x] = counti[st] + val;\\n             dfs2(g, counti , m , x,  st, k);\\n             \\n         }\\n         if(counti[st] >= k){\\n             count++ ;\\n         }\\n        // cout<<st<<\" \"<<counti[st]<<\"    \";\\n     }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n = edges.size()+1;\\n        map<pair<int,int>, bool>m;\\n        for(int i = 0 ; i<guesses.size(); i++){\\n            int a = guesses[i][0];\\n            int b = guesses[i][1];\\n            m[{a, b}] = 1;\\n        }\\n        vector<vector<int>>g(n);\\n        for(int i = 0 ; i<edges.size() ; i++){\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            g[a].push_back(b);\\n            g[b].push_back(a);\\n        }\\n        vector<int>counti(n);\\n        dfs(g, 0 , 0 , m  );\\n        counti[0] = countz;\\n        // cout << countz <<\" \"; \\n        dfs2(g, counti, m, 0 , 0 , k);\\n        // for(int i = 0 ; i<counti.size()  ; i++){\\n        //     cout <<counti[i]<<\" \";\\n        // }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count = 0 ;\\n    int countz = 0;\\n    void dfs(vector<vector<int>>&g, int st, int p, map<pair<int,int>, bool>&m ){\\n          for(auto x : g[st]){\\n              if( x == p){\\n                  continue;\\n              }\\n              dfs(g, x, st, m);\\n              if(m.find({st, x }) != m.end()){\\n                  countz ++ ;\\n              }\\n          }\\n    }\\n\\n    void dfs2(vector<vector<int>>& g, vector<int>&counti ,map<pair<int,int>, bool>&m,\\n     int st, int p ,int & k ){\\n\\n         \\n         for(auto x : g[st]){\\n             if( x == p ){\\n                 continue;\\n             }\\n             int val = 0;\\n             if(m.find({st, x }) != m.end()){\\n                 val -= 1;\\n             }\\n             if(m.find({x, st}) != m.end()){\\n                 val += 1;\\n             }\\n             counti[x] = counti[st] + val;\\n             dfs2(g, counti , m , x,  st, k);\\n             \\n         }\\n         if(counti[st] >= k){\\n             count++ ;\\n         }\\n        // cout<<st<<\" \"<<counti[st]<<\"    \";\\n     }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n = edges.size()+1;\\n        map<pair<int,int>, bool>m;\\n        for(int i = 0 ; i<guesses.size(); i++){\\n            int a = guesses[i][0];\\n            int b = guesses[i][1];\\n            m[{a, b}] = 1;\\n        }\\n        vector<vector<int>>g(n);\\n        for(int i = 0 ; i<edges.size() ; i++){\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            g[a].push_back(b);\\n            g[b].push_back(a);\\n        }\\n        vector<int>counti(n);\\n        dfs(g, 0 , 0 , m  );\\n        counti[0] = countz;\\n        // cout << countz <<\" \"; \\n        dfs2(g, counti, m, 0 , 0 , k);\\n        // for(int i = 0 ; i<counti.size()  ; i++){\\n        //     cout <<counti[i]<<\" \";\\n        // }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3674530,
                "title": "euler-tour",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvoid eulerTour(int node,vector<vector<int>> &adj,int &ind,int par,\\nvector<int> &st,vector<int> &en){\\n    st[node]=ind;\\n    for(auto it: adj[node]){\\n        if(it==par) continue;\\n        ind++;\\n        eulerTour(it,adj,ind,node,st,en);\\n    }\\n    en[node]=ind;\\n}\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges,vector<vector<int>>& g,int k){\\n        int n = edges.size()+1;\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int idx = 0;\\n        vector<int> st(n);\\n        vector<int> en(n);\\n        eulerTour(0,adj,idx,-1,st,en);\\n        vector<int> rangequery(n+1,0);\\n        for(int i=0;i<g.size();i++){\\n            int par = g[i][0];\\n            int child = g[i][1];\\n            if(par<child){\\n                rangequery[0]++;\\n                rangequery[st[child]]--;\\n                rangequery[en[child]+1]++;\\n            }\\n            else{\\n                rangequery[st[par]]++;\\n                rangequery[en[par]+1]--;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            rangequery[i]+=rangequery[i-1];\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(rangequery[i]>=k){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvoid eulerTour(int node,vector<vector<int>> &adj,int &ind,int par,\\nvector<int> &st,vector<int> &en){\\n    st[node]=ind;\\n    for(auto it: adj[node]){\\n        if(it==par) continue;\\n        ind++;\\n        eulerTour(it,adj,ind,node,st,en);\\n    }\\n    en[node]=ind;\\n}\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges,vector<vector<int>>& g,int k){\\n        int n = edges.size()+1;\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int idx = 0;\\n        vector<int> st(n);\\n        vector<int> en(n);\\n        eulerTour(0,adj,idx,-1,st,en);\\n        vector<int> rangequery(n+1,0);\\n        for(int i=0;i<g.size();i++){\\n            int par = g[i][0];\\n            int child = g[i][1];\\n            if(par<child){\\n                rangequery[0]++;\\n                rangequery[st[child]]--;\\n                rangequery[en[child]+1]++;\\n            }\\n            else{\\n                rangequery[st[par]]++;\\n                rangequery[en[par]+1]--;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            rangequery[i]+=rangequery[i-1];\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(rangequery[i]>=k){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641318,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<unordered_set<int>> sons;\\nvector<vector<int>> e;\\nint count=0,k;\\nvector<vector<int>> dp;\\nvoid help(int node,int parent){\\n    int rem;\\n    for(int i=0;i<e[node].size();i++){\\n        if(e[node][i]!=parent){\\n        if(sons[node].find(e[node][i])!=sons[node].end())count++;\\n        if(dp[node][i]!=-1)count+=dp[node][i];\\n        else\\n        {\\n        rem=count;\\n        help(e[node][i],node);\\n        dp[node][i]=count-rem;\\n        }\\n        }\\n    }\\n\\n}\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& g, int K) {\\n        sons=vector<unordered_set<int>>(edges.size()+1,unordered_set<int>());\\n        e=vector<vector<int>>(edges.size()+1,vector<int>(0,0));\\n        dp=vector<vector<int>>(edges.size()+1,vector<int>(0,0));\\n        for(int i=0;i<g.size();i++)sons[g[i][0]].insert(g[i][1]);\\n        for(int i=0;i<edges.size();i++){\\n            e[edges[i][0]].push_back(edges[i][1]);\\n            e[edges[i][1]].push_back(edges[i][0]);\\n            dp[edges[i][0]].push_back(-1);\\n            dp[edges[i][1]].push_back(-1);\\n        }\\n        int res=0;\\n        k=K;\\n        for(int i=0;i<=edges.size();i++){\\n            count=0;\\n            help(i,-1);\\n            if(count>=k)res++;\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<unordered_set<int>> sons;\\nvector<vector<int>> e;\\nint count=0,k;\\nvector<vector<int>> dp;\\nvoid help(int node,int parent){\\n    int rem;\\n    for(int i=0;i<e[node].size();i++){\\n        if(e[node][i]!=parent){\\n        if(sons[node].find(e[node][i])!=sons[node].end())count++;\\n        if(dp[node][i]!=-1)count+=dp[node][i];\\n        else\\n        {\\n        rem=count;\\n        help(e[node][i],node);\\n        dp[node][i]=count-rem;\\n        }\\n        }\\n    }\\n\\n}\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& g, int K) {\\n        sons=vector<unordered_set<int>>(edges.size()+1,unordered_set<int>());\\n        e=vector<vector<int>>(edges.size()+1,vector<int>(0,0));\\n        dp=vector<vector<int>>(edges.size()+1,vector<int>(0,0));\\n        for(int i=0;i<g.size();i++)sons[g[i][0]].insert(g[i][1]);\\n        for(int i=0;i<edges.size();i++){\\n            e[edges[i][0]].push_back(edges[i][1]);\\n            e[edges[i][1]].push_back(edges[i][0]);\\n            dp[edges[i][0]].push_back(-1);\\n            dp[edges[i][1]].push_back(-1);\\n        }\\n        int res=0;\\n        k=K;\\n        for(int i=0;i<=edges.size();i++){\\n            count=0;\\n            help(i,-1);\\n            if(count>=k)res++;\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617360,
                "title": "dp-on-trees-c-o-nlog-n",
                "content": "# Intuition\\nWe have to find the total number of roots satisfying the condition. Also we can observe the relation between the two directly connected nodes in cintext to that codition. This gives us a strong hint to proceed in the direction of `Rerooting of Trees` using `Dynamic Programming.`\\n\\n# Approach\\nFind the solution assuming any one node as the root using `dfs1`. After that we will again run a dfs called `dfs2` to find all the adjacent nodes answer, and the process continues.\\n\\n# Complexity\\n- Time complexity:\\n`dfs1` = `O(n)`\\n`dfs2` = `O(n)`\\ninserting into set, `gss` = `O(nlog(n))`\\nOverall = `O(nlog(n))`\\n\\n- Space complexity:\\nOverall = `O(n)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n = edges.size() + 1;\\n        vector<vector<int>> g(n);\\n        for(auto edge: edges){\\n            g[edge[0]].push_back(edge[1]);\\n            g[edge[1]].push_back(edge[0]);\\n        }\\n        set<pair<int, int>> gss;\\n        for(auto x: guesses){\\n            gss.insert({x[0], x[1]});\\n        }\\n        vector<int> dp(n, 0);\\n        auto dfs1 = [&](int node, int par, auto &dfs1) -> void {\\n            for(auto nbr: g[node]){\\n                if(nbr != par){\\n                    dp[node] += (gss.count({node, nbr}));\\n                    dfs1(nbr, node, dfs1);\\n                    dp[node] += dp[nbr];\\n                }\\n            }\\n        };\\n        dfs1(0, -1, dfs1);\\n        int res = 0;\\n        auto dfs2 = [&](int node, int par, auto &dfs2) -> void {\\n            if(dp[node] >= k){\\n                res++;\\n            }\\n            for(auto nbr: g[node]){\\n                if(nbr != par){\\n                    int diff = 0;\\n                    if(gss.count({node, nbr})){\\n                        diff--;\\n                    }\\n                    if(gss.count({nbr, node})){\\n                        diff++;\\n                    }\\n                    dp[node] -= dp[nbr];\\n                    dp[nbr] += dp[node];\\n                    dp[nbr] += diff;\\n                    dfs2(nbr, node, dfs2);\\n                    dp[nbr] -= diff;\\n                    dp[nbr] -= dp[node];\\n                    dp[node] += dp[nbr];\\n                }\\n            }\\n        };\\n        dfs2(0, -1, dfs2);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n = edges.size() + 1;\\n        vector<vector<int>> g(n);\\n        for(auto edge: edges){\\n            g[edge[0]].push_back(edge[1]);\\n            g[edge[1]].push_back(edge[0]);\\n        }\\n        set<pair<int, int>> gss;\\n        for(auto x: guesses){\\n            gss.insert({x[0], x[1]});\\n        }\\n        vector<int> dp(n, 0);\\n        auto dfs1 = [&](int node, int par, auto &dfs1) -> void {\\n            for(auto nbr: g[node]){\\n                if(nbr != par){\\n                    dp[node] += (gss.count({node, nbr}));\\n                    dfs1(nbr, node, dfs1);\\n                    dp[node] += dp[nbr];\\n                }\\n            }\\n        };\\n        dfs1(0, -1, dfs1);\\n        int res = 0;\\n        auto dfs2 = [&](int node, int par, auto &dfs2) -> void {\\n            if(dp[node] >= k){\\n                res++;\\n            }\\n            for(auto nbr: g[node]){\\n                if(nbr != par){\\n                    int diff = 0;\\n                    if(gss.count({node, nbr})){\\n                        diff--;\\n                    }\\n                    if(gss.count({nbr, node})){\\n                        diff++;\\n                    }\\n                    dp[node] -= dp[nbr];\\n                    dp[nbr] += dp[node];\\n                    dp[nbr] += diff;\\n                    dfs2(nbr, node, dfs2);\\n                    dp[nbr] -= diff;\\n                    dp[nbr] -= dp[node];\\n                    dp[node] += dp[nbr];\\n                }\\n            }\\n        };\\n        dfs2(0, -1, dfs2);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513223,
                "title": "c-n-logn",
                "content": "<!-- # Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach --> -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n logn )\\nn for dfs traversal . \\nlogn = searching in map (guesses array )\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj ;\\n    map<pair<int,int> , int> mp ;\\n    vector<int> dp ;\\n    int ans = 0 ;\\n    vector<bool> visited ;\\n    int k ;\\n\\n    void dfs(int curr ){\\n        visited[curr] = 1 ;\\n        for(auto it : adj[curr] ){\\n            if( !visited[it] ){\\n                dfs(it ) ;\\n                dp[curr] += ( dp[it] + mp[{curr , it }] );\\n            }\\n        }\\n    }   \\n\\n    void dfs2(int curr , int par , int pans ){\\n        visited[curr] = 1 ;\\n        int sz = 0 ;\\n        vector<int> pre , suff ;\\n        for( auto it : adj[curr] ){\\n            if(it != par ){\\n                int cp = mp[{curr , it}] ;\\n                pre.push_back(dp[it] + cp ) ;\\n                suff.push_back(dp[it] + cp ) ;\\n                ++sz ;\\n            }\\n        }\\n        for(int i = 1 ; i< sz ; ++i ){\\n            pre[i] += pre[i-1] ;\\n        }\\n        for(int i = sz-2 ; i>=0 ; --i ){\\n            suff[i] += suff[i+1] ;\\n        }\\n\\n        int cans = dp[curr] + pans ;\\n        if(cans >= k ) ++ans ; \\n        int j = 0 ;\\n\\n        for(int i = 0 ; i< sz ; ++i ){\\n            int prefix = (i > 0 )? pre[i-1] : 0  ;\\n            int suffix = (i < sz-1 )? suff[i+1] : 0  ;\\n             \\n            int val = adj[curr][j] ; ++j;\\n            if(val == par ) { \\n                val = adj[curr][j] ;\\n                ++j;\\n            }\\n        \\n            int partial_ans = prefix + suffix + pans + mp[{val , curr}]  ;\\n            dfs2( val , curr , partial_ans ) ; \\n\\n        }\\n\\n    }    \\n\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int ke ) {\\n        k = ke ; \\n        mp.clear() ;\\n        int n = edges.size() + 1 ;\\n        dp.resize( n ) ;\\n        adj.resize( n ) ;\\n        // 0 - correct   1- reverse \\n        visited.resize(n , 0 ) ;\\n        for(auto it : edges ){\\n            adj[it[0]].push_back(it[1]) ;\\n            adj[it[1]].push_back(it[0]) ;\\n            mp[{it[0] , it[1]}] = 0 ;\\n            mp[{it[1] , it[0]}] = 0 ;\\n        }\\n        for(auto it : guesses ){\\n            mp[{it[0] , it[1]}] = 1 ;\\n        }\\n        dfs(0);\\n\\n        visited.clear() ;\\n        visited.resize(n , 0 ) ;\\n        dfs2( 0 , -1 , 0 ) ;\\n\\n        return ans ;\\n    }\\n};  \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj ;\\n    map<pair<int,int> , int> mp ;\\n    vector<int> dp ;\\n    int ans = 0 ;\\n    vector<bool> visited ;\\n    int k ;\\n\\n    void dfs(int curr ){\\n        visited[curr] = 1 ;\\n        for(auto it : adj[curr] ){\\n            if( !visited[it] ){\\n                dfs(it ) ;\\n                dp[curr] += ( dp[it] + mp[{curr , it }] );\\n            }\\n        }\\n    }   \\n\\n    void dfs2(int curr , int par , int pans ){\\n        visited[curr] = 1 ;\\n        int sz = 0 ;\\n        vector<int> pre , suff ;\\n        for( auto it : adj[curr] ){\\n            if(it != par ){\\n                int cp = mp[{curr , it}] ;\\n                pre.push_back(dp[it] + cp ) ;\\n                suff.push_back(dp[it] + cp ) ;\\n                ++sz ;\\n            }\\n        }\\n        for(int i = 1 ; i< sz ; ++i ){\\n            pre[i] += pre[i-1] ;\\n        }\\n        for(int i = sz-2 ; i>=0 ; --i ){\\n            suff[i] += suff[i+1] ;\\n        }\\n\\n        int cans = dp[curr] + pans ;\\n        if(cans >= k ) ++ans ; \\n        int j = 0 ;\\n\\n        for(int i = 0 ; i< sz ; ++i ){\\n            int prefix = (i > 0 )? pre[i-1] : 0  ;\\n            int suffix = (i < sz-1 )? suff[i+1] : 0  ;\\n             \\n            int val = adj[curr][j] ; ++j;\\n            if(val == par ) { \\n                val = adj[curr][j] ;\\n                ++j;\\n            }\\n        \\n            int partial_ans = prefix + suffix + pans + mp[{val , curr}]  ;\\n            dfs2( val , curr , partial_ans ) ; \\n\\n        }\\n\\n    }    \\n\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int ke ) {\\n        k = ke ; \\n        mp.clear() ;\\n        int n = edges.size() + 1 ;\\n        dp.resize( n ) ;\\n        adj.resize( n ) ;\\n        // 0 - correct   1- reverse \\n        visited.resize(n , 0 ) ;\\n        for(auto it : edges ){\\n            adj[it[0]].push_back(it[1]) ;\\n            adj[it[1]].push_back(it[0]) ;\\n            mp[{it[0] , it[1]}] = 0 ;\\n            mp[{it[1] , it[0]}] = 0 ;\\n        }\\n        for(auto it : guesses ){\\n            mp[{it[0] , it[1]}] = 1 ;\\n        }\\n        dfs(0);\\n\\n        visited.clear() ;\\n        visited.resize(n , 0 ) ;\\n        dfs2( 0 , -1 , 0 ) ;\\n\\n        return ans ;\\n    }\\n};  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481931,
                "title": "c-o-n-time-o-n-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIf we start with node $0$ as root then we know how many guess are right. If any of children of $0$ become root then we can find total correct guesses in $O(1)$ time (we only need to check for $0$ to that child for guess true/false condition). Do this iteratively. \\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int ans;\\n    vector<vector<int>> adl;\\n    vector<int> visited;\\n    int k;\\n\\n    //possible children of node i\\n    vector<unordered_set<int>> cont;\\n\\n    //check edges\\n    int check_edges(int n, int pa){\\n        visited[n] = 1;\\n        int ans = 0;\\n        for(int i: adl[n]){\\n            if(visited[i] == -1){\\n                ans += check_edges(i,n);\\n            }\\n        }\\n        if(pa != -1){\\n            if(cont[n].find(pa) != cont[n].end()){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n\\n    int solve(int n, int pn, int pans){\\n        //cout <<\"root: \"<<n <<\" ans:\"<<pans << endl;\\n        int ans = 0;\\n        if(pans >= k){\\n            ans++;\\n        }\\n        visited[n] = 1;\\n        for(int i: adl[n]){\\n            if(visited[i] == -1){\\n                int pans_n = pans;\\n                if(cont[n].find(i) != cont[n].end()){\\n                    pans_n++;\\n                }\\n                if(cont[i].find(n) != cont[i].end()){\\n                    pans_n--;\\n                }\\n                \\n                ans += solve(i,n,pans_n);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        \\n        //number of nodes\\n        int n = edges.size() + 1;\\n        this->k = k;\\n        \\n        //make adjl\\n        adl = vector<vector<int>>(n,vector<int>());\\n        for(auto edge: edges){\\n            adl[edge[0]].push_back(edge[1]);\\n            adl[edge[1]].push_back(edge[0]);\\n        }\\n\\n        //make list of constraint\\n        cont = vector<unordered_set<int>>(n, unordered_set<int>());\\n        for(auto guess: guesses){\\n            cont[guess[1]].insert(guess[0]);\\n        }  \\n\\n        //check for stisfied edges at 0 root\\n        visited = vector<int>(n,-1);\\n        visited[0] = 1;\\n        int pa = check_edges(0,-1);\\n        //cout <<\"pa: \"<<pa << endl;\\n        //now solve one by one\\n        visited = vector<int>(n,-1);\\n        int ans = solve(0,-1, pa);  \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int ans;\\n    vector<vector<int>> adl;\\n    vector<int> visited;\\n    int k;\\n\\n    //possible children of node i\\n    vector<unordered_set<int>> cont;\\n\\n    //check edges\\n    int check_edges(int n, int pa){\\n        visited[n] = 1;\\n        int ans = 0;\\n        for(int i: adl[n]){\\n            if(visited[i] == -1){\\n                ans += check_edges(i,n);\\n            }\\n        }\\n        if(pa != -1){\\n            if(cont[n].find(pa) != cont[n].end()){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n\\n    int solve(int n, int pn, int pans){\\n        //cout <<\"root: \"<<n <<\" ans:\"<<pans << endl;\\n        int ans = 0;\\n        if(pans >= k){\\n            ans++;\\n        }\\n        visited[n] = 1;\\n        for(int i: adl[n]){\\n            if(visited[i] == -1){\\n                int pans_n = pans;\\n                if(cont[n].find(i) != cont[n].end()){\\n                    pans_n++;\\n                }\\n                if(cont[i].find(n) != cont[i].end()){\\n                    pans_n--;\\n                }\\n                \\n                ans += solve(i,n,pans_n);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        \\n        //number of nodes\\n        int n = edges.size() + 1;\\n        this->k = k;\\n        \\n        //make adjl\\n        adl = vector<vector<int>>(n,vector<int>());\\n        for(auto edge: edges){\\n            adl[edge[0]].push_back(edge[1]);\\n            adl[edge[1]].push_back(edge[0]);\\n        }\\n\\n        //make list of constraint\\n        cont = vector<unordered_set<int>>(n, unordered_set<int>());\\n        for(auto guess: guesses){\\n            cont[guess[1]].insert(guess[0]);\\n        }  \\n\\n        //check for stisfied edges at 0 root\\n        visited = vector<int>(n,-1);\\n        visited[0] = 1;\\n        int pa = check_edges(0,-1);\\n        //cout <<\"pa: \"<<pa << endl;\\n        //now solve one by one\\n        visited = vector<int>(n,-1);\\n        int ans = solve(0,-1, pa);  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3440348,
                "title": "single-pass-bfs",
                "content": "Lets say we do bfs from any node \\'u\\' and get this parent-child configuration:\\n\\n```\\nx <--- |      | ---> a\\ny <--- u ---> v ---> b\\nz <--- |      | ---> c\\n```\\nNow, let say we say bfs from a neighbour of \\'u\\', say \\'v\\' then notice that only u-v configuration reverses. Rest all parent-child relationship remains the same. \\n```\\nx <--- |      | ---> a\\ny <--- u <--- v ---> b\\nz <--- |      | ---> c\\n```\\nSo, Let say we do bfs once from node 0 to find all correct guesses when tree is rooted at 0. Now, if we do 2nd bfs to find number of correct guesses for tree rooted at every node, using the fact that a neighbors\\' parent-child relationship changes only for one edge (Hence, number of correct guesses at a neighbors\\' node can only increase or decrease by 1 or remain the same.)\\nSo, we can combine both this calculation in single bfs itself(by first assuming a hypothetical number of guesses are correct for node 0 as root, and later reducing the offset which will fix the correct number of guesses at node 0 from every node after the bfs is over)\\n\\nWe can have assume that hypothetical number to 0.(I assumed \\'n\\' in code below and also repurposed count array for visited array while doing bfs. Although, that could also be done with assuming 0 and using \\'n\\' as mark for unvisited nodes.)\\n```\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n = edges.size() + 1;\\n        unordered_set<string> us;\\n        for(vector<int> x: guesses) us.insert(to_string(x[0]) + \":\" + to_string(x[1]));\\n        vector<vector<int> > adj(n, vector<int>());\\n        for(vector<int> x: edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        vector<int> count(n, 0);\\n        int c = 0;\\n        int x;\\n        queue<int> q;\\n        q.push(0);\\n        count[0] = n;\\n        while(!q.empty()){\\n            x = q.front();\\n            q.pop();\\n            for(int d: adj[x]){\\n                if(count[d] == 0){\\n                    count[d] = count[x];\\n                    if(us.find(to_string(x) + \":\" + to_string(d)) != us.end()){\\n                        c++;\\n                        count[d] -= 1;\\n                    }\\n                    if(us.find(to_string(d) + \":\" + to_string(x)) != us.end()){\\n                        count[d] += 1;\\n                    }\\n                    q.push(d);\\n                }\\n            }\\n        }\\n        c -= n;\\n        int ans = 0;\\n        for(int i = 0; i < count.size(); i++){\\n            if(count[i] + c >= k) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nx <--- |      | ---> a\\ny <--- u ---> v ---> b\\nz <--- |      | ---> c\\n```\n```\\nx <--- |      | ---> a\\ny <--- u <--- v ---> b\\nz <--- |      | ---> c\\n```\n```\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n = edges.size() + 1;\\n        unordered_set<string> us;\\n        for(vector<int> x: guesses) us.insert(to_string(x[0]) + \":\" + to_string(x[1]));\\n        vector<vector<int> > adj(n, vector<int>());\\n        for(vector<int> x: edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        vector<int> count(n, 0);\\n        int c = 0;\\n        int x;\\n        queue<int> q;\\n        q.push(0);\\n        count[0] = n;\\n        while(!q.empty()){\\n            x = q.front();\\n            q.pop();\\n            for(int d: adj[x]){\\n                if(count[d] == 0){\\n                    count[d] = count[x];\\n                    if(us.find(to_string(x) + \":\" + to_string(d)) != us.end()){\\n                        c++;\\n                        count[d] -= 1;\\n                    }\\n                    if(us.find(to_string(d) + \":\" + to_string(x)) != us.end()){\\n                        count[d] += 1;\\n                    }\\n                    q.push(d);\\n                }\\n            }\\n        }\\n        c -= n;\\n        int ans = 0;\\n        for(int i = 0; i < count.size(); i++){\\n            if(count[i] + c >= k) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429509,
                "title": "c-python-dp",
                "content": "For each node as parent node check if we can form a tree with at least k edges in guesses.\\nWe can use dp to optimize this as for every pair of nodes we only have 2 combinations i.e. (node,nei) and (nei,node)  both going in reverse direction. \\nTime Complexity: O(N) \\nC++ :\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> memo;\\n    int dp(int node,int par,vector<vector<int>> &graph,set<pair<int,int>> &seen){\\n        if (memo.find(make_pair(node,par))!=memo.end()) return memo[make_pair(node,par)];\\n        int val=0;\\n        if (seen.find(make_pair(par,node))!=seen.end()) val++;\\n        for (auto &nei: graph[node]){\\n            if (nei==par) continue;\\n            val+=dp(nei,node,graph,seen);\\n        }\\n        return memo[make_pair(node,par)]=val;\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n=edges.size()+1;\\n        vector<vector<int>> graph(n);\\n        for (auto &v:edges) {\\n            graph[v[0]].push_back(v[1]);\\n            graph[v[1]].push_back(v[0]);\\n        }\\n        set<pair<int,int>> seen;\\n        for (auto &v: guesses) seen.insert(make_pair(v[0],v[1]));\\n        int gg,ans=0;\\n        for (int i=0;i<n;i++) {\\n            gg=dp(i,-1,graph,seen);\\n            if (gg>=k) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPython : \\n\\n```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        #n edges from 0 to n-1\\n        n=len(edges)+1\\n        graph=defaultdict(list)\\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        seen=set([(a,b) for a,b in guesses])\\n        @cache\\n        def dp(node,par):\\n            val=1 if (par,node) in seen else 0\\n            for nei in graph[node]:\\n                if nei==par: continue\\n                val+=dp(nei,node)\\n            return val\\n        ans=0\\n        for i in range(n):\\n            gg=dp(i,-1)\\n            if gg>=k: ans+=1\\n        return ans\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> memo;\\n    int dp(int node,int par,vector<vector<int>> &graph,set<pair<int,int>> &seen){\\n        if (memo.find(make_pair(node,par))!=memo.end()) return memo[make_pair(node,par)];\\n        int val=0;\\n        if (seen.find(make_pair(par,node))!=seen.end()) val++;\\n        for (auto &nei: graph[node]){\\n            if (nei==par) continue;\\n            val+=dp(nei,node,graph,seen);\\n        }\\n        return memo[make_pair(node,par)]=val;\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n=edges.size()+1;\\n        vector<vector<int>> graph(n);\\n        for (auto &v:edges) {\\n            graph[v[0]].push_back(v[1]);\\n            graph[v[1]].push_back(v[0]);\\n        }\\n        set<pair<int,int>> seen;\\n        for (auto &v: guesses) seen.insert(make_pair(v[0],v[1]));\\n        int gg,ans=0;\\n        for (int i=0;i<n;i++) {\\n            gg=dp(i,-1,graph,seen);\\n            if (gg>=k) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        #n edges from 0 to n-1\\n        n=len(edges)+1\\n        graph=defaultdict(list)\\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        seen=set([(a,b) for a,b in guesses])\\n        @cache\\n        def dp(node,par):\\n            val=1 if (par,node) in seen else 0\\n            for nei in graph[node]:\\n                if nei==par: continue\\n                val+=dp(nei,node)\\n            return val\\n        ans=0\\n        for i in range(n):\\n            gg=dp(i,-1)\\n            if gg>=k: ans+=1\\n        return ans\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339186,
                "title": "c-two-dfs-with-counters-for-correctness-incorrectness",
                "content": "```\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        const int N = edges.size() + 1;\\n        vector<vector<int>> graph(N);\\n        for (auto& edge : edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        set<pair<int, int>> guesses_set;\\n        for (auto& g : guesses) {\\n            guesses_set.emplace(g[0], g[1]);\\n        }\\n        \\n        int correct = 0, incorrect = 0;\\n        init(graph, guesses_set, correct, incorrect);\\n        //cout << correct << \" \" << incorrect << endl;\\n        return dfs(graph, guesses_set, correct, incorrect, k);\\n    }\\n    \\n    int dfs(const vector<vector<int>>& graph, const set<pair<int, int>>& guesses, int correct, int incorrect, int k, int start = 0, int parent = -1) {\\n        int ret = (correct >= k);\\n        \\n        for (auto next : graph[start]) {\\n            if (next == parent) continue;\\n            \\n            int next_correct = correct;\\n            int next_incorrect = incorrect;\\n            \\n            if (guesses.count(make_pair(start, next))) {\\n                --next_correct;\\n                ++next_incorrect;\\n            }\\n            if (guesses.count(make_pair(next, start))) {\\n                --next_incorrect;\\n                ++next_correct;\\n            }\\n            \\n            ret += dfs(graph, guesses, next_correct, next_incorrect, k, next, start);\\n        }\\n        \\n        //cout << start << \": \" << ret << endl;\\n        return ret;\\n    }\\n    \\n    void init(const vector<vector<int>>& graph, const set<pair<int, int>>& guesses, int& correct, int& incorrect, int start = 0, int parent = -1) {\\n        for (auto next : graph[start]) {\\n            if (next == parent) continue;\\n            \\n            if (guesses.count(make_pair(start, next))) {\\n                ++correct;\\n            }\\n            if (guesses.count(make_pair(next, start))) {\\n                ++incorrect;\\n            }\\n            \\n            init(graph, guesses, correct, incorrect, next, start);\\n        }\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        const int N = edges.size() + 1;\\n        vector<vector<int>> graph(N);\\n        for (auto& edge : edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        set<pair<int, int>> guesses_set;\\n        for (auto& g : guesses) {\\n            guesses_set.emplace(g[0], g[1]);\\n        }\\n        \\n        int correct = 0, incorrect = 0;\\n        init(graph, guesses_set, correct, incorrect);\\n        //cout << correct << \" \" << incorrect << endl;\\n        return dfs(graph, guesses_set, correct, incorrect, k);\\n    }\\n    \\n    int dfs(const vector<vector<int>>& graph, const set<pair<int, int>>& guesses, int correct, int incorrect, int k, int start = 0, int parent = -1) {\\n        int ret = (correct >= k);\\n        \\n        for (auto next : graph[start]) {\\n            if (next == parent) continue;\\n            \\n            int next_correct = correct;\\n            int next_incorrect = incorrect;\\n            \\n            if (guesses.count(make_pair(start, next))) {\\n                --next_correct;\\n                ++next_incorrect;\\n            }\\n            if (guesses.count(make_pair(next, start))) {\\n                --next_incorrect;\\n                ++next_correct;\\n            }\\n            \\n            ret += dfs(graph, guesses, next_correct, next_incorrect, k, next, start);\\n        }\\n        \\n        //cout << start << \": \" << ret << endl;\\n        return ret;\\n    }\\n    \\n    void init(const vector<vector<int>>& graph, const set<pair<int, int>>& guesses, int& correct, int& incorrect, int start = 0, int parent = -1) {\\n        for (auto next : graph[start]) {\\n            if (next == parent) continue;\\n            \\n            if (guesses.count(make_pair(start, next))) {\\n                ++correct;\\n            }\\n            if (guesses.count(make_pair(next, start))) {\\n                ++incorrect;\\n            }\\n            \\n            init(graph, guesses, correct, incorrect, next, start);\\n        }\\n    } \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3323049,
                "title": "c-solution",
                "content": "```\\nbool CG (int* nums, int numsSize, int k){\\n    for (int i = 0 ; i < numsSize ; i++){\\n        if (nums[i] == k){\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n\\nvoid check (int** can_to, int* can_to_count, int** Guess, int* Guess_count, int from, int now, int* correct){\\n    for (int i = 0 ; i < can_to_count[now] ; i++){\\n        if (can_to[now][i] == from){\\n            i++;\\n            while (i < can_to_count[now]){\\n                if (CG(Guess[now], Guess_count[now], can_to[now][i])){\\n                    *correct += 1;\\n                }\\n                check (can_to, can_to_count, Guess, Guess_count, now, can_to[now][i], correct);\\n                i++;\\n            }\\n        } else {\\n            if (CG(Guess[now], Guess_count[now], can_to[now][i])){\\n                *correct += 1;\\n            }\\n            check (can_to, can_to_count, Guess, Guess_count, now, can_to[now][i], correct);\\n        }\\n    }\\n}\\n\\nvoid change_root (int** can_to, int* can_to_count, int** Guess, int* Guess_count, int from, int now, int correct, int* ans){\\n    for (int i = 0 ; i < can_to_count[now] ; i++){\\n        if (can_to[now][i] == from){\\n            continue;\\n        }\\n        int count = correct;\\n        if (CG(Guess[now], Guess_count[now], can_to[now][i])){\\n            count--;\\n        }\\n        if (CG(Guess[can_to[now][i]], Guess_count[can_to[now][i]], now)){\\n            count++;\\n        }\\n        if (count >= 0){\\n            *ans += 1;\\n        }\\n        change_root (can_to, can_to_count, Guess, Guess_count, now, can_to[now][i], count, ans);\\n    }\\n}\\n\\nint rootCount(int** edges, int edgesSize, int* edgesColSize, int** guesses, int guessesSize, int* guessesColSize, int k){\\n    int m = edgesSize+1;\\n    \\n    int** can_to = malloc(sizeof(int*)*m);\\n    int* can_to_count = calloc(m, sizeof(int));\\n    \\n    int** Guess = malloc(sizeof(int*)*m);\\n    int* Guess_count = calloc(m, sizeof(int));\\n    \\n    //\\u6B64\\u8655\\u662F\\u70BA\\u4E86\\u7BC0\\u7701\\u8A18\\u61B6\\u9AD4\\u7A7A\\u9593\\u624D\\u9019\\u6A23\\u8A2D\\u8A08 \\u5982\\u679C\\u5C07 Guess \\u6539\\u6210\\u4E00\\u500B m*m \\u5927\\u5C0F\\u7684 bool \\u76F4\\u63A5\\u641C\\u5C0B\\u4E0B\\u4F86\\u53EF\\u4EE5\\u66F4\\u52A0\\u5FEB\\u901F \\u5C31\\u4E0D\\u7528 CG \\u51FD\\u5F0F \\u4E5F\\u4E0D\\u6015\\u4E00\\u500B\\u9EDE\\u9023\\u63A5\\u8D85\\u904E20\\u500B\\u9EDE\\n    \\n    for (int i = 0 ; i < m ; i++){\\n        can_to[i] = malloc(sizeof(int)*20);\\n        Guess[i] = malloc(sizeof(int)*20);\\n    }\\n    \\n    for (int i = 0 ; i < edgesSize ; i++){\\n        can_to[edges[i][0]][can_to_count[edges[i][0]]] = edges[i][1];\\n        can_to_count[edges[i][0]]++;\\n        can_to[edges[i][1]][can_to_count[edges[i][1]]] = edges[i][0];\\n        can_to_count[edges[i][1]]++;\\n    }\\n    for (int i = 0 ; i < guessesSize ; i++){\\n        Guess[guesses[i][0]][Guess_count[guesses[i][0]]] = guesses[i][1];\\n        Guess_count[guesses[i][0]]++;\\n    }\\n    \\n    int correct = 0;\\n    int ans = 0;\\n    \\n    for (int i = 0 ; i < can_to_count[0] ; i++){\\n        if (CG(Guess[0], Guess_count[0], can_to[0][i])){\\n            correct += 1;\\n        }\\n        check (can_to, can_to_count, Guess, Guess_count, 0, can_to[0][i], &correct);\\n    }\\n    \\n    correct -= k;\\n        \\n    if (correct >= 0){\\n        ans++;\\n    }\\n    \\n   change_root (can_to, can_to_count, Guess, Guess_count, -1, 0, correct, &ans);\\n    \\n    free(can_to_count);\\n    free(Guess_count);\\n    for (int i = 0 ; i < m ; i++){\\n        free(can_to[i]);\\n        free(Guess[i]);\\n    }\\n    free(can_to);\\n    free(Guess);\\n    \\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool CG (int* nums, int numsSize, int k){\\n    for (int i = 0 ; i < numsSize ; i++){\\n        if (nums[i] == k){\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n\\nvoid check (int** can_to, int* can_to_count, int** Guess, int* Guess_count, int from, int now, int* correct){\\n    for (int i = 0 ; i < can_to_count[now] ; i++){\\n        if (can_to[now][i] == from){\\n            i++;\\n            while (i < can_to_count[now]){\\n                if (CG(Guess[now], Guess_count[now], can_to[now][i])){\\n                    *correct += 1;\\n                }\\n                check (can_to, can_to_count, Guess, Guess_count, now, can_to[now][i], correct);\\n                i++;\\n            }\\n        } else {\\n            if (CG(Guess[now], Guess_count[now], can_to[now][i])){\\n                *correct += 1;\\n            }\\n            check (can_to, can_to_count, Guess, Guess_count, now, can_to[now][i], correct);\\n        }\\n    }\\n}\\n\\nvoid change_root (int** can_to, int* can_to_count, int** Guess, int* Guess_count, int from, int now, int correct, int* ans){\\n    for (int i = 0 ; i < can_to_count[now] ; i++){\\n        if (can_to[now][i] == from){\\n            continue;\\n        }\\n        int count = correct;\\n        if (CG(Guess[now], Guess_count[now], can_to[now][i])){\\n            count--;\\n        }\\n        if (CG(Guess[can_to[now][i]], Guess_count[can_to[now][i]], now)){\\n            count++;\\n        }\\n        if (count >= 0){\\n            *ans += 1;\\n        }\\n        change_root (can_to, can_to_count, Guess, Guess_count, now, can_to[now][i], count, ans);\\n    }\\n}\\n\\nint rootCount(int** edges, int edgesSize, int* edgesColSize, int** guesses, int guessesSize, int* guessesColSize, int k){\\n    int m = edgesSize+1;\\n    \\n    int** can_to = malloc(sizeof(int*)*m);\\n    int* can_to_count = calloc(m, sizeof(int));\\n    \\n    int** Guess = malloc(sizeof(int*)*m);\\n    int* Guess_count = calloc(m, sizeof(int));\\n    \\n    //\\u6B64\\u8655\\u662F\\u70BA\\u4E86\\u7BC0\\u7701\\u8A18\\u61B6\\u9AD4\\u7A7A\\u9593\\u624D\\u9019\\u6A23\\u8A2D\\u8A08 \\u5982\\u679C\\u5C07 Guess \\u6539\\u6210\\u4E00\\u500B m*m \\u5927\\u5C0F\\u7684 bool \\u76F4\\u63A5\\u641C\\u5C0B\\u4E0B\\u4F86\\u53EF\\u4EE5\\u66F4\\u52A0\\u5FEB\\u901F \\u5C31\\u4E0D\\u7528 CG \\u51FD\\u5F0F \\u4E5F\\u4E0D\\u6015\\u4E00\\u500B\\u9EDE\\u9023\\u63A5\\u8D85\\u904E20\\u500B\\u9EDE\\n    \\n    for (int i = 0 ; i < m ; i++){\\n        can_to[i] = malloc(sizeof(int)*20);\\n        Guess[i] = malloc(sizeof(int)*20);\\n    }\\n    \\n    for (int i = 0 ; i < edgesSize ; i++){\\n        can_to[edges[i][0]][can_to_count[edges[i][0]]] = edges[i][1];\\n        can_to_count[edges[i][0]]++;\\n        can_to[edges[i][1]][can_to_count[edges[i][1]]] = edges[i][0];\\n        can_to_count[edges[i][1]]++;\\n    }\\n    for (int i = 0 ; i < guessesSize ; i++){\\n        Guess[guesses[i][0]][Guess_count[guesses[i][0]]] = guesses[i][1];\\n        Guess_count[guesses[i][0]]++;\\n    }\\n    \\n    int correct = 0;\\n    int ans = 0;\\n    \\n    for (int i = 0 ; i < can_to_count[0] ; i++){\\n        if (CG(Guess[0], Guess_count[0], can_to[0][i])){\\n            correct += 1;\\n        }\\n        check (can_to, can_to_count, Guess, Guess_count, 0, can_to[0][i], &correct);\\n    }\\n    \\n    correct -= k;\\n        \\n    if (correct >= 0){\\n        ans++;\\n    }\\n    \\n   change_root (can_to, can_to_count, Guess, Guess_count, -1, 0, correct, &ans);\\n    \\n    free(can_to_count);\\n    free(Guess_count);\\n    for (int i = 0 ; i < m ; i++){\\n        free(can_to[i]);\\n        free(Guess[i]);\\n    }\\n    free(can_to);\\n    free(Guess);\\n    \\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3307317,
                "title": "c-dfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n     map<pair<int,int>,bool> mp;\\n    //count ans for 0;\\n    int get_ans(vector<vector<int>>&g,int node,vector<bool> &vis)\\n    {\\n        vis[node]=1;\\n        int ans=0;\\n        for(auto &x:g[node])\\n        {\\n            if(!vis[x])\\n            {\\n                ans+=(mp.count({node,x})+get_ans(g,x,vis));\\n            }\\n        }\\n        return ans;\\n    }\\n    int res=0;\\n    void dfs(vector<vector<int>> &g,int ans,int node,int k,vector<bool> &vis)\\n    {\\n        if(ans>=k)\\n            res++;\\n        vis[node]=1;\\n        for(auto &x:g[node])\\n        {\\n            if(!vis[x])\\n            {\\n                dfs(g,ans-mp.count({node,x})+mp.count({x,node}),x,k,vis);\\n            }\\n        }\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k)\\n    {\\n        int n=edges.size()+1;\\n        vector<vector<int>> g(n,vector<int>());\\n        for(auto &e:edges)\\n        {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        for(auto gs:guesses)\\n        {\\n            mp[{gs[0],gs[1]}]=1;\\n        }\\n        vector<bool> vis(n,0);\\n        int ans=get_ans(g,0,vis);\\n        fill(vis.begin(),vis.end(),0);\\n        dfs(g,ans,0,k,vis);\\n        return res;  \\n    }\\n};\\n```\\nIf you like the solution plz upvote.\\n=\\n",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     map<pair<int,int>,bool> mp;\\n    //count ans for 0;\\n    int get_ans(vector<vector<int>>&g,int node,vector<bool> &vis)\\n    {\\n        vis[node]=1;\\n        int ans=0;\\n        for(auto &x:g[node])\\n        {\\n            if(!vis[x])\\n            {\\n                ans+=(mp.count({node,x})+get_ans(g,x,vis));\\n            }\\n        }\\n        return ans;\\n    }\\n    int res=0;\\n    void dfs(vector<vector<int>> &g,int ans,int node,int k,vector<bool> &vis)\\n    {\\n        if(ans>=k)\\n            res++;\\n        vis[node]=1;\\n        for(auto &x:g[node])\\n        {\\n            if(!vis[x])\\n            {\\n                dfs(g,ans-mp.count({node,x})+mp.count({x,node}),x,k,vis);\\n            }\\n        }\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k)\\n    {\\n        int n=edges.size()+1;\\n        vector<vector<int>> g(n,vector<int>());\\n        for(auto &e:edges)\\n        {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        for(auto gs:guesses)\\n        {\\n            mp[{gs[0],gs[1]}]=1;\\n        }\\n        vector<bool> vis(n,0);\\n        int ans=get_ans(g,0,vis);\\n        fill(vis.begin(),vis.end(),0);\\n        dfs(g,ans,0,k,vis);\\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273138,
                "title": "easy-detail-explained-o-n-java-solution-using-dfs-only",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\n--> First assume that node 0 is the root of the tree. Let say we say it global tree\\n--> then do a travesal and for every node find count of actual correct guesses made by bob.\\n    --> Question is how to find the actual correct guesses made for a particular node? Let say we are at node x.\\n    -->suppose that we make the node as x root , now see how count of correct guesses changes wrt global tree\\n    --> All the subtree nodes of x does not change wrt global tree. So the number of correct guesses for subtree of x remains unchanged\\n    --> For all nodes not on the path from 0 to x, the number of correct guesses remains unchanged for these nodes\\n    --> now the correct guesses for path from 0 to x becomes false and the incorrect guesses for this path becomes correct wrt global tree. \\n    --> so count of correct guesses for x = (total count of correct guesses in global tree)  - \\n        (count of correct guesses for the path in global tree) + (count of incorrect guesses for the path in global tree)\\n--> then our answer is the count of nodes whose count of correct guesses>=k\\n\\n```\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(h + guesses.length)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\\n        int n = edges.length + 1;\\n        tree = new ArrayList[n];\\n        for(int i=0;i<n;i++)tree[i] = new ArrayList<>();\\n        for(int[] x : edges){\\n            tree[x[0]].add(x[1]);\\n            tree[x[1]].add(x[0]);\\n        }\\n        set = new HashSet<>();\\n        for(int [] x: guesses){\\n            set.add(x[0]+\" \"+x[1]);\\n        }\\n        int total = dfs1(0,-1);\\n        return dfs2(0,-1,k,total,0,0);\\n\\n    }\\n    List<Integer> [] tree;\\n    Set<String> set;\\n    private int dfs2(int x, int p, int k, int total,int ancTrue,int ancFalse){\\n        if(set.contains(p+\" \"+x))ancTrue++;\\n        if(set.contains(x+\" \"+p))ancFalse++;\\n        int curr = total - ancTrue + ancFalse;\\n        int ans = 0;\\n        if(curr >=k)ans++;\\n        for(int y : tree[x])\\n            if(y!=p)\\n                ans += dfs2(y,x,k,total,ancTrue,ancFalse);\\n        return ans;\\n\\n\\n    }\\n    private int dfs1(int x, int p){\\n        int ans = 0;\\n        if(set.contains(p+\" \"+x))ans++;\\n        for(int y : tree[x])\\n            if(y!=p)ans += dfs1(y,x);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n--> First assume that node 0 is the root of the tree. Let say we say it global tree\\n--> then do a travesal and for every node find count of actual correct guesses made by bob.\\n    --> Question is how to find the actual correct guesses made for a particular node? Let say we are at node x.\\n    -->suppose that we make the node as x root , now see how count of correct guesses changes wrt global tree\\n    --> All the subtree nodes of x does not change wrt global tree. So the number of correct guesses for subtree of x remains unchanged\\n    --> For all nodes not on the path from 0 to x, the number of correct guesses remains unchanged for these nodes\\n    --> now the correct guesses for path from 0 to x becomes false and the incorrect guesses for this path becomes correct wrt global tree. \\n    --> so count of correct guesses for x = (total count of correct guesses in global tree)  - \\n        (count of correct guesses for the path in global tree) + (count of incorrect guesses for the path in global tree)\\n--> then our answer is the count of nodes whose count of correct guesses>=k\\n\\n```\n```\\nclass Solution {\\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\\n        int n = edges.length + 1;\\n        tree = new ArrayList[n];\\n        for(int i=0;i<n;i++)tree[i] = new ArrayList<>();\\n        for(int[] x : edges){\\n            tree[x[0]].add(x[1]);\\n            tree[x[1]].add(x[0]);\\n        }\\n        set = new HashSet<>();\\n        for(int [] x: guesses){\\n            set.add(x[0]+\" \"+x[1]);\\n        }\\n        int total = dfs1(0,-1);\\n        return dfs2(0,-1,k,total,0,0);\\n\\n    }\\n    List<Integer> [] tree;\\n    Set<String> set;\\n    private int dfs2(int x, int p, int k, int total,int ancTrue,int ancFalse){\\n        if(set.contains(p+\" \"+x))ancTrue++;\\n        if(set.contains(x+\" \"+p))ancFalse++;\\n        int curr = total - ancTrue + ancFalse;\\n        int ans = 0;\\n        if(curr >=k)ans++;\\n        for(int y : tree[x])\\n            if(y!=p)\\n                ans += dfs2(y,x,k,total,ancTrue,ancFalse);\\n        return ans;\\n\\n\\n    }\\n    private int dfs1(int x, int p){\\n        int ans = 0;\\n        if(set.contains(p+\" \"+x))ans++;\\n        for(int y : tree[x])\\n            if(y!=p)ans += dfs1(y,x);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272727,
                "title": "c-approach-explained-recursion",
                "content": "# Intuition\\nWhats the naivest way possible to solve the problem. We can run dfs rooting each node and validating if the number of parent child relationship satrified in the call is >= k. \\nThe problem is seriously this simple and now the only thing left to see is memoisation. This is the reason for problem been tagged as hard. \\n\\n# Approach\\nWhy and how will memoisation (DP) work over here. Lets picture it out this way. Consider a subtree and we can store the number of guesses this subtree will satisy. \\nThe only problem appears is when we root the tree at child in this subtree, because all the relations gets reversed considering this subtree. That is why we use dp and store everything as parent child.    \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        \\n        vector<int>graph[edges.size()+1] ; \\n        map<pair<int,int>,int>w; \\n        for(auto E : edges){\\n            graph[E[0]].push_back(E[1]); \\n            graph[E[1]].push_back(E[0]);\\n        }\\n        for(auto E : guesses){\\n            w[{E[0],E[1]}] = 1 ;\\n        }\\n\\n        map<pair<int,int>,int>dp ; \\n        function<int(int,int)>dfs = [&](int node,int par){\\n            if(dp.count({par,node})) return dp[{par,node}] ;\\n            int cur_guess = 0 ; \\n            for(auto x : graph[node]){\\n                if(x == par) continue ; \\n                cur_guess += w[{node,x}] + dfs(x, node); \\n            }\\n            return dp[{par,node}] = cur_guess ; \\n        };\\n\\n        int ans = 0 ; \\n        for(int i = 0 ; i < edges.size()+1 ; i++){\\n            ans += (dfs(i,-1) >= k) ;\\n        }\\n        return ans ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        \\n        vector<int>graph[edges.size()+1] ; \\n        map<pair<int,int>,int>w; \\n        for(auto E : edges){\\n            graph[E[0]].push_back(E[1]); \\n            graph[E[1]].push_back(E[0]);\\n        }\\n        for(auto E : guesses){\\n            w[{E[0],E[1]}] = 1 ;\\n        }\\n\\n        map<pair<int,int>,int>dp ; \\n        function<int(int,int)>dfs = [&](int node,int par){\\n            if(dp.count({par,node})) return dp[{par,node}] ;\\n            int cur_guess = 0 ; \\n            for(auto x : graph[node]){\\n                if(x == par) continue ; \\n                cur_guess += w[{node,x}] + dfs(x, node); \\n            }\\n            return dp[{par,node}] = cur_guess ; \\n        };\\n\\n        int ans = 0 ; \\n        for(int i = 0 ; i < edges.size()+1 ; i++){\\n            ans += (dfs(i,-1) >= k) ;\\n        }\\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271199,
                "title": "brute-force-memoization-o-n-2-o-n",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDo Brute-force and memoized the state of (parent, node). Also, for guessess, use set for better searching if current state is present in guesses vector or not.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> dp;\\n    unordered_set<string> st;\\n\\n    int dfs(int s, int p, vector<int> graph[]){\\n        string state = to_string(p) + \"#\" + to_string(s); // (state of {parent, node})\\n        if(dp.count(state)) return dp[state];\\n        int ans = 0;\\n        if(st.find(state) != st.end()) ans++;\\n        for(auto i: graph[s]){\\n            if(i == p) continue;\\n            ans += dfs(i, s, graph);\\n        }\\n        return dp[state] = ans;\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n = edges.size() + 1;\\n        vector<int> graph[n];\\n        for(auto it: edges){\\n            graph[it[0]].push_back(it[1]);\\n            graph[it[1]].push_back(it[0]);\\n        }\\n        for(auto i: guesses){\\n            string state = to_string(i[0]) + \"#\" + to_string(i[1]);\\n            st.insert(state);\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if(dfs(i, -1, graph) >= k) ans++; // if it returns value >= k, it can be our possible root hence ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> dp;\\n    unordered_set<string> st;\\n\\n    int dfs(int s, int p, vector<int> graph[]){\\n        string state = to_string(p) + \"#\" + to_string(s); // (state of {parent, node})\\n        if(dp.count(state)) return dp[state];\\n        int ans = 0;\\n        if(st.find(state) != st.end()) ans++;\\n        for(auto i: graph[s]){\\n            if(i == p) continue;\\n            ans += dfs(i, s, graph);\\n        }\\n        return dp[state] = ans;\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n = edges.size() + 1;\\n        vector<int> graph[n];\\n        for(auto it: edges){\\n            graph[it[0]].push_back(it[1]);\\n            graph[it[1]].push_back(it[0]);\\n        }\\n        for(auto i: guesses){\\n            string state = to_string(i[0]) + \"#\" + to_string(i[1]);\\n            st.insert(state);\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if(dfs(i, -1, graph) >= k) ans++; // if it returns value >= k, it can be our possible root hence ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270788,
                "title": "intuitive-racket-solution",
                "content": "# Intuition\\n\\nFor each node `i` as root, we count the number of correct guesses and see if it is at least `k`.\\n\\n# Approach\\n\\nThe intuition is simple, and looks like $O(n * g)$ complexity.\\nThe trick is the number of edges is `n-1`, we can cache\\nthe count procedure to get linear complexity. See the code.\\n\\n# Complexity\\n- Time complexity: $O(n + g)$\\n\\n- Space complexity: $O(n + g)$\\n\\n# Code\\n```\\n(define (root-count edges guesses k)\\n  (define n (add1 (length edges)))\\n\\n  (define adj-of\\n    (let ([adjs (make-vector n \\'())])\\n      (for ([e edges])\\n        (aupd! adjs (first e) (\\u03BB (old) (cons (second e) old)))\\n        (aupd! adjs (second e) (\\u03BB (old) (cons (first e) old))))\\n      (\\u03BB (i) (aref adjs i))))\\n\\n  (define in-guesses?\\n    (let ([guesses-set (list->set guesses)])\\n      (\\u03BB (edge) (set-member? guesses-set edge))))\\n\\n  (define (correct-count root from)\\n    (for/sum ([a (adj-of root)]\\n              #:when (not (= a from)))\\n      (cond [(in-guesses? (list root a))\\n             (add1 (correct-count a root))]\\n            [else\\n             (correct-count a root)])))\\n\\n  (cachef! correct-count)\\n\\n  (for/sum ([i n])\\n    (if (>= (correct-count i -1) k)\\n        1\\n        0)))\\n\\n(define-syntax-rule (aupd! arr dims ... fn)\\n  (aset! arr dims ... (fn (aref arr dims ...))))\\n\\n(define-syntax aset!\\n  (syntax-rules ()\\n    [(_ arr i v)\\n     (vector-set! arr i v)]\\n    [(_ arr i args ... v)\\n     (aset! (vector-ref arr i) args ... v)]))\\n\\n(define-syntax aref\\n  (syntax-rules ()\\n    [(_ arr) arr]\\n    [(_ arr i args ...)\\n     (aref (vector-ref arr i) args ...)]))\\n\\n(define (cachef-hash fn)\\n  (let ([cache (make-hash)])\\n    (lambda args\\n      (when (not (hash-has-key? cache args))\\n        (hash-set! cache args (apply fn args)))\\n      (hash-ref cache args))))\\n\\n(define-syntax-rule (cachef! fn)\\n  (set! fn (cachef-hash fn)))\\n\\n```",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```\\n(define (root-count edges guesses k)\\n  (define n (add1 (length edges)))\\n\\n  (define adj-of\\n    (let ([adjs (make-vector n \\'())])\\n      (for ([e edges])\\n        (aupd! adjs (first e) (\\u03BB (old) (cons (second e) old)))\\n        (aupd! adjs (second e) (\\u03BB (old) (cons (first e) old))))\\n      (\\u03BB (i) (aref adjs i))))\\n\\n  (define in-guesses?\\n    (let ([guesses-set (list->set guesses)])\\n      (\\u03BB (edge) (set-member? guesses-set edge))))\\n\\n  (define (correct-count root from)\\n    (for/sum ([a (adj-of root)]\\n              #:when (not (= a from)))\\n      (cond [(in-guesses? (list root a))\\n             (add1 (correct-count a root))]\\n            [else\\n             (correct-count a root)])))\\n\\n  (cachef! correct-count)\\n\\n  (for/sum ([i n])\\n    (if (>= (correct-count i -1) k)\\n        1\\n        0)))\\n\\n(define-syntax-rule (aupd! arr dims ... fn)\\n  (aset! arr dims ... (fn (aref arr dims ...))))\\n\\n(define-syntax aset!\\n  (syntax-rules ()\\n    [(_ arr i v)\\n     (vector-set! arr i v)]\\n    [(_ arr i args ... v)\\n     (aset! (vector-ref arr i) args ... v)]))\\n\\n(define-syntax aref\\n  (syntax-rules ()\\n    [(_ arr) arr]\\n    [(_ arr i args ...)\\n     (aref (vector-ref arr i) args ...)]))\\n\\n(define (cachef-hash fn)\\n  (let ([cache (make-hash)])\\n    (lambda args\\n      (when (not (hash-has-key? cache args))\\n        (hash-set! cache args (apply fn args)))\\n      (hash-ref cache args))))\\n\\n(define-syntax-rule (cachef! fn)\\n  (set! fn (cachef-hash fn)))\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3270368,
                "title": "the-art-of-dynamic-programming",
                "content": "DFS + Memo for each i<sup>th</sup> root node candidate.\\n\\n1. create an adjacency list `adj` from each edge `u`,`v` of the input `E`\\n2. create a set of `u`,`v` edges we `need` from the input array `A` of guesses\\n3. increment the count `cnt` whenever the tree contains an edge we `need`\\n\\nAs the recursive stack unwinds, we accumulate the count `cnt` of edges we `need` and determine if each i<sup>th</sup> root node candidate has count `cnt` greater-than-or-equal to input threshold `T`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun rootCount(E: Array<IntArray>, A: Array<IntArray>, T: Int): Int {\\n        var N = E.size + 1\\n        var adj = Array(N){ mutableListOf<Int>() }\\n        for ((u, v) in E) {\\n            adj[u].add(v)\\n            adj[v].add(u)\\n        }\\n        var key = { u: Int, v: Int -> \"$u,$v\" }\\n        var need = mutableListOf<String>()\\n        for ((u, v) in A)\\n            need.add(key(u, v))\\n        var m = mutableMapOf<String, Int>()\\n        fun go(node: Int, last: Int = -1): Int {\\n            var k = key(last, node)\\n            if (!m.contains(k)) {\\n                var cnt = if (need.contains(k)) 1 else 0\\n                for (next in adj[node])\\n                    if (next != last)\\n                        cnt += go(next, node)\\n                m[k] = cnt\\n            }\\n            return m[k]!!\\n        }\\n        return IntArray(N){ it }.filter{ T <= go(it) }.size\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet rootCount = (E, A, T, N = E.length + 1, m = new Map()) => {\\n    let adj = new Map([...Array(N).keys()].map(i => [i, []]));\\n    for (let [u, v] of E) {\\n        adj.get(u).push(v);\\n        adj.get(v).push(u);\\n    }\\n    let key = (u, v) => `${u},${v}`;\\n    let need = new Set([...A].map(([u, v]) => key(u, v)));\\n    let go = (node, last = -1) => {\\n        let k = key(last, node);\\n        if (!m.has(k)) {\\n            let cnt = Number(need.has(k));\\n            for (let next of adj.get(node))\\n                if (next != last)\\n                    cnt += go(next, node);\\n            m.set(k, cnt);\\n        }\\n        return m.get(k);\\n    };\\n    return [...Array(N).keys()].filter(i => T <= go(i)).length;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def rootCount(self, E: List[List[int]], A: List[List[int]], T: int) -> int:\\n        adj = defaultdict(list)\\n        for u, v in E:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        need = set([(u, v) for u, v in A])\\n        @cache\\n        def go(node, last = -1):\\n            cnt = (last, node) in need\\n            for next in adj[node]:\\n                if next != last:\\n                    cnt += go(next, node)\\n            return cnt\\n        return len([i for i in range(len(E) + 1) if T <= go(i)])\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Adj = unordered_map<int, VI>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    using Need = unordered_set<string>;\\n    int rootCount(VVI& E, VVI& A, int T, Adj adj = {}, Need need = {}, Map m = {}, int cnt = 0) {\\n        for (auto& edge: E) {\\n            auto [u, v] = tie(edge[0], edge[1]);\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        auto key = [](auto u, auto v) {\\n            stringstream ss; ss << u << \",\" << v;\\n            return ss.str();\\n        };\\n        for (auto& edge: A) {\\n            auto [u, v] = tie(edge[0], edge[1]);\\n            need.insert(key(u, v));\\n        }\\n        fun go = [&](auto node, auto last) {\\n            auto k = key(last, node);\\n            if (m.find(k) == m.end()) {\\n                int cnt = need.find(k) != need.end();\\n                for (auto next: adj[node])\\n                    if (next != last)\\n                        cnt += go(next, node);\\n                m[k] = cnt;\\n            }\\n            return m[k];\\n        };\\n        for (auto i{ 0 }; i < E.size() + 1; ++i)\\n            cnt += T <= go(i, -1);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun rootCount(E: Array<IntArray>, A: Array<IntArray>, T: Int): Int {\\n        var N = E.size + 1\\n        var adj = Array(N){ mutableListOf<Int>() }\\n        for ((u, v) in E) {\\n            adj[u].add(v)\\n            adj[v].add(u)\\n        }\\n        var key = { u: Int, v: Int -> \"$u,$v\" }\\n        var need = mutableListOf<String>()\\n        for ((u, v) in A)\\n            need.add(key(u, v))\\n        var m = mutableMapOf<String, Int>()\\n        fun go(node: Int, last: Int = -1): Int {\\n            var k = key(last, node)\\n            if (!m.contains(k)) {\\n                var cnt = if (need.contains(k)) 1 else 0\\n                for (next in adj[node])\\n                    if (next != last)\\n                        cnt += go(next, node)\\n                m[k] = cnt\\n            }\\n            return m[k]!!\\n        }\\n        return IntArray(N){ it }.filter{ T <= go(it) }.size\\n    }\\n}\\n```\n```\\nlet rootCount = (E, A, T, N = E.length + 1, m = new Map()) => {\\n    let adj = new Map([...Array(N).keys()].map(i => [i, []]));\\n    for (let [u, v] of E) {\\n        adj.get(u).push(v);\\n        adj.get(v).push(u);\\n    }\\n    let key = (u, v) => `${u},${v}`;\\n    let need = new Set([...A].map(([u, v]) => key(u, v)));\\n    let go = (node, last = -1) => {\\n        let k = key(last, node);\\n        if (!m.has(k)) {\\n            let cnt = Number(need.has(k));\\n            for (let next of adj.get(node))\\n                if (next != last)\\n                    cnt += go(next, node);\\n            m.set(k, cnt);\\n        }\\n        return m.get(k);\\n    };\\n    return [...Array(N).keys()].filter(i => T <= go(i)).length;\\n};\\n```\n```\\nclass Solution:\\n    def rootCount(self, E: List[List[int]], A: List[List[int]], T: int) -> int:\\n        adj = defaultdict(list)\\n        for u, v in E:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        need = set([(u, v) for u, v in A])\\n        @cache\\n        def go(node, last = -1):\\n            cnt = (last, node) in need\\n            for next in adj[node]:\\n                if next != last:\\n                    cnt += go(next, node)\\n            return cnt\\n        return len([i for i in range(len(E) + 1) if T <= go(i)])\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Adj = unordered_map<int, VI>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    using Need = unordered_set<string>;\\n    int rootCount(VVI& E, VVI& A, int T, Adj adj = {}, Need need = {}, Map m = {}, int cnt = 0) {\\n        for (auto& edge: E) {\\n            auto [u, v] = tie(edge[0], edge[1]);\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        auto key = [](auto u, auto v) {\\n            stringstream ss; ss << u << \",\" << v;\\n            return ss.str();\\n        };\\n        for (auto& edge: A) {\\n            auto [u, v] = tie(edge[0], edge[1]);\\n            need.insert(key(u, v));\\n        }\\n        fun go = [&](auto node, auto last) {\\n            auto k = key(last, node);\\n            if (m.find(k) == m.end()) {\\n                int cnt = need.find(k) != need.end();\\n                for (auto next: adj[node])\\n                    if (next != last)\\n                        cnt += go(next, node);\\n                m[k] = cnt;\\n            }\\n            return m[k];\\n        };\\n        for (auto i{ 0 }; i < E.size() + 1; ++i)\\n            cnt += T <= go(i, -1);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268880,
                "title": "c-solution-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>G;\\n    vector<set<int>>Guesses;\\n    int k;\\n    int valid_cnt;\\n    int ans;\\n    void dfs(int cur,int pre)\\n    {\\n        for(auto &x:G[cur])\\n        {\\n            if(x==pre)continue;\\n            if(Guesses[cur].count(x))valid_cnt+=1;\\n            dfs(x,cur);\\n        }\\n    }\\n    void dfs2(int cur,int pre)\\n    {\\n        if(valid_cnt>=k)ans+=1;\\n        for(auto &x:G[cur])\\n        {\\n            if(x==pre)continue;\\n            if(Guesses[cur].count(x))valid_cnt-=1;\\n            if(Guesses[x].count(cur))valid_cnt+=1;\\n            dfs2(x,cur);\\n            if(Guesses[cur].count(x))valid_cnt+=1;\\n            if(Guesses[x].count(cur))valid_cnt-=1;\\n        }\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) \\n    {\\n        int n=edges.size()+1;\\n        G.resize(n);\\n        Guesses.resize(n);\\n        this->k=k;\\n        valid_cnt=0;\\n        ans=0;\\n        for(auto &x:edges)G[x[0]].push_back(x[1]),G[x[1]].push_back(x[0]);\\n        for(auto &x:guesses)Guesses[x[0]].insert(x[1]);\\n        dfs(0,-1);\\n        dfs2(0,-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>G;\\n    vector<set<int>>Guesses;\\n    int k;\\n    int valid_cnt;\\n    int ans;\\n    void dfs(int cur,int pre)\\n    {\\n        for(auto &x:G[cur])\\n        {\\n            if(x==pre)continue;\\n            if(Guesses[cur].count(x))valid_cnt+=1;\\n            dfs(x,cur);\\n        }\\n    }\\n    void dfs2(int cur,int pre)\\n    {\\n        if(valid_cnt>=k)ans+=1;\\n        for(auto &x:G[cur])\\n        {\\n            if(x==pre)continue;\\n            if(Guesses[cur].count(x))valid_cnt-=1;\\n            if(Guesses[x].count(cur))valid_cnt+=1;\\n            dfs2(x,cur);\\n            if(Guesses[cur].count(x))valid_cnt+=1;\\n            if(Guesses[x].count(cur))valid_cnt-=1;\\n        }\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) \\n    {\\n        int n=edges.size()+1;\\n        G.resize(n);\\n        Guesses.resize(n);\\n        this->k=k;\\n        valid_cnt=0;\\n        ans=0;\\n        for(auto &x:edges)G[x[0]].push_back(x[1]),G[x[1]].push_back(x[0]);\\n        for(auto &x:guesses)Guesses[x[0]].insert(x[1]);\\n        dfs(0,-1);\\n        dfs2(0,-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264986,
                "title": "c-dynamic-programming-easy-understand",
                "content": "# Code\\n```\\ntypedef pair<int, int> ii;\\n\\nclass Solution {\\n    map<ii, int> dp, hash;\\n    int ans = 0;\\n\\n    int dfs(int root, vector<int> graph[], int parent) {\\n        pair<int, int> key = {parent, root};\\n        if (dp.find(key) != dp.end())\\n            return dp[key];\\n        \\n        int temp = 0;\\n\\n        if (hash.find(key) != hash.end()) \\n            temp++;\\n        \\n        for (auto &cur : graph[root]) {\\n            if (cur == parent) \\n                continue;\\n            temp += dfs(cur, graph, root);\\n        }\\n        \\n        return dp[key] = temp ;\\n    }\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int n = edges.size();\\n        vector<int> graph[n + 1];\\n\\n        for (auto &item : guesses) \\n            hash[{item[0], item[1]}]++;\\n\\n        for (auto &item : edges) {\\n            graph[item[0]].push_back(item[1]);\\n            graph[item[1]].push_back(item[0]);\\n        }\\n\\n        for (int i = 0; i <=  n; i++) {\\n            if (dfs(i, graph, -1) >= k) \\n                ans++;             \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef pair<int, int> ii;\\n\\nclass Solution {\\n    map<ii, int> dp, hash;\\n    int ans = 0;\\n\\n    int dfs(int root, vector<int> graph[], int parent) {\\n        pair<int, int> key = {parent, root};\\n        if (dp.find(key) != dp.end())\\n            return dp[key];\\n        \\n        int temp = 0;\\n\\n        if (hash.find(key) != hash.end()) \\n            temp++;\\n        \\n        for (auto &cur : graph[root]) {\\n            if (cur == parent) \\n                continue;\\n            temp += dfs(cur, graph, root);\\n        }\\n        \\n        return dp[key] = temp ;\\n    }\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int n = edges.size();\\n        vector<int> graph[n + 1];\\n\\n        for (auto &item : guesses) \\n            hash[{item[0], item[1]}]++;\\n\\n        for (auto &item : edges) {\\n            graph[item[0]].push_back(item[1]);\\n            graph[item[1]].push_back(item[0]);\\n        }\\n\\n        for (int i = 0; i <=  n; i++) {\\n            if (dfs(i, graph, -1) >= k) \\n                ans++;             \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263366,
                "title": "c-dfs-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>m;\\n    unordered_map<int,int>r;\\n    unordered_map<int,int>g;\\n    int ans=0;\\n    void dfs(vector<vector<int>>&adj,int node,int parent){\\n        \\n        m[node]=parent;\\n        \\n        for(auto x:adj[node]){\\n            if(x==parent)continue;\\n            dfs(adj,x,node);\\n        }\\n        \\n    }\\n    void dfs2(vector<vector<int>>&adj,int node,int parent,int count,int k){\\n        \\n      \\n        int temp=count;\\n       \\n            if(g.count(node)&& (g[node]==parent)){     // already counted correct parent-child\\n                temp--;\\n            }\\n            if(r.count(node) && (r[node]==parent)){ \\n                 // check if a reverse was present in guesses\\n                //since when making this node a root\\n               //all the node on its path will have reverse parent-                                                    //child relation\\n                temp++;\\n            }\\n        \\n        if(temp>=k)ans++;\\n        \\n        for(auto x:adj[node]){\\n            if(x==parent)continue;\\n            dfs2(adj,x,node,temp,k);\\n        }\\n    }\\n    \\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guess, int k) {\\n        int n=edges.size();\\n        m.clear();\\n        r.clear();\\n        g.clear();\\n        vector<vector<int>>adj(n+1);\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        dfs(adj,0,-1);\\n        \\n        int count=0;\\n        for(int i=0;i<guess.size();i++){\\n            int u=guess[i][0];\\n            int v=guess[i][1];\\n            if(m[v]==u){\\n                g[v]=u; //correct parent-child edge present in guess\\n                count++;\\n            }\\n            if(m[u]==v){    \\n                r[u]=v; //incase of reverse parent child we add it in the reverse map\\n            }\\n        }\\n\\n        dfs2(adj,0,-1,count,k);\\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>m;\\n    unordered_map<int,int>r;\\n    unordered_map<int,int>g;\\n    int ans=0;\\n    void dfs(vector<vector<int>>&adj,int node,int parent){\\n        \\n        m[node]=parent;\\n        \\n        for(auto x:adj[node]){\\n            if(x==parent)continue;\\n            dfs(adj,x,node);\\n        }\\n        \\n    }\\n    void dfs2(vector<vector<int>>&adj,int node,int parent,int count,int k){\\n        \\n      \\n        int temp=count;\\n       \\n            if(g.count(node)&& (g[node]==parent)){     // already counted correct parent-child\\n                temp--;\\n            }\\n            if(r.count(node) && (r[node]==parent)){ \\n                 // check if a reverse was present in guesses\\n                //since when making this node a root\\n               //all the node on its path will have reverse parent-                                                    //child relation\\n                temp++;\\n            }\\n        \\n        if(temp>=k)ans++;\\n        \\n        for(auto x:adj[node]){\\n            if(x==parent)continue;\\n            dfs2(adj,x,node,temp,k);\\n        }\\n    }\\n    \\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guess, int k) {\\n        int n=edges.size();\\n        m.clear();\\n        r.clear();\\n        g.clear();\\n        vector<vector<int>>adj(n+1);\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        dfs(adj,0,-1);\\n        \\n        int count=0;\\n        for(int i=0;i<guess.size();i++){\\n            int u=guess[i][0];\\n            int v=guess[i][1];\\n            if(m[v]==u){\\n                g[v]=u; //correct parent-child edge present in guess\\n                count++;\\n            }\\n            if(m[u]==v){    \\n                r[u]=v; //incase of reverse parent child we add it in the reverse map\\n            }\\n        }\\n\\n        dfs2(adj,0,-1,count,k);\\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263152,
                "title": "simple-python-soln-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe diagram in the example 1 gives a good intuition. When we move from a root (say r) to its child (say c) as a new root, the only thing that changes is that the guess (r,c) becomes false (if any) and guess (c,r) becomes true (if any).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst take any node and run a dfs. Count all correct guesses.\\nNow run dfs again, but use this intuition when moving from current root r to child c as new root, subtract 1 from correct if there was a guess from r->c and add 1 to correct if there was a guess from c->r\\n(As c is now the new root).\\nRemember we are backtracking so reverse the above steps when done with dfs over that child.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        graph = defaultdict(set)\\n        guess = set()\\n        correct,roots = [0],[0]\\n        leaf = 0\\n        for a,b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        for x,y in guesses:\\n            guess.add((x,y)) # x parent of y\\n        path = set()\\n        def dfs(node, chk=False):\\n            path.add(node)\\n            if chk and correct[0]>=k:\\n                roots[0]+=1\\n            for ni in graph[node]:\\n                if ni not in path:\\n                    if chk and (node,ni) in guess:\\n                        correct[0]-=1\\n                    if chk and (ni,node) in guess:\\n                        correct[0]+=1\\n                    dfs(ni,chk)\\n                    if (node,ni) in guess:\\n                        correct[0]+=1\\n                    if chk and (ni,node) in guess:\\n                        correct[0]-=1\\n        dfs(0) # Check for 0 as root\\n        path = set()\\n        dfs(0,True) # For rest of nodes as root\\n        return roots[0]\\n    \\n    \\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        graph = defaultdict(set)\\n        guess = set()\\n        correct,roots = [0],[0]\\n        leaf = 0\\n        for a,b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        for x,y in guesses:\\n            guess.add((x,y)) # x parent of y\\n        path = set()\\n        def dfs(node, chk=False):\\n            path.add(node)\\n            if chk and correct[0]>=k:\\n                roots[0]+=1\\n            for ni in graph[node]:\\n                if ni not in path:\\n                    if chk and (node,ni) in guess:\\n                        correct[0]-=1\\n                    if chk and (ni,node) in guess:\\n                        correct[0]+=1\\n                    dfs(ni,chk)\\n                    if (node,ni) in guess:\\n                        correct[0]+=1\\n                    if chk and (ni,node) in guess:\\n                        correct[0]-=1\\n        dfs(0) # Check for 0 as root\\n        path = set()\\n        dfs(0,True) # For rest of nodes as root\\n        return roots[0]\\n    \\n    \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260508,
                "title": "python-two-times-traversal-o-n",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        \\n        G = defaultdict(list)\\n        for u, v in edges:\\n            G[u].append(v)\\n            G[v].append(u)\\n        \\n        s = set(map(tuple, guesses))\\n        \\n        counter = defaultdict(list)\\n        counter[0] = [0, 0]\\n        def dfs(v, par):\\n            \\n            ans = 0\\n            for u in G[v]:\\n                if u != par:\\n                    counter[u] = [0, 0]\\n                    counter[u][0] = counter[v][0] + int((v, u) in s)\\n                    counter[u][1] = counter[v][1] + int((u, v) in s)\\n                    ans += dfs(u, v) + int((v, u) in s)\\n                    \\n            return ans\\n        \\n        z = dfs(0, -1)\\n        ans = 0\\n        \\n        for x1, x2 in counter.values():\\n            if z - x1 + x2 >= k:\\n                ans += 1\\n    \\n        return ans\\n                \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        \\n        G = defaultdict(list)\\n        for u, v in edges:\\n            G[u].append(v)\\n            G[v].append(u)\\n        \\n        s = set(map(tuple, guesses))\\n        \\n        counter = defaultdict(list)\\n        counter[0] = [0, 0]\\n        def dfs(v, par):\\n            \\n            ans = 0\\n            for u in G[v]:\\n                if u != par:\\n                    counter[u] = [0, 0]\\n                    counter[u][0] = counter[v][0] + int((v, u) in s)\\n                    counter[u][1] = counter[v][1] + int((u, v) in s)\\n                    ans += dfs(u, v) + int((v, u) in s)\\n                    \\n            return ans\\n        \\n        z = dfs(0, -1)\\n        ans = 0\\n        \\n        for x1, x2 in counter.values():\\n            if z - x1 + x2 >= k:\\n                ans += 1\\n    \\n        return ans\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260421,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        n = edges.size() + 1;\\n        g.resize(n);\\n        for(auto& e:edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        for(auto& g:guesses){\\n            guess.insert(pair(g[0], g[1]));\\n        }\\n\\n        int res = 0, numGood = 0;\\n        numGoodGuess(0, -1, numGood);\\n        dfs(0, -1, numGood, res, k);\\n        return res;\\n    }\\n\\n    void numGoodGuess(int i, int par, int& count){\\n        for(auto j:g[i]){\\n            if(j == par) continue;\\n            if(guess.count(pair(i, j))) count++;\\n            numGoodGuess(j, i, count);\\n        }\\n    }\\n\\n    void dfs(int i, int par, int numGood, int& res, int k){\\n        //cout<<i<<\" \"<<numGood<<endl;\\n        if(numGood >= k) res++;\\n        for(auto j:g[i]){\\n            if(j == par) continue;\\n            int jGood = numGood;\\n            if(guess.count(pair(j, i))) jGood++;\\n            if(guess.count(pair(i, j))) jGood--;\\n            dfs(j, i, jGood, res, k);\\n        }\\n    }\\n\\n    int n;\\n    vector<vector<int>> g;\\n    set<pair<int,int>> guess;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        n = edges.size() + 1;\\n        g.resize(n);\\n        for(auto& e:edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        for(auto& g:guesses){\\n            guess.insert(pair(g[0], g[1]));\\n        }\\n\\n        int res = 0, numGood = 0;\\n        numGoodGuess(0, -1, numGood);\\n        dfs(0, -1, numGood, res, k);\\n        return res;\\n    }\\n\\n    void numGoodGuess(int i, int par, int& count){\\n        for(auto j:g[i]){\\n            if(j == par) continue;\\n            if(guess.count(pair(i, j))) count++;\\n            numGoodGuess(j, i, count);\\n        }\\n    }\\n\\n    void dfs(int i, int par, int numGood, int& res, int k){\\n        //cout<<i<<\" \"<<numGood<<endl;\\n        if(numGood >= k) res++;\\n        for(auto j:g[i]){\\n            if(j == par) continue;\\n            int jGood = numGood;\\n            if(guess.count(pair(j, i))) jGood++;\\n            if(guess.count(pair(i, j))) jGood--;\\n            dfs(j, i, jGood, res, k);\\n        }\\n    }\\n\\n    int n;\\n    vector<vector<int>> g;\\n    set<pair<int,int>> guess;\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3260250,
                "title": "o-nlogn-depth-first-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n`Tip:` It is almost always best to root the tree in tree based problems and then think of the solution.\\n\\nInitially assuming that the root is at 0.\\nWhen we want to promote a node `B` as the root of the tree, then only the edges lying in the path from (0 to B) are reversed (This can easily be proved by making some example trees). Hence, while running dfs, we only need to maintain the count of edges that are as it is present in the `guesses` vector, and the count of edges that when reversed, can be found in `guesses` vector.\\n\\nLet\\'s assume the `same`(an integer) number of edges are as it is present in the `guesses` vector, and `revert`(an integer) number of edges can be found by reverting the edges.\\n\\nNow, if we want to check whether, or not node `B` can become the root of the tree, we can simply use this relation: `validGuesses - same + revert >= k`.\\n\\n`Note:` \\n1. For a node to be qualified as the root, the number of guesses must be greater than equal to `k`.\\n2. `validGuesses` is the total number of edges that we could find as it is in `guesses` vector.\\n\\n\\n# Complexity\\n- Time complexity: $$O(NlogN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  map<int, vector<int> > tree;\\n  set<vector<int>> new_guesses;\\n  int validGuesses = 0;\\n  int ans = 0;\\n\\n  int dfs1(int prev, int curr) {\\n    for (int nxt: tree[curr]) {\\n      if (prev != nxt) {\\n        validGuesses += dfs1(curr, nxt);\\n      }\\n    }\\n    return new_guesses.count({ prev, curr });\\n  }\\n\\n  void dfs2(int prev, int curr, int k, int same, int revert) {\\n    if (new_guesses.count({ prev, curr })) {\\n      same++;\\n    }\\n    if (new_guesses.count({ curr, prev })) {\\n      revert++;\\n    }\\n    ans += (validGuesses - same + revert >= k);\\n    \\n    for (int nxt: tree[curr]) {\\n      if (prev != nxt) {\\n        dfs2(curr, nxt, k, same, revert);\\n      }\\n    }\\n    return;\\n  }\\n\\n  int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n\\n    for (vector<int> edge: edges) {\\n      int u = edge[0], v = edge[1];\\n      tree[u].push_back(v);\\n      tree[v].push_back(u);\\n    }\\n\\n    for (vector<int> edge: guesses) {\\n      new_guesses.insert(edge);\\n    }\\n\\n    dfs1(-1, 0);\\n    dfs2(-1, 0, k, 0, 0);\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  map<int, vector<int> > tree;\\n  set<vector<int>> new_guesses;\\n  int validGuesses = 0;\\n  int ans = 0;\\n\\n  int dfs1(int prev, int curr) {\\n    for (int nxt: tree[curr]) {\\n      if (prev != nxt) {\\n        validGuesses += dfs1(curr, nxt);\\n      }\\n    }\\n    return new_guesses.count({ prev, curr });\\n  }\\n\\n  void dfs2(int prev, int curr, int k, int same, int revert) {\\n    if (new_guesses.count({ prev, curr })) {\\n      same++;\\n    }\\n    if (new_guesses.count({ curr, prev })) {\\n      revert++;\\n    }\\n    ans += (validGuesses - same + revert >= k);\\n    \\n    for (int nxt: tree[curr]) {\\n      if (prev != nxt) {\\n        dfs2(curr, nxt, k, same, revert);\\n      }\\n    }\\n    return;\\n  }\\n\\n  int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n\\n    for (vector<int> edge: edges) {\\n      int u = edge[0], v = edge[1];\\n      tree[u].push_back(v);\\n      tree[v].push_back(u);\\n    }\\n\\n    for (vector<int> edge: guesses) {\\n      new_guesses.insert(edge);\\n    }\\n\\n    dfs1(-1, 0);\\n    dfs2(-1, 0, k, 0, 0);\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260114,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rootCount(self, edges, guesses, k):\\n        dict1 = collections.defaultdict(list)\\n\\n        for i,j in edges:\\n            dict1[i].append(j)\\n            dict1[j].append(i)\\n\\n        guesses_set = set((i,j) for i,j in guesses)\\n\\n\\n        @lru_cache(None)\\n        def dfs(i,parent):\\n            total = 0\\n\\n            if (parent,i) in guesses_set:\\n                total = 1\\n\\n            for neighbor in dict1[i]:\\n                if neighbor == parent:\\n                    continue\\n                total += dfs(neighbor,i)\\n\\n            return total\\n\\n        result = 0\\n\\n        for i in dict1:\\n            if dfs(i,None) >= k:\\n                result += 1\\n\\n        return result\\n\\n                \\n\\n\\n            \\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rootCount(self, edges, guesses, k):\\n        dict1 = collections.defaultdict(list)\\n\\n        for i,j in edges:\\n            dict1[i].append(j)\\n            dict1[j].append(i)\\n\\n        guesses_set = set((i,j) for i,j in guesses)\\n\\n\\n        @lru_cache(None)\\n        def dfs(i,parent):\\n            total = 0\\n\\n            if (parent,i) in guesses_set:\\n                total = 1\\n\\n            for neighbor in dict1[i]:\\n                if neighbor == parent:\\n                    continue\\n                total += dfs(neighbor,i)\\n\\n            return total\\n\\n        result = 0\\n\\n        for i in dict1:\\n            if dfs(i,None) >= k:\\n                result += 1\\n\\n        return result\\n\\n                \\n\\n\\n            \\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259748,
                "title": "c-o-n-rerooting-dfs-sln",
                "content": "```\\nint rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        const int n = size(edges) + 1;\\n        vector<vector<int>> g(n);\\n        for (const auto& e: edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n\\n        vector<unordered_set<int>> edgesOrdered(n);\\n        function<void(int, int)> getEdgesDfs;\\n        getEdgesDfs = [&](int v, int from) {\\n            edgesOrdered[from].insert(v);\\n            for (const auto to: g[v]) {\\n                if (to != from) {\\n                    getEdgesDfs(to, v);\\n                }\\n            }\\n        };\\n        getEdgesDfs(0, 0);\\n\\n        vector<unordered_set<int>> guessesSet(n);\\n        for (const auto& g: guesses) {\\n            guessesSet[g[0]].insert(g[1]);\\n        }\\n        int correctGuesses = 0;\\n        for (int v = 0; v < n; ++v) {\\n            for (const auto to: guessesSet[v]) {\\n                if (edgesOrdered[v].count(to)) {\\n                    ++correctGuesses;\\n                }\\n            }\\n        }\\n\\n        int ans = 0;\\n        function<void(int, int)> rerootingDfs;\\n        rerootingDfs = [&](int newRoot, int previousRoot) {\\n            const int diff = guessesSet[newRoot].count(previousRoot) - guessesSet[previousRoot].count(newRoot);\\n            correctGuesses += diff;\\n            ans += correctGuesses >= k;\\n            for (const auto to: g[newRoot]) {\\n                if (to != previousRoot) {\\n                    rerootingDfs(to, newRoot);\\n                }\\n            }\\n            correctGuesses -= diff;\\n        };\\n        rerootingDfs(0, 0);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        const int n = size(edges) + 1;\\n        vector<vector<int>> g(n);\\n        for (const auto& e: edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n\\n        vector<unordered_set<int>> edgesOrdered(n);\\n        function<void(int, int)> getEdgesDfs;\\n        getEdgesDfs = [&](int v, int from) {\\n            edgesOrdered[from].insert(v);\\n            for (const auto to: g[v]) {\\n                if (to != from) {\\n                    getEdgesDfs(to, v);\\n                }\\n            }\\n        };\\n        getEdgesDfs(0, 0);\\n\\n        vector<unordered_set<int>> guessesSet(n);\\n        for (const auto& g: guesses) {\\n            guessesSet[g[0]].insert(g[1]);\\n        }\\n        int correctGuesses = 0;\\n        for (int v = 0; v < n; ++v) {\\n            for (const auto to: guessesSet[v]) {\\n                if (edgesOrdered[v].count(to)) {\\n                    ++correctGuesses;\\n                }\\n            }\\n        }\\n\\n        int ans = 0;\\n        function<void(int, int)> rerootingDfs;\\n        rerootingDfs = [&](int newRoot, int previousRoot) {\\n            const int diff = guessesSet[newRoot].count(previousRoot) - guessesSet[previousRoot].count(newRoot);\\n            correctGuesses += diff;\\n            ans += correctGuesses >= k;\\n            for (const auto to: g[newRoot]) {\\n                if (to != previousRoot) {\\n                    rerootingDfs(to, newRoot);\\n                }\\n            }\\n            correctGuesses -= diff;\\n        };\\n        rerootingDfs(0, 0);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259416,
                "title": "recursion-memoization-dp-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    map<pair<int,int>,int> m;\\n    int f(int node, vector<int> adj[], int par, set<vector<int>> &g)\\n    {\\n        int cnt=0;\\n        if(m.find({node,par})!=m.end()) return m[{node,par}];\\n        for(auto it: adj[node])\\n        {\\n            if(it!=par)\\n            {\\n                vector<int> v={node,it};\\n                if(g.find(v)!=g.end()) cnt++;\\n                cnt+=f(it,adj,node,g);\\n            }\\n        }\\n        return m[{node,par}]=cnt;\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) \\n    {\\n        int n=edges.size()+1;\\n        vector<int> adj[n];\\n        for(auto it: edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        set<vector<int>> g;\\n        for(auto it: guesses) g.insert(it);\\n        int cnt=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            int ans=f(x,adj,-1,g);\\n            if(ans>=k) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    map<pair<int,int>,int> m;\\n    int f(int node, vector<int> adj[], int par, set<vector<int>> &g)\\n    {\\n        int cnt=0;\\n        if(m.find({node,par})!=m.end()) return m[{node,par}];\\n        for(auto it: adj[node])\\n        {\\n            if(it!=par)\\n            {\\n                vector<int> v={node,it};\\n                if(g.find(v)!=g.end()) cnt++;\\n                cnt+=f(it,adj,node,g);\\n            }\\n        }\\n        return m[{node,par}]=cnt;\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) \\n    {\\n        int n=edges.size()+1;\\n        vector<int> adj[n];\\n        for(auto it: edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        set<vector<int>> g;\\n        for(auto it: guesses) g.insert(it);\\n        int cnt=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            int ans=f(x,adj,-1,g);\\n            if(ans>=k) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259311,
                "title": "easy-top-down-c-explained-well",
                "content": "# Approach\\n\\nTry all nodes as a potential root of the tree. Count the number of correct guesses recursively during the traversal. If the number of correct guesses is `>= k` you found a potential root.\\n\\n1. Convert the list of edges and guesses to an adjacency list. I use a `vector<vector<pair<bool, int>>>`, here the `bool` marks whether the connection has been among the guesses.\\n2. Traverse the adjacency list recursively (`CountGuessed`). Simply count the number of times a \"guessed\" edge has been traversed. We pass in the parent node to indicate the direction of the traversal, or in other words, to prevent \"turning back\".\\n3. If the total number of traversed \"guessed\" edges is `>= k` then we found a potential root.\\n\\nThe above algorithm is $$O(N^2)$$ in the number of nodes/edges. We can improve this to $$O(N)$$ with memoization. We can memoize the result for the current node and the parent (`i` and `p` arguments of `CountGuessed`) thus we\\'ll traverse all edges at most twice (in both directions). Notice that `i` and `p` are always directly connected so an `(i, p)` pair always corresponds to an existing edge, thus the complexity is $$O(N)$$.\\n\\nA key insight is that we better use a hashmap as the cache rather than a 2-dimensional array. The array-based cache will allocate $$N^2$$ slots (and hence TLE) whereas the hashmap will have at most $$2N$$ elements.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$ in the number of nodes/edges.\\n- Space complexity: $$O(N)$$ in the number of nodes/edges.\\n\\nSince this is a tree, $$V = E+1$$.\\n\\n# Code\\n```\\nnamespace std {\\ntemplate<>\\nstruct hash<pair<int, int>> {\\n    size_t operator()(const pair<int, int>& p) const {\\n        size_t h = p.first;\\n        return h ^= hash<size_t>()(h) + 0x9e3779b9 + (h << 6) + (h >> 2);\\n    }\\n};\\n}\\n\\nint CountGuessed(const vector<vector<pair<bool, int>>>& adj,\\n                 int i, int p, unordered_map<pair<int, int>, int>& memo) {\\n    auto it = memo.find({i, p});\\n    if (it != memo.end()) {\\n        return it->second;\\n    }\\n    int result = 0;\\n    for (auto& [guess, j] : adj[i]) {\\n        if (j != p) {\\n            result += guess;\\n            result += CountGuessed(adj, abs(j), i, memo);\\n        }\\n    }\\n    return memo.emplace_hint(it, make_pair(i, p), result)->second;\\n}\\n\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n = edges.size() + 1;\\n        unordered_set<pair<int, int>> lookup;\\n        for (auto& g : guesses) {\\n            lookup.emplace(g[0], g[1]);\\n        }\\n        vector<vector<pair<bool, int>>> adj(n);\\n        for (auto& e : edges) {\\n            adj[e[0]].emplace_back(lookup.count({e[0], e[1]}), e[1]);\\n            adj[e[1]].emplace_back(lookup.count({e[1], e[0]}), e[0]);\\n        }\\n        int result = 0;\\n        unordered_map<pair<int, int>, int> memo;\\n        for (int i = 0; i < n; ++i) {\\n            result += CountGuessed(adj, i, n, memo) >= k;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nnamespace std {\\ntemplate<>\\nstruct hash<pair<int, int>> {\\n    size_t operator()(const pair<int, int>& p) const {\\n        size_t h = p.first;\\n        return h ^= hash<size_t>()(h) + 0x9e3779b9 + (h << 6) + (h >> 2);\\n    }\\n};\\n}\\n\\nint CountGuessed(const vector<vector<pair<bool, int>>>& adj,\\n                 int i, int p, unordered_map<pair<int, int>, int>& memo) {\\n    auto it = memo.find({i, p});\\n    if (it != memo.end()) {\\n        return it->second;\\n    }\\n    int result = 0;\\n    for (auto& [guess, j] : adj[i]) {\\n        if (j != p) {\\n            result += guess;\\n            result += CountGuessed(adj, abs(j), i, memo);\\n        }\\n    }\\n    return memo.emplace_hint(it, make_pair(i, p), result)->second;\\n}\\n\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n = edges.size() + 1;\\n        unordered_set<pair<int, int>> lookup;\\n        for (auto& g : guesses) {\\n            lookup.emplace(g[0], g[1]);\\n        }\\n        vector<vector<pair<bool, int>>> adj(n);\\n        for (auto& e : edges) {\\n            adj[e[0]].emplace_back(lookup.count({e[0], e[1]}), e[1]);\\n            adj[e[1]].emplace_back(lookup.count({e[1], e[0]}), e[0]);\\n        }\\n        int result = 0;\\n        unordered_map<pair<int, int>, int> memo;\\n        for (int i = 0; i < n; ++i) {\\n            result += CountGuessed(adj, i, n, memo) >= k;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258852,
                "title": "python-dfs-with-memorization-explained",
                "content": "Honestly, I didn\\'t come up with the DFS + memorization first time because I thought I cannot run `n` DFS sweep which may cause TLE considering the lenght of guess is `10^5`.\\n\\nTherefore, I was implementing something that I only need run 1 DFS sweep (See the TLE solution at the bottom). I was trying to run DFS with root 0, and memorize all the necessary information that can help to get the final ans.\\n\\nHowever, the 1 DFS sweep got TLE due to the overhead I added to remember the extra information.\\n\\nBelow the the `n` DFS sweep with memorization. It is straightforward, and we only need to remember the number of correct guesses starting from each node. Since, we are going to change the parent nodes, thus, we use (parent, current) pair as the key of each (key, value) set, in which the value is the number correct guesses.\\n\\n```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int: \\n        self.G = collections.defaultdict(list)\\n        for s, e in edges:\\n            self.G[s].append(e)\\n            self.G[e].append(s)\\n            \\n        self.guess = set()\\n        for gp, gc in guesses:\\n            self.guess.add((gp, gc))\\n        \\n        self.dp = collections.defaultdict(lambda: None)\\n        self.visited = set()\\n        \\n        ans = 0\\n        for i in range(len(self.G)):\\n            self.visited.clear()\\n            self.visited.add(i)\\n            if self.dfs(i, -1) >= k:\\n                ans += 1\\n        return ans\\n```\\n\\n**TLE Solution with 1 DFS sweep**\\n```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        self.parent = collections.defaultdict(set)\\n        self.parent_n0 = set()\\n        self.parent_n0_rev = set()\\n        \\n        self.G = collections.defaultdict(list)\\n        for s, e in edges:\\n            self.G[s].append(e)\\n            self.G[e].append(s)\\n            \\n        self.guess = set()\\n        for gp, gc in guesses:\\n            self.guess.add((gp, gc))\\n            \\n        self.visited = set()\\n        \\n        self.n0_guess = 0\\n        self.visited.add(0)\\n        self.dfs(0, set())\\n        self.parent_n0_diff = self.guess.difference(self.parent_n0)\\n        \\n        ans = 0 \\n        if self.n0_guess >= k:\\n            ans += 1\\n        \\n        for i in range(1, len(self.G)):\\n            t = len(self.parent_n0_diff.intersection(self.parent[i])) + self.n0_guess - len(self.parent[i].intersection(self.parent_n0_rev))\\n            if t >= k:\\n                ans += 1\\n        return ans\\n            \\n        \\n    def dfs(self, i, reverse_path_set):\\n        for ni in self.G[i]:\\n            if ni not in self.visited:\\n                reverse_path_set.add((ni, i))\\n                self.parent[ni] = set(reverse_path_set)\\n                if (i, ni) in self.guess:\\n                    self.parent_n0.add((i, ni))\\n                    self.parent_n0_rev.add((ni, i))\\n                    self.n0_guess += 1\\n                self.visited.add(ni)\\n                self.dfs(ni, reverse_path_set)\\n                reverse_path_set.discard((ni, i))\\n                \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int: \\n        self.G = collections.defaultdict(list)\\n        for s, e in edges:\\n            self.G[s].append(e)\\n            self.G[e].append(s)\\n            \\n        self.guess = set()\\n        for gp, gc in guesses:\\n            self.guess.add((gp, gc))\\n        \\n        self.dp = collections.defaultdict(lambda: None)\\n        self.visited = set()\\n        \\n        ans = 0\\n        for i in range(len(self.G)):\\n            self.visited.clear()\\n            self.visited.add(i)\\n            if self.dfs(i, -1) >= k:\\n                ans += 1\\n        return ans\\n```\n```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        self.parent = collections.defaultdict(set)\\n        self.parent_n0 = set()\\n        self.parent_n0_rev = set()\\n        \\n        self.G = collections.defaultdict(list)\\n        for s, e in edges:\\n            self.G[s].append(e)\\n            self.G[e].append(s)\\n            \\n        self.guess = set()\\n        for gp, gc in guesses:\\n            self.guess.add((gp, gc))\\n            \\n        self.visited = set()\\n        \\n        self.n0_guess = 0\\n        self.visited.add(0)\\n        self.dfs(0, set())\\n        self.parent_n0_diff = self.guess.difference(self.parent_n0)\\n        \\n        ans = 0 \\n        if self.n0_guess >= k:\\n            ans += 1\\n        \\n        for i in range(1, len(self.G)):\\n            t = len(self.parent_n0_diff.intersection(self.parent[i])) + self.n0_guess - len(self.parent[i].intersection(self.parent_n0_rev))\\n            if t >= k:\\n                ans += 1\\n        return ans\\n            \\n        \\n    def dfs(self, i, reverse_path_set):\\n        for ni in self.G[i]:\\n            if ni not in self.visited:\\n                reverse_path_set.add((ni, i))\\n                self.parent[ni] = set(reverse_path_set)\\n                if (i, ni) in self.guess:\\n                    self.parent_n0.add((i, ni))\\n                    self.parent_n0_rev.add((ni, i))\\n                    self.n0_guess += 1\\n                self.visited.add(ni)\\n                self.dfs(ni, reverse_path_set)\\n                reverse_path_set.discard((ni, i))\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258780,
                "title": "explained-beats-100-time-space-java",
                "content": "# Intuition\\n1. Pick a node(0) as the root, built a rooted tree using DFS and keep a count on how many of Bob guesses are right.\\n2. With the tree built, perform another DFS of backtracking on the count of how many of Bob guesses are right if next child will be used as the root as the new tree.\\n3. Clearly, this approach is the problem of re-rooting.\\n\\n# Approach\\n1. We create the tree, guess and parent arrays\\n2. To create parents array, we start from assuming node 0, and iterate through the tree.\\n3. Now, check how many guesses are correct and update the counter.\\n4. Whenever counter > k, increment the answer.\\n5. Then use Depth first search approach to assume all the nodes as root node one by one and accordingly update the counter and answer variables.\\n6. Return the answer.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    int[] parents;\\n    List<Integer>[] graph;\\n    HashSet<Integer>[] guess; // Use set to avoid duplicate enteries\\n    int ans=0;\\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\\n        int n = edges.length+1;\\n        graph = new ArrayList[n];\\n        guess = new HashSet[n];\\n        for(int i=0; i<n; i++){\\n            graph[i] = new ArrayList<Integer>();\\n            guess[i] = new HashSet<Integer>();\\n        }\\n        // Create tree\\n        for(int i=0; i<edges.length; i++){\\n            graph[edges[i][0]].add(edges[i][1]);\\n            graph[edges[i][1]].add(edges[i][0]);\\n        }\\n        // Create guess array\\n        for(int i=0; i<guesses.length; i++){\\n            guess[guesses[i][0]].add(guesses[i][1]);\\n        }\\n        parents = new int[n];\\n        fill(0,-1);\\n        int c=0;\\n        for(int i=1; i<n; i++) {\\n            if(guess[parents[i]].contains(i)) c++;\\n        }\\n        if(c>=k) ans++;\\n        for(int i: graph[0]) dfs(i, 0, c, k);\\n        return ans;\\n    }\\n\\n    // Fill the parent array\\n    void fill(int v,int p){\\n        parents[v] = p;\\n        for(int child: graph[v]){\\n            if(child==p) continue;\\n            fill(child,v);\\n        }\\n    }\\n\\n    // Use DFS to make all nodes as root one by one\\n    void dfs(int v, int p, int c, int k){\\n        if(guess[p].contains(v)) c--;\\n        if(guess[v].contains(p)) c++;\\n        if(c>=k) ans++;\\n        for(int child: graph[v]) if(child!=p) dfs(child, v, c, k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int[] parents;\\n    List<Integer>[] graph;\\n    HashSet<Integer>[] guess; // Use set to avoid duplicate enteries\\n    int ans=0;\\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\\n        int n = edges.length+1;\\n        graph = new ArrayList[n];\\n        guess = new HashSet[n];\\n        for(int i=0; i<n; i++){\\n            graph[i] = new ArrayList<Integer>();\\n            guess[i] = new HashSet<Integer>();\\n        }\\n        // Create tree\\n        for(int i=0; i<edges.length; i++){\\n            graph[edges[i][0]].add(edges[i][1]);\\n            graph[edges[i][1]].add(edges[i][0]);\\n        }\\n        // Create guess array\\n        for(int i=0; i<guesses.length; i++){\\n            guess[guesses[i][0]].add(guesses[i][1]);\\n        }\\n        parents = new int[n];\\n        fill(0,-1);\\n        int c=0;\\n        for(int i=1; i<n; i++) {\\n            if(guess[parents[i]].contains(i)) c++;\\n        }\\n        if(c>=k) ans++;\\n        for(int i: graph[0]) dfs(i, 0, c, k);\\n        return ans;\\n    }\\n\\n    // Fill the parent array\\n    void fill(int v,int p){\\n        parents[v] = p;\\n        for(int child: graph[v]){\\n            if(child==p) continue;\\n            fill(child,v);\\n        }\\n    }\\n\\n    // Use DFS to make all nodes as root one by one\\n    void dfs(int v, int p, int c, int k){\\n        if(guess[p].contains(v)) c--;\\n        if(guess[v].contains(p)) c++;\\n        if(c>=k) ans++;\\n        for(int child: graph[v]) if(child!=p) dfs(child, v, c, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258625,
                "title": "c-dfs-set",
                "content": "\\n# Approach\\nFirstly we make 0 as a root and check the guesses how many are correct.\\nAfter that in the second dfs if we are on the node say x and we want this node as root then the nodes from 0 to node are just becomes reverse means this node x will now parent of its par. And all the other things will be same.\\nLet say 0-1-2-3-4-5 and if I make 3 as a root then 3 become parent of 2 and 2 parent of 1 and 1 parent of 0. means we just need to analyse the path nothing else.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nconst static int N = 1e5 + 1;\\nint ans = 0;\\nint initial_true;\\nset<pair<int, int>> st;\\nvector<int> g[N];\\n\\nvoid dfs1(int node, int par) {\\n\\tif(st.find({node, par}) != st.end()) {\\n\\t\\tinitial_true--;\\n\\t}\\n\\tfor(int child : g[node]) {\\n\\t\\tif(child == par) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tdfs1(child, node);\\n\\t}\\n}\\nvoid dfs2(int node, int par, int k) {\\n\\t// let the current node is root then it will be parent of par\\n\\tif(st.find({node, par}) != st.end()) {\\n\\t\\tinitial_true++;\\n\\t}\\n    if(st.find({par, node}) != st.end()) {\\n        initial_true--;\\n    }\\n\\tfor(int child : g[node]) {\\n\\t\\tif(child == par) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tdfs2(child, node, k);\\n\\t}\\n\\tif(initial_true >= k) {\\n\\t\\tans++;\\n\\t}\\n\\tif(st.find({node, par}) != st.end()) {\\n\\t\\tinitial_true--;\\n\\t}\\n    if(st.find({par, node}) != st.end()) {\\n        initial_true++;\\n    }\\n}\\nint rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n\\tint n = (int) edges.size() + 1;\\n\\tinitial_true = guesses.size();\\n\\tfor(auto g : guesses) {\\n\\t\\tst.insert({g[0], g[1]});\\n\\t}\\n\\tfor(int i = 0; i + 1 < n; i++) {\\n\\t\\tint a = edges[i][0];\\n\\t\\tint b = edges[i][1];\\n\\t\\tg[a].push_back(b);\\n\\t\\tg[b].push_back(a);\\n\\t}\\n\\tdfs1(0, -1);\\n\\tdfs2(0, -1, k);\\n\\treturn ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nconst static int N = 1e5 + 1;\\nint ans = 0;\\nint initial_true;\\nset<pair<int, int>> st;\\nvector<int> g[N];\\n\\nvoid dfs1(int node, int par) {\\n\\tif(st.find({node, par}) != st.end()) {\\n\\t\\tinitial_true--;\\n\\t}\\n\\tfor(int child : g[node]) {\\n\\t\\tif(child == par) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tdfs1(child, node);\\n\\t}\\n}\\nvoid dfs2(int node, int par, int k) {\\n\\t// let the current node is root then it will be parent of par\\n\\tif(st.find({node, par}) != st.end()) {\\n\\t\\tinitial_true++;\\n\\t}\\n    if(st.find({par, node}) != st.end()) {\\n        initial_true--;\\n    }\\n\\tfor(int child : g[node]) {\\n\\t\\tif(child == par) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tdfs2(child, node, k);\\n\\t}\\n\\tif(initial_true >= k) {\\n\\t\\tans++;\\n\\t}\\n\\tif(st.find({node, par}) != st.end()) {\\n\\t\\tinitial_true--;\\n\\t}\\n    if(st.find({par, node}) != st.end()) {\\n        initial_true++;\\n    }\\n}\\nint rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n\\tint n = (int) edges.size() + 1;\\n\\tinitial_true = guesses.size();\\n\\tfor(auto g : guesses) {\\n\\t\\tst.insert({g[0], g[1]});\\n\\t}\\n\\tfor(int i = 0; i + 1 < n; i++) {\\n\\t\\tint a = edges[i][0];\\n\\t\\tint b = edges[i][1];\\n\\t\\tg[a].push_back(b);\\n\\t\\tg[b].push_back(a);\\n\\t}\\n\\tdfs1(0, -1);\\n\\tdfs2(0, -1, k);\\n\\treturn ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258001,
                "title": "python-dfs-o-n-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        # build graph\\n        graph = collections.defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        # make guesses set\\n        guesses, edges, res = {tuple(x) for x in guesses}, set(), 0\\n        \\n        def dfs1(x, px):\\n            for y in graph[x]:\\n                if y != px:\\n                    edges.add((x, y))\\n                    dfs1(y, x)      \\n                    \\n        def dfs2(x, px):\\n            nonlocal res, match\\n            res += match >= k\\n                \\n            for y in graph[x]:\\n                if y != px:\\n                    oldMatch = match\\n                    \\n                    edges.remove((x, y))\\n                    edges.add((y, x))\\n                    match -= (x, y) in guesses\\n                    match += (y, x) in guesses\\n                    \\n                    dfs2(y, x)\\n                    \\n                    edges.remove((y, x))\\n                    edges.add((x, y))\\n                    match = oldMatch\\n        \\n        # build edges set given node 0 as root\\n        dfs1(0, -1)\\n        match = len(edges & guesses)\\n        \\n        # calc match given different node as root in dfs way\\n        dfs2(0, -1)\\n        return res\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        # build graph\\n        graph = collections.defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        # make guesses set\\n        guesses, edges, res = {tuple(x) for x in guesses}, set(), 0\\n        \\n        def dfs1(x, px):\\n            for y in graph[x]:\\n                if y != px:\\n                    edges.add((x, y))\\n                    dfs1(y, x)      \\n                    \\n        def dfs2(x, px):\\n            nonlocal res, match\\n            res += match >= k\\n                \\n            for y in graph[x]:\\n                if y != px:\\n                    oldMatch = match\\n                    \\n                    edges.remove((x, y))\\n                    edges.add((y, x))\\n                    match -= (x, y) in guesses\\n                    match += (y, x) in guesses\\n                    \\n                    dfs2(y, x)\\n                    \\n                    edges.remove((y, x))\\n                    edges.add((x, y))\\n                    match = oldMatch\\n        \\n        # build edges set given node 0 as root\\n        dfs1(0, -1)\\n        match = len(edges & guesses)\\n        \\n        # calc match given different node as root in dfs way\\n        dfs2(0, -1)\\n        return res\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257753,
                "title": "dp-with-edges-dfs",
                "content": "```\\nclass Solution {\\n    \\n    Map<Integer, List<Integer>> map = new HashMap<>();\\n    Map<Long, Integer> dp = new HashMap<>();\\n    Set<Long> g = new HashSet<>(); \\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\\n        for (int[] e : edges) {\\n            map.putIfAbsent(e[0], new ArrayList<>());\\n            map.putIfAbsent(e[1], new ArrayList<>());\\n            map.get(e[0]).add(e[1]);\\n            map.get(e[1]).add(e[0]);\\n        }\\n        \\n        for (int[] gu : guesses) g.add((long) (gu[0] + 1) * 1_000_000L + (long) gu[1]);\\n        \\n        int ans = 0;\\n        for (int i = 0; i < map.size(); i++) {\\n            if (traverse(-1, i, new HashSet<>()) >= k) ans += 1;\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n    \\n    public int traverse(int prev, int curr, Set<Integer> visited) {\\n        long key = (long) (prev + 1) * 1_000_000L + (long) curr;\\n        if (dp.containsKey(key)) return dp.get(key);\\n        visited.add(curr);\\n        int count = 0;\\n        for (int i : map.get(curr)) {\\n            if (visited.contains(i)) continue;\\n            long k = (long) (curr + 1) * 1_000_000L + (long) i;\\n            count = g.contains(k) ? count + 1 + traverse(curr, i, visited) : count + traverse(curr, i, visited);\\n        }\\n        dp.put(key, count);\\n        return count;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Map<Integer, List<Integer>> map = new HashMap<>();\\n    Map<Long, Integer> dp = new HashMap<>();\\n    Set<Long> g = new HashSet<>(); \\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\\n        for (int[] e : edges) {\\n            map.putIfAbsent(e[0], new ArrayList<>());\\n            map.putIfAbsent(e[1], new ArrayList<>());\\n            map.get(e[0]).add(e[1]);\\n            map.get(e[1]).add(e[0]);\\n        }\\n        \\n        for (int[] gu : guesses) g.add((long) (gu[0] + 1) * 1_000_000L + (long) gu[1]);\\n        \\n        int ans = 0;\\n        for (int i = 0; i < map.size(); i++) {\\n            if (traverse(-1, i, new HashSet<>()) >= k) ans += 1;\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n    \\n    public int traverse(int prev, int curr, Set<Integer> visited) {\\n        long key = (long) (prev + 1) * 1_000_000L + (long) curr;\\n        if (dp.containsKey(key)) return dp.get(key);\\n        visited.add(curr);\\n        int count = 0;\\n        for (int i : map.get(curr)) {\\n            if (visited.contains(i)) continue;\\n            long k = (long) (curr + 1) * 1_000_000L + (long) i;\\n            count = g.contains(k) ? count + 1 + traverse(curr, i, visited) : count + traverse(curr, i, visited);\\n        }\\n        dp.put(key, count);\\n        return count;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257731,
                "title": "time-limit-exceeded-but-good-for-understanding-problem",
                "content": "# Intuition\\nmake graph for root 0 and then for each vertex change root to that vertex by updating the previous generated graph.\\n\\n\\n# Time limit exceeded\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    ArrayList<HashSet<Integer>> grr = new ArrayList<HashSet<Integer>>();\\n    private int[] parents;\\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\\n        int n = edges.length;\\n        int ans = 0;\\n        parents = new int[n+1];\\n        Arrays.fill(parents,-1);  \\n        grr = makeGraph(0,edges);\\n        \\n        for(int i = 0; i<=n ;i++) {\\n            updateGraph(i,new HashSet<Integer>(),n);\\n            System.out.println(i+\"   graph = \"+grr);\\n            int tmp = 0;\\n            for(int guess[] : guesses) {\\n                int a = guess[0];\\n                int b = guess[1];\\n                if(grr.get(a).contains(b)) {\\n                    tmp++;\\n                    System.out.println(i+\"   \"+a+\" - \"+b);\\n                }\\n                else {\\n                    System.out.println(i+\"   \"+a+\" * \"+b);\\n                }\\n            }\\n            for(int kz : parents) {\\n                System.out.print(kz+ \"  \");\\n            }\\n            System.out.println();\\n            System.out.println(i+\"   \"+tmp);\\n\\n            if(tmp>=k) ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    ArrayList<HashSet<Integer>> makeGraph(int root,int[][] edges) {\\n        ArrayList<HashSet<Integer>> graph = new ArrayList<HashSet<Integer>>();\\n        for(int i = 0; i<=edges.length; i++) graph.add(new HashSet<Integer>());\\n        HashSet<Integer> vis = new HashSet<>();\\n        vis.add(root);\\n        for(int edge[] : edges) {\\n            int a = edge[0];\\n            int b = edge[1];\\n            if(vis.contains(a)) {\\n                graph.get(a).add(b);  \\n                parents[b] = a;  \\n            }\\n            else {\\n                graph.get(b).add(a);\\n                parents[a] = b;\\n            }\\n            vis.add(a);\\n            vis.add(b);\\n        }\\n        return graph;\\n    }\\n    \\n    int updateGraph(int root,HashSet<Integer> vis,int n) {\\n        int par = parents[root];\\n        if(par == -1) return -1;\\n        int gp = updateGraph(par,vis,n);\\n        grr.get(par).remove(root);\\n        grr.get(root).add(par);\\n        parents[par] = root;\\n        parents[root] = gp;\\n        return gp;\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    ArrayList<HashSet<Integer>> grr = new ArrayList<HashSet<Integer>>();\\n    private int[] parents;\\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\\n        int n = edges.length;\\n        int ans = 0;\\n        parents = new int[n+1];\\n        Arrays.fill(parents,-1);  \\n        grr = makeGraph(0,edges);\\n        \\n        for(int i = 0; i<=n ;i++) {\\n            updateGraph(i,new HashSet<Integer>(),n);\\n            System.out.println(i+\"   graph = \"+grr);\\n            int tmp = 0;\\n            for(int guess[] : guesses) {\\n                int a = guess[0];\\n                int b = guess[1];\\n                if(grr.get(a).contains(b)) {\\n                    tmp++;\\n                    System.out.println(i+\"   \"+a+\" - \"+b);\\n                }\\n                else {\\n                    System.out.println(i+\"   \"+a+\" * \"+b);\\n                }\\n            }\\n            for(int kz : parents) {\\n                System.out.print(kz+ \"  \");\\n            }\\n            System.out.println();\\n            System.out.println(i+\"   \"+tmp);\\n\\n            if(tmp>=k) ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    ArrayList<HashSet<Integer>> makeGraph(int root,int[][] edges) {\\n        ArrayList<HashSet<Integer>> graph = new ArrayList<HashSet<Integer>>();\\n        for(int i = 0; i<=edges.length; i++) graph.add(new HashSet<Integer>());\\n        HashSet<Integer> vis = new HashSet<>();\\n        vis.add(root);\\n        for(int edge[] : edges) {\\n            int a = edge[0];\\n            int b = edge[1];\\n            if(vis.contains(a)) {\\n                graph.get(a).add(b);  \\n                parents[b] = a;  \\n            }\\n            else {\\n                graph.get(b).add(a);\\n                parents[a] = b;\\n            }\\n            vis.add(a);\\n            vis.add(b);\\n        }\\n        return graph;\\n    }\\n    \\n    int updateGraph(int root,HashSet<Integer> vis,int n) {\\n        int par = parents[root];\\n        if(par == -1) return -1;\\n        int gp = updateGraph(par,vis,n);\\n        grr.get(par).remove(root);\\n        grr.get(root).add(par);\\n        parents[par] = root;\\n        parents[root] = gp;\\n        return gp;\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257669,
                "title": "search-with-subtree-memoization",
                "content": "# Intuition\\nWhen traversing each edge `(src, dest)`, the subtree rooted at the destination `dest` is the same irrespective of how we reached the source node `src`. Hence we could cache the search result. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rootCount(\\n        vector<vector<int>>& edges, \\n        vector<vector<int>>& guesses, \\n        int k) {\\n        const int num_nodes = edges.size() + 1;\\n        std::vector<std::vector<int>> neighbors(num_nodes);\\n        std::vector<std::unordered_set<int>> constraints(num_nodes);\\n        std::vector<std::unordered_map<int, int>> substree_num_sat(num_nodes);        \\n        for (auto &&edge : edges) {\\n            neighbors[edge[0]].push_back(edge[1]);\\n            neighbors[edge[1]].push_back(edge[0]);\\n        }\\n        for (auto &&guess : guesses) {\\n            constraints[guess[0]].insert(guess[1]);\\n        }\\n        int num_possible_roots = 0;\\n        for (int root = 0; root < num_nodes; ++root) {\\n            if (count_num_sat(-1, root, neighbors, constraints, substree_num_sat) >= k) {\\n                num_possible_roots += 1;\\n            }\\n        }\\n        return num_possible_roots;\\n    }\\nprivate:\\n    int count_num_sat(\\n        const int ancestor,\\n        const int root, \\n        const std::vector<std::vector<int>> &neighbors,\\n        const std::vector<std::unordered_set<int>> &constraints,\\n        std::vector<std::unordered_map<int, int>> &substree_num_sat) {        \\n        int total = 0;\\n        for (const int node : neighbors[root]) {\\n            if (node == ancestor) {\\n                continue;\\n            }\\n            if (constraints[root].count(node)) {\\n                total += 1;\\n            }\\n            auto it = substree_num_sat[root].find(node);\\n            if (it != substree_num_sat[root].end()) {\\n                total += it->second;\\n            } else {\\n                const auto subtree_total = \\n                    count_num_sat(root, node, neighbors, constraints, substree_num_sat);\\n                substree_num_sat[root].insert({\\n                    node, subtree_total\\n                });  \\n                total += subtree_total;\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rootCount(\\n        vector<vector<int>>& edges, \\n        vector<vector<int>>& guesses, \\n        int k) {\\n        const int num_nodes = edges.size() + 1;\\n        std::vector<std::vector<int>> neighbors(num_nodes);\\n        std::vector<std::unordered_set<int>> constraints(num_nodes);\\n        std::vector<std::unordered_map<int, int>> substree_num_sat(num_nodes);        \\n        for (auto &&edge : edges) {\\n            neighbors[edge[0]].push_back(edge[1]);\\n            neighbors[edge[1]].push_back(edge[0]);\\n        }\\n        for (auto &&guess : guesses) {\\n            constraints[guess[0]].insert(guess[1]);\\n        }\\n        int num_possible_roots = 0;\\n        for (int root = 0; root < num_nodes; ++root) {\\n            if (count_num_sat(-1, root, neighbors, constraints, substree_num_sat) >= k) {\\n                num_possible_roots += 1;\\n            }\\n        }\\n        return num_possible_roots;\\n    }\\nprivate:\\n    int count_num_sat(\\n        const int ancestor,\\n        const int root, \\n        const std::vector<std::vector<int>> &neighbors,\\n        const std::vector<std::unordered_set<int>> &constraints,\\n        std::vector<std::unordered_map<int, int>> &substree_num_sat) {        \\n        int total = 0;\\n        for (const int node : neighbors[root]) {\\n            if (node == ancestor) {\\n                continue;\\n            }\\n            if (constraints[root].count(node)) {\\n                total += 1;\\n            }\\n            auto it = substree_num_sat[root].find(node);\\n            if (it != substree_num_sat[root].end()) {\\n                total += it->second;\\n            } else {\\n                const auto subtree_total = \\n                    count_num_sat(root, node, neighbors, constraints, substree_num_sat);\\n                substree_num_sat[root].insert({\\n                    node, subtree_total\\n                });  \\n                total += subtree_total;\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257631,
                "title": "c-easy-to-understand-simple-bfs-dfs-with-backtracking-traversal-approach",
                "content": "# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    ll dfs(vector<vector<int>> &adj,int root,int par,set<pair<ll,ll>> &match,set<pair<ll,ll>> &unmatch,int k)\\n    {\\n        \\n        if(match.find({par,root})!=match.end())\\n        {\\n            match.erase({par,root});\\n            unmatch.insert({par,root});\\n        }\\n        if(unmatch.find({root,par})!=unmatch.end())\\n        {\\n            match.insert({root,par});\\n            unmatch.erase({root,par});\\n        }\\n        int ans=0;\\n        if(match.size()>=k)\\n        ++ans;\\n        \\n        for(auto &x:adj[root])\\n        {\\n            if(x!=par)\\n            ans+=dfs(adj,x,root,match,unmatch,k);\\n        }\\n        if(unmatch.find({par,root})!=unmatch.end())\\n        {\\n            match.insert({par,root});\\n            unmatch.erase({par,root});\\n        }\\n        if(match.find({root,par})!=match.end())\\n        {\\n            match.erase({root,par});\\n            unmatch.insert({root,par});\\n        }\\n        return ans;\\n        \\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n=edges.size();\\n        vector<vector<int>> adj(n+1);\\n        for(auto &x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        set<pair<int,int>> st;\\n        for(auto &g:guesses)\\n        {\\n            st.insert({g[0],g[1]});\\n        }\\n        set<pair<ll,ll>> match,unmatch;\\n        queue<pair<int,int>> q;\\n        q.push({0,-1});\\n        ll level=0;\\n        while(!q.empty())\\n        {\\n          ll sz=q.size();\\n          for(ll i=0;i<sz;i++)\\n          {\\n              ll top=q.front().first;\\n              ll par=q.front().second;\\n              if(st.find({par,top})!=st.end())\\n              {\\n                  match.insert({par,top});\\n              }\\n           \\n              q.pop();      \\n              for(auto &x:adj[top])\\n              {\\n                 if(x==par)continue;\\n                  q.push({x,top});\\n              }\\n          }\\n          level++;\\n        }\\n        for(auto &z:st)\\n        {\\n            if(match.find(z)==match.end())\\n            {\\n                unmatch.insert(z);\\n            }\\n        }\\n        int ans=0;\\n        if(match.size()>=k)\\n            ++ans;\\n        int z=match.size();\\n        return dfs(adj,0,-1,match,unmatch,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    ll dfs(vector<vector<int>> &adj,int root,int par,set<pair<ll,ll>> &match,set<pair<ll,ll>> &unmatch,int k)\\n    {\\n        \\n        if(match.find({par,root})!=match.end())\\n        {\\n            match.erase({par,root});\\n            unmatch.insert({par,root});\\n        }\\n        if(unmatch.find({root,par})!=unmatch.end())\\n        {\\n            match.insert({root,par});\\n            unmatch.erase({root,par});\\n        }\\n        int ans=0;\\n        if(match.size()>=k)\\n        ++ans;\\n        \\n        for(auto &x:adj[root])\\n        {\\n            if(x!=par)\\n            ans+=dfs(adj,x,root,match,unmatch,k);\\n        }\\n        if(unmatch.find({par,root})!=unmatch.end())\\n        {\\n            match.insert({par,root});\\n            unmatch.erase({par,root});\\n        }\\n        if(match.find({root,par})!=match.end())\\n        {\\n            match.erase({root,par});\\n            unmatch.insert({root,par});\\n        }\\n        return ans;\\n        \\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n=edges.size();\\n        vector<vector<int>> adj(n+1);\\n        for(auto &x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        set<pair<int,int>> st;\\n        for(auto &g:guesses)\\n        {\\n            st.insert({g[0],g[1]});\\n        }\\n        set<pair<ll,ll>> match,unmatch;\\n        queue<pair<int,int>> q;\\n        q.push({0,-1});\\n        ll level=0;\\n        while(!q.empty())\\n        {\\n          ll sz=q.size();\\n          for(ll i=0;i<sz;i++)\\n          {\\n              ll top=q.front().first;\\n              ll par=q.front().second;\\n              if(st.find({par,top})!=st.end())\\n              {\\n                  match.insert({par,top});\\n              }\\n           \\n              q.pop();      \\n              for(auto &x:adj[top])\\n              {\\n                 if(x==par)continue;\\n                  q.push({x,top});\\n              }\\n          }\\n          level++;\\n        }\\n        for(auto &z:st)\\n        {\\n            if(match.find(z)==match.end())\\n            {\\n                unmatch.insert(z);\\n            }\\n        }\\n        int ans=0;\\n        if(match.size()>=k)\\n            ++ans;\\n        int z=match.size();\\n        return dfs(adj,0,-1,match,unmatch,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257628,
                "title": "javascript-dfs",
                "content": "The only real insight is that when you traverse the tree from anywhere, a once correct / incorrect guess flips as you pick the node on the other side of it as the new root. All other guesses remain unchanged. So we can just sum up the total correct / incorrect guesses from any root, then DFS the tree and update the number of correct guesses as we visit each edge.\\n\\n1. Pick any node to start with as the root\\n2. DFS to figure out how many correct guesses there are from that root\\n3. DFS again, any time we go past a previously correct guess, it becomes an incorrect guess. When we go past a previously incorrect guess, it becomes a correct guess\\n\\nI think a diagram helps illustrate the point a bit.\\n\\nBlue node is a root\\nGreen arrows are correct guesses\\nRed arrows are incorrect guesses\\n\\n\\n![image](https://assets.leetcode.com/users/images/9569b267-9951-4b23-9f6b-8b4bfe842b5f_1677968949.2627468.png)\\n\\n\\nSince we don\\'t have tuples in JS, we just gotta figure out how to identify matching edges as we traverse over them. The constraints are small enough that we can encode an edge in a number - given ```nodeA``` and ```nodeB```, ```nodeA -> nodeB = nodeA * 1_000_000 + nodeB```.\\n\\n```javascript\\nvar rootCount = function (edges, guesses, k) {\\n  const lookup = new Set(guesses.map(([a, b]) => a * 1_000_000 + b));\\n  const adjList = edges.reduce((adjList, [a, b]) => {\\n    adjList[a].push(b);\\n    adjList[b].push(a);\\n    return adjList;\\n  }, new Array(edges.length + 1).fill(0).map(() => []));\\n\\n  const guessed = (a, b) => lookup.has(a * 1_000_000 + b) ? 1 : 0;\\n\\n  const getCorrect = (node, parent) =>\\n    adjList[node].reduce((total, child) =>\\n      child === parent\\n        ? total\\n        : total + guessed(node, child) + getCorrect(child, node),\\n      0);\\n\\n  const getTotal = (node, parent, correct) => (\\n    (correct >= k ? 1 : 0) +\\n    adjList[node].reduce((total, child) =>\\n      child === parent\\n        ? total\\n        : total + getTotal(child, node, correct - guessed(node, child) + guessed(child, node)),\\n      0)\\n  );\\n\\n  return getTotal(0, -1, getCorrect(0, -1));\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```nodeA```\n```nodeB```\n```nodeA -> nodeB = nodeA * 1_000_000 + nodeB```\n```javascript\\nvar rootCount = function (edges, guesses, k) {\\n  const lookup = new Set(guesses.map(([a, b]) => a * 1_000_000 + b));\\n  const adjList = edges.reduce((adjList, [a, b]) => {\\n    adjList[a].push(b);\\n    adjList[b].push(a);\\n    return adjList;\\n  }, new Array(edges.length + 1).fill(0).map(() => []));\\n\\n  const guessed = (a, b) => lookup.has(a * 1_000_000 + b) ? 1 : 0;\\n\\n  const getCorrect = (node, parent) =>\\n    adjList[node].reduce((total, child) =>\\n      child === parent\\n        ? total\\n        : total + guessed(node, child) + getCorrect(child, node),\\n      0);\\n\\n  const getTotal = (node, parent, correct) => (\\n    (correct >= k ? 1 : 0) +\\n    adjList[node].reduce((total, child) =>\\n      child === parent\\n        ? total\\n        : total + getTotal(child, node, correct - guessed(node, child) + guessed(child, node)),\\n      0)\\n  );\\n\\n  return getTotal(0, -1, getCorrect(0, -1));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3257590,
                "title": "c-java-php",
                "content": "# C++\\n```\\n#include <iostream>\\n#include <vector>\\n#include <map>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> visited;\\n    map<pair<int,int>,int> g;\\n    int dp(vector<vector<int>>& adj, int node, int par) {\\n        if (visited.count(make_pair(par, node))) {\\n            return visited[make_pair(par, node)];}\\n        int guess = g.count(make_pair(par, node));\\n        for (int i = 0; i < adj[node].size(); i++) {\\n            if (adj[node][i] != par) {\\n                guess += dp(adj, adj[node][i], node);}}\\n        return visited[make_pair(par, node)] = guess;}\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n = edges.size();\\n        for (int i = 0; i < guesses.size(); i++) {\\n            g[make_pair(guesses[i][0], guesses[i][1])] = 1;}\\n        vector<vector<int>> adj(n + 1);\\n        for (int i = 0; i < n; i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);}\\n        int count = 0;\\n        for (int i = 0; i < n + 1; i++) {\\n            int guess = dp(adj, i, -1);\\n            if (guess >= k) {\\n                count++;}}\\n        return count;}};\\n```\\n# Java\\n```\\nclass Solution {\\n    int res = 0;\\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\\n        List<Integer>[] graph = makeGraph(edges);\\n        Set<String> allGuess = new HashSet<>();\\n        Set<String> ansGuess = new HashSet<>();\\n        for(int[] guess : guesses){\\n            allGuess.add(guess[0]+\"-\"+guess[1]);}\\n        int total = DFS1(0, -1, allGuess, ansGuess, graph);\\n        DFS2(0, -1, total, k, ansGuess, allGuess, graph);\\n        return total >= k ? res + 1 : res;}\\n    private void DFS2(int node, int parent, int total, int k, Set<String> ansGuess, Set<String> allGuess, List<Integer>[] graph){\\n        int curr = total;\\n        for(int child : graph[node]){\\n            if(child == parent) continue;\\n            if(ansGuess.contains(node+\"-\"+child)){\\n                curr -= 1;}\\n            if(allGuess.contains(child+\"-\"+node)){\\n                curr += 1;}\\n            if(curr >= k) res += 1;\\n            DFS2(child, node, curr, k, ansGuess, allGuess, graph);\\n            curr = total;}}\\n    private int DFS1(int node, int parent, Set<String> allGuess, Set<String> ansGuess, List<Integer>[] graph){\\n        int count = 0;\\n        for(int child : graph[node]){\\n            if(child == parent) continue;\\n            count += DFS1(child, node, allGuess, ansGuess, graph);}\\n        if(allGuess.contains(parent+\"-\"+node)){\\n            ansGuess.add(parent+\"-\"+node);\\n            count += 1;}\\n        return count;}\\n    private List<Integer>[] makeGraph(int[][] edges){\\n        List<Integer>[] graph = new ArrayList[edges.length + 1];\\n        for(int i=0 ; i<=edges.length ; ++i){\\n            graph[i] = new ArrayList<>();}\\n        for(int[] edge : edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);}\\n        return graph;}}\\n```\\n# PHP\\n```\\n<?php\\nclass Solution {\\n    public $visited;\\n    public $g;\\n    public function __construct() {\\n        $this->visited = array();\\n        $this->g = array();\\n    }\\n    public function dp(&$adj, $node, $par) {\\n        if (isset($this->visited[$par][$node])) {\\n            return $this->visited[$par][$node];\\n        }\\n        $guess = isset($this->g[$par][$node]) ? $this->g[$par][$node] : 0;\\n        foreach ($adj[$node] as $i => $child) {\\n            if ($child != $par) {\\n                $guess += $this->dp($adj, $child, $node);\\n            }\\n        }\\n        return $this->visited[$par][$node] = $guess;\\n    }\\n    public function rootCount(&$edges, &$guesses, $k) {\\n        $n = count($edges);\\n        foreach ($guesses as $guess) {\\n            $this->g[$guess[0]][$guess[1]] = 1;\\n        }\\n        $adj = array();\\n        for ($i = 0; $i < $n; $i++) {\\n            $adj[$edges[$i][0]][] = $edges[$i][1];\\n            $adj[$edges[$i][1]][] = $edges[$i][0];\\n        }\\n        $count = 0;\\n        for ($i = 0; $i < $n + 1; $i++) {\\n            $guess = $this->dp($adj, $i, -1);\\n            if ($guess >= $k) {\\n                $count++;\\n            }\\n        }\\n        return $count;\\n    }\\n}\\n?>\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "PHP"
                ],
                "code": "```\\n#include <iostream>\\n#include <vector>\\n#include <map>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> visited;\\n    map<pair<int,int>,int> g;\\n    int dp(vector<vector<int>>& adj, int node, int par) {\\n        if (visited.count(make_pair(par, node))) {\\n            return visited[make_pair(par, node)];}\\n        int guess = g.count(make_pair(par, node));\\n        for (int i = 0; i < adj[node].size(); i++) {\\n            if (adj[node][i] != par) {\\n                guess += dp(adj, adj[node][i], node);}}\\n        return visited[make_pair(par, node)] = guess;}\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n = edges.size();\\n        for (int i = 0; i < guesses.size(); i++) {\\n            g[make_pair(guesses[i][0], guesses[i][1])] = 1;}\\n        vector<vector<int>> adj(n + 1);\\n        for (int i = 0; i < n; i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);}\\n        int count = 0;\\n        for (int i = 0; i < n + 1; i++) {\\n            int guess = dp(adj, i, -1);\\n            if (guess >= k) {\\n                count++;}}\\n        return count;}};\\n```\n```\\nclass Solution {\\n    int res = 0;\\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\\n        List<Integer>[] graph = makeGraph(edges);\\n        Set<String> allGuess = new HashSet<>();\\n        Set<String> ansGuess = new HashSet<>();\\n        for(int[] guess : guesses){\\n            allGuess.add(guess[0]+\"-\"+guess[1]);}\\n        int total = DFS1(0, -1, allGuess, ansGuess, graph);\\n        DFS2(0, -1, total, k, ansGuess, allGuess, graph);\\n        return total >= k ? res + 1 : res;}\\n    private void DFS2(int node, int parent, int total, int k, Set<String> ansGuess, Set<String> allGuess, List<Integer>[] graph){\\n        int curr = total;\\n        for(int child : graph[node]){\\n            if(child == parent) continue;\\n            if(ansGuess.contains(node+\"-\"+child)){\\n                curr -= 1;}\\n            if(allGuess.contains(child+\"-\"+node)){\\n                curr += 1;}\\n            if(curr >= k) res += 1;\\n            DFS2(child, node, curr, k, ansGuess, allGuess, graph);\\n            curr = total;}}\\n    private int DFS1(int node, int parent, Set<String> allGuess, Set<String> ansGuess, List<Integer>[] graph){\\n        int count = 0;\\n        for(int child : graph[node]){\\n            if(child == parent) continue;\\n            count += DFS1(child, node, allGuess, ansGuess, graph);}\\n        if(allGuess.contains(parent+\"-\"+node)){\\n            ansGuess.add(parent+\"-\"+node);\\n            count += 1;}\\n        return count;}\\n    private List<Integer>[] makeGraph(int[][] edges){\\n        List<Integer>[] graph = new ArrayList[edges.length + 1];\\n        for(int i=0 ; i<=edges.length ; ++i){\\n            graph[i] = new ArrayList<>();}\\n        for(int[] edge : edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);}\\n        return graph;}}\\n```\n```\\n<?php\\nclass Solution {\\n    public $visited;\\n    public $g;\\n    public function __construct() {\\n        $this->visited = array();\\n        $this->g = array();\\n    }\\n    public function dp(&$adj, $node, $par) {\\n        if (isset($this->visited[$par][$node])) {\\n            return $this->visited[$par][$node];\\n        }\\n        $guess = isset($this->g[$par][$node]) ? $this->g[$par][$node] : 0;\\n        foreach ($adj[$node] as $i => $child) {\\n            if ($child != $par) {\\n                $guess += $this->dp($adj, $child, $node);\\n            }\\n        }\\n        return $this->visited[$par][$node] = $guess;\\n    }\\n    public function rootCount(&$edges, &$guesses, $k) {\\n        $n = count($edges);\\n        foreach ($guesses as $guess) {\\n            $this->g[$guess[0]][$guess[1]] = 1;\\n        }\\n        $adj = array();\\n        for ($i = 0; $i < $n; $i++) {\\n            $adj[$edges[$i][0]][] = $edges[$i][1];\\n            $adj[$edges[$i][1]][] = $edges[$i][0];\\n        }\\n        $count = 0;\\n        for ($i = 0; $i < $n + 1; $i++) {\\n            $guess = $this->dp($adj, $i, -1);\\n            if ($guess >= $k) {\\n                $count++;\\n            }\\n        }\\n        return $count;\\n    }\\n}\\n?>\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3257489,
                "title": "python-rerooting-o-n",
                "content": "# Intuition\\nFirst, simplify the problem into one fixed root problem -- given a fixed root vertex i, can we check if this has `correct_guesses >= k`? This can be done in $O(n)$. Now, can we use this information for other roots? \\n\\nThe important realizations are:\\n1. given a root node, the tree is fixed (by fixed, I mean each node has a fixed parent)\\n2. Suppose $j$ is a neighbor of $i$. Then the number of correct guesses can only change by the following when we do rerooting (original root is $i$, now root becomes $j$)\\n    a. if we guessed that $i$ is the root of $j$, which was correct for the rooted tree at $i$, now this guess is incorrect, so current guess number goes down by one\\n    b. if we gussed that $j$ is the root of $i$, which was incorrect for the rooted tree at $j$, now this guess is correct, so current guess number goes up by one\\n\\n\\n\\n# Approach\\nTherefore, we first root the tree at any vertex (pick 0 here). After we have computed the number of correct guesses for the rooted tree at $0$ (using dfs we can find the dependency relationship for the rooted tree at $0$ stored in the array parents), we can transfer the root using DFS/BFS (called rerooting). \\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.parents = [] # parents[i] is the parent of the vertex i for the current rooted tree, assuming this is a global variable\\n        self.adj = collections.defaultdict(list)  \\n        self.n = 0\\n        self.ans = 0\\n        self.k = 0\\n        self.guess = collections.defaultdict(set)\\n    def dfs1(self, node, parent):\\n        if (parent != -1):\\n            self.parents[node] = parent\\n        for child in self.adj[node]:\\n            if child == parent:\\n                continue\\n            self.dfs1(child, node)\\n\\n    def dfs2(self, node, parent, correct):\\n        curr = correct\\n        if parent in self.guess[node]:\\n            curr += 1\\n        if node in self.guess[parent]:\\n            curr -= 1\\n        if curr >= self.k:\\n            self.ans += 1\\n        for child in self.adj[node]:\\n            if child == parent:\\n                continue\\n            self.dfs2(child, node, curr) \\n\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        # build the edge graph\\n        self.n = len(edges) + 1\\n        self.parents = [-1] * self.n\\n        self.k = k\\n        for u, v in edges:\\n            self.adj[u].append(v)\\n            self.adj[v].append(u)\\n\\n        # build the guess graph\\n\\n        for u,v in guesses:\\n            self.guess[u].add(v)\\n\\n        # pick vertex 0 as the parent, fill the parents array\\n        self.dfs1(0, -1) \\n        correct = 0 \\n        # compute the number of correct guesses\\n        for u,v in guesses:\\n            if self.parents[v] == u:\\n               correct += 1\\n        if correct >= self.k:\\n            self.ans += 1\\n        for child in self.adj[0]:\\n            self.dfs2(child, 0, correct)\\n\\n        return self.ans\\n        # rerooting the tree by dfs \\n\\nCredit to https://leetcode.com/problems/count-number-of-possible-root-nodes/solutions/3256065/re-rooting-on-explained/\\nI thought of rerooting in the contest but didn\\'t have time to finish it...\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.parents = [] # parents[i] is the parent of the vertex i for the current rooted tree, assuming this is a global variable\\n        self.adj = collections.defaultdict(list)  \\n        self.n = 0\\n        self.ans = 0\\n        self.k = 0\\n        self.guess = collections.defaultdict(set)\\n    def dfs1(self, node, parent):\\n        if (parent != -1):\\n            self.parents[node] = parent\\n        for child in self.adj[node]:\\n            if child == parent:\\n                continue\\n            self.dfs1(child, node)\\n\\n    def dfs2(self, node, parent, correct):\\n        curr = correct\\n        if parent in self.guess[node]:\\n            curr += 1\\n        if node in self.guess[parent]:\\n            curr -= 1\\n        if curr >= self.k:\\n            self.ans += 1\\n        for child in self.adj[node]:\\n            if child == parent:\\n                continue\\n            self.dfs2(child, node, curr) \\n\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        # build the edge graph\\n        self.n = len(edges) + 1\\n        self.parents = [-1] * self.n\\n        self.k = k\\n        for u, v in edges:\\n            self.adj[u].append(v)\\n            self.adj[v].append(u)\\n\\n        # build the guess graph\\n\\n        for u,v in guesses:\\n            self.guess[u].add(v)\\n\\n        # pick vertex 0 as the parent, fill the parents array\\n        self.dfs1(0, -1) \\n        correct = 0 \\n        # compute the number of correct guesses\\n        for u,v in guesses:\\n            if self.parents[v] == u:\\n               correct += 1\\n        if correct >= self.k:\\n            self.ans += 1\\n        for child in self.adj[0]:\\n            self.dfs2(child, 0, correct)\\n\\n        return self.ans\\n        # rerooting the tree by dfs \\n\\nCredit to https://leetcode.com/problems/count-number-of-possible-root-nodes/solutions/3256065/re-rooting-on-explained/\\nI thought of rerooting in the contest but didn\\'t have time to finish it...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257418,
                "title": "super-ez-python-dfs-recursion",
                "content": "```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        \"\"\"\\n            [[1,3],[0,1],[1,0],[2,4]] in these guesses, k=3 means \"atleast\" 3 of them are corect, so there can be 0 or 1 wrong guess, ie guesses >= 3 are considered valid guess\\n            \\n            return the number of possible nodes that can be the root of tree\\n            \\n            guesses = [3,4] means is 3 parent of 4\\n        \"\"\"\\n        \\n        g = defaultdict(set)\\n        nodes = set()\\n        \\n        for u, v in edges:\\n            nodes.add(u)\\n            nodes.add(v)\\n            \\n            g[u].add(v)\\n            g[v].add(u)\\n        \\n        \\n        \\n        guesses_set = set(map(tuple, guesses ))\\n        \\n        @cache\\n        def dp_dfs(curr_node, parent):\\n            \\n            curr_guess = 0\\n            if (parent, curr_node) in guesses_set:\\n                curr_guess = 1\\n            \\n            for neig in g[curr_node]:\\n                if neig == parent: continue\\n                curr_guess += dp_dfs(neig, curr_node)\\n            \\n            return curr_guess\\n    \\n        ans = 0\\n        for node in nodes:\\n            res = dp_dfs(node, -1)\\n            if res >= k:\\n                ans += 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        \"\"\"\\n            [[1,3],[0,1],[1,0],[2,4]] in these guesses, k=3 means \"atleast\" 3 of them are corect, so there can be 0 or 1 wrong guess, ie guesses >= 3 are considered valid guess\\n            \\n            return the number of possible nodes that can be the root of tree\\n            \\n            guesses = [3,4] means is 3 parent of 4\\n        \"\"\"\\n        \\n        g = defaultdict(set)\\n        nodes = set()\\n        \\n        for u, v in edges:\\n            nodes.add(u)\\n            nodes.add(v)\\n            \\n            g[u].add(v)\\n            g[v].add(u)\\n        \\n        \\n        \\n        guesses_set = set(map(tuple, guesses ))\\n        \\n        @cache\\n        def dp_dfs(curr_node, parent):\\n            \\n            curr_guess = 0\\n            if (parent, curr_node) in guesses_set:\\n                curr_guess = 1\\n            \\n            for neig in g[curr_node]:\\n                if neig == parent: continue\\n                curr_guess += dp_dfs(neig, curr_node)\\n            \\n            return curr_guess\\n    \\n        ans = 0\\n        for node in nodes:\\n            res = dp_dfs(node, -1)\\n            if res >= k:\\n                ans += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257412,
                "title": "golang-solution",
                "content": "# Approach\\nLet\\'s fix the root to 0. First find how many guesses are correct when the root is fixed to 0. This will be our initial correct guesses count. \\nAfter that we need to traverse the tree again, while we traverse the tree second time, we consider every node for a possible root. If the tree was 0->1->2, when we are at 1 notice that the edge between parent(0) and child(1) needs to be reversed for 1 to be the root. We had the initial count of correct guesses, if the edge 0->1 was a correct guess we have to decrease the correct guess count by 1 and if the reverse edge is in the guesses we need to increment correct guess count by 1 and compare it with k to check if the node can be a root. Used two variables count,reverse to make this more intuitive.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar res int\\nfunc rootCount(edges [][]int, guesses [][]int, k int) int {\\n    res = 0\\n    adjList := make([][]int, len(edges)+1)\\n    // Make the adjancency list\\n    for _, edge := range edges {\\n        adjList[edge[0]] = append(adjList[edge[0]], edge[1])\\n        adjList[edge[1]] = append(adjList[edge[1]], edge[0])\\n    }\\n    \\n    visited := map[int]bool{0 : true}\\n    guessSet := make(map[pair]bool)\\n    // Add the guesses to the guess set\\n    for _, guess := range guesses {\\n        guessSet[pair{first: guess[0], second: guess[1]}] = true\\n    }\\n    \\n    // Assume 0 is the root, find how many guesses are correct.\\n    count := findCount(0, adjList, visited, guessSet)\\n    visited = map[int]bool{0 : true}\\n    // Starting from 0 traverse the tree and check if the guess for reverted edge exists.\\n    traverse(0, count, 0, k, adjList, visited, guessSet)\\n    return res\\n}\\n\\nfunc findCount(node int, adjList [][]int, visited map[int]bool, guesses map[pair]bool) int {\\n    var count int\\n    for _, nei := range adjList[node] {\\n        if !visited[nei] {\\n            visited[nei] = true\\n            if guesses[pair{first: node, second: nei}] {\\n                count++\\n            }\\n            count += findCount(nei, adjList, visited, guesses)\\n        }\\n    }\\n    return count\\n}\\n\\nfunc traverse(node, count, reverse, k int, adjList [][]int, visited map[int]bool, guesses map[pair]bool) {\\n    for _, nei := range adjList[node] {\\n        if !visited[nei] {\\n            visited[nei] = true\\n            rev, c := reverse, count\\n            if guesses[pair{first: nei, second: node}] {\\n                rev++\\n            }\\n            if guesses[pair{first: node, second: nei}] {\\n                c--\\n            }\\n            traverse(nei, c, rev, k, adjList, visited, guesses)\\n        }\\n    }\\n    if count + reverse >= k {\\n        res++\\n    }\\n}\\n\\ntype pair struct {\\n    first int\\n    second int\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nvar res int\\nfunc rootCount(edges [][]int, guesses [][]int, k int) int {\\n    res = 0\\n    adjList := make([][]int, len(edges)+1)\\n    // Make the adjancency list\\n    for _, edge := range edges {\\n        adjList[edge[0]] = append(adjList[edge[0]], edge[1])\\n        adjList[edge[1]] = append(adjList[edge[1]], edge[0])\\n    }\\n    \\n    visited := map[int]bool{0 : true}\\n    guessSet := make(map[pair]bool)\\n    // Add the guesses to the guess set\\n    for _, guess := range guesses {\\n        guessSet[pair{first: guess[0], second: guess[1]}] = true\\n    }\\n    \\n    // Assume 0 is the root, find how many guesses are correct.\\n    count := findCount(0, adjList, visited, guessSet)\\n    visited = map[int]bool{0 : true}\\n    // Starting from 0 traverse the tree and check if the guess for reverted edge exists.\\n    traverse(0, count, 0, k, adjList, visited, guessSet)\\n    return res\\n}\\n\\nfunc findCount(node int, adjList [][]int, visited map[int]bool, guesses map[pair]bool) int {\\n    var count int\\n    for _, nei := range adjList[node] {\\n        if !visited[nei] {\\n            visited[nei] = true\\n            if guesses[pair{first: node, second: nei}] {\\n                count++\\n            }\\n            count += findCount(nei, adjList, visited, guesses)\\n        }\\n    }\\n    return count\\n}\\n\\nfunc traverse(node, count, reverse, k int, adjList [][]int, visited map[int]bool, guesses map[pair]bool) {\\n    for _, nei := range adjList[node] {\\n        if !visited[nei] {\\n            visited[nei] = true\\n            rev, c := reverse, count\\n            if guesses[pair{first: nei, second: node}] {\\n                rev++\\n            }\\n            if guesses[pair{first: node, second: nei}] {\\n                c--\\n            }\\n            traverse(nei, c, rev, k, adjList, visited, guesses)\\n        }\\n    }\\n    if count + reverse >= k {\\n        res++\\n    }\\n}\\n\\ntype pair struct {\\n    first int\\n    second int\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3257366,
                "title": "two-dfs-traversal-o-v-e-clean-code-explanation-java",
                "content": "# Intuition\\nThink about how to find neighbor node answers with the current node answer.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIn the First DFS traversal, we find out the solution for one node(eg. node 0) and maintained correct guesses in a hash set of strings.\\nNow In the second DFS traversal, we started with the same node and check 2 things.\\n1. If the edge exists in the correct guess then remove this edge. (Subtract 1).\\n2. Add reverse edge, If reverse edge exists in all guesses then add 1.\\n3. If the count is greater than or equal to k then is node is a valid candidate for the root node.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(V + E)\\nBecause we only traversed the graph 2 times and complexity of graph traversal is O(V + E). V mean number of Vertices and E means number of Edges.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V + E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int res = 0;\\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\\n        List<Integer>[] graph = makeGraph(edges);\\n        Set<String> allGuess = new HashSet<>();\\n        Set<String> ansGuess = new HashSet<>();\\n        for(int[] guess : guesses){\\n            allGuess.add(guess[0]+\"-\"+guess[1]);\\n        }\\n        int total = DFS1(0, -1, allGuess, ansGuess, graph);   // Result for node 0.\\n        DFS2(0, -1, total, k, ansGuess, allGuess, graph);    // Finding result of all other node from result of node zero.\\n        return total >= k ? res + 1 : res;             // This condition is for starting node (node 0).\\n    }\\n    private void DFS2(int node, int parent, int total, int k, Set<String> ansGuess, Set<String> allGuess, List<Integer>[] graph){\\n        int curr = total;\\n        for(int child : graph[node]){\\n            if(child == parent) continue;\\n            if(ansGuess.contains(node+\"-\"+child)){\\n                curr -= 1;\\n            }\\n            if(allGuess.contains(child+\"-\"+node)){\\n                curr += 1;\\n            }\\n            if(curr >= k) res += 1;\\n            DFS2(child, node, curr, k, ansGuess, allGuess, graph);\\n            curr = total;\\n        }\\n    }\\n    private int DFS1(int node, int parent, Set<String> allGuess, Set<String> ansGuess, List<Integer>[] graph){\\n        int count = 0;\\n        for(int child : graph[node]){\\n            if(child == parent) continue;\\n            count += DFS1(child, node, allGuess, ansGuess, graph);\\n        }\\n        if(allGuess.contains(parent+\"-\"+node)){\\n            ansGuess.add(parent+\"-\"+node);\\n            count += 1;\\n        }\\n        return count;\\n    }\\n    private List<Integer>[] makeGraph(int[][] edges){\\n        List<Integer>[] graph = new ArrayList[edges.length + 1];\\n        for(int i=0 ; i<=edges.length ; ++i){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int[] edge : edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        return graph;\\n    }\\n}\\n```\\nFeel free to correct me or ask any doubt. \\nIf you like the code then Please upvote me :)",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    public int rootCount(int[][] edges, int[][] guesses, int k) {\\n        List<Integer>[] graph = makeGraph(edges);\\n        Set<String> allGuess = new HashSet<>();\\n        Set<String> ansGuess = new HashSet<>();\\n        for(int[] guess : guesses){\\n            allGuess.add(guess[0]+\"-\"+guess[1]);\\n        }\\n        int total = DFS1(0, -1, allGuess, ansGuess, graph);   // Result for node 0.\\n        DFS2(0, -1, total, k, ansGuess, allGuess, graph);    // Finding result of all other node from result of node zero.\\n        return total >= k ? res + 1 : res;             // This condition is for starting node (node 0).\\n    }\\n    private void DFS2(int node, int parent, int total, int k, Set<String> ansGuess, Set<String> allGuess, List<Integer>[] graph){\\n        int curr = total;\\n        for(int child : graph[node]){\\n            if(child == parent) continue;\\n            if(ansGuess.contains(node+\"-\"+child)){\\n                curr -= 1;\\n            }\\n            if(allGuess.contains(child+\"-\"+node)){\\n                curr += 1;\\n            }\\n            if(curr >= k) res += 1;\\n            DFS2(child, node, curr, k, ansGuess, allGuess, graph);\\n            curr = total;\\n        }\\n    }\\n    private int DFS1(int node, int parent, Set<String> allGuess, Set<String> ansGuess, List<Integer>[] graph){\\n        int count = 0;\\n        for(int child : graph[node]){\\n            if(child == parent) continue;\\n            count += DFS1(child, node, allGuess, ansGuess, graph);\\n        }\\n        if(allGuess.contains(parent+\"-\"+node)){\\n            ansGuess.add(parent+\"-\"+node);\\n            count += 1;\\n        }\\n        return count;\\n    }\\n    private List<Integer>[] makeGraph(int[][] edges){\\n        List<Integer>[] graph = new ArrayList[edges.length + 1];\\n        for(int i=0 ; i<=edges.length ; ++i){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int[] edge : edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        return graph;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257335,
                "title": "bfs-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n          map<pair<int,int>,int>m;\\n        for(auto it: guesses) {\\n            m[{it[0], it[1]}]++;\\n        }\\n        \\n        int n = edges.size() + 1;\\n        vector<vector<int>>adj(n+1);\\n        \\n        for(auto it: edges) {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        queue<int>q;\\n        q.push(0);\\n        vector<int>vis(n+1, 0) , xi(n+1,0);\\n        vis[0] = 1;\\n        while(q.size()) {\\n            int x = q.front();\\n            q.pop();\\n            vis[x] = 1;\\n            for(auto it: adj[x]) {\\n                if(!vis[it]) {\\n                    if(m.count({x, it})) {\\n                       xi[0]++;\\n                   }\\n                    q.push(it);\\n                }\\n            } \\n        }\\n        \\n        q.push(0);\\n        for(int i=0; i <= n; i++) {\\n            vis[i] = 0;\\n        }\\n        while(q.size()) {\\n            int x = q.front();\\n            q.pop();\\n            vis[x] = 1;\\n            for(auto it: adj[x]) {\\n                if(!vis[it]) {\\n                    xi[it] = xi[x];\\n                    if(m.count({it, x})) {\\n                       xi[it]++;\\n                    }\\n                    if(m.count({x, it})) {\\n                        xi[it]--;\\n                    }\\n                    q.push(it);\\n                }\\n            } \\n        }\\n        \\n        int a = 0;\\n        for(int i=0; i<n; i++) {\\n            if(xi[i] >= k) {\\n                a++;\\n            } \\n        }\\n        return a;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n          map<pair<int,int>,int>m;\\n        for(auto it: guesses) {\\n            m[{it[0], it[1]}]++;\\n        }\\n        \\n        int n = edges.size() + 1;\\n        vector<vector<int>>adj(n+1);\\n        \\n        for(auto it: edges) {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        queue<int>q;\\n        q.push(0);\\n        vector<int>vis(n+1, 0) , xi(n+1,0);\\n        vis[0] = 1;\\n        while(q.size()) {\\n            int x = q.front();\\n            q.pop();\\n            vis[x] = 1;\\n            for(auto it: adj[x]) {\\n                if(!vis[it]) {\\n                    if(m.count({x, it})) {\\n                       xi[0]++;\\n                   }\\n                    q.push(it);\\n                }\\n            } \\n        }\\n        \\n        q.push(0);\\n        for(int i=0; i <= n; i++) {\\n            vis[i] = 0;\\n        }\\n        while(q.size()) {\\n            int x = q.front();\\n            q.pop();\\n            vis[x] = 1;\\n            for(auto it: adj[x]) {\\n                if(!vis[it]) {\\n                    xi[it] = xi[x];\\n                    if(m.count({it, x})) {\\n                       xi[it]++;\\n                    }\\n                    if(m.count({x, it})) {\\n                        xi[it]--;\\n                    }\\n                    q.push(it);\\n                }\\n            } \\n        }\\n        \\n        int a = 0;\\n        for(int i=0; i<n; i++) {\\n            if(xi[i] >= k) {\\n                a++;\\n            } \\n        }\\n        return a;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257149,
                "title": "dynamic-programing-solution-dp-dfs-easy-implementation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    map<pair<int, int>, int> mp;\\n    vector<vector<int> > adj;\\n    vector<int> dp;\\n\\n    // For the subtree under node i\\n    void dfs(int i, int par){\\n        for (int &j:adj[i]){\\n            if (j == par) continue;\\n            dfs(j, i);\\n            dp[i] += mp[{i, j}] + dp[j];\\n        }\\n    }\\n    \\n    // Includes the subtrees from above and from below\\n    void dfs2(int i, int par){\\n        dp[i] = dp[par] - (mp[{par, i}] - mp[{i, par}]); \\n        \\n        for (int &j:adj[i])\\n            if (j != par)\\n                dfs2(j, i);\\n    }\\n        \\n    int rootCount(vector<vector<int>>& ed, vector<vector<int>>& gs, int k) {\\n        int n = ed.size() + 1;\\n        int res = 0;\\n        adj.resize(n);\\n        dp.resize(n);\\n        \\n        for (vector<int> &e:ed){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        for (vector<int> &e:gs)\\n            mp[{e[0], e[1]}]++;\\n        \\n        dfs(0, -1);\\n        for (int j:adj[0])\\n            dfs2(j, 0);\\n\\n        for (int i:dp)\\n            if (i >= k) \\n                res++;\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int, int>, int> mp;\\n    vector<vector<int> > adj;\\n    vector<int> dp;\\n\\n    // For the subtree under node i\\n    void dfs(int i, int par){\\n        for (int &j:adj[i]){\\n            if (j == par) continue;\\n            dfs(j, i);\\n            dp[i] += mp[{i, j}] + dp[j];\\n        }\\n    }\\n    \\n    // Includes the subtrees from above and from below\\n    void dfs2(int i, int par){\\n        dp[i] = dp[par] - (mp[{par, i}] - mp[{i, par}]); \\n        \\n        for (int &j:adj[i])\\n            if (j != par)\\n                dfs2(j, i);\\n    }\\n        \\n    int rootCount(vector<vector<int>>& ed, vector<vector<int>>& gs, int k) {\\n        int n = ed.size() + 1;\\n        int res = 0;\\n        adj.resize(n);\\n        dp.resize(n);\\n        \\n        for (vector<int> &e:ed){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        for (vector<int> &e:gs)\\n            mp[{e[0], e[1]}]++;\\n        \\n        dfs(0, -1);\\n        for (int j:adj[0])\\n            dfs2(j, 0);\\n\\n        for (int i:dp)\\n            if (i >= k) \\n                res++;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257035,
                "title": "c-simple-intuitive-approach-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n      vector<int> right,wrong,vis;\\n            map<vector<int>,bool> mp;\\n    int dfs(int node,vector<int> adj[],int r,int w){\\n        // cout<<node<<\" \"<<r<<\" \"<<w<<\"\\\\n\";\\n        vis[node]=1;\\n        right[node]=r;\\n        wrong[node]=w;\\n        int ans=0;\\n       \\n        for(auto c:adj[node]){\\n             int k=r,j=w;\\n            if(!vis [c]){\\n                if(mp.find({node,c})!=mp.end() && mp[{node,c}])\\n                {\\n                    // cout<<node<<\" r  \"<<c<<\"\\\\n\";\\n                 ans++;k+=1;}\\n                if( mp.find({c,node})!=mp.end() &&  mp[{c,node}]){\\n                    // cout<<node<<\" w \"<<c<<\"\\\\n\";\\n                    j+=1;}\\n                // cout<<c<<\" \"<<k<<\" \"<<j<<\"\\\\n\";\\n                auto p =dfs(c,adj,k,j);\\n                ans+=p;\\n                // ans.second+=p.second;\\n            }\\n        }\\n        return ans;\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n=edges.size()+1;\\n        vector<int> adj[n];\\n        for(auto e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        mp.clear();\\n        for(auto g:guesses)\\n            mp[g]=1;\\n        vis.resize(n,0);\\n        right.resize(n,0);\\n        wrong.resize(n,0);\\n       auto p= dfs(0,adj,0,0);\\n     // cout<<p<<\"\\\\n\";\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            // cout<<i<<\" \"<<right[i]<<\" \"<<wrong[i]<<\"\\\\n\";\\n            if(p + wrong[i] - right[i]>=k) ans++; \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      vector<int> right,wrong,vis;\\n            map<vector<int>,bool> mp;\\n    int dfs(int node,vector<int> adj[],int r,int w){\\n        // cout<<node<<\" \"<<r<<\" \"<<w<<\"\\\\n\";\\n        vis[node]=1;\\n        right[node]=r;\\n        wrong[node]=w;\\n        int ans=0;\\n       \\n        for(auto c:adj[node]){\\n             int k=r,j=w;\\n            if(!vis [c]){\\n                if(mp.find({node,c})!=mp.end() && mp[{node,c}])\\n                {\\n                    // cout<<node<<\" r  \"<<c<<\"\\\\n\";\\n                 ans++;k+=1;}\\n                if( mp.find({c,node})!=mp.end() &&  mp[{c,node}]){\\n                    // cout<<node<<\" w \"<<c<<\"\\\\n\";\\n                    j+=1;}\\n                // cout<<c<<\" \"<<k<<\" \"<<j<<\"\\\\n\";\\n                auto p =dfs(c,adj,k,j);\\n                ans+=p;\\n                // ans.second+=p.second;\\n            }\\n        }\\n        return ans;\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n=edges.size()+1;\\n        vector<int> adj[n];\\n        for(auto e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        mp.clear();\\n        for(auto g:guesses)\\n            mp[g]=1;\\n        vis.resize(n,0);\\n        right.resize(n,0);\\n        wrong.resize(n,0);\\n       auto p= dfs(0,adj,0,0);\\n     // cout<<p<<\"\\\\n\";\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            // cout<<i<<\" \"<<right[i]<<\" \"<<wrong[i]<<\"\\\\n\";\\n            if(p + wrong[i] - right[i]>=k) ans++; \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3256940,
                "title": "beats-100-best-solution-in-python-watch-now",
                "content": "# Intuition\\nJUST BETTER \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMY BRAIN WORKS LIKE THAT\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntc=0\\npr=defaultdict(int)\\ndef dfs(node,par,g,gs,s,rs,cnt,cntr):\\n    global tc,pr\\n    pr[node]=par\\n    # print((node,par),gs)\\n    if (par,node) in gs:\\n        tc+=1\\n        s+=1\\n    if (node,par) in gs:\\n        rs+=1\\n    cntr[node]=rs\\n    cnt[node]=s\\n    for i in g[node]:\\n        if i==par:\\n            continue\\n        dfs(i,node,g,gs,s,rs,cnt,cntr)\\n     \\n\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        gs=set([(i,j) for i,j in guesses])\\n        global tc,pr\\n        pr=defaultdict(int)\\n        tc=0\\n        n=len(edges)+1\\n        g=defaultdict(list)\\n        for a,b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n        cnt=[0]*n\\n        cntr=[0]*n\\n        dfs(0,-1,g,gs,0,0,cnt,cntr)\\n        # print(cnt)\\n        # print(cntr)\\n        # print(tc)\\n        # print(pr)\\n        # for i in range\\n        ans=0\\n        if tc>=k:\\n            ans=1\\n        for i in range(1,n):\\n            res=tc-cnt[i]+cntr[i]\\n            if res>=k:\\n                ans+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ntc=0\\npr=defaultdict(int)\\ndef dfs(node,par,g,gs,s,rs,cnt,cntr):\\n    global tc,pr\\n    pr[node]=par\\n    # print((node,par),gs)\\n    if (par,node) in gs:\\n        tc+=1\\n        s+=1\\n    if (node,par) in gs:\\n        rs+=1\\n    cntr[node]=rs\\n    cnt[node]=s\\n    for i in g[node]:\\n        if i==par:\\n            continue\\n        dfs(i,node,g,gs,s,rs,cnt,cntr)\\n     \\n\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        gs=set([(i,j) for i,j in guesses])\\n        global tc,pr\\n        pr=defaultdict(int)\\n        tc=0\\n        n=len(edges)+1\\n        g=defaultdict(list)\\n        for a,b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n        cnt=[0]*n\\n        cntr=[0]*n\\n        dfs(0,-1,g,gs,0,0,cnt,cntr)\\n        # print(cnt)\\n        # print(cntr)\\n        # print(tc)\\n        # print(pr)\\n        # for i in range\\n        ans=0\\n        if tc>=k:\\n            ans=1\\n        for i in range(1,n):\\n            res=tc-cnt[i]+cntr[i]\\n            if res>=k:\\n                ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256935,
                "title": "count-number-of-possible-root-nodes-c-dp-on-trees-indp-outdp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void indfs(int node, int par, vector<vector<int>> &g, vector<int> &indp, set<vector<int>> &st){\\n        indp[node]=0;\\n        if(st.find({par,node}) != st.end()) indp[node]=1;\\n        for(auto x : g[node]){\\n            if(x!=par){\\n                indfs(x,node,g,indp,st);\\n                indp[node]+=indp[x];\\n            }\\n        }\\n    }\\n    void outdfs(int node, int par, vector<vector<int>> &g, vector<int> &outdp, set<vector<int>> &st, vector<int> &indp){\\n        if(par==-1){\\n            outdp[node]=0;\\n        }else{\\n            int cnt1 = 0; // to be subtracted\\n            if(st.find({par,node}) != st.end()) cnt1=1; // check whether par->node edge exist\\n            int cnt2 = 0; // to be added\\n            if(st.find({node,par}) != st.end()) cnt2 = 1;// check whether node->par edge exist\\n            outdp[node]=(outdp[par]+indp[par]-(indp[node]+cnt1)+cnt2);\\n        }\\n        for(auto x: g[node]){\\n            if(x!=par)\\n            outdfs(x,node,g,outdp,st,indp);\\n        }\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n = edges.size() + 1;\\n        vector<vector<int>> g(n);\\n        for(auto x: edges){\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n        }\\n        set<vector<int>> st;\\n        for(auto x: guesses){\\n            st.insert(x);\\n        }\\n        vector<int> indp(n,0),outdp(n,0);\\n        indfs(0,-1,g,indp,st);\\n        outdfs(0,-1,g,outdp,st,indp);\\n        int ans = 0;\\n\\n        for(int i=0; i<n; i++){\\n            // cout<<indp[i]<<\" \"<<outdp[i]<<endl;\\n            if(indp[i]+outdp[i]>=k) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void indfs(int node, int par, vector<vector<int>> &g, vector<int> &indp, set<vector<int>> &st){\\n        indp[node]=0;\\n        if(st.find({par,node}) != st.end()) indp[node]=1;\\n        for(auto x : g[node]){\\n            if(x!=par){\\n                indfs(x,node,g,indp,st);\\n                indp[node]+=indp[x];\\n            }\\n        }\\n    }\\n    void outdfs(int node, int par, vector<vector<int>> &g, vector<int> &outdp, set<vector<int>> &st, vector<int> &indp){\\n        if(par==-1){\\n            outdp[node]=0;\\n        }else{\\n            int cnt1 = 0; // to be subtracted\\n            if(st.find({par,node}) != st.end()) cnt1=1; // check whether par->node edge exist\\n            int cnt2 = 0; // to be added\\n            if(st.find({node,par}) != st.end()) cnt2 = 1;// check whether node->par edge exist\\n            outdp[node]=(outdp[par]+indp[par]-(indp[node]+cnt1)+cnt2);\\n        }\\n        for(auto x: g[node]){\\n            if(x!=par)\\n            outdfs(x,node,g,outdp,st,indp);\\n        }\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n = edges.size() + 1;\\n        vector<vector<int>> g(n);\\n        for(auto x: edges){\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n        }\\n        set<vector<int>> st;\\n        for(auto x: guesses){\\n            st.insert(x);\\n        }\\n        vector<int> indp(n,0),outdp(n,0);\\n        indfs(0,-1,g,indp,st);\\n        outdfs(0,-1,g,outdp,st,indp);\\n        int ans = 0;\\n\\n        for(int i=0; i<n; i++){\\n            // cout<<indp[i]<<\" \"<<outdp[i]<<endl;\\n            if(indp[i]+outdp[i]>=k) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3256796,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the number of the nodes of the tree represented by `edges`\\n */\\nclass Solution {\\n public:\\n  int rootCount(const vector<vector<int>> &edges, const vector<vector<int>> &guesses, const int k) {\\n    const int n = static_cast<int>(edges.size()) + 1;\\n    vector<int> tree[n];\\n    for (const vector<int> &edge : edges) {\\n      tree[edge[0]].emplace_back(edge[1]);\\n      tree[edge[1]].emplace_back(edge[0]);\\n    }\\n    \\n    unordered_set<int> all_guesses[n];\\n    for (const vector<int> &guess : guesses) {\\n      all_guesses[guess[0]].emplace(guess[1]);\\n    }\\n    \\n    int count = 0;\\n    dfs_count_root_0(tree, 0, -1, all_guesses, count);\\n    \\n    int counts[n];\\n    memset(counts, 0, sizeof(counts));\\n    counts[0] = count;\\n    dfs_traverse_tree(tree, 0, -1, all_guesses, counts);\\n    \\n    int ret = 0;\\n    for (const int c : counts) {\\n      if (c >= k) {\\n        ++ret;\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  void dfs_count_root_0(const vector<int> *tree,\\n                        const int node,\\n                        const int parent,\\n                        const unordered_set<int> *all_guesses,\\n                        int &count) {\\n    if (parent != -1) {\\n      if (exists(all_guesses, parent, node)) {\\n        ++count;\\n      }\\n    }\\n    for (const int child : tree[node]) {\\n      if (child == parent) {\\n        continue;\\n      }\\n      dfs_count_root_0(tree, child, node, all_guesses, count);\\n    }\\n  }\\n  \\n  void dfs_traverse_tree(const vector<int> *tree,\\n                         const int node,\\n                         const int parent,\\n                         const unordered_set<int> *all_guesses,\\n                         int *counts) {\\n    if (parent != -1) {\\n      int count = counts[parent];\\n      if (exists(all_guesses, parent, node)) {\\n        --count;\\n      }\\n      if (exists(all_guesses, node, parent)) {\\n        ++count;\\n      }\\n      counts[node] = count;\\n    }\\n    for (const int child : tree[node]) {\\n      if (child == parent) {\\n        continue;\\n      }\\n      dfs_traverse_tree(tree, child, node, all_guesses, counts);\\n    }\\n  }\\n  \\n  bool exists(const unordered_set<int> *all_guesses, const int parent, const int node) {\\n    const unordered_set<int> &guess = all_guesses[parent];\\n    return guess.find(node) != guess.end();\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the number of the nodes of the tree represented by `edges`\\n */\\nclass Solution {\\n public:\\n  int rootCount(const vector<vector<int>> &edges, const vector<vector<int>> &guesses, const int k) {\\n    const int n = static_cast<int>(edges.size()) + 1;\\n    vector<int> tree[n];\\n    for (const vector<int> &edge : edges) {\\n      tree[edge[0]].emplace_back(edge[1]);\\n      tree[edge[1]].emplace_back(edge[0]);\\n    }\\n    \\n    unordered_set<int> all_guesses[n];\\n    for (const vector<int> &guess : guesses) {\\n      all_guesses[guess[0]].emplace(guess[1]);\\n    }\\n    \\n    int count = 0;\\n    dfs_count_root_0(tree, 0, -1, all_guesses, count);\\n    \\n    int counts[n];\\n    memset(counts, 0, sizeof(counts));\\n    counts[0] = count;\\n    dfs_traverse_tree(tree, 0, -1, all_guesses, counts);\\n    \\n    int ret = 0;\\n    for (const int c : counts) {\\n      if (c >= k) {\\n        ++ret;\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  void dfs_count_root_0(const vector<int> *tree,\\n                        const int node,\\n                        const int parent,\\n                        const unordered_set<int> *all_guesses,\\n                        int &count) {\\n    if (parent != -1) {\\n      if (exists(all_guesses, parent, node)) {\\n        ++count;\\n      }\\n    }\\n    for (const int child : tree[node]) {\\n      if (child == parent) {\\n        continue;\\n      }\\n      dfs_count_root_0(tree, child, node, all_guesses, count);\\n    }\\n  }\\n  \\n  void dfs_traverse_tree(const vector<int> *tree,\\n                         const int node,\\n                         const int parent,\\n                         const unordered_set<int> *all_guesses,\\n                         int *counts) {\\n    if (parent != -1) {\\n      int count = counts[parent];\\n      if (exists(all_guesses, parent, node)) {\\n        --count;\\n      }\\n      if (exists(all_guesses, node, parent)) {\\n        ++count;\\n      }\\n      counts[node] = count;\\n    }\\n    for (const int child : tree[node]) {\\n      if (child == parent) {\\n        continue;\\n      }\\n      dfs_traverse_tree(tree, child, node, all_guesses, counts);\\n    }\\n  }\\n  \\n  bool exists(const unordered_set<int> *all_guesses, const int parent, const int node) {\\n    const unordered_set<int> &guess = all_guesses[parent];\\n    return guess.find(node) != guess.end();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256794,
                "title": "from-intuition-to-optimal-solution-explaination",
                "content": "# Intuition\\n1. Let\\'s start from brute force , we can simply select each node as the root of the tree , then for that tree if the number of conditions satisfied >=k then that node can be selected . TC:O(n^2)\\n2. We need to focus on optimising either the root choosing part or checking the conditions part or both\\n3. lets say at some moment u node was my root , if then I decide to choose one of the children of u i.e v as the new root , how does my tree change? \\nAns: The tree remains almost same , the only change now is that v is the parent of u, that\\'s it\\n\\n\\nPart1:\\nFrom above observations , lets make a better solution. If we maintain a parent array where par[i] indicates parent of ith node\\n1. Start dfs from any node , check how many conditions does the par array satisfy and update the ans\\n2. Dfs to the child and update the parent array i.e the child now becomes the parent of its own parent \\n\\nTC:O(n^2)\\n\\nThe problem with this part is that we are spending too much time on checking the conditions , Let\\'s try to opitmise that part now\\n\\n\\nIs there some redundant thing we are doing while checking? \\nYes you got it right!!\\nWhen we are updating the parent during the dfs, we don\\'t need to check the entire parent array again as the only part that changed was the updation of parent in the current node and its child\\n\\nSo if my curr score = Su while I had u as the root\\nMy score when I make v(child node of u) the root , the new score will be\\n\\nnewScore (Sv) = Su - 1(if {u,v} was in the guess array and now we are going to change it) + 1 (if {v,u} is in the guess array)\\n\\n\\nThat\\'s it this is the solution :)\\n\\n\\n# Approach\\n1. Create the tree , and dfs from 0 and calculate the score of the tree formed\\n2. Use a set of pair where {u,v} denotes u has v as the parent in the guess array\\n3. Now create another dfs kind of function and update the score while you reroot the tree i.e select the child as the root\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > adj;\\n    set<pair<int,int> > s;\\n    int ans;\\n    \\n    int dfs(int node , int p){\\n        int score=0;\\n        if(s.find({node,p})!=s.end()) score++;\\n        for(auto v:adj[node]){\\n            if(v==p) continue;\\n            score += dfs(v,node);\\n        }\\n        return score;\\n    }\\n    \\n    void solve(int node , int p , int score , int k){\\n        if(score>=k) ans++;\\n        for(auto &v:adj[node]){\\n            if(v==p) continue;\\n            int newScore = score;\\n            if(s.find({v,node})!=s.end()) newScore--;\\n            if(s.find({node,v})!=s.end())newScore++;\\n            \\n            solve(v,node,newScore,k);\\n        }\\n    }\\n    \\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n= edges.size()+1;\\n        adj.resize(n);\\n        ans=0;\\n        \\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        \\n        for(auto &x:guesses){\\n            s.insert({x[1],x[0]});\\n        }\\n        \\n        int score = dfs(0,-1);//calculate score of the tree\\n        \\n        solve(0,-1 , score,k);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> > adj;\\n    set<pair<int,int> > s;\\n    int ans;\\n    \\n    int dfs(int node , int p){\\n        int score=0;\\n        if(s.find({node,p})!=s.end()) score++;\\n        for(auto v:adj[node]){\\n            if(v==p) continue;\\n            score += dfs(v,node);\\n        }\\n        return score;\\n    }\\n    \\n    void solve(int node , int p , int score , int k){\\n        if(score>=k) ans++;\\n        for(auto &v:adj[node]){\\n            if(v==p) continue;\\n            int newScore = score;\\n            if(s.find({v,node})!=s.end()) newScore--;\\n            if(s.find({node,v})!=s.end())newScore++;\\n            \\n            solve(v,node,newScore,k);\\n        }\\n    }\\n    \\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n= edges.size()+1;\\n        adj.resize(n);\\n        ans=0;\\n        \\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        \\n        for(auto &x:guesses){\\n            s.insert({x[1],x[0]});\\n        }\\n        \\n        int score = dfs(0,-1);//calculate score of the tree\\n        \\n        solve(0,-1 , score,k);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256737,
                "title": "python-rerooting",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        pa=defaultdict(set)\\n        g=defaultdict(list)\\n        for u,v in edges:\\n            g[u].append(v); g[v].append(u)\\n        for p,c in guesses:\\n            pa[c].add(p)\\n        vs=set()\\n        nk=0\\n        def dfs1(u,p):\\n            nonlocal nk\\n            vs.add(u)\\n            for v in g[u]:\\n                if v!=p:\\n                    for par in pa[v]:\\n                        if par in vs: nk+=1\\n                    dfs1(v,u)\\n            vs.discard(u)\\n        dfs1(0,-1)\\n        ok=0\\n        def dfs(u,p,cur):\\n            nonlocal ok\\n            if cur>=k: ok+=1\\n            for v in g[u]:\\n                if v!=p: dfs(v,u,cur+(v in pa[u])-(u in pa[v]))\\n        dfs(0,-1,nk)\\n        return ok\\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        pa=defaultdict(set)\\n        g=defaultdict(list)\\n        for u,v in edges:\\n            g[u].append(v); g[v].append(u)\\n        for p,c in guesses:\\n            pa[c].add(p)\\n        vs=set()\\n        nk=0\\n        def dfs1(u,p):\\n            nonlocal nk\\n            vs.add(u)\\n            for v in g[u]:\\n                if v!=p:\\n                    for par in pa[v]:\\n                        if par in vs: nk+=1\\n                    dfs1(v,u)\\n            vs.discard(u)\\n        dfs1(0,-1)\\n        ok=0\\n        def dfs(u,p,cur):\\n            nonlocal ok\\n            if cur>=k: ok+=1\\n            for v in g[u]:\\n                if v!=p: dfs(v,u,cur+(v in pa[u])-(u in pa[v]))\\n        dfs(0,-1,nk)\\n        return ok\\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256696,
                "title": "rust-dfs-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1) Pich a node (0) as the root, built a rooted tree using DFS and keep a count on how many of Bob guesses are right.\\n2) With the tree built, perform another DFS of backtracking on the count of how many of Bob guesses are right if next child will be used as the root as the new tree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn root_count(edges: Vec<Vec<i32>>, guesses: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let n = edges.len();\\n        let mut graph = vec![vec![]; n + 1];\\n        let mut s = HashSet::new();\\n\\n        for e in edges {\\n            graph[e[0] as usize].push(e[1] as usize);\\n            graph[e[1] as usize].push(e[0] as usize);\\n        }\\n\\n        for g in guesses { s.insert((g[0] as usize, g[1] as usize)); }\\n\\n        let mut cnt = -k;\\n        let mut flag = vec![0; n + 1];\\n        Self::dfs(0, &mut flag, &graph, &mut cnt, &s);\\n        \\n        flag = vec![0; n + 1];\\n        Self::back_tracking(0, &mut flag, &graph, &mut cnt, &s)\\n    }\\n\\n    fn back_tracking(u: usize, flag: &mut Vec<i32>, graph: &Vec<Vec<usize>>, cnt: &mut i32, s: &HashSet<(usize, usize)>) -> i32 {\\n        let mut ret = if *cnt >= 0 { 1 } else { 0 };\\n        flag[u] = 1;\\n        for v in &graph[u] {\\n            if flag[*v] == 1 { continue }\\n            \\n            flag[*v] = 1;\\n            if s.contains(&(u, *v)) { *cnt -= 1; }\\n            if s.contains(&(*v, u)) { *cnt += 1; }\\n\\n            ret += Self::back_tracking(*v, flag, graph, cnt, s);\\n            \\n            if s.contains(&(u, *v)) { *cnt += 1; }\\n            if s.contains(&(*v, u)) { *cnt -= 1; }\\n        }\\n\\n        ret\\n    }\\n\\n    fn dfs(u: usize, flag: &mut Vec<i32>, graph: &Vec<Vec<usize>>, cnt: &mut i32, s: &HashSet<(usize, usize)>) {\\n        flag[u] = 1;\\n        for v in &graph[u] {\\n            if flag[*v] == 1 { continue }\\n\\n            flag[*v] = 1;\\n            if s.contains(&(u, *v)) { *cnt += 1; }\\n            Self::dfs(*v, flag, graph, cnt, s);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn root_count(edges: Vec<Vec<i32>>, guesses: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let n = edges.len();\\n        let mut graph = vec![vec![]; n + 1];\\n        let mut s = HashSet::new();\\n\\n        for e in edges {\\n            graph[e[0] as usize].push(e[1] as usize);\\n            graph[e[1] as usize].push(e[0] as usize);\\n        }\\n\\n        for g in guesses { s.insert((g[0] as usize, g[1] as usize)); }\\n\\n        let mut cnt = -k;\\n        let mut flag = vec![0; n + 1];\\n        Self::dfs(0, &mut flag, &graph, &mut cnt, &s);\\n        \\n        flag = vec![0; n + 1];\\n        Self::back_tracking(0, &mut flag, &graph, &mut cnt, &s)\\n    }\\n\\n    fn back_tracking(u: usize, flag: &mut Vec<i32>, graph: &Vec<Vec<usize>>, cnt: &mut i32, s: &HashSet<(usize, usize)>) -> i32 {\\n        let mut ret = if *cnt >= 0 { 1 } else { 0 };\\n        flag[u] = 1;\\n        for v in &graph[u] {\\n            if flag[*v] == 1 { continue }\\n            \\n            flag[*v] = 1;\\n            if s.contains(&(u, *v)) { *cnt -= 1; }\\n            if s.contains(&(*v, u)) { *cnt += 1; }\\n\\n            ret += Self::back_tracking(*v, flag, graph, cnt, s);\\n            \\n            if s.contains(&(u, *v)) { *cnt += 1; }\\n            if s.contains(&(*v, u)) { *cnt -= 1; }\\n        }\\n\\n        ret\\n    }\\n\\n    fn dfs(u: usize, flag: &mut Vec<i32>, graph: &Vec<Vec<usize>>, cnt: &mut i32, s: &HashSet<(usize, usize)>) {\\n        flag[u] = 1;\\n        for v in &graph[u] {\\n            if flag[*v] == 1 { continue }\\n\\n            flag[*v] = 1;\\n            if s.contains(&(u, *v)) { *cnt += 1; }\\n            Self::dfs(*v, flag, graph, cnt, s);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3256685,
                "title": "dfs-twice",
                "content": "```cpp\\nclass Solution {\\n    int dfs(int p, int u, vector<vector<int>>& adj, map<pair<int, int>, int>& bob_guess)\\n    {\\n        int w = 0;\\n\\n        for (int v : adj[u])\\n        {\\n            if (v == p)\\n                continue;\\n\\n            w += dfs(u, v, adj, bob_guess);\\n            w += bob_guess[{u, v}];\\n        }\\n\\n        return w;\\n    }\\n\\n    void dfs(int p, int u, vector<vector<int>>& adj, map<pair<int, int>, int>& bob_guess, vector<int>& correct_guess)\\n    {\\n        for (int v : adj[u])\\n        {\\n            if (v == p)\\n                continue;\\n\\n            // normally, correct_guess[v] should be euqal to correct_guess[u],\\n            // but if edge u -> v is a bob_guess, \\n            // then when we set node v as root, edge u -> v will be reversed to v -> u,\\n            // thus no longer be a good guess.\\n            // on the other hand, we should increae the count if edge v -> u is a bob_guess.\\n            correct_guess[v] = correct_guess[u] - bob_guess[{u, v}] + bob_guess[{v, u}];\\n            dfs(u, v, adj, bob_guess, correct_guess);\\n        }\\n    }\\n    \\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n = edges.size() + 1;\\n        vector<vector<int>> adj(n);\\n        map<pair<int, int>, int> bob_guess;\\n        vector<int> correct_guess(n);\\n\\n        // build the adjacent list of the tree\\n        for (auto& e : edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        // make it easier to lookup\\n        for (auto& g : guesses)\\n            bob_guess[{g[0], g[1]}] = 1;\\n\\n        // first, we travel from node 0 to count how many correct guesses.\\n        correct_guess[0] = dfs(-1, 0, adj, bob_guess);\\n\\n        // second, we travel again from node 0, \\n        // but this time, we adject correct_guess[i] while traveling.\\n        dfs(-1, 0, adj, bob_guess, correct_guess);\\n\\n        int cnt = 0;\\n\\n        for (int i = 0; i < n; ++i)\\n            if (correct_guess[i] >= k)\\n                ++ cnt;\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\n    int dfs(int p, int u, vector<vector<int>>& adj, map<pair<int, int>, int>& bob_guess)\\n    {\\n        int w = 0;\\n\\n        for (int v : adj[u])\\n        {\\n            if (v == p)\\n                continue;\\n\\n            w += dfs(u, v, adj, bob_guess);\\n            w += bob_guess[{u, v}];\\n        }\\n\\n        return w;\\n    }\\n\\n    void dfs(int p, int u, vector<vector<int>>& adj, map<pair<int, int>, int>& bob_guess, vector<int>& correct_guess)\\n    {\\n        for (int v : adj[u])\\n        {\\n            if (v == p)\\n                continue;\\n\\n            // normally, correct_guess[v] should be euqal to correct_guess[u],\\n            // but if edge u -> v is a bob_guess, \\n            // then when we set node v as root, edge u -> v will be reversed to v -> u,\\n            // thus no longer be a good guess.\\n            // on the other hand, we should increae the count if edge v -> u is a bob_guess.\\n            correct_guess[v] = correct_guess[u] - bob_guess[{u, v}] + bob_guess[{v, u}];\\n            dfs(u, v, adj, bob_guess, correct_guess);\\n        }\\n    }\\n    \\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n = edges.size() + 1;\\n        vector<vector<int>> adj(n);\\n        map<pair<int, int>, int> bob_guess;\\n        vector<int> correct_guess(n);\\n\\n        // build the adjacent list of the tree\\n        for (auto& e : edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        // make it easier to lookup\\n        for (auto& g : guesses)\\n            bob_guess[{g[0], g[1]}] = 1;\\n\\n        // first, we travel from node 0 to count how many correct guesses.\\n        correct_guess[0] = dfs(-1, 0, adj, bob_guess);\\n\\n        // second, we travel again from node 0, \\n        // but this time, we adject correct_guess[i] while traveling.\\n        dfs(-1, 0, adj, bob_guess, correct_guess);\\n\\n        int cnt = 0;\\n\\n        for (int i = 0; i < n; ++i)\\n            if (correct_guess[i] >= k)\\n                ++ cnt;\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256675,
                "title": "just-brute-force-memoization",
                "content": "```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        adj = defaultdict(list)\\n        correct = Counter()\\n        g = set((i, j) for i, j in guesses)\\n        for i, j in edges:\\n            adj[i].append(j)\\n            adj[j].append(i)\\n        @cache\\n        def dfs(x, p):\\n            val = 0\\n            for y in adj[x]:\\n                if y != p:\\n                    if (x, y) in g:\\n                        val += 1\\n                    val += dfs(y, x)\\n            return val\\n        for i in adj:\\n            correct[i] = dfs(i, -1)\\n        ans = 0\\n        for i, j in correct.items():\\n            if j >= k:\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        adj = defaultdict(list)\\n        correct = Counter()\\n        g = set((i, j) for i, j in guesses)\\n        for i, j in edges:\\n            adj[i].append(j)\\n            adj[j].append(i)\\n        @cache\\n        def dfs(x, p):\\n            val = 0\\n            for y in adj[x]:\\n                if y != p:\\n                    if (x, y) in g:\\n                        val += 1\\n                    val += dfs(y, x)\\n            return val\\n        for i in adj:\\n            correct[i] = dfs(i, -1)\\n        ans = 0\\n        for i, j in correct.items():\\n            if j >= k:\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256605,
                "title": "c-o-n-time-ansd-space-complexity-indp-outdp",
                "content": "class Solution {\\npublic:\\n\\tvector<vector<int>>g;\\n\\tmap<vector<int>, int>m;\\n\\tvector<int>inDp, outDp;\\n\\tint ans = 0;\\n\\tint dfs(int node, int par) {\\n\\n\\t\\tfor (auto child : g[node]) {\\n\\t\\t\\tif (child == par)continue;\\n\\t\\t\\tif (m.count({node, child}))inDp[node]++;\\n\\t\\t\\tdfs(child, node);\\n\\t\\t\\tinDp[node]  += inDp[child];\\n\\t\\t}\\n\\t\\treturn inDp[node];\\n\\t}\\n\\n\\tvoid dfs2(int node, int par) {\\n\\n        for(auto child:g[node]){\\n            if(child == par)continue;\\n            if(m.count({child,node}))outDp[child]++;\\n            outDp[child] += outDp[node] + inDp[node]-inDp[child] - ((m.count({node,child}))?1:0);\\n            dfs2(child,node);\\n        }\\n\\t}\\n    \\n\\tint rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n\\t\\tint n = edges.size() + 1;\\n\\t\\tg.resize(n);\\n\\t\\tfor (auto edge : edges) {\\n\\t\\t\\tg[edge[0]].push_back(edge[1]);\\n\\t\\t\\tg[edge[1]].push_back(edge[0]);\\n\\t\\t}\\n\\t\\toutDp.resize(n, 0);\\n\\t\\tinDp.resize(n, 0);\\n\\t\\tfor (auto x : guesses) {\\n\\t\\t\\tm[x]++;\\n\\t\\t}\\n\\t\\tdfs(0, -1);\\n\\t\\toutDp[0] = 0;\\n\\t\\tdfs2(0, -1);\\n\\t\\tint cnt = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (inDp[i] + outDp[i] >= k)cnt++;\\n\\t\\t}\\n\\t\\treturn cnt;\\n\\t}\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\tvector<vector<int>>g;\\n\\tmap<vector<int>, int>m;\\n\\tvector<int>inDp, outDp;\\n\\tint ans = 0;\\n\\tint dfs(int node, int par) {\\n\\n\\t\\tfor (auto child : g[node]) {\\n\\t\\t\\tif (child == par)continue;\\n\\t\\t\\tif (m.count({node, child}",
                "codeTag": "Java"
            },
            {
                "id": 3256580,
                "title": "c-dfs-with-memo-o-n-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nSince the given problem involves a tree structure, once we make a decision on the direction of a certain edge while searching, the directions of the subsequent edges are also determined.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Perform DFS at each node to find the number of correct guesses for a given direction in the tree structure.\\n2. Using a hash table to record the number of correct guesses for a particular direction of an edge and its subsequent edges allows us to reduce redundant calculations.\\n3. To avoid resetting the data structure used by DFS every time, we can use a hash set to record the visited nodes, which allows us to avoid the O(N) time complexity required for each resetting (if using array).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(N)$$, where N is the number of nodes.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(N)$$.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        const int n = size(edges) + 1;\\n        \\n        vector<vector<int>> adjList(n);\\n        for (const auto &edge : edges) {\\n            auto u = edge[0], v = edge[1];\\n            adjList[u].emplace_back(v);\\n            adjList[v].emplace_back(u);\\n        }\\n        \\n        unordered_set<string> guessSet;\\n        for (const auto &guess : guesses)\\n            guessSet.emplace(getKey(guess));\\n        \\n        int res = 0;\\n        unordered_map<string,int> dp;\\n        for (int i = 0 ; i < n; ++i) {\\n            unordered_set<int> visited;\\n            if (solve(adjList, i, guessSet, dp, visited) >= k)\\n                res++;\\n        }\\n        return res;\\n    }\\nprivate:\\n    string getKey(const vector<int> &guess) {\\n        return to_string(guess[0]) + \",\" + to_string(guess[1]);\\n    }\\n    \\n    int solve(const vector<vector<int>> &adjList, int root, unordered_set<string> &guessSet,\\n              unordered_map<string,int> &dp, unordered_set<int> &visited) {\\n        \\n        visited.emplace(root);\\n        \\n        int res = 0;\\n        for (const auto v : adjList[root]) {\\n            if (visited.count(v)) continue;\\n                        \\n            auto key = getKey(vector<int>{root, v});\\n            if (!dp.count(key))\\n                dp[key] = guessSet.count(key) + solve(adjList, v, guessSet, dp, visited);\\n            res += dp[key];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        const int n = size(edges) + 1;\\n        \\n        vector<vector<int>> adjList(n);\\n        for (const auto &edge : edges) {\\n            auto u = edge[0], v = edge[1];\\n            adjList[u].emplace_back(v);\\n            adjList[v].emplace_back(u);\\n        }\\n        \\n        unordered_set<string> guessSet;\\n        for (const auto &guess : guesses)\\n            guessSet.emplace(getKey(guess));\\n        \\n        int res = 0;\\n        unordered_map<string,int> dp;\\n        for (int i = 0 ; i < n; ++i) {\\n            unordered_set<int> visited;\\n            if (solve(adjList, i, guessSet, dp, visited) >= k)\\n                res++;\\n        }\\n        return res;\\n    }\\nprivate:\\n    string getKey(const vector<int> &guess) {\\n        return to_string(guess[0]) + \",\" + to_string(guess[1]);\\n    }\\n    \\n    int solve(const vector<vector<int>> &adjList, int root, unordered_set<string> &guessSet,\\n              unordered_map<string,int> &dp, unordered_set<int> &visited) {\\n        \\n        visited.emplace(root);\\n        \\n        int res = 0;\\n        for (const auto v : adjList[root]) {\\n            if (visited.count(v)) continue;\\n                        \\n            auto key = getKey(vector<int>{root, v});\\n            if (!dp.count(key))\\n                dp[key] = guessSet.count(key) + solve(adjList, v, guessSet, dp, visited);\\n            res += dp[key];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256466,
                "title": "easy-c-dfs-bfs-solution-with-graph-explanation-with-thinking-process",
                "content": "# Thinking process\\nObservation: \\n1. it is a graph problem\\n2. The node size is 10^5 with means it is better to finish by o(n) time\\n\\n=> We get the hints that it should be solved by dfs/ bfs.\\n# Let start with brute force\\n- We could start with Root = index i. Then, dfs the whole tree and check how many valid guess is made.\\n- After searching all index, we could know the number of valid root.\\n### The time complexity here would be O(E * N) where E = edges and N = nodes\\n\\n### ** Due to the input size, it must be overrun.\\n### ** Since DFS and BFS must be the algorithm we need, so we need to optimize the N to make the algorithm become O(E) which would be accepted\\n\\n# Optimization from observation\\n- In the example of this question, we could see there are many overlap correct guessings. For example:\\n\\nRoot 0,\\n```\\n        0\\n    /       \\\\\\n    1       2  \\n    |\\n    3\\n```\\n\\nRoot 2,\\n```\\n    2\\n    |\\n    0\\n    |\\n    1\\n    |\\n    3\\n```\\nIf we make the guess 1 to 3, it would be correct for both tree.\\nThe observation from here is that, the correct guessing would keep correct if it is not the roots (which is 0 and 2). Thus, Once we dfs once and get the correct guessing number. For each root, we only need to care about the guess of Root changing. That is guess 0 -> 2 and 2 -> 0. We could see that, this update could be done in constant time. And thus, the algorithm become: \\n1. DFS [O(N)]\\n2. For each node, update the correct guess number [O(N)]\\n\\n# Time complexity: O(N)\\n\\n### If you find this useful, please feel free to drop an upvote and comment. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        unordered_map<int, set<int>> graph;\\n        unordered_map<int, vector<int>> graph2;\\n        for (auto &guess: guesses){\\n            graph[guess[0]].insert(guess[1]); \\n        }\\n        for (auto &edge: edges){\\n            graph2[edge[0]].push_back(edge[1]);\\n            graph2[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        int correct = 0, ans = 0;\\n        dfs(graph, graph2, -1, 0, correct);\\n        if (correct >= k) ans++;\\n        queue<pair<int, int>> bfs;\\n        bfs.push({0, correct});\\n        bool flag[edges.size() + 1];\\n        memset(flag, 0, sizeof(flag));\\n        flag[0] = 1;\\n        while (!bfs.empty()){\\n            auto current = bfs.front();\\n            auto tmp = graph2[current.first];\\n            for (auto &next: tmp){\\n                if (flag[next] == 1) continue;\\n                auto tmp_correct = current.second;\\n                if (graph[current.first].find(next) != graph[current.first].end()) tmp_correct--;\\n                if (graph[next].find(current.first) != graph[next].end()) tmp_correct++;\\n                if (tmp_correct >= k) ans++;\\n                bfs.push({next, tmp_correct});\\n                flag[next] = 1;\\n            }\\n            bfs.pop();\\n        }\\n        return ans;\\n    }\\n    \\n    void dfs(unordered_map<int, set<int>>& guessGraph, unordered_map<int, vector<int>> &graph, int parent, int currentNode, int& correctGuess){\\n        auto tmp = graph[currentNode];\\n        while (!tmp.empty()){\\n            auto& visit = tmp.back();\\n            if (visit != parent){\\n                if (guessGraph[currentNode].find(visit) != guessGraph[currentNode].end()) {\\n                    correctGuess++;\\n                }\\n                dfs(guessGraph, graph, currentNode, visit, correctGuess);\\n            }\\n            tmp.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Memoization"
                ],
                "code": "```\\n        0\\n    /       \\\\\\n    1       2  \\n    |\\n    3\\n```\n```\\n    2\\n    |\\n    0\\n    |\\n    1\\n    |\\n    3\\n```\n```\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        unordered_map<int, set<int>> graph;\\n        unordered_map<int, vector<int>> graph2;\\n        for (auto &guess: guesses){\\n            graph[guess[0]].insert(guess[1]); \\n        }\\n        for (auto &edge: edges){\\n            graph2[edge[0]].push_back(edge[1]);\\n            graph2[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        int correct = 0, ans = 0;\\n        dfs(graph, graph2, -1, 0, correct);\\n        if (correct >= k) ans++;\\n        queue<pair<int, int>> bfs;\\n        bfs.push({0, correct});\\n        bool flag[edges.size() + 1];\\n        memset(flag, 0, sizeof(flag));\\n        flag[0] = 1;\\n        while (!bfs.empty()){\\n            auto current = bfs.front();\\n            auto tmp = graph2[current.first];\\n            for (auto &next: tmp){\\n                if (flag[next] == 1) continue;\\n                auto tmp_correct = current.second;\\n                if (graph[current.first].find(next) != graph[current.first].end()) tmp_correct--;\\n                if (graph[next].find(current.first) != graph[next].end()) tmp_correct++;\\n                if (tmp_correct >= k) ans++;\\n                bfs.push({next, tmp_correct});\\n                flag[next] = 1;\\n            }\\n            bfs.pop();\\n        }\\n        return ans;\\n    }\\n    \\n    void dfs(unordered_map<int, set<int>>& guessGraph, unordered_map<int, vector<int>> &graph, int parent, int currentNode, int& correctGuess){\\n        auto tmp = graph[currentNode];\\n        while (!tmp.empty()){\\n            auto& visit = tmp.back();\\n            if (visit != parent){\\n                if (guessGraph[currentNode].find(visit) != guessGraph[currentNode].end()) {\\n                    correctGuess++;\\n                }\\n                dfs(guessGraph, graph, currentNode, visit, correctGuess);\\n            }\\n            tmp.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256465,
                "title": "dfs-with-memo-intuition",
                "content": "# Intuition\\n\\nIn the bruteforce solution, we should go though each node and check if the node can be a root. Doing that you we get a TLE. To speed up this approach we can use memo to store previous results.\\n\\n# Approach\\n\\n1. Build a `tree` as an ajustancy list.\\n2. Build a set based on `guesses`.\\n3. Go through each node and check if the node can be a root: use dfs and return a count of guesses on the way as a result. Compare with `k`.\\n4. Use a dictionary to store a count of guesses in a subtree starting on `y`: `memo[(x, y)]`, where `x` is a parent and `y` is a child. With `x` we can set a direction of a subtree in the memo. `memo[(0,1)] = 4` means there are 4 guesses in a subtree with a root `1` if we came to node `1` from node `0` in DFS.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        n = len(edges)\\n        tree = [[] for _ in range(n+1)]\\n        s = set()\\n        for guess in guesses:\\n            s.add((guess[0], guess[1]))\\n        for edge in edges:\\n            tree[edge[0]].append(edge[1])\\n            tree[edge[1]].append(edge[0])\\n        memo = dict()\\n        def checkRoot(node: int, parent: int) -> int:\\n            if (parent, node) in memo:\\n                return memo[(parent, node)]\\n            res = 0\\n            if (parent, node) in s:\\n                res += 1\\n            for next_node in tree[node]:\\n                if next_node == parent:\\n                    continue\\n                if (node, next_node) in memo:\\n                    res += memo[(node, next_node)]\\n                else:\\n                    local = checkRoot(next_node, node)\\n                    memo[(node, next_node)] = local\\n                    res += local\\n            return res\\n        result = 0\\n        for root in range(n+1):\\n            if checkRoot(root, -1) >= k:\\n                result += 1\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\\n        n = len(edges)\\n        tree = [[] for _ in range(n+1)]\\n        s = set()\\n        for guess in guesses:\\n            s.add((guess[0], guess[1]))\\n        for edge in edges:\\n            tree[edge[0]].append(edge[1])\\n            tree[edge[1]].append(edge[0])\\n        memo = dict()\\n        def checkRoot(node: int, parent: int) -> int:\\n            if (parent, node) in memo:\\n                return memo[(parent, node)]\\n            res = 0\\n            if (parent, node) in s:\\n                res += 1\\n            for next_node in tree[node]:\\n                if next_node == parent:\\n                    continue\\n                if (node, next_node) in memo:\\n                    res += memo[(node, next_node)]\\n                else:\\n                    local = checkRoot(next_node, node)\\n                    memo[(node, next_node)] = local\\n                    res += local\\n            return res\\n        result = 0\\n        for root in range(n+1):\\n            if checkRoot(root, -1) >= k:\\n                result += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256455,
                "title": "two-dfs-and-unordered-map-o-n-c",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    unordered_map<int,vector<int>> mp;\\n    unordered_map<long long,int> gmp;\\n    int dfs(int cur,int from)\\n    {\\n        long long g = 0;\\n        g= cur;\\n        g*=100000;\\n        int ret = 0;\\n        for(int i : mp[cur])\\n        {\\n            if(i == from)\\n                continue;\\n            g+=i;\\n            if(gmp.count(g))\\n            {\\n                ret++;\\n                gmp[g]=2;\\n            }\\n            g-=i;\\n            ret+=dfs(i,cur);\\n        }\\n        return ret;\\n    }\\n    int dfs2(int cur,int from,int st,int k)\\n    {\\n        long long g = 0;\\n        int ret = 0;\\n        for(int i : mp[cur])\\n        {\\n            g= cur;\\n            g*=100000;\\n            if(i == from)\\n                continue;\\n            g+=i;\\n            int nst = st;\\n            if(gmp.count(g))\\n            {\\n                if(gmp[g]==2)\\n                    nst-=1;\\n            }\\n            g=0;\\n            g=i;\\n            g*=100000;\\n            g+=cur;\\n            if(gmp.count(g))\\n            {\\n                if(gmp[g]==1)\\n                    nst+=1;\\n            }\\n            ret += dfs2(i,cur,nst,k);\\n        }\\n        if(st>=k)\\n            ret += 1;\\n        return ret;\\n    }\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        long long g;\\n        for(auto i : guesses)\\n        {\\n            g=0;\\n            g+=i[0];\\n            g*=100000;\\n            g+=i[1];\\n            gmp[g]=1;\\n        }\\n        for(auto i : edges)\\n        {\\n            mp[i[0]].push_back(i[1]);\\n            mp[i[1]].push_back(i[0]);\\n        }\\n        int st = dfs(0,-1);\\n        int ans = 0;\\n        return dfs2(0,-1,st,k);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<int,vector<int>> mp;\\n    unordered_map<long long,int> gmp;\\n    int dfs(int cur,int from)\\n    {\\n        long long g = 0;\\n        g= cur;\\n        g*=100000;\\n        int ret = 0;\\n        for(int i : mp[cur])\\n        {\\n            if(i == from)\\n                continue;\\n            g+=i;\\n            if(gmp.count(g))\\n            {\\n                ret++;\\n                gmp[g]=2;\\n            }\\n            g-=i;\\n            ret+=dfs(i,cur);\\n        }\\n        return ret;\\n    }\\n    int dfs2(int cur,int from,int st,int k)\\n    {\\n        long long g = 0;\\n        int ret = 0;\\n        for(int i : mp[cur])\\n        {\\n            g= cur;\\n            g*=100000;\\n            if(i == from)\\n                continue;\\n            g+=i;\\n            int nst = st;\\n            if(gmp.count(g))\\n            {\\n                if(gmp[g]==2)\\n                    nst-=1;\\n            }\\n            g=0;\\n            g=i;\\n            g*=100000;\\n            g+=cur;\\n            if(gmp.count(g))\\n            {\\n                if(gmp[g]==1)\\n                    nst+=1;\\n            }\\n            ret += dfs2(i,cur,nst,k);\\n        }\\n        if(st>=k)\\n            ret += 1;\\n        return ret;\\n    }\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        long long g;\\n        for(auto i : guesses)\\n        {\\n            g=0;\\n            g+=i[0];\\n            g*=100000;\\n            g+=i[1];\\n            gmp[g]=1;\\n        }\\n        for(auto i : edges)\\n        {\\n            mp[i[0]].push_back(i[1]);\\n            mp[i[1]].push_back(i[0]);\\n        }\\n        int st = dfs(0,-1);\\n        int ans = 0;\\n        return dfs2(0,-1,st,k);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256417,
                "title": "c-2-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n = size(edges) + 1;\\n        vector<vector<int>> adj(n);\\n        for (auto& e: edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<unordered_set<int>> g(n);\\n        for (auto& e: guesses)\\n            g[e[0]].insert(e[1]);\\n        int cnt = 0;\\n        function<void(int, int)> dfs1 = [&] (int u, int p) {\\n            for (auto v: adj[u]) {\\n                if (v != p) {\\n                    cnt += g[u].count(v);\\n                    dfs1(v, u);\\n                }\\n            }\\n        };\\n        dfs1(0, -1);\\n        int ans = 0;\\n        function<void(int, int)> dfs2 = [&] (int u, int p) {\\n            ans += cnt >= k;\\n            for (auto v: adj[u]) {\\n                if (v != p) {\\n                    cnt += g[v].count(u) - g[u].count(v);\\n                    dfs2(v, u);\\n                    cnt += g[u].count(v) - g[v].count(u);\\n                }\\n            }\\n        };\\n        dfs2(0, -1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        int n = size(edges) + 1;\\n        vector<vector<int>> adj(n);\\n        for (auto& e: edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<unordered_set<int>> g(n);\\n        for (auto& e: guesses)\\n            g[e[0]].insert(e[1]);\\n        int cnt = 0;\\n        function<void(int, int)> dfs1 = [&] (int u, int p) {\\n            for (auto v: adj[u]) {\\n                if (v != p) {\\n                    cnt += g[u].count(v);\\n                    dfs1(v, u);\\n                }\\n            }\\n        };\\n        dfs1(0, -1);\\n        int ans = 0;\\n        function<void(int, int)> dfs2 = [&] (int u, int p) {\\n            ans += cnt >= k;\\n            for (auto v: adj[u]) {\\n                if (v != p) {\\n                    cnt += g[v].count(u) - g[u].count(v);\\n                    dfs2(v, u);\\n                    cnt += g[u].count(v) - g[v].count(u);\\n                }\\n            }\\n        };\\n        dfs2(0, -1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1821697,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "When you move the \"root\" from a node to a neighbor node, only guesses at that edge switch from correct to incorrect (or vise versa). So you can get the number of correct guesses for a neighbor node in `O(1)`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Use memo to speed up you code"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Beautiful question. Blew my mind"
                    }
                ]
            },
            {
                "id": 1821665,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "When you move the \"root\" from a node to a neighbor node, only guesses at that edge switch from correct to incorrect (or vise versa). So you can get the number of correct guesses for a neighbor node in `O(1)`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Use memo to speed up you code"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Beautiful question. Blew my mind"
                    }
                ]
            },
            {
                "id": 1824116,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "When you move the \"root\" from a node to a neighbor node, only guesses at that edge switch from correct to incorrect (or vise versa). So you can get the number of correct guesses for a neighbor node in `O(1)`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Use memo to speed up you code"
                    },
                    {
                        "username": "shivansh961",
                        "content": "Beautiful question. Blew my mind"
                    }
                ]
            }
        ]
    }
]