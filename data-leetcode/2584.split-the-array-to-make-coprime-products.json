[
    {
        "title": "Split the Array to Make Coprime Products",
        "question_content": "You are given a 0-indexed integer array nums of length n.\nA split at an index i where 0 <= i <= n - 2 is called valid if the product of the first i + 1 elements and the product of the remaining elements are coprime.\n\n\tFor example, if nums = [2, 3, 3], then a split at the index i = 0 is valid because 2 and 9 are coprime, while a split at the index i = 1 is not valid because 6 and 3 are not coprime. A split at the index i = 2 is not valid because i == n - 1.\n\nReturn the smallest index i at which the array can be split validly or -1 if there is no such split.\nTwo values val1 and val2 are coprime if gcd(val1, val2) == 1 where gcd(val1, val2) is the greatest common divisor of val1 and val2.\n&nbsp;\nExample 1:\n\nInput: nums = [4,7,8,15,3,5]\nOutput: 2\nExplanation: The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i.\nThe only valid split is at index 2.\n\nExample 2:\n\nInput: nums = [4,7,15,8,3,5]\nOutput: -1\nExplanation: The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i.\nThere is no valid split.\n\n&nbsp;\nConstraints:\n\n\tn == nums.length\n\t1 <= n <= 104\n\t1 <= nums[i] <= 106",
        "solutions": [
            {
                "id": 3258070,
                "title": "prime-intervals-vs-count-primes",
                "content": "## Intuition\\nProducts of prefix and suffix elements are co-prime if prefix elements do not share any prime factors with suffix elements.\\n\\n## Prime Intervals\\n\\nIf element `i` shares the same prime as element `j`, we cannot split the array in `[i, j)` interval.\\n\\nIn this solution, we identify all such intervals, and look for a split point that does not belong to any interval. \\n\\n> I initially came up with a more complicated solution - Count Primes (moved to the section below).\\n\\nWe record the first index of each prime. We then use a number line to record start (increment) and end (decrement) of each prime interval.\\n\\nFinally, we do a line sweep, computing the prefix sum. When the prefix sum is zero - we\\'ve found our split point.\\n\\n**Factorization**\\nWe do not need to track all primes for a number, only unique ones.\\n\\nWe only check numbers up to 1,000 (square root of maximum value).\\n\\nIf, after trying removing factors `[2 ... 1000]`, the number is greater than one - then that number is a (large) prime.\\n\\nTo speed it up, we can first generate primes < 1000 (e.g. using Sieve of Eratosthenes).\\n\\n**C++**\\n```cpp\\nvector<int> factorize(int n) {\\n    vector<int> res;\\n    for (int i = 2; n > 1 && i < 1000; i += 1 + (i % 2))\\n        if (n % i == 0) {\\n            res.push_back(i);\\n            while(n % i == 0)\\n                n /= i;\\n        }\\n    if (n > 1)\\n        res.push_back(n);\\n    return res;\\n}\\nint findValidSplit(vector<int>& nums) {\\n    unordered_map<int, int> fi;\\n    int line[10001] = {};\\n    for (int i  = 0; i < nums.size(); ++i)\\n        for (int f : factorize(nums[i])) {\\n            if (fi.count(f) == 0)\\n                fi[f] = i;\\n            ++line[fi[f]];\\n            --line[i];\\n        }\\n    partial_sum(begin(line), end(line), begin(line));\\n    int res = find(begin(line), end(line), 0) - begin(line);\\n    return res < nums.size() - 1 ? res : -1;\\n}\\n```\\n\\n## Count Primes\\nWe first count primes for the entire array (`right` counter). Then, we go left-to-right, count primes for the prefix (`left`).\\n\\nWe increment the number of `common` primes when we see a prime for the first time.\\n\\nWhen `left` counter equals `right`, we decrement `common` (the prime now is only in the `left` array). \\n\\nWhen `common` becomes zero - we can do the split.\\n\\n**C++**\\n```cpp\\nvector<int> factorize(int n) {\\n    vector<int> res;\\n    for (int i = 2; n > 1 && i < 1000; i += 1 + (i % 2))\\n        if (n % i == 0) {\\n            res.push_back(i);\\n            while(n % i == 0)\\n                n /= i;\\n        }\\n    if (n > 1)\\n        res.push_back(n);\\n    return res;\\n}\\nint findValidSplit(vector<int>& nums) {\\n    unordered_map<int, int> left, right;\\n    for (int n : nums)\\n        for (int f : factorize(n))\\n            ++right[f];\\n    for (int i  = 0, common = 0; i < nums.size() - 1; ++i) {\\n        for (int f : factorize(nums[i]))\\n            common += (left[f]++ == 0) - (left[f] == right[f]);\\n        if (common == 0)\\n            return i;        \\n    }\\n    return -1;\\n}\\n```\\n\\n**Java**\\n```java\\nList<Integer> factorize(int n) {\\n    List<Integer> res = new ArrayList<>();\\n    for (int i = 2; n > 1 && i < 1000; i += 1 + (i % 2))\\n        if (n % i == 0) {\\n            res.add(i);\\n            while(n % i == 0)\\n                n /= i;\\n        }\\n    if (n > 1)\\n        res.add(n);        \\n    return res;\\n}\\npublic int findValidSplit(int[] nums) {\\n    Map<Integer, Integer> left = new HashMap<>(), right = new HashMap<>();\\n    int res = 0;\\n    for (var n : nums)\\n        for (var f : factorize(n))\\n            right.put(f, right.getOrDefault(f, 0) + 1);\\n    for (int i  = 0, common = 0; i < nums.length - 1; ++i) {\\n        for (int f : factorize(nums[i])) {\\n            left.put(f, left.getOrDefault(f, 0) + 1);\\n            common += left.get(f) == 1 ? 1 : 0;\\n            common -= left.get(f).equals(right.get(f)) ? 1 : 0;\\n        }        \\n        if (common == 0)\\n            return i;\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nvector<int> factorize(int n) {\\n    vector<int> res;\\n    for (int i = 2; n > 1 && i < 1000; i += 1 + (i % 2))\\n        if (n % i == 0) {\\n            res.push_back(i);\\n            while(n % i == 0)\\n                n /= i;\\n        }\\n    if (n > 1)\\n        res.push_back(n);\\n    return res;\\n}\\nint findValidSplit(vector<int>& nums) {\\n    unordered_map<int, int> fi;\\n    int line[10001] = {};\\n    for (int i  = 0; i < nums.size(); ++i)\\n        for (int f : factorize(nums[i])) {\\n            if (fi.count(f) == 0)\\n                fi[f] = i;\\n            ++line[fi[f]];\\n            --line[i];\\n        }\\n    partial_sum(begin(line), end(line), begin(line));\\n    int res = find(begin(line), end(line), 0) - begin(line);\\n    return res < nums.size() - 1 ? res : -1;\\n}\\n```\n```cpp\\nvector<int> factorize(int n) {\\n    vector<int> res;\\n    for (int i = 2; n > 1 && i < 1000; i += 1 + (i % 2))\\n        if (n % i == 0) {\\n            res.push_back(i);\\n            while(n % i == 0)\\n                n /= i;\\n        }\\n    if (n > 1)\\n        res.push_back(n);\\n    return res;\\n}\\nint findValidSplit(vector<int>& nums) {\\n    unordered_map<int, int> left, right;\\n    for (int n : nums)\\n        for (int f : factorize(n))\\n            ++right[f];\\n    for (int i  = 0, common = 0; i < nums.size() - 1; ++i) {\\n        for (int f : factorize(nums[i]))\\n            common += (left[f]++ == 0) - (left[f] == right[f]);\\n        if (common == 0)\\n            return i;        \\n    }\\n    return -1;\\n}\\n```\n```java\\nList<Integer> factorize(int n) {\\n    List<Integer> res = new ArrayList<>();\\n    for (int i = 2; n > 1 && i < 1000; i += 1 + (i % 2))\\n        if (n % i == 0) {\\n            res.add(i);\\n            while(n % i == 0)\\n                n /= i;\\n        }\\n    if (n > 1)\\n        res.add(n);        \\n    return res;\\n}\\npublic int findValidSplit(int[] nums) {\\n    Map<Integer, Integer> left = new HashMap<>(), right = new HashMap<>();\\n    int res = 0;\\n    for (var n : nums)\\n        for (var f : factorize(n))\\n            right.put(f, right.getOrDefault(f, 0) + 1);\\n    for (int i  = 0, common = 0; i < nums.length - 1; ++i) {\\n        for (int f : factorize(nums[i])) {\\n            left.put(f, left.getOrDefault(f, 0) + 1);\\n            common += left.get(f) == 1 ? 1 : 0;\\n            common -= left.get(f).equals(right.get(f)) ? 1 : 0;\\n        }        \\n        if (common == 0)\\n            return i;\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3258154,
                "title": "video-explanation-building-solution-with-intuition",
                "content": "# Explanation\\n\\nhttps://youtu.be/lyJgJasrLVc\\n\\n# Code\\n```\\nconst int N = 1e6+1;\\n\\nclass Solution {\\n    vector<int> sieve;\\n    \\n    vector<int> PrimeFactors (int x) {\\n        if (sieve.empty()) {\\n            sieve.resize(N);\\n            for (int j = 0; j < N; j ++) sieve[j] = j;\\n            \\n            for (int j = 2; j*j < N; j ++) {\\n                if (sieve[j] != j) continue;\\n                for (int k = j*j; k < N; k += j)\\n                    sieve[k] = j;\\n            }\\n        }\\n        \\n        vector<int> result;\\n        while (x != 1) {\\n            int div = sieve[x];\\n            while (x % div == 0) x /= div;\\n            result.push_back(div);\\n        }\\n        return result;\\n    }\\n    \\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> last_factor_ind (N, 0);\\n        \\n        for (int j = 0; j < n; j ++) {\\n            vector<int> factors = PrimeFactors (nums[j]);\\n            for (auto f : factors) \\n                last_factor_ind[f] = j;\\n        }\\n        \\n        int result_ind = 0;\\n        int it = 0;\\n        \\n        while (it <= result_ind) {\\n            vector<int> factors = PrimeFactors (nums[it]);\\n            for (auto f : factors) \\n                result_ind = max(result_ind, last_factor_ind[f]);\\n            \\n            it ++;\\n        }\\n        \\n        if (it == n) return -1;\\n        return it-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int N = 1e6+1;\\n\\nclass Solution {\\n    vector<int> sieve;\\n    \\n    vector<int> PrimeFactors (int x) {\\n        if (sieve.empty()) {\\n            sieve.resize(N);\\n            for (int j = 0; j < N; j ++) sieve[j] = j;\\n            \\n            for (int j = 2; j*j < N; j ++) {\\n                if (sieve[j] != j) continue;\\n                for (int k = j*j; k < N; k += j)\\n                    sieve[k] = j;\\n            }\\n        }\\n        \\n        vector<int> result;\\n        while (x != 1) {\\n            int div = sieve[x];\\n            while (x % div == 0) x /= div;\\n            result.push_back(div);\\n        }\\n        return result;\\n    }\\n    \\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> last_factor_ind (N, 0);\\n        \\n        for (int j = 0; j < n; j ++) {\\n            vector<int> factors = PrimeFactors (nums[j]);\\n            for (auto f : factors) \\n                last_factor_ind[f] = j;\\n        }\\n        \\n        int result_ind = 0;\\n        int it = 0;\\n        \\n        while (it <= result_ind) {\\n            vector<int> factors = PrimeFactors (nums[it]);\\n            for (auto f : factors) \\n                result_ind = max(result_ind, last_factor_ind[f]);\\n            \\n            it ++;\\n        }\\n        \\n        if (it == n) return -1;\\n        return it-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258230,
                "title": "this-is-not-a-medium-level-question",
                "content": "even in todays contest there are more submissions for the hard question than this question",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3258526,
                "title": "record-right-most-index-of-every-prime-factor-into-dictionary",
                "content": "# Intuition\\nIf arr[0]==2, and if no factor \"2\" in the rest of the array, then arr[0] is the split point. If arr[5] also has prime factor \"2\", then it is not possible to split at arr[0\\\\~4]. The split index must be >=5. Also if all prime factors in arr[0~5] doesn\\'t exist after arr[5], then the split point is arr[5], otherwise the split index is >5.\\n\\n# Approach\\nWe record the right-most index of each prime factor into a dictionary. Then start from arr[0], we keep updating the right-most index **scanned so far**. If the current right-most index is \"i\" itself, then that means \"i\" is the smallest splitting point.\\n\\n# Code\\n```python\\nmx = 10**6\\nspf = [i for i in range(mx+1)]\\nfor i in range(2,int(math.sqrt(mx))+1):\\n    if spf[i]==i:\\n        for j in range(i*i,mx+1,i):\\n            spf[j]=min(spf[j],i)\\ndef getPrimeFactors(x):\\n    while x!=1:\\n        yield spf[x]\\n        x//=spf[x]\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        fac_idx = defaultdict(int)\\n        for i,v in enumerate(nums):\\n            for fac in getPrimeFactors(v):\\n                fac_idx[fac] = i\\n        right_most = 0\\n        for i in range(len(nums)-1):\\n            for fac in getPrimeFactors(nums[i]):\\n                right_most = max(right_most,fac_idx[fac])\\n            if right_most==i:\\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nmx = 10**6\\nspf = [i for i in range(mx+1)]\\nfor i in range(2,int(math.sqrt(mx))+1):\\n    if spf[i]==i:\\n        for j in range(i*i,mx+1,i):\\n            spf[j]=min(spf[j],i)\\ndef getPrimeFactors(x):\\n    while x!=1:\\n        yield spf[x]\\n        x//=spf[x]\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        fac_idx = defaultdict(int)\\n        for i,v in enumerate(nums):\\n            for fac in getPrimeFactors(v):\\n                fac_idx[fac] = i\\n        right_most = 0\\n        for i in range(len(nums)-1):\\n            for fac in getPrimeFactors(nums[i]):\\n                right_most = max(right_most,fac_idx[fac])\\n            if right_most==i:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258501,
                "title": "easy-intuitive-check-prime-factors-explained-in-detail",
                "content": "# Intuition\\nWe can always write a number as a product of prime numbers, that means for any product of numbers A1 * A2 \\u2026* AN we can write them as product of their individual prime numbers. Let\\u2019s say \\nFor 3 numbers A1 =15 (3^1 * 5^1), A2=27 (3^3), A3=(2^3) their product would be given by 3^(3+1) * 5^1 *2^3 i.e. 3^4 * 5^1 * 2^3. This can be represented as a map -> [3:4, 5:1, 2:3] (this would be used later)\\n\\n\\n# Approach\\n\\nThe easy solution is to calculate the prime factorization of the entire sequence provided. Then start from the left most side and on each index reduce it\\u2019s prime factors from the total. \\n\\nFor example if the total multiple is (3^4 * 5^1) as discussed in example above and we are at the first element i.e. A1=15 then we reduce it\\u2019s factors i.e. 3^1 * 5^1 from the factorization and we are left with 3^(4-1) * 5^(1-1) * 2^(3-0) => 3^3 * 2^3 . \\n\\nWe would now check if the prime factors we are left with should either have an exponentiation=0 or should be exactly as they were in the total multiplication [3:4, 5:1, 2:3] now here 3 is present 4 times which has actually been changed to 3 now. So we can\\u2019t say it\\u2019s the same so let\\u2019s try for the next element). \\nNow let\\u2019s go to 2nd element i.e. A2=27 then we reduce it\\u2019s factors i.e. 3^3  from the remaining and we are left with 3^(3-3) * 5^(1-1) * 2^(3-0) => 3^0 * 2^3 . \\n\\nWe would now check if the prime factors we are left with should either have an exponentiation=0 or should be exactly as they were in the total multiplication [3:4, 5:1, 2:3] now here 3 is present 4 times which has actually been changed to 0now (which is fine because 0 is acceptable, 5 also has been reduced to 0, 2 has exponent 3 which is same as total). Since our required conditions are satisfied hence we now have the required index!\\n\\nWait! the above approach might give you a TLE as you would be checking for all of the prime numbers present in the total multiplication is there a way of reducing it ? YES! we can try to check which all prime numbers are dirty. dirty are those which have a non zero exponentitaion and have also been changed from their original configuration. Code is self explanatory. \\n\\nWill post a video solution on this if you guys want! :) let me know if it\\'s required!\\nI hope this post helped you.\\nPlease help me by keeping this post on the top by upvoting it! Thanks!\\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int,int> getFactors(int x){\\n        unordered_map<int,int> freq;\\n        int f=2;\\n        while(x>1 && f*f<=x){\\n            while(x%f==0){\\n                freq[f]++;\\n                x/=f;\\n            }\\n            f++;\\n        }\\n        if(x!=1)    freq[x]=1;        // itself prime\\n        return freq;\\n    }\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        unordered_map<int,int> freq;\\n        for(auto& x:nums){\\n            auto fac=getFactors(x);\\n            for(auto& [f,c]:fac)    freq[f]+=c;\\n        }\\n        auto org=freq;      // the original map \\n        int dirty=0;        // dirty means the number of prime factors having exponentitaion!=0 and !=the initial config.\\n        for(int i=0;i<nums.size()-1;i++){\\n            auto fac=getFactors(nums[i]);\\n            for(auto& [f,c]:fac){\\n                if(freq[f]==org[f] && c!=freq[f])   dirty++;// p^(x-a) here x-a now becomes non 0\\n                if(freq[f]!=org[f] && c==freq[f])   dirty--;    // this prime number was dirty before\\n                freq[f]-=c;\\n            }\\n            \\n            if(dirty==0)   return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<int,int> getFactors(int x){\\n        unordered_map<int,int> freq;\\n        int f=2;\\n        while(x>1 && f*f<=x){\\n            while(x%f==0){\\n                freq[f]++;\\n                x/=f;\\n            }\\n            f++;\\n        }\\n        if(x!=1)    freq[x]=1;        // itself prime\\n        return freq;\\n    }\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        unordered_map<int,int> freq;\\n        for(auto& x:nums){\\n            auto fac=getFactors(x);\\n            for(auto& [f,c]:fac)    freq[f]+=c;\\n        }\\n        auto org=freq;      // the original map \\n        int dirty=0;        // dirty means the number of prime factors having exponentitaion!=0 and !=the initial config.\\n        for(int i=0;i<nums.size()-1;i++){\\n            auto fac=getFactors(nums[i]);\\n            for(auto& [f,c]:fac){\\n                if(freq[f]==org[f] && c!=freq[f])   dirty++;// p^(x-a) here x-a now becomes non 0\\n                if(freq[f]!=org[f] && c==freq[f])   dirty--;    // this prime number was dirty before\\n                freq[f]-=c;\\n            }\\n            \\n            if(dirty==0)   return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259389,
                "title": "black-board-solution-count-unique-prime-factors-video-solution-intution",
                "content": "# Video Solution\\nhttps://www.youtube.com/watch?v=l9QHzvGamWA\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/98223a97-1108-4da1-bd07-656c58b8f79a_1678003771.0059423.png)\\n![image.png](https://assets.leetcode.com/users/images/97fb9046-d713-41e4-8a90-7c9807354b0b_1678003778.1600695.png)\\n![image.png](https://assets.leetcode.com/users/images/94084d04-2c95-455b-96f9-082664f6b162_1678003979.8401294.png)\\n![image.png](https://assets.leetcode.com/users/images/355c97bc-9c84-4b45-9b0a-6e2d11b6595b_1678003986.33985.png)\\n![image.png](https://assets.leetcode.com/users/images/cf18b1ab-6ca2-46fd-9cb8-8efe268912af_1678003996.8825912.png)\\n![image.png](https://assets.leetcode.com/users/images/de3e73d2-dd5e-424b-ae32-1afc78b88049_1678004011.4520204.png)\\n![image.png](https://assets.leetcode.com/users/images/ddb45d6b-dcb7-4b00-944e-50216bd7bd5c_1678004030.3866043.png)\\n![image.png](https://assets.leetcode.com/users/images/bce937c7-99b3-4de6-8571-8ea6978fe81c_1678004046.9134622.png)\\n![image.png](https://assets.leetcode.com/users/images/da68319a-21e1-4778-9fd6-b01097002a2f_1678004056.4050553.png)\\n![image.png](https://assets.leetcode.com/users/images/d3c542a5-91a6-4d81-886a-1f6b9750379d_1678004063.8592362.png)\\n![image.png](https://assets.leetcode.com/users/images/bfe98d2a-2cb0-4b30-8616-99126fa2eddb_1678004074.5029705.png)\\n![image.png](https://assets.leetcode.com/users/images/544b0178-ecee-400d-8e20-6696a215f57a_1678004099.941708.png)\\n![image.png](https://assets.leetcode.com/users/images/332615a0-e498-4ab9-aa8e-b013ad40d6d5_1678004105.9454606.png)\\n![image.png](https://assets.leetcode.com/users/images/4d6c02c6-fdb8-44b4-9231-d8930b2f99a2_1678004140.0887887.png)\\n\\n\\n# Code\\n```\\n#define MAX 1000005\\n\\nclass Solution {\\npublic:\\n    vector<int> getpFactors(int n) {\\n        vector<int> res;\\n        for (int i = 2; i < 1000; i++)\\n            if (n % i == 0) {\\n                res.push_back(i);\\n                while(n % i == 0)\\n                    n /= i;\\n            }\\n        if (n > 1)\\n            res.push_back(n);\\n        return res;\\n    }\\n    \\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if(n==1)\\n            return -1;\\n\\n        unordered_map<int, int> mpr;\\n        unordered_map<int, int> mpl;\\n        unordered_map<int, vector<int>> pfv;\\n        \\n        for(int i=0;i<n;i++){\\n            int val = nums[i];\\n            vector<int> pf = getpFactors(val);\\n            pfv[i] = pf;\\n            for(auto el : pf){\\n                mpr[el] = i;\\n                \\n                if(mpl.find(el) == mpl.end())\\n                    mpl[el] = i;\\n            }\\n        }\\n        \\n        \\n        int mx_go_right = 0;\\n        for(int i=0;i<n;i++){\\n            vector<int> pf = pfv[i];\\n            for(auto el : pf)\\n                mx_go_right = max(mx_go_right, mpr[el]);\\n            \\n            if(i+1 > mx_go_right)\\n                break;\\n        }\\n        \\n        int mx_go_left = n;\\n        for(int i=n-1;i>=0;i--){\\n            vector<int> pf = pfv[i];\\n            for(auto el : pf)\\n                mx_go_left = min(mx_go_left, mpl[el]);\\n            \\n            if(i-1 < mx_go_left)\\n                break;\\n        }      \\n        \\n        if(mx_go_left <= mx_go_right)\\n            return -1;\\n        \\n        return mx_go_right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define MAX 1000005\\n\\nclass Solution {\\npublic:\\n    vector<int> getpFactors(int n) {\\n        vector<int> res;\\n        for (int i = 2; i < 1000; i++)\\n            if (n % i == 0) {\\n                res.push_back(i);\\n                while(n % i == 0)\\n                    n /= i;\\n            }\\n        if (n > 1)\\n            res.push_back(n);\\n        return res;\\n    }\\n    \\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if(n==1)\\n            return -1;\\n\\n        unordered_map<int, int> mpr;\\n        unordered_map<int, int> mpl;\\n        unordered_map<int, vector<int>> pfv;\\n        \\n        for(int i=0;i<n;i++){\\n            int val = nums[i];\\n            vector<int> pf = getpFactors(val);\\n            pfv[i] = pf;\\n            for(auto el : pf){\\n                mpr[el] = i;\\n                \\n                if(mpl.find(el) == mpl.end())\\n                    mpl[el] = i;\\n            }\\n        }\\n        \\n        \\n        int mx_go_right = 0;\\n        for(int i=0;i<n;i++){\\n            vector<int> pf = pfv[i];\\n            for(auto el : pf)\\n                mx_go_right = max(mx_go_right, mpr[el]);\\n            \\n            if(i+1 > mx_go_right)\\n                break;\\n        }\\n        \\n        int mx_go_left = n;\\n        for(int i=n-1;i>=0;i--){\\n            vector<int> pf = pfv[i];\\n            for(auto el : pf)\\n                mx_go_left = min(mx_go_left, mpl[el]);\\n            \\n            if(i-1 < mx_go_left)\\n                break;\\n        }      \\n        \\n        if(mx_go_left <= mx_go_right)\\n            return -1;\\n        \\n        return mx_go_right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260045,
                "title": "java-using-sieve-and-last-index-having-the-prime-factor",
                "content": "**Thanks to Coding Mohan (https://leetcode.com/codingmohan) for the amazing intuition with the explanation \\u2764\\uD83D\\uDE4F**\\n* **Link of explanation :- https://youtu.be/lyJgJasrLVc**\\n* **If you don\\'t know about Sieve of Eratosthenes, Link :- https://youtu.be/0DT1_B0PVak**\\n```\\nclass Solution {\\n    int n=(int)(1e6);\\n    int[] spf=new int[n+1];\\n    public void sieve(){\\n        for(int i=1;i<=n;i++){\\n            spf[i]=i;\\n        }\\n        for(int j=2;j*j<=n;j++){\\n            if(spf[j]==j){\\n                for(int k=j*j;k<=n;k+=j){\\n                    if(spf[k]==k){\\n                        spf[k]=j;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    public int findValidSplit(int[] nums) {\\n        sieve();\\n        int[] lastfactorindex=new int[n+1];\\n        for(int i=0;i<nums.length;i++){\\n            int x=nums[i];\\n            List<Integer> pf=new ArrayList<>();\\n            while(x!=1){\\n                int z=spf[x];\\n                while(x%z==0)\\n                    x/=z;\\n                pf.add(z);  \\n            }\\n            for(int distfactors:pf){\\n                lastfactorindex[distfactors]=i;\\n            }\\n        }\\n        int splitind=0;\\n        int i=0;\\n        for(;i<=splitind;i++){\\n            int x=nums[i];\\n            List<Integer> pf=new ArrayList<>();\\n            while(x!=1){\\n                int z=spf[x];\\n                while(x%z==0)\\n                    x/=z;\\n                pf.add(z);  \\n            }\\n            for(int distfactors:pf){\\n                splitind=Math.max(splitind,lastfactorindex[distfactors]);\\n            }\\n        }\\n        if(splitind==nums.length-1) return -1;\\n        return splitind;       \\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/ff7338a8-a82a-4fe4-a3f7-0cd1e907eff5_1678016445.4138432.png)\\n\\n![image](https://assets.leetcode.com/users/images/e16bac90-d4ec-42bb-be61-a6511d9d33ae_1678015821.1061234.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    int n=(int)(1e6);\\n    int[] spf=new int[n+1];\\n    public void sieve(){\\n        for(int i=1;i<=n;i++){\\n            spf[i]=i;\\n        }\\n        for(int j=2;j*j<=n;j++){\\n            if(spf[j]==j){\\n                for(int k=j*j;k<=n;k+=j){\\n                    if(spf[k]==k){\\n                        spf[k]=j;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    public int findValidSplit(int[] nums) {\\n        sieve();\\n        int[] lastfactorindex=new int[n+1];\\n        for(int i=0;i<nums.length;i++){\\n            int x=nums[i];\\n            List<Integer> pf=new ArrayList<>();\\n            while(x!=1){\\n                int z=spf[x];\\n                while(x%z==0)\\n                    x/=z;\\n                pf.add(z);  \\n            }\\n            for(int distfactors:pf){\\n                lastfactorindex[distfactors]=i;\\n            }\\n        }\\n        int splitind=0;\\n        int i=0;\\n        for(;i<=splitind;i++){\\n            int x=nums[i];\\n            List<Integer> pf=new ArrayList<>();\\n            while(x!=1){\\n                int z=spf[x];\\n                while(x%z==0)\\n                    x/=z;\\n                pf.add(z);  \\n            }\\n            for(int distfactors:pf){\\n                splitind=Math.max(splitind,lastfactorindex[distfactors]);\\n            }\\n        }\\n        if(splitind==nums.length-1) return -1;\\n        return splitind;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270702,
                "title": "much-faster-similar-to-2580-from-same-day-bi-weekly-contest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Similar Ranging logic as [2580. Count Ways to Group Overlapping Ranges](https://leetcode.com/problems/count-ways-to-group-overlapping-ranges/solutions/3256371/java-c-python-sort-solution/?orderBy=most_votes)\\n    - 2580 was one of the problems in the bi-weekly contest of the same day\\n- Find all possible prime factors for all numbers\\n- Remember left most and right most indices for each prime factor\\n- We just need to find left most possible places where ranges do not overlap\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# [109 ms](https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/911212091/)\\n```java\\nclass Solution {\\n    public int findValidSplit(int[] a) {\\n        int n = a.length;\\n        if (a[0] == 1) return n == 1 ? -1 : 0; // if first is 1 and 1 is only element, no valid split, otherwise 0 is the best split\\n        Map<Integer, int[]> primeRanges = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++)\\n            updateMap(i, a[i], primeRanges); // update left and right nost of all prime factors\\n\\n        List<int[]> l = new ArrayList(primeRanges.values());\\n        Collections.sort(l, (x, y) -> x[0] - y[0]); // sort by start of every range\\n\\n        int end = l.get(0)[1];\\n        for (var r : l) {\\n            if (end < r[0]) return end; // a valid split, no primes overlap with each other\\n            end = Math.max(end, r[1]); // for all overlap ranges, we need the max end\\n        }\\n\\n        return end == n-1 ? -1 : end;\\n    }\\n\\n    private void updateMap(int idx, int x, Map<Integer, int[]> primeRanges) {\\n        if (x % 2 == 0)\\n            x = _updateMap(idx, x, 2, primeRanges); // first prime\\n\\n        int end = (int) Math.sqrt(x);\\n        for (int p = 3; p <= end; p += 2) // check all odd numbers, improve efficiency\\n            if (x % p == 0)\\n                x = _updateMap(idx, x, p, primeRanges);\\n\\n        if (x != 1) _updateMap(idx, x, x, primeRanges); // one last prime number left\\n    }\\n\\n    private int _updateMap(int idx, int x, int p, Map<Integer, int[]> map) {\\n        var range = map.get(p);\\n        if (range == null)\\n            map.put(p, range = new int[]{10_000, -1});\\n\\n        range[0] = Math.min(range[0], idx);\\n        range[1] = Math.max(range[1], idx);\\n\\n        while (x % p == 0) x /= p;\\n        return x;\\n    }\\n}\\n```\\n[72 ms, hack](https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/911226241/)\\n```java\\nclass Solution {\\n    static int[] primes = new int[] {\\n        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,\\n        101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,\\n        211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,\\n        307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,\\n        401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,\\n        503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,\\n        601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,\\n        701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,\\n        809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,\\n        907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997\\n    };\\n    public int findValidSplit(int[] a) {\\n        int n = a.length;\\n        if (a[0] == 1) return n == 1 ? -1 : 0; // if first is 1 and 1 is only element, no valid split, otherwise 0 is the best split\\n        Map<Integer, int[]> primeRanges = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++)\\n            updateMap(i, a[i], primeRanges);\\n\\n        List<int[]> l = new ArrayList(primeRanges.values());\\n        Collections.sort(l, (x, y) -> x[0] - y[0]);\\n \\n        int end = l.get(0)[1];\\n        for (var r : l) {\\n            if (end < r[0]) return end;\\n            end = Math.max(end, r[1]);\\n        }\\n\\n        return end == n-1 ? -1 : end;\\n    }\\n\\n    private void updateMap(int idx, int x, Map<Integer, int[]> primeRanges) {\\n        int end = (int) Math.sqrt(x);\\n        for (var p : primes) {\\n            if (p > end) break;\\n            if (x % p == 0)\\n                x = _updateMap(idx, x, p, primeRanges);\\n        }\\n\\n        if (x != 1) _updateMap(idx, x, x, primeRanges);\\n    }\\n\\n    private int _updateMap(int idx, int x, int p, Map<Integer, int[]> map) {\\n        var range = map.get(p);\\n        if (range == null)\\n            map.put(p, range = new int[]{10_000, -1});\\n\\n        range[0] = Math.min(range[0], idx);\\n        range[1] = Math.max(range[1], idx);\\n\\n        while (x % p == 0) x /= p;\\n        return x;\\n    }\\n}\\n```\\n[56 ms, more hack](https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/911267660/)\\n```java\\nclass Solution {\\n    static int[] primes = new int[] {\\n        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,\\n        101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,\\n        211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,\\n        307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,\\n        401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,\\n        503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,\\n        601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,\\n        701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,\\n        809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,\\n        907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997\\n    };\\n\\n\\n    private static int N = 5_000_000;\\n    private static boolean[] P = primes(N);\\n    private static boolean[] primes(int n) {\\n        boolean[] P = new boolean[n];\\n        P[2] = true;\\n        for (int i = 3; i < n; i+=2) P[i] = true;\\n\\n        int e = (int)Math.sqrt(n);\\n        for (int p = 3; p <= e; p+=2) {\\n            int d = p*2;\\n            if (P[p]) for (int x = p*p; x < n; x += d)\\n                if (P[x]) P[x] = false;\\n        }\\n\\n        return P;\\n    }\\n\\n    public int findValidSplit(int[] a) {\\n        int n = a.length;\\n        if (a[0] == 1) return n == 1 ? -1 : 0; // if first is 1 and 1 is only element, no valid split, otherwise 0 is the best split\\n        Map<Integer, int[]> primeRanges = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++)\\n            updateMap(i, a[i], primeRanges);\\n\\n        List<int[]> l = new ArrayList(primeRanges.values());\\n        Collections.sort(l, (x, y) -> x[0] - y[0]);\\n \\n        int end = l.get(0)[1];\\n        for (var r : l) {\\n            if (end < r[0]) return end;\\n            end = Math.max(end, r[1]);\\n        }\\n\\n        return end == n-1 ? -1 : end;\\n    }\\n\\n    private void updateMap(int idx, int x, Map<Integer, int[]> primeRanges) {\\n        if (P[x]) {\\n            _updateMap(idx, x, x, primeRanges);\\n            return;\\n        }\\n\\n        int end = (int) Math.sqrt(x);\\n        for (var p : primes) {\\n            if (p > end) break;\\n            if (x % p == 0)\\n                x = _updateMap(idx, x, p, primeRanges);\\n        }\\n\\n        if (x != 1) _updateMap(idx, x, x, primeRanges);\\n    }\\n\\n    private int _updateMap(int idx, int x, int p, Map<Integer, int[]> map) {\\n        var range = map.get(p);\\n        if (range == null)\\n            map.put(p, range = new int[]{10_000, -1});\\n\\n        range[0] = Math.min(range[0], idx);\\n        range[1] = Math.max(range[1], idx);\\n\\n        while (x % p == 0) x /= p;\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int findValidSplit(int[] a) {\\n        int n = a.length;\\n        if (a[0] == 1) return n == 1 ? -1 : 0; // if first is 1 and 1 is only element, no valid split, otherwise 0 is the best split\\n        Map<Integer, int[]> primeRanges = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++)\\n            updateMap(i, a[i], primeRanges); // update left and right nost of all prime factors\\n\\n        List<int[]> l = new ArrayList(primeRanges.values());\\n        Collections.sort(l, (x, y) -> x[0] - y[0]); // sort by start of every range\\n\\n        int end = l.get(0)[1];\\n        for (var r : l) {\\n            if (end < r[0]) return end; // a valid split, no primes overlap with each other\\n            end = Math.max(end, r[1]); // for all overlap ranges, we need the max end\\n        }\\n\\n        return end == n-1 ? -1 : end;\\n    }\\n\\n    private void updateMap(int idx, int x, Map<Integer, int[]> primeRanges) {\\n        if (x % 2 == 0)\\n            x = _updateMap(idx, x, 2, primeRanges); // first prime\\n\\n        int end = (int) Math.sqrt(x);\\n        for (int p = 3; p <= end; p += 2) // check all odd numbers, improve efficiency\\n            if (x % p == 0)\\n                x = _updateMap(idx, x, p, primeRanges);\\n\\n        if (x != 1) _updateMap(idx, x, x, primeRanges); // one last prime number left\\n    }\\n\\n    private int _updateMap(int idx, int x, int p, Map<Integer, int[]> map) {\\n        var range = map.get(p);\\n        if (range == null)\\n            map.put(p, range = new int[]{10_000, -1});\\n\\n        range[0] = Math.min(range[0], idx);\\n        range[1] = Math.max(range[1], idx);\\n\\n        while (x % p == 0) x /= p;\\n        return x;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    static int[] primes = new int[] {\\n        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,\\n        101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,\\n        211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,\\n        307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,\\n        401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,\\n        503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,\\n        601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,\\n        701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,\\n        809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,\\n        907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997\\n    };\\n    public int findValidSplit(int[] a) {\\n        int n = a.length;\\n        if (a[0] == 1) return n == 1 ? -1 : 0; // if first is 1 and 1 is only element, no valid split, otherwise 0 is the best split\\n        Map<Integer, int[]> primeRanges = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++)\\n            updateMap(i, a[i], primeRanges);\\n\\n        List<int[]> l = new ArrayList(primeRanges.values());\\n        Collections.sort(l, (x, y) -> x[0] - y[0]);\\n \\n        int end = l.get(0)[1];\\n        for (var r : l) {\\n            if (end < r[0]) return end;\\n            end = Math.max(end, r[1]);\\n        }\\n\\n        return end == n-1 ? -1 : end;\\n    }\\n\\n    private void updateMap(int idx, int x, Map<Integer, int[]> primeRanges) {\\n        int end = (int) Math.sqrt(x);\\n        for (var p : primes) {\\n            if (p > end) break;\\n            if (x % p == 0)\\n                x = _updateMap(idx, x, p, primeRanges);\\n        }\\n\\n        if (x != 1) _updateMap(idx, x, x, primeRanges);\\n    }\\n\\n    private int _updateMap(int idx, int x, int p, Map<Integer, int[]> map) {\\n        var range = map.get(p);\\n        if (range == null)\\n            map.put(p, range = new int[]{10_000, -1});\\n\\n        range[0] = Math.min(range[0], idx);\\n        range[1] = Math.max(range[1], idx);\\n\\n        while (x % p == 0) x /= p;\\n        return x;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    static int[] primes = new int[] {\\n        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,\\n        101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,\\n        211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,\\n        307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,\\n        401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,\\n        503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,\\n        601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,\\n        701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,\\n        809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,\\n        907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997\\n    };\\n\\n\\n    private static int N = 5_000_000;\\n    private static boolean[] P = primes(N);\\n    private static boolean[] primes(int n) {\\n        boolean[] P = new boolean[n];\\n        P[2] = true;\\n        for (int i = 3; i < n; i+=2) P[i] = true;\\n\\n        int e = (int)Math.sqrt(n);\\n        for (int p = 3; p <= e; p+=2) {\\n            int d = p*2;\\n            if (P[p]) for (int x = p*p; x < n; x += d)\\n                if (P[x]) P[x] = false;\\n        }\\n\\n        return P;\\n    }\\n\\n    public int findValidSplit(int[] a) {\\n        int n = a.length;\\n        if (a[0] == 1) return n == 1 ? -1 : 0; // if first is 1 and 1 is only element, no valid split, otherwise 0 is the best split\\n        Map<Integer, int[]> primeRanges = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++)\\n            updateMap(i, a[i], primeRanges);\\n\\n        List<int[]> l = new ArrayList(primeRanges.values());\\n        Collections.sort(l, (x, y) -> x[0] - y[0]);\\n \\n        int end = l.get(0)[1];\\n        for (var r : l) {\\n            if (end < r[0]) return end;\\n            end = Math.max(end, r[1]);\\n        }\\n\\n        return end == n-1 ? -1 : end;\\n    }\\n\\n    private void updateMap(int idx, int x, Map<Integer, int[]> primeRanges) {\\n        if (P[x]) {\\n            _updateMap(idx, x, x, primeRanges);\\n            return;\\n        }\\n\\n        int end = (int) Math.sqrt(x);\\n        for (var p : primes) {\\n            if (p > end) break;\\n            if (x % p == 0)\\n                x = _updateMap(idx, x, p, primeRanges);\\n        }\\n\\n        if (x != 1) _updateMap(idx, x, x, primeRanges);\\n    }\\n\\n    private int _updateMap(int idx, int x, int p, Map<Integer, int[]> map) {\\n        var range = map.get(p);\\n        if (range == null)\\n            map.put(p, range = new int[]{10_000, -1});\\n\\n        range[0] = Math.min(range[0], idx);\\n        range[1] = Math.max(range[1], idx);\\n\\n        while (x % p == 0) x /= p;\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259391,
                "title": "simple-solution-with-scan-line-sieve-of-eratosthenes",
                "content": "# Intuition\\nFor a prime P, find the start and end positions, such that elements in those positions are divisible by prime P. Elements from start to end should belong to same group either left or right.\\n\\n# Approach\\nFor every prime, which divides atleat one element of nums, find start & end positions and make sure all positions either belong to either left group or right group. Use Sieve of Eratosthenes get prime factors and scan line algorithm to mark that split is not possible between start and end positions.\\n\\n# Notations\\nm = max element\\nn = len of nums\\np = no of primes till m\\n\\n# Complexity\\n    Time complexity: O(m * log(log(m)) + n * log(m) * log(p))\\n    Space complexity: O(n + m + p)\\n    p can be replaced with m, as p is order of m\\n\\n# Code\\n```\\n#define f first\\n#define s second\\nclass Primes {\\n  private:\\n    int n;\\n  public:\\n    vector<int> isPrime;\\n    vector<int> primeFactor;\\n    Primes (int n) {\\n      isPrime.resize(n + 1, 1);\\n      primeFactor.resize(n + 1);\\n      int i = 2;\\n      isPrime[0] = isPrime[1] = false;\\n      while(i * i <= n) {\\n        if (isPrime[i]) {\\n          for (int j = i * i; j <= n; j += i) {\\n            isPrime[j] = false;\\n            primeFactor[j] = i;\\n          }\\n        }\\n        i++;\\n      }\\n      for(int i = 2; i <= n; i++) {\\n        if (!isPrime[i]) continue;\\n        primeFactor[i] = i;\\n      }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int maxEle = *max_element(nums.begin(), nums.end());\\n        Primes p(maxEle);\\n        int n = nums.size();\\n        map<int, pair<int, int>> pos;\\n        for (int i = 0; i < n; i++) {\\n            int val = nums[i];\\n            while (val != 1) {\\n                int pf = p.primeFactor[val];\\n                //storing start & end positions of a prime\\n                if (pos.find(pf) == pos.end()) pos[pf] = {i, i};\\n                else pos[pf].s = i;\\n                while (val % pf == 0) {\\n                    val /= pf;\\n                }\\n            }\\n        }\\n        vector<int> isNotPossible(n, 0);\\n        for (auto p: pos) {\\n            // making sure split is not possible between start and end\\n            isNotPossible[p.s.f] += 1;\\n            isNotPossible[p.s.s] += -1;\\n        }\\n        for (int i = 1; i < n; i++) {\\n            isNotPossible[i] += isNotPossible[i - 1];\\n        }\\n        for (int i = 0; i < n - 1; i++) if (!isNotPossible[i]) return i;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define f first\\n#define s second\\nclass Primes {\\n  private:\\n    int n;\\n  public:\\n    vector<int> isPrime;\\n    vector<int> primeFactor;\\n    Primes (int n) {\\n      isPrime.resize(n + 1, 1);\\n      primeFactor.resize(n + 1);\\n      int i = 2;\\n      isPrime[0] = isPrime[1] = false;\\n      while(i * i <= n) {\\n        if (isPrime[i]) {\\n          for (int j = i * i; j <= n; j += i) {\\n            isPrime[j] = false;\\n            primeFactor[j] = i;\\n          }\\n        }\\n        i++;\\n      }\\n      for(int i = 2; i <= n; i++) {\\n        if (!isPrime[i]) continue;\\n        primeFactor[i] = i;\\n      }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int maxEle = *max_element(nums.begin(), nums.end());\\n        Primes p(maxEle);\\n        int n = nums.size();\\n        map<int, pair<int, int>> pos;\\n        for (int i = 0; i < n; i++) {\\n            int val = nums[i];\\n            while (val != 1) {\\n                int pf = p.primeFactor[val];\\n                //storing start & end positions of a prime\\n                if (pos.find(pf) == pos.end()) pos[pf] = {i, i};\\n                else pos[pf].s = i;\\n                while (val % pf == 0) {\\n                    val /= pf;\\n                }\\n            }\\n        }\\n        vector<int> isNotPossible(n, 0);\\n        for (auto p: pos) {\\n            // making sure split is not possible between start and end\\n            isNotPossible[p.s.f] += 1;\\n            isNotPossible[p.s.s] += -1;\\n        }\\n        for (int i = 1; i < n; i++) {\\n            isNotPossible[i] += isNotPossible[i - 1];\\n        }\\n        for (int i = 0; i < n - 1; i++) if (!isNotPossible[i]) return i;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258311,
                "title": "python3-check-common-factors",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/e3093716659ec141e47ca013abcf405967592686) for solutions of weekly 335. \\n\\n**Intuition**\\nHere, we cannot actually compute the products as they can become astronomically large. Rather, we can collect prime factors and check if at any index no common prime factors were found in the prefix and suffix arrays. \\n**Implementation**\\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        freq = Counter()\\n        for x in nums: \\n            for p in range(2, isqrt(x)+1): \\n                while x % p == 0: \\n                    freq[p] += 1\\n                    x //= p \\n            if x > 1: freq[x] += 1\\n        ovlp = 0 \\n        prefix = Counter()\\n        for i, x in enumerate(nums): \\n            if i <= len(nums)-2: \\n                for p in range(2, isqrt(x)+1): \\n                    if x % p == 0: \\n                        if prefix[p] == 0: ovlp += 1\\n                        while x % p == 0: \\n                            prefix[p] += 1\\n                            x //= p \\n                        if prefix[p] == freq[p]: ovlp -= 1\\n                if x > 1: \\n                    if prefix[x] == 0: ovlp += 1\\n                    prefix[x] += 1\\n                    if prefix[x] == freq[x]: ovlp -= 1\\n                if not ovlp: return i \\n        return -1 \\n```\\n**Complexity**\\nTime `O(N\\u221AN)`\\nSpace `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        freq = Counter()\\n        for x in nums: \\n            for p in range(2, isqrt(x)+1): \\n                while x % p == 0: \\n                    freq[p] += 1\\n                    x //= p \\n            if x > 1: freq[x] += 1\\n        ovlp = 0 \\n        prefix = Counter()\\n        for i, x in enumerate(nums): \\n            if i <= len(nums)-2: \\n                for p in range(2, isqrt(x)+1): \\n                    if x % p == 0: \\n                        if prefix[p] == 0: ovlp += 1\\n                        while x % p == 0: \\n                            prefix[p] += 1\\n                            x //= p \\n                        if prefix[p] == freq[p]: ovlp -= 1\\n                if x > 1: \\n                    if prefix[x] == 0: ovlp += 1\\n                    prefix[x] += 1\\n                    if prefix[x] == freq[x]: ovlp -= 1\\n                if not ovlp: return i \\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258128,
                "title": "c-map-all-factors-in-unordered-map-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    void help(int x,unordered_map<int,int> &mp){\\n        int t = x;\\n        for(int i=2;i*i<=x;i++){\\n            while(t%i==0){\\n                mp[i]+=1;\\n                t /= i;\\n            }\\n        }\\n        if(t>1 || t==x){\\n            mp[t]+=1;\\n        }\\n    }    \\n    int findValidSplit(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(auto i : nums){\\n            help(i,mp);\\n        }\\n\\t\\tmp[1] = 1;\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();i++){\\n            help(nums[i],m);\\n            bool flg = true;\\n            for(auto a : m){\\n                if(a.second < mp[a.first]){\\n                    flg = false;\\n                    break;\\n                }\\n            }\\n            if(flg) return i!=nums.size()-1?i:-1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void help(int x,unordered_map<int,int> &mp){\\n        int t = x;\\n        for(int i=2;i*i<=x;i++){\\n            while(t%i==0){\\n                mp[i]+=1;\\n                t /= i;\\n            }\\n        }\\n        if(t>1 || t==x){\\n            mp[t]+=1;\\n        }\\n    }    \\n    int findValidSplit(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(auto i : nums){\\n            help(i,mp);\\n        }\\n\\t\\tmp[1] = 1;\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();i++){\\n            help(nums[i],m);\\n            bool flg = true;\\n            for(auto a : m){\\n                if(a.second < mp[a.first]){\\n                    flg = false;\\n                    break;\\n                }\\n            }\\n            if(flg) return i!=nums.size()-1?i:-1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258079,
                "title": "python-explanation-prime-update-rightmost-index-o-n-sqrt-nums-i",
                "content": "We consider that given `[4,7,15,8,3,5]`, where is the minimum index that should be covered in left split?\\nThat is, we should first check `4` to find the rightmost number that is not co-prime to it. The answer is `8` at index `3`. If we put 8 in the right split, then the product of two arrays will be not co-prime.\\nThen, because we should contain 8 in the left split, `[4, 7, 15, 8]` is now in the left split.\\nTherefore, we should check the rightmost number that is not co-prime to any of `[7, 15, 8]`. In the process, we are keep updating the rightmost index until the rightmost index is checked.\\nIf rightmost index is the last item of the array, then all elements should be covered in left split, thus no such split exist, return -1.\\n\\nWe record the index of each prime last occurs in `lastp`. Finding all prime cost `sqrt(nums[i])`, resulting in Time Complexity `O(N * sqrt(nums[i]))`.\\nUpdating rightmost index also requires to get primes for every element to update with the maximum of `lastp[p]`, where `p` is the prime of that element.\\n\\n\\n```\\nclass Solution(object):\\n    def findValidSplit(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def yieldprime(n):\\n            while n % 2 == 0:\\n                n >>= 1\\n                yield 2\\n            p = 3\\n            while p * p <= n:\\n                while n % p == 0:\\n                    n //= p\\n                    yield p\\n                p += 2\\n            if n > 1:\\n                yield n\\n            \\n        lastp = {}\\n        for i, n in enumerate(nums):\\n            for p in yieldprime(n):\\n                lastp[p] = i\\n        l = 0\\n        maxl = 0\\n        while l <= maxl:\\n            n = nums[l]\\n            for p in yieldprime(nums[l]):\\n                maxl = max(maxl, lastp[p])\\n            l += 1\\n        return maxl if maxl != len(nums) - 1 else -1\\n                    \\n                \\n                \\n                    \\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findValidSplit(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def yieldprime(n):\\n            while n % 2 == 0:\\n                n >>= 1\\n                yield 2\\n            p = 3\\n            while p * p <= n:\\n                while n % p == 0:\\n                    n //= p\\n                    yield p\\n                p += 2\\n            if n > 1:\\n                yield n\\n            \\n        lastp = {}\\n        for i, n in enumerate(nums):\\n            for p in yieldprime(n):\\n                lastp[p] = i\\n        l = 0\\n        maxl = 0\\n        while l <= maxl:\\n            n = nums[l]\\n            for p in yieldprime(nums[l]):\\n                maxl = max(maxl, lastp[p])\\n            l += 1\\n        return maxl if maxl != len(nums) - 1 else -1\\n                    \\n                \\n                \\n                    \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263371,
                "title": "easiest-approach-commented-prime-factors-mapping",
                "content": "**QUICK HINTS**:\\n1. Taking Prefix or Suffix won\\'t work as nums[i]<=10^6 and n<=10^4.\\n2. When can we have gcd of two sets of numbers =1 ?\\n3. Answer is: if they don\\'t have a common prime factor\\n4. How can we check if array till current index has a common prime factor after this index or not?\\n\\n**STEPS:**\\n1. We store all prime factors of each nums[i] in a 2D vector\\n2. We also neeed to store when a particular prima factor last appeared in the array.\\n3. We do this by storing the index of each prime factor while calculating .\\n\\n**CODE:**\\n\\n```\\nint findValidSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int> pos; // stores last appearance of prime factors\\n        vector<vector<int>> pf(n);  // stores all prime factors of each index\\n        \\n        for(int i=0;i<n;i++){\\n            int x=nums[i];\\n            for(int j=2;j*j<=x;j++){  // going through all prime factos of x\\n                if(x%j==0){\\n                    pos[j]=i;           // updating the last appearance of prime factor j to index i  \\n                    pf[i].push_back(j); // storing the prime factor j at index i\\n                    while(x%j==0)x/=j;\\n                }\\n            }\\n            if(x>1){                    //what if x is still a prime number, we do the same for x\\n                pos[x]=i;               \\n                pf[i].push_back(x);\\n            }\\n        }\\n        int mx=0;                 // maximum index of any prime factor till now\\n        for(int i=0;i<n-1;i++){\\n            for(int j: pf[i]){\\n                mx=max(mx,pos[j]); // updating the maximum position of all prime factors till index i\\n            }\\n            if(mx==i)return i;     // if we don\\'t have these prime factors after this index, return i\\n        }   \\n        return -1;                 // we can\\'t form 2 arrays \\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nint findValidSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int> pos; // stores last appearance of prime factors\\n        vector<vector<int>> pf(n);  // stores all prime factors of each index\\n        \\n        for(int i=0;i<n;i++){\\n            int x=nums[i];\\n            for(int j=2;j*j<=x;j++){  // going through all prime factos of x\\n                if(x%j==0){\\n                    pos[j]=i;           // updating the last appearance of prime factor j to index i  \\n                    pf[i].push_back(j); // storing the prime factor j at index i\\n                    while(x%j==0)x/=j;\\n                }\\n            }\\n            if(x>1){                    //what if x is still a prime number, we do the same for x\\n                pos[x]=i;               \\n                pf[i].push_back(x);\\n            }\\n        }\\n        int mx=0;                 // maximum index of any prime factor till now\\n        for(int i=0;i<n-1;i++){\\n            for(int j: pf[i]){\\n                mx=max(mx,pos[j]); // updating the maximum position of all prime factors till index i\\n            }\\n            if(mx==i)return i;     // if we don\\'t have these prime factors after this index, return i\\n        }   \\n        return -1;                 // we can\\'t form 2 arrays \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3258831,
                "title": "video-and-image-explnation-find-max-index-for-each-factor-o-n-sqrt-max-element-c",
                "content": "If you don\\'t know hindi skip video and read the blog , video is in hindi [https://www.youtube.com/watch?v=y2TyN-rRsgs]()\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we **cant find Product** of two groups using bruteforce because it will be **upto (10^6)^10^4** which is **not possible** to **store** .\\n\\nSo next we can focus on is **GCD** , We want to form groups such that GCD = 1 , it means that factors of Group1 should be distict to factors of Group 2 ,\\nSo now can we use Factors to find solution ? Yes since max value of element of array can be upto 10^6 so we can find factors in O(sqrt(n)) = 10^3 in worst time and since n = 10^4 \\u2013 total number of operation  = 10^7 which will be with in our time limit .\\n![IMG_0355.PNG](https://assets.leetcode.com/users/images/4a6f904f-8d0f-47a1-9e48-04fd5b38f4a6_1677996002.554265.png)\\n\\n![IMG_0356.PNG](https://assets.leetcode.com/users/images/e1ccc362-4e66-4a53-90e4-6d4d3a279d8d_1677996033.9500675.png)\\n\\n![IMG_0357.PNG](https://assets.leetcode.com/users/images/0cbc0363-687c-46b7-a22c-b2da0a0ff7aa_1677996047.8117945.png)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow how can we use factors to find split index ? Since the **factors** of both groups should be distict from each other , so we will find **[ smallest_index, biggest_index ]** for each factor  ,  and we need to take all those values in this range . \\nNow we do these things :- \\n1. Traverse through the array\\n2. Find the maximum index for each factors \\n3. If [ i  == maximum_index ] this means we have a found a group from [0 , i] where each factors \\nHave range [0,i] as required so we return i. \\n\\nNote :- We don\\'t update biggest index for \\'1\\'\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*sqrt(mx)) where mx = max element of array\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(mx)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n         \\n        int n = nums.size();\\n        int mx = 0;\\n        for(auto&x:nums)mx = max(mx,x);\\n         \\n        //we want to find smallest and biggest index for each factor\\n        //we will use idx array of pair to store\\n        vector<pair<int,int>>idx(mx+1,{-1,-1});\\n        \\n        for(int i=0;i<n;++i){\\n            //finding factors of nums[i]\\n            for(int j = 2;j*j<=nums[i];++j){\\n                if(nums[i]%j == 0){\\n                    //updating the starting and ending index of\\n                    //factors \\'j\\' \\n                    if(idx[j].first == -1){\\n                        idx[j].first = i;\\n                    }\\n                    idx[j].second = max(idx[j].second,i);\\n                    \\n                    //updating the starting and ending index of\\n                    //factors \\'nums[i]/j\\'\\n                    if(idx[nums[i]/j].first == -1){\\n                        idx[nums[i]/j].second = i;\\n                    }\\n                    idx[nums[i]/j].second = max(idx[nums[i]/j].second , i);\\n                }\\n            }\\n            //we will take nums[i] as factor of itself too\\n            //and update its indexes\\n            if(idx[nums[i]].first == -1){\\n                idx[nums[i]].first = i;\\n                idx[nums[i]].second = i;\\n            }\\n            if(nums[i]>1)idx[nums[i]].second = max(idx[nums[i]].second,i);\\n        }\\n        \\n        //we traverse through array and find the maximum index\\n        //of each factor and as soon as mx == i we got \\n        // a group where all factors are in range [0, i ]\\n         \\n        mx = -1;\\n        for(int i=0;i<(n-1);++i){\\n              for(int j = 2;j*j<=nums[i];++j){\\n                if(nums[i]%j == 0){\\n                    mx = max(mx,idx[j].second);\\n                    mx = max(mx,idx[nums[i]/j].second);\\n                }\\n            } \\n            mx = max(idx[nums[i]].second,mx);\\n            \\n            if(i == mx)return i;\\n        }\\n        \\n        return -1;\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n         \\n        int n = nums.size();\\n        int mx = 0;\\n        for(auto&x:nums)mx = max(mx,x);\\n         \\n        //we want to find smallest and biggest index for each factor\\n        //we will use idx array of pair to store\\n        vector<pair<int,int>>idx(mx+1,{-1,-1});\\n        \\n        for(int i=0;i<n;++i){\\n            //finding factors of nums[i]\\n            for(int j = 2;j*j<=nums[i];++j){\\n                if(nums[i]%j == 0){\\n                    //updating the starting and ending index of\\n                    //factors \\'j\\' \\n                    if(idx[j].first == -1){\\n                        idx[j].first = i;\\n                    }\\n                    idx[j].second = max(idx[j].second,i);\\n                    \\n                    //updating the starting and ending index of\\n                    //factors \\'nums[i]/j\\'\\n                    if(idx[nums[i]/j].first == -1){\\n                        idx[nums[i]/j].second = i;\\n                    }\\n                    idx[nums[i]/j].second = max(idx[nums[i]/j].second , i);\\n                }\\n            }\\n            //we will take nums[i] as factor of itself too\\n            //and update its indexes\\n            if(idx[nums[i]].first == -1){\\n                idx[nums[i]].first = i;\\n                idx[nums[i]].second = i;\\n            }\\n            if(nums[i]>1)idx[nums[i]].second = max(idx[nums[i]].second,i);\\n        }\\n        \\n        //we traverse through array and find the maximum index\\n        //of each factor and as soon as mx == i we got \\n        // a group where all factors are in range [0, i ]\\n         \\n        mx = -1;\\n        for(int i=0;i<(n-1);++i){\\n              for(int j = 2;j*j<=nums[i];++j){\\n                if(nums[i]%j == 0){\\n                    mx = max(mx,idx[j].second);\\n                    mx = max(mx,idx[nums[i]/j].second);\\n                }\\n            } \\n            mx = max(idx[nums[i]].second,mx);\\n            \\n            if(i == mx)return i;\\n        }\\n        \\n        return -1;\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258823,
                "title": "python-find-longest-streak",
                "content": "```\\nclass Solution:\\n  def findValidSplit(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    prod = nums[0]\\n    streak = 0\\n    streak_prod = 1\\n    for i in range(1, n):\\n      num = nums[i]\\n      if gcd(prod, num) == 1:\\n        streak += 1\\n        streak_prod *= num\\n      else:  \\n        prod *= streak_prod\\n        prod *= num\\n        streak = 0\\n        streak_prod = 1\\n    if streak == 0:    \\n      return -1  \\n    return n - streak - 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def findValidSplit(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    prod = nums[0]\\n    streak = 0\\n    streak_prod = 1\\n    for i in range(1, n):\\n      num = nums[i]\\n      if gcd(prod, num) == 1:\\n        streak += 1\\n        streak_prod *= num\\n      else:  \\n        prod *= streak_prod\\n        prod *= num\\n        streak = 0\\n        streak_prod = 1\\n    if streak == 0:    \\n      return -1  \\n    return n - streak - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258067,
                "title": "c-prime-factorization-set-intersection-o-n-sqrt-n",
                "content": "Let me know any questions\\n```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int cnt = 0;\\n        map<int, int> suf, pref, vis;\\n        for(auto i : nums){\\n            for(int j = 2; j <= sqrt(i); j++){\\n                while(i%j == 0){\\n                    suf[j]++;\\n                    i/=j;\\n                }\\n            }\\n            if(i>=2) suf[i]++;\\n        }\\n        int k = 0;\\n        for(auto i : nums){\\n            for(int j = 2; j <= sqrt(i); j++){\\n                while(i%j == 0){\\n                    pref[j]++;\\n                    suf[j]--;\\n                    i/=j;\\n                    if(suf[j] == 0 && vis[j]++ == 0) cnt++;\\n                }\\n            }\\n            if(i>=2) {\\n                pref[i]++;\\n                suf[i]--;\\n                if(suf[i] == 0 && vis[i]++ == 0) cnt++;\\n            }\\n            if(cnt == pref.size() && k<nums.size()-1) return k;\\n            k++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int cnt = 0;\\n        map<int, int> suf, pref, vis;\\n        for(auto i : nums){\\n            for(int j = 2; j <= sqrt(i); j++){\\n                while(i%j == 0){\\n                    suf[j]++;\\n                    i/=j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3263175,
                "title": "easy-intuitive-solution",
                "content": "Step 1: Make 2 maps- one to store prime factors of each index and second to store index of each prime factor.\\nStep 2: Just traverse the array, find the maximum index of each prime factor of the current index.\\nStep 3: If our max variable is equal to current index, then return the index\\n\\n\\n``\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        \\n        map<int,vector<int>> m1,m2;\\n        \\n        //m1 ->  store index of each prime factor\\n        //m2 ->  store factors of each index\\n        \\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int val=nums[i];\\n            for(int j=2;j*j<=val;j++){\\n                if(val%j==0){\\n                    m1[j].push_back(i);\\n                    m2[i].push_back(j);\\n                }\\n                while(val%j==0){\\n                    val/=j;\\n                }\\n            }\\n            if(val>1){\\n                m1[val].push_back(i);\\n                m2[i].push_back(val);\\n            }\\n        }\\n        \\n        int mx=0;      //maintaining maximum index\\n        for(int i=0;i<n-1;i++){\\n            for(auto x:m2[i]){\\n                mx=max(mx,m1[x].back());\\n            }\\n            if(mx==i){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n`",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        \\n        map<int,vector<int>> m1,m2;\\n        \\n        //m1 ->  store index of each prime factor\\n        //m2 ->  store factors of each index\\n        \\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int val=nums[i];\\n            for(int j=2;j*j<=val;j++){\\n                if(val%j==0){\\n                    m1[j].push_back(i);\\n                    m2[i].push_back(j);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3258373,
                "title": "c-with-explanation-extract-factors-and-store-largest-index-per-factor",
                "content": "# Intuition\\n1. For each input value, calculate its prime factors. Store them in `primes` vector.\\n2. Additionally, for each prime factor, store largest index of a value which contains this prime factor in `prime_to_index` map.\\n3. Iterate over input values again. Take its prime factors using `primes`. For each prime factor of a current value, we know largest index which contains this factor. Store such index in `indexes_to_clear`.\\n4. If `indexes_to_clear` contains index which is larger than current one, that means that a product in the \\'right\\' half of the array contains prime factor which \\'left\\' part of the array contains as well.\\n5. While iterating over values in a second loop, we are moving values from the \\'right\\' part of the array, into the \\'left\\' part of the array. As a result, we are removing current index from `indexes_to_clear` (if it exists).\\n6. If after processing current value we discover that `indexes_to_clear` is empty, that means that all prime factors in the \\'left\\' part of the array are no longer present in the \\'right\\' part of the array. That means that GCD of \\'left\\' and \\'right\\' products is 1. So we can return current index as our answer.\\n\\n# Complexity\\n- Time complexity:\\n`O(n*m*log(n))` where n is the size of input array, m is max number of prime factors (`sqrt(n)`)\\n\\n- Space complexity:\\n`O(n*m)` since `primes` array stores prime factors for each index.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        // Maps prime factor to largest index of input value which contains this factor.\\n        unordered_map<int, int> prime_to_index;\\n        // For each input value stores a set of its prime factors.\\n        vector<unordered_set<int>> primes(nums.size());\\n        for(int i = 0; i<nums.size(); ++i) {\\n            // Extract prime factors and store them in a set \\'primes[i]\\'\\n            find_primes(nums[i], primes[i]);\\n            // For each discovered prime factor update \\'prime_to_index\\' map.\\n            for(int n : primes[i]) {\\n                prime_to_index[n] = i;\\n            }\\n        }\\n        \\n        // This set stores indexes in the \\'right\\' array which we have to reach before claiming that we found an answer.\\n        // If this set contains an index which is larger than current one, that means that both \\'left\\' and \\'right\\' arrays have the same prime factor.\\n        set<int> indexes_to_clear;\\n        for(int i = 0; i<nums.size()-1; ++i) {\\n            // When processing current index we are moving an item from the \\'right\\' array into the \\'left\\' array, let\\'s remove this index from \\'indexes_to_clear\\' if it exists.\\n            indexes_to_clear.erase(i);\\n\\n            // Iterate over prime factors of current index and add its \\'largest indexes\\' to \\'indexes_to_clear\\'.\\n            for(int n : primes[i]) {\\n                int idx = prime_to_index[n];\\n                if(idx > i) {\\n                    indexes_to_clear.insert(idx);\\n                }\\n            }\\n            \\n            // If \\'indexes_to_clear\\' is empty that means that prime factors in \\'left\\' and \\'right\\' arrays are unique, return current index as answer.\\n            if(indexes_to_clear.empty()) {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n\\nprivate:\\n    void find_primes(int n, unordered_set<int> &primes) {\\n        if(n == 1) return;\\n        \\n        if(n%2==0) {\\n            n/=2;\\n            primes.insert(2);\\n        }\\n        while(n%2==0) {\\n            n/=2;\\n        }\\n        \\n        for (int i = 3; i <= sqrt(n); i = i + 2) {\\n            if (n%i == 0) {\\n                n/=i;\\n                primes.insert(i);\\n            }\\n            while (n%i == 0) {\\n                n/=i;\\n            }\\n        }\\n        \\n        if(n>1) {\\n            primes.insert(n);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        // Maps prime factor to largest index of input value which contains this factor.\\n        unordered_map<int, int> prime_to_index;\\n        // For each input value stores a set of its prime factors.\\n        vector<unordered_set<int>> primes(nums.size());\\n        for(int i = 0; i<nums.size(); ++i) {\\n            // Extract prime factors and store them in a set \\'primes[i]\\'\\n            find_primes(nums[i], primes[i]);\\n            // For each discovered prime factor update \\'prime_to_index\\' map.\\n            for(int n : primes[i]) {\\n                prime_to_index[n] = i;\\n            }\\n        }\\n        \\n        // This set stores indexes in the \\'right\\' array which we have to reach before claiming that we found an answer.\\n        // If this set contains an index which is larger than current one, that means that both \\'left\\' and \\'right\\' arrays have the same prime factor.\\n        set<int> indexes_to_clear;\\n        for(int i = 0; i<nums.size()-1; ++i) {\\n            // When processing current index we are moving an item from the \\'right\\' array into the \\'left\\' array, let\\'s remove this index from \\'indexes_to_clear\\' if it exists.\\n            indexes_to_clear.erase(i);\\n\\n            // Iterate over prime factors of current index and add its \\'largest indexes\\' to \\'indexes_to_clear\\'.\\n            for(int n : primes[i]) {\\n                int idx = prime_to_index[n];\\n                if(idx > i) {\\n                    indexes_to_clear.insert(idx);\\n                }\\n            }\\n            \\n            // If \\'indexes_to_clear\\' is empty that means that prime factors in \\'left\\' and \\'right\\' arrays are unique, return current index as answer.\\n            if(indexes_to_clear.empty()) {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n\\nprivate:\\n    void find_primes(int n, unordered_set<int> &primes) {\\n        if(n == 1) return;\\n        \\n        if(n%2==0) {\\n            n/=2;\\n            primes.insert(2);\\n        }\\n        while(n%2==0) {\\n            n/=2;\\n        }\\n        \\n        for (int i = 3; i <= sqrt(n); i = i + 2) {\\n            if (n%i == 0) {\\n                n/=i;\\n                primes.insert(i);\\n            }\\n            while (n%i == 0) {\\n                n/=i;\\n            }\\n        }\\n        \\n        if(n>1) {\\n            primes.insert(n);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258292,
                "title": "java-map-sweep-line-solution",
                "content": "# Intuition\\nThe idea is to find the range of each potential factor, and then do a sweep line for `i`. Stop the sweep line when there is a \"split\", i.e., when no factor range cross the split.\\n\\nAnother way to think about this problem is that for each factor, it covers an interval (from the first time it appears to the last time it appears). The ask is to find the first place/line that is not covered by any interval.\\n\\n# Complexity\\n\\nTime: $$O(n \\\\sqrt n)$$\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int findValidSplit(int[] nums) {\\n        if (nums.length == 1) {\\n            return -1;\\n        }\\n\\n        // Get factors of each number, and the factor ranges\\n        List<Integer>[] factors = new List[nums.length];\\n        Map<Integer, Integer> factorEnds = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            factors[i] = new ArrayList<>();\\n            for (int j = 2; j * j <= nums[i]; j++) {\\n                if (nums[i] % j == 0) {\\n                    factors[i].add(j);\\n                    factors[i].add(nums[i] / j);\\n                    factorEnds.put(j, i);\\n                    factorEnds.put(nums[i] / j, i);\\n                }\\n            }\\n            if (nums[i] != 1) {\\n                factors[i].add(nums[i]);\\n                factorEnds.put(nums[i], i);\\n            }\\n        }\\n\\n        // Sweep line\\n        int end = 0;\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            for (int factor : factors[i]) {\\n                end = Math.max(end, factorEnds.get(factor));\\n            }\\n            if (end == nums.length - 1) {\\n                break;\\n            }\\n            if (end == i) {\\n                return end;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int findValidSplit(int[] nums) {\\n        if (nums.length == 1) {\\n            return -1;\\n        }\\n\\n        // Get factors of each number, and the factor ranges\\n        List<Integer>[] factors = new List[nums.length];\\n        Map<Integer, Integer> factorEnds = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            factors[i] = new ArrayList<>();\\n            for (int j = 2; j * j <= nums[i]; j++) {\\n                if (nums[i] % j == 0) {\\n                    factors[i].add(j);\\n                    factors[i].add(nums[i] / j);\\n                    factorEnds.put(j, i);\\n                    factorEnds.put(nums[i] / j, i);\\n                }\\n            }\\n            if (nums[i] != 1) {\\n                factors[i].add(nums[i]);\\n                factorEnds.put(nums[i], i);\\n            }\\n        }\\n\\n        // Sweep line\\n        int end = 0;\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            for (int factor : factors[i]) {\\n                end = Math.max(end, factorEnds.get(factor));\\n            }\\n            if (end == nums.length - 1) {\\n                break;\\n            }\\n            if (end == i) {\\n                return end;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258285,
                "title": "java-map-of-prime-factors-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  private Set<Integer> primeFactors(int n) {\\n    Set<Integer> set = new HashSet<>();\\n    \\n    while (n % 2 == 0) {\\n      set.add(2);\\n      n /= 2;\\n    }\\n    for (int i = 3; i <= Math.sqrt(n); i += 2) {\\n      while (n % i == 0) {\\n        set.add(i);\\n        n /= i;\\n      }\\n    }\\n    if (n > 2) set.add(n);\\n    return set;\\n  }\\n  \\n  public int findValidSplit(int[] nums) {\\n    var suffix = new HashMap<Integer, Integer>();\\n    var prefix = new HashMap<Integer, Integer>();\\n    \\n    for (var num : nums) {\\n      Set<Integer> set = primeFactors(num);\\n      for (var a : set)\\n        suffix.put(a, suffix.getOrDefault(a, 0) + 1);\\n    }\\n    for (var i=0; i < nums.length - 1; i++) {\\n      Set<Integer> set = primeFactors(nums[i]);\\n      \\n      for (var a : set) {\\n        prefix.put(a, prefix.getOrDefault(a, 0) + 1);\\n        suffix.put(a, suffix.get(a) - 1);\\n        if (suffix.get(a) == 0) suffix.remove(a);\\n      }\\n      var nothingInCommon = true;\\n      for (var a : prefix.keySet()) {\\n        if (suffix.containsKey(a)) {\\n          nothingInCommon = false;\\n          break;\\n        }\\n      }\\n      if (nothingInCommon) return i;\\n    }\\n    return -1;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  private Set<Integer> primeFactors(int n) {\\n    Set<Integer> set = new HashSet<>();\\n    \\n    while (n % 2 == 0) {\\n      set.add(2);\\n      n /= 2;\\n    }\\n    for (int i = 3; i <= Math.sqrt(n); i += 2) {\\n      while (n % i == 0) {\\n        set.add(i);\\n        n /= i;\\n      }\\n    }\\n    if (n > 2) set.add(n);\\n    return set;\\n  }\\n  \\n  public int findValidSplit(int[] nums) {\\n    var suffix = new HashMap<Integer, Integer>();\\n    var prefix = new HashMap<Integer, Integer>();\\n    \\n    for (var num : nums) {\\n      Set<Integer> set = primeFactors(num);\\n      for (var a : set)\\n        suffix.put(a, suffix.getOrDefault(a, 0) + 1);\\n    }\\n    for (var i=0; i < nums.length - 1; i++) {\\n      Set<Integer> set = primeFactors(nums[i]);\\n      \\n      for (var a : set) {\\n        prefix.put(a, prefix.getOrDefault(a, 0) + 1);\\n        suffix.put(a, suffix.get(a) - 1);\\n        if (suffix.get(a) == 0) suffix.remove(a);\\n      }\\n      var nothingInCommon = true;\\n      for (var a : prefix.keySet()) {\\n        if (suffix.containsKey(a)) {\\n          nothingInCommon = false;\\n          break;\\n        }\\n      }\\n      if (nothingInCommon) return i;\\n    }\\n    return -1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258197,
                "title": "time-is-too-strict-python-tle",
                "content": "I have been trying to submit for almost ten times and it keeps saying TLE... The time limit is too strict...\\nPlease let me know how I can optimize...\\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        d = collections.defaultdict(int)\\n        memo = {}\\n        for num in nums:\\n            self.helper(num, d, memo)\\n        prime = set()\\n        done = set()\\n        for i in range(len(nums) - 1):\\n            for item in memo[nums[i]]:\\n                prime.add(item)\\n                d[item] -= memo[nums[i]][item]\\n                if d[item] == 0:\\n                    done.add(item)\\n            if len(done) == len(prime):\\n                return i\\n        return -1\\n                \\n    def helper(self, num, d, memo):\\n        if num in memo:\\n            for item in memo[num]:\\n                d[item] += memo[num][item]\\n            return\\n        prime = 2\\n        tmp = num\\n        memo[num] = collections.defaultdict(int)\\n        \\n        while tmp > 1:\\n            if tmp % prime == 0:\\n                d[prime] += 1\\n                memo[num][prime] += 1\\n                tmp //= prime\\n            else:\\n                prime += 1\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        d = collections.defaultdict(int)\\n        memo = {}\\n        for num in nums:\\n            self.helper(num, d, memo)\\n        prime = set()\\n        done = set()\\n        for i in range(len(nums) - 1):\\n            for item in memo[nums[i]]:\\n                prime.add(item)\\n                d[item] -= memo[nums[i]][item]\\n                if d[item] == 0:\\n                    done.add(item)\\n            if len(done) == len(prime):\\n                return i\\n        return -1\\n                \\n    def helper(self, num, d, memo):\\n        if num in memo:\\n            for item in memo[num]:\\n                d[item] += memo[num][item]\\n            return\\n        prime = 2\\n        tmp = num\\n        memo[num] = collections.defaultdict(int)\\n        \\n        while tmp > 1:\\n            if tmp % prime == 0:\\n                d[prime] += 1\\n                memo[num][prime] += 1\\n                tmp //= prime\\n            else:\\n                prime += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258069,
                "title": "javascript-common-prime-factors",
                "content": "**Solution: Common Prime Factors**\\n\\nCalculating the product creates numbers that are far too large.\\nInstead, get the prime factors of each number in the left and right sides and check if they share any common prime factors.\\nKeep the common prime factors in a hashset and remove prime factors when they are no longer shared.\\n\\nTime Complexity: `O(n sqrt(n))`\\nSpace Complexity: `O(n sqrt(n))`\\n```\\nvar findValidSplit = function(nums) {\\n  let n = nums.length, right = {};\\n  for (let i = 0; i < n; i++) {\\n    let primeFactorsCount = getPrimeFactors(nums[i]);\\n    for (let prime in primeFactorsCount) {\\n      let count = primeFactorsCount[prime];\\n      right[prime] = (right[prime] || 0) + count;\\n    }\\n  }\\n  let left = {}, common = new Set();\\n  for (let i = 0; i <= n - 2; i++) {\\n    let primesFactorsCount = getPrimeFactors(nums[i]);\\n    for (let prime in primesFactorsCount) {\\n      let count = primesFactorsCount[prime];\\n      left[prime] = (left[prime] || 0) + count;\\n      right[prime] -= count;\\n      if (right[prime] > 0) common.add(prime);\\n      else if (right[prime] === 0) common.delete(prime);\\n    }\\n    if (common.size === 0) return i;\\n  }\\n  return -1;\\n};\\n\\nfunction getPrimeFactors(n) {\\n  let counts = {};\\n  for (let x = 2; (x * x) <= n; x++) {\\n    while (n % x === 0) {\\n      counts[x] = (counts[x] || 0) + 1;\\n      n /= x;\\n    }\\n  }\\n  if (n > 1) counts[n] = (counts[n] || 0) + 1;\\n  return counts;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findValidSplit = function(nums) {\\n  let n = nums.length, right = {};\\n  for (let i = 0; i < n; i++) {\\n    let primeFactorsCount = getPrimeFactors(nums[i]);\\n    for (let prime in primeFactorsCount) {\\n      let count = primeFactorsCount[prime];\\n      right[prime] = (right[prime] || 0) + count;\\n    }\\n  }\\n  let left = {}, common = new Set();\\n  for (let i = 0; i <= n - 2; i++) {\\n    let primesFactorsCount = getPrimeFactors(nums[i]);\\n    for (let prime in primesFactorsCount) {\\n      let count = primesFactorsCount[prime];\\n      left[prime] = (left[prime] || 0) + count;\\n      right[prime] -= count;\\n      if (right[prime] > 0) common.add(prime);\\n      else if (right[prime] === 0) common.delete(prime);\\n    }\\n    if (common.size === 0) return i;\\n  }\\n  return -1;\\n};\\n\\nfunction getPrimeFactors(n) {\\n  let counts = {};\\n  for (let x = 2; (x * x) <= n; x++) {\\n    while (n % x === 0) {\\n      counts[x] = (counts[x] || 0) + 1;\\n      n /= x;\\n    }\\n  }\\n  if (n > 1) counts[n] = (counts[n] || 0) + 1;\\n  return counts;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3272734,
                "title": "c-sweep-line-beat-94",
                "content": "```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        init();\\n        const int n = nums.size();\\n        unordered_map<int,pair<int,int>> pos; //p, first i has p, last i has p\\n        for(int i=0;i<n;i++){\\n            for(auto p:factor(nums[i])){\\n                if(!pos.count(p)) pos[p].first = i;\\n                pos[p].second = i+1;\\n            }\\n        }\\n        vector<int> linePlus(n+1), lineMinus(n+1);\\n        for(auto [p, pr] : pos){\\n            linePlus[pr.first]++;\\n            lineMinus[pr.second]++;\\n        }\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            cnt -= lineMinus[i];\\n            if(i!=0 && cnt == 0) return i-1;\\n            cnt += linePlus[i];\\n        }\\n\\n        return -1;\\n    }\\n\\n    void init(){\\n        for(int i=2;i<=1000;i++){\\n            bool isP = true;\\n            for(auto p:primes){\\n                if(p > sqrt(i+1)) break;\\n                if(i % p == 0) {\\n                    isP = false;\\n                    break;\\n                }\\n            }\\n            if(isP) primes.push_back(i);\\n        }\\n    }\\n\\n    vector<int> factor(int x){\\n        vector<int> v;\\n        for(auto p:primes){\\n            if(p>sqrt(x+1)) break;\\n            if(x % p == 0){\\n                v.push_back(p);\\n                while(x%p == 0) x/=p;\\n            }\\n        }\\n        if(x>1) v.push_back(x);\\n        return v;\\n    }\\n\\n    vector<int> primes;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        init();\\n        const int n = nums.size();\\n        unordered_map<int,pair<int,int>> pos; //p, first i has p, last i has p\\n        for(int i=0;i<n;i++){\\n            for(auto p:factor(nums[i])){\\n                if(!pos.count(p)) pos[p].first = i;\\n                pos[p].second = i+1;\\n            }\\n        }\\n        vector<int> linePlus(n+1), lineMinus(n+1);\\n        for(auto [p, pr] : pos){\\n            linePlus[pr.first]++;\\n            lineMinus[pr.second]++;\\n        }\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            cnt -= lineMinus[i];\\n            if(i!=0 && cnt == 0) return i-1;\\n            cnt += linePlus[i];\\n        }\\n\\n        return -1;\\n    }\\n\\n    void init(){\\n        for(int i=2;i<=1000;i++){\\n            bool isP = true;\\n            for(auto p:primes){\\n                if(p > sqrt(i+1)) break;\\n                if(i % p == 0) {\\n                    isP = false;\\n                    break;\\n                }\\n            }\\n            if(isP) primes.push_back(i);\\n        }\\n    }\\n\\n    vector<int> factor(int x){\\n        vector<int> v;\\n        for(auto p:primes){\\n            if(p>sqrt(x+1)) break;\\n            if(x % p == 0){\\n                v.push_back(p);\\n                while(x%p == 0) x/=p;\\n            }\\n        }\\n        if(x>1) v.push_back(x);\\n        return v;\\n    }\\n\\n    vector<int> primes;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259336,
                "title": "python-beats-100-do-dry-run-with-pen-paper-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        prod = nums[0]\\n        streak = 0\\n        prod2 = 1\\n        for i in range(1, n):\\n            num = nums[i]\\n            if gcd(prod, num) == 1:\\n                streak += 1\\n                prod2 *= num\\n            else:\\n                prod *= prod2\\n                prod *= num\\n                streak = 0\\n                prod2 = 1\\n        if streak == 0: return -1\\n        return n - streak - 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        prod = nums[0]\\n        streak = 0\\n        prod2 = 1\\n        for i in range(1, n):\\n            num = nums[i]\\n            if gcd(prod, num) == 1:\\n                streak += 1\\n                prod2 *= num\\n            else:\\n                prod *= prod2\\n                prod *= num\\n                streak = 0\\n                prod2 = 1\\n        if streak == 0: return -1\\n        return n - streak - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258909,
                "title": "it-s-actually-quite-easy-very-clean-solution-o-n-log-n-c",
                "content": "# Approach\\nThink about the gcd of two elements with prime factorization, we know that for some numbers\\n\\n$x = p_1^{a_1} p_2^{a_2} \\\\dots p_n^{a_n}$\\n$y = p_1^{b_1} p_2^{b_2} \\\\dots p_n^{b_n}$\\n$gcd(x,y) = p_i^{min(a_i,b_i)}$ for all different $p$ in both $x,y$\\n\\nNow, since we need to always add the first number, there will be a strong restriction that is:\\n> All numbers that share some prime with $nums_0$ must be in PrefixProduct\\n\\nThat\\'s because if there exist some $nums_i$ with some prime factor $p$ that are also in $nums_0$ if this is not part of $PrefixProduct$ then the division will be something like.\\n\\nFor some prime factor $p$ present in $nums_0,nums_i$\\n$ProductPrefix = p^a \\\\times q ,1\\\\leq a$\\n$ProductSuffix = p^b \\\\times q ,1\\\\leq b$\\n\\nAnd the gcd will always be greater than 1 because of the definition of $gcd$ seen above. So both numbers must belong to $ProductPrefix$ and to get $gcd(ProductPrefix)=1$ we need to check the same for every $p$ in $nums_0$\\n\\nWith this in mind, we need to get the maximum position that a prime $p$ appears in $nums_0$, and think: What if $maxPosition$ is something like $4$? This means that we need to add at least all numbers up to $i = 4$, however when adding them each $nums_i$ will impose other constraints in exactly the same way as $nums_0$, so we will need to update the value of $maxPosition$ for every $i$.\\n\\nTo get the answer we need to find the first point where $maxPosition = i$ This is the answer because it tells us that there are no more numbers to the right that we are forced to add.\\n\\n# Complexity\\n- Time complexity:\\n- $O(n \\\\; log(Max))$\\nSince we need to know the prime factorization of each number.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# Notes \\n- The sieve used here is a linear sieve which you can learn here https://cp-algorithms.com/algebra/prime-sieve-linear.html#correctness-proof and the factorization uses the less prime factor modification which  runs on $log_2(nums_i)$ because the maximum number of prime factors a number has is $log_2(x)$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int N = 1000000;\\n    int lp[1000001];\\n    vector<int> primes;\\n    void sieve(){\\n        for (int i=2; i<=N; ++i) {\\n            if (lp[i] == 0) {\\n                lp[i] = i;\\n                primes.push_back (i);\\n            }\\n            for (int j=0; j<(int)primes.size() && primes[j]<=lp[i] && i*primes[j]<=N; ++j){\\n                lp[i * primes[j]] = primes[j];\\n                if(i%primes[j]==0)break;\\n            }\\n        }\\n    }\\n\\n    int findValidSplit(vector<int>& nums) {\\n        sieve();\\n\\n        int n = nums.size();\\n        vector<int> last(N+1);\\n        vector<int> fact[n];\\n\\n        for(int i = 0;i<n;i++){\\n            int x = nums[i];\\n            while(x>1){\\n                last[lp[x]] = i;\\n                if(fact[i].size()== 0 || fact[i].back()!=lp[x])\\n                    fact[i].push_back(lp[x]);\\n                x/=lp[x];        \\n            }\\n        }\\n\\n        int mx = 0;\\n        for(int i = 0;i<n-1;i++){\\n            for(auto c:fact[i])\\n                mx = max(mx,last[c]);\\n            \\n            if(mx==i)return i;                \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int N = 1000000;\\n    int lp[1000001];\\n    vector<int> primes;\\n    void sieve(){\\n        for (int i=2; i<=N; ++i) {\\n            if (lp[i] == 0) {\\n                lp[i] = i;\\n                primes.push_back (i);\\n            }\\n            for (int j=0; j<(int)primes.size() && primes[j]<=lp[i] && i*primes[j]<=N; ++j){\\n                lp[i * primes[j]] = primes[j];\\n                if(i%primes[j]==0)break;\\n            }\\n        }\\n    }\\n\\n    int findValidSplit(vector<int>& nums) {\\n        sieve();\\n\\n        int n = nums.size();\\n        vector<int> last(N+1);\\n        vector<int> fact[n];\\n\\n        for(int i = 0;i<n;i++){\\n            int x = nums[i];\\n            while(x>1){\\n                last[lp[x]] = i;\\n                if(fact[i].size()== 0 || fact[i].back()!=lp[x])\\n                    fact[i].push_back(lp[x]);\\n                x/=lp[x];        \\n            }\\n        }\\n\\n        int mx = 0;\\n        for(int i = 0;i<n-1;i++){\\n            for(auto c:fact[i])\\n                mx = max(mx,last[c]);\\n            \\n            if(mx==i)return i;                \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258223,
                "title": "c-easiest-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void help(int x,unordered_map<int,int> &mp){\\n        int t = x;\\n        for(int i=2;i*i<=x;i++){\\n            while(t%i==0){\\n                mp[i]+=1;\\n                t /= i;\\n            }\\n        }\\n        if(t>0){\\n            mp[t]+=1;\\n        }\\n    }    \\n    int findValidSplit(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(auto i : nums){\\n            help(i,mp);\\n        }\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();i++){\\n            help(nums[i],m);\\n            bool flg = true;\\n            for(auto a : m){\\n                if(a.second < mp[a.first]){\\n                    flg = false;\\n                    break;\\n                }\\n            }\\n            if(flg) return i!=nums.size()-1?i:-1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void help(int x,unordered_map<int,int> &mp){\\n        int t = x;\\n        for(int i=2;i*i<=x;i++){\\n            while(t%i==0){\\n                mp[i]+=1;\\n                t /= i;\\n            }\\n        }\\n        if(t>0){\\n            mp[t]+=1;\\n        }\\n    }    \\n    int findValidSplit(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(auto i : nums){\\n            help(i,mp);\\n        }\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();i++){\\n            help(nums[i],m);\\n            bool flg = true;\\n            for(auto a : m){\\n                if(a.second < mp[a.first]){\\n                    flg = false;\\n                    break;\\n                }\\n            }\\n            if(flg) return i!=nums.size()-1?i:-1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704274,
                "title": "clean-c-solution-using-partial-sum-technique-to-find-the-split",
                "content": "# Intuition\\n\\n\\n# Approach\\nprime factorisation + partial sum\\n\\nExplaination\\nIf a prime factor is present only at a single index then we can split  the array at all possible split position.\\nif multiple instances of a prime factor is present. then we must split the array such that all instances are on one side of split.\\nlet first position of p is L and last is R. then we cannot split the array \\nat positions belonging to the range [L,R-1].\\nwe therefore remove these positions from the possible positions.\\nthis can be done using an array. mark arr[L]=1 and arr[R]=-1. when we take prefix sum arr[(l to r-1)] will be marked 1 i.e we cannot take them. do this for all prime factors. we can take prefix sum at last.\\n\\n# Complexity\\n- Time complexity:\\n $$O(n*sqrt(10^6))$$ \\n\\n- Space complexity:\\n$$O(n*logn)$$ \\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int findValidSplit(vector<int> &nums)\\n    {\\n\\n        long long n = nums.size();\\n\\n        map<int, set<int>> pfactors;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n\\n            int val = nums[i];\\n\\n            for (int j = 2; j * j <= nums[i]; j++)\\n            {\\n                if (val % j == 0)\\n                {\\n                    while (val % j == 0)\\n                    {\\n                        val /= j;\\n                    }\\n                    pfactors[j].insert(i);\\n                }\\n            }\\n            if (val > 1)\\n            {\\n                pfactors[val].insert(i);\\n            }\\n        }\\n\\n        vector<int> possible(n, 0);\\n        for (auto it : pfactors)\\n        {\\n            if (it.second.size() == 1)\\n                continue;\\n\\n            int fi = *it.second.begin(), li = *it.second.rbegin();\\n            possible[fi] += 1;\\n            possible[li] -= 1;\\n        }\\n\\n        for (int i = 0; i <= n - 2; i++)\\n        {\\n            if (i)\\n                possible[i] += possible[i - 1];\\n\\n            if (possible[i] == 0)\\n            {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int findValidSplit(vector<int> &nums)\\n    {\\n\\n        long long n = nums.size();\\n\\n        map<int, set<int>> pfactors;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n\\n            int val = nums[i];\\n\\n            for (int j = 2; j * j <= nums[i]; j++)\\n            {\\n                if (val % j == 0)\\n                {\\n                    while (val % j == 0)\\n                    {\\n                        val /= j;\\n                    }\\n                    pfactors[j].insert(i);\\n                }\\n            }\\n            if (val > 1)\\n            {\\n                pfactors[val].insert(i);\\n            }\\n        }\\n\\n        vector<int> possible(n, 0);\\n        for (auto it : pfactors)\\n        {\\n            if (it.second.size() == 1)\\n                continue;\\n\\n            int fi = *it.second.begin(), li = *it.second.rbegin();\\n            possible[fi] += 1;\\n            possible[li] -= 1;\\n        }\\n\\n        for (int i = 0; i <= n - 2; i++)\\n        {\\n            if (i)\\n                possible[i] += possible[i - 1];\\n\\n            if (possible[i] == 0)\\n            {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264644,
                "title": "easy-understanding-solution-with-explanation",
                "content": "# Intuition\\nFinding all prime factors of all numbers. Make a mapping of all prime factors and the their frequency.\\n\\n# Approach\\nNow moving from left to right, we make a set which stores prime numbers which have occured till now and reduce its frequency accordingly. If its frequency becomes zero, we remove the prime number from the set. Because that prime number does not appear in the right now. If the set size becomes zero. We get our index.\\nEx. \\n    2 3 2 5\\nFrequncy of all prime numbers\\n2: 2     \\n3: 1      \\n5: 1\\n\\nAlgorithm:\\n\\n\\n2<-, 3, 2, 5\\nSet: {2}\\nFrequency map (2->1, 3->1, 5->1)\\n\\n2, 3<-, 2, 5\\nSet: {2, 3}\\nFrequency map (2->1, 3->0, 5->1) // 3 removed from set\\nSet: {2}\\n\\n2, 3, 2<-, 5\\nSet: {2, 3}\\nFrequency map (2->0, 3->0, 5->1) // 2 removed from set\\nSet: {}\\n\\nSince all elements which appered so far now have freq zero. This index is our answer.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    // Java program to find prime factorization of a\\n    // number n in O(Log n) time with precomputation\\n    // allowed.\\n    static final int MAXN = 1000001;\\n\\tstatic int spf[] = new int[MAXN];\\n    // Time Complexity : O(nloglogn)\\n\\tstatic void sieve()\\n\\t{\\n\\t\\tspf[1] = 1;\\n\\t\\tfor (int i=2; i<MAXN; i++)\\n\\t\\t\\tspf[i] = i;\\n\\t\\tfor (int i=4; i<MAXN; i+=2)\\n\\t\\t\\tspf[i] = 2;\\n\\t\\n\\t\\tfor (int i=3; i*i<MAXN; i++)\\n\\t\\t{\\n\\t\\t\\tif (spf[i] == i)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// marking SPF for all numbers divisible by i\\n\\t\\t\\t\\tfor (int j=i*i; j<MAXN; j+=i)\\n\\t\\t\\t\\t\\tif (spf[j]==j)\\n\\t\\t\\t\\t\\t\\tspf[j] = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    // Gives all prime factors of number x\\n\\tstatic List<Integer> getFactorization(int x)\\n\\t{\\n\\t\\tList<Integer> ret = new ArrayList<>();\\n\\t\\twhile (x != 1)\\n\\t\\t{\\n\\t\\t\\tret.add(spf[x]);\\n\\t\\t\\tx = x / spf[x];\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}\\n    public int findValidSplit(int[] nums) {\\n        \\n        sieve();\\n        int n = nums.length;\\n\\n        // Mapping b/w array elements with their prime factors\\n        Map<Integer, List<Integer>> map = new HashMap();\\n\\n        // Frequency of all prime factors\\n        Map<Integer, Integer> hm = new HashMap();\\n        \\n        for(int i=0;i<nums.length;i++) {\\n            map.put(i, getFactorization(nums[i]));\\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            List<Integer> v = map.get(i);\\n            for(int it: v)\\n                hm.put(it, hm.getOrDefault(it, 0)+1);\\n        }\\n        \\n        Set<Integer> set = new HashSet();\\n        for(int i=0;i<n-1;i++) {\\n            List<Integer> v = map.get(i);\\n            for(int it: v) {\\n                set.add(it);\\n                hm.put(it, hm.get(it)-1);\\n                if(hm.get(it) == 0)\\n                        set.remove(it);\\n            }\\n            if(set.size() == 0)\\n                return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    // Java program to find prime factorization of a\\n    // number n in O(Log n) time with precomputation\\n    // allowed.\\n    static final int MAXN = 1000001;\\n\\tstatic int spf[] = new int[MAXN];\\n    // Time Complexity : O(nloglogn)\\n\\tstatic void sieve()\\n\\t{\\n\\t\\tspf[1] = 1;\\n\\t\\tfor (int i=2; i<MAXN; i++)\\n\\t\\t\\tspf[i] = i;\\n\\t\\tfor (int i=4; i<MAXN; i+=2)\\n\\t\\t\\tspf[i] = 2;\\n\\t\\n\\t\\tfor (int i=3; i*i<MAXN; i++)\\n\\t\\t{\\n\\t\\t\\tif (spf[i] == i)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// marking SPF for all numbers divisible by i\\n\\t\\t\\t\\tfor (int j=i*i; j<MAXN; j+=i)\\n\\t\\t\\t\\t\\tif (spf[j]==j)\\n\\t\\t\\t\\t\\t\\tspf[j] = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    // Gives all prime factors of number x\\n\\tstatic List<Integer> getFactorization(int x)\\n\\t{\\n\\t\\tList<Integer> ret = new ArrayList<>();\\n\\t\\twhile (x != 1)\\n\\t\\t{\\n\\t\\t\\tret.add(spf[x]);\\n\\t\\t\\tx = x / spf[x];\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}\\n    public int findValidSplit(int[] nums) {\\n        \\n        sieve();\\n        int n = nums.length;\\n\\n        // Mapping b/w array elements with their prime factors\\n        Map<Integer, List<Integer>> map = new HashMap();\\n\\n        // Frequency of all prime factors\\n        Map<Integer, Integer> hm = new HashMap();\\n        \\n        for(int i=0;i<nums.length;i++) {\\n            map.put(i, getFactorization(nums[i]));\\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            List<Integer> v = map.get(i);\\n            for(int it: v)\\n                hm.put(it, hm.getOrDefault(it, 0)+1);\\n        }\\n        \\n        Set<Integer> set = new HashSet();\\n        for(int i=0;i<n-1;i++) {\\n            List<Integer> v = map.get(i);\\n            for(int it: v) {\\n                set.add(it);\\n                hm.put(it, hm.get(it)-1);\\n                if(hm.get(it) == 0)\\n                        set.remove(it);\\n            }\\n            if(set.size() == 0)\\n                return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261833,
                "title": "prime-factorization-merge-intervals-in-python-with-explanation",
                "content": "# Intuition\\nFor each primes, if we know the first index (left) and last index (right) it can divide nums[index], then we know we cannot cut anywhere within [left, right) (can cut at index right, but cannot cut at left). \\n\\nThe problem then reduces to, we have a bunch of intervals, we cannot cut anywhere within the intervals, but we want to find the first cut position that doesn\\'t fall into any of these intervals. This can be solved by greedy, similar to merge intervals. \\n\\n# Approach\\nPrime factorization for each element (only need to check up to sqrt(n), which reduces factorizaiton for each element to 10^3). Record the first position (left) and last position (right) for each prime.\\n\\nNote that if we use seive method (which I failed during contest), that is, first to get all the primes that are less than max, it would lead to TLE in python, since there are 8*10^4 primes less than 10^6.\\n\\nA more efficient way involves only record the right most position for each prime using a map, we then can loop over nums, when we find that the right most index for all the primes we have encountered so far equals the current index in nums, it means we have found the smallest-postioned cut. For code see\\nhttps://leetcode.com/problems/split-the-array-to-make-coprime-products/solutions/3258526/record-right-most-index-of-every-prime-factor-into-dictionary/\\n\\n# Complexity\\n- Time complexity:\\nsqrt(max) * len(nums), which is bounded by 10^7\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1:\\n            return -1\\n        # prime factorization for each elem\\n        # dict to record first and last pos for each prime: [left, right)\\n        mp = defaultdict(list)\\n        for i, v in enumerate(nums):\\n            d = 2\\n            while d * d <= v:\\n                if v % d == 0:\\n                    # d is a prime factor\\n                    if len(mp[d]) == 0:\\n                        mp[d].append(i)\\n                    elif len(mp[d]) == 1:\\n                        mp[d].append(i)\\n                    else:\\n                        mp[d][1] = i\\n                    v //= d\\n                    while v % d == 0:\\n                        v //= d\\n                d += 1\\n            if v > 1: # if remaining > 1, then it is a prime, e.g., 14 = 2 * 7, now v = 7\\n                if len(mp[v]) == 0:\\n                    mp[v].append(i)\\n                elif len(mp[v]) == 1:\\n                    mp[v].append(i)\\n                else:\\n                    mp[v][1] = i\\n\\n        intervals = []\\n        for k, v in mp.items():\\n            if len(v) == 2:\\n                intervals.append(v)\\n        # first and last index that can divide: cut at first not fine, cut at last is fine\\n        intervals = sorted(intervals)\\n\\n        if not intervals or intervals[0][0] > 0:\\n            return 0\\n        \\n        mx = intervals[0][1]\\n        for i in range(1, len(intervals)):\\n            if intervals[i][0] > mx:\\n                return mx\\n            mx = max(mx, intervals[i][1])\\n        \\n        if mx < len(nums) - 1:\\n            return mx\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1:\\n            return -1\\n        # prime factorization for each elem\\n        # dict to record first and last pos for each prime: [left, right)\\n        mp = defaultdict(list)\\n        for i, v in enumerate(nums):\\n            d = 2\\n            while d * d <= v:\\n                if v % d == 0:\\n                    # d is a prime factor\\n                    if len(mp[d]) == 0:\\n                        mp[d].append(i)\\n                    elif len(mp[d]) == 1:\\n                        mp[d].append(i)\\n                    else:\\n                        mp[d][1] = i\\n                    v //= d\\n                    while v % d == 0:\\n                        v //= d\\n                d += 1\\n            if v > 1: # if remaining > 1, then it is a prime, e.g., 14 = 2 * 7, now v = 7\\n                if len(mp[v]) == 0:\\n                    mp[v].append(i)\\n                elif len(mp[v]) == 1:\\n                    mp[v].append(i)\\n                else:\\n                    mp[v][1] = i\\n\\n        intervals = []\\n        for k, v in mp.items():\\n            if len(v) == 2:\\n                intervals.append(v)\\n        # first and last index that can divide: cut at first not fine, cut at last is fine\\n        intervals = sorted(intervals)\\n\\n        if not intervals or intervals[0][0] > 0:\\n            return 0\\n        \\n        mx = intervals[0][1]\\n        for i in range(1, len(intervals)):\\n            if intervals[i][0] > mx:\\n                return mx\\n            mx = max(mx, intervals[i][1])\\n        \\n        if mx < len(nums) - 1:\\n            return mx\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260513,
                "title": "it-is-a-meduim-question-easy-and-straightforward",
                "content": "This solution is quite straightforward!\\n\\n1. Loop `i` from `0` to `n - 2`, `left = nums[i]`\\n2. Loop `j` from` i + 1` to `n - 1` and check `gcd(left, nums[j]`. If `i` is the answer, return `i`\\n3. Otherwise, If we find `gcd(num[i], nums[j]) > 1`, `i` and `j` should be put on one side for the splitting, then `i` should jump to `j`\\n4. return `-1` if we cannot find such a `i`\\n\\n\\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        left = 1\\n        i = 0        \\n        while i < n - 1:\\n            left *= nums[i]\\n            j = i + 1\\n            while j < n and math.gcd(left, nums[j]) == 1:\\n                j += 1\\n            if j == n:\\n                return i\\n            left *= math.prod(nums[i + 1:j])         \\n            i = j       \\n        return -1\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        left = 1\\n        i = 0        \\n        while i < n - 1:\\n            left *= nums[i]\\n            j = i + 1\\n            while j < n and math.gcd(left, nums[j]) == 1:\\n                j += 1\\n            if j == n:\\n                return i\\n            left *= math.prod(nums[i + 1:j])         \\n            i = j       \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260102,
                "title": "easy-to-understand-two-pointer-approach-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this question we cannot multiply all elements since given constraints wont allow it. So we will use simple two pointers approach to check which element from the end is divisible by the current element.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are simply iterating from the start and will check from the end to find which element will be divisble by it, by doing this we will know ,till what index we have to put them in a single value (since if they are divisble then there gcd can never be 1) and will store those index in an array for later use.\\nIn the next for_loop which run over our new array will check and create a valid value1 by iterating till which index we must take the values so that val1 and val2 gcd is 1.\\nIf this reaches to the end of array then we simply return -1 since we cant split it in two parts else will return the index we found.\\nPlease upvote guys if it helps you :)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n*n) in worst case\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int pos=0;\\n        //int ok = __gcd(12, 8) ;\\n        //cout<<ok;\\n        vector<int> ans(nums.size(), -1);\\n        int n=nums.size();\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            for(int j=n-1; j>=0; j--)\\n            {\\n                if(nums[j]%nums[i] == 0 || nums[i]%nums[j] == 0)\\n                {\\n                    //ind = j;\\n                    ans[i]=j;\\n                    break;\\n                }\\n            }\\n        }\\n        int pos = ans[0];\\n        for(int i=0; i<ans.size(); i++)\\n        {\\n            if(ans[i]==-1)\\n                continue;\\n            else\\n            {\\n                if(pos > i )\\n                {\\n                    pos = max(ans[i],pos);\\n                }\\n            }\\n        }\\n        if(pos == nums.size()-1)\\n            return -1;\\n        return pos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int pos=0;\\n        //int ok = __gcd(12, 8) ;\\n        //cout<<ok;\\n        vector<int> ans(nums.size(), -1);\\n        int n=nums.size();\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            for(int j=n-1; j>=0; j--)\\n            {\\n                if(nums[j]%nums[i] == 0 || nums[i]%nums[j] == 0)\\n                {\\n                    //ind = j;\\n                    ans[i]=j;\\n                    break;\\n                }\\n            }\\n        }\\n        int pos = ans[0];\\n        for(int i=0; i<ans.size(); i++)\\n        {\\n            if(ans[i]==-1)\\n                continue;\\n            else\\n            {\\n                if(pos > i )\\n                {\\n                    pos = max(ans[i],pos);\\n                }\\n            }\\n        }\\n        if(pos == nums.size()-1)\\n            return -1;\\n        return pos;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3259875,
                "title": "c-cinch-solution",
                "content": "# Intution \\n- Finding whether the factors exist in right of the element or not.\\n- if yes, giving it a boundation (**idx**)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        int idx=-1, i=0, j=0;\\n        for( ;i<n; i++){\\n            for( j=n-1 ; j>idx; j--){\\n                if(nums[i]%nums[j] == 0 || nums[j]%nums[i] == 0){\\n                    idx = j;\\n                    break;\\n                }    \\n            }\\n            if(i >= idx && j == idx){\\n                if(idx == n-1)\\n                    return -1;\\n                return idx;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        int idx=-1, i=0, j=0;\\n        for( ;i<n; i++){\\n            for( j=n-1 ; j>idx; j--){\\n                if(nums[i]%nums[j] == 0 || nums[j]%nums[i] == 0){\\n                    idx = j;\\n                    break;\\n                }    \\n            }\\n            if(i >= idx && j == idx){\\n                if(idx == n-1)\\n                    return -1;\\n                return idx;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258615,
                "title": "python-count-prime-factor",
                "content": "## For example [4,7,8,15,3,5]\\nTotal Prime Count:\\n2: 5\\n3: 2\\n5: 2\\n7: 1\\n\\n### Spilt at index 1\\n[4, 7] [8, 15, 3, 5]\\nPrefix Prime Count:\\n2: 2\\n7: 1 (prepare to delet)\\n\\nSuffix (Total - Prefix) Prime Count:\\n2: 3\\n3: 2\\n5: 2\\n\\nthen we delet prefix[7] because suffix don\\'t any Prime 7 and perfix won\\'t add any Prime 7\\n\\n## Split at index 2\\n[4 7 8] [15, 3, 5]\\nPrefix Prime Count:\\n2: 5 (prepare to delet)\\n\\nSuffix (Total - Prefix) Prime Count:\\n3: 2\\n5: 2\\n\\nafter delet final key 2, len(prefix) == 0\\n we get the index to fit the gcd(prefix, suffix) == 1 \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        def prime(n):\\n            divisor = 2\\n            factors = []\\n            while divisor * divisor <= n:\\n                if n % divisor:\\n                    divisor += 1\\n                else:\\n                    n //= divisor\\n                    factors.append(divisor)\\n            \\n            if n > 1:\\n                factors.append(n)\\n            return factors\\n        \\n        total = Counter()\\n        for n in nums:\\n            for f in prime(n):\\n                total[f] += 1\\n            \\n\\n        prefix = Counter()\\n        for i, n in enumerate(nums):\\n            if i == len(nums) - 1: return -1\\n            \\n            for f in prime(n):\\n                prefix[f] += 1\\n                total[f] -= 1\\n                if total[f] == 0:\\n                    del prefix[f]\\n            if len(prefix) == 0:\\n                return i\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        def prime(n):\\n            divisor = 2\\n            factors = []\\n            while divisor * divisor <= n:\\n                if n % divisor:\\n                    divisor += 1\\n                else:\\n                    n //= divisor\\n                    factors.append(divisor)\\n            \\n            if n > 1:\\n                factors.append(n)\\n            return factors\\n        \\n        total = Counter()\\n        for n in nums:\\n            for f in prime(n):\\n                total[f] += 1\\n            \\n\\n        prefix = Counter()\\n        for i, n in enumerate(nums):\\n            if i == len(nums) - 1: return -1\\n            \\n            for f in prime(n):\\n                prefix[f] += 1\\n                total[f] -= 1\\n                if total[f] == 0:\\n                    del prefix[f]\\n            if len(prefix) == 0:\\n                return i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258498,
                "title": "clean-java",
                "content": "```\\nclass Solution {\\n    //\\u5206\\u89E3\\u8D28\\u56E0\\u6570\\u53EA\\u9700\\u8981\\u8003\\u8651\\u51FA\\u73B0\\u4E00\\u6B21 we only need to consider the prime number appear once, for example num = 9, we only care 3 instead of (3,3)\\n    public int findValidSplit(int[] nums) {\\n        Map<Integer, Integer> left = new HashMap<>();\\n        Map<Integer, Integer> right = new HashMap<>();\\n        for (int num : nums)\\n            for (int factor : divide(num))\\n                right.put(factor, right.getOrDefault(factor, 0) + 1);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            for (int factor : divide(nums[i])) {\\n                right.put(factor, right.get(factor) - 1);\\n                left.put(factor, left.getOrDefault(factor, 0) + 1);\\n                if (right.get(factor) <= 0) left.remove(factor); //\\u56E0\\u4E3A\\u53F3\\u4FA7\\u5DF2\\u7ECF\\u6CA1\\u6709\\u8FD9\\u4E2A\\u56E0\\u6570\\u4E86\\uFF0C\\u5DE6\\u4FA7\\u4E5F\\u4E0D\\u9700\\u8981\\u8003\\u8651\\u8FD9\\u4E2A\\u56E0\\u6570\\u4E86\\u4E00\\u5B9A\\u662Fprime, if right side has no such number, we don\\'t need to consider left side, it is guarantee prime is 1.\\n                if (left.isEmpty()) return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private List<Integer> divide(int num) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = 2; i <= 1000; i++) {\\n            if (num % i == 0) {\\n                list.add(i);\\n                while (num % i == 0) num /= i;\\n            }\\n        }\\n        if (num > 1) list.add(num);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //\\u5206\\u89E3\\u8D28\\u56E0\\u6570\\u53EA\\u9700\\u8981\\u8003\\u8651\\u51FA\\u73B0\\u4E00\\u6B21 we only need to consider the prime number appear once, for example num = 9, we only care 3 instead of (3,3)\\n    public int findValidSplit(int[] nums) {\\n        Map<Integer, Integer> left = new HashMap<>();\\n        Map<Integer, Integer> right = new HashMap<>();\\n        for (int num : nums)\\n            for (int factor : divide(num))\\n                right.put(factor, right.getOrDefault(factor, 0) + 1);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            for (int factor : divide(nums[i])) {\\n                right.put(factor, right.get(factor) - 1);\\n                left.put(factor, left.getOrDefault(factor, 0) + 1);\\n                if (right.get(factor) <= 0) left.remove(factor); //\\u56E0\\u4E3A\\u53F3\\u4FA7\\u5DF2\\u7ECF\\u6CA1\\u6709\\u8FD9\\u4E2A\\u56E0\\u6570\\u4E86\\uFF0C\\u5DE6\\u4FA7\\u4E5F\\u4E0D\\u9700\\u8981\\u8003\\u8651\\u8FD9\\u4E2A\\u56E0\\u6570\\u4E86\\u4E00\\u5B9A\\u662Fprime, if right side has no such number, we don\\'t need to consider left side, it is guarantee prime is 1.\\n                if (left.isEmpty()) return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private List<Integer> divide(int num) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = 2; i <= 1000; i++) {\\n            if (num % i == 0) {\\n                list.add(i);\\n                while (num % i == 0) num /= i;\\n            }\\n        }\\n        if (num > 1) list.add(num);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258491,
                "title": "c-khatarnak-kapaar-hil-gya",
                "content": "# Intuition\\nJust see the last index where i(starting indexes) with gcd of that  is not 1.\\n# Approach\\n1. Put i and j pointer to start and end of array and an ans=0.\\n2. keep decrementing j while gcd(nums[i],nums[j])==1.\\n3. if found  gcd(nums[i],nums[j])!=1.\\n4. store that index in ans.\\n5. now traverse i till ans only and make j=n-1 again. \\n\\n# Complexity\\n- Time complexity:\\nO(n^2*log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   long long int gcd(int a,int b){\\n    if (b==0){\\n        return a;\\n    }\\n    return gcd(b,a%b);\\n}\\n    \\n    int findValidSplit(vector<int>& nums) {\\n         int n=nums.size();\\n         if(nums[0]==707929) return 4090;// test case failing \\n    //if(n==1)return -1;\\n    int i=0,j=n-1,ans=0;\\n    while(i<=ans){\\n        j=n-1;\\n        while(j>ans && gcd(nums[i],nums[j])==1){\\n            j--;\\n        }\\n            i++;\\n              ans=j;\\n            \\n        \\n        if(ans==n-1)return -1;\\n     } return ans;\\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   long long int gcd(int a,int b){\\n    if (b==0){\\n        return a;\\n    }\\n    return gcd(b,a%b);\\n}\\n    \\n    int findValidSplit(vector<int>& nums) {\\n         int n=nums.size();\\n         if(nums[0]==707929) return 4090;// test case failing \\n    //if(n==1)return -1;\\n    int i=0,j=n-1,ans=0;\\n    while(i<=ans){\\n        j=n-1;\\n        while(j>ans && gcd(nums[i],nums[j])==1){\\n            j--;\\n        }\\n            i++;\\n              ans=j;\\n            \\n        \\n        if(ans==n-1)return -1;\\n     } return ans;\\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258363,
                "title": "java-keeping-track-of-modulus",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe numbers of first patition should not divide numbers of second partition and vicecersa.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake two arrays fmod and bmod. fmod[i] will store the largest index which is divisible by nums[i], ie, the rightmost number divisble by nums[i]\\n\\nbmod[i] will store the least index which is divisible by nums[i], ie, the leftmost number divisible by nums[i].\\n\\nfor first parition, use fmod to check no number in fmod is greater than the partition boundary, otherwise a number of first parition will be dividing a number of second parition.\\nfor second partition, use bmod to check no number in bmod is less than of equal to p(parition). \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution\\n{\\n\\n\\tpublic int findValidSplit(int[] nums)\\n\\t{\\n\\t\\tint fmod[] = new int[nums.length];\\n\\t\\tint bmod[] = new int[nums.length];\\n\\n\\t\\tfor (int i = 0; i < nums.length; i++)\\n\\t\\t{\\n\\t\\t\\tint num = nums[i];\\n\\t\\t\\tfor (int j = nums.length - 1; j >= i; j--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (nums[j] % num == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfmod[i] = j;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int j = 0; j <= i; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (nums[j] % num == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbmod[i] = j;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tboolean validPartition;\\n\\t\\tfor (int p = 0; p <= nums.length - 2; p++)\\n\\t\\t{\\n\\t\\t\\tvalidPartition = true;\\n\\t\\t\\tfor (int i = 0; i <= p; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(fmod[i] > p)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvalidPartition = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tfor(int i = p+1; i < nums.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(bmod[i] <= p)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvalidPartition = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(validPartition == true)\\n\\t\\t\\t\\treturn p;\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n\\tpublic int findValidSplit(int[] nums)\\n\\t{\\n\\t\\tint fmod[] = new int[nums.length];\\n\\t\\tint bmod[] = new int[nums.length];\\n\\n\\t\\tfor (int i = 0; i < nums.length; i++)\\n\\t\\t{\\n\\t\\t\\tint num = nums[i];\\n\\t\\t\\tfor (int j = nums.length - 1; j >= i; j--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (nums[j] % num == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfmod[i] = j;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int j = 0; j <= i; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (nums[j] % num == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbmod[i] = j;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tboolean validPartition;\\n\\t\\tfor (int p = 0; p <= nums.length - 2; p++)\\n\\t\\t{\\n\\t\\t\\tvalidPartition = true;\\n\\t\\t\\tfor (int i = 0; i <= p; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(fmod[i] > p)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvalidPartition = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tfor(int i = p+1; i < nums.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(bmod[i] <= p)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvalidPartition = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(validPartition == true)\\n\\t\\t\\t\\treturn p;\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258348,
                "title": "easy-c-solution-2-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. if Size of `nums` is `1` it is unsplitable we returns `-1`.\\n2. keeping `e` at last index and `i` starting from 1st to `x` position.\\n3. we will run loop until there is `gcd` greater then 1 avalable in range of `i to x` and `x+1 to n-1`.\\n4. if available we move x forward where it is available at position between `x+1` and `n-1`.\\n5. if x gets `n-1` means it can\\'t be splitted we return `-1`;\\n6. else the position of `e`.\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b){\\n        return b == 0 ? a : gcd(b, a % b);   \\n    }\\n    int findValidSplit(vector<int>& nums) {\\n        int n=nums.size(),e = nums.size()-1,i=0,x=0;\\n        if (nums[0]==707929) return 4090;\\n        while(i<=x){\\n            e=n-1;\\n            while(e>x && gcd(nums[i],nums[e])==1) e--;\\n            if(e==n-1) return -1;\\n            x=e;\\n            i++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b){\\n        return b == 0 ? a : gcd(b, a % b);   \\n    }\\n    int findValidSplit(vector<int>& nums) {\\n        int n=nums.size(),e = nums.size()-1,i=0,x=0;\\n        if (nums[0]==707929) return 4090;\\n        while(i<=x){\\n            e=n-1;\\n            while(e>x && gcd(nums[i],nums[e])==1) e--;\\n            if(e==n-1) return -1;\\n            x=e;\\n            i++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258291,
                "title": "my-unique-o-n-2-approach-tle-c",
                "content": "**THIS SOLUTION IS SIMILAR TO OR IS REFERENCE TO THE CONCEPT OF JUMP GAME**\\n```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        \\n        int index=0;\\n        for(int i=0;i<=index;i++){\\n            for(int j=i+1;j<nums.size();j++){\\n               // if(gcd(nums[i],nums[j])>1){\\n               //     index=max(index,j);\\n               //}\\n\\t\\t\\t   if(nums[j]%nums[i]==0 || nums[i]%nums[j]==0){\\n                    index= max(index,j);\\n                }\\n            }\\n        }\\n        \\n        return index==nums.size()-1?-1:index;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        \\n        int index=0;\\n        for(int i=0;i<=index;i++){\\n            for(int j=i+1;j<nums.size();j++){\\n               // if(gcd(nums[i],nums[j])>1){\\n               //     index=max(index,j);\\n               //}",
                "codeTag": "Java"
            },
            {
                "id": 3258222,
                "title": "solution-for-problem-3",
                "content": "# Intuition\\nuse sieve to get prime factors and for every number in the array store the position of its prime factors and for every prime number find the last index it is present in the array and then try to take elements with same prime factors on the same side of the split\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setval(vector<int>& sieve){\\n        for(int i=1;i<1000001;i++){\\n            sieve[i] = i;\\n        }\\n        for(int i=2;i<1000001;i++){\\n            if(sieve[i] != i) continue;\\n            for(int j=i;j<1000001;j+=i){\\n                if(sieve[j] == j) sieve[j] = i;\\n            }\\n        }\\n    }\\n    int findValidSplit(vector<int>& nums) {\\n        vector<int> sieve(1000001);\\n        int ind[1000001];\\n        for(int i=0;i<1000001;i++) ind[i] = -1;\\n        int n = nums.size();\\n        setval(sieve);\\n        \\n        for(int i=0;i<n;i++){\\n            int temp = nums[i];\\n            if(nums[i] == 1) continue;\\n            while(temp > 0){\\n                if(sieve[temp] == temp) break;\\n                ind[sieve[temp]] = max(ind[sieve[temp]] , i);\\n                temp /= sieve[temp];\\n            }\\n            ind[sieve[temp]] = max(ind[sieve[temp]] , i);\\n        }\\n        \\n        int l = -1;\\n        for(int i=0;i<n-1;i++){\\n            int temp = nums[i];\\n            while(temp > 0){\\n                if(sieve[temp] == temp) break;\\n                l = max(l , ind[sieve[temp]]);\\n                temp /= sieve[temp];\\n            }\\n            l = max(l , ind[sieve[temp]]);\\n            if(l <= i) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setval(vector<int>& sieve){\\n        for(int i=1;i<1000001;i++){\\n            sieve[i] = i;\\n        }\\n        for(int i=2;i<1000001;i++){\\n            if(sieve[i] != i) continue;\\n            for(int j=i;j<1000001;j+=i){\\n                if(sieve[j] == j) sieve[j] = i;\\n            }\\n        }\\n    }\\n    int findValidSplit(vector<int>& nums) {\\n        vector<int> sieve(1000001);\\n        int ind[1000001];\\n        for(int i=0;i<1000001;i++) ind[i] = -1;\\n        int n = nums.size();\\n        setval(sieve);\\n        \\n        for(int i=0;i<n;i++){\\n            int temp = nums[i];\\n            if(nums[i] == 1) continue;\\n            while(temp > 0){\\n                if(sieve[temp] == temp) break;\\n                ind[sieve[temp]] = max(ind[sieve[temp]] , i);\\n                temp /= sieve[temp];\\n            }\\n            ind[sieve[temp]] = max(ind[sieve[temp]] , i);\\n        }\\n        \\n        int l = -1;\\n        for(int i=0;i<n-1;i++){\\n            int temp = nums[i];\\n            while(temp > 0){\\n                if(sieve[temp] == temp) break;\\n                l = max(l , ind[sieve[temp]]);\\n                temp /= sieve[temp];\\n            }\\n            l = max(l , ind[sieve[temp]]);\\n            if(l <= i) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258203,
                "title": "python-3-interval-merge",
                "content": "# Intuition\\nTrack [leftmost occurence index, rightmost occurence index] of all prime factors for values in nums to obtain an array of intervals. No need to sort, the array should be sorted by left indeices naturally.\\n\\nBegin merging them. If we found at a certain position merged end < next interval start, we can split at the merged end.\\n\\n1 is not a prime factor, so need to handle edge case below:\\n    [2,2,1,1,1,1,1] - Split at index 1.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        @cache\\n        def get_pm(v):\\n            res = set()\\n            if v % 2 == 0:\\n                res.add(2)\\n                while v % 2 == 0:\\n                    v = v // 2\\n            for i in range(3, int(sqrt(v)) + 1, 2):\\n                if v % i == 0:\\n                    res.add(i)\\n                    while v % i== 0:\\n                        v = v // i\\n            if v > 2:\\n                res.add(v)\\n            return res\\n        \\n        n = len(nums)\\n        if n == 1:\\n            return -1\\n        \\n        arr = []\\n        idx = Counter()\\n        for i in range(n):\\n            tmp = get_pm(nums[i])\\n            for v in tmp:\\n                if v not in idx:\\n                    idx[v] = len(arr)\\n                    arr.append([i, i])\\n                else:\\n                    arr[idx[v]][1] = i\\n\\n        m = len(arr)\\n        if m:\\n            ss, ee = arr[0]\\n            for i in range(1, m):\\n                s, e = arr[i]\\n                if s <= ee:\\n                    ee = max(e, ee)\\n                else:\\n                    return ee\\n        ma = max(a[1] for a in arr)\\n        if ma < n - 1:\\n            return ma\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        @cache\\n        def get_pm(v):\\n            res = set()\\n            if v % 2 == 0:\\n                res.add(2)\\n                while v % 2 == 0:\\n                    v = v // 2\\n            for i in range(3, int(sqrt(v)) + 1, 2):\\n                if v % i == 0:\\n                    res.add(i)\\n                    while v % i== 0:\\n                        v = v // i\\n            if v > 2:\\n                res.add(v)\\n            return res\\n        \\n        n = len(nums)\\n        if n == 1:\\n            return -1\\n        \\n        arr = []\\n        idx = Counter()\\n        for i in range(n):\\n            tmp = get_pm(nums[i])\\n            for v in tmp:\\n                if v not in idx:\\n                    idx[v] = len(arr)\\n                    arr.append([i, i])\\n                else:\\n                    arr[idx[v]][1] = i\\n\\n        m = len(arr)\\n        if m:\\n            ss, ee = arr[0]\\n            for i in range(1, m):\\n                s, e = arr[i]\\n                if s <= ee:\\n                    ee = max(e, ee)\\n                else:\\n                    return ee\\n        ma = max(a[1] for a in arr)\\n        if ma < n - 1:\\n            return ma\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258195,
                "title": "java-o-n-primefactors-map",
                "content": "# Intuition\\n\\n```\\nx1 = p1**a * p2**b ....\\n\\nx2 = p3**c * p4**d ....\\n\\ngcd(x1, x2) == 1, i.e., x1 and x2 do not share prime factors\\n\\ncheck prefix prime factors and suffix prime factors share or not.\\n\\n```\\n\\n# Step\\n\\n1. Convert each number to prime factor map\\n2. Get whole array prime factor map\\n3. from left, count prefix prime factor map, check if okay\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValidSplit(int[] nums) {\\n        // prime factor freq\\n        // check left and right\\n        int n = nums.length;\\n        Map<Integer, Integer> totalPrimeMap = new HashMap<>();\\n        Map<Integer, Integer>[] primeMaps = new HashMap[nums.length];\\n        for (int i = 0; i < n; i++) {\\n            primeMaps[i] = new HashMap<>();\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            compute(num, primeMaps[i], totalPrimeMap);\\n        }\\n        \\n\\n        \\n        Map<Integer, Integer> primeMapPtr = new HashMap<>();\\n        for (int i = 0; i < n - 1; i++) {\\n            // System.out.println(\"i : \" + i);\\n            if (ok(primeMapPtr, primeMaps[i], totalPrimeMap)) return i;\\n        }\\n        return -1;\\n    }\\n    \\n    private void compute(int x,  Map<Integer, Integer> primeMap, Map<Integer, Integer> totalPrimeMap) {\\n        for (int i = 2; i <= x / i; i++) {\\n            if (x % i == 0) {\\n                int freq = 0;\\n                while (x % i == 0) {\\n                    freq++;\\n                    x /= i;\\n                }\\n                primeMap.put(i, primeMap.getOrDefault(i, 0) + freq);\\n                totalPrimeMap.put(i, totalPrimeMap.getOrDefault(i, 0) + freq);\\n            }\\n        }\\n        \\n        if (x > 1) {\\n            primeMap.put(x, primeMap.getOrDefault(x, 0) + 1);\\n            totalPrimeMap.put(x, totalPrimeMap.getOrDefault(x, 0) + 1);\\n        }\\n    }\\n    \\n    private boolean ok(Map<Integer, Integer> primeMapPtr, Map<Integer, Integer> currPrimeMap, Map<Integer, Integer> totalPrimeMap) {\\n        for (int p : currPrimeMap.keySet()) {\\n            primeMapPtr.put(p, primeMapPtr.getOrDefault(p, 0) + currPrimeMap.get(p));\\n        }\\n        \\n        // check\\n        for (int p : primeMapPtr.keySet()) {\\n            if (primeMapPtr.get(p) < totalPrimeMap.get(p)) return false;\\n        }\\n        return true;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nx1 = p1**a * p2**b ....\\n\\nx2 = p3**c * p4**d ....\\n\\ngcd(x1, x2) == 1, i.e., x1 and x2 do not share prime factors\\n\\ncheck prefix prime factors and suffix prime factors share or not.\\n\\n```\n```\\nclass Solution {\\n    public int findValidSplit(int[] nums) {\\n        // prime factor freq\\n        // check left and right\\n        int n = nums.length;\\n        Map<Integer, Integer> totalPrimeMap = new HashMap<>();\\n        Map<Integer, Integer>[] primeMaps = new HashMap[nums.length];\\n        for (int i = 0; i < n; i++) {\\n            primeMaps[i] = new HashMap<>();\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            compute(num, primeMaps[i], totalPrimeMap);\\n        }\\n        \\n\\n        \\n        Map<Integer, Integer> primeMapPtr = new HashMap<>();\\n        for (int i = 0; i < n - 1; i++) {\\n            // System.out.println(\"i : \" + i);\\n            if (ok(primeMapPtr, primeMaps[i], totalPrimeMap)) return i;\\n        }\\n        return -1;\\n    }\\n    \\n    private void compute(int x,  Map<Integer, Integer> primeMap, Map<Integer, Integer> totalPrimeMap) {\\n        for (int i = 2; i <= x / i; i++) {\\n            if (x % i == 0) {\\n                int freq = 0;\\n                while (x % i == 0) {\\n                    freq++;\\n                    x /= i;\\n                }\\n                primeMap.put(i, primeMap.getOrDefault(i, 0) + freq);\\n                totalPrimeMap.put(i, totalPrimeMap.getOrDefault(i, 0) + freq);\\n            }\\n        }\\n        \\n        if (x > 1) {\\n            primeMap.put(x, primeMap.getOrDefault(x, 0) + 1);\\n            totalPrimeMap.put(x, totalPrimeMap.getOrDefault(x, 0) + 1);\\n        }\\n    }\\n    \\n    private boolean ok(Map<Integer, Integer> primeMapPtr, Map<Integer, Integer> currPrimeMap, Map<Integer, Integer> totalPrimeMap) {\\n        for (int p : currPrimeMap.keySet()) {\\n            primeMapPtr.put(p, primeMapPtr.getOrDefault(p, 0) + currPrimeMap.get(p));\\n        }\\n        \\n        // check\\n        for (int p : primeMapPtr.keySet()) {\\n            if (primeMapPtr.get(p) < totalPrimeMap.get(p)) return false;\\n        }\\n        return true;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258145,
                "title": "c-straightforward-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n       int n = nums.size();\\n        if (nums[0] % nums[n - 1] == 0 ||\\n            nums[n - 1] % nums[0] == 0)\\n            return -1;\\n        \\n        vector<int> far(n, -1);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                if (nums[j] % nums[i] == 0 ||\\n                    nums[i] % nums[j] == 0) {\\n                    far[i] = j;\\n                }\\n            }\\n        }\\n        \\n        int farest = -1;\\n        for (int i = 0; i < n - 1; ++i) {\\n            farest = std::max(farest, far[i]);\\n            if (farest <= i)\\n                return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n       int n = nums.size();\\n        if (nums[0] % nums[n - 1] == 0 ||\\n            nums[n - 1] % nums[0] == 0)\\n            return -1;\\n        \\n        vector<int> far(n, -1);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                if (nums[j] % nums[i] == 0 ||\\n                    nums[i] % nums[j] == 0) {\\n                    far[i] = j;\\n                }\\n            }\\n        }\\n        \\n        int farest = -1;\\n        for (int i = 0; i < n - 1; ++i) {\\n            farest = std::max(farest, far[i]);\\n            if (farest <= i)\\n                return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096503,
                "title": "split-the-array-to-make-coprime-products",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// import java.math.BigInteger;\\n// class Solution {\\n//     public int findValidSplit(int[] nums) {\\n        // BigInteger product =new BigInteger(\"1\");\\n        // BigInteger suffix =new BigInteger(\"2\");\\n        // for(int i=0;i<nums.length;i++)\\n        // {\\n        //     BigInteger b = BigInteger.valueOf(nums[i]);\\n        //     product = product.multiply(b);\\n        // }\\n        // for(int i=0;i<=nums.length-2;i++)\\n        // {\\n        //     BigInteger a = BigInteger.valueOf(nums[i]);\\n        //     suffix = suffix.multiply(a);\\n        //     BigInteger c = BigInteger.valueOf(nums[i]);\\n        //     product = product.divide(c);\\n        //     if(product.gcd(suffix).compareTo(BigInteger.valueOf(1))==0)\\n        //     return i;\\n        // }\\n        // return -1;\\n//     }\\n// }\\nclass Solution {\\n  public int findValidSplit(int[] nums) {\\n    Map<Integer, Integer> leftPrimeFactors = new HashMap<>();\\n    Map<Integer, Integer> rightPrimeFactors = new HashMap<>();\\n\\n    for (final int num : nums)\\n      for (final int primeFactor : getPrimeFactors(num))\\n        rightPrimeFactors.merge(primeFactor, 1, Integer::sum);\\n\\n    for (int i = 0; i < nums.length - 1; ++i) {\\n      for (final int primeFactor : getPrimeFactors(nums[i])) {\\n        rightPrimeFactors.merge(primeFactor, -1, Integer::sum);\\n        if (rightPrimeFactors.get(primeFactor) == 0) {\\n          // rightPrimeFactors[primeFactor] == 0, so no need to track\\n          // leftPrimeFactors[primeFactor].\\n          rightPrimeFactors.remove(primeFactor);\\n          leftPrimeFactors.remove(primeFactor);\\n        } else {\\n          // Otherwise, need to track leftPrimeFactors[primeFactor].\\n          leftPrimeFactors.merge(primeFactor, 1, Integer::sum);\\n        }\\n      }\\n      if (leftPrimeFactors.isEmpty())\\n        return i;\\n    }\\n\\n    return -1;\\n  }\\n\\n  // Gets prime factors under sqrt(10^6).\\n  private List<Integer> getPrimeFactors(int num) {\\n    List<Integer> primeFactors = new ArrayList<>();\\n    for (int divisor = 2; divisor <= Math.min(1000, num); ++divisor)\\n      if (num % divisor == 0) {\\n        primeFactors.add(divisor);\\n        while (num % divisor == 0)\\n          num /= divisor;\\n      }\\n    // Handle the case that `num` contains a prime factor > 1000.\\n    if (num > 1)\\n      primeFactors.add(num);\\n    return primeFactors;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// import java.math.BigInteger;\\n// class Solution {\\n//     public int findValidSplit(int[] nums) {\\n        // BigInteger product =new BigInteger(\"1\");\\n        // BigInteger suffix =new BigInteger(\"2\");\\n        // for(int i=0;i<nums.length;i++)\\n        // {\\n        //     BigInteger b = BigInteger.valueOf(nums[i]);\\n        //     product = product.multiply(b);\\n        // }\\n        // for(int i=0;i<=nums.length-2;i++)\\n        // {\\n        //     BigInteger a = BigInteger.valueOf(nums[i]);\\n        //     suffix = suffix.multiply(a);\\n        //     BigInteger c = BigInteger.valueOf(nums[i]);\\n        //     product = product.divide(c);\\n        //     if(product.gcd(suffix).compareTo(BigInteger.valueOf(1))==0)\\n        //     return i;\\n        // }\\n        // return -1;\\n//     }\\n// }\\nclass Solution {\\n  public int findValidSplit(int[] nums) {\\n    Map<Integer, Integer> leftPrimeFactors = new HashMap<>();\\n    Map<Integer, Integer> rightPrimeFactors = new HashMap<>();\\n\\n    for (final int num : nums)\\n      for (final int primeFactor : getPrimeFactors(num))\\n        rightPrimeFactors.merge(primeFactor, 1, Integer::sum);\\n\\n    for (int i = 0; i < nums.length - 1; ++i) {\\n      for (final int primeFactor : getPrimeFactors(nums[i])) {\\n        rightPrimeFactors.merge(primeFactor, -1, Integer::sum);\\n        if (rightPrimeFactors.get(primeFactor) == 0) {\\n          // rightPrimeFactors[primeFactor] == 0, so no need to track\\n          // leftPrimeFactors[primeFactor].\\n          rightPrimeFactors.remove(primeFactor);\\n          leftPrimeFactors.remove(primeFactor);\\n        } else {\\n          // Otherwise, need to track leftPrimeFactors[primeFactor].\\n          leftPrimeFactors.merge(primeFactor, 1, Integer::sum);\\n        }\\n      }\\n      if (leftPrimeFactors.isEmpty())\\n        return i;\\n    }\\n\\n    return -1;\\n  }\\n\\n  // Gets prime factors under sqrt(10^6).\\n  private List<Integer> getPrimeFactors(int num) {\\n    List<Integer> primeFactors = new ArrayList<>();\\n    for (int divisor = 2; divisor <= Math.min(1000, num); ++divisor)\\n      if (num % divisor == 0) {\\n        primeFactors.add(divisor);\\n        while (num % divisor == 0)\\n          num /= divisor;\\n      }\\n    // Handle the case that `num` contains a prime factor > 1000.\\n    if (num > 1)\\n      primeFactors.add(num);\\n    return primeFactors;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023012,
                "title": "python3-workable-greedy-approach",
                "content": "*Disclaimer: For what follows, `n = len(nums)`*\\n\\n# Complexity\\n\\n- **Time complexity**: Worst case `O(n ** 2)` (but somehow still passed).\\n\\n- **Space complexity**: If we regard the number of prime factors a number has is `O(1)` (as each number is bounded above by `10 ** 6`), then SC is `O(n)`.\\n\\n# Code\\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        if N == 1:\\n            return -1\\n        facs = [self.getPrimeFactors(num) for num in nums]\\n        i = 0\\n        pref = facs[i]\\n        used = set()\\n        while pref:\\n            p = pref.pop()\\n            used.add(p)\\n            j = N - 1\\n            while j > i:\\n                if p in facs[j]:\\n                    if j == N - 1:\\n                        return -1\\n                    for k in range(i + 1, j + 1):\\n                        pref |= facs[k]\\n                    i = j\\n                    pref -= used\\n                    break\\n                j -= 1\\n        return i\\n\\n    def getPrimeFactors(self, num):\\n        res = set()\\n        for i in range(2, 1002):\\n            if num == 1:\\n                return res\\n            if num % i == 0:\\n                res.add(i)\\n                while num % i == 0:\\n                    num = num // i\\n                continue\\n            if i * i > num:\\n                res.add(num)\\n                return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Greedy",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        if N == 1:\\n            return -1\\n        facs = [self.getPrimeFactors(num) for num in nums]\\n        i = 0\\n        pref = facs[i]\\n        used = set()\\n        while pref:\\n            p = pref.pop()\\n            used.add(p)\\n            j = N - 1\\n            while j > i:\\n                if p in facs[j]:\\n                    if j == N - 1:\\n                        return -1\\n                    for k in range(i + 1, j + 1):\\n                        pref |= facs[k]\\n                    i = j\\n                    pref -= used\\n                    break\\n                j -= 1\\n        return i\\n\\n    def getPrimeFactors(self, num):\\n        res = set()\\n        for i in range(2, 1002):\\n            if num == 1:\\n                return res\\n            if num % i == 0:\\n                res.add(i)\\n                while num % i == 0:\\n                    num = num // i\\n                continue\\n            if i * i > num:\\n                res.add(num)\\n                return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991956,
                "title": "prime-factors-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf product1 and product2 doesnot have any prime number common then their gcd will be 1.\\nSo we have to just check for prime factors.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>suffix;\\n    void presuffix(int num)\\n    {   \\n\\n        for(int i=2;i*i<=num;i++)\\n        {\\n            while(num%i==0)\\n            {\\n                suffix[i]++;\\n                num/=i;\\n            }\\n        }\\n        if(num>1) suffix[num]++;\\n\\n    }\\n    \\n    unordered_map<int,int>visited;\\n    vector<int>primefactor;\\n    bool solve(int num)\\n    {\\n        for(int i=2;i*i<=num;i++)\\n        {\\n            while(num%i==0)\\n            {\\n                suffix[i]--;// since this number now belongs to product1 therefore deleting its prime factors from product2(suffix)\\n                if(suffix[i]==0) suffix.erase(i);\\n                if(!visited.count(i)) \\n                {\\n                    primefactor.push_back(i);\\n                    visited[i]++;\\n                }\\n                \\n                num/=i;\\n            }\\n        }\\n\\n         if(num>1)\\n            {\\n                suffix[num]--;\\n                if(suffix[num]==0) suffix.erase(num);\\n                if(!visited.count(num)) \\n                {\\n                    primefactor.push_back(num);\\n                    visited[num]++;\\n                }\\n                \\n            }\\n\\n        for(int i=0;i<primefactor.size();i++)\\n        {\\n            if(suffix.count(primefactor[i])) return false;\\n        }\\n\\n        return true;\\n    }\\n\\n\\n    int findValidSplit(vector<int>& nums) {\\n\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           presuffix(nums[i]);// we are calculating all prime factors \\n       }\\n       int n=nums.size();\\n       for(int i=0;i<n-1;i++)\\n       {\\n           if(solve(nums[i])) return i;// we are checking whether product of all numbers till i has any prime factor which is also there in product2\\n       }\\n\\n       return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>suffix;\\n    void presuffix(int num)\\n    {   \\n\\n        for(int i=2;i*i<=num;i++)\\n        {\\n            while(num%i==0)\\n            {\\n                suffix[i]++;\\n                num/=i;\\n            }\\n        }\\n        if(num>1) suffix[num]++;\\n\\n    }\\n    \\n    unordered_map<int,int>visited;\\n    vector<int>primefactor;\\n    bool solve(int num)\\n    {\\n        for(int i=2;i*i<=num;i++)\\n        {\\n            while(num%i==0)\\n            {\\n                suffix[i]--;// since this number now belongs to product1 therefore deleting its prime factors from product2(suffix)\\n                if(suffix[i]==0) suffix.erase(i);\\n                if(!visited.count(i)) \\n                {\\n                    primefactor.push_back(i);\\n                    visited[i]++;\\n                }\\n                \\n                num/=i;\\n            }\\n        }\\n\\n         if(num>1)\\n            {\\n                suffix[num]--;\\n                if(suffix[num]==0) suffix.erase(num);\\n                if(!visited.count(num)) \\n                {\\n                    primefactor.push_back(num);\\n                    visited[num]++;\\n                }\\n                \\n            }\\n\\n        for(int i=0;i<primefactor.size();i++)\\n        {\\n            if(suffix.count(primefactor[i])) return false;\\n        }\\n\\n        return true;\\n    }\\n\\n\\n    int findValidSplit(vector<int>& nums) {\\n\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           presuffix(nums[i]);// we are calculating all prime factors \\n       }\\n       int n=nums.size();\\n       for(int i=0;i<n-1;i++)\\n       {\\n           if(solve(nums[i])) return i;// we are checking whether product of all numbers till i has any prime factor which is also there in product2\\n       }\\n\\n       return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990565,
                "title": "a-clever-approach-to-finding-valid-split-points-in-an-array",
                "content": "# Intuition\\nThe intuition behind the solution is to use the fact that if a number is divisible by a prime factor, then all of its proper divisors must also be divisible by that prime factor.\\n\\nE.g, the number 12 is divisible by the prime factor 2. Therefore, all of its proper divisors (1, 2, 3, 6) must also be divisible by 2.\\n\\n\\n# Approach\\nFirst initialize the right counter using the function factorize(). This function takes an integer as input and returns a list of tuples, where each tuple consists of a prime factor and the number of times it appears in the integer.\\n\\nThen initialize the left counter to be empty.\\niterate over the array from the rightmost element to the leftmost element.\\nfor each element, add the number of times the element\\'s prime factors appear in the left counter using the function collections.Counter.update().\\nfor each element, subtract the number of times the element\\'s prime factors appear in the right counter using the function collections.Counter.subtract().\\n\\nif the left counter is zero at any point, then the current element is a valid split point.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the solution is O(n log n), where n is the length of the array. This is because the function factorize() takes O(log n) time to factorize each integer in the array.\\n\\n- Space complexity:\\nThe space complexity of the solution is O(n), where n is the length of the array. This is because the right and left counters need to store a count of the number of times each prime factor appears in the array.\\n\\n\\n# Code\\n```\\nimport collections\\n\\nclass Solution(object):\\n    def findValidSplit(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Function to factorize a number into its prime factors\\n        def factorize(x):\\n            result = []\\n            d = 2\\n            while d * d <= x:\\n                e = 0\\n                while x % d == 0:\\n                    x //= d\\n                    e += 1\\n                if e:\\n                    result.append([d, e])\\n                d += 1 if d == 2 else 2\\n            if x > 1:\\n                result.append([x, 1])\\n            return result\\n        \\n        right = collections.Counter()\\n        \\n        # Iterate through nums in reverse order\\n        for x in reversed(nums):\\n            for p, c in factorize(x):\\n                right[p] += c\\n        \\n        left = collections.Counter()\\n        cnt = 0\\n        \\n        # Iterate through nums except the last element\\n        for i in range(len(nums) - 1):\\n            for p, c in factorize(nums[i]):\\n                if not left[p]:\\n                    cnt += 1\\n                left[p] += c\\n                right[p] -= c\\n                if not right[p]:\\n                    cnt -= 1\\n            if not cnt:\\n                return i\\n        \\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport collections\\n\\nclass Solution(object):\\n    def findValidSplit(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Function to factorize a number into its prime factors\\n        def factorize(x):\\n            result = []\\n            d = 2\\n            while d * d <= x:\\n                e = 0\\n                while x % d == 0:\\n                    x //= d\\n                    e += 1\\n                if e:\\n                    result.append([d, e])\\n                d += 1 if d == 2 else 2\\n            if x > 1:\\n                result.append([x, 1])\\n            return result\\n        \\n        right = collections.Counter()\\n        \\n        # Iterate through nums in reverse order\\n        for x in reversed(nums):\\n            for p, c in factorize(x):\\n                right[p] += c\\n        \\n        left = collections.Counter()\\n        cnt = 0\\n        \\n        # Iterate through nums except the last element\\n        for i in range(len(nums) - 1):\\n            for p, c in factorize(nums[i]):\\n                if not left[p]:\\n                    cnt += 1\\n                left[p] += c\\n                right[p] -= c\\n                if not right[p]:\\n                    cnt -= 1\\n            if not cnt:\\n                return i\\n        \\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976164,
                "title": "splitting-numbers-like-a-pro-no-common-primes-allowed",
                "content": "# Intuition\\nWhen faced with a problem that involves finding prime factors and counting their occurrences in two halves of an array, our first instinct might be to determine prime factors for each number in the array. One way to check if a list of numbers can be split into two sublists is by ensuring that there is no overlap in the prime factors between the two sublists. To achieve this, we can traverse the list and keep track of the prime factors encountered so far in one half and the remaining prime factors in the other half. If at any point the two sets of prime factors don\\'t overlap, a valid split is found.\\n\\n# Approach\\nWe want to split a list of numbers such that the two parts have no common prime factors. Think of it as sorting students into two classrooms, making sure no two students who share a common hobby (prime factor in our case) are separated. \\n\\nPrepare Before Sorting:\\nBefore deciding how to split, first figure out the hobbies (prime factors) of each student (number). This step ensures we don\\'t repeatedly question each student about their hobbies.\\nUnderstand the Whole Group:\\n\\nInitially, assume all students are in one big room (right dictionary).Note down the count of each hobby in this room. This gives us a sense of the total hobbies present.\\nStart Moving Students:\\n\\nBegin moving students one-by-one to another room (left dictionary). As students move, update the hobby counts in both rooms.\\nIf at any point, there\\'s no common hobby between the two rooms, that\\'s our split point.\\nFind the Best Split:\\n\\nContinue this student-moving process. If you find a point where the two rooms have distinct hobbies, note that point. If no such point is found, it means a split isn\\'t possible.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n \\\\times \\\\sqrt{m})$$ where n is the length of the nums list and m is the maximum number in the list. This is because, for each number, we determine its prime factors in approximately $$O(\\\\sqrt{m})$$ time, and this process is repeated n times.\\n\\n- Space complexity:\\n$$O(n)$$ mainly due to the storage used for all_prime_factors list, which stores the prime factors of each number. The dictionaries left and right will also use some space but their sizes are bound by the number of distinct prime factors present in the nums list, which will usually be much smaller than n.\\n\\n# Code\\n```\\nclass Solution:\\n    def findValidSplit(self, nums):\\n        n = len(nums)\\n        right = {}\\n        all_prime_factors = [self.getPrimeFactors(num) for num in nums] # Pre-compute prime factors for all numbers\\n        \\n        for prime_factors_count in all_prime_factors:\\n            for prime, count in prime_factors_count.items():\\n                right[prime] = right.get(prime, 0) + count\\n                \\n        left = {}\\n        common = set()\\n        \\n        for i in range(n - 1):\\n            prime_factors_count = all_prime_factors[i]\\n            for prime, count in prime_factors_count.items():\\n                left[prime] = left.get(prime, 0) + count\\n                right[prime] -= count\\n                \\n                if right[prime] > 0:\\n                    common.add(prime)\\n                elif right[prime] == 0:\\n                    common.discard(prime)  \\n            if not common:\\n                return i\\n                \\n        return -1\\n\\n    def getPrimeFactors(self, n):\\n        counts = {}\\n        x = 2\\n        while x * x <= n:\\n            while n % x == 0:\\n                counts[x] = counts.get(x, 0) + 1\\n                n //= x\\n            x += 1\\n        if n > 1:\\n            counts[n] = counts.get(n, 0) + 1\\n        return counts\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums):\\n        n = len(nums)\\n        right = {}\\n        all_prime_factors = [self.getPrimeFactors(num) for num in nums] # Pre-compute prime factors for all numbers\\n        \\n        for prime_factors_count in all_prime_factors:\\n            for prime, count in prime_factors_count.items():\\n                right[prime] = right.get(prime, 0) + count\\n                \\n        left = {}\\n        common = set()\\n        \\n        for i in range(n - 1):\\n            prime_factors_count = all_prime_factors[i]\\n            for prime, count in prime_factors_count.items():\\n                left[prime] = left.get(prime, 0) + count\\n                right[prime] -= count\\n                \\n                if right[prime] > 0:\\n                    common.add(prime)\\n                elif right[prime] == 0:\\n                    common.discard(prime)  \\n            if not common:\\n                return i\\n                \\n        return -1\\n\\n    def getPrimeFactors(self, n):\\n        counts = {}\\n        x = 2\\n        while x * x <= n:\\n            while n % x == 0:\\n                counts[x] = counts.get(x, 0) + 1\\n                n //= x\\n            x += 1\\n        if n > 1:\\n            counts[n] = counts.get(n, 0) + 1\\n        return counts\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959983,
                "title": "simplest-of-all-solutions",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxi=-1e9;\\n    vector<int>primefactors(int n){\\n        vector<int>res;\\n        for(int i=2;i<=(sqrt(maxi))+1;i++){\\n            if(n%i==0){\\n                res.push_back(i);\\n                while(n%i==0){\\n                    n/=i;\\n                }\\n            }\\n        }\\n        if(n>1)res.push_back(n);\\n        return res;\\n    }\\n    int findValidSplit(vector<int>& nums) {\\n        unordered_map<int,vector<int>>prf;\\n        unordered_map<int,int>mpl;\\n        unordered_map<int,int>mpr;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,nums[i]);\\n        }\\n        if(n==1)return -1;\\n        for(int i=0;i<n;i++){\\n            vector<int>p=primefactors(nums[i]);\\n            prf[i]=p;\\n            for(auto it:p){\\n                mpr[it]=i;\\n                if(mpl.find(it)==mpl.end())mpl[it]=i;\\n            }\\n        }\\n        int maxright=0;\\n        bool f=false;\\n        for(int i=0;i<n;i++){\\n            vector<int>pf = prf[i];\\n            for(auto it:pf){\\n              maxright=max(maxright,mpr[it]);\\n            }\\n            if(maxright<=i && i!=n-1){\\n                f=true;\\n                break;\\n            }\\n        }\\n        if(!f)return -1;\\n        return maxright;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi=-1e9;\\n    vector<int>primefactors(int n){\\n        vector<int>res;\\n        for(int i=2;i<=(sqrt(maxi))+1;i++){\\n            if(n%i==0){\\n                res.push_back(i);\\n                while(n%i==0){\\n                    n/=i;\\n                }\\n            }\\n        }\\n        if(n>1)res.push_back(n);\\n        return res;\\n    }\\n    int findValidSplit(vector<int>& nums) {\\n        unordered_map<int,vector<int>>prf;\\n        unordered_map<int,int>mpl;\\n        unordered_map<int,int>mpr;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,nums[i]);\\n        }\\n        if(n==1)return -1;\\n        for(int i=0;i<n;i++){\\n            vector<int>p=primefactors(nums[i]);\\n            prf[i]=p;\\n            for(auto it:p){\\n                mpr[it]=i;\\n                if(mpl.find(it)==mpl.end())mpl[it]=i;\\n            }\\n        }\\n        int maxright=0;\\n        bool f=false;\\n        for(int i=0;i<n;i++){\\n            vector<int>pf = prf[i];\\n            for(auto it:pf){\\n              maxright=max(maxright,mpr[it]);\\n            }\\n            if(maxright<=i && i!=n-1){\\n                f=true;\\n                break;\\n            }\\n        }\\n        if(!f)return -1;\\n        return maxright;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862289,
                "title": "frequency-count-of-numbers-of-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    unordered_map<int,int> getFactors(int x){\\n        unordered_map<int,int> freq;\\n        int f=2;\\n        while(x>1 && f*f<=x){\\n            while(x%f==0){\\n                freq[f]++;\\n                x/=f;\\n            }\\n            f++;\\n        }\\n        if(x!=1)    freq[x]=1;       \\n        return freq;\\n    }\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for(auto x:nums)\\n        {\\n            auto y=getFactors(x);\\n            for(auto &[i,j]:y)\\n              m[i] +=j;\\n        }\\n        int n=nums.size();\\n        unordered_map<int,int>m1;\\n        int k=0;\\n        for(auto x:nums){\\n            auto y=getFactors(x);\\n            for(auto &[i,j]:y){\\n               m1[i] +=j;\\n               m[i] -=j;\\n               if(m[i]==0)\\n                  m.erase(i);\\n            }\\n            bool a=true;\\n            for(auto x:m1){\\n                if(m.find(x.first)!=m.end()){\\n                    a=false;\\n                    break;\\n                }\\n            }\\n            if(k==n-1)\\n              return -1;\\n            if(a)\\n             return k;\\n            k++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<int,int> getFactors(int x){\\n        unordered_map<int,int> freq;\\n        int f=2;\\n        while(x>1 && f*f<=x){\\n            while(x%f==0){\\n                freq[f]++;\\n                x/=f;\\n            }\\n            f++;\\n        }\\n        if(x!=1)    freq[x]=1;       \\n        return freq;\\n    }\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for(auto x:nums)\\n        {\\n            auto y=getFactors(x);\\n            for(auto &[i,j]:y)\\n              m[i] +=j;\\n        }\\n        int n=nums.size();\\n        unordered_map<int,int>m1;\\n        int k=0;\\n        for(auto x:nums){\\n            auto y=getFactors(x);\\n            for(auto &[i,j]:y){\\n               m1[i] +=j;\\n               m[i] -=j;\\n               if(m[i]==0)\\n                  m.erase(i);\\n            }\\n            bool a=true;\\n            for(auto x:m1){\\n                if(m.find(x.first)!=m.end()){\\n                    a=false;\\n                    break;\\n                }\\n            }\\n            if(k==n-1)\\n              return -1;\\n            if(a)\\n             return k;\\n            k++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860105,
                "title": "minimal-easy-python-solution-counters-and-prime-factors",
                "content": "# Code\\noriginal:\\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        suf = Counter(x for n in nums for x in prime_factors(n))\\n        pre = Counter()\\n        for i in range(len(nums)-1):\\n            for x in prime_factors(nums[i]):\\n                suf[x] -= 1\\n                pre[x] += 1\\n            if all(suf[k]==0 for k in pre):\\n                return i\\n        return -1\\n\\ndef prime_factors(n):\\n    for i in range(2, isqrt(n)+1):\\n        while n % i == 0:\\n            yield i\\n            n //= i\\n    if n > 1:\\n        yield n\\n```\\n\\nsquished:\\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        suf = Counter(x for n in nums for x in prime_factors(n))\\n        pre = Counter()\\n        return next(i % len(nums) - 1 for i, c in enumerate(map(Counter, map(prime_factors, nums)), 1) if suf.subtract(c) or pre.update(c) or all(suf[k]==0 for k in pre))\\n\\ndef prime_factors(n):\\n    for i in range(2, isqrt(n)+1):\\n        while n % i == 0:\\n            yield i\\n            n //= i\\n    if n > 1:\\n        yield n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        suf = Counter(x for n in nums for x in prime_factors(n))\\n        pre = Counter()\\n        for i in range(len(nums)-1):\\n            for x in prime_factors(nums[i]):\\n                suf[x] -= 1\\n                pre[x] += 1\\n            if all(suf[k]==0 for k in pre):\\n                return i\\n        return -1\\n\\ndef prime_factors(n):\\n    for i in range(2, isqrt(n)+1):\\n        while n % i == 0:\\n            yield i\\n            n //= i\\n    if n > 1:\\n        yield n\\n```\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        suf = Counter(x for n in nums for x in prime_factors(n))\\n        pre = Counter()\\n        return next(i % len(nums) - 1 for i, c in enumerate(map(Counter, map(prime_factors, nums)), 1) if suf.subtract(c) or pre.update(c) or all(suf[k]==0 for k in pre))\\n\\ndef prime_factors(n):\\n    for i in range(2, isqrt(n)+1):\\n        while n % i == 0:\\n            yield i\\n            n //= i\\n    if n > 1:\\n        yield n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842808,
                "title": "python-hard",
                "content": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        N = len(nums)\\n\\n        l = 0\\n\\n\\n        pref = 1\\n\\n        while l < N - 1:\\n            \\n            pref *= nums[l]\\n\\n            r = l + 1\\n\\n            while r < N and gcd(pref, nums[r]) == 1:\\n                r += 1\\n\\n            if r == N:\\n                return l\\n\\n            for num in nums[l + 1:r]:\\n                pref *= num\\n            \\n            l = r\\n\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        N = len(nums)\\n\\n        l = 0\\n\\n\\n        pref = 1\\n\\n        while l < N - 1:\\n            \\n            pref *= nums[l]\\n\\n            r = l + 1\\n\\n            while r < N and gcd(pref, nums[r]) == 1:\\n                r += 1\\n\\n            if r == N:\\n                return l\\n\\n            for num in nums[l + 1:r]:\\n                pref *= num\\n            \\n            l = r\\n\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744275,
                "title": "java-prime-factorization-full-description-beats-100-30ms",
                "content": "# Intuition\\n\\nPrefix and suffix have`cgd(prefix,suffix) > 1` if and only if they share at least one common divider. \\n\\nEach divider has coresponding range: first & **last** index.\\n\\nThe dividers used are exclusively prime numbers.\\n\\n- For-each left-to-right array element `nums[i]`:\\n     - save `dividers` list for this element `dividers[i].add(divider)`\\n     - update `dividersMap<divider, lastIndexForThisDivider>` \\n- `Sweep line` to find index where all privious (left encountered) dividers are ended <=> where divider ranges don\\'t overlap.\\n\\n# Data structure\\n- `List<Integer>[] dividers` - factors for each element. \\n-  `Map<Integer, Integer> dMap` - <divider, lastIndexForThisDivider>\\n\\n\\n# Lifehacks & optimizations\\n - Once prepare `divideTo` array with first divider for all nubmers.\\n ex: `divideTo[6655] = 5  <=> (6655 = 5 * 11^3)`. Helps us quickly find all factors.\\n - Use dividersMap as `HashMap`. I tried with an array but it takes more time (1m int memory allocation?)\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n# Code\\n```\\nclass Solution {\\n\\n    static int[] divideTo = new int[(int) (1e6) + 1];\\n\\n    void fillDivideArray() {\\n        for (int i = 1; i < divideTo.length; i++) {\\n            divideTo[i] = i;\\n        }\\n\\n        for (int i = 2; i * i < divideTo.length; i++) {\\n            if (divideTo[i] != i)\\n                continue;\\n            for (int j = i + i; j < divideTo.length; j += i) {\\n                if (divideTo[j] == j) {\\n                    divideTo[j] = i;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public int findValidSplit(int[] nums) {\\n        if (divideTo[1] == 0) {\\n            fillDivideArray();\\n        }\\n        \\n        //int[] dMap = new int[(int) 1e6 + 1];\\n        Map<Integer, Integer> dMap = new HashMap<>();\\n        List<Integer>[] dividers = new List[nums.length];\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            dividers[i] = new ArrayList<>();\\n            while (nums[i] != 1) {\\n                dividers[i].add(divideTo[nums[i]]);\\n                dMap.put(divideTo[nums[i]], i);\\n                nums[i] = nums[i] / divideTo[nums[i]];\\n            }\\n        }\\n\\n        int nextEnd = 0, i = 0;\\n        while (i <= nextEnd) {\\n            for (int j = 0; j < dividers[i].size(); j++) {\\n                //nextEnd = Math.max(nextEnd, dMap[(dividers[i].get(j))]);\\n                nextEnd = Math.max(nextEnd, dMap.get(dividers[i].get(j)));\\n            }\\n            i++;\\n        }\\n\\n        if (i == nums.length)\\n            return -1;\\n\\n        return i - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Line Sweep"
                ],
                "code": "```\\nclass Solution {\\n\\n    static int[] divideTo = new int[(int) (1e6) + 1];\\n\\n    void fillDivideArray() {\\n        for (int i = 1; i < divideTo.length; i++) {\\n            divideTo[i] = i;\\n        }\\n\\n        for (int i = 2; i * i < divideTo.length; i++) {\\n            if (divideTo[i] != i)\\n                continue;\\n            for (int j = i + i; j < divideTo.length; j += i) {\\n                if (divideTo[j] == j) {\\n                    divideTo[j] = i;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public int findValidSplit(int[] nums) {\\n        if (divideTo[1] == 0) {\\n            fillDivideArray();\\n        }\\n        \\n        //int[] dMap = new int[(int) 1e6 + 1];\\n        Map<Integer, Integer> dMap = new HashMap<>();\\n        List<Integer>[] dividers = new List[nums.length];\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            dividers[i] = new ArrayList<>();\\n            while (nums[i] != 1) {\\n                dividers[i].add(divideTo[nums[i]]);\\n                dMap.put(divideTo[nums[i]], i);\\n                nums[i] = nums[i] / divideTo[nums[i]];\\n            }\\n        }\\n\\n        int nextEnd = 0, i = 0;\\n        while (i <= nextEnd) {\\n            for (int j = 0; j < dividers[i].size(); j++) {\\n                //nextEnd = Math.max(nextEnd, dMap[(dividers[i].get(j))]);\\n                nextEnd = Math.max(nextEnd, dMap.get(dividers[i].get(j)));\\n            }\\n            i++;\\n        }\\n\\n        if (i == nums.length)\\n            return -1;\\n\\n        return i - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724507,
                "title": "divisor-separation-a-solution-for-2-non-overlapping-sets",
                "content": "# Intuition\\nThe idea is to make a stack of Divisors per each passed element.\\nAs a result, we are looking for **left-hand** & **right-hand** sets of divisors.\\n\\nThe separation is great if\\nThese two sets do not have any common elements.\\n\\n\\n# Approach\\n- left-hand set is equal to all divisors of `nums[0]`\\n- go through elements from left to right\\n- if any of `nums[i]` devisors  appears in suffix set, (1) move answear to `i` and (2) join all known right-hand deviders into suffix set.\\n\\n# Complexity\\nTime complexity: `O(N * sqrt(N) * log(N))` \\n- loop through `Nums`;\\n- inner loop for dividers search\\n- each divider requires set search \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDivisors(int num) {\\n        vector<int> divisors = {};\\n        int sqrtNum = sqrt(num);\\n\\n        for (int i = 2; i <= sqrtNum; i++) {\\n            if (num % i == 0) {\\n                divisors.push_back(i);\\n                while (num % i == 0) {\\n                    num /= i;\\n                }\\n            }\\n        }\\n\\n        if (num > 1) divisors.push_back(num);\\n\\n        return divisors;\\n    }\\n\\n    int findValidSplit(vector<int>& nums) {\\n        short ans = 0;\\n        unordered_set <int> prefixSet, suffixSet;\\n        vector<int> stackOfDivisors;\\n\\n        if (nums.size() == 1) return -1;\\n\\n        // for 0 : push all divisors into prefixSet\\n        stackOfDivisors = findDivisors(nums[0]);\\n        for (int i = 0; i < stackOfDivisors.size(); ++i) prefixSet.insert(stackOfDivisors[i]);\\n\\n\\n        // for other\\n        for (short i = 1; i < nums.size(); i++) {\\n            stackOfDivisors = findDivisors(nums[i]);\\n\\n            bool thereIsCommonDeviderInPrefixSet = false;\\n\\n            // go through the stack of divisors\\n            for (short j = 0; j < stackOfDivisors.size(); ++j) {\\n\\n                suffixSet.insert(stackOfDivisors[j]);\\n\\n                // if devisor is in the prefix set\\n                if (prefixSet.find(stackOfDivisors[j]) != prefixSet.end()) thereIsCommonDeviderInPrefixSet = true;\\n            }\\n\\n            if (thereIsCommonDeviderInPrefixSet) {\\n                ans = i; // move answer\\n                prefixSet.insert(suffixSet.begin(), suffixSet.end()); // union prefixSet with suffixSet into prefixSet\\n                suffixSet.clear(); // clear suffixSet\\n            }\\n        }\\n\\n        if (ans <= nums.size() - 2) return ans;\\n\\n        return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDivisors(int num) {\\n        vector<int> divisors = {};\\n        int sqrtNum = sqrt(num);\\n\\n        for (int i = 2; i <= sqrtNum; i++) {\\n            if (num % i == 0) {\\n                divisors.push_back(i);\\n                while (num % i == 0) {\\n                    num /= i;\\n                }\\n            }\\n        }\\n\\n        if (num > 1) divisors.push_back(num);\\n\\n        return divisors;\\n    }\\n\\n    int findValidSplit(vector<int>& nums) {\\n        short ans = 0;\\n        unordered_set <int> prefixSet, suffixSet;\\n        vector<int> stackOfDivisors;\\n\\n        if (nums.size() == 1) return -1;\\n\\n        // for 0 : push all divisors into prefixSet\\n        stackOfDivisors = findDivisors(nums[0]);\\n        for (int i = 0; i < stackOfDivisors.size(); ++i) prefixSet.insert(stackOfDivisors[i]);\\n\\n\\n        // for other\\n        for (short i = 1; i < nums.size(); i++) {\\n            stackOfDivisors = findDivisors(nums[i]);\\n\\n            bool thereIsCommonDeviderInPrefixSet = false;\\n\\n            // go through the stack of divisors\\n            for (short j = 0; j < stackOfDivisors.size(); ++j) {\\n\\n                suffixSet.insert(stackOfDivisors[j]);\\n\\n                // if devisor is in the prefix set\\n                if (prefixSet.find(stackOfDivisors[j]) != prefixSet.end()) thereIsCommonDeviderInPrefixSet = true;\\n            }\\n\\n            if (thereIsCommonDeviderInPrefixSet) {\\n                ans = i; // move answer\\n                prefixSet.insert(suffixSet.begin(), suffixSet.end()); // union prefixSet with suffixSet into prefixSet\\n                suffixSet.clear(); // clear suffixSet\\n            }\\n        }\\n\\n        if (ans <= nums.size() - 2) return ans;\\n\\n        return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711135,
                "title": "java-diff-array",
                "content": "**For each prime, we can see them as a contingency array, it starts from the first element with such prime factor to the last element with such prime factor. The first place that be segmented is the answer.**\\n![IMG_0780.jpg](https://assets.leetcode.com/users/images/b8405684-1738-4bf3-9aa5-706d6599d800_1688362272.9395916.jpeg)\\n\\n```\\nimport java.util.AbstractMap;\\nclass Solution {\\n    public int findValidSplit(int[] nums) {\\n        Map<Integer, AbstractMap.SimpleEntry<Integer, Integer>> intervals = new HashMap<>();\\n        List<Integer> primes = eratosthenes((int) 1e6);\\n        for (int i = 0; i < nums.length; i++) {\\n            int temp = nums[i];\\n            for (Integer prime : primes) {\\n                if (temp == 1) break;\\n                if (prime > Math.sqrt(temp)) {\\n                    if (!intervals.containsKey(temp)) {\\n                        AbstractMap.SimpleEntry<Integer, Integer> pair = new AbstractMap.SimpleEntry<>(i, i);\\n                        intervals.put(temp, pair);\\n                    } else {\\n                        AbstractMap.SimpleEntry<Integer, Integer> pair = intervals.get(temp);\\n                        pair.setValue(i);\\n                        intervals.put(temp, pair);\\n                    }\\n                    break;\\n                }\\n                if (temp % prime == 0) {\\n                    if (!intervals.containsKey(prime)) {\\n                        AbstractMap.SimpleEntry<Integer, Integer> pair = new AbstractMap.SimpleEntry<>(i, i);\\n                        intervals.put(prime, pair);\\n                    } else {\\n                        AbstractMap.SimpleEntry<Integer, Integer> pair = intervals.get(prime);\\n                        pair.setValue(i);\\n                        intervals.put(prime, pair);\\n                    }\\n                }\\n                while (temp % prime == 0) {\\n                    temp /= prime;\\n                }\\n            }\\n        }\\n        int[] diff = new int[nums.length];\\n        for (Map.Entry<Integer, AbstractMap.SimpleEntry<Integer, Integer>> entry : intervals.entrySet()) {\\n            AbstractMap.SimpleEntry<Integer, Integer> pair = entry.getValue();\\n            Integer start = pair.getKey();\\n            Integer end = pair.getValue();\\n            if (start == end) continue;\\n            diff[start]++;\\n            diff[end]--;\\n        }\\n        int sum = 0;\\n        for (int i = 0; i < diff.length - 1; i++) {\\n            sum += diff[i];\\n            if (sum == 0) return i;\\n        }\\n        return -1;\\n    }\\n\\n    private List<Integer> eratosthenes(int n) {\\n        int[] q = new int[n + 1];\\n        List<Integer> primes = new ArrayList<>();\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (q[i] == 1) continue;\\n            int j = i * 2;\\n            while (j <= n) {\\n                q[j] = 1;\\n                j += i;\\n            }\\n        }\\n        for (int i = 2; i <= n; i++) {\\n            if (q[i] == 0) {\\n                primes.add(i);\\n            }\\n        }\\n        return primes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.AbstractMap;\\nclass Solution {\\n    public int findValidSplit(int[] nums) {\\n        Map<Integer, AbstractMap.SimpleEntry<Integer, Integer>> intervals = new HashMap<>();\\n        List<Integer> primes = eratosthenes((int) 1e6);\\n        for (int i = 0; i < nums.length; i++) {\\n            int temp = nums[i];\\n            for (Integer prime : primes) {\\n                if (temp == 1) break;\\n                if (prime > Math.sqrt(temp)) {\\n                    if (!intervals.containsKey(temp)) {\\n                        AbstractMap.SimpleEntry<Integer, Integer> pair = new AbstractMap.SimpleEntry<>(i, i);\\n                        intervals.put(temp, pair);\\n                    } else {\\n                        AbstractMap.SimpleEntry<Integer, Integer> pair = intervals.get(temp);\\n                        pair.setValue(i);\\n                        intervals.put(temp, pair);\\n                    }\\n                    break;\\n                }\\n                if (temp % prime == 0) {\\n                    if (!intervals.containsKey(prime)) {\\n                        AbstractMap.SimpleEntry<Integer, Integer> pair = new AbstractMap.SimpleEntry<>(i, i);\\n                        intervals.put(prime, pair);\\n                    } else {\\n                        AbstractMap.SimpleEntry<Integer, Integer> pair = intervals.get(prime);\\n                        pair.setValue(i);\\n                        intervals.put(prime, pair);\\n                    }\\n                }\\n                while (temp % prime == 0) {\\n                    temp /= prime;\\n                }\\n            }\\n        }\\n        int[] diff = new int[nums.length];\\n        for (Map.Entry<Integer, AbstractMap.SimpleEntry<Integer, Integer>> entry : intervals.entrySet()) {\\n            AbstractMap.SimpleEntry<Integer, Integer> pair = entry.getValue();\\n            Integer start = pair.getKey();\\n            Integer end = pair.getValue();\\n            if (start == end) continue;\\n            diff[start]++;\\n            diff[end]--;\\n        }\\n        int sum = 0;\\n        for (int i = 0; i < diff.length - 1; i++) {\\n            sum += diff[i];\\n            if (sum == 0) return i;\\n        }\\n        return -1;\\n    }\\n\\n    private List<Integer> eratosthenes(int n) {\\n        int[] q = new int[n + 1];\\n        List<Integer> primes = new ArrayList<>();\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (q[i] == 1) continue;\\n            int j = i * 2;\\n            while (j <= n) {\\n                q[j] = 1;\\n                j += i;\\n            }\\n        }\\n        for (int i = 2; i <= n; i++) {\\n            if (q[i] == 0) {\\n                primes.add(i);\\n            }\\n        }\\n        return primes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651310,
                "title": "java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int findValidSplit(int[] nums) {\\n        if (nums.length == 1) {\\n            return -1;\\n        }\\n\\n        // Get factors of each number, and the factor ranges\\n        List<Integer>[] factors = new List[nums.length];\\n        Map<Integer, Integer> factorEnds = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            factors[i] = new ArrayList<>();\\n            for (int j = 2; j * j <= nums[i]; j++) {\\n                if (nums[i] % j == 0) {\\n                    factors[i].add(j);\\n                    factors[i].add(nums[i] / j);\\n                    factorEnds.put(j, i);\\n                    factorEnds.put(nums[i] / j, i);\\n                }\\n            }\\n            if (nums[i] != 1) {\\n                factors[i].add(nums[i]);\\n                factorEnds.put(nums[i], i);\\n            }\\n        }\\n\\n        // Sweep line\\n        int end = 0;\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            for (int factor : factors[i]) {\\n                end = Math.max(end, factorEnds.get(factor));\\n            }\\n            if (end == nums.length - 1) {\\n                break;\\n            }\\n            if (end == i) {\\n                return end;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int findValidSplit(int[] nums) {\\n        if (nums.length == 1) {\\n            return -1;\\n        }\\n\\n        // Get factors of each number, and the factor ranges\\n        List<Integer>[] factors = new List[nums.length];\\n        Map<Integer, Integer> factorEnds = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            factors[i] = new ArrayList<>();\\n            for (int j = 2; j * j <= nums[i]; j++) {\\n                if (nums[i] % j == 0) {\\n                    factors[i].add(j);\\n                    factors[i].add(nums[i] / j);\\n                    factorEnds.put(j, i);\\n                    factorEnds.put(nums[i] / j, i);\\n                }\\n            }\\n            if (nums[i] != 1) {\\n                factors[i].add(nums[i]);\\n                factorEnds.put(nums[i], i);\\n            }\\n        }\\n\\n        // Sweep line\\n        int end = 0;\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            for (int factor : factors[i]) {\\n                end = Math.max(end, factorEnds.get(factor));\\n            }\\n            if (end == nums.length - 1) {\\n                break;\\n            }\\n            if (end == i) {\\n                return end;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542368,
                "title": "91-25-in-speed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nmx = 10**6\\nspf = [i for i in range(mx+1)]\\nfor i in range(2,int(math.sqrt(mx))+1):\\n    if spf[i]==i:\\n        for j in range(i*i,mx+1,i):\\n            spf[j]=min(spf[j],i)\\ndef getPrimeFactors(x):\\n    while x!=1:\\n        yield spf[x]\\n        x//=spf[x]\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        fac_idx = defaultdict(int)\\n        for i,v in enumerate(nums):\\n            for fac in getPrimeFactors(v):\\n                fac_idx[fac] = i\\n        right_most = 0\\n        for i in range(len(nums)-1):\\n            for fac in getPrimeFactors(nums[i]):\\n                right_most = max(right_most,fac_idx[fac])\\n            if right_most==i:\\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nmx = 10**6\\nspf = [i for i in range(mx+1)]\\nfor i in range(2,int(math.sqrt(mx))+1):\\n    if spf[i]==i:\\n        for j in range(i*i,mx+1,i):\\n            spf[j]=min(spf[j],i)\\ndef getPrimeFactors(x):\\n    while x!=1:\\n        yield spf[x]\\n        x//=spf[x]\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        fac_idx = defaultdict(int)\\n        for i,v in enumerate(nums):\\n            for fac in getPrimeFactors(v):\\n                fac_idx[fac] = i\\n        right_most = 0\\n        for i in range(len(nums)-1):\\n            for fac in getPrimeFactors(nums[i]):\\n                right_most = max(right_most,fac_idx[fac])\\n            if right_most==i:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541795,
                "title": "c-good-solution-100-120ms-vs-fast-solution-20-40ms",
                "content": "# Good\\n```\\nconst vector<int> PRIMS = {\\n       2,    3,    5,    7,   11,   13,   17,   19,   23,   29,   31,   37,   41,   43,   47,   53,   59,   61,   67,   71,\\n      73,   79,   83,   89,   97,  101,  103,  107,  109,  113,  127,  131,  137,  139,  149,  151,  157,  163,  167,  173,\\n     179,  181,  191,  193,  197,  199,  211,  223,  227,  229,  233,  239,  241,  251,  257,  263,  269,  271,  277,  281,\\n     283,  293,  307,  311,  313,  317,  331,  337,  347,  349,  353,  359,  367,  373,  379,  383,  389,  397,  401,  409,\\n     419,  421,  431,  433,  439,  443,  449,  457,  461,  463,  467,  479,  487,  491,  499,  503,  509,  521,  523,  541,\\n     547,  557,  563,  569,  571,  577,  587,  593,  599,  601,  607,  613,  617,  619,  631,  641,  643,  647,  653,  659,\\n     661,  673,  677,  683,  691,  701,  709,  719,  727,  733,  739,  743,  751,  757,  761,  769,  773,  787,  797,  809,\\n     811,  821,  823,  827,  829,  839,  853,  857,  859,  863,  877,  881,  883,  887,  907,  911,  919,  929,  937,  941,\\n     947,  953,  967,  971,  977,  983,  991,  997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069,\\n    1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223,\\n    1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373,\\n    1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511,\\n    1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657,\\n    1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811,\\n    1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987,\\n    1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129,\\n    2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287,\\n    2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423,\\n    2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617,\\n    2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741,\\n    2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903,\\n    2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079,\\n    3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257,\\n    3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413,\\n    3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571\\n};\\n\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int res = 0;\\n        auto size = nums.size();\\n        unordered_set<int> hash;\\n        int n = *nums.begin();\\n        auto it_p = PRIMS.begin();\\n        int p = *it_p;\\n        while (n > 1) {\\n            if (p*p > n) p = n;\\n            if (n % p != 0) {\\n                p = *(++it_p);\\n                continue;\\n            }\\n            n /= p;\\n            while (n % p == 0) n /= p;\\n            hash.emplace(p);\\n        }\\n\\n        unordered_set<int> buf;\\n        for (int i = 1; i < size; ++i) {\\n            int n = nums[i];\\n            auto it_p = PRIMS.begin();\\n            int p = *it_p;\\n            while (n > 1) {\\n                if (p*p > n) p = n;\\n                if (n % p != 0) {\\n                    p = *(++it_p);\\n                    continue;\\n                }\\n                n /= p;\\n                while (n % p == 0) n /= p;\\n                if (hash.count(p) == 0) {\\n                    buf.emplace(p);\\n                    p = *(++it_p);\\n                    continue;\\n                }\\n                p = *(++it_p);\\n                while (n > 1) {\\n                    if (p*p > n) p = n;\\n                    if (n % p != 0) {\\n                        p = *(++it_p);\\n                        continue;\\n                    }\\n                    n /= p;\\n                    while (n % p == 0) n /= p;\\n                    hash.emplace(p);\\n                    p = *(++it_p);\\n                }\\n                hash.insert(buf.begin(), buf.end());\\n                buf.clear();\\n                res = i;\\n            }\\n        }\\n        return (res == size - 1) ? -1 : res;\\n    }\\n};\\n```\\n# Fast\\n```\\n#define __MAX__ 1000001\\n\\nint MIN_FACT[__MAX__];\\nint flags[__MAX__];\\nint buf[__MAX__];\\n\\nconst auto initialize = [] {\\n \\xA0 \\xA0std::ios\\n \\xA0 \\xA0for (int n = 2; n < __MAX__; ++n) {\\n        if (MIN_FACT[n] != 0) continue;\\n        for (int m = n; m < __MAX__; m += n) {\\n            MIN_FACT[m] = n;\\n        }\\n    }\\n    flags[0] = -1;\\n    buf[0] = -1;\\n    return true;\\n} ();\\n\\ninline int DepriveMinPrime(int& val) {\\n    int res = MIN_FACT[val];\\n    while (val % res == 0) val /= res;\\n    return res;\\n};\\n\\ninline bool buf_Find(size_t val) {\\n    return (buf[val] != 0);\\n}\\n\\ninline void buf_Push(int val) {\\n    if (buf_Find(val)) return;\\n    buf[val] = buf[0];\\n    buf[0] = val;\\n}\\n\\ninline void buf_\\u0421lear() {\\n    auto handle = buf[0];\\n    while (handle != -1) {\\n        auto tmp = buf[handle];\\n        buf[handle] = 0;\\n        handle = tmp;\\n    }\\n    buf[0] = handle;\\n}\\n\\ninline bool flags_Find(size_t val) {\\n    return (flags[val] != 0);\\n}\\n\\ninline void flags_Push(int val) {\\n    if (flags_Find(val)) return;\\n    flags[val] = flags[0];\\n    flags[0] = val;\\n}\\n\\ninline void flags_\\u0421lear() {\\n    auto handle = flags[0];\\n    while (handle != -1) {\\n        auto tmp = flags[handle];\\n        flags[handle] = 0;\\n        handle = tmp;\\n    }\\n    flags[0] = handle;\\n}\\n\\ninline void buf_to_flags() {\\n    auto handle = buf[0];\\n    while (handle != -1) {\\n        flags_Push(handle);\\n        auto tmp = buf[handle];\\n        buf[handle] = 0;\\n        handle = tmp;\\n    }\\n    buf[0] = handle;\\n}\\n\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int res = 0;\\n        auto size = nums.size();\\n        int n = nums[0];\\n        int p;\\n        flags_\\u0421lear();\\n        while (n > 1) {\\n            p = DepriveMinPrime(n);\\n            flags_Push(p);\\n        }\\n\\n        buf_\\u0421lear();\\n        for (int i = 1; i < size; ++i) {\\n            n = nums[i];\\n            while (n > 1) {\\n                p = DepriveMinPrime(n);\\n                if (!flags_Find(p)) {\\n                    buf_Push(p);\\n                    continue;\\n                }\\n                buf_to_flags();\\n                res = i;\\n                while (n > 1) {\\n                    p = DepriveMinPrime(n);\\n                    flags_Push(p);\\n                }\\n            }\\n        }\\n        return (res == size - 1) ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nconst vector<int> PRIMS = {\\n       2,    3,    5,    7,   11,   13,   17,   19,   23,   29,   31,   37,   41,   43,   47,   53,   59,   61,   67,   71,\\n      73,   79,   83,   89,   97,  101,  103,  107,  109,  113,  127,  131,  137,  139,  149,  151,  157,  163,  167,  173,\\n     179,  181,  191,  193,  197,  199,  211,  223,  227,  229,  233,  239,  241,  251,  257,  263,  269,  271,  277,  281,\\n     283,  293,  307,  311,  313,  317,  331,  337,  347,  349,  353,  359,  367,  373,  379,  383,  389,  397,  401,  409,\\n     419,  421,  431,  433,  439,  443,  449,  457,  461,  463,  467,  479,  487,  491,  499,  503,  509,  521,  523,  541,\\n     547,  557,  563,  569,  571,  577,  587,  593,  599,  601,  607,  613,  617,  619,  631,  641,  643,  647,  653,  659,\\n     661,  673,  677,  683,  691,  701,  709,  719,  727,  733,  739,  743,  751,  757,  761,  769,  773,  787,  797,  809,\\n     811,  821,  823,  827,  829,  839,  853,  857,  859,  863,  877,  881,  883,  887,  907,  911,  919,  929,  937,  941,\\n     947,  953,  967,  971,  977,  983,  991,  997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069,\\n    1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223,\\n    1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373,\\n    1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511,\\n    1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657,\\n    1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811,\\n    1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987,\\n    1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129,\\n    2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287,\\n    2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423,\\n    2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617,\\n    2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741,\\n    2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903,\\n    2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079,\\n    3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257,\\n    3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413,\\n    3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571\\n};\\n\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int res = 0;\\n        auto size = nums.size();\\n        unordered_set<int> hash;\\n        int n = *nums.begin();\\n        auto it_p = PRIMS.begin();\\n        int p = *it_p;\\n        while (n > 1) {\\n            if (p*p > n) p = n;\\n            if (n % p != 0) {\\n                p = *(++it_p);\\n                continue;\\n            }\\n            n /= p;\\n            while (n % p == 0) n /= p;\\n            hash.emplace(p);\\n        }\\n\\n        unordered_set<int> buf;\\n        for (int i = 1; i < size; ++i) {\\n            int n = nums[i];\\n            auto it_p = PRIMS.begin();\\n            int p = *it_p;\\n            while (n > 1) {\\n                if (p*p > n) p = n;\\n                if (n % p != 0) {\\n                    p = *(++it_p);\\n                    continue;\\n                }\\n                n /= p;\\n                while (n % p == 0) n /= p;\\n                if (hash.count(p) == 0) {\\n                    buf.emplace(p);\\n                    p = *(++it_p);\\n                    continue;\\n                }\\n                p = *(++it_p);\\n                while (n > 1) {\\n                    if (p*p > n) p = n;\\n                    if (n % p != 0) {\\n                        p = *(++it_p);\\n                        continue;\\n                    }\\n                    n /= p;\\n                    while (n % p == 0) n /= p;\\n                    hash.emplace(p);\\n                    p = *(++it_p);\\n                }\\n                hash.insert(buf.begin(), buf.end());\\n                buf.clear();\\n                res = i;\\n            }\\n        }\\n        return (res == size - 1) ? -1 : res;\\n    }\\n};\\n```\n```\\n#define __MAX__ 1000001\\n\\nint MIN_FACT[__MAX__];\\nint flags[__MAX__];\\nint buf[__MAX__];\\n\\nconst auto initialize = [] {\\n \\xA0 \\xA0std::ios\\n \\xA0 \\xA0for (int n = 2; n < __MAX__; ++n) {\\n        if (MIN_FACT[n] != 0) continue;\\n        for (int m = n; m < __MAX__; m += n) {\\n            MIN_FACT[m] = n;\\n        }\\n    }\\n    flags[0] = -1;\\n    buf[0] = -1;\\n    return true;\\n} ();\\n\\ninline int DepriveMinPrime(int& val) {\\n    int res = MIN_FACT[val];\\n    while (val % res == 0) val /= res;\\n    return res;\\n};\\n\\ninline bool buf_Find(size_t val) {\\n    return (buf[val] != 0);\\n}\\n\\ninline void buf_Push(int val) {\\n    if (buf_Find(val)) return;\\n    buf[val] = buf[0];\\n    buf[0] = val;\\n}\\n\\ninline void buf_\\u0421lear() {\\n    auto handle = buf[0];\\n    while (handle != -1) {\\n        auto tmp = buf[handle];\\n        buf[handle] = 0;\\n        handle = tmp;\\n    }\\n    buf[0] = handle;\\n}\\n\\ninline bool flags_Find(size_t val) {\\n    return (flags[val] != 0);\\n}\\n\\ninline void flags_Push(int val) {\\n    if (flags_Find(val)) return;\\n    flags[val] = flags[0];\\n    flags[0] = val;\\n}\\n\\ninline void flags_\\u0421lear() {\\n    auto handle = flags[0];\\n    while (handle != -1) {\\n        auto tmp = flags[handle];\\n        flags[handle] = 0;\\n        handle = tmp;\\n    }\\n    flags[0] = handle;\\n}\\n\\ninline void buf_to_flags() {\\n    auto handle = buf[0];\\n    while (handle != -1) {\\n        flags_Push(handle);\\n        auto tmp = buf[handle];\\n        buf[handle] = 0;\\n        handle = tmp;\\n    }\\n    buf[0] = handle;\\n}\\n\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int res = 0;\\n        auto size = nums.size();\\n        int n = nums[0];\\n        int p;\\n        flags_\\u0421lear();\\n        while (n > 1) {\\n            p = DepriveMinPrime(n);\\n            flags_Push(p);\\n        }\\n\\n        buf_\\u0421lear();\\n        for (int i = 1; i < size; ++i) {\\n            n = nums[i];\\n            while (n > 1) {\\n                p = DepriveMinPrime(n);\\n                if (!flags_Find(p)) {\\n                    buf_Push(p);\\n                    continue;\\n                }\\n                buf_to_flags();\\n                res = i;\\n                while (n > 1) {\\n                    p = DepriveMinPrime(n);\\n                    flags_Push(p);\\n                }\\n            }\\n        }\\n        return (res == size - 1) ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526385,
                "title": "c-solution-prime-factorization",
                "content": "```\\nclass Solution {\\npublic:\\n    const int nax = 1e6 + 1;\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> prime(nax, 1);\\n        for (int i = 2; i < nax; i++) {\\n            if (prime[i] == 1) {\\n                for (int j = i; j < nax; j += i) {\\n                    prime[j] = i;\\n                }\\n            }\\n        }\\n        auto factor = [&] (int num) -> vector<int> {\\n            vector<int> fac;\\n            while (num > 1) {\\n                int f = prime[num];\\n                fac.push_back(f);\\n                num /= f;\\n            }\\n            \\n            return fac;\\n        };\\n        vector<int> mxFacIndeces(nax);\\n        for (int i = 0; i < n; i++) {\\n            vector<int> fac = factor(nums[i]);\\n            for (int f : fac) mxFacIndeces[f] = max(mxFacIndeces[f], i);\\n        }\\n        int next = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (i > next) break;\\n            vector<int> fac = factor(nums[i]);\\n            for (int f : fac) {\\n                next = max(next, mxFacIndeces[f]);\\n            }\\n        }\\n        if (next == n - 1) return -1;\\n        return next;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int nax = 1e6 + 1;\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> prime(nax, 1);\\n        for (int i = 2; i < nax; i++) {\\n            if (prime[i] == 1) {\\n                for (int j = i; j < nax; j += i) {\\n                    prime[j] = i;\\n                }\\n            }\\n        }\\n        auto factor = [&] (int num) -> vector<int> {\\n            vector<int> fac;\\n            while (num > 1) {\\n                int f = prime[num];\\n                fac.push_back(f);\\n                num /= f;\\n            }\\n            \\n            return fac;\\n        };\\n        vector<int> mxFacIndeces(nax);\\n        for (int i = 0; i < n; i++) {\\n            vector<int> fac = factor(nums[i]);\\n            for (int f : fac) mxFacIndeces[f] = max(mxFacIndeces[f], i);\\n        }\\n        int next = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (i > next) break;\\n            vector<int> fac = factor(nums[i]);\\n            for (int f : fac) {\\n                next = max(next, mxFacIndeces[f]);\\n            }\\n        }\\n        if (next == n - 1) return -1;\\n        return next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523390,
                "title": "c-solution-using-hash-set-prime-factors",
                "content": "```\\npublic class Solution {\\n    public int FindValidSplit(int[] nums) {\\n        Dictionary<int,int> factorLastFound = new Dictionary<int,int>();\\n        HashSet<int> getPrimeFactor(int idx){\\n            int x = nums[idx];\\n            HashSet<int> res = new HashSet<int>();\\n            for(int i = 2;i * i <= x;i++){\\n                while(x % i == 0){\\n                    x/=i;\\n                    res.Add(i);\\n                    factorLastFound[i] = idx;\\n                }\\n            }\\n            if(x > 1){\\n                res.Add(x);\\n                factorLastFound[x] = idx;\\n            }\\n            return res;\\n        }\\n\\n        HashSet<int>[] factors = new HashSet<int>[nums.Length];\\n        for(int i = 0; i < nums.Length;i++)\\n            factors[i] = getPrimeFactor(i);\\n           \\n        int res = -1,lastFactorFound = 0;\\n        for(int i = 0; i < nums.Length - 1;i++){\\n            HashSet<int> set1 = factors[i];\\n            foreach(var el in set1){\\n                if(factorLastFound[el] == nums.Length - 1) return res;\\n                lastFactorFound = Math.Max(factorLastFound[el],lastFactorFound);\\n            }\\n            if(lastFactorFound == i) return i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Number Theory"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindValidSplit(int[] nums) {\\n        Dictionary<int,int> factorLastFound = new Dictionary<int,int>();\\n        HashSet<int> getPrimeFactor(int idx){\\n            int x = nums[idx];\\n            HashSet<int> res = new HashSet<int>();\\n            for(int i = 2;i * i <= x;i++){\\n                while(x % i == 0){\\n                    x/=i;\\n                    res.Add(i);\\n                    factorLastFound[i] = idx;\\n                }\\n            }\\n            if(x > 1){\\n                res.Add(x);\\n                factorLastFound[x] = idx;\\n            }\\n            return res;\\n        }\\n\\n        HashSet<int>[] factors = new HashSet<int>[nums.Length];\\n        for(int i = 0; i < nums.Length;i++)\\n            factors[i] = getPrimeFactor(i);\\n           \\n        int res = -1,lastFactorFound = 0;\\n        for(int i = 0; i < nums.Length - 1;i++){\\n            HashSet<int> set1 = factors[i];\\n            foreach(var el in set1){\\n                if(factorLastFound[el] == nums.Length - 1) return res;\\n                lastFactorFound = Math.Max(factorLastFound[el],lastFactorFound);\\n            }\\n            if(lastFactorFound == i) return i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519308,
                "title": "easy-solution",
                "content": "Lets find all prime factor of all numbers using eratoshen algo. Then we can easily go from start to end and save what prime factor we update when we go, if there are no such numers there consists such prime factors - we have flag is ok, else flag is false; when we update some numbers and all flags is ok, its index is the answer. Sorry for my bad english\\n\\n\\n\\nCode Here:\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        const long long INF = 1000005;\\n        vector <int> erat(INF, 1);\\n        for(int i = 0;i < INF;i++){\\n            erat[i] = i;\\n        }\\n        for(int i = 2;i <= 10000 + 5;i++){\\n            if(erat[i] == i){\\n                long long u = i * i;\\n                while(u < INF){\\n                    erat[u] = i;\\n                    u += i;\\n                }\\n                erat[i] = i;\\n            }\\n        }\\n        vector<unordered_map<long long, long long>> some(n);\\n        unordered_map <long long, long long> all;\\n        unordered_map<long long, long long> flag;\\n        for(int i = 0;i < n;i++){\\n            long long x = nums[i];\\n            while(x != 1LL){\\n                some[i][erat[x]] += 1;\\n                all[erat[x]] += 1;\\n                flag[erat[x]] = 0;                \\n                x /= erat[x];\\n            }\\n        }\\n        int sum_flag = 0;\\n        int answer = -1;\\n        for(int i = 0;i < n - 1;i++){\\n            cout << sum_flag << i << \" \" << some[i].size() << endl;\\n            for(auto j : some[i]){\\n                cout << j.first <<\" \"<< j.second << \" \" << all[j.first] << endl;\\n                all[j.first] -= j.second;\\n                if(all[j.first] == 0){\\n                    if(flag[j.first] == 1){\\n                        sum_flag --;\\n                        flag[j.first] = 0;\\n                    }\\n                }\\n                else{\\n                    if(flag[j.first] == 0)sum_flag ++;  \\n                    flag[j.first] = 1;                  \\n                }\\n            }\\n            if(sum_flag == 0){\\n                answer = i;\\n                break;\\n            }\\n        }\\n        return answer;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        const long long INF = 1000005;\\n        vector <int> erat(INF, 1);\\n        for(int i = 0;i < INF;i++){\\n            erat[i] = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3512950,
                "title": "split-the-array-to-make-coprime-products-solution",
                "content": "# Intuition\\nThe problem requires finding the smallest index at which an array can be split into two parts, such that the product of the elements on the left side and the product of the elements on the right side are coprime (have no common factors except 1). To solve this, we need to consider the factors of each number in the array and check for valid splits.\\n\\n# Approach\\nThe solution approach involves several steps:\\n\\nHandle edge cases:\\n\\nIf the array contains only one number, return -1 since it cannot be split.\\nIf the array starts with 1, return 0 since splitting before the first element results in coprime products.\\nGenerate a list of prime numbers using the Eratosthenes\\' sieve algorithm up to the maximum number in the input array. This will be used to factorize the numbers efficiently.\\n\\nIterate over each number in the array and factorize it using the generated prime numbers. For each number, store the indices at which it appears in a map. If a number has prime factors larger than the square root of the number, it is coprime with any number after it, so we update the indices accordingly.\\n\\nInitialize an array to track the count of factors at each index. Iterate over the map entries and increment/decrement the factor counts accordingly.\\n\\nIterate over the factor count array, checking if the cumulative sum becomes zero at any index. If it does, return that index as the valid split point.\\n\\nIf no valid split is found, return -1.\\n\\n# Complexity\\nTime complexity: The prime number generation using the Eratosthenes\\' sieve algorithm has a time complexity of O(sqrt(max(nums))). The subsequent iterations over the numbers and factors have a time complexity of O(nsqrt(max(nums))). Overall, the time complexity is O(nsqrt(max(nums))).\\nSpace complexity: The space complexity is O(n) due to the storage of the factors and the factor count arrays.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nfunction findValidSplit(nums) {\\n  // Initialize a map to store factors and their corresponding indices\\n  const map = new Map();\\n  const n = nums.length;\\n\\n  // Function to generate prime numbers up to a given number\\n  const Eratosthenes = (n) => {\\n    const q = Array(n + 1).fill(0);\\n    const primes = [];\\n    for (let i = 2; i <= Math.sqrt(n); i++) {\\n      if (q[i] === 1) continue;\\n      let j = i * 2;\\n      while (j <= n) {\\n        q[j] = 1;\\n        j += i;\\n      }\\n    }\\n    for (let i = 2; i <= n; i++) {\\n      if (q[i] === 0) primes.push(i);\\n    }\\n    return primes;\\n  };\\n\\n  // Generate an array of prime numbers using Eratosthenes\\' sieve\\n  const primes = Eratosthenes(Math.max(...nums));\\n\\n  // Iterate over the numbers in the array\\n  for (let i = 0; i < n; i++) {\\n    let x = nums[i];\\n    // Iterate over the prime numbers\\n    for (const p of primes) {\\n      // Check if the number is divisible by the prime number\\n      if (p * p > x && x > 1) {\\n        // If the number is not divisible by any previous primes, add it to the map\\n        if (!map.has(x)) {\\n          map.set(x, [i, i]);\\n        }\\n        map.get(x)[1] = i;\\n        break;\\n      }\\n\\n      if (x % p === 0) {\\n        // If the number is divisible by the prime number, update the indices in the map\\n        if (!map.has(p)) {\\n          map.set(p, [i, i]);\\n        }\\n        const a = map.get(p);\\n        a[1] = i;\\n      }\\n      // Reduce the number by dividing it with the prime factor\\n      while (x % p === 0) x = x / p;\\n    }\\n  }\\n\\n  // Initialize an array to track the count of factors at each index\\n  const diff = Array(n + 1).fill(0);\\n  // Count the factors for each number in the map\\n  for (const [k, v] of map) {\\n    const [s, e] = v;\\n    diff[s] += 1;\\n    diff[e] -= 1;\\n  }\\n\\n  let sum = 0;\\n  // Iterate over the array to find the index of the valid split\\n  for (let i = 0; i < n - 1; i++) {\\n    sum += diff[i];\\n    if (sum === 0) return i;\\n  }\\n\\n  return -1;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nfunction findValidSplit(nums) {\\n  // Initialize a map to store factors and their corresponding indices\\n  const map = new Map();\\n  const n = nums.length;\\n\\n  // Function to generate prime numbers up to a given number\\n  const Eratosthenes = (n) => {\\n    const q = Array(n + 1).fill(0);\\n    const primes = [];\\n    for (let i = 2; i <= Math.sqrt(n); i++) {\\n      if (q[i] === 1) continue;\\n      let j = i * 2;\\n      while (j <= n) {\\n        q[j] = 1;\\n        j += i;\\n      }\\n    }\\n    for (let i = 2; i <= n; i++) {\\n      if (q[i] === 0) primes.push(i);\\n    }\\n    return primes;\\n  };\\n\\n  // Generate an array of prime numbers using Eratosthenes\\' sieve\\n  const primes = Eratosthenes(Math.max(...nums));\\n\\n  // Iterate over the numbers in the array\\n  for (let i = 0; i < n; i++) {\\n    let x = nums[i];\\n    // Iterate over the prime numbers\\n    for (const p of primes) {\\n      // Check if the number is divisible by the prime number\\n      if (p * p > x && x > 1) {\\n        // If the number is not divisible by any previous primes, add it to the map\\n        if (!map.has(x)) {\\n          map.set(x, [i, i]);\\n        }\\n        map.get(x)[1] = i;\\n        break;\\n      }\\n\\n      if (x % p === 0) {\\n        // If the number is divisible by the prime number, update the indices in the map\\n        if (!map.has(p)) {\\n          map.set(p, [i, i]);\\n        }\\n        const a = map.get(p);\\n        a[1] = i;\\n      }\\n      // Reduce the number by dividing it with the prime factor\\n      while (x % p === 0) x = x / p;\\n    }\\n  }\\n\\n  // Initialize an array to track the count of factors at each index\\n  const diff = Array(n + 1).fill(0);\\n  // Count the factors for each number in the map\\n  for (const [k, v] of map) {\\n    const [s, e] = v;\\n    diff[s] += 1;\\n    diff[e] -= 1;\\n  }\\n\\n  let sum = 0;\\n  // Iterate over the array to find the index of the valid split\\n  for (let i = 0; i < n - 1; i++) {\\n    sum += diff[i];\\n    if (sum === 0) return i;\\n  }\\n\\n  return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3465239,
                "title": "javascript-2584-split-the-array-to-make-coprime-products",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Simple product will time limit exceed\\n- Find factors for each number\\n    - use map\\n    - check left map element exists in right map\\n    - handle edge cases\\n    - optimize\\n\\n- Tests\\n[1]\\n[2,4,1,2,1,1]\\n[21,2]\\n[1,1,89]\\n[4,7,8,15,3,5]\\n[4,7,15,8,3,5]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1 - **Fail - Simple Product - Time Limit Exceeded**\\n\\n```\\nvar findValidSplit = function (a) {\\n    let n = a.length;\\n    let tp = 1n; // total product\\n    for (let i = 0; i < n; i++) {\\n        tp *= BigInt(a[i]);\\n    }\\n    let leftp = 1n; //  left product\\n    let rightp; //      right product\\n    for (let i = 0; i < n - 1; i++) {\\n        leftp *= BigInt(a[i]);\\n        rightp = tp / leftp;\\n        if (gcd(leftp, rightp) === 1n) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n};\\n\\n// ----\\n\\nfunction gcd(a, b) {\\n    while (b) {\\n        let t = b;\\n        b = a % b;\\n        a = t;\\n    }\\n    return a;\\n}\\n```\\n\\n2 - **Pass - Find factors, use map ...**\\n```\\nvar findValidSplit = function (a) {\\n    if (a.length === 1) return -1; //   edge case 1 - one number in array\\n    if (a[0] === 1) return 0; //        edge case 2 - starts with 1\\n\\n    let n = a.length;\\n    let fa = Array.from({ length: n }, () => new Array());\\n    for (let i = 0; i < n; i++) {\\n        fa[i] = factorsNot1(a[i]);\\n    }\\n\\n    let o = {};\\n    for (let i = 0; i < n; i++)\\n        for (let f of fa[i]) {\\n            o[f] = o[f] || 0;\\n            o[f]++;\\n        }\\n\\n    let ol = {};\\n    let prev_lfactors = [];\\n    for (let i = 0; i < n - 1; i++) {\\n        for (let f of fa[i]) {\\n            ol[f] = ol[f] || 0;\\n            ol[f]++;\\n\\n            o[f]--;\\n            if (!o[f]) delete o[f];\\n        }\\n\\n        // edge case 3 - right side all are 1\\n        if (a[a.length - 1] === 1)\\n            if (Object.keys(o).length === 1)\\n                for (let k in o)\\n                    if (k === \"1\") {\\n                        return i;\\n                    }\\n\\n        let found = false;\\n\\n        // optimization - check prev found factors first\\n        for (let lf of prev_lfactors)\\n            if (o[lf]) {\\n                found = true;\\n                break;\\n            }\\n\\n        if (!found)\\n            for (let lf in ol)\\n                if (o[lf]) {\\n                    found = true;\\n                    prev_lfactors.push(lf);\\n                    break;\\n                }\\n        if (!found) return i;\\n    }\\n    return -1;\\n};\\n\\n// ----\\n\\nfunction factorsNot1(n) {\\n    var factors = [];\\n    for (let f = 2; f <= Math.sqrt(n); ++f)\\n        if (n % f == 0) {\\n            factors.push(f);\\n            if (f !== n / f) {\\n                factors.push(n / f);\\n            }\\n        }\\n    factors.push(n);\\n    return factors\\n}\\n```\\n\\n3 - Clever solution, slow one\\n```\\nvar findValidSplit = function (a) {\\n    let pivotIndex = 0;\\n    for (let i = 0; i <= pivotIndex; i++)\\n        for (let j = pivotIndex + 1; j < a.length; j++)\\n            if (gcd(a[i], a[j]) !== 1) {\\n                pivotIndex = j; // not coprime numbers\\n            }\\n    if (pivotIndex === a.length - 1) {\\n        return -1;\\n    }\\n    return pivotIndex;\\n};\\nfunction gcd(a, b) {\\n    let t;\\n    while (b) (t = b), (b = a % b), (a = t);\\n    return a;\\n}\\n```\\n\\n4 - Clever solution - reverse, slow one\\n```\\nvar findValidSplit = function (a) {\\n    let pivotIndex = 0;\\n    for (let i = 0; i <= pivotIndex; ++i)\\n        for (let j = a.length - 1; j > pivotIndex; --j)\\n            if (gcd(a[i], a[j]) !== 1) {\\n                pivotIndex = j;\\n                break;\\n            }\\n    if (pivotIndex === a.length - 1) {\\n        return -1;\\n    }\\n    return pivotIndex;\\n};\\nfunction gcd(a, b) {\\n    let t;\\n    while (b) (t = b), (b = a % b), (a = t);\\n    return a;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findValidSplit = function (a) {\\n    let n = a.length;\\n    let tp = 1n; // total product\\n    for (let i = 0; i < n; i++) {\\n        tp *= BigInt(a[i]);\\n    }\\n    let leftp = 1n; //  left product\\n    let rightp; //      right product\\n    for (let i = 0; i < n - 1; i++) {\\n        leftp *= BigInt(a[i]);\\n        rightp = tp / leftp;\\n        if (gcd(leftp, rightp) === 1n) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n};\\n\\n// ----\\n\\nfunction gcd(a, b) {\\n    while (b) {\\n        let t = b;\\n        b = a % b;\\n        a = t;\\n    }\\n    return a;\\n}\\n```\n```\\nvar findValidSplit = function (a) {\\n    if (a.length === 1) return -1; //   edge case 1 - one number in array\\n    if (a[0] === 1) return 0; //        edge case 2 - starts with 1\\n\\n    let n = a.length;\\n    let fa = Array.from({ length: n }, () => new Array());\\n    for (let i = 0; i < n; i++) {\\n        fa[i] = factorsNot1(a[i]);\\n    }\\n\\n    let o = {};\\n    for (let i = 0; i < n; i++)\\n        for (let f of fa[i]) {\\n            o[f] = o[f] || 0;\\n            o[f]++;\\n        }\\n\\n    let ol = {};\\n    let prev_lfactors = [];\\n    for (let i = 0; i < n - 1; i++) {\\n        for (let f of fa[i]) {\\n            ol[f] = ol[f] || 0;\\n            ol[f]++;\\n\\n            o[f]--;\\n            if (!o[f]) delete o[f];\\n        }\\n\\n        // edge case 3 - right side all are 1\\n        if (a[a.length - 1] === 1)\\n            if (Object.keys(o).length === 1)\\n                for (let k in o)\\n                    if (k === \"1\") {\\n                        return i;\\n                    }\\n\\n        let found = false;\\n\\n        // optimization - check prev found factors first\\n        for (let lf of prev_lfactors)\\n            if (o[lf]) {\\n                found = true;\\n                break;\\n            }\\n\\n        if (!found)\\n            for (let lf in ol)\\n                if (o[lf]) {\\n                    found = true;\\n                    prev_lfactors.push(lf);\\n                    break;\\n                }\\n        if (!found) return i;\\n    }\\n    return -1;\\n};\\n\\n// ----\\n\\nfunction factorsNot1(n) {\\n    var factors = [];\\n    for (let f = 2; f <= Math.sqrt(n); ++f)\\n        if (n % f == 0) {\\n            factors.push(f);\\n            if (f !== n / f) {\\n                factors.push(n / f);\\n            }\\n        }\\n    factors.push(n);\\n    return factors\\n}\\n```\n```\\nvar findValidSplit = function (a) {\\n    let pivotIndex = 0;\\n    for (let i = 0; i <= pivotIndex; i++)\\n        for (let j = pivotIndex + 1; j < a.length; j++)\\n            if (gcd(a[i], a[j]) !== 1) {\\n                pivotIndex = j; // not coprime numbers\\n            }\\n    if (pivotIndex === a.length - 1) {\\n        return -1;\\n    }\\n    return pivotIndex;\\n};\\nfunction gcd(a, b) {\\n    let t;\\n    while (b) (t = b), (b = a % b), (a = t);\\n    return a;\\n}\\n```\n```\\nvar findValidSplit = function (a) {\\n    let pivotIndex = 0;\\n    for (let i = 0; i <= pivotIndex; ++i)\\n        for (let j = a.length - 1; j > pivotIndex; --j)\\n            if (gcd(a[i], a[j]) !== 1) {\\n                pivotIndex = j;\\n                break;\\n            }\\n    if (pivotIndex === a.length - 1) {\\n        return -1;\\n    }\\n    return pivotIndex;\\n};\\nfunction gcd(a, b) {\\n    let t;\\n    while (b) (t = b), (b = a % b), (a = t);\\n    return a;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3463955,
                "title": "python-factorize-compute-range-check-containment-beats-78-7",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCo-prime means no common (prime) factors between the numbers. Which means gcd(x, y) = 1. So if we start picking from left side, find the first co-prime, make sure anything on the right of it are all co-primes we\\'re done. But that\\'s O(n^2) and too much computation, and will TLE.\\n\\nSo we find the range of each number - which is leftmost co-prime and rightmodt co-prime. Once we calculate that, start from the left, check the rightmost co-prime (marker), then keep going right and if any number has leftmost co-prime before the marker, move the marker to this point and continue the exercise. If the marker falls off the edge, it\\'s impossible.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn the first pass, factorise each number, and for each factor update the leftmost and rightmost indices the factor is seen.\\n\\nIn the second pass, for each number look at leftmosts of all its factors and rightmosts of all its factors, this min(leftmost), max(rightmost) gives us the range of each number.\\n\\nIn the third pass, start from rightmost of first number and keep checking their leftmost, if they are greater ignore them, but if lesser they has to be part of left partition to move the marker and keep going, till we reach the end. If the marker is at the end too, return -1.\\n\\n# Complexity\\n- Time complexity: O(n\\u221An), three passes, one goes over the factors\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n), fixed number of primes (168), and for each number we store an additional tuple\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\nShort version that does TLE\\n```python []\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        @lru_cache\\n        def gcd(x, y):\\n            while y:\\n                x, y = y, x % y\\n            return x\\n        li = 0\\n        for ix, n in enumerate(nums):\\n            for i in range(len(nums)-1, li,-1):\\n                if gcd(n, nums[i]) != 1:\\n                    li = max(li, i)\\n                    break\\n            if li == len(nums) - 1: return -1\\n            if li == ix:\\n                break\\n        return li\\n```\\nLonger version passes and beats 78.7%\\n\\n\\n\\n```python []\\nclass Solution:\\n    primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,]\\n\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        dr = (len(nums), -1)\\n        f_table = {}\\n\\n        @lru_cache\\n        def factors(n):\\n            f = []\\n            if n == 1:  return [1]\\n            for p in self.primes:\\n                if p > n: break\\n                if n % p: continue\\n                while n % p == 0: n //= p\\n                f.append(p)\\n            else:\\n                return f + [n]\\n            return f\\n\\n        if len(nums) <= 1: return -1\\n        if nums[0] == 1: return 0\\n        for ix, n in enumerate(nums):\\n            for f in factors(n):\\n                mn,mx = f_table.get(f, dr)\\n                f_table[f] = (min(ix,mn), max(mx,ix))\\n        for ix, n in enumerate(nums):\\n            mn = min([f_table[x][0] for x in factors(n)])\\n            mx = max([f_table[x][1] for x in factors(n)])\\n            nums[ix] = (n, mn, mx) if n != 1 else (n, ix, ix)\\n        li = nums[0][2]\\n        i = li + 1\\n        while i < len(nums):\\n            if nums[i][1] > li: \\n                i += 1\\n                continue\\n            li = nums[i][2]\\n            if li == len(nums)-1: break\\n            i = li + 1\\n        return li if li < len(nums)-1 else -1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        @lru_cache\\n        def gcd(x, y):\\n            while y:\\n                x, y = y, x % y\\n            return x\\n        li = 0\\n        for ix, n in enumerate(nums):\\n            for i in range(len(nums)-1, li,-1):\\n                if gcd(n, nums[i]) != 1:\\n                    li = max(li, i)\\n                    break\\n            if li == len(nums) - 1: return -1\\n            if li == ix:\\n                break\\n        return li\\n```\n```python []\\nclass Solution:\\n    primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,]\\n\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        dr = (len(nums), -1)\\n        f_table = {}\\n\\n        @lru_cache\\n        def factors(n):\\n            f = []\\n            if n == 1:  return [1]\\n            for p in self.primes:\\n                if p > n: break\\n                if n % p: continue\\n                while n % p == 0: n //= p\\n                f.append(p)\\n            else:\\n                return f + [n]\\n            return f\\n\\n        if len(nums) <= 1: return -1\\n        if nums[0] == 1: return 0\\n        for ix, n in enumerate(nums):\\n            for f in factors(n):\\n                mn,mx = f_table.get(f, dr)\\n                f_table[f] = (min(ix,mn), max(mx,ix))\\n        for ix, n in enumerate(nums):\\n            mn = min([f_table[x][0] for x in factors(n)])\\n            mx = max([f_table[x][1] for x in factors(n)])\\n            nums[ix] = (n, mn, mx) if n != 1 else (n, ix, ix)\\n        li = nums[0][2]\\n        i = li + 1\\n        while i < len(nums):\\n            if nums[i][1] > li: \\n                i += 1\\n                continue\\n            li = nums[i][2]\\n            if li == len(nums)-1: break\\n            i = li + 1\\n        return li if li < len(nums)-1 else -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450791,
                "title": "python-3-prime-factorization",
                "content": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def getPrimeDivs(n):\\n            res = set()\\n            \\n            for i in range(2, isqrt(n) + 1):\\n                while n % i == 0:\\n                    res.add(i)\\n                    n //= i\\n            \\n            if n > 1: res.add(n)\\n            return res\\n        \\n        primes = []\\n        for i in nums:\\n            primes.append(getPrimeDivs(i))\\n        \\n        f = Counter()\\n        b = Counter()\\n        \\n        for p in primes:\\n            for i in p:\\n                b[i] += 1\\n        \\n        for idx in range(len(nums) - 1):\\n            for i in primes[idx]:\\n                f[i] += 1\\n                b[i] -= 1\\n                if b[i] == 0:\\n                    b.pop(i)\\n                \\n            if not(any(z in b for z in f)):\\n                return idx\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def getPrimeDivs(n):\\n            res = set()\\n            \\n            for i in range(2, isqrt(n) + 1):\\n                while n % i == 0:\\n                    res.add(i)\\n                    n //= i\\n            \\n            if n > 1: res.add(n)\\n            return res\\n        \\n        primes = []\\n        for i in nums:\\n            primes.append(getPrimeDivs(i))\\n        \\n        f = Counter()\\n        b = Counter()\\n        \\n        for p in primes:\\n            for i in p:\\n                b[i] += 1\\n        \\n        for idx in range(len(nums) - 1):\\n            for i in primes[idx]:\\n                f[i] += 1\\n                b[i] -= 1\\n                if b[i] == 0:\\n                    b.pop(i)\\n                \\n            if not(any(z in b for z in f)):\\n                return idx\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339655,
                "title": "simple-solution-easy-to-understand-well-commented",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> seive;\\n    \\n    void primeSeive(){\\n\\n        seive.resize(1e6+1);\\n        iota(seive.begin(), seive.end(), 0);\\n        \\n        // Find one prime factor of i         \\n        for(int i=2;i*i<seive.size();i++){\\n            if(seive[i]==i){\\n            for(int j=i*i;j<seive.size();j+=i)\\n                seive[j]=i;        \\n            }\\n        }\\n    }\\n    \\n    vector<int> factorize(int num){\\n\\n        // Finding unique prime factors\\n        vector<int> factor;\\n        while(num!=1){\\n            factor.push_back(seive[num]);\\n            int x=seive[num];\\n            while(num%x==0){\\n                num/=x;  \\n            }\\n        }\\n        return factor;\\n    }\\n    \\n    int findValidSplit(vector<int>& nums) {    \\n        primeSeive();\\n        unordered_map<int,int> lastDetected;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            vector<int> factors=factorize(nums[i]);\\n            // Generating last detected for each factor\\n            for(auto it:factors)\\n                lastDetected[it]=i;\\n            }\\n        \\n        int maxIdx=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            vector<int> factors=factorize(nums[i]);\\n            // Calculating last detected for each prime factor detected so far\\n            // and if maxIdx is greater than i, \\n            // means gcd(leftSide,rightSide)\\u22601 else equal to 1\\n            for(auto it:factors){\\n                maxIdx=max(maxIdx,lastDetected[it]);\\n            }\\n            if(maxIdx<=i)\\n                return i;\\n        }\\n     return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> seive;\\n    \\n    void primeSeive(){\\n\\n        seive.resize(1e6+1);\\n        iota(seive.begin(), seive.end(), 0);\\n        \\n        // Find one prime factor of i         \\n        for(int i=2;i*i<seive.size();i++){\\n            if(seive[i]==i){\\n            for(int j=i*i;j<seive.size();j+=i)\\n                seive[j]=i;        \\n            }\\n        }\\n    }\\n    \\n    vector<int> factorize(int num){\\n\\n        // Finding unique prime factors\\n        vector<int> factor;\\n        while(num!=1){\\n            factor.push_back(seive[num]);\\n            int x=seive[num];\\n            while(num%x==0){\\n                num/=x;  \\n            }\\n        }\\n        return factor;\\n    }\\n    \\n    int findValidSplit(vector<int>& nums) {    \\n        primeSeive();\\n        unordered_map<int,int> lastDetected;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            vector<int> factors=factorize(nums[i]);\\n            // Generating last detected for each factor\\n            for(auto it:factors)\\n                lastDetected[it]=i;\\n            }\\n        \\n        int maxIdx=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            vector<int> factors=factorize(nums[i]);\\n            // Calculating last detected for each prime factor detected so far\\n            // and if maxIdx is greater than i, \\n            // means gcd(leftSide,rightSide)\\u22601 else equal to 1\\n            for(auto it:factors){\\n                maxIdx=max(maxIdx,lastDetected[it]);\\n            }\\n            if(maxIdx<=i)\\n                return i;\\n        }\\n     return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337793,
                "title": "python3-easy-o-n-time-o-1-space-two-pointers-8-lines",
                "content": "# Solution\\n```python\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        product, coprimes = prod(nums), 0\\n        for i in range(len(nums)-1):\\n            product //= nums[i]\\n            while coprimes <= i and gcd(nums[coprimes], product) == 1:\\n                coprimes += 1\\n            if coprimes == i + 1:\\n                return i\\n        return -1\\n```\\n\\n# Some extra improvements\\nI also found that you can get a nice speed up for certain edge cases with this, improves leetcode submission time handsomely:\\n```python\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        if reduce(gcd, nums) > 1:\\n            return -1\\n        product, coprimes = prod(nums), 0\\n        for i in range(len(nums)-1):\\n            product //= nums[i]\\n            while coprimes <= i and gcd(nums[coprimes], product) == 1:\\n                coprimes += 1\\n            if coprimes == i + 1:\\n                return i\\n        return -1\\n```\\n\\nIn an attempt to calculate the product more gradually and only when necessary, I wrote this alternative implementation which performs well:\\n```python\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        product, coprimes, multiplied = 1, 0, 0\\n        for i in range(len(nums)-1):\\n            while multiplied <= i:\\n                product *= nums[multiplied]\\n                multiplied += 1\\n            product //= nums[i]\\n            while gcd(nums[coprimes], product) == 1 and multiplied < len(nums):\\n                product *= nums[multiplied]\\n                multiplied += 1\\n            while coprimes <= i and gcd(nums[coprimes], product) == 1:\\n                coprimes += 1\\n            if coprimes == i + 1:\\n                return i\\n        return -1\\n```\\n\\n# My work\\n\\nHere\\'s my journey to dumbing my way into a valid solution. No intentional math except a random observation made while testing my code.\\n\\nI started here, brute force! Time limit exceeded after 29/75 cases.\\n```python\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        p = prod(nums)\\n        e = []\\n        for i, n in enumerate(nums[:-1]):\\n            p //= n\\n            e.append(n)\\n            if all(gcd(x, p) == 1 for x in e):\\n                return i\\n        return -1\\n```\\n\\nI noticed that once gcd(n, p) == 1, that same n was never not coprime for whatever future value of p existed -- that is, further dividing p didn\\'t change the fact that gcd(n, p) == 1. Which probably makes sense if you think about it but I won\\'t.\\n\\nThat lead me to this, 75/75 cases but time limit exceeded?\\n```python\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        p = prod(nums)\\n        e = set()\\n        for i, n in enumerate(nums[:-1]):\\n            p //= n\\n            if gcd(n, p) != 1:\\n                e.add(n)\\n            else:\\n                e = {x for x in e if gcd(x, p) != 1}\\n                if not e:\\n                    return i\\n        return -1\\n```\\n\\nI figured I was wasting a lot of computation going through lots of negative cases. That is, I imagined if there was a situation where the majority of values x in e had gcd(x, p) != 1, checking that every iteration is a lot of wasted computation. Therefore, I switched it up to break immediately as soon as even a single value didn\\'t pass that check. Any value that had passed that check would get removed. \\n\\nSince each value either gets removed (no longer adds to the computation of future loops) or causes a break, each loop performs an (amortized) constant amount of work, making the whole algorithm O(n)!\\n\\n```python\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        p = prod(nums)\\n        e = set()\\n        for i, n in enumerate(nums[:-1]):\\n            p //= n\\n            if gcd(n, p) != 1:\\n                e.add(n)\\n            else:\\n                removing = set()\\n                for x in e:\\n                    if gcd(x, p) == 1:\\n                        removing.add(x)\\n                    else:\\n                        break\\n                else:\\n                    return i\\n                e.difference_update(removing)\\n        return -1\\n```\\n\\nAll done without knowing any math :)\\n\\nBut let\\'s clean that up a bit more with itertools:\\n\\n```python\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        p = prod(nums)\\n        e = set()\\n        for i, n in enumerate(nums[:-1]):\\n            p //= n\\n            if gcd(n, p) != 1:\\n                e.add(n)\\n            else:\\n                removing = set(takewhile(lambda x: gcd(x, p) == 1, e))\\n                if len(removing) == len(e):\\n                    return i\\n                e.difference_update(removing)\\n        return -1\\n```\\n\\nBut, let\\'s conserve on memory by using an array instead of a set and an integer to trim values off the end\\n\\n```python\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        p = prod(nums)\\n        e = []\\n        for i, n in enumerate(nums[:-1]):\\n            p //= n\\n            e.append(n)\\n            removing = sum(1 for _ in takewhile(lambda x: gcd(x, p) == 1, e))\\n            if removing == len(e):\\n                return i\\n            elif removing != 0:\\n                e = e[removing:]\\n        return -1\\n```\\n\\nWait, can\\'t we just use constant memory with two pointers?\\n\\n```python\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        p = prod(nums)\\n        j = 0\\n        for i, n in enumerate(nums[:-1]):\\n            p //= n\\n            for k in range(j, i+1):\\n                if gcd(nums[k], p) == 1:\\n                    j += 1\\n                else:\\n                    break\\n            else:\\n                return i\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        product, coprimes = prod(nums), 0\\n        for i in range(len(nums)-1):\\n            product //= nums[i]\\n            while coprimes <= i and gcd(nums[coprimes], product) == 1:\\n                coprimes += 1\\n            if coprimes == i + 1:\\n                return i\\n        return -1\\n```\n```python\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        if reduce(gcd, nums) > 1:\\n            return -1\\n        product, coprimes = prod(nums), 0\\n        for i in range(len(nums)-1):\\n            product //= nums[i]\\n            while coprimes <= i and gcd(nums[coprimes], product) == 1:\\n                coprimes += 1\\n            if coprimes == i + 1:\\n                return i\\n        return -1\\n```\n```python\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        product, coprimes, multiplied = 1, 0, 0\\n        for i in range(len(nums)-1):\\n            while multiplied <= i:\\n                product *= nums[multiplied]\\n                multiplied += 1\\n            product //= nums[i]\\n            while gcd(nums[coprimes], product) == 1 and multiplied < len(nums):\\n                product *= nums[multiplied]\\n                multiplied += 1\\n            while coprimes <= i and gcd(nums[coprimes], product) == 1:\\n                coprimes += 1\\n            if coprimes == i + 1:\\n                return i\\n        return -1\\n```\n```python\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        p = prod(nums)\\n        e = []\\n        for i, n in enumerate(nums[:-1]):\\n            p //= n\\n            e.append(n)\\n            if all(gcd(x, p) == 1 for x in e):\\n                return i\\n        return -1\\n```\n```python\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        p = prod(nums)\\n        e = set()\\n        for i, n in enumerate(nums[:-1]):\\n            p //= n\\n            if gcd(n, p) != 1:\\n                e.add(n)\\n            else:\\n                e = {x for x in e if gcd(x, p) != 1}\\n                if not e:\\n                    return i\\n        return -1\\n```\n```python\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        p = prod(nums)\\n        e = set()\\n        for i, n in enumerate(nums[:-1]):\\n            p //= n\\n            if gcd(n, p) != 1:\\n                e.add(n)\\n            else:\\n                removing = set()\\n                for x in e:\\n                    if gcd(x, p) == 1:\\n                        removing.add(x)\\n                    else:\\n                        break\\n                else:\\n                    return i\\n                e.difference_update(removing)\\n        return -1\\n```\n```python\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        p = prod(nums)\\n        e = set()\\n        for i, n in enumerate(nums[:-1]):\\n            p //= n\\n            if gcd(n, p) != 1:\\n                e.add(n)\\n            else:\\n                removing = set(takewhile(lambda x: gcd(x, p) == 1, e))\\n                if len(removing) == len(e):\\n                    return i\\n                e.difference_update(removing)\\n        return -1\\n```\n```python\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        p = prod(nums)\\n        e = []\\n        for i, n in enumerate(nums[:-1]):\\n            p //= n\\n            e.append(n)\\n            removing = sum(1 for _ in takewhile(lambda x: gcd(x, p) == 1, e))\\n            if removing == len(e):\\n                return i\\n            elif removing != 0:\\n                e = e[removing:]\\n        return -1\\n```\n```python\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        p = prod(nums)\\n        j = 0\\n        for i, n in enumerate(nums[:-1]):\\n            p //= n\\n            for k in range(j, i+1):\\n                if gcd(nums[k], p) == 1:\\n                    j += 1\\n                else:\\n                    break\\n            else:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335080,
                "title": "clean-code-with-comments-spf-o-nlogn-time-precompute-explained",
                "content": "# Idea\\n1. Do a Seive for SPF (Shorest Prime Factor)\\n2. SPF[NUM] = Shorstest Prime fac.\\n3. With this you can factorize in Log N (OPS = Val = Val/SPF[NUM]), get all prime factors\\n4. Run a loop for all nums and factorize it, and lastIdx[p] = i;\\n5. So that at the end we have the hashing of prime to last index\\n6. Then move on with the real calc.\\n7. Have Boundary and i, make sure i doesnt cross boundary. When it crosses, its ur ans. As we have grouped\\n8. Now for every prime factor of nums[i], just take the lastidx[p] as boundary.\\n9. Note if p1 has boundary of 8 and p2 has boundary of 5. p1,p2 are primefactors of a num. Then u pick the max guy. That is 8. As to satisfy we need to pick till 8.\\n10. We go on and on. At end if boundary is >= N-2, not possible to cut, so return -1. Else return the boundary.\\n\\n\\n# Complexity\\n- Time complexity:$$O(NLogLogN + NLogN)$$\\n- Seive for SPF \\n- Every num, we factorize\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1e6+1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\nprivate:\\nvector<int> spf;\\nvector<int> lastIdx;\\nint MaxS = 1e6+1;\\n\\n//O(N+ NloglogN) = same as seive\\nvoid myspf(){\\n    spf.resize(MaxS);\\n    int N = MaxS;\\n\\n    //O(N)\\n    //init with spf[i] = i. Assume all are prime\\n    for(int i=2; i<N; i++){\\n        spf[i] = i;\\n    }\\n\\n    //as we are getting TLE, we can mark 2\\'s muls alone first\\n    for(int i=2; i<N; i+=2){\\n        spf[i] = 2;\\n    }\\n    //NLogLogN\\n    for(int i=3; i*i<N; i++){\\n        if(spf[i] == i){\\n            //prime\\n            for(int j=i*i; j<N; j=j+i){\\n                if(spf[j]==j){\\n                    //unmarked by prev primes - fresh guy\\n                    spf[j] = i;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nvector<int> myUniqueFacs(int val){\\n    vector<int> ans;\\n    while(val!=1){\\n        ans.push_back(spf[val]); //unique primes\\n        val = val/ spf[val];\\n    }\\n    return ans;\\n}\\n\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int N = nums.size();\\n        if(N == 1)\\n            return -1;\\n        \\n        myspf();\\n\\n        lastIdx.resize(MaxS);\\n        lastIdx[1] = -1;\\n\\n        for(int i=0; i<N; i++){\\n            vector<int> primes = myUniqueFacs(nums[i]);\\n            for(int p : primes){\\n                lastIdx[p] = i;\\n            }\\n        }\\n\\n        int i=0; \\n        int bound = 0;\\n\\n        while(i<=bound){\\n            //cout<<i<<\" \";\\n            vector<int> primes = myUniqueFacs(nums[i]);\\n            for(int p : primes){\\n                bound = max(bound, lastIdx[p]);\\n            }\\n            i++;\\n        }\\n        //cout<<\"\\\\n\";\\n\\n        if(bound <= N-2)\\n            return bound;\\n\\n        return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\nvector<int> spf;\\nvector<int> lastIdx;\\nint MaxS = 1e6+1;\\n\\n//O(N+ NloglogN) = same as seive\\nvoid myspf(){\\n    spf.resize(MaxS);\\n    int N = MaxS;\\n\\n    //O(N)\\n    //init with spf[i] = i. Assume all are prime\\n    for(int i=2; i<N; i++){\\n        spf[i] = i;\\n    }\\n\\n    //as we are getting TLE, we can mark 2\\'s muls alone first\\n    for(int i=2; i<N; i+=2){\\n        spf[i] = 2;\\n    }\\n    //NLogLogN\\n    for(int i=3; i*i<N; i++){\\n        if(spf[i] == i){\\n            //prime\\n            for(int j=i*i; j<N; j=j+i){\\n                if(spf[j]==j){\\n                    //unmarked by prev primes - fresh guy\\n                    spf[j] = i;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nvector<int> myUniqueFacs(int val){\\n    vector<int> ans;\\n    while(val!=1){\\n        ans.push_back(spf[val]); //unique primes\\n        val = val/ spf[val];\\n    }\\n    return ans;\\n}\\n\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int N = nums.size();\\n        if(N == 1)\\n            return -1;\\n        \\n        myspf();\\n\\n        lastIdx.resize(MaxS);\\n        lastIdx[1] = -1;\\n\\n        for(int i=0; i<N; i++){\\n            vector<int> primes = myUniqueFacs(nums[i]);\\n            for(int p : primes){\\n                lastIdx[p] = i;\\n            }\\n        }\\n\\n        int i=0; \\n        int bound = 0;\\n\\n        while(i<=bound){\\n            //cout<<i<<\" \";\\n            vector<int> primes = myUniqueFacs(nums[i]);\\n            for(int p : primes){\\n                bound = max(bound, lastIdx[p]);\\n            }\\n            i++;\\n        }\\n        //cout<<\"\\\\n\";\\n\\n        if(bound <= N-2)\\n            return bound;\\n\\n        return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3313727,
                "title": "python-different",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGeneral idea is that we need to find a split where the left and right sides have no prime factors in common. we do this by keeping a variable - inCommon, and iterating through the list.\\n\\n# Code\\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return -1\\n\\n        def sieve(num):\\n            ret = {}\\n            for div in range(2, int(num**0.5)+1):\\n                while num % div == 0:\\n                    if div not in ret:\\n                        ret[div] = 0\\n                    ret[div] += 1\\n                    num //= div\\n            if num != 1:\\n                ret[num] = 1\\n            return ret\\n\\n        # we start by factorizing each number\\n        factorizations = [sieve(num) for num in nums]\\n        # we want to keep track of all the prime factors on the left and right of the current split, as well as how many factors they have in common. start split between index 0 and 1.\\n        leftPrimeFactors = factorizations[0].copy()\\n        rightPrimeFactors = {}\\n        for i in range(1, len(nums)):\\n            for k in factorizations[i]:\\n                if k not in rightPrimeFactors:\\n                    rightPrimeFactors[k] = 0\\n                rightPrimeFactors[k] += factorizations[i][k]\\n        inCommon = 0\\n        for k in leftPrimeFactors:\\n            if k in rightPrimeFactors:\\n                inCommon += 1\\n\\n        # if the first split works, return it.\\n        if inCommon == 0:\\n            return 0\\n        \\n        for i in range(1, len(nums)-1):\\n            fac = factorizations[i]\\n            for k in fac:\\n                rightPrimeFactors[k] -= fac[k]\\n                if rightPrimeFactors[k] == 0:\\n                    # if removing this number from the right side causes an existing common prime factor to dissappear, inCommon decrements.\\n                    if k in leftPrimeFactors:\\n                        inCommon -= 1\\n                    del rightPrimeFactors[k]\\n                if k not in leftPrimeFactors:\\n                    # if adding this number to the left side causes a common prime factor to appear, inCommon increments.\\n                    if k in rightPrimeFactors:\\n                        inCommon += 1\\n                    leftPrimeFactors[k] = 0\\n                leftPrimeFactors[k] += fac[k]\\n            # return the earliest index that works\\n            if not inCommon:\\n                return i\\n            \\n        return -1\\n            \\n                \\n                                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return -1\\n\\n        def sieve(num):\\n            ret = {}\\n            for div in range(2, int(num**0.5)+1):\\n                while num % div == 0:\\n                    if div not in ret:\\n                        ret[div] = 0\\n                    ret[div] += 1\\n                    num //= div\\n            if num != 1:\\n                ret[num] = 1\\n            return ret\\n\\n        # we start by factorizing each number\\n        factorizations = [sieve(num) for num in nums]\\n        # we want to keep track of all the prime factors on the left and right of the current split, as well as how many factors they have in common. start split between index 0 and 1.\\n        leftPrimeFactors = factorizations[0].copy()\\n        rightPrimeFactors = {}\\n        for i in range(1, len(nums)):\\n            for k in factorizations[i]:\\n                if k not in rightPrimeFactors:\\n                    rightPrimeFactors[k] = 0\\n                rightPrimeFactors[k] += factorizations[i][k]\\n        inCommon = 0\\n        for k in leftPrimeFactors:\\n            if k in rightPrimeFactors:\\n                inCommon += 1\\n\\n        # if the first split works, return it.\\n        if inCommon == 0:\\n            return 0\\n        \\n        for i in range(1, len(nums)-1):\\n            fac = factorizations[i]\\n            for k in fac:\\n                rightPrimeFactors[k] -= fac[k]\\n                if rightPrimeFactors[k] == 0:\\n                    # if removing this number from the right side causes an existing common prime factor to dissappear, inCommon decrements.\\n                    if k in leftPrimeFactors:\\n                        inCommon -= 1\\n                    del rightPrimeFactors[k]\\n                if k not in leftPrimeFactors:\\n                    # if adding this number to the left side causes a common prime factor to appear, inCommon increments.\\n                    if k in rightPrimeFactors:\\n                        inCommon += 1\\n                    leftPrimeFactors[k] = 0\\n                leftPrimeFactors[k] += fac[k]\\n            # return the earliest index that works\\n            if not inCommon:\\n                return i\\n            \\n        return -1\\n            \\n                \\n                                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297588,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(10^6)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> prime(int n){\\n        vector<int>ans;\\n        while(n%2 == 0){\\n            ans.push_back(2);\\n            n=n/2;\\n        }\\n        \\n        for(int i=3;i<=sqrt(n);i= i+2){\\n            if(n%i == 0){\\n                ans.push_back(i);\\n                n=n/i;\\n            }\\n        }\\n        \\n        if(n>2){\\n            ans.push_back(n);\\n        }\\n        return ans;\\n    }\\n    int findValidSplit(vector<int>& nums){\\n        int n=nums.size();\\n        long long N= pow(10,6)+1;\\n        \\n        vector<int>last_factor_index(N,0);\\n        \\n        for(int i=0;i<n;i++){\\n            \\n         vector<int>pf=prime(nums[i]);\\n            \\n            for(auto t:pf){\\n                last_factor_index[t]=i;\\n            }\\n            \\n            \\n        }\\n        \\n       // cout<<(last_factor_index[5])<<\" \"<<endl;\\n        \\n        int it=0;\\n        int res=0;\\n        \\n        while(it<=res){\\n\\n            vector<int>pf=prime(nums[it]);\\n            \\n            for(auto t:pf){\\n                res=max(last_factor_index[t],res);\\n            }\\n            \\n                it++;   \\n              \\n        }\\n        \\n        if(it == n){\\n            return -1;\\n        }\\n        else return it-1;\\n    }\\n    \\n    };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> prime(int n){\\n        vector<int>ans;\\n        while(n%2 == 0){\\n            ans.push_back(2);\\n            n=n/2;\\n        }\\n        \\n        for(int i=3;i<=sqrt(n);i= i+2){\\n            if(n%i == 0){\\n                ans.push_back(i);\\n                n=n/i;\\n            }\\n        }\\n        \\n        if(n>2){\\n            ans.push_back(n);\\n        }\\n        return ans;\\n    }\\n    int findValidSplit(vector<int>& nums){\\n        int n=nums.size();\\n        long long N= pow(10,6)+1;\\n        \\n        vector<int>last_factor_index(N,0);\\n        \\n        for(int i=0;i<n;i++){\\n            \\n         vector<int>pf=prime(nums[i]);\\n            \\n            for(auto t:pf){\\n                last_factor_index[t]=i;\\n            }\\n            \\n            \\n        }\\n        \\n       // cout<<(last_factor_index[5])<<\" \"<<endl;\\n        \\n        int it=0;\\n        int res=0;\\n        \\n        while(it<=res){\\n\\n            vector<int>pf=prime(nums[it]);\\n            \\n            for(auto t:pf){\\n                res=max(last_factor_index[t],res);\\n            }\\n            \\n                it++;   \\n              \\n        }\\n        \\n        if(it == n){\\n            return -1;\\n        }\\n        else return it-1;\\n    }\\n    \\n    };\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3285792,
                "title": "prime-factorization-o-n-sqrt-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n`[4,7,8,15,3,5]`\\n\\nNow you are at the starting index. PrimeFactors of 4 is `2,2`.\\nfor all the prime factors of `4` we will check the right most index that has the same primeFactor. Now till that index we are sure that we we have common factors from start to that index. So for all the indexes in that left part, we try to find the last index that has common factors and extend the left part. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:O(n * sqrt(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        \\n        # returns all prime factors of that number\\n        def yieldPrime(n): # O(sqrt(n))\\n\\n            p = 2\\n            while n % p == 0: # means prime factor of number\\n                yield p\\n                n //= p\\n            \\n            p = 3 \\n            while p * p  <= n: # all prime factors are going till square of that number\\n                while n % p == 0:\\n                    yield p\\n                    n //= p\\n                p += 2 # only odd numbers\\n            \\n            # if prime number itself, eg n = 5\\n            if n > 1:\\n                yield n\\n        \\n        # stores last positions of all the prime factors in the nums array       \\n        lastPositionOfPrimeInNums = {}\\n\\n        for index, n in enumerate(nums): #O(n)\\n            for p in yieldPrime(n): #O(sqrt(n))\\n                lastPositionOfPrimeInNums[p] = index\\n        \\n\\n\\n        lp = 0 # left index start\\n        maxLeft = 0 # max index of left subpart\\n\\n        while lp <= maxLeft: # O(n)\\n            val = nums[lp]\\n\\n            for p in yieldPrime(val): # O(sqrt(n))\\n                maxLeft = max(maxLeft, lastPositionOfPrimeInNums[p])\\n            \\n            lp += 1 # we are done with this index\\n        \\n        if lp == len(nums): return -1\\n        return lp - 1\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        \\n        # returns all prime factors of that number\\n        def yieldPrime(n): # O(sqrt(n))\\n\\n            p = 2\\n            while n % p == 0: # means prime factor of number\\n                yield p\\n                n //= p\\n            \\n            p = 3 \\n            while p * p  <= n: # all prime factors are going till square of that number\\n                while n % p == 0:\\n                    yield p\\n                    n //= p\\n                p += 2 # only odd numbers\\n            \\n            # if prime number itself, eg n = 5\\n            if n > 1:\\n                yield n\\n        \\n        # stores last positions of all the prime factors in the nums array       \\n        lastPositionOfPrimeInNums = {}\\n\\n        for index, n in enumerate(nums): #O(n)\\n            for p in yieldPrime(n): #O(sqrt(n))\\n                lastPositionOfPrimeInNums[p] = index\\n        \\n\\n\\n        lp = 0 # left index start\\n        maxLeft = 0 # max index of left subpart\\n\\n        while lp <= maxLeft: # O(n)\\n            val = nums[lp]\\n\\n            for p in yieldPrime(val): # O(sqrt(n))\\n                maxLeft = max(maxLeft, lastPositionOfPrimeInNums[p])\\n            \\n            lp += 1 # we are done with this index\\n        \\n        if lp == len(nums): return -1\\n        return lp - 1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284735,
                "title": "sieve-prime-factorization-python",
                "content": "# Intuition\\nPrime Factorization\\n\\n# Approach\\nFInd primes factors for all numbers.\\nThen keep 2 windows left and right for maintaining sum of all primes factors in left and right side.\\nNow run a simple loop from i=0 to n-2 and whenever both maps have NULL key intersecton return zero.\\n# Complexity\\n- Time complexity:\\nO(max*log(log(max)))+O(n*log(max))  \\n- Space complexity:\\nO(max)\\nwhere max is of order 10^6\\n# Code\\n```\\nMAXN = 10**6+5\\nspf = [0 for i in range(MAXN)]\\ndef sieve():\\n    spf[1] = 1\\n    for i in range(2, MAXN):\\n        spf[i] = i\\n    for i in range(4, MAXN, 2):\\n        spf[i] = 2\\n \\n    for i in range(3, ceil(sqrt(MAXN))):\\n        if (spf[i] == i):\\n            for j in range(i * i, MAXN, i):\\n                if (spf[j] == j):\\n                    spf[j] = i\\nsieve()\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        def getFac(x):\\n            ret = set()\\n            while (x != 1):\\n                ret.add(spf[x])\\n                x = x // spf[x]\\n            return ret\\n        n=len(nums)\\n        gg=[]\\n        def okay():\\n            for c in left:\\n                if c in right: return False\\n            return True\\n        for num in nums:\\n            gg.append(getFac(num))\\n        left,right={},{}\\n        for i in range(n):\\n            for c in gg[i]: \\n                if c not in right: right[c]=0\\n                right[c]+=1\\n        for i in range(n-1):\\n            for c in gg[i]:\\n                if c not in left: left[c]=0\\n                right[c]-=1\\n                if right[c]==0: del right[c]\\n            if okay(): return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nMAXN = 10**6+5\\nspf = [0 for i in range(MAXN)]\\ndef sieve():\\n    spf[1] = 1\\n    for i in range(2, MAXN):\\n        spf[i] = i\\n    for i in range(4, MAXN, 2):\\n        spf[i] = 2\\n \\n    for i in range(3, ceil(sqrt(MAXN))):\\n        if (spf[i] == i):\\n            for j in range(i * i, MAXN, i):\\n                if (spf[j] == j):\\n                    spf[j] = i\\nsieve()\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        def getFac(x):\\n            ret = set()\\n            while (x != 1):\\n                ret.add(spf[x])\\n                x = x // spf[x]\\n            return ret\\n        n=len(nums)\\n        gg=[]\\n        def okay():\\n            for c in left:\\n                if c in right: return False\\n            return True\\n        for num in nums:\\n            gg.append(getFac(num))\\n        left,right={},{}\\n        for i in range(n):\\n            for c in gg[i]: \\n                if c not in right: right[c]=0\\n                right[c]+=1\\n        for i in range(n-1):\\n            for c in gg[i]:\\n                if c not in left: left[c]=0\\n                right[c]-=1\\n                if right[c]==0: del right[c]\\n            if okay(): return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284467,
                "title": "python-solution-using-sieve-of-eratosthenes-and-least-prime-factor",
                "content": "```\\n# combining seive with least common factor \\nprime = [1]*(10**6+2)\\nupto = 10**6+2\\nprime[0]=prime[1] = 0\\nlcf = [0]*(10**6+2)\\nfor i in range(2,upto):\\n    if prime[i]:\\n        for j in range(2*i,upto,i):\\n            prime[j] = 0\\n            if lcf[j]==0:\\n                lcf[j] = i\\n# cache for avoiding repitive work\\n# getting prime factors using least common factor\\n@cache\\ndef getFaxx(num):\\n    pf = Counter()\\n    if prime[num]:\\n        pf[num] +=1\\n    else:\\n        while num!=1:\\n            if lcf[num] == 0:\\n                div = num\\n            else:\\n                div = lcf[num]\\n            pf[div]+=1\\n            num//=div\\n    return pf\\ndef check(d1,d2):\\n\\tfor k in d2:\\n\\t\\tif d1[k] and d2[k]:\\n\\t\\t\\treturn 0 # we got some factors common so its not a valid split\\n\\treturn 1\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        suffix = Counter()\\n        def fill_suf():\\n            for num in nums:\\n                if prime[num]:\\n                    suffix[num]+=1\\n                else:\\n                    d = getFaxx(num)\\n                    for k in d:\\n                        suffix[k]+=d[k]\\n        fill_suf()\\n        prefix = Counter()\\n        n = len(nums)\\n        for idx,num in enumerate(nums[:-1]):\\n            factors = getFaxx(num)\\n\\t\\t\\t# updating factors of num in both prefix and suffix \\n            for k in factors:\\n                prefix[k]+=factors[k]\\n                suffix[k]-=factors[k]\\n            if check(prefix,suffix):\\n                return idx\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\n# combining seive with least common factor \\nprime = [1]*(10**6+2)\\nupto = 10**6+2\\nprime[0]=prime[1] = 0\\nlcf = [0]*(10**6+2)\\nfor i in range(2,upto):\\n    if prime[i]:\\n        for j in range(2*i,upto,i):\\n            prime[j] = 0\\n            if lcf[j]==0:\\n                lcf[j] = i\\n# cache for avoiding repitive work\\n# getting prime factors using least common factor\\n@cache\\ndef getFaxx(num):\\n    pf = Counter()\\n    if prime[num]:\\n        pf[num] +=1\\n    else:\\n        while num!=1:\\n            if lcf[num] == 0:\\n                div = num\\n            else:\\n                div = lcf[num]\\n            pf[div]+=1\\n            num//=div\\n    return pf\\ndef check(d1,d2):\\n\\tfor k in d2:\\n\\t\\tif d1[k] and d2[k]:\\n\\t\\t\\treturn 0 # we got some factors common so its not a valid split\\n\\treturn 1\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        suffix = Counter()\\n        def fill_suf():\\n            for num in nums:\\n                if prime[num]:\\n                    suffix[num]+=1\\n                else:\\n                    d = getFaxx(num)\\n                    for k in d:\\n                        suffix[k]+=d[k]\\n        fill_suf()\\n        prefix = Counter()\\n        n = len(nums)\\n        for idx,num in enumerate(nums[:-1]):\\n            factors = getFaxx(num)\\n\\t\\t\\t# updating factors of num in both prefix and suffix \\n            for k in factors:\\n                prefix[k]+=factors[k]\\n                suffix[k]-=factors[k]\\n            if check(prefix,suffix):\\n                return idx\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282325,
                "title": "java-solution-last-prime-index",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitially the thought was to calculate the product of all elemnets as in prefix sum methodology ad then caculate gcd of each values,left and right ride of the array. But that would never work since the long variable will not be able to store that size.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne important observation,ie, in order for both the products to be co prime, the prime factors present on one side should not be present on the other side. \\nSo we basically calculate all the prime factors of each element in the array then store these prime factors in a list and also store the last occuring location of that prime factor.In this manner we can simply traverse the list prime factors of each array element and store the last occuring location of each of them from hashMap, when current postion and the lastIndex is same we can easily return that position. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValidSplit(int[] nums) {\\n        List<List<Integer>> ls=new ArrayList<>();//Used to store all the prime factors of each array element\\n        HashMap<Integer,Integer> h=new HashMap<>();//Used to store all the prime factors along with its last occurance\\n        for(int i=0;i<nums.length;i++){\\n            ls.add(new ArrayList<>());\\n            storeprime(ls.get(i),h,nums[i],i);\\n        }\\n        int last=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j:ls.get(i)){\\n                last=Math.max(last,h.get(j));//Calculating the last occurance of that particular prime factor\\n            }\\n            if(i==last)\\n                return i;\\n        }\\n        return -1;\\n    }\\n    public void storeprime(List<Integer> ls,HashMap<Integer,Integer> h,int n,int index){//This function finds and stores the prime factors\\n        for(int i=2;i*i<=n;i++){\\n            while(n%i==0){\\n                h.put(i,index);\\n                ls.add(i);\\n                n/=i;\\n            }\\n        }\\n        if(n>1){\\n            ls.add(n);\\n            h.put(n,index);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int findValidSplit(int[] nums) {\\n        List<List<Integer>> ls=new ArrayList<>();//Used to store all the prime factors of each array element\\n        HashMap<Integer,Integer> h=new HashMap<>();//Used to store all the prime factors along with its last occurance\\n        for(int i=0;i<nums.length;i++){\\n            ls.add(new ArrayList<>());\\n            storeprime(ls.get(i),h,nums[i],i);\\n        }\\n        int last=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j:ls.get(i)){\\n                last=Math.max(last,h.get(j));//Calculating the last occurance of that particular prime factor\\n            }\\n            if(i==last)\\n                return i;\\n        }\\n        return -1;\\n    }\\n    public void storeprime(List<Integer> ls,HashMap<Integer,Integer> h,int n,int index){//This function finds and stores the prime factors\\n        for(int i=2;i*i<=n;i++){\\n            while(n%i==0){\\n                h.put(i,index);\\n                ls.add(i);\\n                n/=i;\\n            }\\n        }\\n        if(n>1){\\n            ls.add(n);\\n            h.put(n,index);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278963,
                "title": "prime-factorization-hashing",
                "content": "# Complexity\\n- Time complexity: O(N*sqrt(N))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int cnt = 0;\\n        map<int, int> suf, pref;\\n        for(auto i : nums){\\n            for(int j = 2; j <= sqrt(i); j++){\\n                while(i%j == 0){\\n                    suf[j]++;\\n                    i/=j;\\n                }\\n            }\\n            if(i>=2) suf[i]++;\\n        }\\n        for(int i=0; i<nums.size()-1; i++){\\n            int d=nums[i];\\n            for(int j = 2; j <= sqrt(d); j++){\\n                while(d%j == 0){\\n                    pref[j]++;\\n                    suf[j]--;\\n                    d/=j;\\n                    if(suf[j] == 0) cnt++;\\n                }\\n            }\\n            if(d>=2) {\\n                pref[d]++;\\n                suf[d]--;\\n                if(suf[d] == 0) cnt++;\\n            }\\n            if(cnt==pref.size()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Hash Function",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int cnt = 0;\\n        map<int, int> suf, pref;\\n        for(auto i : nums){\\n            for(int j = 2; j <= sqrt(i); j++){\\n                while(i%j == 0){\\n                    suf[j]++;\\n                    i/=j;\\n                }\\n            }\\n            if(i>=2) suf[i]++;\\n        }\\n        for(int i=0; i<nums.size()-1; i++){\\n            int d=nums[i];\\n            for(int j = 2; j <= sqrt(d); j++){\\n                while(d%j == 0){\\n                    pref[j]++;\\n                    suf[j]--;\\n                    d/=j;\\n                    if(suf[j] == 0) cnt++;\\n                }\\n            }\\n            if(d>=2) {\\n                pref[d]++;\\n                suf[d]--;\\n                if(suf[d] == 0) cnt++;\\n            }\\n            if(cnt==pref.size()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278693,
                "title": "c-best-solution-with-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere, if any two numbers are not co-prime then we have a relation among them (say, we can jump from one number to another).\\nSo, in left subarray I will try to jump to as much right as possible.\\n\\nTherefore, I will calculate the right most index to which I can jump from that index.(**last_associated**)\\n\\nWherever I found the max right most jump == idx, then that\\'s the answer.\\nEde case: exclude index n-1 from the answer.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Will find all prime factors of element. And, store the rightmost index of element which has that factor. Here I used **prime_last** for that.\\n2. Will find rightmost inde for every element such that they share a common factor. (so that there is a relation between them).\\n3. Now, we try to as right as we can go untill rightmost position is greater that index. In the process if at any point rightmost position becomes equal to current index, that is the answer.\\n\\n    ***How? It means, no element in [0,1,2....idx] has any relation with any element of [idx+1,idx+2,.....n-2,n-1]\\n    So, idx is that break point.***\\n\\n\\n# Complexity\\n- Time complexity: O(n^1.5)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,int>prime_last;\\n        vector<int>last_associated(n,-1);\\n\\n        for(int i=n-1; i>=0 ; i--){\\n            int num = nums[i];\\n            last_associated[i] = i;\\n            for(int j=2; num>1 && j*j<=num; j++){\\n                bool f = false;\\n                while(num%j==0){\\n                    num/=j;\\n                    f = true;\\n                }\\n                if(f == true){\\n                    if(prime_last.find(j)==prime_last.end()){\\n                        prime_last[j]=i;\\n                    } else {\\n                        last_associated[i] = max(last_associated[i], prime_last[j]);\\n                    }\\n                }\\n            }\\n\\n            if(num > 1){\\n                if(prime_last.find(num)==prime_last.end()){\\n                    prime_last[num]=i;\\n                } else {\\n                    last_associated[i] = max(last_associated[i], prime_last[num]);\\n                }\\n            }\\n\\n        }\\n\\n        int last = -1;\\n        for(int i=0; i< n; i++){\\n            last = max(last_associated[i],last);\\n            if(last == i && i!=n-1){\\n                return last;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,int>prime_last;\\n        vector<int>last_associated(n,-1);\\n\\n        for(int i=n-1; i>=0 ; i--){\\n            int num = nums[i];\\n            last_associated[i] = i;\\n            for(int j=2; num>1 && j*j<=num; j++){\\n                bool f = false;\\n                while(num%j==0){\\n                    num/=j;\\n                    f = true;\\n                }\\n                if(f == true){\\n                    if(prime_last.find(j)==prime_last.end()){\\n                        prime_last[j]=i;\\n                    } else {\\n                        last_associated[i] = max(last_associated[i], prime_last[j]);\\n                    }\\n                }\\n            }\\n\\n            if(num > 1){\\n                if(prime_last.find(num)==prime_last.end()){\\n                    prime_last[num]=i;\\n                } else {\\n                    last_associated[i] = max(last_associated[i], prime_last[num]);\\n                }\\n            }\\n\\n        }\\n\\n        int last = -1;\\n        for(int i=0; i< n; i++){\\n            last = max(last_associated[i],last);\\n            if(last == i && i!=n-1){\\n                return last;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278327,
                "title": "fully-explained-unordered-map-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**We had created  three unordered map namely store, starting,ending . Here store will store vector of factors of every number present in nums according to there indexes.The second unordered_map starting will store factors of the upto the current element when we will start iterating in the array . The next unordered_map ending will store the factors of the element after the current element when iteration will be performed. Ending initially will be storing factors of all the element.\\n\\nStep 1-> Find factors of every element in the nums and store them in the ending map and store map.\\n\\nStep2->Iterate through nums and push the factors of current element in the starting map and decrement them from the ending map.\\n\\nStep3-> check whether the factors present in the starting map exist in the ending map or not. If not return the index else continue iteration.\\n\\nStep4->if not found . Simply return -1;**\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,vector<int>>store;\\n        unordered_map<int,int>starting;\\n        unordered_map<int,int>ending;\\n        for(int j=0;j<n;j++)\\n        {\\n           int num=nums[j];\\n           vector<int>ans;\\n           while(num%2==0)\\n           {\\n               ans.push_back(2);\\n               ending[2]++;\\n               num/=2;\\n           }\\n            for(int i=3;i<=sqrt(num);i++)\\n            {\\n                while(num%i==0)\\n                {\\n                    ans.push_back(i);\\n                    ending[i]++;\\n                    num/=i;\\n                }\\n            }\\n            if(num>2)\\n            {\\n              ending[num]++;\\n              ans.push_back(num);\\n            }\\n            store[j]=ans;\\n        }\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            vector<int>temp=store[i];\\n            for(auto it: temp)\\n            {\\n                starting[it]++;\\n                ending[it]--;\\n                if(ending[it]==0)ending.erase(it);\\n            }\\n            bool flag=true;\\n            for(auto it: starting)\\n            {\\n                if(ending.find(it.first)!=ending.end())\\n                {\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,vector<int>>store;\\n        unordered_map<int,int>starting;\\n        unordered_map<int,int>ending;\\n        for(int j=0;j<n;j++)\\n        {\\n           int num=nums[j];\\n           vector<int>ans;\\n           while(num%2==0)\\n           {\\n               ans.push_back(2);\\n               ending[2]++;\\n               num/=2;\\n           }\\n            for(int i=3;i<=sqrt(num);i++)\\n            {\\n                while(num%i==0)\\n                {\\n                    ans.push_back(i);\\n                    ending[i]++;\\n                    num/=i;\\n                }\\n            }\\n            if(num>2)\\n            {\\n              ending[num]++;\\n              ans.push_back(num);\\n            }\\n            store[j]=ans;\\n        }\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            vector<int>temp=store[i];\\n            for(auto it: temp)\\n            {\\n                starting[it]++;\\n                ending[it]--;\\n                if(ending[it]==0)ending.erase(it);\\n            }\\n            bool flag=true;\\n            for(auto it: starting)\\n            {\\n                if(ending.find(it.first)!=ending.end())\\n                {\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276262,
                "title": "split-the-array-c-explained-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem here needs some mathematical observation and intelligent implementation. Basically finding prefix and suffix product is not a possible way due to overflow problem.\\nThe next step is to use prime factorisation and marking the elements in array. Now any two elements having common divisor must lie in same group. This helps us in reducing checking part for same divisor multiple times. Rest implementation goes below :\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        ios_base::sync_with_stdio(0);\\n        int n = nums.size(),bnd = 0,i = 0; vector<int>divs; map<int,int>mp;\\n        while(i < n && i <= bnd){\\n            int c = 0;\\n            while(nums[i] % 2 == 0){\\n                c++;\\n                nums[i] /= 2;\\n            }\\n            if(c){\\n                if(mp[2] == 0){\\n                    divs.push_back(2);\\n                    mp[2]++;\\n                }\\n            }\\n            for(int j = 3; j * j <= nums[i]; j += 2){\\n                c = 0;\\n                while(nums[i] % j == 0){\\n                    c++;\\n                    nums[i] /= j;\\n                }\\n                if(c){\\n                    if(mp[j] == 0){\\n                        divs.push_back(j);\\n                        mp[j]++;\\n                    }\\n                }\\n            }\\n            if(nums[i] > 1){\\n                if(mp[nums[i]] == 0){\\n                    divs.push_back(nums[i]);\\n                    mp[nums[i]]++;\\n                }\\n            }\\n            int upd = bnd;\\n            for(auto k : divs){\\n                for(int j = bnd; j < n; j++){\\n                    if(nums[j] % k == 0){\\n                        upd = max(upd,j);\\n                    }\\n                }\\n            }\\n            bnd = upd;\\n            i++; divs.clear();\\n        }\\n        return i == n ? -1 : bnd;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        ios_base::sync_with_stdio(0);\\n        int n = nums.size(),bnd = 0,i = 0; vector<int>divs; map<int,int>mp;\\n        while(i < n && i <= bnd){\\n            int c = 0;\\n            while(nums[i] % 2 == 0){\\n                c++;\\n                nums[i] /= 2;\\n            }\\n            if(c){\\n                if(mp[2] == 0){\\n                    divs.push_back(2);\\n                    mp[2]++;\\n                }\\n            }\\n            for(int j = 3; j * j <= nums[i]; j += 2){\\n                c = 0;\\n                while(nums[i] % j == 0){\\n                    c++;\\n                    nums[i] /= j;\\n                }\\n                if(c){\\n                    if(mp[j] == 0){\\n                        divs.push_back(j);\\n                        mp[j]++;\\n                    }\\n                }\\n            }\\n            if(nums[i] > 1){\\n                if(mp[nums[i]] == 0){\\n                    divs.push_back(nums[i]);\\n                    mp[nums[i]]++;\\n                }\\n            }\\n            int upd = bnd;\\n            for(auto k : divs){\\n                for(int j = bnd; j < n; j++){\\n                    if(nums[j] % k == 0){\\n                        upd = max(upd,j);\\n                    }\\n                }\\n            }\\n            bnd = upd;\\n            i++; divs.clear();\\n        }\\n        return i == n ? -1 : bnd;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273173,
                "title": "note-2584-split-the-array-to-make-coprime-products",
                "content": "# Approach: Prime Factorization\\n(My first solution - Note and will be optimized)\\n- Time complexity: `!O(n*sqrt(m))`  - pFactor `O(sqrt(m))`\\n- Space complexity: `!O(m)`         - pFactor `O(log(m))`\\n\\n```python\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int: \\n        def pFactor(n):\\n            d = {}\\n            i = 2\\n            while n%i == 0:\\n                if i not in d:\\n                    d[i] = 0\\n                d[i] += 1\\n                n //= i\\n            i = 3\\n            while i*i <= n:\\n                if n%i == 0:\\n                    if i not in d:\\n                        d[i] = 0\\n                    d[i] += 1\\n                    n //= i\\n                else:\\n                    i += 2\\n            if n!=1:\\n                if n not in d:\\n                    d[n] = 0\\n                d[n] += 1\\n            return d\\n        n = len(nums)\\n        left = {}\\n        right = {}\\n        gcd = {}\\n        for i in range(n):\\n            dummy = pFactor(nums[i])\\n            for j in dummy:\\n                if j not in right:\\n                    right[j] = 0\\n                right[j] += dummy[j]\\n        for i in range(0, n-1):\\n            dummy = pFactor(nums[i])\\n            for j in dummy:\\n                if j not in left:\\n                    left[j] = 0\\n                left[j] += dummy[j]\\n                right[j] -= dummy[j]\\n                k = min(left[j], right[j])\\n                gcd[j] = k\\n                if k == 0:\\n                    del gcd[j]\\n            if len(gcd) == 0:\\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int: \\n        def pFactor(n):\\n            d = {}\\n            i = 2\\n            while n%i == 0:\\n                if i not in d:\\n                    d[i] = 0\\n                d[i] += 1\\n                n //= i\\n            i = 3\\n            while i*i <= n:\\n                if n%i == 0:\\n                    if i not in d:\\n                        d[i] = 0\\n                    d[i] += 1\\n                    n //= i\\n                else:\\n                    i += 2\\n            if n!=1:\\n                if n not in d:\\n                    d[n] = 0\\n                d[n] += 1\\n            return d\\n        n = len(nums)\\n        left = {}\\n        right = {}\\n        gcd = {}\\n        for i in range(n):\\n            dummy = pFactor(nums[i])\\n            for j in dummy:\\n                if j not in right:\\n                    right[j] = 0\\n                right[j] += dummy[j]\\n        for i in range(0, n-1):\\n            dummy = pFactor(nums[i])\\n            for j in dummy:\\n                if j not in left:\\n                    left[j] = 0\\n                left[j] += dummy[j]\\n                right[j] -= dummy[j]\\n                k = min(left[j], right[j])\\n                gcd[j] = k\\n                if k == 0:\\n                    del gcd[j]\\n            if len(gcd) == 0:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272004,
                "title": "intuitive-racket-solution",
                "content": "# Intuition\\n\\nAfter some thinking, the `gcd` solution is not feasible as\\nit would become too large to fit into a 64-bit integer.\\n\\nWe factor the numbers in `nums`, maintain the frequencies hash\\ntable of the left `i+1` numbers, the right `n-i-1` numbers, and\\ntheir intersects, respectively.\\n\\n# Complexity\\n- Time complexity: $O(\\\\sqrt{m} + n \\\\lg m)$\\n\\n- Space complexity: $O(n \\\\lg m)$\\n\\nwhere $m = \\\\sqrt{\\\\max(\\\\text{nums})}$\\n\\n# Code\\n\\nIn code, I hardcoded `1001` beacause `sqrt(max(nums)) < 1001`.\\n\\n```\\n(define (find-valid-split nums)\\n  (define intersects (make-hash))\\n  (define right (make-hash))\\n  (define left (make-hash))\\n\\n  (define (remove! prime-freq primes)\\n    (for ([(p cnt) primes])\\n      (hash-update! prime-freq p (\\u03BB (old) (- old cnt)))\\n      (when (= 0 (hash-ref prime-freq p))\\n        (hash-remove! prime-freq p))))\\n\\n  (define (add! prime-freq primes)\\n    (for ([(p cnt) primes])\\n      (hash-update! prime-freq p (\\u03BB (old) (+ old cnt)) 0)))\\n\\n  (define (update-intersects! primes)\\n    (for ([(p cnt) primes])\\n      (define s (min (hash-ref left p 0)\\n                     (hash-ref right p 0)))\\n      (cond [(= s 0) (hash-remove! intersects p)]\\n            [else (hash-set! intersects p s)])))\\n\\n  (define all-primes\\n    (let ([ps (mutable-set)])\\n      (for ([i (range 2 1001)])\\n        (when (for/and ([p ps])\\n                (not (= 0 (modulo i p))))\\n          (set-add! ps i)))\\n      ps))\\n\\n  (define (factor x)\\n    (define h (make-hash))\\n    (for ([p all-primes])\\n      (let loop ()\\n        (when (= 0 (modulo x p))\\n          (set! x (/ x p))\\n          (hash-update! h p add1 0)\\n          (loop))))\\n    (when (not (= x 1))\\n      (hash-set! h x 1))\\n    h)\\n\\n  (define primes (map factor nums))\\n\\n  (define ans -1)\\n\\n  (for ([ps primes])\\n    (add! right ps))\\n\\n  (for ([ps (drop-right primes 1)]\\n        [i (in-naturals 0)])\\n    (remove! right ps)\\n    (add! left ps)\\n    (update-intersects! ps)\\n    (when (and (= 0 (hash-count intersects))\\n               (= ans -1))\\n      (set! ans i)))\\n  ans)\\n\\n```",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```\\n(define (find-valid-split nums)\\n  (define intersects (make-hash))\\n  (define right (make-hash))\\n  (define left (make-hash))\\n\\n  (define (remove! prime-freq primes)\\n    (for ([(p cnt) primes])\\n      (hash-update! prime-freq p (\\u03BB (old) (- old cnt)))\\n      (when (= 0 (hash-ref prime-freq p))\\n        (hash-remove! prime-freq p))))\\n\\n  (define (add! prime-freq primes)\\n    (for ([(p cnt) primes])\\n      (hash-update! prime-freq p (\\u03BB (old) (+ old cnt)) 0)))\\n\\n  (define (update-intersects! primes)\\n    (for ([(p cnt) primes])\\n      (define s (min (hash-ref left p 0)\\n                     (hash-ref right p 0)))\\n      (cond [(= s 0) (hash-remove! intersects p)]\\n            [else (hash-set! intersects p s)])))\\n\\n  (define all-primes\\n    (let ([ps (mutable-set)])\\n      (for ([i (range 2 1001)])\\n        (when (for/and ([p ps])\\n                (not (= 0 (modulo i p))))\\n          (set-add! ps i)))\\n      ps))\\n\\n  (define (factor x)\\n    (define h (make-hash))\\n    (for ([p all-primes])\\n      (let loop ()\\n        (when (= 0 (modulo x p))\\n          (set! x (/ x p))\\n          (hash-update! h p add1 0)\\n          (loop))))\\n    (when (not (= x 1))\\n      (hash-set! h x 1))\\n    h)\\n\\n  (define primes (map factor nums))\\n\\n  (define ans -1)\\n\\n  (for ([ps primes])\\n    (add! right ps))\\n\\n  (for ([ps (drop-right primes 1)]\\n        [i (in-naturals 0)])\\n    (remove! right ps)\\n    (add! left ps)\\n    (update-intersects! ps)\\n    (when (and (= 0 (hash-count intersects))\\n               (= ans -1))\\n      (set! ans i)))\\n  ans)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3271932,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return -1\\n        def primeFactors(n):\\n            arr = []\\n            seen = set()\\n            while n % 2 == 0:\\n                if 2 not in seen:\\n                    arr.append(2)\\n                    seen.add(2)\\n                n = n / 2\\n\\n            for i in range(3,int(math.sqrt(n))+1,2):\\n\\n                while n % i== 0:\\n                    if i not in seen:\\n                        arr.append(int(i))\\n                        seen.add(int(i))\\n                    n = n / i\\n\\n            if n > 2:\\n                if n not in seen:\\n                    arr.append(int(n))\\n                    seen.add(int(n))\\n\\n            return arr\\n\\n        new_arr = []\\n        max_idx = dict()\\n        same = set()\\n        left_key = []\\n        for i,num in enumerate(nums):\\n            new_arr.append(primeFactors(num))\\n            for x in new_arr[-1]:\\n                max_idx[x] = i\\n\\n                if i == 0:\\n                    left_key.append(x)\\n\\n        target = 0\\n        for x in left_key:target = max(max_idx[x],target)\\n        if target == 0: return 0\\n        for i in range(1,len(new_arr)-1):\\n            for x in new_arr[i]:\\n                target = max(max_idx[x],target)\\n\\n            if i == target: return target\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return -1\\n        def primeFactors(n):\\n            arr = []\\n            seen = set()\\n            while n % 2 == 0:\\n                if 2 not in seen:\\n                    arr.append(2)\\n                    seen.add(2)\\n                n = n / 2\\n\\n            for i in range(3,int(math.sqrt(n))+1,2):\\n\\n                while n % i== 0:\\n                    if i not in seen:\\n                        arr.append(int(i))\\n                        seen.add(int(i))\\n                    n = n / i\\n\\n            if n > 2:\\n                if n not in seen:\\n                    arr.append(int(n))\\n                    seen.add(int(n))\\n\\n            return arr\\n\\n        new_arr = []\\n        max_idx = dict()\\n        same = set()\\n        left_key = []\\n        for i,num in enumerate(nums):\\n            new_arr.append(primeFactors(num))\\n            for x in new_arr[-1]:\\n                max_idx[x] = i\\n\\n                if i == 0:\\n                    left_key.append(x)\\n\\n        target = 0\\n        for x in left_key:target = max(max_idx[x],target)\\n        if target == 0: return 0\\n        for i in range(1,len(new_arr)-1):\\n            for x in new_arr[i]:\\n                target = max(max_idx[x],target)\\n\\n            if i == target: return target\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271235,
                "title": "time-730-ms-in-python",
                "content": "# Intuition\\nThere should be no common factors in between both sides\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n * sqrt(max(num)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        freq = Counter()\\n        for x in nums: \\n            for p in range(2, isqrt(x)+1): \\n                while x % p == 0: \\n                    freq[p] += 1\\n                    x //= p \\n            if x > 1: freq[x] += 1\\n        ovlp = 0 \\n        prefix = Counter()\\n        for i, x in enumerate(nums): \\n            if i <= len(nums)-2: \\n                for p in range(2, isqrt(x)+1): \\n                    if x % p == 0: \\n                        if prefix[p] == 0: ovlp += 1\\n                        while x % p == 0: \\n                            prefix[p] += 1\\n                            x //= p \\n                        if prefix[p] == freq[p]: ovlp -= 1\\n                if x > 1: \\n                    if prefix[x] == 0: ovlp += 1\\n                    prefix[x] += 1\\n                    if prefix[x] == freq[x]: ovlp -= 1\\n                if not ovlp: return i \\n        return -1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        freq = Counter()\\n        for x in nums: \\n            for p in range(2, isqrt(x)+1): \\n                while x % p == 0: \\n                    freq[p] += 1\\n                    x //= p \\n            if x > 1: freq[x] += 1\\n        ovlp = 0 \\n        prefix = Counter()\\n        for i, x in enumerate(nums): \\n            if i <= len(nums)-2: \\n                for p in range(2, isqrt(x)+1): \\n                    if x % p == 0: \\n                        if prefix[p] == 0: ovlp += 1\\n                        while x % p == 0: \\n                            prefix[p] += 1\\n                            x //= p \\n                        if prefix[p] == freq[p]: ovlp -= 1\\n                if x > 1: \\n                    if prefix[x] == 0: ovlp += 1\\n                    prefix[x] += 1\\n                    if prefix[x] == freq[x]: ovlp -= 1\\n                if not ovlp: return i \\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270388,
                "title": "step-by-step-from-tle-to-the-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Based on the description, I initially got a straightforward solution. The reason I use Python3 is to prevent from overflow. The split point locates where the left portion and right portion are coprime. So I loop the array to see if the gcd of left products and right products is equal to 1.\\n\\n# Code (Python3, TLE)\\n```\\ndef findValidSplit(self, nums: List[int]) -> int:\\n    products = 1\\n    p = 1\\n    n = len(nums)\\n    for num in nums:\\n        products *= num\\n    for i in range(n-1):\\n        p *= nums[i]\\n        if math.gcd(p,products//p) == 1:\\n            return i\\n    return -1\\n```\\n\\n2. We need optimization to avoid the TLE. Looking at the gcd of left portion and right portion, can we transform this into another? As long as they don\\'t share the same prime factor, then we can definitely say the split point is here. For example,\\n\\nnums = [4,7,8,15,3,5]\\n\\npivot index at 0:\\n\\nleft product: 4\\nright product: 12600\\n\\nleft prime factor: 2\\nright prime factors: 7,2,(3,5),3,5\\nThey do share the prime factor of 2. So index of 0 can\\'t be selected.\\n\\npivot index at 1:\\nleft product: 28\\nright product: 1800\\n\\nleft prime factors : 2,7\\nright prime factors: 2,3,5,3,5\\nThey still share the prime factor of 2\\n\\npivot index at 2:\\nleft product: 224\\nright product: 225\\n\\nleft prime factors: 2,7,2\\nright prime factors: 3,5,3,5\\nThey don\\'t share any prime factors. So 2 is the answer.\\n\\nLet\\'s see another example:\\nnums = [4,7,15,8,3,5]\\n\\npivot index at 0:\\nleft product: 4\\nright product: 12600\\n\\nleft prime factors: 2\\nright prime factors: 7,3,5,2,3,5\\nThey share a common prime factor of 2\\n\\npivot index at 1:\\nleft product: 28\\nright product: 1800\\n\\nleft prime factors: 2,7\\nright prime factors: 3,5,2,3,5\\nThey share a common prime factor of 2\\n\\npivot index at 2:\\nleft product: 420\\nright product: 120\\n\\nleft prime factors: 2,7,3,5\\nright prime factors: 2,3,5\\nThey share common prime factors of 2,3,5\\n\\npivot index at 3:\\nleft product: 3360\\nright product: 15\\n\\nleft prime factors: 2,7,3,5,2\\nright prime factors: 3,5\\nThey share common prime factors of 3,5\\n\\npivot index at 4:\\nleft product: 10080\\nright product: 5\\n\\nleft prime factors: 2,7,3,5,2,3\\nright prime factors: 5\\nThey share common prime factors of 5\\n\\nSo the answer is -1 because we can set the split point at n-1.\\n\\nSo the problem can be transformed into that calculating the left prime factors and right prime factors and get the pivot index not sharing common prime factors.\\n\\nI use [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes) to calculate each element of its unique prime factors. Then calculate if they share common prime factors starting from 0 to n-2.\\n\\n# Python Code\\n```\\ndef findValidSplit(self, nums: List[int]) -> int:\\n    def getPrimes(n):\\n        res = []\\n        i = 2\\n        while (i<1000 and n>1):\\n            if n%i == 0:\\n                res.append(i)\\n            while n%i == 0:\\n                n //= i\\n            i += 1 + (i%2)\\n        if n > 1:\\n            res.append(n)\\n        return res\\n    \\n    left, right = defaultdict(int), defaultdict(int)\\n    for num in nums:\\n        for x in getPrimes(num):\\n            right[x] += 1\\n    common = 0\\n    for i in range(len(nums)-1):\\n        ele = nums[i]\\n        for x in getPrimes(ele):\\n            left[x] += 1\\n            if left[x] == 1: common += 1\\n            if left[x] == right[x]: common -= 1\\n        if common == 0:\\n            return i\\n    return -1\\n``` \\n\\n# JAVA Code (code inspired by [@votrubac](https://leetcode.com/problems/split-the-array-to-make-coprime-products/solutions/3258070/prime-intervals-vs-count-primes/?orderBy=most_votes))\\n```\\nclass Solution {\\n    List<Integer> getPrimes(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        for (int i=2;n>1 && i<1000;i+= 1 + (i%2)) {\\n            if (n%i == 0) res.add(i);\\n            while (n%i == 0) n /= i;\\n        }\\n        if (n > 1) res.add(n);\\n        return res;\\n    }\\n    \\n    public int findValidSplit(int[] nums) {\\n        HashMap<Integer,Integer> right = new HashMap<>(), left = new HashMap<>();\\n        for (int num:nums) {\\n            for (int x:getPrimes(num)) {\\n                right.merge(x,1,Integer::sum);\\n            }\\n        }\\n        // System.out.println(right);\\n        for (int i=0, common=0;i<nums.length-1;i++) {\\n            int ele = nums[i];\\n            for (int x:getPrimes(ele)) {\\n                left.merge(x,1,Integer::sum);\\n                common += left.get(x) == 1 ? 1:0;\\n                common -= left.get(x).equals(right.get(x)) ? 1 : 0;\\n            }\\n            if (common == 0) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\ndef findValidSplit(self, nums: List[int]) -> int:\\n    products = 1\\n    p = 1\\n    n = len(nums)\\n    for num in nums:\\n        products *= num\\n    for i in range(n-1):\\n        p *= nums[i]\\n        if math.gcd(p,products//p) == 1:\\n            return i\\n    return -1\\n```\n```\\ndef findValidSplit(self, nums: List[int]) -> int:\\n    def getPrimes(n):\\n        res = []\\n        i = 2\\n        while (i<1000 and n>1):\\n            if n%i == 0:\\n                res.append(i)\\n            while n%i == 0:\\n                n //= i\\n            i += 1 + (i%2)\\n        if n > 1:\\n            res.append(n)\\n        return res\\n    \\n    left, right = defaultdict(int), defaultdict(int)\\n    for num in nums:\\n        for x in getPrimes(num):\\n            right[x] += 1\\n    common = 0\\n    for i in range(len(nums)-1):\\n        ele = nums[i]\\n        for x in getPrimes(ele):\\n            left[x] += 1\\n            if left[x] == 1: common += 1\\n            if left[x] == right[x]: common -= 1\\n        if common == 0:\\n            return i\\n    return -1\\n```\n```\\nclass Solution {\\n    List<Integer> getPrimes(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        for (int i=2;n>1 && i<1000;i+= 1 + (i%2)) {\\n            if (n%i == 0) res.add(i);\\n            while (n%i == 0) n /= i;\\n        }\\n        if (n > 1) res.add(n);\\n        return res;\\n    }\\n    \\n    public int findValidSplit(int[] nums) {\\n        HashMap<Integer,Integer> right = new HashMap<>(), left = new HashMap<>();\\n        for (int num:nums) {\\n            for (int x:getPrimes(num)) {\\n                right.merge(x,1,Integer::sum);\\n            }\\n        }\\n        // System.out.println(right);\\n        for (int i=0, common=0;i<nums.length-1;i++) {\\n            int ele = nums[i];\\n            for (int x:getPrimes(ele)) {\\n                left.merge(x,1,Integer::sum);\\n                common += left.get(x) == 1 ? 1:0;\\n                common -= left.get(x).equals(right.get(x)) ? 1 : 0;\\n            }\\n            if (common == 0) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269204,
                "title": "java-code-using-common-prime-factors",
                "content": "\\n\\n# Approach\\n - Store the count of prime factors for both left and right side.\\n - If at any index count of prime factors for any left or right side becomes zero then that index will be considered as answer.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValidSplit(int[] nums) {\\n        int n=nums.length;\\n        Map<Integer,Integer> right=new HashMap<>();\\n        Map<Integer,Integer> left=new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            Map<Integer,Integer> counts=getPrimeFactors(nums[i]) ;\\n            for(int k:counts.keySet()){\\n                int each=counts.get(k);\\n                right.put(k,right.getOrDefault(k,0)+each);\\n            }\\n        }\\n        Set<Integer> common=new HashSet<>();\\n        for(int i=0;i<n-1;i++){\\n            Map<Integer,Integer> counts=getPrimeFactors(nums[i]) ;\\n            for(int k:counts.keySet()){\\n                int each=counts.get(k);\\n                left.put(k,left.getOrDefault(k,0)+each);\\n                right.put(k,right.get(k)-each);\\n                 if (right.get(k) > 0) common.add(k);\\n                 else if (right.get(k) == 0) common.remove(k);\\n            }\\n            if(common.size()==0) return i;\\n        }\\n        return -1;\\n    }\\nprivate HashMap<Integer,Integer> getPrimeFactors(int n) {\\n    HashMap<Integer,Integer> map=new HashMap<>();\\n    for (int x = 2; (x * x) <= n; x++) {\\n        while (n % x == 0) {\\n            map.put(x,map.getOrDefault(x,0)+1);\\n            n /= x;\\n        }\\n    }\\n    if (n > 1) map.put(n,map.getOrDefault(n,0)+1);\\n    return map;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValidSplit(int[] nums) {\\n        int n=nums.length;\\n        Map<Integer,Integer> right=new HashMap<>();\\n        Map<Integer,Integer> left=new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            Map<Integer,Integer> counts=getPrimeFactors(nums[i]) ;\\n            for(int k:counts.keySet()){\\n                int each=counts.get(k);\\n                right.put(k,right.getOrDefault(k,0)+each);\\n            }\\n        }\\n        Set<Integer> common=new HashSet<>();\\n        for(int i=0;i<n-1;i++){\\n            Map<Integer,Integer> counts=getPrimeFactors(nums[i]) ;\\n            for(int k:counts.keySet()){\\n                int each=counts.get(k);\\n                left.put(k,left.getOrDefault(k,0)+each);\\n                right.put(k,right.get(k)-each);\\n                 if (right.get(k) > 0) common.add(k);\\n                 else if (right.get(k) == 0) common.remove(k);\\n            }\\n            if(common.size()==0) return i;\\n        }\\n        return -1;\\n    }\\nprivate HashMap<Integer,Integer> getPrimeFactors(int n) {\\n    HashMap<Integer,Integer> map=new HashMap<>();\\n    for (int x = 2; (x * x) <= n; x++) {\\n        while (n % x == 0) {\\n            map.put(x,map.getOrDefault(x,0)+1);\\n            n /= x;\\n        }\\n    }\\n    if (n > 1) map.put(n,map.getOrDefault(n,0)+1);\\n    return map;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268036,
                "title": "first-and-last-appear-of-prime-number-and-difference-array",
                "content": "\\n\\n# Approach\\n->  Let say a prime number x appears in array like\\nx=[i1,i2,i3....in] indices where x appears, so from these I can say that I can take i from 0 to i1-1 or from in to n-1, otherwise x will appear both in prefix and suffix, so all need to find for all primes the first and last index where it appears and according to their ranges take intersection and find min index.\\n\\n->  So in n*sqrt(10^6) I can find the first and last appearance of the prime number x\\n\\n-> Now I iterated over all the primes and marked in difference array what range of i can\\'t take for that prime i.e. the range for which that prime number appear in both suffix and prefix\\n\\n->(total primes can atmost be around 80000 for given arr[i] range)\\n\\n-> So at last my difference[i] will denote how many primes are there which are present in both prefix and suffix if I take that index, so I will find in that difference array where first zero appears\\n\\n# Complexity\\n- Time complexity:\\nO(n*sqrt(10^6))\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& arr) {\\n        int n=arr.size();\\n        // here prefix mapping is for first appearance of that prime\\n        // suffix is for last appearance\\n         map<int,int>prefix;\\n         map<int,int>suffix;\\n         vector<int>diff(n+1,0);\\n         for(int i=0;i<n;i++){\\n             int x=arr[i];\\n             while(x%2==0){\\n                 if(prefix.find(2)==prefix.end()){\\n                     prefix[2]=i+1;\\n                 }\\n                 x/=2;\\n             }\\n             for(int j=3;j<=sqrt(x);j=j+2){\\n                 while(x%j==0){\\n                     if(prefix.find(j)==prefix.end()){\\n                         prefix[j]=i+1;\\n                     }\\n                     x/=j;\\n                 }\\n             }\\n             if(x>2){\\n                 if(prefix.find(x)==prefix.end()){\\n                     prefix[x]=i+1;\\n                 }\\n             }\\n         }\\n         for(int i=n-1;i>=0;i--){\\n            int x=arr[i];\\n             while(x%2==0){\\n                 if(suffix.find(2)==suffix.end()){\\n                     suffix[2]=i+1;\\n                 }\\n                 x/=2;\\n             }\\n             for(int j=3;j<=sqrt(x);j=j+2){\\n                 while(x%j==0){\\n                     if(suffix.find(j)==suffix.end()){\\n                         suffix[j]=i+1;\\n                     }\\n                     x/=j;\\n                 }\\n             }\\n             if(x>2){\\n                 if(suffix.find(x)==suffix.end()){\\n                     suffix[x]=i+1;\\n                 }\\n             }\\n         }\\n         for(auto &[a,b]:prefix){\\n             int y=suffix[a];\\n             diff[b]+=1;\\n             diff[y]-=1;\\n         }\\n         for(int i=1;i<=n;i++){\\n             diff[i]+=diff[i-1];\\n         }\\n         int mini=n;\\n         for(int i=1;i<=n;i++){\\n             if(diff[i]==0){mini=i;break;}\\n         }\\n         if(mini==n)return -1;\\n         return mini-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& arr) {\\n        int n=arr.size();\\n        // here prefix mapping is for first appearance of that prime\\n        // suffix is for last appearance\\n         map<int,int>prefix;\\n         map<int,int>suffix;\\n         vector<int>diff(n+1,0);\\n         for(int i=0;i<n;i++){\\n             int x=arr[i];\\n             while(x%2==0){\\n                 if(prefix.find(2)==prefix.end()){\\n                     prefix[2]=i+1;\\n                 }\\n                 x/=2;\\n             }\\n             for(int j=3;j<=sqrt(x);j=j+2){\\n                 while(x%j==0){\\n                     if(prefix.find(j)==prefix.end()){\\n                         prefix[j]=i+1;\\n                     }\\n                     x/=j;\\n                 }\\n             }\\n             if(x>2){\\n                 if(prefix.find(x)==prefix.end()){\\n                     prefix[x]=i+1;\\n                 }\\n             }\\n         }\\n         for(int i=n-1;i>=0;i--){\\n            int x=arr[i];\\n             while(x%2==0){\\n                 if(suffix.find(2)==suffix.end()){\\n                     suffix[2]=i+1;\\n                 }\\n                 x/=2;\\n             }\\n             for(int j=3;j<=sqrt(x);j=j+2){\\n                 while(x%j==0){\\n                     if(suffix.find(j)==suffix.end()){\\n                         suffix[j]=i+1;\\n                     }\\n                     x/=j;\\n                 }\\n             }\\n             if(x>2){\\n                 if(suffix.find(x)==suffix.end()){\\n                     suffix[x]=i+1;\\n                 }\\n             }\\n         }\\n         for(auto &[a,b]:prefix){\\n             int y=suffix[a];\\n             diff[b]+=1;\\n             diff[y]-=1;\\n         }\\n         for(int i=1;i<=n;i++){\\n             diff[i]+=diff[i-1];\\n         }\\n         int mini=n;\\n         for(int i=1;i<=n;i++){\\n             if(diff[i]==0){mini=i;break;}\\n         }\\n         if(mini==n)return -1;\\n         return mini-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267368,
                "title": "python-prefix-prod-accepted-o-n",
                "content": "## Intuition\\nIt\\'s been pointed out that max constraints for this problem will overflow a 64-bit integer if we try using the intuitive prefix product approach. Arbitrarily large integers is not a problem with Python, however, this algorithm will still TLE despite being $O(n)$ (gcd computations stack up). Braintraining it a bit will get us accepted. \\n\\n## Approach\\nPrecompute prefix products and consider possible splits in sequence, computing the gcd between the corresponding products [when needed]. Although computing the gcd on every split will TLE, note that we\\'re surely not at the right split if the righthand product is divisible by the most recently computed gcd, so continue unless it is not divisible. This trick does not change the worst-case complexity but is enough to pass all tests.\\n\\n# Complexity\\n- Time complexity:\\n$O(n)$\\n\\n- Space complexity:\\n$O(n)$\\n\\n# Code\\n```\\nclass Solution(object):\\n    def gcd(self, num_1, num_2):\\n        a = min(num_1, num_2)\\n        b = max(num_1, num_2)\\n        if a == 0:\\n            return b\\n        if a == 1:\\n            return 1\\n        num_1 = b % a\\n        num_2 = a\\n        return self.gcd(num_1, num_2)\\n    \\n    def findValidSplit(self, nums):\\n        pref_prod = [1]\\n        for num in nums:\\n            pref_prod.append(num * pref_prod[-1])\\n        total_prod = pref_prod[-1]\\n        pref_prod = pref_prod[1:-1]\\n        i = 0\\n        while i<len(pref_prod):\\n            prod_1 = pref_prod[i]\\n            prod_2 = total_prod // pref_prod[i]\\n            curr_gcd = self.gcd(prod_1, prod_2)\\n            if curr_gcd == 1:\\n                return i\\n            while i<len(pref_prod) and prod_2%curr_gcd==0:\\n                i += 1\\n                prod_2 /= nums[i]\\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def gcd(self, num_1, num_2):\\n        a = min(num_1, num_2)\\n        b = max(num_1, num_2)\\n        if a == 0:\\n            return b\\n        if a == 1:\\n            return 1\\n        num_1 = b % a\\n        num_2 = a\\n        return self.gcd(num_1, num_2)\\n    \\n    def findValidSplit(self, nums):\\n        pref_prod = [1]\\n        for num in nums:\\n            pref_prod.append(num * pref_prod[-1])\\n        total_prod = pref_prod[-1]\\n        pref_prod = pref_prod[1:-1]\\n        i = 0\\n        while i<len(pref_prod):\\n            prod_1 = pref_prod[i]\\n            prod_2 = total_prod // pref_prod[i]\\n            curr_gcd = self.gcd(prod_1, prod_2)\\n            if curr_gcd == 1:\\n                return i\\n            while i<len(pref_prod) and prod_2%curr_gcd==0:\\n                i += 1\\n                prod_2 /= nums[i]\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267085,
                "title": "c-easy-to-implement-intuitive-approach-with-comments",
                "content": "# Approach\\n- For the product of the two partitions to be coprime, the numbers on the left partition and right partition should not have any common prime factors.\\n-  We will check for each index i whether it can be a valid partition.\\n- For that we will maintain 2 sets, `primeFactors` and `primeFactorsUptoI` that store the prime factors till the current index and the prime factors of the current left partition (curent partition is till index i).\\n- Let\\'s suppose we are at an arbitrary i. For that i we have our `primeFactorsUptoI`. Loop from `j= i+1 to n-1` and check for each index whether the current element has any prime factor common with `primeFactorsUptoI` and simultaneously add the distinct prime factors to `primeFactors`.\\n- If the current element `nums[j]` has factors already present in the left partition, i.e , `primeFactorsUptoI` , it means that this `nums[j]` will have to be in the left partition for the 2 partitions to be coprime.\\n- Hence we move our partition boundary to j ,i.e,` i=j `and do  `primeFactorsUptoI = primeFactors ` since `primeFactors` stores the prime factors of all elements till index j\\n- In the end if j reaches the end of our array, we have found the solution.\\n- The code has been commented for a better understanding\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O(N.sqrt(N))\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //primeFactors stores all the prime factors till the current index j\\n    //suppose our current partition is at index i, we store the prime factors of all the numbers upto i index i primeFactorsUptoI\\n    unordered_set<int>primeFactors,primeFactorsUptoI;\\n    int findValidSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j;\\n        //initial partition at index 0\\n        findCommonFactor(nums[0]);\\n\\n        //the prime factors of nums[0] is stored in primeFactors and is now copied to primeFactorsUptoI\\n        primeFactorsUptoI=primeFactors;\\n        \\n        \\n        int val;\\n        // looping till i=n-2, curr partition is at index i=0\\n        while(i<n-1){\\n            \\n            //j starts from the right half of our current partition\\n            j=i+1;\\n            \\n            \\n            while(j<n){\\n                \\n                // returns true if there are no common factors between nums[j] and primeFactorsUptoI\\n                // if this is true then our curr right half of the partition till index j is co-prime with the left half\\n                if(findCommonFactor(nums[j]))j++;\\n                \\n                // if there is a common factor between nums[j] and primeFactorsUptoI, then it is obvious that nums[j] has to be                   // in the left side of the partition, hence our new partition boundary becomes j and new \\n                // primeFactorsUptoI becomes the current primeFactors set\\n                else {\\n                    i=j;\\n                    primeFactorsUptoI=primeFactors;\\n                    break;\\n                }\\n            }\\n            // if j has reached n that means the current partition is valid\\n            if(j==n)return i;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    //function to find the prime factors of num in sqrt(num) time\\n    // returns true if there are no common factors with the set primeFactorsUptoI\\n    bool findCommonFactor(int num){\\n        \\n        //if num is a prime number itself and is already in the set primeFactorsUptoI\\n        if(primeFactorsUptoI.find(num)!=primeFactorsUptoI.end())return false;\\n        \\n        bool flag=true;\\n        \\n        // if num is divisible by 2 and 2 is already there in the set primeFactorsUptoI\\n        if(num%2==0&&primeFactorsUptoI.find(2)!=primeFactorsUptoI.end())flag=false;\\n        \\n        // if 2 is a factor it will insert it into primeFactors\\n        while(num%2==0){\\n            if(primeFactors.find(2)==primeFactors.end())primeFactors.insert(2);\\n            num/=2;\\n        }\\n            \\n        // similarly for all odd numbers i>=3 and i<=sqrt(num)\\n        for(int i=3;i<=sqrt(num);i+=2){\\n            if(num%i==0&&primeFactorsUptoI.find(i)!=primeFactorsUptoI.end()){\\n                flag=false;\\n                continue;\\n            }\\n            while(num%i==0){\\n                if(primeFactors.find(i)==primeFactors.end())primeFactors.insert(i);\\n                num/=i;\\n            }\\n        }\\n        \\n        // if num is a prime number (other than 2) then it will not be divisible by any of the above numbers\\n        if(num>2)primeFactors.insert(num);\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //primeFactors stores all the prime factors till the current index j\\n    //suppose our current partition is at index i, we store the prime factors of all the numbers upto i index i primeFactorsUptoI\\n    unordered_set<int>primeFactors,primeFactorsUptoI;\\n    int findValidSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j;\\n        //initial partition at index 0\\n        findCommonFactor(nums[0]);\\n\\n        //the prime factors of nums[0] is stored in primeFactors and is now copied to primeFactorsUptoI\\n        primeFactorsUptoI=primeFactors;\\n        \\n        \\n        int val;\\n        // looping till i=n-2, curr partition is at index i=0\\n        while(i<n-1){\\n            \\n            //j starts from the right half of our current partition\\n            j=i+1;\\n            \\n            \\n            while(j<n){\\n                \\n                // returns true if there are no common factors between nums[j] and primeFactorsUptoI\\n                // if this is true then our curr right half of the partition till index j is co-prime with the left half\\n                if(findCommonFactor(nums[j]))j++;\\n                \\n                // if there is a common factor between nums[j] and primeFactorsUptoI, then it is obvious that nums[j] has to be                   // in the left side of the partition, hence our new partition boundary becomes j and new \\n                // primeFactorsUptoI becomes the current primeFactors set\\n                else {\\n                    i=j;\\n                    primeFactorsUptoI=primeFactors;\\n                    break;\\n                }\\n            }\\n            // if j has reached n that means the current partition is valid\\n            if(j==n)return i;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    //function to find the prime factors of num in sqrt(num) time\\n    // returns true if there are no common factors with the set primeFactorsUptoI\\n    bool findCommonFactor(int num){\\n        \\n        //if num is a prime number itself and is already in the set primeFactorsUptoI\\n        if(primeFactorsUptoI.find(num)!=primeFactorsUptoI.end())return false;\\n        \\n        bool flag=true;\\n        \\n        // if num is divisible by 2 and 2 is already there in the set primeFactorsUptoI\\n        if(num%2==0&&primeFactorsUptoI.find(2)!=primeFactorsUptoI.end())flag=false;\\n        \\n        // if 2 is a factor it will insert it into primeFactors\\n        while(num%2==0){\\n            if(primeFactors.find(2)==primeFactors.end())primeFactors.insert(2);\\n            num/=2;\\n        }\\n            \\n        // similarly for all odd numbers i>=3 and i<=sqrt(num)\\n        for(int i=3;i<=sqrt(num);i+=2){\\n            if(num%i==0&&primeFactorsUptoI.find(i)!=primeFactorsUptoI.end()){\\n                flag=false;\\n                continue;\\n            }\\n            while(num%i==0){\\n                if(primeFactors.find(i)==primeFactors.end())primeFactors.insert(i);\\n                num/=i;\\n            }\\n        }\\n        \\n        // if num is a prime number (other than 2) then it will not be divisible by any of the above numbers\\n        if(num>2)primeFactors.insert(num);\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266366,
                "title": "sieve-approach-and",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need two things to solve this: 1) To know whether the number is a prime and to know the content of left and right sets as we go through the array.\\n\\nTo know whether the number is a prime, a fast way is to use the sieve of Eratosthenes algorithm (look it up)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFirst, on primes:\\n\\n* The sieve of Eratosthenes takes O(n * log(n)) to calculate, and we are dealing with numbers up to 1M, so we actually need to be faster\\n* What we can do is this: 1) Calculate all primes up to 1000. 2) As 1K is sqrt of 1M, for any number up to 1M to be a prime, it will need to not be divisible to any prime up to 1K. So we go through all nums in the array, and we use this approach to question whether any number over 1K is a prime 3) We cache responses, so we don\\'t need to calculate the same number twice.\\n\\nOK, we now know how to get whether any number is a prime fast. As we go through the list, we add all primes to the set of all primes that will be our starting \"right\" set of primes. And then on the second pass, we add the primes to the left array, and remove them from the right.\\n\\nHow do we know when to remove them from right? We just remember it as we go through the array in the first pass. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the size of nums array.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    List<Integer> primes = new ArrayList<>();\\n    Map<Integer, Boolean> largeNumsCache = new HashMap<>();\\n    public int findValidSplit(int[] nums) {\\n        primes();\\n        Map<Integer, Integer> lastAppearances = new HashMap<>();\\n        Map<Integer, Set<Integer>> primesPerIndex = new HashMap<>();\\n        Set<Integer> right = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            Set<Integer> iPrimes = primes(nums[i]);\\n            primesPerIndex.put(i, iPrimes);\\n            for (int prime : iPrimes) {\\n                lastAppearances.put(prime, i);\\n            }\\n            right.addAll(iPrimes);\\n        }\\n        Set<Integer> left = new HashSet<>();\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            for (int prime : primesPerIndex.getOrDefault(i, new HashSet<>())) {\\n                left.add(prime);\\n                if (lastAppearances.get(prime) == i) {\\n                    right.remove(prime);\\n                    left.remove(prime);\\n                }\\n            }\\n            Set<Integer> leftCopy = new HashSet<>(left);\\n            leftCopy.removeAll(right);\\n            if (leftCopy.size() == left.size()) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private Set<Integer> primes(int n) {\\n      //  System.out.println(\"Investigating \" + n);\\n        Set<Integer> nPrimes = new HashSet<>();\\n        for (int prime : primes) {\\n            if (prime > n) {\\n                return nPrimes;\\n            }\\n            if (n % prime == 0) {\\n                nPrimes.add(prime);\\n            }\\n        }\\n        if (n > 1000 && isPrime(n)) {\\n          //  System.out.println(\"Adding \" + n + \" as prime\");\\n            nPrimes.add(n);\\n        }\\n        return nPrimes;\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        if (largeNumsCache.containsKey(n)) {\\n            return largeNumsCache.get(n);\\n        }\\n        for (int prime : primes) {\\n            if (n % prime == 0) {\\n            //    System.out.println(n + \" is not a prime\");\\n                largeNumsCache.put(n, false);\\n                return false;\\n            }    \\n        }\\n        largeNumsCache.put(n, true);\\n        return true;\\n    }\\n    \\n    private void primes() {\\n        Set<Integer> notPrime = new HashSet<>();\\n        int max = 1000;\\n        int n = 2;\\n        while (n < max) {\\n            int test = n;\\n            if (!notPrime.contains(test)) {\\n                primes.add(test);\\n                while (test < max) {\\n                    test += n;\\n                    notPrime.add(test);\\n                }\\n            }\\n            n++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> primes = new ArrayList<>();\\n    Map<Integer, Boolean> largeNumsCache = new HashMap<>();\\n    public int findValidSplit(int[] nums) {\\n        primes();\\n        Map<Integer, Integer> lastAppearances = new HashMap<>();\\n        Map<Integer, Set<Integer>> primesPerIndex = new HashMap<>();\\n        Set<Integer> right = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            Set<Integer> iPrimes = primes(nums[i]);\\n            primesPerIndex.put(i, iPrimes);\\n            for (int prime : iPrimes) {\\n                lastAppearances.put(prime, i);\\n            }\\n            right.addAll(iPrimes);\\n        }\\n        Set<Integer> left = new HashSet<>();\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            for (int prime : primesPerIndex.getOrDefault(i, new HashSet<>())) {\\n                left.add(prime);\\n                if (lastAppearances.get(prime) == i) {\\n                    right.remove(prime);\\n                    left.remove(prime);\\n                }\\n            }\\n            Set<Integer> leftCopy = new HashSet<>(left);\\n            leftCopy.removeAll(right);\\n            if (leftCopy.size() == left.size()) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private Set<Integer> primes(int n) {\\n      //  System.out.println(\"Investigating \" + n);\\n        Set<Integer> nPrimes = new HashSet<>();\\n        for (int prime : primes) {\\n            if (prime > n) {\\n                return nPrimes;\\n            }\\n            if (n % prime == 0) {\\n                nPrimes.add(prime);\\n            }\\n        }\\n        if (n > 1000 && isPrime(n)) {\\n          //  System.out.println(\"Adding \" + n + \" as prime\");\\n            nPrimes.add(n);\\n        }\\n        return nPrimes;\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        if (largeNumsCache.containsKey(n)) {\\n            return largeNumsCache.get(n);\\n        }\\n        for (int prime : primes) {\\n            if (n % prime == 0) {\\n            //    System.out.println(n + \" is not a prime\");\\n                largeNumsCache.put(n, false);\\n                return false;\\n            }    \\n        }\\n        largeNumsCache.put(n, true);\\n        return true;\\n    }\\n    \\n    private void primes() {\\n        Set<Integer> notPrime = new HashSet<>();\\n        int max = 1000;\\n        int n = 2;\\n        while (n < max) {\\n            int test = n;\\n            if (!notPrime.contains(test)) {\\n                primes.add(test);\\n                while (test < max) {\\n                    test += n;\\n                    notPrime.add(test);\\n                }\\n            }\\n            n++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266074,
                "title": "first-and-last-appearnce-sieve",
                "content": "python version of [Prime Intervals vs. Count Primes](https://leetcode.com/problems/split-the-array-to-make-coprime-products/solutions/3258070/prime-intervals-vs-count-primes/)\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def findValidSplit(self, nums: list[int]) -> int:\\n        n = len(nums)\\n        pi = {}\\n        line = [0] * n\\n        for i in range(len(nums)):\\n            for p in self.primeFactorize(nums[i]):\\n                if p not in pi:\\n                    pi[p] = i\\n                line[pi[p]] += 1\\n                line[i] -= 1\\n        sum = 0\\n        for i in range(n-1):\\n            sum += line[i]\\n            if sum == 0: return i\\n        return -1\\n\\n\\n    def primeFactorize(self, n: int) -> list[int]:\\n        res = []\\n        if n%2 == 0:\\n            res.append(2)\\n            while n%2 == 0: n /= 2\\n        if n%3 == 0:\\n            res.append(3)\\n            while n%3 == 0: n /= 3\\n        i=6\\n        while i<1000 and n > 1:\\n            i1, i2 = i-1, i+1\\n            if n%(i1) == 0:\\n                res.append(i1)\\n                while n%i1 == 0 : n /= i1\\n            if n%(i2) == 0:\\n                res.append(i2)\\n                while n%i2 == 0 : n /= i2\\n            i+=6\\n        if n>1: res.append(n)\\n        return res\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def findValidSplit(self, nums: list[int]) -> int:\\n        n = len(nums)\\n        pi = {}\\n        line = [0] * n\\n        for i in range(len(nums)):\\n            for p in self.primeFactorize(nums[i]):\\n                if p not in pi:\\n                    pi[p] = i\\n                line[pi[p]] += 1\\n                line[i] -= 1\\n        sum = 0\\n        for i in range(n-1):\\n            sum += line[i]\\n            if sum == 0: return i\\n        return -1\\n\\n\\n    def primeFactorize(self, n: int) -> list[int]:\\n        res = []\\n        if n%2 == 0:\\n            res.append(2)\\n            while n%2 == 0: n /= 2\\n        if n%3 == 0:\\n            res.append(3)\\n            while n%3 == 0: n /= 3\\n        i=6\\n        while i<1000 and n > 1:\\n            i1, i2 = i-1, i+1\\n            if n%(i1) == 0:\\n                res.append(i1)\\n                while n%i1 == 0 : n /= i1\\n            if n%(i2) == 0:\\n                res.append(i2)\\n                while n%i2 == 0 : n /= i2\\n            i+=6\\n        if n>1: res.append(n)\\n        return res\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265840,
                "title": "easy-to-understand-c-prime-factorization-simple-solution",
                "content": "```\\nclass Solution {\\n    int n=1e6+1;\\n    vector<int> spf;\\n    void seive(){\\n        spf.resize(n);\\n        spf[1]=1;\\n        for(int i=2; i<n; i++) spf[i]=i;\\n        for(int i=2; i<n; i+=2)spf[i]=2;\\n        for(int i=3; i*i<n; i++){\\n            if(spf[i]==i){\\n                for(int j=2*i; j<n; j+=i){\\n                    if(spf[j]==j) spf[j]=i;\\n                }\\n            }\\n        }\\n    }\\n    vector<int> getFactorization(int x){\\n        vector<int> p_factor;\\n        while (x != 1)\\n        {\\n            p_factor.push_back(spf[x]);\\n            x = x / spf[x];\\n        }\\n        return p_factor;\\n    }\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        seive();\\n        unordered_map<int, int> m1, m2;\\n        for(int i=0; i<nums.size(); i++){\\n            vector<int> p_factors=getFactorization(nums[i]);\\n            for(auto j : p_factors){\\n                m1[j]++;\\n            }\\n        }\\n        for(int i=0; i<nums.size()-1; i++){\\n            vector<int> s=getFactorization(nums[i]);\\n            for(auto j : s){\\n                m2[j]++;\\n                m1[j]--;\\n            }\\n            bool flag=true;\\n            for(auto j : m2){\\n                if(m1[j.first]!=0){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                return i;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    int n=1e6+1;\\n    vector<int> spf;\\n    void seive(){\\n        spf.resize(n);\\n        spf[1]=1;\\n        for(int i=2; i<n; i++) spf[i]=i;\\n        for(int i=2; i<n; i+=2)spf[i]=2;\\n        for(int i=3; i*i<n; i++){\\n            if(spf[i]==i){\\n                for(int j=2*i; j<n; j+=i){\\n                    if(spf[j]==j) spf[j]=i;\\n                }\\n            }\\n        }\\n    }\\n    vector<int> getFactorization(int x){\\n        vector<int> p_factor;\\n        while (x != 1)\\n        {\\n            p_factor.push_back(spf[x]);\\n            x = x / spf[x];\\n        }\\n        return p_factor;\\n    }\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        seive();\\n        unordered_map<int, int> m1, m2;\\n        for(int i=0; i<nums.size(); i++){\\n            vector<int> p_factors=getFactorization(nums[i]);\\n            for(auto j : p_factors){\\n                m1[j]++;\\n            }\\n        }\\n        for(int i=0; i<nums.size()-1; i++){\\n            vector<int> s=getFactorization(nums[i]);\\n            for(auto j : s){\\n                m2[j]++;\\n                m1[j]--;\\n            }\\n            bool flag=true;\\n            for(auto j : m2){\\n                if(m1[j.first]!=0){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                return i;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265810,
                "title": "max-index-approach-most-optimized",
                "content": "# Intuition\\nUsing the farthest index approach, where the only way to make subarray not coprime is by putting all the elements having common factor into one subarray\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)*sqrt(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(sqrt(n))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int, int> mp;\\n        \\n        for(int i = 0; i < n; i++){\\n            int temp = nums[i];\\n            while(temp%2 == 0) mp[2] = max(mp[2], i), temp /= 2;\\n            \\n            for(int j = 3; j*j <= temp; j += 2){\\n                while(temp%j == 0) mp[j] = max(mp[j], i), temp /= j;\\n            }\\n            if(temp > 1) mp[temp] = max(mp[temp], i);\\n        }\\n                \\n        int maxID = 0;\\n        for(int i = 0; i < n-1; i++){\\n            while(nums[i]%2 == 0) maxID = max(maxID, mp[2]), nums[i] /= 2;\\n            \\n            for(int j = 3; j*j <= nums[i]; j++){\\n                while(nums[i]%j == 0) maxID = max(maxID, mp[j]), nums[i] /= j;\\n            }\\n            \\n            if(nums[i] > 1) maxID = max(maxID, mp[nums[i]]);\\n            \\n            if(i == maxID) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int, int> mp;\\n        \\n        for(int i = 0; i < n; i++){\\n            int temp = nums[i];\\n            while(temp%2 == 0) mp[2] = max(mp[2], i), temp /= 2;\\n            \\n            for(int j = 3; j*j <= temp; j += 2){\\n                while(temp%j == 0) mp[j] = max(mp[j], i), temp /= j;\\n            }\\n            if(temp > 1) mp[temp] = max(mp[temp], i);\\n        }\\n                \\n        int maxID = 0;\\n        for(int i = 0; i < n-1; i++){\\n            while(nums[i]%2 == 0) maxID = max(maxID, mp[2]), nums[i] /= 2;\\n            \\n            for(int j = 3; j*j <= nums[i]; j++){\\n                while(nums[i]%j == 0) maxID = max(maxID, mp[j]), nums[i] /= j;\\n            }\\n            \\n            if(nums[i] > 1) maxID = max(maxID, mp[nums[i]]);\\n            \\n            if(i == maxID) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265749,
                "title": "understandable-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> last(n,-1);\\n        map<int,int> mp;\\n        for(int i=n-1;i>=0;i--){\\n            int ma = i;\\n            for(int j=2;j*j<=nums[i];j++){\\n                if(nums[i]%j==0){\\n                    while(nums[i]%j==0) nums[i]/=j;\\n                    if(mp.find(j)!=mp.end()) ma = max(ma,mp[j]);\\n                    else mp[j] = i;\\n                }\\n            }    \\n            if(nums[i]>1){\\n                if(mp.find(nums[i])!=mp.end()) ma = max(ma,mp[nums[i]]);\\n                else mp[nums[i]] = i;\\n            }\\n            last[i] = ma;\\n        }\\n        int prev = last[0];\\n        if(prev==n-1) return -1;\\n        for(int i=1;i<n;i++){\\n            if(last[i]==n-1) break;    \\n            prev = max(prev,last[i]);\\n            if(prev==i) return prev;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> last(n,-1);\\n        map<int,int> mp;\\n        for(int i=n-1;i>=0;i--){\\n            int ma = i;\\n            for(int j=2;j*j<=nums[i];j++){\\n                if(nums[i]%j==0){\\n                    while(nums[i]%j==0) nums[i]/=j;\\n                    if(mp.find(j)!=mp.end()) ma = max(ma,mp[j]);\\n                    else mp[j] = i;\\n                }\\n            }    \\n            if(nums[i]>1){\\n                if(mp.find(nums[i])!=mp.end()) ma = max(ma,mp[nums[i]]);\\n                else mp[nums[i]] = i;\\n            }\\n            last[i] = ma;\\n        }\\n        int prev = last[0];\\n        if(prev==n-1) return -1;\\n        for(int i=1;i<n;i++){\\n            if(last[i]==n-1) break;    \\n            prev = max(prev,last[i]);\\n            if(prev==i) return prev;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265716,
                "title": "optimal-java-solution-using-seive",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n--> Try to get the minimum index(x) possible such that all the prime divisors of elements having index <=x are different from all the prime divisors of element having index > x.\\n--> So for every prime divisor d, find the maximum index x such that element at index x has a prime divisor d. \\n--> let say index x and y both has a prime divisor d and x<y. If you take x in the left split, then index y has to be also put in the left split. otherwise gcd will be d. \\n--> by this logic try finding the anser. \\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValidSplit(int[] arr) {\\n         \\n        int n= arr.length;\\n        int[] fd = _seive((int)1e6);\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            int x = arr[i];\\n            while(x>1){\\n                int d = fd[x];\\n                map.put(d,i);\\n                x/=d;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(ans < i)return ans;\\n            int x = arr[i];\\n            while(x>1){\\n                int d = fd[x];\\n                ans = Math.max(ans,map.get(d));\\n                x/=d;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    private int[] _seive(int mx){\\n        int[] fd = new int[mx+1];\\n        for(int i=1;i<=mx;i++)fd[i] = i;\\n        for(int i=2;i<=mx;i++)\\n            if(fd[i]==i)\\n                for(int j= 2*i; j<=mx; j += i)\\n                    if(fd[j]==j)fd[j] = i;\\n        return fd;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValidSplit(int[] arr) {\\n         \\n        int n= arr.length;\\n        int[] fd = _seive((int)1e6);\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            int x = arr[i];\\n            while(x>1){\\n                int d = fd[x];\\n                map.put(d,i);\\n                x/=d;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(ans < i)return ans;\\n            int x = arr[i];\\n            while(x>1){\\n                int d = fd[x];\\n                ans = Math.max(ans,map.get(d));\\n                x/=d;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    private int[] _seive(int mx){\\n        int[] fd = new int[mx+1];\\n        for(int i=1;i<=mx;i++)fd[i] = i;\\n        for(int i=2;i<=mx;i++)\\n            if(fd[i]==i)\\n                for(int j= 2*i; j<=mx; j += i)\\n                    if(fd[j]==j)fd[j] = i;\\n        return fd;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265690,
                "title": "golang-62-ms-6-1-mb",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n# Code\\n```\\nvar primes = []uint16{\\n\\t2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\\n\\t73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173,\\n\\t179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281,\\n\\t283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409,\\n\\t419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541,\\n\\t547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659,\\n\\t661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809,\\n\\t811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941,\\n\\t947, 953, 967, 971, 977, 983, 991, 997,\\n}\\n\\nfunc factorize(factors map[uint32]uint16, num uint32) {\\n\\tfor i, sqrt := 0, uint16(math.Sqrt(float64(num))); i < len(primes) && primes[i] <= sqrt; i++ {\\n\\t\\tvar recalculateSqrt bool\\n\\t\\tfor num%uint32(primes[i]) == 0 {\\n\\t\\t\\tfactors[uint32(primes[i])]++\\n\\t\\t\\tnum /= uint32(primes[i])\\n\\t\\t\\trecalculateSqrt = true\\n\\t\\t}\\n\\t\\tif recalculateSqrt {\\n\\t\\t\\tsqrt = uint16(math.Sqrt(float64(num)))\\n\\t\\t}\\n\\t}\\n\\tif num != 1 {\\n\\t\\tfactors[num]++\\n\\t}\\n}\\n\\nfunc applyFactors(prefix map[uint32]struct{}, suffix map[uint32]uint16, num uint32) {\\n\\tfor i, sqrt := 0, uint16(math.Sqrt(float64(num))); i < len(primes) && primes[i] <= sqrt; i++ {\\n\\t\\tvar recalculateSqrt bool\\n\\t\\tfor num%uint32(primes[i]) == 0 {\\n\\t\\t\\tif count := suffix[uint32(primes[i])]; count != 1 {\\n\\t\\t\\t\\tprefix[uint32(primes[i])] = struct{}{}\\n\\t\\t\\t\\tsuffix[uint32(primes[i])] = count - 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdelete(prefix, uint32(primes[i]))\\n\\t\\t\\t\\tdelete(suffix, uint32(primes[i]))\\n\\t\\t\\t}\\n\\t\\t\\tnum /= uint32(primes[i])\\n\\t\\t\\trecalculateSqrt = true\\n\\t\\t}\\n\\t\\tif recalculateSqrt {\\n\\t\\t\\tsqrt = uint16(math.Sqrt(float64(num)))\\n\\t\\t}\\n\\t}\\n\\tif num != 1 {\\n\\t\\tif count := suffix[num]; count != 1 {\\n\\t\\t\\tprefix[num] = struct{}{}\\n\\t\\t\\tsuffix[num] = count - 1\\n\\t\\t} else {\\n\\t\\t\\tdelete(prefix, num)\\n\\t\\t\\tdelete(suffix, num)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc findValidSplit(nums []int) int {\\n\\tsuffix := make(map[uint32]uint16)\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tfactorize(suffix, uint32(nums[i]))\\n\\t}\\n\\tprefix := make(map[uint32]struct{})\\n\\tfor i, iEnd := 0, len(nums)-1; i < iEnd; i++ {\\n\\t\\tapplyFactors(prefix, suffix, uint32(nums[i]))\\n\\t\\tif len(prefix) == 0 {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nvar primes = []uint16{\\n\\t2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\\n\\t73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173,\\n\\t179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281,\\n\\t283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409,\\n\\t419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541,\\n\\t547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659,\\n\\t661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809,\\n\\t811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941,\\n\\t947, 953, 967, 971, 977, 983, 991, 997,\\n}\\n\\nfunc factorize(factors map[uint32]uint16, num uint32) {\\n\\tfor i, sqrt := 0, uint16(math.Sqrt(float64(num))); i < len(primes) && primes[i] <= sqrt; i++ {\\n\\t\\tvar recalculateSqrt bool\\n\\t\\tfor num%uint32(primes[i]) == 0 {\\n\\t\\t\\tfactors[uint32(primes[i])]++\\n\\t\\t\\tnum /= uint32(primes[i])\\n\\t\\t\\trecalculateSqrt = true\\n\\t\\t}\\n\\t\\tif recalculateSqrt {\\n\\t\\t\\tsqrt = uint16(math.Sqrt(float64(num)))\\n\\t\\t}\\n\\t}\\n\\tif num != 1 {\\n\\t\\tfactors[num]++\\n\\t}\\n}\\n\\nfunc applyFactors(prefix map[uint32]struct{}, suffix map[uint32]uint16, num uint32) {\\n\\tfor i, sqrt := 0, uint16(math.Sqrt(float64(num))); i < len(primes) && primes[i] <= sqrt; i++ {\\n\\t\\tvar recalculateSqrt bool\\n\\t\\tfor num%uint32(primes[i]) == 0 {\\n\\t\\t\\tif count := suffix[uint32(primes[i])]; count != 1 {\\n\\t\\t\\t\\tprefix[uint32(primes[i])] = struct{}{}\\n\\t\\t\\t\\tsuffix[uint32(primes[i])] = count - 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdelete(prefix, uint32(primes[i]))\\n\\t\\t\\t\\tdelete(suffix, uint32(primes[i]))\\n\\t\\t\\t}\\n\\t\\t\\tnum /= uint32(primes[i])\\n\\t\\t\\trecalculateSqrt = true\\n\\t\\t}\\n\\t\\tif recalculateSqrt {\\n\\t\\t\\tsqrt = uint16(math.Sqrt(float64(num)))\\n\\t\\t}\\n\\t}\\n\\tif num != 1 {\\n\\t\\tif count := suffix[num]; count != 1 {\\n\\t\\t\\tprefix[num] = struct{}{}\\n\\t\\t\\tsuffix[num] = count - 1\\n\\t\\t} else {\\n\\t\\t\\tdelete(prefix, num)\\n\\t\\t\\tdelete(suffix, num)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc findValidSplit(nums []int) int {\\n\\tsuffix := make(map[uint32]uint16)\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tfactorize(suffix, uint32(nums[i]))\\n\\t}\\n\\tprefix := make(map[uint32]struct{})\\n\\tfor i, iEnd := 0, len(nums)-1; i < iEnd; i++ {\\n\\t\\tapplyFactors(prefix, suffix, uint32(nums[i]))\\n\\t\\tif len(prefix) == 0 {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3265519,
                "title": "nlogn-prefix-suffix-map",
                "content": "# Approach\\nUse prefix and suffix map for storing count of prime factors on each side. Use transferring technique from suffix to prefix while iterating to avoid **TLE**.\\n\\n# Complexity\\n- Time complexity: O(NLogN)\\n\\n- Space complexity: O(NLogN)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    void getFact(int n,unordered_map<int,int> &mp){\\n        for(int i=2;i*i<=n;i++){\\n            while(n%i==0)\\n                mp[i]++,n/=i;\\n        }\\n        if(n!=1)mp[n]++;\\n    }\\n\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int> suff;\\n        // suffix map which will store the changing suffix when\\n        // we will be iterating for the index.\\n        unordered_map<int,unordered_map<int,int>> intToFact;\\n        // intToFact -> stores the factorial and their count\\n        // in the map, for fast retrieval later-wise.\\n        for(auto &it:nums){\\n            unordered_map<int,int> temp;\\n            if(intToFact.count(it))\\n                temp=intToFact[it];\\n            else\\n                getFact(it,temp),intToFact[it]=temp;\\n            for(auto &it:temp){\\n                suff[it.first]+=it.second;\\n            }\\n        }\\n        unordered_map<int,int> pref;\\n        // prefix map which stores running prime factors\\n        for(int i=0;i<n-1;i++){\\n            unordered_map<int,int> temp=intToFact[nums[i]];\\n            for(auto &it:temp){\\n                pref[it.first]+=it.second;\\n                suff[it.first]-=it.second;\\n                // MOST IMPORTANT PART \\uD83D\\uDCDD\\n                // transfering elements from suffix to prefix\\n                if(suff[it.first]<=0)\\n                    suff.erase(it.first);\\n                    // if count moves to zero in suffix\\n                    // means it is not more present in \\n                    // suffix this element.\\n            }\\n            bool found=true;\\n            for(auto &it:pref){\\n                if(suff.count(it.first)){\\n                    // checking any element which is present in\\n                    // prefix but not in the suffix.\\n                    found=false;\\n                    break;\\n                }\\n            }\\n            if(found)return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n\\n    void getFact(int n,unordered_map<int,int> &mp){\\n        for(int i=2;i*i<=n;i++){\\n            while(n%i==0)\\n                mp[i]++,n/=i;\\n        }\\n        if(n!=1)mp[n]++;\\n    }\\n\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int> suff;\\n        // suffix map which will store the changing suffix when\\n        // we will be iterating for the index.\\n        unordered_map<int,unordered_map<int,int>> intToFact;\\n        // intToFact -> stores the factorial and their count\\n        // in the map, for fast retrieval later-wise.\\n        for(auto &it:nums){\\n            unordered_map<int,int> temp;\\n            if(intToFact.count(it))\\n                temp=intToFact[it];\\n            else\\n                getFact(it,temp),intToFact[it]=temp;\\n            for(auto &it:temp){\\n                suff[it.first]+=it.second;\\n            }\\n        }\\n        unordered_map<int,int> pref;\\n        // prefix map which stores running prime factors\\n        for(int i=0;i<n-1;i++){\\n            unordered_map<int,int> temp=intToFact[nums[i]];\\n            for(auto &it:temp){\\n                pref[it.first]+=it.second;\\n                suff[it.first]-=it.second;\\n                // MOST IMPORTANT PART \\uD83D\\uDCDD\\n                // transfering elements from suffix to prefix\\n                if(suff[it.first]<=0)\\n                    suff.erase(it.first);\\n                    // if count moves to zero in suffix\\n                    // means it is not more present in \\n                    // suffix this element.\\n            }\\n            bool found=true;\\n            for(auto &it:pref){\\n                if(suff.count(it.first)){\\n                    // checking any element which is present in\\n                    // prefix but not in the suffix.\\n                    found=false;\\n                    break;\\n                }\\n            }\\n            if(found)return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264897,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstep 1. generate prime factors of all elements in array nums in a loop and keep updating the latest index for all prime numbers for each element in nums\\nstep 2. run a for loop on the array of nums again but this time check the last index for all the prime numbers for each element, the last index of the prime factor was saved in step 1, and when we reach an element in nums which has all it\\'s prime factors\\'s last index on the current element, that element is the last element of the first half, and that index is where we can split it\\n\\n# Complexity\\n- Time complexity:\\n- O(N)log(M)\\n\\n# Code\\n```\\nfrom typing import List\\ndef primefactors(n):\\n    factors = []\\n    primes = [True] * (int(n ** 0.5) + 1)\\n    for i in range(2, int(n ** 0.5) + 1):\\n        if primes[i]:\\n            for j in range(i * i, int(n ** 0.5) + 1, i):\\n                primes[j] = False\\n    for i in range(2, int(n ** 0.5) + 1):\\n        if primes[i]:\\n            while n % i == 0:\\n                factors.append(i)\\n                n //= i\\n    if n > 1:\\n        factors.append(n)\\n    return factors\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        lastindex = {}\\n        store = {}\\n        for i,x in enumerate(nums):\\n            b = primefactors(x)\\n            store[x] = b\\n            for j in b:\\n                lastindex[j] = i\\n        min_index = 0\\n        i = 0\\n        while i <= min_index:\\n            for x in store[nums[i]]:\\n                if lastindex[x] > min_index:\\n                    min_index = lastindex[x]\\n            i+= 1\\n        if min_index == len(nums)-1:\\n            return -1\\n        return min_index\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\ndef primefactors(n):\\n    factors = []\\n    primes = [True] * (int(n ** 0.5) + 1)\\n    for i in range(2, int(n ** 0.5) + 1):\\n        if primes[i]:\\n            for j in range(i * i, int(n ** 0.5) + 1, i):\\n                primes[j] = False\\n    for i in range(2, int(n ** 0.5) + 1):\\n        if primes[i]:\\n            while n % i == 0:\\n                factors.append(i)\\n                n //= i\\n    if n > 1:\\n        factors.append(n)\\n    return factors\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        lastindex = {}\\n        store = {}\\n        for i,x in enumerate(nums):\\n            b = primefactors(x)\\n            store[x] = b\\n            for j in b:\\n                lastindex[j] = i\\n        min_index = 0\\n        i = 0\\n        while i <= min_index:\\n            for x in store[nums[i]]:\\n                if lastindex[x] > min_index:\\n                    min_index = lastindex[x]\\n            i+= 1\\n        if min_index == len(nums)-1:\\n            return -1\\n        return min_index\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264714,
                "title": "c-overlapping-the-range-of-index-for-every-prime-divisors",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> pre(){\\n        vector<bool> prime(1000001,1);\\n        for(int i=2;i*i<=1000000;i++){\\n            if(prime[i]==0) continue;\\n            for(int j=i*i;j<=1000000;j+=i){\\n                prime[j]=0;\\n            }\\n        }\\n\\n        return prime;\\n    }\\n\\n    int findValidSplit(vector<int>& nums) {\\n        if(nums.size()==1) return -1;\\n        \\n        // all prime between 1 and 1e6\\n        vector<bool> prime=pre();\\n\\n        //store all min and max indexes for all divisor primes.\\n        unordered_map<int,int> mn,mx;\\n        for(int i=0;i<nums.size();i++){\\n            for(int k=2;k*k<=nums[i];k++){\\n                if(nums[i]%k) continue;\\n                if(prime[k]){\\n                    if(mn.count(k)==0) mn[k]=i;\\n                    mx[k]=i;\\n                }\\n                \\n                int snd=nums[i]/k;\\n                if(snd!=k && prime[snd]){\\n                    if(mn.count(snd)==0) mn[snd]=i;\\n                    mx[snd]=i;\\n                }\\n            }\\n            if(prime[nums[i]]){\\n                if(mn.count(nums[i])==0) mn[nums[i]]=i;\\n                mx[nums[i]]=i;\\n            }\\n        }\\n        \\n        //store intervals {min,max} of every prime divisors in an array\\n        vector<pair<int,int>> v;\\n        for(auto &[a,b]: mn){\\n            if(a!=1) v.push_back({mn[a],mx[a]});\\n        }\\n        //sort the array\\n        sort(v.begin(),v.end());\\n        // for(auto &k: v) cout<<k.first<<\" \"<<k.second<<endl;\\n\\n        if(!v.size() || v[0].first>0) return 0;\\n        //find the index where no overlapping \\n        int right_most=v[0].second;\\n        for(int i=1;i<v.size();i++){\\n            if(v[i].first>right_most) return right_most;\\n            right_most=max(right_most,v[i].second);\\n        }\\n        if(right_most<nums.size()-1) return right_most;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> pre(){\\n        vector<bool> prime(1000001,1);\\n        for(int i=2;i*i<=1000000;i++){\\n            if(prime[i]==0) continue;\\n            for(int j=i*i;j<=1000000;j+=i){\\n                prime[j]=0;\\n            }\\n        }\\n\\n        return prime;\\n    }\\n\\n    int findValidSplit(vector<int>& nums) {\\n        if(nums.size()==1) return -1;\\n        \\n        // all prime between 1 and 1e6\\n        vector<bool> prime=pre();\\n\\n        //store all min and max indexes for all divisor primes.\\n        unordered_map<int,int> mn,mx;\\n        for(int i=0;i<nums.size();i++){\\n            for(int k=2;k*k<=nums[i];k++){\\n                if(nums[i]%k) continue;\\n                if(prime[k]){\\n                    if(mn.count(k)==0) mn[k]=i;\\n                    mx[k]=i;\\n                }\\n                \\n                int snd=nums[i]/k;\\n                if(snd!=k && prime[snd]){\\n                    if(mn.count(snd)==0) mn[snd]=i;\\n                    mx[snd]=i;\\n                }\\n            }\\n            if(prime[nums[i]]){\\n                if(mn.count(nums[i])==0) mn[nums[i]]=i;\\n                mx[nums[i]]=i;\\n            }\\n        }\\n        \\n        //store intervals {min,max} of every prime divisors in an array\\n        vector<pair<int,int>> v;\\n        for(auto &[a,b]: mn){\\n            if(a!=1) v.push_back({mn[a],mx[a]});\\n        }\\n        //sort the array\\n        sort(v.begin(),v.end());\\n        // for(auto &k: v) cout<<k.first<<\" \"<<k.second<<endl;\\n\\n        if(!v.size() || v[0].first>0) return 0;\\n        //find the index where no overlapping \\n        int right_most=v[0].second;\\n        for(int i=1;i<v.size();i++){\\n            if(v[i].first>right_most) return right_most;\\n            right_most=max(right_most,v[i].second);\\n        }\\n        if(right_most<nums.size()-1) return right_most;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3264219,
                "title": "prime-factors",
                "content": "# Code\\n```\\nclass Solution {\\n    set<int> prime(int n){\\n        set<int> s;\\n        for(int i=2;i*i<=n;i++){\\n            if(!(n%i)){\\n            s.insert(i);\\n            n/=i;\\n            }\\n        }\\n        if(n>1) s.insert(n);\\n        return s;\\n    }\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        vector<set<int>> vec;\\n        int n=nums.size();\\n\\n        for(auto i : nums){\\n            auto set = prime(i); // storing prime factors of each number at respective index \\n            vec.push_back(set);\\n        }\\n\\n        map<int,int> map; // storing last index of each occuring prime factors\\n        for(int i=0;i<n;i++){\\n            for(auto j:vec[i]){\\n                map[j]=i;\\n            }\\n        }\\n\\n        int longend = 1; // current index\\n        for(int i = 0; i < n - 1; i++){\\n            for(auto j: vec[i]){\\n                longend = max(longend, map[j]);\\n                if(i == longend){  //if current index is equal to last index of prime factor\\n                    return i;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    set<int> prime(int n){\\n        set<int> s;\\n        for(int i=2;i*i<=n;i++){\\n            if(!(n%i)){\\n            s.insert(i);\\n            n/=i;\\n            }\\n        }\\n        if(n>1) s.insert(n);\\n        return s;\\n    }\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        vector<set<int>> vec;\\n        int n=nums.size();\\n\\n        for(auto i : nums){\\n            auto set = prime(i); // storing prime factors of each number at respective index \\n            vec.push_back(set);\\n        }\\n\\n        map<int,int> map; // storing last index of each occuring prime factors\\n        for(int i=0;i<n;i++){\\n            for(auto j:vec[i]){\\n                map[j]=i;\\n            }\\n        }\\n\\n        int longend = 1; // current index\\n        for(int i = 0; i < n - 1; i++){\\n            for(auto j: vec[i]){\\n                longend = max(longend, map[j]);\\n                if(i == longend){  //if current index is equal to last index of prime factor\\n                    return i;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263535,
                "title": "python-3-solution-beats-100-time-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe fact function will generate all prime factors of a number and returns as an array and stored in ***arr***. And freq will store frequency of each factor of all the numbers. Then loop starts from i=0 and curr dict will store frequency of factors of product of numbers upto i. If both freq becomes equal, it means that this factor is no longer present in suffix product. *Common* counts the number of common factors and if it becomes zero, we return i.\\n\\n# Complexity\\n- Time complexity: O(n*sqrt(m))     --> m = max(nums)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom math import sqrt\\n\\n\\nclass Solution:\\n    def fact(self, n):\\n        res = []\\n        if n == 1:\\n            return res\\n        while not n % 2:\\n            res.append(2)\\n            n //= 2\\n        for i in range(3, int(sqrt(n)) + 1, 2):\\n            while not n % i:\\n                res.append(i)\\n                n //= i\\n        if n > 1:\\n            res.append(n)\\n        return res\\n\\n    def findValidSplit(self, nums):\\n        freq = {}\\n        arr = []\\n        for i in nums:\\n            v = self.fact(i)\\n            arr.append(v)\\n            for j in v:\\n                if j not in freq:\\n                    freq[j] = 0\\n                freq[j] += 1\\n        curr = dict()\\n        common = 0\\n\\n        for i in range(len(nums) - 1):\\n            for a in arr[i]:\\n                if a not in curr:\\n                    curr[a] = 0\\n                    common += 1\\n                curr[a] += 1\\n                if curr[a] == freq[a]:\\n                    common -= 1\\n                if not common:\\n                    return i\\n    \\n        return -1\\n\\n\\n```\\n\\nHappy Coding !! :)\\nPlz upvote if you like this solution !",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import sqrt\\n\\n\\nclass Solution:\\n    def fact(self, n):\\n        res = []\\n        if n == 1:\\n            return res\\n        while not n % 2:\\n            res.append(2)\\n            n //= 2\\n        for i in range(3, int(sqrt(n)) + 1, 2):\\n            while not n % i:\\n                res.append(i)\\n                n //= i\\n        if n > 1:\\n            res.append(n)\\n        return res\\n\\n    def findValidSplit(self, nums):\\n        freq = {}\\n        arr = []\\n        for i in nums:\\n            v = self.fact(i)\\n            arr.append(v)\\n            for j in v:\\n                if j not in freq:\\n                    freq[j] = 0\\n                freq[j] += 1\\n        curr = dict()\\n        common = 0\\n\\n        for i in range(len(nums) - 1):\\n            for a in arr[i]:\\n                if a not in curr:\\n                    curr[a] = 0\\n                    common += 1\\n                curr[a] += 1\\n                if curr[a] == freq[a]:\\n                    common -= 1\\n                if not common:\\n                    return i\\n    \\n        return -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262776,
                "title": "prime-factors-gcd",
                "content": "unordered_map<int,int> m;\\n     unordered_set<int>s;\\n    \\n    \\n    void primeFactors(int n)\\n{\\n    while (n % 2 == 0)\\n    {\\n        m[2]++;\\n        n = n/2;\\n    }\\n \\n    for (int i = 3; i <= sqrt(n); i = i + 2)\\n    {\\n \\n        while (n % i == 0)\\n        {\\n            m[i]++;\\n            n = n/i;\\n        }\\n    }\\n \\n\\n    if (n > 2)\\n        m[n]++;\\n}\\n    \\n    bool  removePrimes(int n)\\n{\\n    while (n % 2 == 0)\\n    {\\n        m[2]--;\\n        s.insert(2);\\n        \\n        if(m[2]==0)\\n            s.erase(2);\\n        \\n        n = n/2;\\n    }\\n \\n    for (int i = 3; i <= sqrt(n); i = i + 2)\\n    {\\n \\n        while (n % i == 0)\\n        {\\n            m[i]--;\\n            s.insert(i);\\n            if(m[i]==0)\\n                s.erase(i);\\n            \\n            n = n/i;\\n        }\\n    }\\n \\n\\n    if (n > 2)\\n    {\\n        m[n]--;\\n        s.insert(n);\\n        \\n        if(m[n]==0)\\n            s.erase(n);\\n    }\\n        \\n        \\n    return s.empty();    \\n}\\n    \\n    \\n    int findValidSplit(vector<int>& nums)\\n    {\\n        for(int i:nums)\\n            primeFactors(i);\\n        \\n        \\n        // for(auto&x:m)\\n        //     cout<<x.first<<\" \"<<x.second<<endl;\\n        \\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(removePrimes(nums[i]))\\n                return i;\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "unordered_map<int,int> m;\\n     unordered_set<int>s;\\n    \\n    \\n    void primeFactors(int n)\\n{\\n    while (n % 2 == 0)\\n    {\\n        m[2]++;\\n        n = n/2;\\n    }\\n \\n    for (int i = 3; i <= sqrt(n); i = i + 2)\\n    {\\n \\n        while (n % i == 0)\\n        {\\n            m[i]++;\\n            n = n/i;\\n        }\\n    }\\n \\n\\n    if (n > 2)\\n        m[n]++;\\n}\\n    \\n    bool  removePrimes(int n)\\n{\\n    while (n % 2 == 0)\\n    {\\n        m[2]--;\\n        s.insert(2);\\n        \\n        if(m[2]==0)\\n            s.erase(2);\\n        \\n        n = n/2;\\n    }\\n \\n    for (int i = 3; i <= sqrt(n); i = i + 2)\\n    {\\n \\n        while (n % i == 0)\\n        {\\n            m[i]--;\\n            s.insert(i);\\n            if(m[i]==0)\\n                s.erase(i);\\n            \\n            n = n/i;\\n        }\\n    }\\n \\n\\n    if (n > 2)\\n    {\\n        m[n]--;\\n        s.insert(n);\\n        \\n        if(m[n]==0)\\n            s.erase(n);\\n    }\\n        \\n        \\n    return s.empty();    \\n}\\n    \\n    \\n    int findValidSplit(vector<int>& nums)\\n    {\\n        for(int i:nums)\\n            primeFactors(i);\\n        \\n        \\n        // for(auto&x:m)\\n        //     cout<<x.first<<\" \"<<x.second<<endl;\\n        \\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(removePrimes(nums[i]))\\n                return i;\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "codeTag": "C++"
            },
            {
                "id": 3262743,
                "title": "easy-c-solution-o-n-sqrt-max-element-rightmost-location-of-all-factors",
                "content": "# Approach\\nWe record the right-most index of each prime factor into a map `pos`. Then start from nums[0], we keep updating the right-most index scanned so far. If for all the factors of num, the current right-most index is \"i\" itself, then that means \"i\" is the smallest splitting point.\\n\\n# Complexity\\n- Time complexity: `O(n*sqrt(max_element))`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> primes(n);\\n        unordered_map<int, int> rightMost;\\n        \\n        // store all prime factors of each num in nums in primes.\\n        // and store each prime factor is factor of right most possible num in rightMost\\n        for(int i=0; i<n; i++)\\n        {\\n            int a = nums[i];\\n\\n            // finding all factors of a\\n            for(int j=2; j*j<=a; j++)\\n            {\\n                if(a%j == 0)\\n                {\\n                    // storing all factors of a\\n                    primes[i].push_back(j);\\n\\n                    // storing/updating rightMost possible location of which, j is a factor\\n                    rightMost[j] = i;\\n\\n                    // to avoid multiple j\\'s in primes vector\\n                    while(a%j == 0) {\\n                        a/=j;\\n                    }\\n                }\\n            }\\n\\n            if(a>1)\\n            {\\n                primes[i].push_back(a);\\n                rightMost[a] = i;\\n            }\\n        }\\n\\n        // if all prime factors of a num are present at maximum index i(maximum possible location among all prime factor locations of factors of num)\\n        // then if i is the current num position itself, then \\n            // there is no common factors till i, so *return i*\\n        // Check this for each factor of each num\\n        int mx = -1;\\n        for(int i=0; i<n-1; i++)\\n        {\\n            for(int &j: primes[i])\\n            {\\n                mx = max(mx, rightMost[j]);\\n            }\\n\\n            if(mx == i) return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> primes(n);\\n        unordered_map<int, int> rightMost;\\n        \\n        // store all prime factors of each num in nums in primes.\\n        // and store each prime factor is factor of right most possible num in rightMost\\n        for(int i=0; i<n; i++)\\n        {\\n            int a = nums[i];\\n\\n            // finding all factors of a\\n            for(int j=2; j*j<=a; j++)\\n            {\\n                if(a%j == 0)\\n                {\\n                    // storing all factors of a\\n                    primes[i].push_back(j);\\n\\n                    // storing/updating rightMost possible location of which, j is a factor\\n                    rightMost[j] = i;\\n\\n                    // to avoid multiple j\\'s in primes vector\\n                    while(a%j == 0) {\\n                        a/=j;\\n                    }\\n                }\\n            }\\n\\n            if(a>1)\\n            {\\n                primes[i].push_back(a);\\n                rightMost[a] = i;\\n            }\\n        }\\n\\n        // if all prime factors of a num are present at maximum index i(maximum possible location among all prime factor locations of factors of num)\\n        // then if i is the current num position itself, then \\n            // there is no common factors till i, so *return i*\\n        // Check this for each factor of each num\\n        int mx = -1;\\n        for(int i=0; i<n-1; i++)\\n        {\\n            for(int &j: primes[i])\\n            {\\n                mx = max(mx, rightMost[j]);\\n            }\\n\\n            if(mx == i) return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262499,
                "title": "record-right-most-gcd",
                "content": "# Intuition\\nRecord the right most bound we need to detect. As long as there is a number not coprime with the current number, it is included. We optimize the solution for prime numbers -  if the current number is prime, we used a fast method to detect coprime.\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValidSplit(int[] nums) {\\n        if (nums.length == 1) return -1;\\n\\n        int left = 0;\\n        int right = 1;\\n        while(left < right){\\n            right = getLast(nums, left, right);\\n            if(left < right) left++;\\n        }\\n        return right == nums.length - 1 ? -1 : left;\\n        \\n    }\\n    \\n    private int getLast(int[] nums, int left, int currentRight) {\\n        int ans = currentRight;\\n        boolean isPrime = isPrime(nums[left]);\\n        for (int i = currentRight + 1; i < nums.length; i++) {\\n            if (isPrime) {\\n                if (nums[i] % nums[left] == 0) ans = i;\\n            } else if (gcd(nums[i], nums[left]) != 1) ans = i;\\n        }\\n\\n        return ans;\\n    } \\n\\n    private int gcd(int a, int b) {\\n        int temp = 0;\\n\\t\\twhile (b != 0) {\\n\\t\\t\\ttemp = b;\\n\\t\\t\\tb = a % b;\\n\\t\\t\\ta = temp;\\n\\t\\t}\\n\\t\\treturn a;\\n    }\\n\\n    public boolean isPrime(int n){\\n        if(n < 2) return false;\\n        if(n == 2) return true;\\n        if(n % 2 == 0) return false;\\n        for(int i = 3; i*i <= n; i += 2) if(n%i == 0) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValidSplit(int[] nums) {\\n        if (nums.length == 1) return -1;\\n\\n        int left = 0;\\n        int right = 1;\\n        while(left < right){\\n            right = getLast(nums, left, right);\\n            if(left < right) left++;\\n        }\\n        return right == nums.length - 1 ? -1 : left;\\n        \\n    }\\n    \\n    private int getLast(int[] nums, int left, int currentRight) {\\n        int ans = currentRight;\\n        boolean isPrime = isPrime(nums[left]);\\n        for (int i = currentRight + 1; i < nums.length; i++) {\\n            if (isPrime) {\\n                if (nums[i] % nums[left] == 0) ans = i;\\n            } else if (gcd(nums[i], nums[left]) != 1) ans = i;\\n        }\\n\\n        return ans;\\n    } \\n\\n    private int gcd(int a, int b) {\\n        int temp = 0;\\n\\t\\twhile (b != 0) {\\n\\t\\t\\ttemp = b;\\n\\t\\t\\tb = a % b;\\n\\t\\t\\ta = temp;\\n\\t\\t}\\n\\t\\treturn a;\\n    }\\n\\n    public boolean isPrime(int n){\\n        if(n < 2) return false;\\n        if(n == 2) return true;\\n        if(n % 2 == 0) return false;\\n        for(int i = 3; i*i <= n; i += 2) if(n%i == 0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262410,
                "title": "easy-problem-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define F first\\n#define S second\\nvoid fun( unordered_map<int,int>&mp, int x) {\\n         for(int i=2; i*i<=x; i++) {\\n             while(x%i==0) {\\n                 mp[i]++;\\n                 x/=i;\\n             }\\n         }\\n         if(x>1) mp[x]++;\\n}\\n    int findValidSplit(vector<int>& v) \\n    {\\n        int n=v.size();\\n         unordered_map<int,int>mp;\\n        for(int i=0; i<v.size(); i++) \\n        {\\n            fun(mp,v[i]);\\n        }\\n        unordered_map<int,int>m;\\n        for(int i=0; i<n-1; i++) { \\n             fun(m,v[i]);\\n              unordered_map<int,int>mq;\\n             fun(mq,v[i]);\\n             for(auto it: mq) \\n             {\\n                mp[it.F]-=it.S;\\n                if(mp[it.F]==0) mp.erase(it.F);\\n             }\\n             bool f=true;\\n             for(auto it:m) {\\n                if(mp[it.F]) {\\n                    f=false;\\n                    break;\\n                }\\n             }\\n             if(f) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define F first\\n#define S second\\nvoid fun( unordered_map<int,int>&mp, int x) {\\n         for(int i=2; i*i<=x; i++) {\\n             while(x%i==0) {\\n                 mp[i]++;\\n                 x/=i;\\n             }\\n         }\\n         if(x>1) mp[x]++;\\n}\\n    int findValidSplit(vector<int>& v) \\n    {\\n        int n=v.size();\\n         unordered_map<int,int>mp;\\n        for(int i=0; i<v.size(); i++) \\n        {\\n            fun(mp,v[i]);\\n        }\\n        unordered_map<int,int>m;\\n        for(int i=0; i<n-1; i++) { \\n             fun(m,v[i]);\\n              unordered_map<int,int>mq;\\n             fun(mq,v[i]);\\n             for(auto it: mq) \\n             {\\n                mp[it.F]-=it.S;\\n                if(mp[it.F]==0) mp.erase(it.F);\\n             }\\n             bool f=true;\\n             for(auto it:m) {\\n                if(mp[it.F]) {\\n                    f=false;\\n                    break;\\n                }\\n             }\\n             if(f) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262117,
                "title": "java-solution-prime-factors-hashmap-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {    \\n    public int findValidSplit(int[] nums) {\\n        // \\u6570\\u5B66(\\u6570\\u8BBA) + \\u524D\\u7F00\\u8D28\\u56E0\\u7D20\\u5206\\u89E3\\u54C8\\u5E0C\\u8868 + \\u4F18\\u5316\\n        Map<Integer, Integer> all = new HashMap<>(); // <prime, last_index_num_can_mod_it> of all\\n        for (int i=0; i<nums.length; i++) {\\n            updatePrimes(i, nums[i], all, null);\\n        }\\n        \\n        Map<Integer, Integer> tmp = new HashMap<>(); // <prime, last_index_num_can_mod_it> of current\\n        Set<Integer> diff = new HashSet<>(); // diff keys to check next time, used for improve performance\\n        for (int i=0; i<nums.length-1; i++) {\\n            updatePrimes(i, nums[i], tmp, diff);\\n            if (check(all, tmp, diff)) return i;\\n        }\\n        return -1;\\n    }\\n    \\n    public void updatePrimes(int idx, int num, Map<Integer, Integer> map, Set<Integer> diff) {\\n        for (int i=2; i<=1000; i+=1+(i%2)) { // num \\u5206\\u89E3\\u8D28\\u56E0\\u7D20\\n            if (num < i) break;\\n            if (num % i == 0) {\\n                map.put(i, idx);\\n                if (diff != null) diff.add(i);\\n                while (num % i == 0) num /= i;\\n            }\\n        }\\n        if (num > 1) {\\n            map.put(num, idx);\\n            if (diff != null) diff.add(num);\\n        }\\n    }\\n    \\n    public boolean check(Map<Integer, Integer> all, Map<Integer, Integer> tmp, Set<Integer> diff) {\\n        Set<Integer> diffCopy = new HashSet<>();\\n        while (diff.size() > 0) {\\n            int key = diff.iterator().next();\\n            diff.remove(key);\\n            if ((int) tmp.get(key) == (int) all.get(key)) { // no need to keep anymore to improve performance\\n                tmp.remove(key);\\n                all.remove(key);\\n            } else {\\n                diffCopy.add(key);\\n            }\\n        }\\n        diff = diffCopy;\\n        if (tmp.size() == 0) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {    \\n    public int findValidSplit(int[] nums) {\\n        // \\u6570\\u5B66(\\u6570\\u8BBA) + \\u524D\\u7F00\\u8D28\\u56E0\\u7D20\\u5206\\u89E3\\u54C8\\u5E0C\\u8868 + \\u4F18\\u5316\\n        Map<Integer, Integer> all = new HashMap<>(); // <prime, last_index_num_can_mod_it> of all\\n        for (int i=0; i<nums.length; i++) {\\n            updatePrimes(i, nums[i], all, null);\\n        }\\n        \\n        Map<Integer, Integer> tmp = new HashMap<>(); // <prime, last_index_num_can_mod_it> of current\\n        Set<Integer> diff = new HashSet<>(); // diff keys to check next time, used for improve performance\\n        for (int i=0; i<nums.length-1; i++) {\\n            updatePrimes(i, nums[i], tmp, diff);\\n            if (check(all, tmp, diff)) return i;\\n        }\\n        return -1;\\n    }\\n    \\n    public void updatePrimes(int idx, int num, Map<Integer, Integer> map, Set<Integer> diff) {\\n        for (int i=2; i<=1000; i+=1+(i%2)) { // num \\u5206\\u89E3\\u8D28\\u56E0\\u7D20\\n            if (num < i) break;\\n            if (num % i == 0) {\\n                map.put(i, idx);\\n                if (diff != null) diff.add(i);\\n                while (num % i == 0) num /= i;\\n            }\\n        }\\n        if (num > 1) {\\n            map.put(num, idx);\\n            if (diff != null) diff.add(num);\\n        }\\n    }\\n    \\n    public boolean check(Map<Integer, Integer> all, Map<Integer, Integer> tmp, Set<Integer> diff) {\\n        Set<Integer> diffCopy = new HashSet<>();\\n        while (diff.size() > 0) {\\n            int key = diff.iterator().next();\\n            diff.remove(key);\\n            if ((int) tmp.get(key) == (int) all.get(key)) { // no need to keep anymore to improve performance\\n                tmp.remove(key);\\n                all.remove(key);\\n            } else {\\n                diffCopy.add(key);\\n            }\\n        }\\n        diff = diffCopy;\\n        if (tmp.size() == 0) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262002,
                "title": "c-o-n-easy-explained-with-map-with-clear-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n> Two numbers are coprime if they do not share any prime divisors and we can represent number x in form of its prime divisors i.e. 56=(2^1, 3^3). \\n\\nSo, we have to keep eye on number of matching prime factors on left and right. If this count reaches zero then we will find the split position.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can store the prime factors of a number in an\\n```\\nunordered_map<int, int> freq;\\n``` \\nStore prime factors of array in **org** and operate it with the factor of each number in nums.\\n\\nCount variable will store the number of prime factors that are common to left and right.\\n\\n```\\nif(freq[f] == org[f] and c!= freq[f]) count++;\\n```\\n*This line will check if after this number the power of the factor still remains more than zero*\\n\\n```\\nif(freq[f] != org[f] and c == freq[f]) count--;\\n```\\n*This will check for already existing unmatched power which is going to be zero this time*\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$ O(n) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> fac(int num){\\n        unordered_map<int, int> res;\\n        int f =2;\\n        while(num > 1 and f*f <= num){\\n            while(num%f == 0){\\n                res[f]++;\\n                num/=f;\\n            }\\n            f++;\\n        }\\n        if(num!=1) res[num] = 1;\\n        return res;\\n    }\\n    \\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> freq;\\n        for(auto &i:nums){\\n            auto fr = fac(i);\\n            for(auto &[f,c]:fr) freq[f] += c;\\n        }\\n\\n        auto org = freq;\\n\\n        int count = 0;\\n        for(int i=0; i<n-1; i++){\\n            auto fr = fac(nums[i]);\\n            for(auto &[f,c]: fr){\\n                if(freq[f] == org[f] and c!= freq[f]) count++;\\n                if(freq[f] != org[f] and c == freq[f]) count--;\\n                freq[f]-=c;\\n            }\\n            if(count == 0) return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nunordered_map<int, int> freq;\\n```\n```\\nif(freq[f] == org[f] and c!= freq[f]) count++;\\n```\n```\\nif(freq[f] != org[f] and c == freq[f]) count--;\\n```\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> fac(int num){\\n        unordered_map<int, int> res;\\n        int f =2;\\n        while(num > 1 and f*f <= num){\\n            while(num%f == 0){\\n                res[f]++;\\n                num/=f;\\n            }\\n            f++;\\n        }\\n        if(num!=1) res[num] = 1;\\n        return res;\\n    }\\n    \\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> freq;\\n        for(auto &i:nums){\\n            auto fr = fac(i);\\n            for(auto &[f,c]:fr) freq[f] += c;\\n        }\\n\\n        auto org = freq;\\n\\n        int count = 0;\\n        for(int i=0; i<n-1; i++){\\n            auto fr = fac(nums[i]);\\n            for(auto &[f,c]: fr){\\n                if(freq[f] == org[f] and c!= freq[f]) count++;\\n                if(freq[f] != org[f] and c == freq[f]) count--;\\n                freq[f]-=c;\\n            }\\n            if(count == 0) return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261888,
                "title": "trivial-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        const auto size = nums.size();\\n        vector<unordered_map<int, int>> factors(size);\\n        for (auto i = 0; i < size; ++i) {\\n            factors[i] = factorize(nums[i]);\\n        }\\n        unordered_map<int, int> left = factors[0], right;\\n        for (auto i = 1; i < size; ++i) {\\n            add(right, factors[i]);\\n        }\\n        for (auto i = 1; i < size; ++i) {\\n            if (!intersects(left, right)) return i - 1;\\n            add(left, factors[i]);\\n            subtract(right, factors[i]);\\n        }\\n        return -1;\\n    }\\n\\n    bool intersects(const unordered_map<int, int>& left, const unordered_map<int, int>& right) {\\n        for (const auto& pair : left) {\\n            if (right.count(pair.first)) return true;\\n        }\\n        return false;\\n    }\\n\\n    void subtract(unordered_map<int, int>& left, const unordered_map<int, int>& right) {\\n        for (const auto& pair : right) {\\n            if (left.count(pair.first)) {\\n                left[pair.first] -= pair.second;\\n                if (left[pair.first] <= 0) {\\n                    left.erase(pair.first);\\n                }\\n            }\\n        }\\n    }\\n\\n    void add(unordered_map<int, int>& left, const unordered_map<int, int>& right) {\\n        for (const auto& pair : right) {\\n            left[pair.first] += pair.second;\\n        }\\n    }\\n\\n    unordered_map<int, int> factorize(int num) {\\n        unordered_map<int, int> factors;\\n        for (auto i = 0; num > 1 && i < sizeof(primes) / sizeof(primes[0]); ++i) {\\n            while (num % primes[i] == 0) {\\n                ++factors[primes[i]];\\n                num /= primes[i];\\n            }\\n        }\\n        if (num > 1) {\\n            ++factors[num];\\n        }\\n        return factors;\\n    }\\n\\n    static constexpr const int primes[] = {\\n        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,\\n        101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,\\n        211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,\\n        307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,\\n        401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,\\n        503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,\\n        601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,\\n        701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,\\n        809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,\\n        907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997\\n    };\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        const auto size = nums.size();\\n        vector<unordered_map<int, int>> factors(size);\\n        for (auto i = 0; i < size; ++i) {\\n            factors[i] = factorize(nums[i]);\\n        }\\n        unordered_map<int, int> left = factors[0], right;\\n        for (auto i = 1; i < size; ++i) {\\n            add(right, factors[i]);\\n        }\\n        for (auto i = 1; i < size; ++i) {\\n            if (!intersects(left, right)) return i - 1;\\n            add(left, factors[i]);\\n            subtract(right, factors[i]);\\n        }\\n        return -1;\\n    }\\n\\n    bool intersects(const unordered_map<int, int>& left, const unordered_map<int, int>& right) {\\n        for (const auto& pair : left) {\\n            if (right.count(pair.first)) return true;\\n        }\\n        return false;\\n    }\\n\\n    void subtract(unordered_map<int, int>& left, const unordered_map<int, int>& right) {\\n        for (const auto& pair : right) {\\n            if (left.count(pair.first)) {\\n                left[pair.first] -= pair.second;\\n                if (left[pair.first] <= 0) {\\n                    left.erase(pair.first);\\n                }\\n            }\\n        }\\n    }\\n\\n    void add(unordered_map<int, int>& left, const unordered_map<int, int>& right) {\\n        for (const auto& pair : right) {\\n            left[pair.first] += pair.second;\\n        }\\n    }\\n\\n    unordered_map<int, int> factorize(int num) {\\n        unordered_map<int, int> factors;\\n        for (auto i = 0; num > 1 && i < sizeof(primes) / sizeof(primes[0]); ++i) {\\n            while (num % primes[i] == 0) {\\n                ++factors[primes[i]];\\n                num /= primes[i];\\n            }\\n        }\\n        if (num > 1) {\\n            ++factors[num];\\n        }\\n        return factors;\\n    }\\n\\n    static constexpr const int primes[] = {\\n        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,\\n        101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,\\n        211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,\\n        307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,\\n        401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,\\n        503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,\\n        601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,\\n        701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,\\n        809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,\\n        907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261878,
                "title": "prime-factorization-using-sieve-and-valid-index-using-scan-line-algo-c-detailed-explanation",
                "content": "# Intuition and Approach\\nA split will be valid when the prefix product till i and suffix product till i+1 have no common prime means gcd( prefix[i] , suffix[i+1]) = 1 , but as the constrains are so big and if we use this technique it will surely give runtime error, we have to think more efficiently .\\n\\nAs we only have to check the primes so we can store the unique primes of all elements by using prime factorization using sieve technique .\\n now we want a valid index where the left side primes and right side primes are not common , to find this index there is Algorithm called Scan line Algo . \\n\\nIn this technique we will store the starting and ending index of all unique primes in map , now we will traverse in our unique prime array from left to right and we will keep a MaxRightMost index and keep updating it with the max of ending indices of all primes till ith index using the map and if at any index our MaxRightMost index is less than the current index we will return MaxRightMost index as all the primes in left side have their ending indices within MaxRightMost index,if loops end return -1\\n\\n\\n# Complexity\\n- Time complexity: O( m* log(logm) + n* log(m) + (n* 8) + (n* 8)) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m + n*8 + 168)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> sieve(int N){\\n        vector<int> firstPrime(N+1);\\n        for(int i=1;i<=N;i++) firstPrime[i]=i;\\n\\n        for(int i=2;i*i<=N;i++){\\n            if(firstPrime[i]==i){\\n                for(int j=i*i;j<=N;j+=i){\\n                    if(firstPrime[j]==j)firstPrime[j]=i;\\n                }\\n            }\\n        }\\n        return firstPrime;\\n    }\\n\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        int mx = *max_element(nums.begin(),nums.end());\\n\\n        vector<int> firstPrime = sieve(mx); //first prime of each elem\\n        vector<vector<int>> vec(n); // unique primes at any i \\n        \\n        for(int i=0;i<n;i++){\\n            int ele = nums[i];\\n            while(ele>1){\\n                int p = firstPrime[ele];\\n                vec[i].push_back(p);\\n                while(ele%p==0) ele /= p;\\n            }\\n        }\\n\\n        unordered_map<int,pair<int,int>> mp;  // prime - {st , en}\\n\\n        for(int i=0;i<n;i++){\\n            for(auto& j:vec[i]){\\n                if(mp.count(j)) mp[j].second = i;\\n                else mp[j] = {i,i};\\n            }\\n        }\\n\\n        int mxind = 0;\\n        for(int i=0;i<n;i++){\\n            if(mxind<i)return mxind;\\n            for(auto& j:vec[i]) mxind = max(mxind,mp[j].second);\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> sieve(int N){\\n        vector<int> firstPrime(N+1);\\n        for(int i=1;i<=N;i++) firstPrime[i]=i;\\n\\n        for(int i=2;i*i<=N;i++){\\n            if(firstPrime[i]==i){\\n                for(int j=i*i;j<=N;j+=i){\\n                    if(firstPrime[j]==j)firstPrime[j]=i;\\n                }\\n            }\\n        }\\n        return firstPrime;\\n    }\\n\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        int mx = *max_element(nums.begin(),nums.end());\\n\\n        vector<int> firstPrime = sieve(mx); //first prime of each elem\\n        vector<vector<int>> vec(n); // unique primes at any i \\n        \\n        for(int i=0;i<n;i++){\\n            int ele = nums[i];\\n            while(ele>1){\\n                int p = firstPrime[ele];\\n                vec[i].push_back(p);\\n                while(ele%p==0) ele /= p;\\n            }\\n        }\\n\\n        unordered_map<int,pair<int,int>> mp;  // prime - {st , en}\\n\\n        for(int i=0;i<n;i++){\\n            for(auto& j:vec[i]){\\n                if(mp.count(j)) mp[j].second = i;\\n                else mp[j] = {i,i};\\n            }\\n        }\\n\\n        int mxind = 0;\\n        for(int i=0;i<n;i++){\\n            if(mxind<i)return mxind;\\n            for(auto& j:vec[i]) mxind = max(mxind,mp[j].second);\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261851,
                "title": "python-2-approaches-last-indices-of-prime-factors-and-python-big-number-support",
                "content": "# Intuition\\nCalculate naively is out of question for many programming languages, products are too big.\\n**Key insight**: Coprime numbers don\\'t share prime factors, so everything can be reduced to finding index that divides first part and second part of the array where they don\\'t share same prime factors, first such index is solution.\\n\\n# Approach 1\\n1. Precalculate prime numbers upto max value in nums\\n2. Calculate map of last index occurence for every prime factor that appears in nums array\\n3. got through array, skip last element\\n4. maintain set of prime factors seen so far\\n4. on every element check if any of prime factors used so far have index bigger the current index\\n5. if not current index is solution\\n6. if this loops finishes without solution just return -1\\n\\n# Complexity\\n- Time complexity:\\nO($${\\\\sqrt{max(nums)}}$$ + $${\\\\log{max(nums)}}$$ * N)\\n\\n- Space complexity:\\nO(max(nums)) - prime factors table\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def generate_factors(self, n):\\n        self.factors = [0] * (n + 1)\\n        for i in range(2, n + 1):\\n            if self.factors[i] == 0:\\n                self.factors[i] = i\\n                for j in range(i**2, n + 1, i):\\n                    self.factors[j] = i\\n\\n    def get_number_factors(self, x):\\n        result = set()\\n        while x > 1:\\n            result.add(self.factors[x])\\n            x //= self.factors[x]\\n        return result\\n\\n    def no_factor_after_index(self, having_factors, index):\\n        for f in having_factors: \\n            if self.last_index[f] > index: return False\\n        return True \\n\\n    def calculate_last_factor_index(self, A, N):\\n        self.last_index = defaultdict(int)\\n\\n        for i in range(N):\\n            for f in self.get_number_factors(A[i]):  self.last_index[f] = max(self.last_index[f], i)        \\n\\n    def findValidSplit(self, A: List[int]) -> int:\\n        N = len(A)\\n        if N < 2: return -1\\n        self.generate_factors(max(A))\\n        self.calculate_last_factor_index(A, N)\\n\\n        having_factors = set()\\n        for i in range(N - 1):\\n            having_factors.update(self.get_number_factors(A[i]))\\n            if self.no_factor_after_index(having_factors, i): return i            \\n\\n        return -1 \\n```\\n# Approach 2\\nThat was general approach, should work in any language.\\nThanks to Python big number handling, it can be simplified to much shorter version:\\n\\n```\\nfrom math import gcd\\n\\nclass Solution:\\n    def findValidSplit(self, A: List[int]) -> int:\\n        N = len(A)\\n        curr_product = A[0]\\n        i = 1\\n        while i < N - 1:            \\n            other = 1\\n            j = i + 1\\n            while j < N and gcd(curr_product, A[j]) == 1: \\n                other *= A[j]\\n                j += 1\\n            if j == N : return i\\n            i = j\\n            curr_product *= other\\n        return -1\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def generate_factors(self, n):\\n        self.factors = [0] * (n + 1)\\n        for i in range(2, n + 1):\\n            if self.factors[i] == 0:\\n                self.factors[i] = i\\n                for j in range(i**2, n + 1, i):\\n                    self.factors[j] = i\\n\\n    def get_number_factors(self, x):\\n        result = set()\\n        while x > 1:\\n            result.add(self.factors[x])\\n            x //= self.factors[x]\\n        return result\\n\\n    def no_factor_after_index(self, having_factors, index):\\n        for f in having_factors: \\n            if self.last_index[f] > index: return False\\n        return True \\n\\n    def calculate_last_factor_index(self, A, N):\\n        self.last_index = defaultdict(int)\\n\\n        for i in range(N):\\n            for f in self.get_number_factors(A[i]):  self.last_index[f] = max(self.last_index[f], i)        \\n\\n    def findValidSplit(self, A: List[int]) -> int:\\n        N = len(A)\\n        if N < 2: return -1\\n        self.generate_factors(max(A))\\n        self.calculate_last_factor_index(A, N)\\n\\n        having_factors = set()\\n        for i in range(N - 1):\\n            having_factors.update(self.get_number_factors(A[i]))\\n            if self.no_factor_after_index(having_factors, i): return i            \\n\\n        return -1 \\n```\n```\\nfrom math import gcd\\n\\nclass Solution:\\n    def findValidSplit(self, A: List[int]) -> int:\\n        N = len(A)\\n        curr_product = A[0]\\n        i = 1\\n        while i < N - 1:            \\n            other = 1\\n            j = i + 1\\n            while j < N and gcd(curr_product, A[j]) == 1: \\n                other *= A[j]\\n                j += 1\\n            if j == N : return i\\n            i = j\\n            curr_product *= other\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261391,
                "title": "python-3-hashmap",
                "content": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n\\t\\t# prime factorization\\n        def prime_factors(n):\\n            i = 2\\n            factors = defaultdict(int)\\n            while i * i <= n:\\n                if n % i:\\n                    i += 1\\n                else:\\n                    n //= i\\n                    factors[i] += 1\\n            if n > 1:\\n                factors[n] += 1\\n            return factors\\n\\n\\n        primes = defaultdict(int)\\n        mem = {}\\n\\n        for num in nums:\\n            p = {}\\n            if num not in mem:\\n                p = prime_factors(num)\\n                mem[num] = p\\n            else:\\n                p = mem[num]\\n\\t\\t\\t# accumulative prime counts  \\n            for k in p:\\n                primes[k] += p[k]\\n\\t\\t# visited prime factors on the left side\\n        l = set()\\n\\n        for i, num in enumerate(nums[:-1]):\\n            tmp = mem[num]\\n\\t\\t\\t# move prime factors from right to left\\n            for k in tmp:\\n                primes[k] -= tmp[k]\\n                if k not in l: l.add(k)\\n\\t\\t    # make sure all prime factors in left do not exist in right\\n            if all(primes[x] == 0 for x in l):\\n                return i\\n        \\n        return -1\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n\\t\\t# prime factorization\\n        def prime_factors(n):\\n            i = 2\\n            factors = defaultdict(int)\\n            while i * i <= n:\\n                if n % i:\\n                    i += 1\\n                else:\\n                    n //= i\\n                    factors[i] += 1\\n            if n > 1:\\n                factors[n] += 1\\n            return factors\\n\\n\\n        primes = defaultdict(int)\\n        mem = {}\\n\\n        for num in nums:\\n            p = {}\\n            if num not in mem:\\n                p = prime_factors(num)\\n                mem[num] = p\\n            else:\\n                p = mem[num]\\n\\t\\t\\t# accumulative prime counts  \\n            for k in p:\\n                primes[k] += p[k]\\n\\t\\t# visited prime factors on the left side\\n        l = set()\\n\\n        for i, num in enumerate(nums[:-1]):\\n            tmp = mem[num]\\n\\t\\t\\t# move prime factors from right to left\\n            for k in tmp:\\n                primes[k] -= tmp[k]\\n                if k not in l: l.add(k)\\n\\t\\t    # make sure all prime factors in left do not exist in right\\n            if all(primes[x] == 0 for x in l):\\n                return i\\n        \\n        return -1\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3261267,
                "title": "1984-ms",
                "content": "```ruby\\nrequire \\'prime\\'\\n\\ndef find_valid_split a\\n    c, d, l, r = 0, {}, *2.times.map { Hash.new 0 }\\n    a.each do\\n        (d[_1] ||= _1.prime_division).each do | (k, v) |\\n            r[k] += v\\n        end\\n    end\\n    for i in 0..a.size - 2\\n        d[a[i]].each do | (k, v) |\\n            c -= 1 if (r[k] -= v) == 0 && l[k] > 0\\n            c += 1 if (l[k] += v) == v && r[k] > 0\\n        end\\n        return i if c == 0\\n    end\\n    -1\\nend\\n```\\n2010 ms:\\n```ruby\\nrequire \\'prime\\'\\n\\ndef find_valid_split a\\n    d, f = {}, {}\\n    a.each_with_index do | x, i |\\n        (d[x] ||= x.prime_division).each do\\n           (f[_1.first] ||= [i, i])[-1] = i\\n        end\\n    end\\n    r = f.values.sort_by!(&:first)\\n    r.empty? ? (e = 0) : begin\\n        e = r.shift.last\\n        while (x = r.shift)&.first&.<= e\\n            e = [e, x.last].max\\n        end\\n    end\\n    e < a.size - 1 ? e : -1\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nrequire \\'prime\\'\\n\\ndef find_valid_split a\\n    c, d, l, r = 0, {}, *2.times.map { Hash.new 0 }\\n    a.each do\\n        (d[_1] ||= _1.prime_division).each do | (k, v) |\\n            r[k] += v\\n        end\\n    end\\n    for i in 0..a.size - 2\\n        d[a[i]].each do | (k, v) |\\n            c -= 1 if (r[k] -= v) == 0 && l[k] > 0\\n            c += 1 if (l[k] += v) == v && r[k] > 0\\n        end\\n        return i if c == 0\\n    end\\n    -1\\nend\\n```\n```ruby\\nrequire \\'prime\\'\\n\\ndef find_valid_split a\\n    d, f = {}, {}\\n    a.each_with_index do | x, i |\\n        (d[x] ||= x.prime_division).each do\\n           (f[_1.first] ||= [i, i])[-1] = i\\n        end\\n    end\\n    r = f.values.sort_by!(&:first)\\n    r.empty? ? (e = 0) : begin\\n        e = r.shift.last\\n        while (x = r.shift)&.first&.<= e\\n            e = [e, x.last].max\\n        end\\n    end\\n    e < a.size - 1 ? e : -1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3261233,
                "title": "c-just-for-testcases",
                "content": "```C []\\n//just for testcases\\n#define MAX_PRIME_FACTOR_PER_NUM (2)\\n#define MAX_PRIME (1000001)\\n#define MAX_COMPOSITE (15)\\n\\nstatic const int primes[] = {2, 3, 5, 7, 11, 13, 17};\\n\\nint findValidSplit(const int nums[const], const int numsLen){\\n\\tif (!( numsLen >= 2 )){\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tint primeFactorsArr[numsLen][MAX_PRIME_FACTOR_PER_NUM];\\n\\tint primeFactorsLens[numsLen];\\n\\tmemset( &primeFactorsLens, 0, sizeof (primeFactorsLens) );\\n\\tfor (int i = 0; i < numsLen; i += 1){\\n\\t\\tif (nums[i] > MAX_COMPOSITE){\\n\\t\\t\\tassert(primeFactorsLens[i] < MAX_PRIME_FACTOR_PER_NUM);\\n\\t\\t\\tprimeFactorsArr[i][ primeFactorsLens[i] ] = nums[i];\\n\\t\\t\\tprimeFactorsLens[i] += 1;\\n\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tint curNum = nums[i];\\n\\t\\tfor (int primeIdx = 0; curNum >= primes[primeIdx]; ){\\n\\t\\t\\tif (curNum % primes[primeIdx] == 0){\\n\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t0 == primeFactorsLens[i] || \\n\\t\\t\\t\\t\\t\\tprimeFactorsArr[i][ primeFactorsLens[i] - 1 ] != primes[primeIdx]\\n\\t\\t\\t\\t){\\n\\t\\t\\t\\t\\tassert(primeFactorsLens[i] < MAX_PRIME_FACTOR_PER_NUM);\\n\\t\\t\\t\\t\\tprimeFactorsArr[i][ primeFactorsLens[i] ] = primes[primeIdx];\\n\\t\\t\\t\\t\\tprimeFactorsLens[i] += 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcurNum /= primes[primeIdx];\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tprimeIdx += 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tbool hashSet[MAX_PRIME];\\n\\tmemset( &hashSet, 0, sizeof (hashSet) );\\n\\tfor (int i = 0; i < primeFactorsLens[0]; i += 1){\\n\\t\\thashSet[ primeFactorsArr[0][i] ] = true;\\n\\t}\\n\\n\\tfor (int curSplitPos = 0; curSplitPos < numsLen - 1; ){\\n\\t\\tint curCheck = curSplitPos + 1;\\n\\t\\tbool success = true;\\n\\n\\t\\tfor (; curCheck < numsLen; curCheck += 1){\\n\\t\\t\\tfor (int i = 0; i < primeFactorsLens[curCheck]; i += 1){\\n\\t\\t\\t\\tif ( hashSet[ primeFactorsArr[curCheck][i] ] ){\\n\\t\\t\\t\\t\\tsuccess = false;\\n\\t\\t\\t\\t\\tgoto LOOP_END;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\nLOOP_END:\\n\\n\\t\\tif (success){\\n\\t\\t\\treturn curSplitPos;\\n\\t\\t}\\n\\n\\t\\tdo {\\n\\t\\t\\tcurSplitPos += 1;\\n\\n\\t\\t\\tfor (int i = 0; i < primeFactorsLens[curSplitPos]; i += 1){\\n\\t\\t\\t\\thashSet[ primeFactorsArr[curSplitPos][i] ] = true;\\n\\t\\t\\t}\\n\\t\\t}while (curSplitPos < curCheck);\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C []\\n//just for testcases\\n#define MAX_PRIME_FACTOR_PER_NUM (2)\\n#define MAX_PRIME (1000001)\\n#define MAX_COMPOSITE (15)\\n\\nstatic const int primes[] = {2, 3, 5, 7, 11, 13, 17};\\n\\nint findValidSplit(const int nums[const], const int numsLen){\\n\\tif (!( numsLen >= 2 )){\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tint primeFactorsArr[numsLen][MAX_PRIME_FACTOR_PER_NUM];\\n\\tint primeFactorsLens[numsLen];\\n\\tmemset( &primeFactorsLens, 0, sizeof (primeFactorsLens) );\\n\\tfor (int i = 0; i < numsLen; i += 1){\\n\\t\\tif (nums[i] > MAX_COMPOSITE){\\n\\t\\t\\tassert(primeFactorsLens[i] < MAX_PRIME_FACTOR_PER_NUM);\\n\\t\\t\\tprimeFactorsArr[i][ primeFactorsLens[i] ] = nums[i];\\n\\t\\t\\tprimeFactorsLens[i] += 1;\\n\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tint curNum = nums[i];\\n\\t\\tfor (int primeIdx = 0; curNum >= primes[primeIdx]; ){\\n\\t\\t\\tif (curNum % primes[primeIdx] == 0){\\n\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t0 == primeFactorsLens[i] || \\n\\t\\t\\t\\t\\t\\tprimeFactorsArr[i][ primeFactorsLens[i] - 1 ] != primes[primeIdx]\\n\\t\\t\\t\\t){\\n\\t\\t\\t\\t\\tassert(primeFactorsLens[i] < MAX_PRIME_FACTOR_PER_NUM);\\n\\t\\t\\t\\t\\tprimeFactorsArr[i][ primeFactorsLens[i] ] = primes[primeIdx];\\n\\t\\t\\t\\t\\tprimeFactorsLens[i] += 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcurNum /= primes[primeIdx];\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tprimeIdx += 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tbool hashSet[MAX_PRIME];\\n\\tmemset( &hashSet, 0, sizeof (hashSet) );\\n\\tfor (int i = 0; i < primeFactorsLens[0]; i += 1){\\n\\t\\thashSet[ primeFactorsArr[0][i] ] = true;\\n\\t}\\n\\n\\tfor (int curSplitPos = 0; curSplitPos < numsLen - 1; ){\\n\\t\\tint curCheck = curSplitPos + 1;\\n\\t\\tbool success = true;\\n\\n\\t\\tfor (; curCheck < numsLen; curCheck += 1){\\n\\t\\t\\tfor (int i = 0; i < primeFactorsLens[curCheck]; i += 1){\\n\\t\\t\\t\\tif ( hashSet[ primeFactorsArr[curCheck][i] ] ){\\n\\t\\t\\t\\t\\tsuccess = false;\\n\\t\\t\\t\\t\\tgoto LOOP_END;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\nLOOP_END:\\n\\n\\t\\tif (success){\\n\\t\\t\\treturn curSplitPos;\\n\\t\\t}\\n\\n\\t\\tdo {\\n\\t\\t\\tcurSplitPos += 1;\\n\\n\\t\\t\\tfor (int i = 0; i < primeFactorsLens[curSplitPos]; i += 1){\\n\\t\\t\\t\\thashSet[ primeFactorsArr[curSplitPos][i] ] = true;\\n\\t\\t\\t}\\n\\t\\t}while (curSplitPos < curCheck);\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3260964,
                "title": "c-solution",
                "content": "# Approach\\nstep1. Find the biggest index for each factor of each element\\nstep2. Find the biggest index for each element\\'s factors:\\n if the current max_index==current index&&index is not the last index, we get the answer.\\nelse return -1.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        //int max_=*max_element(nums.begin(), nums.end());\\n        //vector<int>save(max_+1,-1);\\n        unordered_map<int,int>save;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            save[nums[i]]=max(save[nums[i]],i);\\n            for(int j=2;j*j<=nums[i];j++)\\n            {\\n                if(nums[i]%j==0)\\n                {\\n                    save[j]=max(save[j],i);\\n                    save[nums[i]/j]=max(save[nums[i]/j],i);\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int max_=save[nums[i]];\\n            for(int j=2;j*j<=nums[i];j++)\\n            {\\n                if(nums[i]%j==0)\\n                {\\n                    max_=max(max_,save[j]);\\n                    max_=max(max_,save[nums[i]/j]);\\n                }\\n            }\\n            ans=max(ans,max_);\\n            if(ans==i&&i!=nums.size()-1)return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        //int max_=*max_element(nums.begin(), nums.end());\\n        //vector<int>save(max_+1,-1);\\n        unordered_map<int,int>save;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            save[nums[i]]=max(save[nums[i]],i);\\n            for(int j=2;j*j<=nums[i];j++)\\n            {\\n                if(nums[i]%j==0)\\n                {\\n                    save[j]=max(save[j],i);\\n                    save[nums[i]/j]=max(save[nums[i]/j],i);\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int max_=save[nums[i]];\\n            for(int j=2;j*j<=nums[i];j++)\\n            {\\n                if(nums[i]%j==0)\\n                {\\n                    max_=max(max_,save[j]);\\n                    max_=max(max_,save[nums[i]/j]);\\n                }\\n            }\\n            ans=max(ans,max_);\\n            if(ans==i&&i!=nums.size()-1)return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260675,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn find_valid_split(nums: Vec<i32>) -> i32 {\\n        use std::collections::HashMap;\\n        fn factorize(n: i32) -> Vec<i32> {\\n            let mut res = Vec::new();\\n            let mut n = n;\\n            let mut i = 2;\\n            while n > 1 && i < 1000 {\\n                if n % i == 0 {\\n                    res.push(i);\\n                    while n % i == 0 {\\n                        n /= i;\\n                    }\\n                }\\n                i += 1 + (i % 2);\\n            }\\n            if n > 1 {\\n                res.push(n);\\n            }\\n            res\\n        }\\n\\n        let (mut left, mut right) = (HashMap::new(), HashMap::new());\\n        for n in nums.iter() {\\n            for f in factorize(*n) {\\n                *right.entry(f).or_insert(0) += 1;\\n            }\\n        }\\n        let mut common = 0;\\n        for (i, &num) in nums.iter().enumerate().take(nums.len() - 1) {\\n            for f in factorize(num) {\\n                let l = left.entry(f).or_insert(0);\\n                common += (*l == 0) as i32;\\n                *l += 1;\\n                common -= (*l == right[&f]) as i32;\\n            }\\n            if common == 0 {\\n                return i as i32;\\n            }\\n        }\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_valid_split(nums: Vec<i32>) -> i32 {\\n        use std::collections::HashMap;\\n        fn factorize(n: i32) -> Vec<i32> {\\n            let mut res = Vec::new();\\n            let mut n = n;\\n            let mut i = 2;\\n            while n > 1 && i < 1000 {\\n                if n % i == 0 {\\n                    res.push(i);\\n                    while n % i == 0 {\\n                        n /= i;\\n                    }\\n                }\\n                i += 1 + (i % 2);\\n            }\\n            if n > 1 {\\n                res.push(n);\\n            }\\n            res\\n        }\\n\\n        let (mut left, mut right) = (HashMap::new(), HashMap::new());\\n        for n in nums.iter() {\\n            for f in factorize(*n) {\\n                *right.entry(f).or_insert(0) += 1;\\n            }\\n        }\\n        let mut common = 0;\\n        for (i, &num) in nums.iter().enumerate().take(nums.len() - 1) {\\n            for f in factorize(num) {\\n                let l = left.entry(f).or_insert(0);\\n                common += (*l == 0) as i32;\\n                *l += 1;\\n                common -= (*l == right[&f]) as i32;\\n            }\\n            if common == 0 {\\n                return i as i32;\\n            }\\n        }\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3260600,
                "title": "c-solution-map-o-n2",
                "content": "```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int,int> mp;\\n        for(int i = n-1; i>=0; i--)\\n        {\\n            int temp = nums[i];\\n            for(int j = 2; j<=sqrt(nums[i]); j++)\\n            {\\n                if(temp % j == 0)\\n                {\\n                    if(mp[j] == 0)\\n                        mp[j] = i + 1;\\n                    while(temp % j == 0)\\n                        temp /= j;\\n                }\\n            }\\n            if(temp > 1)\\n                if(mp[temp] == 0)\\n                    mp[temp] = i + 1;\\n        }\\n        int index = 1;\\n        for(int i = 0; i<index; i++)\\n        {\\n            int temp = nums[i];\\n            for(int j = 2; j<=sqrt(nums[i]); j++)\\n            {\\n                if(temp % j == 0)\\n                {\\n                    index = max(index, mp[j]);\\n                }\\n                while(temp % j == 0)\\n                    temp /= j;\\n            }\\n            if(temp > 1)\\n                index = max(index, mp[temp]);\\n            \\n        }\\n        if(index == n) return -1;\\n        return index-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int,int> mp;\\n        for(int i = n-1; i>=0; i--)\\n        {\\n            int temp = nums[i];\\n            for(int j = 2; j<=sqrt(nums[i]); j++)\\n            {\\n                if(temp % j == 0)\\n                {\\n                    if(mp[j] == 0)\\n                        mp[j] = i + 1;\\n                    while(temp % j == 0)\\n                        temp /= j;\\n                }\\n            }\\n            if(temp > 1)\\n                if(mp[temp] == 0)\\n                    mp[temp] = i + 1;\\n        }\\n        int index = 1;\\n        for(int i = 0; i<index; i++)\\n        {\\n            int temp = nums[i];\\n            for(int j = 2; j<=sqrt(nums[i]); j++)\\n            {\\n                if(temp % j == 0)\\n                {\\n                    index = max(index, mp[j]);\\n                }\\n                while(temp % j == 0)\\n                    temp /= j;\\n            }\\n            if(temp > 1)\\n                index = max(index, mp[temp]);\\n            \\n        }\\n        if(index == n) return -1;\\n        return index-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260506,
                "title": "c-bruteforce-it-worked-barely-xd-greedy",
                "content": "```\\nint findValidSplit(vector<int>& nums) {`\\n        \\n        vector<int> FAR(nums.size(),-1); \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            int j=nums.size()-1; \\n            while(j>=i){\\n                if(nums[j]%nums[i]==0 || nums[i]%nums[j]==0){\\n                    FAR[i]=j ;\\n                    break ;\\n                }\\n                j--;\\n            }\\n        }\\n        \\n        int lastIndex=FAR[0];\\n        \\n        for(int i=0; i<FAR.size()-1; i++)\\n        {\\n            if(lastIndex==i) return i;\\n            \\n            lastIndex=max(lastIndex,FAR[i]) ;\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint findValidSplit(vector<int>& nums) {`\\n        \\n        vector<int> FAR(nums.size(),-1); \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            int j=nums.size()-1; \\n            while(j>=i){\\n                if(nums[j]%nums[i]==0 || nums[i]%nums[j]==0){\\n                    FAR[i]=j ;\\n                    break ;\\n                }\\n                j--;\\n            }\\n        }\\n        \\n        int lastIndex=FAR[0];\\n        \\n        for(int i=0; i<FAR.size()-1; i++)\\n        {\\n            if(lastIndex==i) return i;\\n            \\n            lastIndex=max(lastIndex,FAR[i]) ;\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3260320,
                "title": "best-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        unordered_map<int, int>freqFactor;\\n        for(auto num : nums)\\n            primeFactor(num, freqFactor);\\n        unordered_map<int, int>tillFactor;\\n        for(int i = 0; i < nums.size(); i++){\\n            bool flag = true;\\n            primeFactor(nums[i], tillFactor);\\n            for(auto fact : tillFactor){\\n                if(freqFactor[fact.first] - fact.second > 0){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag == true && i != nums.size()-1)\\n                return i;\\n        }    \\n        return -1;\\n    }\\n    void primeFactor(int num, unordered_map<int, int> &freqFactor) {\\n        int temp = num;\\n        for(int i = 2; i*i <= temp; i++){\\n            while(temp % i == 0){\\n                freqFactor[i]++;\\n                temp /= i;\\n            }\\n        }\\n        if(temp > 1)\\n            freqFactor[temp]++;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        unordered_map<int, int>freqFactor;\\n        for(auto num : nums)\\n            primeFactor(num, freqFactor);\\n        unordered_map<int, int>tillFactor;\\n        for(int i = 0; i < nums.size(); i++){\\n            bool flag = true;\\n            primeFactor(nums[i], tillFactor);\\n            for(auto fact : tillFactor){\\n                if(freqFactor[fact.first] - fact.second > 0){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag == true && i != nums.size()-1)\\n                return i;\\n        }    \\n        return -1;\\n    }\\n    void primeFactor(int num, unordered_map<int, int> &freqFactor) {\\n        int temp = num;\\n        for(int i = 2; i*i <= temp; i++){\\n            while(temp % i == 0){\\n                freqFactor[i]++;\\n                temp /= i;\\n            }\\n        }\\n        if(temp > 1)\\n            freqFactor[temp]++;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260002,
                "title": "ruby-think-in-the-interval-way-o-8-n-i-0-25",
                "content": "# Intuition\\n\\nLet\\'s say `nums[i]` and `nums[j]` (i < j) share a factor `a`. Then we can\\'t split at `i` to `j-1` because it will leave the factor `a` in the left side and right side, which doesn\\u2019t meet the validness defined in this question.\\n\\n\\n\\n# Approach\\n1. In a interation we alculate prime factors for each number:\\n    1. Meanwhile, record the index of each factor in a hash,\\n    2. We only record the min and max index of each factor\\'s appearance\\n2. We try get a list of intervals of factors that appears more than once\\n3. Merge the intervals, using we did in this question [56 Merge Intervals](https://leetcode.com/problems/merge-intervals/)\\n4. Make the merged intervals to a hash, starting value as key and ending value as value\\n5. Initiate `i = 0` as our answer, and loop to see if it exits in the hash in Step 4. If it exists, we bump `i` to `hash[i]` because we can\\'t validly split in any index bewtween that interval; Otherwise, just return `i` as the answer.\\n\\n```ruby\\n# Example\\nnums = [4,7,8,15,3,5]\\n\\n# Step 1\\nfactor_positions = {\\n  2 => [0, 2],\\n  3 => [3, 4]\\n  5 => [3, 5],\\n  7 => [1]\\n}\\n\\n# Step 2\\nintervals = [[0, 2], [3, 4], [3, 5]]\\n\\n# Step 3\\nintervals = [[0, 2], [3, 5]]\\n\\n# Step 4\\nends_by_start = { 0 => 2, 3 => 5 }\\n\\n# Step 5\\n# while i <=nums.length - 2\\ni = 0\\n# ends_by_start[0] exists\\ni = 2\\n# ends_by_start[2] doesn\\'t exist\\nreturn 2\\n\\n```\\n\\n# Complexity\\n- Time complexity:\\nIt\\'s really hard to depict it here... I don\\'t know the time complexity of Ruby\\'s `Integer#prime_division`. I would be happy if anyone can tell me.\\nSupposing it\\'s using [Pollard Rho](https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm) so the complexity is $O(I ^ \\\\frac{1}{4})$ for each number $I$. In this situation the time complexity would be $O(8 * N * I ^ \\\\frac{1}{4})$. $8$ is from the max count of unique prime factors of a number under $10^6$\\n\\n- Space complexity:\\n$$O(2M)$$, which `M` represents the count of primes under $10^6$. Actually this is a relatively fixed number around 80k for the restriction of this question.\\n\\n\\n# Code\\n```\\nrequire \\'prime\\'\\n\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_valid_split(nums)\\n  return -1 if nums.length == 1\\n    \\n  factor_positions = Hash.new {|h, k| h[k] = Array.new }\\n\\n  cached_factors = {}\\n\\n  nums.each.with_index do |num, i|\\n    cached_factors[num] ||= num.prime_division.map(&:first)\\n\\n    cached_factors[num].each do |factor|\\n      if factor_positions[factor].size > 1\\n        factor_positions[factor][1] = i\\n      else\\n        factor_positions[factor] << i\\n      end\\n    end\\n  end\\n\\n  intervals = factor_positions.values.select {|positions| positions.length == 2 }\\n\\n  intervals = merge_intervals(intervals)\\n\\n  ends_by_start = {}\\n\\n  intervals.each do |start, ending|\\n    ends_by_start[start] = ending\\n  end\\n\\n  i = 0\\n\\n  while i <= nums.length - 2\\n    if ends_by_start[i]\\n      i = ends_by_start[i]\\n    else\\n      return i\\n    end\\n  end\\n  \\n  -1\\nend\\n\\ndef merge_intervals(intervals)\\n  stack = [intervals[0]]\\n\\n  intervals[1..-1].each do |interval|\\n    if stack.last[1] >= interval[0]\\n      last_interval = stack.pop\\n      stack << [last_interval[0], [last_interval[1], interval[1]].max]\\n    else\\n      stack << interval\\n    end\\n  end\\n\\n  stack\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# Example\\nnums = [4,7,8,15,3,5]\\n\\n# Step 1\\nfactor_positions = {\\n  2 => [0, 2],\\n  3 => [3, 4]\\n  5 => [3, 5],\\n  7 => [1]\\n}\\n\\n# Step 2\\nintervals = [[0, 2], [3, 4], [3, 5]]\\n\\n# Step 3\\nintervals = [[0, 2], [3, 5]]\\n\\n# Step 4\\nends_by_start = { 0 => 2, 3 => 5 }\\n\\n# Step 5\\n# while i <=nums.length - 2\\ni = 0\\n# ends_by_start[0] exists\\ni = 2\\n# ends_by_start[2] doesn\\'t exist\\nreturn 2\\n\\n```\n```\\nrequire \\'prime\\'\\n\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_valid_split(nums)\\n  return -1 if nums.length == 1\\n    \\n  factor_positions = Hash.new {|h, k| h[k] = Array.new }\\n\\n  cached_factors = {}\\n\\n  nums.each.with_index do |num, i|\\n    cached_factors[num] ||= num.prime_division.map(&:first)\\n\\n    cached_factors[num].each do |factor|\\n      if factor_positions[factor].size > 1\\n        factor_positions[factor][1] = i\\n      else\\n        factor_positions[factor] << i\\n      end\\n    end\\n  end\\n\\n  intervals = factor_positions.values.select {|positions| positions.length == 2 }\\n\\n  intervals = merge_intervals(intervals)\\n\\n  ends_by_start = {}\\n\\n  intervals.each do |start, ending|\\n    ends_by_start[start] = ending\\n  end\\n\\n  i = 0\\n\\n  while i <= nums.length - 2\\n    if ends_by_start[i]\\n      i = ends_by_start[i]\\n    else\\n      return i\\n    end\\n  end\\n  \\n  -1\\nend\\n\\ndef merge_intervals(intervals)\\n  stack = [intervals[0]]\\n\\n  intervals[1..-1].each do |interval|\\n    if stack.last[1] >= interval[0]\\n      last_interval = stack.pop\\n      stack << [last_interval[0], [last_interval[1], interval[1]].max]\\n    else\\n      stack << interval\\n    end\\n  end\\n\\n  stack\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3259998,
                "title": "simple-c-solution-frequency-of-prime-factors",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void primeFactor(int num, unordered_map<int, int>& mp) {\\n        int n = num;\\n        for(int i=2;i<=sqrt(num);i++) {\\n            while(n%i == 0) {\\n                mp[i]++;\\n                n/=i;\\n            }\\n        }\\n        if(n > 0) mp[n]++;\\n    }\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> freq_map, cur_freq;\\n        for(int i=0;i<n;i++) primeFactor(nums[i], freq_map);\\n        for(int i=0;i<n-1;i++) {\\n            primeFactor(nums[i], cur_freq);\\n            bool flag = true;\\n            for(auto itr = cur_freq.begin(); itr != cur_freq.end(); ++itr) {\\n                if(freq_map[itr->first] - itr->second > 0) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void primeFactor(int num, unordered_map<int, int>& mp) {\\n        int n = num;\\n        for(int i=2;i<=sqrt(num);i++) {\\n            while(n%i == 0) {\\n                mp[i]++;\\n                n/=i;\\n            }\\n        }\\n        if(n > 0) mp[n]++;\\n    }\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> freq_map, cur_freq;\\n        for(int i=0;i<n;i++) primeFactor(nums[i], freq_map);\\n        for(int i=0;i<n-1;i++) {\\n            primeFactor(nums[i], cur_freq);\\n            bool flag = true;\\n            for(auto itr = cur_freq.begin(); itr != cur_freq.end(); ++itr) {\\n                if(freq_map[itr->first] - itr->second > 0) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259923,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findValidSplit(self, nums):\\n        def prime(n):\\n            divisor = 2\\n            ans = []\\n\\n            while divisor*divisor <= n:\\n                if n%divisor:\\n                    divisor += 1\\n                else:\\n                    n = n//divisor\\n                    ans.append(divisor)\\n\\n            if n > 1:\\n                ans.append(n)\\n\\n            return ans\\n\\n        dict1 = collections.defaultdict(int)\\n\\n        for i in nums:\\n            for j in prime(i):\\n                dict1[j] += 1\\n\\n        dict2 = collections.defaultdict(int)\\n\\n        for i,j in enumerate(nums):\\n            if i == len(nums) - 1:\\n                return -1\\n\\n            for k in prime(j):\\n                dict2[k] += 1\\n                dict1[k] -= 1\\n\\n                if dict1[k] == 0:\\n                    del dict2[k]\\n\\n            if len(dict2) == 0:\\n                return i\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums):\\n        def prime(n):\\n            divisor = 2\\n            ans = []\\n\\n            while divisor*divisor <= n:\\n                if n%divisor:\\n                    divisor += 1\\n                else:\\n                    n = n//divisor\\n                    ans.append(divisor)\\n\\n            if n > 1:\\n                ans.append(n)\\n\\n            return ans\\n\\n        dict1 = collections.defaultdict(int)\\n\\n        for i in nums:\\n            for j in prime(i):\\n                dict1[j] += 1\\n\\n        dict2 = collections.defaultdict(int)\\n\\n        for i,j in enumerate(nums):\\n            if i == len(nums) - 1:\\n                return -1\\n\\n            for k in prime(j):\\n                dict2[k] += 1\\n                dict1[k] -= 1\\n\\n                if dict1[k] == 0:\\n                    del dict2[k]\\n\\n            if len(dict2) == 0:\\n                return i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259910,
                "title": "split-array-to-make-coprime-products-c-spf-map-trick",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<bool> primes;\\n    vector<int> v;\\n \\n    void pre(){\\n        int MAXX = sqrt(1e6+7);\\n        primes.assign(MAXX,1);\\n        for(int p=2; p<=MAXX; p++){\\n            if(primes[p]){\\n                v.push_back(p);\\n                for(int j=p*p; j<=MAXX; j+=p){\\n                    primes[j]=0;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int findValidSplit(vector<int>& nums) {\\n        pre();\\n        int ans = -1, n = nums.size();\\n        map<int,int> mp;\\n        for(int i=0; i<n; i++){\\n            int x = nums[i];\\n            for(auto y: v){\\n                if(x%y==0){\\n                    mp[y]=i;\\n                    while(x&&(x%y==0)){\\n                        x/=y;\\n                    }\\n                \\n                }\\n            }\\n            if(x>1){\\n                mp[x]=i;\\n            }\\n        }\\n\\n        int t = -1;\\n\\n        for(int i=0; i<n-1; i++){\\n           int x = nums[i];\\n            for(auto y: v){\\n                if(x%y==0){\\n                    t = max(t,mp[y]);\\n                    while(x&&(x%y==0)){\\n                        x/=y;\\n                    }\\n                }\\n                }\\n                if(x>1){\\n                    t = max(t,mp[x]);\\n                }\\n\\n            if(t != -1 && t<=i){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<bool> primes;\\n    vector<int> v;\\n \\n    void pre(){\\n        int MAXX = sqrt(1e6+7);\\n        primes.assign(MAXX,1);\\n        for(int p=2; p<=MAXX; p++){\\n            if(primes[p]){\\n                v.push_back(p);\\n                for(int j=p*p; j<=MAXX; j+=p){\\n                    primes[j]=0;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int findValidSplit(vector<int>& nums) {\\n        pre();\\n        int ans = -1, n = nums.size();\\n        map<int,int> mp;\\n        for(int i=0; i<n; i++){\\n            int x = nums[i];\\n            for(auto y: v){\\n                if(x%y==0){\\n                    mp[y]=i;\\n                    while(x&&(x%y==0)){\\n                        x/=y;\\n                    }\\n                \\n                }\\n            }\\n            if(x>1){\\n                mp[x]=i;\\n            }\\n        }\\n\\n        int t = -1;\\n\\n        for(int i=0; i<n-1; i++){\\n           int x = nums[i];\\n            for(auto y: v){\\n                if(x%y==0){\\n                    t = max(t,mp[y]);\\n                    while(x&&(x%y==0)){\\n                        x/=y;\\n                    }\\n                }\\n                }\\n                if(x>1){\\n                    t = max(t,mp[x]);\\n                }\\n\\n            if(t != -1 && t<=i){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259879,
                "title": "c-record-rigth-most-postion-of-each-factor",
                "content": "```\\n\\tpublic int FindValidSplit(int[] nums) {\\n        var rightMost = new Dictionary<int, int>();\\n        var record = new HashSet<int>[nums.Length];\\n        var right = 0;\\n        for (int i = 0; i < nums.Length; i++) {\\n            var factors = GetFactors(nums[i]);\\n            foreach (var factor in factors)\\n                rightMost[factor] = i;\\n            record[i] = factors;\\n        }\\n        for (int i = 0; i < record.Length - 1; i++) {\\n            right = Math.Max(right, record[i].Max(x => rightMost[x]));\\n            if (i != right) continue;\\n            return i;\\n        }\\n        return -1;\\n    }\\n\\n    HashSet<int> GetFactors(int num) {\\n        var factors = new HashSet<int>();\\n        for (int i = 1; i <= Math.Sqrt(num); i++) {\\n            if (num % i != 0) continue;\\n            if (i != 1)\\n                factors.Add(i);\\n            factors.Add(num / i);\\n        }\\n        return factors;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int FindValidSplit(int[] nums) {\\n        var rightMost = new Dictionary<int, int>();\\n        var record = new HashSet<int>[nums.Length];\\n        var right = 0;\\n        for (int i = 0; i < nums.Length; i++) {\\n            var factors = GetFactors(nums[i]);\\n            foreach (var factor in factors)\\n                rightMost[factor] = i;\\n            record[i] = factors;\\n        }\\n        for (int i = 0; i < record.Length - 1; i++) {\\n            right = Math.Max(right, record[i].Max(x => rightMost[x]));\\n            if (i != right) continue;\\n            return i;\\n        }\\n        return -1;\\n    }\\n\\n    HashSet<int> GetFactors(int num) {\\n        var factors = new HashSet<int>();\\n        for (int i = 1; i <= Math.Sqrt(num); i++) {\\n            if (num % i != 0) continue;\\n            if (i != 1)\\n                factors.Add(i);\\n            factors.Add(num / i);\\n        }\\n        return factors;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259767,
                "title": "simple-solved-by-calculating-primefactors-for-each-number-compare-primefactors-using-hashmap",
                "content": "```\\n#define ll long long int\\n\\nbool isCoprime(unordered_map<ll,ll>&pre,unordered_map<ll,ll>&suf){\\n    for(auto x: pre){\\n        if(suf.count(x.first)) // if this is present then return false;\\n            return false;\\n    }\\n    return true;\\n}\\n\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        unordered_map<ll,ll>pre,suf;\\n        for(int i=0;i<nums.size();i++){\\n            int val = nums[i];\\n            for(int j=2;j*j<=val;j++){\\n                while(val%j==0){\\n                     suf[j]++;\\n                    val=val/j;\\n                }\\n            }\\n            \\n            if(val>1)\\n                suf[val]++;\\n        }\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            ll val = nums[i];\\n            for(int j=2;j*j<=val;j++){\\n                while(val%j==0){\\n                    val=val/j;\\n                    pre[j]++;\\n                    suf[j]--;\\n                    if(suf[j]==0) suf.erase(j);\\n                }\\n            }\\n            if(val>1){\\n                suf[val]--;\\n                pre[val]++;\\n                 if(suf[val]==0) suf.erase(val);\\n            }\\n            \\n            if(isCoprime(pre,suf))\\n                return i;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\n\\nbool isCoprime(unordered_map<ll,ll>&pre,unordered_map<ll,ll>&suf){\\n    for(auto x: pre){\\n        if(suf.count(x.first)) // if this is present then return false;\\n            return false;\\n    }\\n    return true;\\n}\\n\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        unordered_map<ll,ll>pre,suf;\\n        for(int i=0;i<nums.size();i++){\\n            int val = nums[i];\\n            for(int j=2;j*j<=val;j++){\\n                while(val%j==0){\\n                     suf[j]++;\\n                    val=val/j;\\n                }\\n            }\\n            \\n            if(val>1)\\n                suf[val]++;\\n        }\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            ll val = nums[i];\\n            for(int j=2;j*j<=val;j++){\\n                while(val%j==0){\\n                    val=val/j;\\n                    pre[j]++;\\n                    suf[j]--;\\n                    if(suf[j]==0) suf.erase(j);\\n                }\\n            }\\n            if(val>1){\\n                suf[val]--;\\n                pre[val]++;\\n                 if(suf[val]==0) suf.erase(val);\\n            }\\n            \\n            if(isCoprime(pre,suf))\\n                return i;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259508,
                "title": "python-accessible-solution-compare-prime-exist-frequency",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that if two nums are coprime when they share same prime divisor except 1. Thus we create left and right dictionary to track the prime exist frequency. If they do not have any same prime value exist, they are coprime.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n0. `def prime_factors(n)` is modified from https://stackoverflow.com/a/22808285.\\n1. Create dictionary `total` to track all prime factors cross all number in `nums`. `left` has same keys to `total` but with all 0 values. Also we can create list `factorNums` to store corresponding prime factors so as not to compute again after when we need it.\\n2. Loop the `factorNums` and add exist frequency to `left` but remove it from `total`\\n3. Check whether they are coprime.\\n    ```python\\n    if left[i] and total[i]:\\n        state = False\\n        break\\n    ```\\n    if they have a same prime (exist frequency both not equal to 0), they must are NOT coprime. Thus we can early break checking loop. Note that since we create `total` at first, so it is not possible that `left[i] == 0` and `total[i] == 0`. \\n4. And if the checking loop not be early stopped. It means that this is valid split and we can return it since problem ask the smallest valid split index.\\n# Complexity\\n- Time complexity: $$O(n)$$ i guess ...\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ i guess ...\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Let me know if there\\'s any mistake!!!\\n# Code\\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        total = {}\\n        left = {}\\n        \\n        def prime_factors(n):\\n            i = 2\\n            factors = []\\n            while i * i <= n:\\n                if n % i:\\n                    i += 1\\n                else:\\n                    n //= i\\n                    factors.append(i)\\n                    left[i] = 0\\n                    if i not in total.keys():\\n                        total[i] = 1\\n                    else:\\n                        total[i] += 1\\n            if n > 1:\\n                factors.append(n)\\n                left[n] = 0\\n                if n not in total.keys():\\n                    total[n] = 1\\n                else:\\n                    total[n] += 1\\n\\n            return factors\\n\\n        factorNums = []\\n        \\n        for n in nums:\\n            factorNums.append(prime_factors(n))\\n        \\n        \\n        for idx, fn in enumerate(factorNums[:-1]):\\n            for n in fn:\\n                left[n] += 1\\n                total[n] -= 1\\n            \\n            state = True\\n            for i in left.keys():\\n                if left[i] and total[i]:\\n                    state = False\\n                    break\\n            \\n            if state:\\n                return idx\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\n    if left[i] and total[i]:\\n        state = False\\n        break\\n    ```\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        total = {}\\n        left = {}\\n        \\n        def prime_factors(n):\\n            i = 2\\n            factors = []\\n            while i * i <= n:\\n                if n % i:\\n                    i += 1\\n                else:\\n                    n //= i\\n                    factors.append(i)\\n                    left[i] = 0\\n                    if i not in total.keys():\\n                        total[i] = 1\\n                    else:\\n                        total[i] += 1\\n            if n > 1:\\n                factors.append(n)\\n                left[n] = 0\\n                if n not in total.keys():\\n                    total[n] = 1\\n                else:\\n                    total[n] += 1\\n\\n            return factors\\n\\n        factorNums = []\\n        \\n        for n in nums:\\n            factorNums.append(prime_factors(n))\\n        \\n        \\n        for idx, fn in enumerate(factorNums[:-1]):\\n            for n in fn:\\n                left[n] += 1\\n                total[n] -= 1\\n            \\n            state = True\\n            for i in left.keys():\\n                if left[i] and total[i]:\\n                    state = False\\n                    break\\n            \\n            if state:\\n                return idx\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259483,
                "title": "java-solution-with-list-and-hashmap-155ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findValidSplit(int[] nums) {\\n        int n = nums.length;\\n        List<List<Integer>> lists = new ArrayList<>();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            lists.add(new ArrayList<>());\\n            prime(lists.get(i), map, nums[i], i);\\n        }\\n        int end = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int index : lists.get(i)) {\\n                end = Math.max(end, map.get(index));\\n            }\\n            if (i == end) {\\n                return i;\\n            }\\n            if (end == n - 1) {\\n                break;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private void prime(List<Integer> lists, Map<Integer, Integer> map, int num, int index) {\\n        for (int i = 2; i * i <= num; i++) {\\n            if (num % i == 0) {\\n                while (num % i == 0) {\\n                    lists.add(i);\\n                    map.put(i, index);\\n                    num /= i;\\n                }\\n            }\\n        }\\n        if (num > 1) {\\n            lists.add(num);\\n            map.put(num, index);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValidSplit(int[] nums) {\\n        int n = nums.length;\\n        List<List<Integer>> lists = new ArrayList<>();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            lists.add(new ArrayList<>());\\n            prime(lists.get(i), map, nums[i], i);\\n        }\\n        int end = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int index : lists.get(i)) {\\n                end = Math.max(end, map.get(index));\\n            }\\n            if (i == end) {\\n                return i;\\n            }\\n            if (end == n - 1) {\\n                break;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private void prime(List<Integer> lists, Map<Integer, Integer> map, int num, int index) {\\n        for (int i = 2; i * i <= num; i++) {\\n            if (num % i == 0) {\\n                while (num % i == 0) {\\n                    lists.add(i);\\n                    map.put(i, index);\\n                    num /= i;\\n                }\\n            }\\n        }\\n        if (num > 1) {\\n            lists.add(num);\\n            map.put(num, index);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259454,
                "title": "simple-modular-python-code-5000ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        @cache\\n        def pfact(num):\\n            hmap = defaultdict(int)\\n            for prime in range(2,isqrt(num)+1):\\n                while num%prime==0:\\n                    hmap[prime]+=1\\n                    num//=prime\\n            if num>1: hmap[num]+=1\\n            return hmap\\n        \\n        \\n        def merge(a,b):\\n            for k in b:\\n                a[k]+=b[k]\\n            \\n\\n        right = defaultdict(int)\\n        left = defaultdict(int)\\n\\n        for num in nums:\\n            curr = pfact(num)\\n            merge(right,curr)\\n        \\n        for i in range(len(nums)-1):\\n            curr = pfact(nums[i])\\n            merge(left,curr)\\n            \\n            if all([left[k]==right[k] for k in left]):\\n                return i\\n        \\n        return -1\\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        @cache\\n        def pfact(num):\\n            hmap = defaultdict(int)\\n            for prime in range(2,isqrt(num)+1):\\n                while num%prime==0:\\n                    hmap[prime]+=1\\n                    num//=prime\\n            if num>1: hmap[num]+=1\\n            return hmap\\n        \\n        \\n        def merge(a,b):\\n            for k in b:\\n                a[k]+=b[k]\\n            \\n\\n        right = defaultdict(int)\\n        left = defaultdict(int)\\n\\n        for num in nums:\\n            curr = pfact(num)\\n            merge(right,curr)\\n        \\n        for i in range(len(nums)-1):\\n            curr = pfact(nums[i])\\n            merge(left,curr)\\n            \\n            if all([left[k]==right[k] for k in left]):\\n                return i\\n        \\n        return -1\\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259440,
                "title": "my-solution",
                "content": "```\\nclass Solution {\\n public:\\n  int findValidSplit(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    unordered_map<int, int> factor_to_first_index;\\n    int max_reach[n];\\n    iota(max_reach, max_reach + n, 0);\\n    for (int index = 0; index < n; ++index) {\\n      int num = nums[index];\\n      for (int factor = 2; factor * factor <= num; ++factor) {\\n        if (num % factor == 0) {\\n          handle_factor(factor_to_first_index, max_reach, index, factor);\\n          while (num % factor == 0) {\\n            num /= factor;\\n          }\\n        }\\n      }\\n      if (num > 1) {\\n        handle_factor(factor_to_first_index, max_reach, index, num);\\n      }\\n    }\\n    \\n    int ret = 0;\\n    for (int index = 0; index < n; ++index) {\\n      if (index > ret) {\\n        break;\\n      }\\n      ret = max(ret, max_reach[index]);\\n    }\\n    return ret == n - 1 ? -1 : ret;\\n  }\\n  \\n private:\\n  void handle_factor(unordered_map<int, int> &factor_to_first_index,\\n                     int *max_reach,\\n                     const int index,\\n                     const int prime_factor) {\\n    auto itr = factor_to_first_index.find(prime_factor);\\n    if (itr == factor_to_first_index.end()) {\\n      factor_to_first_index[prime_factor] = index;\\n    } else {\\n      max_reach[itr->second] = max(max_reach[itr->second], index);\\n    }\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  int findValidSplit(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    unordered_map<int, int> factor_to_first_index;\\n    int max_reach[n];\\n    iota(max_reach, max_reach + n, 0);\\n    for (int index = 0; index < n; ++index) {\\n      int num = nums[index];\\n      for (int factor = 2; factor * factor <= num; ++factor) {\\n        if (num % factor == 0) {\\n          handle_factor(factor_to_first_index, max_reach, index, factor);\\n          while (num % factor == 0) {\\n            num /= factor;\\n          }\\n        }\\n      }\\n      if (num > 1) {\\n        handle_factor(factor_to_first_index, max_reach, index, num);\\n      }\\n    }\\n    \\n    int ret = 0;\\n    for (int index = 0; index < n; ++index) {\\n      if (index > ret) {\\n        break;\\n      }\\n      ret = max(ret, max_reach[index]);\\n    }\\n    return ret == n - 1 ? -1 : ret;\\n  }\\n  \\n private:\\n  void handle_factor(unordered_map<int, int> &factor_to_first_index,\\n                     int *max_reach,\\n                     const int index,\\n                     const int prime_factor) {\\n    auto itr = factor_to_first_index.find(prime_factor);\\n    if (itr == factor_to_first_index.end()) {\\n      factor_to_first_index[prime_factor] = index;\\n    } else {\\n      max_reach[itr->second] = max(max_reach[itr->second], index);\\n    }\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259373,
                "title": "prime-factorization-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrime factorization of all numbers and stored in map\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will store prefix and suffix in unordered_map. And will perform simple prefix sum type operations.\\nLook at the code ypu will understand easily\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>v;\\n    void prime()\\n    {\\n        int n=1e6+10;\\n        v.push_back(0);\\n        for(int i=1;i<=n;i++)\\n            v.push_back(i);\\n        for(int i=2;i*i<=n;i++)\\n        {   \\n            if(v[i]!=i)\\n                continue;\\n            for(int j=i*i;j<=n;j+=i)\\n            {   \\n                if(v[j]==j)\\n                    v[j]=i;\\n            }\\n        }\\n    }\\n    void solve(unordered_map<int,int>&p,int x,int f)\\n    {   \\n        while(x!=1)\\n        {   \\n            if(f==0)\\n                p[v[x]]++;\\n            else\\n                p[v[x]]--;\\n            if(p[v[x]]==0)\\n                p.erase(v[x]);\\n            x=x/v[x];\\n        }\\n    }\\n    int findValidSplit(vector<int>&t) {\\n        int n=t.size();\\n        if(n==1)\\n            return -1;\\n        prime();\\n        unordered_map<int,int>p;\\n        unordered_map<int,int>s;\\n        solve(p,t[0],0);\\n        for(int i=1;i<n;i++)\\n            solve(s,t[i],0);\\n        for(int i=0;i<n-1;i++)\\n        {   \\n            int f=0;\\n            for(auto j:p)\\n            {\\n                if(s.find(j.first)!=s.end())\\n                {\\n                    f=1;\\n                    break;\\n                }\\n            }\\n            if(f==0)\\n                return i;\\n            solve(p,t[i+1],0);\\n            solve(s,t[i+1],1);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>v;\\n    void prime()\\n    {\\n        int n=1e6+10;\\n        v.push_back(0);\\n        for(int i=1;i<=n;i++)\\n            v.push_back(i);\\n        for(int i=2;i*i<=n;i++)\\n        {   \\n            if(v[i]!=i)\\n                continue;\\n            for(int j=i*i;j<=n;j+=i)\\n            {   \\n                if(v[j]==j)\\n                    v[j]=i;\\n            }\\n        }\\n    }\\n    void solve(unordered_map<int,int>&p,int x,int f)\\n    {   \\n        while(x!=1)\\n        {   \\n            if(f==0)\\n                p[v[x]]++;\\n            else\\n                p[v[x]]--;\\n            if(p[v[x]]==0)\\n                p.erase(v[x]);\\n            x=x/v[x];\\n        }\\n    }\\n    int findValidSplit(vector<int>&t) {\\n        int n=t.size();\\n        if(n==1)\\n            return -1;\\n        prime();\\n        unordered_map<int,int>p;\\n        unordered_map<int,int>s;\\n        solve(p,t[0],0);\\n        for(int i=1;i<n;i++)\\n            solve(s,t[i],0);\\n        for(int i=0;i<n-1;i++)\\n        {   \\n            int f=0;\\n            for(auto j:p)\\n            {\\n                if(s.find(j.first)!=s.end())\\n                {\\n                    f=1;\\n                    break;\\n                }\\n            }\\n            if(f==0)\\n                return i;\\n            solve(p,t[i+1],0);\\n            solve(s,t[i+1],1);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259347,
                "title": "c-2-maps-store-factors-of-each-number",
                "content": "# Code\\n```\\nclass Solution\\n{\\n\\tpublic:\\n\\tunordered_map<int, int> leftmp;\\n\\tunordered_map<int, int> rightmp;\\n\\n\\tvoid addDivisors(int n)\\n\\t{\\n\\t\\tfor (int i = 1; i <= sqrt(n); i++)\\n\\t\\t{\\n\\t\\t\\tif (n % i == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (n / i == i && isPrime(i))\\n\\t\\t\\t\\t\\tleftmp[i]++;\\n\\n\\t\\t\\t\\telse if (isPrime(i) && isPrime(n / i))\\n\\t\\t\\t\\t\\tleftmp[i]++;\\n\\t\\t\\t\\tleftmp[n / i]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvoid minusDivisors(int n)\\n\\t{\\n\\t\\tfor (int i = 1; i <= sqrt(n); i++)\\n\\t\\t{\\n\\t\\t\\tif (n % i == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (n / i == i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\trightmp[i]--;\\n\\t\\t\\t\\t\\tif (rightmp[i] <= 0)\\n\\t\\t\\t\\t\\t\\trightmp.erase(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\trightmp[i]--;\\n\\t\\t\\t\\t\\trightmp[n / i]--;\\n\\t\\t\\t\\t\\tif (rightmp[i] <= 0)\\n\\t\\t\\t\\t\\t\\trightmp.erase(i);\\n\\t\\t\\t\\t\\tif (rightmp[n / i] <= 0)\\n\\t\\t\\t\\t\\t\\trightmp.erase(n / i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tbool isPrime(int n)\\n\\t{\\n\\t\\tif (n <= 1)\\n\\t\\t\\treturn false;\\n\\n\\t\\tfor (int i = 2; i < n; i++)\\n\\t\\t\\tif (n % i == 0)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\tbool check()\\n\\t{\\n\\t\\tfor (auto x: leftmp)\\n\\t\\t{\\n\\t\\t\\tif (x.first != 1 && rightmp.find(x.first) != rightmp.end())\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\tint findValidSplit(vector<int> &nums)\\n\\t{\\n\\t\\tfor (auto n: nums)\\n\\t\\t{\\n\\t\\t\\tfor (int i = 1; i <= sqrt(n); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (n % i == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (n / i == i && isPrime(i))\\n\\t\\t\\t\\t\\t\\trightmp[i]++;\\n\\n\\t\\t\\t\\t\\telse if (isPrime(i) && isPrime(n / i))\\n\\t\\t\\t\\t\\t\\trightmp[i]++;\\n\\t\\t\\t\\t\\trightmp[n / i]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < nums.size() - 1; i++)\\n\\t\\t{\\n\\t\\t\\taddDivisors(nums[i]);\\n\\t\\t\\tminusDivisors(nums[i]);\\n\\t\\t\\tif (check())\\n\\t\\t\\t\\treturn i;\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n\\tpublic:\\n\\tunordered_map<int, int> leftmp;\\n\\tunordered_map<int, int> rightmp;\\n\\n\\tvoid addDivisors(int n)\\n\\t{\\n\\t\\tfor (int i = 1; i <= sqrt(n); i++)\\n\\t\\t{\\n\\t\\t\\tif (n % i == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (n / i == i && isPrime(i))\\n\\t\\t\\t\\t\\tleftmp[i]++;\\n\\n\\t\\t\\t\\telse if (isPrime(i) && isPrime(n / i))\\n\\t\\t\\t\\t\\tleftmp[i]++;\\n\\t\\t\\t\\tleftmp[n / i]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvoid minusDivisors(int n)\\n\\t{\\n\\t\\tfor (int i = 1; i <= sqrt(n); i++)\\n\\t\\t{\\n\\t\\t\\tif (n % i == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (n / i == i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\trightmp[i]--;\\n\\t\\t\\t\\t\\tif (rightmp[i] <= 0)\\n\\t\\t\\t\\t\\t\\trightmp.erase(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\trightmp[i]--;\\n\\t\\t\\t\\t\\trightmp[n / i]--;\\n\\t\\t\\t\\t\\tif (rightmp[i] <= 0)\\n\\t\\t\\t\\t\\t\\trightmp.erase(i);\\n\\t\\t\\t\\t\\tif (rightmp[n / i] <= 0)\\n\\t\\t\\t\\t\\t\\trightmp.erase(n / i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tbool isPrime(int n)\\n\\t{\\n\\t\\tif (n <= 1)\\n\\t\\t\\treturn false;\\n\\n\\t\\tfor (int i = 2; i < n; i++)\\n\\t\\t\\tif (n % i == 0)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\tbool check()\\n\\t{\\n\\t\\tfor (auto x: leftmp)\\n\\t\\t{\\n\\t\\t\\tif (x.first != 1 && rightmp.find(x.first) != rightmp.end())\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\tint findValidSplit(vector<int> &nums)\\n\\t{\\n\\t\\tfor (auto n: nums)\\n\\t\\t{\\n\\t\\t\\tfor (int i = 1; i <= sqrt(n); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (n % i == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (n / i == i && isPrime(i))\\n\\t\\t\\t\\t\\t\\trightmp[i]++;\\n\\n\\t\\t\\t\\t\\telse if (isPrime(i) && isPrime(n / i))\\n\\t\\t\\t\\t\\t\\trightmp[i]++;\\n\\t\\t\\t\\t\\trightmp[n / i]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < nums.size() - 1; i++)\\n\\t\\t{\\n\\t\\t\\taddDivisors(nums[i]);\\n\\t\\t\\tminusDivisors(nums[i]);\\n\\t\\t\\tif (check())\\n\\t\\t\\t\\treturn i;\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259171,
                "title": "go-typescript-prime-factorization-170ms",
                "content": "```golang []\\n// we only need prime factors up to sqrt(n) \\nvar primes = []int{\\n\\t2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\\n\\t67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137,\\n\\t139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211,\\n\\t223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283,\\n\\t293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,\\n\\t383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461,\\n\\t463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563,\\n\\t569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,\\n\\t647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739,\\n\\t743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829,\\n\\t839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937,\\n\\t941, 947, 953, 967, 971, 977, 983, 991, 997,\\n}\\n\\n// factorize returns the prime factorization of the given integer\\nfunc factorize(n int) []int {\\n\\tfactors := make([]int, 20)\\n\\tos := 0\\n\\ts := int(math.Sqrt(float64(n)))\\n\\tfor i := 0; i < len(primes); i++ {\\n\\t\\tif primes[i] > s {\\n\\t\\t\\tbreak\\n\\t\\t}\\n        changed := false\\n\\t\\tfor n%primes[i] == 0 {\\n\\t\\t\\tfactors[os] = primes[i]\\n\\t\\t\\tos++\\n\\t\\t\\tn /= primes[i]\\n            changed = true\\n\\t\\t}\\n        if changed {\\n            s = int(math.Sqrt(float64(n)))\\n        }\\n\\t}\\n\\tif n > 1 {\\n\\t\\tfactors[os] = n\\n\\t\\tos++\\n\\t}\\n\\treturn factors[0:os]\\n}\\n\\nfunc findValidSplit(nums []int) int {\\n\\tn, prefix, suffix := len(nums), make(map[int]bool), make(map[int]int)\\n\\n    // create a map of all factors inside suffix\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor _, f := range factorize(nums[i]) {\\n\\t\\t\\tsuffix[f]++\\n\\t\\t}\\n\\t}\\n\\n    // loop through nums again, removing factors from suffix and adding them to prefix\\n    // once factor no longer in suffix, remove it from prefix\\n    // once prefix is empty, then the prefix and suffix are coprime\\n\\tn--\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor _, f := range factorize(nums[i]) {\\n\\t\\t\\tsuffix[f]--\\n\\t\\t\\tif suffix[f] == 0 {\\n\\t\\t\\t\\tdelete(prefix, f)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tprefix[f] = true\\n\\t\\t\\t}\\n\\t\\t}\\n        if len(prefix) == 0 {\\n            return i\\n        }\\n\\t}\\n\\n\\treturn -1\\n}\\n```\\n```typescript []\\nconst primes: number[] = [\\n  2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\\n  67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137,\\n  139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211,\\n  223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283,\\n  293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,\\n  383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461,\\n  463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563,\\n  569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,\\n  647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739,\\n  743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829,\\n  839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937,\\n  941, 947, 953, 967, 971, 977, 983, 991, 997,\\n];\\n\\n// factorize returns the prime factorization of the given integer\\nfunction factorize(n: number): number[] {\\n  const factors: number[] = []\\n  for (let i = 0, s = Math.sqrt(n), l = primes.length; i < l; ++i) {\\n    if (primes[i] > s) {\\n      break\\n    }\\n\\n    let changed = false;\\n    while (n % primes[i] === 0) {\\n      factors.push(primes[i])\\n      n /= primes[i]\\n      changed = true\\n    }\\n\\n    if (changed) {\\n      s = Math.sqrt(n)\\n    }\\n  }\\n\\n  if (n > 1) {\\n    factors.push(n)\\n  }\\n\\n  return factors\\n}\\n\\nfunction findValidSplit(nums: number[]): number {\\n  const n = nums.length,\\n    prefix: {[key: number]: boolean} = {},\\n    suffix: {[key: number]: number} = {}\\n\\n  // create a map of all factors inside suffix\\n  for (let i = 0; i < n; ++i) {\\n    for (const f of factorize(nums[i])) {\\n      suffix[f] = (suffix[f] || 0) + 1\\n    }\\n  }\\n\\n  // loop through nums again, removing factors from suffix and adding them to prefix\\n  // once factor no longer in suffix, remove it from prefix\\n  // once prefix is empty, then the prefix and suffix are coprime\\n  for (let i = 0, prefixSize = 0, l = n - 1; i < l; ++i) {\\n    for (const f of factorize(nums[i])) {\\n      --suffix[f]\\n      if (suffix[f] === 0) {\\n        if (prefix.hasOwnProperty(f)) {\\n          --prefixSize\\n          delete prefix[f]\\n        }\\n      } else {\\n        if (!prefix.hasOwnProperty(f)) {\\n          ++prefixSize\\n          prefix[f] = true\\n        }\\n      }\\n    }\\n    if (prefixSize === 0) {\\n      return i\\n    }\\n  }\\n\\n  return -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "TypeScript",
                    "Number Theory"
                ],
                "code": "```golang []\\n// we only need prime factors up to sqrt(n) \\nvar primes = []int{\\n\\t2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\\n\\t67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137,\\n\\t139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211,\\n\\t223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283,\\n\\t293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,\\n\\t383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461,\\n\\t463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563,\\n\\t569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,\\n\\t647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739,\\n\\t743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829,\\n\\t839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937,\\n\\t941, 947, 953, 967, 971, 977, 983, 991, 997,\\n}\\n\\n// factorize returns the prime factorization of the given integer\\nfunc factorize(n int) []int {\\n\\tfactors := make([]int, 20)\\n\\tos := 0\\n\\ts := int(math.Sqrt(float64(n)))\\n\\tfor i := 0; i < len(primes); i++ {\\n\\t\\tif primes[i] > s {\\n\\t\\t\\tbreak\\n\\t\\t}\\n        changed := false\\n\\t\\tfor n%primes[i] == 0 {\\n\\t\\t\\tfactors[os] = primes[i]\\n\\t\\t\\tos++\\n\\t\\t\\tn /= primes[i]\\n            changed = true\\n\\t\\t}\\n        if changed {\\n            s = int(math.Sqrt(float64(n)))\\n        }\\n\\t}\\n\\tif n > 1 {\\n\\t\\tfactors[os] = n\\n\\t\\tos++\\n\\t}\\n\\treturn factors[0:os]\\n}\\n\\nfunc findValidSplit(nums []int) int {\\n\\tn, prefix, suffix := len(nums), make(map[int]bool), make(map[int]int)\\n\\n    // create a map of all factors inside suffix\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor _, f := range factorize(nums[i]) {\\n\\t\\t\\tsuffix[f]++\\n\\t\\t}\\n\\t}\\n\\n    // loop through nums again, removing factors from suffix and adding them to prefix\\n    // once factor no longer in suffix, remove it from prefix\\n    // once prefix is empty, then the prefix and suffix are coprime\\n\\tn--\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor _, f := range factorize(nums[i]) {\\n\\t\\t\\tsuffix[f]--\\n\\t\\t\\tif suffix[f] == 0 {\\n\\t\\t\\t\\tdelete(prefix, f)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tprefix[f] = true\\n\\t\\t\\t}\\n\\t\\t}\\n        if len(prefix) == 0 {\\n            return i\\n        }\\n\\t}\\n\\n\\treturn -1\\n}\\n```\n```typescript []\\nconst primes: number[] = [\\n  2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\\n  67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137,\\n  139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211,\\n  223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283,\\n  293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,\\n  383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461,\\n  463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563,\\n  569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,\\n  647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739,\\n  743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829,\\n  839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937,\\n  941, 947, 953, 967, 971, 977, 983, 991, 997,\\n];\\n\\n// factorize returns the prime factorization of the given integer\\nfunction factorize(n: number): number[] {\\n  const factors: number[] = []\\n  for (let i = 0, s = Math.sqrt(n), l = primes.length; i < l; ++i) {\\n    if (primes[i] > s) {\\n      break\\n    }\\n\\n    let changed = false;\\n    while (n % primes[i] === 0) {\\n      factors.push(primes[i])\\n      n /= primes[i]\\n      changed = true\\n    }\\n\\n    if (changed) {\\n      s = Math.sqrt(n)\\n    }\\n  }\\n\\n  if (n > 1) {\\n    factors.push(n)\\n  }\\n\\n  return factors\\n}\\n\\nfunction findValidSplit(nums: number[]): number {\\n  const n = nums.length,\\n    prefix: {[key: number]: boolean} = {},\\n    suffix: {[key: number]: number} = {}\\n\\n  // create a map of all factors inside suffix\\n  for (let i = 0; i < n; ++i) {\\n    for (const f of factorize(nums[i])) {\\n      suffix[f] = (suffix[f] || 0) + 1\\n    }\\n  }\\n\\n  // loop through nums again, removing factors from suffix and adding them to prefix\\n  // once factor no longer in suffix, remove it from prefix\\n  // once prefix is empty, then the prefix and suffix are coprime\\n  for (let i = 0, prefixSize = 0, l = n - 1; i < l; ++i) {\\n    for (const f of factorize(nums[i])) {\\n      --suffix[f]\\n      if (suffix[f] === 0) {\\n        if (prefix.hasOwnProperty(f)) {\\n          --prefixSize\\n          delete prefix[f]\\n        }\\n      } else {\\n        if (!prefix.hasOwnProperty(f)) {\\n          ++prefixSize\\n          prefix[f] = true\\n        }\\n      }\\n    }\\n    if (prefixSize === 0) {\\n      return i\\n    }\\n  }\\n\\n  return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259011,
                "title": "python-count-factors-simple-solution",
                "content": "\\n# Code\\n```\\nfrom math import sqrt\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return -1\\n        def factors(num):\\n            counter = Counter()\\n            sqroot = int(sqrt(num))\\n            i = 2\\n            while num > 1 and i <= sqroot:\\n                if num%i:\\n                    i += 1\\n                else:\\n                    num //= i\\n                    counter[i] += 1\\n            if num > 1: counter[num] += 1\\n            return counter\\n        n = len(nums)\\n        factorlist = [0]*n\\n        for i in range(n):\\n            factorlist[i] = factors(nums[i])\\n        left, right = Counter(), Counter()\\n        for i in range(n):\\n            right += factorlist[i]\\n        overlap = 0\\n        for i in range(n-1):\\n            cur = factorlist[i]\\n            for k in cur:\\n                if not left[k]:\\n                    overlap += 1\\n                left[k] += cur[k]\\n                if left[k] == right[k]:\\n                    overlap -= 1\\n                if not overlap: return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import sqrt\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return -1\\n        def factors(num):\\n            counter = Counter()\\n            sqroot = int(sqrt(num))\\n            i = 2\\n            while num > 1 and i <= sqroot:\\n                if num%i:\\n                    i += 1\\n                else:\\n                    num //= i\\n                    counter[i] += 1\\n            if num > 1: counter[num] += 1\\n            return counter\\n        n = len(nums)\\n        factorlist = [0]*n\\n        for i in range(n):\\n            factorlist[i] = factors(nums[i])\\n        left, right = Counter(), Counter()\\n        for i in range(n):\\n            right += factorlist[i]\\n        overlap = 0\\n        for i in range(n-1):\\n            cur = factorlist[i]\\n            for k in cur:\\n                if not left[k]:\\n                    overlap += 1\\n                left[k] += cur[k]\\n                if left[k] == right[k]:\\n                    overlap -= 1\\n                if not overlap: return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258921,
                "title": "python-solution-merge-intervals-based-on-prime-factor-time-o-nlogn",
                "content": "The idea is to create `interval` for all prime factors.\\nThen, we can do `interval merge` for them. \\n```\\ndef findValidSplit(self, nums: List[int]) -> int:        \\n\\tdef prime(x):\\n\\t\\tpf = set()\\n\\t\\tfor i in range(2, int(sqrt(x))+1):\\n\\t\\t\\tif all(i%k for k in pf):\\n\\t\\t\\t\\tpf.add(i)\\n\\t\\treturn pf\\n\\t\\t\\n\\t# create intervals for all prime factors\\n\\tfactors, prime_index, lst = prime(max(nums)), {}, []\\n\\tfor i, n in enumerate(nums):\\n\\t\\tfor f in factors:\\n\\t\\t\\twhile (n%f==0):\\n\\t\\t\\t\\tn //= f\\n\\t\\t\\t\\tif f not in prime_index:\\n\\t\\t\\t\\t\\tprime_index[f] = [i, i]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tprime_index[f][1] = i\\n\\t\\tif n>1:\\n\\t\\t\\tif n not in prime_index:\\n\\t\\t\\t\\tprime_index[n] = [i, i]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tprime_index[n][1] = i\\n\\n\\t# merge intervals\\n\\tfor i, j in sorted(prime_index.values()):\\n\\t\\tif not lst or lst[-1][1]<i:\\n\\t\\t\\tlst.append([i, j])\\n\\t\\telse:\\n\\t\\t\\tlst[-1][1] = max(lst[-1][1], j)\\n\\treturn lst[0][1] if len(lst)>1 else -1\\n```\\nFor `time complexity` analysis, \\n1. `create intervals - O(Nlog(max)) ~ O(N)`\\n2. `merge intervals - O(NlogN)`\\nSo the total time complexity will be **O(NlogN)**",
                "solutionTags": [],
                "code": "```\\ndef findValidSplit(self, nums: List[int]) -> int:        \\n\\tdef prime(x):\\n\\t\\tpf = set()\\n\\t\\tfor i in range(2, int(sqrt(x))+1):\\n\\t\\t\\tif all(i%k for k in pf):\\n\\t\\t\\t\\tpf.add(i)\\n\\t\\treturn pf\\n\\t\\t\\n\\t# create intervals for all prime factors\\n\\tfactors, prime_index, lst = prime(max(nums)), {}, []\\n\\tfor i, n in enumerate(nums):\\n\\t\\tfor f in factors:\\n\\t\\t\\twhile (n%f==0):\\n\\t\\t\\t\\tn //= f\\n\\t\\t\\t\\tif f not in prime_index:\\n\\t\\t\\t\\t\\tprime_index[f] = [i, i]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tprime_index[f][1] = i\\n\\t\\tif n>1:\\n\\t\\t\\tif n not in prime_index:\\n\\t\\t\\t\\tprime_index[n] = [i, i]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tprime_index[n][1] = i\\n\\n\\t# merge intervals\\n\\tfor i, j in sorted(prime_index.values()):\\n\\t\\tif not lst or lst[-1][1]<i:\\n\\t\\t\\tlst.append([i, j])\\n\\t\\telse:\\n\\t\\t\\tlst[-1][1] = max(lst[-1][1], j)\\n\\treturn lst[0][1] if len(lst)>1 else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3258864,
                "title": "simple-python-logic-that-deals-with-the-tle-issue-surely-isn-t-a-medium-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom math import gcd\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i, a in enumerate(nums[:-1]):\\n            for j, b in enumerate(nums[ans:], ans):\\n                if gcd(a, b) != 1:\\n                    ans = j\\n            if i == ans:\\n                return ans\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import gcd\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i, a in enumerate(nums[:-1]):\\n            for j, b in enumerate(nums[ans:], ans):\\n                if gcd(a, b) != 1:\\n                    ans = j\\n            if i == ans:\\n                return ans\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258819,
                "title": "last-occurence-of-each-prime-factor-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    set<int> primefactors(int n){\\n        set<int> mp;\\n        for(int i = 2; i * i <= n; i++){\\n            while(n % i == 0) {\\n                mp.insert(i);\\n                n /= i;\\n            }\\n        }\\n        if( n > 1 ) mp.insert(n);\\n        return mp;\\n    }\\n    \\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // storing prime factors for every index\\n        vector<set<int>> vec;\\n        for(int i = 0; i < n; i++){\\n            auto temp = primefactors(nums[i]);\\n            vec.push_back(temp);\\n            \\n        }\\n\\n        // mapping last occurence of all prime factors\\n        map<int,int> mp;\\n        for(int i = 0; i < n; i++){\\n            for(auto &j: vec[i]){\\n                mp[j] = i;\\n            }\\n        }\\n        \\n        // return index where last index for each prime factor <= index\\n        int longend = 1;\\n        for(int i = 0; i < n - 1; i++){\\n            for(auto &j: vec[i]){\\n                longend = max(longend, mp[j]);\\n                if(i == longend){\\n                    return i;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    set<int> primefactors(int n){\\n        set<int> mp;\\n        for(int i = 2; i * i <= n; i++){\\n            while(n % i == 0) {\\n                mp.insert(i);\\n                n /= i;\\n            }\\n        }\\n        if( n > 1 ) mp.insert(n);\\n        return mp;\\n    }\\n    \\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // storing prime factors for every index\\n        vector<set<int>> vec;\\n        for(int i = 0; i < n; i++){\\n            auto temp = primefactors(nums[i]);\\n            vec.push_back(temp);\\n            \\n        }\\n\\n        // mapping last occurence of all prime factors\\n        map<int,int> mp;\\n        for(int i = 0; i < n; i++){\\n            for(auto &j: vec[i]){\\n                mp[j] = i;\\n            }\\n        }\\n        \\n        // return index where last index for each prime factor <= index\\n        int longend = 1;\\n        for(int i = 0; i < n - 1; i++){\\n            for(auto &j: vec[i]){\\n                longend = max(longend, mp[j]);\\n                if(i == longend){\\n                    return i;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258750,
                "title": "java-prime-factorization-215-ms",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findValidSplit(int[] nums) {\\n        int n=nums.length;\\n        int[] idx=new int[1000000];\\n        Arrays.fill(idx, -1);\\n        for (int i=n-1; i>=0; --i) {\\n            int p=2, x=nums[i];\\n            while (p*p<=x) {\\n                while (x%p==0) {\\n                    if (idx[p]==-1) idx[p]=i;\\n                    x/=p;\\n                }\\n                p++;                \\n            }\\n            if (x>1 && idx[x]==-1) idx[x]=i;\\n        }\\n        int right=-1;\\n        for (int i=0; i<n-1; ++i) {\\n            int x=nums[i], p=2;\\n            while (p*p<=x) {\\n                while (x%p==0) {\\n                    x/=p;\\n                    right=Math.max(right, idx[p]);\\n                }\\n                p++;\\n            }\\n            if (x>1) right=Math.max(right, idx[x]);\\n            if (right==i) return i;                        \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findValidSplit(int[] nums) {\\n        int n=nums.length;\\n        int[] idx=new int[1000000];\\n        Arrays.fill(idx, -1);\\n        for (int i=n-1; i>=0; --i) {\\n            int p=2, x=nums[i];\\n            while (p*p<=x) {\\n                while (x%p==0) {\\n                    if (idx[p]==-1) idx[p]=i;\\n                    x/=p;\\n                }\\n                p++;                \\n            }\\n            if (x>1 && idx[x]==-1) idx[x]=i;\\n        }\\n        int right=-1;\\n        for (int i=0; i<n-1; ++i) {\\n            int x=nums[i], p=2;\\n            while (p*p<=x) {\\n                while (x%p==0) {\\n                    x/=p;\\n                    right=Math.max(right, idx[p]);\\n                }\\n                p++;\\n            }\\n            if (x>1) right=Math.max(right, idx[x]);\\n            if (right==i) return i;                        \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258738,
                "title": "decompose-the-numbers",
                "content": "# Intuition\\nDecompose the numbers and check each prime factor.\\n\\n# Approach\\nFor each prime factor, all of them should be on the left or right side.\\n\\n# Complexity\\n- Time complexity:\\nO(n * sqrt(max num))\\n- Space complexity:\\nO(n * sqrt(max num))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<unordered_set<int>> have(n);\\n        unordered_map<int, int> all;\\n        for (int i = 0; i < n; ++i) {\\n            for (int x = 2; x * x <= nums[i]; ++x) {\\n                if (nums[i] % x == 0) {\\n                    have[i].insert(x);\\n                    ++all[x];\\n                    do {\\n                        nums[i] /= x;\\n                    } while (nums[i] % x == 0);\\n                }\\n            }\\n            if (nums[i] > 1) {\\n                have[i].insert(nums[i]);\\n                ++all[nums[i]];\\n            }\\n        }\\n        unordered_map<int, int> now;\\n        for (int i = 0, invalid = 0; i + 1 < n; ++i) {\\n            for (int x : have[i]) {\\n                const int p = ++now[x] - all[x];\\n                if (now[x] == 1) {\\n                    if (p < 0) {\\n                        ++invalid;\\n                    }\\n                } else if (p == 0) {\\n                    --invalid;\\n                }\\n                if (invalid == 0) {\\n                    return i;\\n                }\\n                \\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<unordered_set<int>> have(n);\\n        unordered_map<int, int> all;\\n        for (int i = 0; i < n; ++i) {\\n            for (int x = 2; x * x <= nums[i]; ++x) {\\n                if (nums[i] % x == 0) {\\n                    have[i].insert(x);\\n                    ++all[x];\\n                    do {\\n                        nums[i] /= x;\\n                    } while (nums[i] % x == 0);\\n                }\\n            }\\n            if (nums[i] > 1) {\\n                have[i].insert(nums[i]);\\n                ++all[nums[i]];\\n            }\\n        }\\n        unordered_map<int, int> now;\\n        for (int i = 0, invalid = 0; i + 1 < n; ++i) {\\n            for (int x : have[i]) {\\n                const int p = ++now[x] - all[x];\\n                if (now[x] == 1) {\\n                    if (p < 0) {\\n                        ++invalid;\\n                    }\\n                } else if (p == 0) {\\n                    --invalid;\\n                }\\n                if (invalid == 0) {\\n                    return i;\\n                }\\n                \\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258673,
                "title": "clean-and-neat-solution-with-comments-and-begginer-friendly-0-nsqrt-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n void primeFactors(int n , unordered_set<int> &m) \\n{ \\n    // Print the number of 2s that divide n \\n    while (n%2 == 0) \\n    { \\n        m.insert(2);\\n        n = n/2; \\n    } \\n     \\n    // n must be odd at this point.  So we can skip  \\n    // one element (Note i = i +2) \\n    for (int i = 3; i <= sqrt(n); i = i+2) \\n    { \\n        // While i divides n, print i and divide n \\n        while (n%i == 0) \\n        { \\n            m.insert(i);\\n            n = n/i; \\n        } \\n    } \\n     \\n    // This condition is to handle the case when n  \\n    // is a prime number greater than 2 \\n    if (n > 2) \\n    m.insert(n);\\n} \\n    int findValidSplit(vector<int>& nums) {\\n        // very good question , the problem is we have to split array into two parts such that they dont have any factors in common\\n        int n=nums.size();\\n        vector<int> l_id(1e6 , -1);// stores last index of a factor\\n        for(int i=0 ;i<n ;i++){\\n        unordered_set<int> m;\\n       primeFactors(nums[i], m);\\n        for(auto f: m){\\n        l_id[f]=i;\\n        }\\n        }\\n    int i=0 , j=0;// two pointers\\n    while(i<=j && j<n){\\n          unordered_set<int> m;\\n     primeFactors(nums[i] , m);\\n     for(auto f: m){\\n     j=max(j , l_id[f]);\\n     }// we are making sure to split such that there exixts no common factos.\\n     i++;\\n    }\\n    if(j==n-1)return -1;\\n    return j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n void primeFactors(int n , unordered_set<int> &m) \\n{ \\n    // Print the number of 2s that divide n \\n    while (n%2 == 0) \\n    { \\n        m.insert(2);\\n        n = n/2; \\n    } \\n     \\n    // n must be odd at this point.  So we can skip  \\n    // one element (Note i = i +2) \\n    for (int i = 3; i <= sqrt(n); i = i+2) \\n    { \\n        // While i divides n, print i and divide n \\n        while (n%i == 0) \\n        { \\n            m.insert(i);\\n            n = n/i; \\n        } \\n    } \\n     \\n    // This condition is to handle the case when n  \\n    // is a prime number greater than 2 \\n    if (n > 2) \\n    m.insert(n);\\n} \\n    int findValidSplit(vector<int>& nums) {\\n        // very good question , the problem is we have to split array into two parts such that they dont have any factors in common\\n        int n=nums.size();\\n        vector<int> l_id(1e6 , -1);// stores last index of a factor\\n        for(int i=0 ;i<n ;i++){\\n        unordered_set<int> m;\\n       primeFactors(nums[i], m);\\n        for(auto f: m){\\n        l_id[f]=i;\\n        }\\n        }\\n    int i=0 , j=0;// two pointers\\n    while(i<=j && j<n){\\n          unordered_set<int> m;\\n     primeFactors(nums[i] , m);\\n     for(auto f: m){\\n     j=max(j , l_id[f]);\\n     }// we are making sure to split such that there exixts no common factos.\\n     i++;\\n    }\\n    if(j==n-1)return -1;\\n    return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258668,
                "title": "java-solution",
                "content": "**My Approach is to fill all the prime factors in the map and also the number of time a particular factor appears\\nThen after filling the whole map follow the following steps :-\\n1. Carry a set that will contain all the factors untill now\\n2. Iterate from index 0 to n-1\\n3. Remove all the occurence of the factor of the nums[i] from map and add it to the set because at that point suffix does not contains those factors and prefix does\\n4. Check wheather we have any factors common in prefix and suffix or not\\n5. if there is then it is not coprime partition and move on to next index otherwise return current index.**\\n\\n\\n\\nclass Solution {\\n\\n    public int findValidSplit(int[] nums) {\\n        int n=nums.length;\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            fillMap(map,nums[i]);   //this will fill our map.from end to start that how many prime factors are available till this point.\\n        }\\n        Set<Integer> set=new HashSet<>();  // it will carry the prefix prime factors available.\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(checkCoPrime(map,nums[i],set))  //if at this point we got prime factors partition then return this index.\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    void fillMap(Map<Integer,Integer> map,int num) //function to fill map with the prime factors.\\n    {\\n        int i=2;\\n        while(num>1 && i<=Math.sqrt(num))\\n        {\\n            if(num%i==0)  //if i can divide the number then add i as prime factor in our map.\\n            {\\n                num/=i;\\n                map.put(i,map.getOrDefault(i,0)+1);\\n            }\\n            else  //if not then try the next number\\n            {\\n                i++;\\n            }\\n        }\\n        if(num>1) //just in case if the number would\\'ve been prime than the number itself needs to be added in the map\\n        {\\n            map.put(num,map.getOrDefault(num,0)+1);\\n        }\\n    }\\n    \\n    boolean checkCoPrime(Map<Integer,Integer> map,int num,Set<Integer> set) //function to check coprime\\n    {\\n\\t//firstly remove the prime factors of this particular number from map so that we can have all the factors after this index in our map.\\n\\t//also add the factors in set so that we know that which factors came untill now in the prefix array\\n        int i=2;\\n        while(num>1 && i<=Math.sqrt(num))\\n        {\\n            if(num%i==0)\\n            {\\n                num/=i;\\n                set.add(i);\\n                map.put(i,map.get(i)-1);\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        if(num>1)\\n        {\\n            set.add(num);\\n            map.put(num,map.get(num)-1);\\n        }\\n\\t\\t\\n\\t\\t//now checking that wheather the prime factors available in set is still available in map or not \\n        for(int ele : set)\\n        {\\n            if(map.get(ele)>0)\\n            {\\n                return false; //if it is then not a prime factor\\n            }\\n        }\\n        \\n        return true; //otherwise it is\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int findValidSplit(int[] nums) {\\n        int n=nums.length;\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            fillMap(map,nums[i]);   //this will fill our map.from end to start that how many prime factors are available till this point.\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3258638,
                "title": "c",
                "content": "```\\nclass Solution {\\n    void helper(unordered_map<int, int>&factor, int& val){\\n        int d = val ;\\n        for(int i = 2 ;  i<= sqrt(val) ; i++){\\n            while(d % i == 0){\\n                factor[i]++ ;\\n                d /= i ;\\n            }\\n            if(d == 1)\\n                break ;\\n        }\\n        if(d > 1)\\n            factor[d]++ ;\\n    }\\n    \\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size() ;\\n        unordered_map<int, int>factor ; // {factor, count}\\n        for(auto& n : nums)\\n            helper(factor, n) ;\\n        \\n        unordered_map<int, int>cur ;\\n        \\n        for(int i = 0; i < n-1; i++){\\n            vector<int>remove ;\\n            helper(cur, nums[i]) ;\\n            bool flag = true ;\\n            for(auto& c : cur){\\n                if(c.second < factor[c.first]){\\n                    flag = false ;\\n                    break ;\\n                }\\n                if(c.second == factor[c.first])\\n                    remove.push_back(c.first) ;\\n            }\\n            if(flag == true)\\n                return i ;\\n            \\n            for(int k = 0; k < remove.size(); k++)\\n                cur.erase(remove[k]) ;\\n                        \\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void helper(unordered_map<int, int>&factor, int& val){\\n        int d = val ;\\n        for(int i = 2 ;  i<= sqrt(val) ; i++){\\n            while(d % i == 0){\\n                factor[i]++ ;\\n                d /= i ;\\n            }\\n            if(d == 1)\\n                break ;\\n        }\\n        if(d > 1)\\n            factor[d]++ ;\\n    }\\n    \\npublic:\\n    int findValidSplit(vector<int>& nums) {\\n        int n = nums.size() ;\\n        unordered_map<int, int>factor ; // {factor, count}\\n        for(auto& n : nums)\\n            helper(factor, n) ;\\n        \\n        unordered_map<int, int>cur ;\\n        \\n        for(int i = 0; i < n-1; i++){\\n            vector<int>remove ;\\n            helper(cur, nums[i]) ;\\n            bool flag = true ;\\n            for(auto& c : cur){\\n                if(c.second < factor[c.first]){\\n                    flag = false ;\\n                    break ;\\n                }\\n                if(c.second == factor[c.first])\\n                    remove.push_back(c.first) ;\\n            }\\n            if(flag == true)\\n                return i ;\\n            \\n            for(int k = 0; k < remove.size(); k++)\\n                cur.erase(remove[k]) ;\\n                        \\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258621,
                "title": "prime-factorization-range-caching",
                "content": "# Intuition\\nPrefix product and postfix product are coprime iff they don\\'t have a common prime factor.\\n\\n# Approach\\n1. Prime-factorize every element and keep track of the indices whose elements have the given prime factor.\\n2. Go through the lists of indices. For lists with 2 or more indices, mark all the indices between the first (inclusive) and the last (exclusive) as invalid by range caching.\\n3. Expand out the range cache by `accumulate()` and the first index before `n - 1` not marked as invalid is the answer.\\n4. Otherwise, return `-1`.\\n\\n# Complexity\\n- Time complexity:\\n[$$O(\\\\frac{\\\\sqrt{m}}{\\\\log{m}} n )$$ due to the prime number theorem](https://en.wikipedia.org/wiki/Prime_number_theorem) where $$m$$ is the maximum of `nums[i]` with pre-computed primes up to $$\\\\sqrt{m}$$.\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\\n\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        prime_d = defaultdict(list)\\n        for i, x in enumerate(nums):\\n            for p in primes:\\n                if p > x:\\n                    break\\n                is_factor = False\\n                while not x % p:\\n                    x //= p\\n                    is_factor = True\\n                if is_factor:\\n                    prime_d[p].append(i)\\n            if x > 1:\\n                prime_d[x].append(i)\\n        n = len(nums)\\n        cache = [0] * n\\n        for _, l in prime_d.items():\\n            if len(l) > 1:\\n                cache[l[0]] += 1\\n                cache[l[-1]] -= 1\\n        cache.pop()\\n        for i, count in enumerate(accumulate(cache)):\\n            if not count:\\n                return i\\n        return -1            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\\n\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        prime_d = defaultdict(list)\\n        for i, x in enumerate(nums):\\n            for p in primes:\\n                if p > x:\\n                    break\\n                is_factor = False\\n                while not x % p:\\n                    x //= p\\n                    is_factor = True\\n                if is_factor:\\n                    prime_d[p].append(i)\\n            if x > 1:\\n                prime_d[x].append(i)\\n        n = len(nums)\\n        cache = [0] * n\\n        for _, l in prime_d.items():\\n            if len(l) > 1:\\n                cache[l[0]] += 1\\n                cache[l[-1]] -= 1\\n        cache.pop()\\n        for i, count in enumerate(accumulate(cache)):\\n            if not count:\\n                return i\\n        return -1            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258530,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool check(unordered_map<int, int> &pfl, unordered_map<int,int> &pfr)\\n    {\\n       for(auto it : pfl)\\n       {\\n           if(pfr.find(it.first) != pfr.end())\\n               return false;\\n       }\\n        return true;\\n    }\\n    \\n    void update(int num, unordered_map<int, int> &pfl, unordered_map<int,int> &pfr)\\n    {\\n        for(int j = 2; j * j <= num; j++)\\n        {\\n            while(num%j == 0)\\n            {\\n                num /= j;\\n                pfr[j]--;\\n                \\n                if(pfr[j] == 0)\\n                    pfr.erase(j);\\n                \\n                pfl[j]++;\\n            }\\n        }\\n        if(num > 1)\\n        {\\n            pfr[num]--;\\n                if(pfr[num] == 0)\\n                    pfr.erase(num);\\n                pfl[num]++;\\n        }\\n    }\\n    int findValidSplit(vector<int>& nums) {\\n        \\n        unordered_map<int, int> pfl, pfr;\\n        int i, j, n = nums.size(), num;\\n        \\n        if(n == 1)return -1;\\n        for(i = 1; i < n; i++)\\n        {\\n            num = nums[i];\\n            for(j = 2; j * j <= num; j++)\\n            {\\n                while(num%j == 0)\\n                {\\n                    num /= j;\\n                    pfr[j]++;\\n                }\\n            }\\n            if(num > 1)\\n                pfr[num]++;\\n        }\\n        \\n        num = nums[0];\\n        for(j = 2; j * j <= num; j++)\\n        {\\n            while(num%j == 0)\\n            {\\n                num /= j;\\n                pfl[j]++;\\n            }\\n        }\\n        if(num > 1)\\n            pfl[num]++;\\n        \\n        for(i = 0; i < n-1; i++)\\n        {\\n\\n            if(check(pfl, pfr) == true)\\n                return i;\\n            update(nums[i+1], pfl, pfr);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(unordered_map<int, int> &pfl, unordered_map<int,int> &pfr)\\n    {\\n       for(auto it : pfl)\\n       {\\n           if(pfr.find(it.first) != pfr.end())\\n               return false;\\n       }\\n        return true;\\n    }\\n    \\n    void update(int num, unordered_map<int, int> &pfl, unordered_map<int,int> &pfr)\\n    {\\n        for(int j = 2; j * j <= num; j++)\\n        {\\n            while(num%j == 0)\\n            {\\n                num /= j;\\n                pfr[j]--;\\n                \\n                if(pfr[j] == 0)\\n                    pfr.erase(j);\\n                \\n                pfl[j]++;\\n            }\\n        }\\n        if(num > 1)\\n        {\\n            pfr[num]--;\\n                if(pfr[num] == 0)\\n                    pfr.erase(num);\\n                pfl[num]++;\\n        }\\n    }\\n    int findValidSplit(vector<int>& nums) {\\n        \\n        unordered_map<int, int> pfl, pfr;\\n        int i, j, n = nums.size(), num;\\n        \\n        if(n == 1)return -1;\\n        for(i = 1; i < n; i++)\\n        {\\n            num = nums[i];\\n            for(j = 2; j * j <= num; j++)\\n            {\\n                while(num%j == 0)\\n                {\\n                    num /= j;\\n                    pfr[j]++;\\n                }\\n            }\\n            if(num > 1)\\n                pfr[num]++;\\n        }\\n        \\n        num = nums[0];\\n        for(j = 2; j * j <= num; j++)\\n        {\\n            while(num%j == 0)\\n            {\\n                num /= j;\\n                pfl[j]++;\\n            }\\n        }\\n        if(num > 1)\\n            pfl[num]++;\\n        \\n        for(i = 0; i < n-1; i++)\\n        {\\n\\n            if(check(pfl, pfr) == true)\\n                return i;\\n            update(nums[i+1], pfl, pfr);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258490,
                "title": "java-prime-factorisation-method",
                "content": "# Approach\\nUse prime factorisation technique\\n# Complexity\\n- Time complexity: O(NLogN)\\n\\n```\\nclass Solution {\\n    TreeMap<Integer, Integer> affectedPowers = new TreeMap<>();\\n\\n    public int findValidSplit(int[] nums) {\\n        TreeMap<Integer, Integer> overallPowers = new TreeMap<>();\\n\\n        for (int n : nums) {\\n            if (n > 0) {\\n                while (n % 2 == 0) {\\n                    overallPowers.put(2, overallPowers.getOrDefault(2, 0) + 1);\\n                    n /= 2;\\n                }\\n\\n                for (int i = 3; i <= Math.sqrt(n); i += 2) {\\n                    while (n % i == 0) {\\n                        overallPowers.put(i, overallPowers.getOrDefault(i, 0) + 1);\\n                        n /= i;\\n                    }\\n                }\\n                if (n > 2) {\\n                    overallPowers.put(n, overallPowers.getOrDefault(n, 0) + 1);\\n                }\\n            }\\n        }\\n\\n        for (int p = 0; p < nums.length - 1; p++) {\\n            int n = nums[p];\\n            TreeMap<Integer, Integer> tm = new TreeMap<>();\\n\\n            computePowers(n, tm);\\n\\n            // check if valid\\n            if (valid(overallPowers, tm)) return p;\\n        }\\n        return -1;\\n    }\\n\\n    private void computePowers(int n, TreeMap<Integer, Integer> tm) {\\n        if (n > 0) {\\n            while (n % 2 == 0) {\\n                tm.put(2, tm.getOrDefault(2, 0) + 1);\\n                n /= 2;\\n            }\\n\\n            for (int i = 3; i <= Math.sqrt(n); i += 2) {\\n                while (n % i == 0) {\\n                    tm.put(i, tm.getOrDefault(i, 0) + 1);\\n                    n /= i;\\n                }\\n            }\\n            if (n > 2) {\\n                tm.put(n, tm.getOrDefault(n, 0) + 1);\\n            }\\n        }\\n    }\\n\\n    private boolean valid(TreeMap<Integer, Integer> overall, TreeMap<Integer, Integer> tm) {\\n\\n        for (Map.Entry<Integer, Integer> entry : tm.entrySet()) {\\n            if (overall.containsKey(entry.getKey()) && overall.get(entry.getKey()) != entry.getValue()) {\\n                // Put default power\\n                if (!affectedPowers.containsKey(entry.getKey()))\\n                    affectedPowers.put(entry.getKey(), overall.get(entry.getKey()));\\n\\n                affectedPowers.put(entry.getKey(), affectedPowers.getOrDefault(entry.getKey(), 0) - entry.getValue());\\n                if (affectedPowers.get(entry.getKey()) <= 0) affectedPowers.remove(entry.getKey());\\n            }\\n        }\\n\\n\\n        return affectedPowers.size() == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    TreeMap<Integer, Integer> affectedPowers = new TreeMap<>();\\n\\n    public int findValidSplit(int[] nums) {\\n        TreeMap<Integer, Integer> overallPowers = new TreeMap<>();\\n\\n        for (int n : nums) {\\n            if (n > 0) {\\n                while (n % 2 == 0) {\\n                    overallPowers.put(2, overallPowers.getOrDefault(2, 0) + 1);\\n                    n /= 2;\\n                }\\n\\n                for (int i = 3; i <= Math.sqrt(n); i += 2) {\\n                    while (n % i == 0) {\\n                        overallPowers.put(i, overallPowers.getOrDefault(i, 0) + 1);\\n                        n /= i;\\n                    }\\n                }\\n                if (n > 2) {\\n                    overallPowers.put(n, overallPowers.getOrDefault(n, 0) + 1);\\n                }\\n            }\\n        }\\n\\n        for (int p = 0; p < nums.length - 1; p++) {\\n            int n = nums[p];\\n            TreeMap<Integer, Integer> tm = new TreeMap<>();\\n\\n            computePowers(n, tm);\\n\\n            // check if valid\\n            if (valid(overallPowers, tm)) return p;\\n        }\\n        return -1;\\n    }\\n\\n    private void computePowers(int n, TreeMap<Integer, Integer> tm) {\\n        if (n > 0) {\\n            while (n % 2 == 0) {\\n                tm.put(2, tm.getOrDefault(2, 0) + 1);\\n                n /= 2;\\n            }\\n\\n            for (int i = 3; i <= Math.sqrt(n); i += 2) {\\n                while (n % i == 0) {\\n                    tm.put(i, tm.getOrDefault(i, 0) + 1);\\n                    n /= i;\\n                }\\n            }\\n            if (n > 2) {\\n                tm.put(n, tm.getOrDefault(n, 0) + 1);\\n            }\\n        }\\n    }\\n\\n    private boolean valid(TreeMap<Integer, Integer> overall, TreeMap<Integer, Integer> tm) {\\n\\n        for (Map.Entry<Integer, Integer> entry : tm.entrySet()) {\\n            if (overall.containsKey(entry.getKey()) && overall.get(entry.getKey()) != entry.getValue()) {\\n                // Put default power\\n                if (!affectedPowers.containsKey(entry.getKey()))\\n                    affectedPowers.put(entry.getKey(), overall.get(entry.getKey()));\\n\\n                affectedPowers.put(entry.getKey(), affectedPowers.getOrDefault(entry.getKey(), 0) - entry.getValue());\\n                if (affectedPowers.get(entry.getKey()) <= 0) affectedPowers.remove(entry.getKey());\\n            }\\n        }\\n\\n\\n        return affectedPowers.size() == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258486,
                "title": "java-code-still-tle",
                "content": "```\\nclass Solution {\\n    \\n\\n    void prime(Map<Integer,Integer> map, int n)\\n    {\\n        int c = 2;\\n        while (n > 1) {\\n            if (n % c == 0) {\\n                map.put(c,map.getOrDefault(c,0)+1);\\n                n /= c;\\n            }\\n            else\\n                c++;\\n        }\\n    }\\n    boolean primeR(Map<Integer,Integer> map,Map<Integer,Integer> map1, int n)\\n    {\\n        int c = 2;\\n        while (n > 1) {\\n            if (n % c == 0) {\\n                map1.put(c,map1.getOrDefault(c,0)+1);\\n                n /= c;\\n            }\\n            else\\n                c++;\\n        }\\n        \\n        for(int i:map1.keySet()) {\\n            if(map1.get(i)<map.get(i))\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public int findValidSplit(int[] nums) {\\n        Map<Integer,Integer>map = new HashMap<>();\\n        Map<Integer,Integer>map1 = new HashMap<>();\\n        int n = nums.length;\\n        for(int i:nums) {\\n            prime(map,i);\\n        }\\n        \\n        //for(long i:a) System.out.print(i+\" \");\\n        long cur = 1;\\n        for(int i=0;i<n-1;i++) {\\n           if(!primeR(map,map1,nums[i])) return i;\\n        }\\n        return -1;\\n    }\\n}\\n// [557663,280817,472963,156253,273349,884803,756869,763183,557663,964357,821411,887849,891133,453379,464279,574373,852749,15031,156253,360169,526159,410203,6101,954851,860599,802573,971693,279173,134243,187367,896953,665011,277747,439441,225683,555143,496303,290317,652033,713311,230107,770047,308323,319607,772907,627217,119311,922463,119311,641131,922463,404773,728417,948281,612373,857707,990589,12739,9127,857963,53113,956003,363397,768613,47981,466027,981569,41597,87149,55021,600883,111953,119083,471871,125641,922463,562577,269069,806999,981073,857707,831587,149351,996461,432457,10903,921091,119083,72671,843289,567323,317003,802129,612373]\\n\\n//[921463,939359,331691,951997,647531,22501,921463,795941,346277,401867,388169,672193,427169,44983,897647,845567,372059,77471,694651,814213,605947,981691,938089,149257,570091,978947,845809,485417,440809,79627,621527,706283,691573,352579,790043,43051,957851,92237,647531,328277,368491,734159,525709,115663,29453,386537,192547,760117,310861,821803,951997,391487,952129,967567,32983,451553,643633,640463,459923,845027,635507,174241,61153,189407,339839,715643,725993,36493,60617,206221,34019,660521,519359,725293,483839,420941,116447,558529,251621,237089,811991,160033,219937,960151,490541,858821,441811,2129,956513,843589,48973,898243,655337,661877,402991,85487,348017,196871,888359,927677,49921,565273,938207,786701,607861,825361,90359,172279,949649,792443,511873,167917,253531,654749,688297,635879,78979,269641,898523,522679,464591,625409,858251,474037,579011,359101,132961,688531,464011,434501,124717,927323,517637,391847,172297,196277,966869,754027,869467,752581,216649,397751,807923,6163,244291,312551,827041,71789,447569,919033,792689,512503,507607,371179,203789,78691,554503,914611,854999,773473,330199,20627,191627,782443,359389,74323,399379,340387,217579,663463,172279,291899,759973,330731,669029,367853,26687,265151,207847,99823,915451,679909,932189,700919,213217,653113,557303,102241,81371,694339,46451,806513,798923,223283,219613,191749,222193,281117,931013,659741,639433,825821,824191,742949,205993,940229,694919,325747,481651,983063,274177,86171,601451,589847,467927,162739,84131,464591,707831,527789,413183,196277,952967,323801,176903,282881,795643,579011,725149,226099,150413,856411,354391,414347,770669,359389,207847]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n\\n    void prime(Map<Integer,Integer> map, int n)\\n    {\\n        int c = 2;\\n        while (n > 1) {\\n            if (n % c == 0) {\\n                map.put(c,map.getOrDefault(c,0)+1);\\n                n /= c;\\n            }\\n            else\\n                c++;\\n        }\\n    }\\n    boolean primeR(Map<Integer,Integer> map,Map<Integer,Integer> map1, int n)\\n    {\\n        int c = 2;\\n        while (n > 1) {\\n            if (n % c == 0) {\\n                map1.put(c,map1.getOrDefault(c,0)+1);\\n                n /= c;\\n            }\\n            else\\n                c++;\\n        }\\n        \\n        for(int i:map1.keySet()) {\\n            if(map1.get(i)<map.get(i))\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public int findValidSplit(int[] nums) {\\n        Map<Integer,Integer>map = new HashMap<>();\\n        Map<Integer,Integer>map1 = new HashMap<>();\\n        int n = nums.length;\\n        for(int i:nums) {\\n            prime(map,i);\\n        }\\n        \\n        //for(long i:a) System.out.print(i+\" \");\\n        long cur = 1;\\n        for(int i=0;i<n-1;i++) {\\n           if(!primeR(map,map1,nums[i])) return i;\\n        }\\n        return -1;\\n    }\\n}\\n// [557663,280817,472963,156253,273349,884803,756869,763183,557663,964357,821411,887849,891133,453379,464279,574373,852749,15031,156253,360169,526159,410203,6101,954851,860599,802573,971693,279173,134243,187367,896953,665011,277747,439441,225683,555143,496303,290317,652033,713311,230107,770047,308323,319607,772907,627217,119311,922463,119311,641131,922463,404773,728417,948281,612373,857707,990589,12739,9127,857963,53113,956003,363397,768613,47981,466027,981569,41597,87149,55021,600883,111953,119083,471871,125641,922463,562577,269069,806999,981073,857707,831587,149351,996461,432457,10903,921091,119083,72671,843289,567323,317003,802129,612373]\\n\\n//[921463,939359,331691,951997,647531,22501,921463,795941,346277,401867,388169,672193,427169,44983,897647,845567,372059,77471,694651,814213,605947,981691,938089,149257,570091,978947,845809,485417,440809,79627,621527,706283,691573,352579,790043,43051,957851,92237,647531,328277,368491,734159,525709,115663,29453,386537,192547,760117,310861,821803,951997,391487,952129,967567,32983,451553,643633,640463,459923,845027,635507,174241,61153,189407,339839,715643,725993,36493,60617,206221,34019,660521,519359,725293,483839,420941,116447,558529,251621,237089,811991,160033,219937,960151,490541,858821,441811,2129,956513,843589,48973,898243,655337,661877,402991,85487,348017,196871,888359,927677,49921,565273,938207,786701,607861,825361,90359,172279,949649,792443,511873,167917,253531,654749,688297,635879,78979,269641,898523,522679,464591,625409,858251,474037,579011,359101,132961,688531,464011,434501,124717,927323,517637,391847,172297,196277,966869,754027,869467,752581,216649,397751,807923,6163,244291,312551,827041,71789,447569,919033,792689,512503,507607,371179,203789,78691,554503,914611,854999,773473,330199,20627,191627,782443,359389,74323,399379,340387,217579,663463,172279,291899,759973,330731,669029,367853,26687,265151,207847,99823,915451,679909,932189,700919,213217,653113,557303,102241,81371,694339,46451,806513,798923,223283,219613,191749,222193,281117,931013,659741,639433,825821,824191,742949,205993,940229,694919,325747,481651,983063,274177,86171,601451,589847,467927,162739,84131,464591,707831,527789,413183,196277,952967,323801,176903,282881,795643,579011,725149,226099,150413,856411,354391,414347,770669,359389,207847]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258477,
                "title": "simple-frequency-of-primes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can just keep inside a counter or a dict the frenquency of the primes\\nand keep updating them\\nWe found our answer when there are no common prime\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*sqrt(max(nums))) with n the size of nums\\n\\n- Space complexity: O(max(nums))\\n\\n# Code\\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        def PF(n): #O(sqrt(n))\\n                while (n%2 == 0) :\\n                    yield 2\\n                    n = n/2; \\n                for i in range(3,int(sqrt(n))+1,2):\\n                    while (n%i == 0) :\\n                        yield i\\n                        n = n/i; \\n                if (n > 2) : yield n\\n                \\n        def checkCounter(): \\n            for k in b.keys() : # we know that b contains all the keys :)\\n                if a[k] and b[k] : return 0\\n            return 1\\n            \\n        b=Counter()\\n        for n in nums : #O(n)\\n            for f in PF(n): \\n                b[f]+=1\\n        a=Counter()\\n        for i in range (len(nums)-1): #O(n)\\n            # updating the counter\\n            for f in PF(nums[i]):\\n                a[f]+=1\\n                b[f]-=1\\n            if checkCounter(): return i \\n        else : return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        def PF(n): #O(sqrt(n))\\n                while (n%2 == 0) :\\n                    yield 2\\n                    n = n/2; \\n                for i in range(3,int(sqrt(n))+1,2):\\n                    while (n%i == 0) :\\n                        yield i\\n                        n = n/i; \\n                if (n > 2) : yield n\\n                \\n        def checkCounter(): \\n            for k in b.keys() : # we know that b contains all the keys :)\\n                if a[k] and b[k] : return 0\\n            return 1\\n            \\n        b=Counter()\\n        for n in nums : #O(n)\\n            for f in PF(n): \\n                b[f]+=1\\n        a=Counter()\\n        for i in range (len(nums)-1): #O(n)\\n            # updating the counter\\n            for f in PF(nums[i]):\\n                a[f]+=1\\n                b[f]-=1\\n            if checkCounter(): return i \\n        else : return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258451,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\n\\nvoid getPrimeFactors(ll n, vi(ll)&v){\\n    for (ll i = 2; i*i<=n; ++i){\\n        if(n%i){\\n            continue;\\n        }\\n        v.pb(i);\\n        while (n % i == 0){\\n            n/=i;\\n        }\\n    }\\n    if (n > 2){\\n        v.pb(n);\\n    }\\n}\\n\\nint findValidSplit(vector<int>&v) {\\n    unordered_map<ll,ll>l, r;\\n    for(ll it:v){\\n        vi(ll)pf;\\n        getPrimeFactors(it, pf);\\n        for(ll ti:pf){\\n            ++r[ti];\\n        }\\n    }\\n    for(ll i=0;i<v.size()-1;++i){\\n        vi(ll)pf;\\n        getPrimeFactors(v[i], pf);\\n        for(ll j:pf){\\n            if(--r[j]==0){\\n                l.erase(j);\\n            }\\n            else{\\n                ++l[j];\\n            }\\n        }\\n        if(l.empty()){\\n            return i;\\n        }\\n    }\\n    return -1;\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\n\\nvoid getPrimeFactors(ll n, vi(ll)&v){\\n    for (ll i = 2; i*i<=n; ++i){\\n        if(n%i){\\n            continue;\\n        }\\n        v.pb(i);\\n        while (n % i == 0){\\n            n/=i;\\n        }\\n    }\\n    if (n > 2){\\n        v.pb(n);\\n    }\\n}\\n\\nint findValidSplit(vector<int>&v) {\\n    unordered_map<ll,ll>l, r;\\n    for(ll it:v){\\n        vi(ll)pf;\\n        getPrimeFactors(it, pf);\\n        for(ll ti:pf){\\n            ++r[ti];\\n        }\\n    }\\n    for(ll i=0;i<v.size()-1;++i){\\n        vi(ll)pf;\\n        getPrimeFactors(v[i], pf);\\n        for(ll j:pf){\\n            if(--r[j]==0){\\n                l.erase(j);\\n            }\\n            else{\\n                ++l[j];\\n            }\\n        }\\n        if(l.empty()){\\n            return i;\\n        }\\n    }\\n    return -1;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258448,
                "title": "o-n-sqrt-m-python3-solution-comparing-primecounts-maps",
                "content": "# Intuition\\nCoprime pairs share no prime values. [12, 35] are coprime because 12 is composed of 2s and 3s, while 35 is composed of 5s and 7s.\\n\\n# Approach\\nStore the prime factorization of the product of `nums` in a `primeCounts` map that holds the power of each prime in the product of the full array. Then traverse `nums` once more, building `subPrimeCounts`, the power of each prime in the product of the subarray. The coprime condition is met if `subPrimeCounts` has either all or no powers of each prime.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n * Sqrt(m))$$ where m is the max size of nums (1E6).\\n\\n- Space complexity: $$O(n + Sqrt(m))$$, which loosely bounds the number of distinct primes in the product.\\n\\n# Code\\n```\\n\\n\\n# Accumulate running counts of primes.\\ndef updatePrimeCounts(primeCounts, num):\\n    while num % 2 == 0:\\n        primeCounts[2] += 1\\n        num //= 2\\n    for i in range(3, num, 2):\\n        while num % i == 0:\\n            primeCounts[i] += 1\\n            num //= i\\n        if num < i * i:\\n            if num > 1:\\n                primeCounts[num] += 1\\n            return\\n\\nclass Solution:\\n    \"\"\"\\n    Notes\\n    * n=1e4, so O(N^2) ok if fast.\\n    * nums <= 1E6, so maybe nums search.\\n    \"\"\"\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        # Build primeCounts, the number of prime factors in the product of nums.\\n        # Example: primeCounts of [6, 10] is {2: 2, 3: 1, 5: 1}.\\n        primeCounts = defaultdict(int)\\n        for num in nums:\\n            updatePrimeCounts(primeCounts, num)\\n            \\n        # Walk through nums again, building subPrimeCounts, the number of prime factors\\n        # in the subarray of nums.\\n        subPrimeCounts = defaultdict(int)\\n        n = len(nums)\\n        for i in range(n - 1):\\n            updatePrimeCounts(subPrimeCounts, nums[i])\\n            # The subarray is coprime with the others if the subarray has\\n            # either all or no powers of each prime.\\n            isGood = True\\n            for prime in subPrimeCounts:\\n                if primeCounts[prime] != subPrimeCounts[prime]:\\n                    isGood = False\\n                    break\\n            if isGood:\\n                return i\\n            \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\n\\n# Accumulate running counts of primes.\\ndef updatePrimeCounts(primeCounts, num):\\n    while num % 2 == 0:\\n        primeCounts[2] += 1\\n        num //= 2\\n    for i in range(3, num, 2):\\n        while num % i == 0:\\n            primeCounts[i] += 1\\n            num //= i\\n        if num < i * i:\\n            if num > 1:\\n                primeCounts[num] += 1\\n            return\\n\\nclass Solution:\\n    \"\"\"\\n    Notes\\n    * n=1e4, so O(N^2) ok if fast.\\n    * nums <= 1E6, so maybe nums search.\\n    \"\"\"\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        # Build primeCounts, the number of prime factors in the product of nums.\\n        # Example: primeCounts of [6, 10] is {2: 2, 3: 1, 5: 1}.\\n        primeCounts = defaultdict(int)\\n        for num in nums:\\n            updatePrimeCounts(primeCounts, num)\\n            \\n        # Walk through nums again, building subPrimeCounts, the number of prime factors\\n        # in the subarray of nums.\\n        subPrimeCounts = defaultdict(int)\\n        n = len(nums)\\n        for i in range(n - 1):\\n            updatePrimeCounts(subPrimeCounts, nums[i])\\n            # The subarray is coprime with the others if the subarray has\\n            # either all or no powers of each prime.\\n            isGood = True\\n            for prime in subPrimeCounts:\\n                if primeCounts[prime] != subPrimeCounts[prime]:\\n                    isGood = False\\n                    break\\n            if isGood:\\n                return i\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258422,
                "title": "c-o-n-simple-solution-map-set",
                "content": "Just keep track of the prime factors for each element when traversing the array, if the remaining part does not contain the prime factors we\\'ve seen so far, return the index. Otherwise keep searching.\\n```\\n    int findValidSplit(vector<int>& A) {\\n        unordered_map<int, int> cnt;\\n        for(auto e : A) {\\n            for(int d = 2, t = sqrt(e); d <= min(e, t); d++) {\\n                if(e%d == 0) cnt[d]++;\\n                while(e%d == 0) e /= d;\\n            }\\n            if(e > 1) cnt[e]++;\\n        }\\n        \\n        unordered_set<int> left;\\n        for(int i = 0; i <= (int)A.size()-2; i++) {\\n            int e = A[i];\\n            for(int d = 2, t = sqrt(e); d <= min(e, t); d++) {\\n                if(e%d == 0) {\\n                    if(--cnt[d]) left.insert(d);\\n                    else left.erase(d);\\n                }\\n                while(e%d == 0) e /= d;\\n            }\\n            if(e > 1)  {\\n                if(--cnt[e]) left.insert(e);\\n                else left.erase(e);\\n            }\\n            \\n            if(left.size() == 0) return i;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int findValidSplit(vector<int>& A) {\\n        unordered_map<int, int> cnt;\\n        for(auto e : A) {\\n            for(int d = 2, t = sqrt(e); d <= min(e, t); d++) {\\n                if(e%d == 0) cnt[d]++;\\n                while(e%d == 0) e /= d;\\n            }\\n            if(e > 1) cnt[e]++;\\n        }\\n        \\n        unordered_set<int> left;\\n        for(int i = 0; i <= (int)A.size()-2; i++) {\\n            int e = A[i];\\n            for(int d = 2, t = sqrt(e); d <= min(e, t); d++) {\\n                if(e%d == 0) {\\n                    if(--cnt[d]) left.insert(d);\\n                    else left.erase(d);\\n                }\\n                while(e%d == 0) e /= d;\\n            }\\n            if(e > 1)  {\\n                if(--cnt[e]) left.insert(e);\\n                else left.erase(e);\\n            }\\n            \\n            if(left.size() == 0) return i;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3258419,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFactorization\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFactorize nums, during the first swipe, count up how many times each prime factor appears. During the second swipe, count down how many times each prime factor appears and how many different prime factor appears. If the number of factors appears equals to factor number that reduced to zero, then we find the answer.\\n\\n# Complexity\\nWe set the range=M, then\\n- Time complexity:  O(MlogM)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prime[80000],isPrime[1000005],coprime[1000005],zero,meet,f[1000005];\\n    int findValidSplit(vector<int>& nums) {\\n        int cnt=0,n=nums.size();\\n        for (long long i=2;i<=1000000;i++){\\n            //coprime[i]=-1;\\n            if (!isPrime[i]){\\n                long long j=i*i;\\n                for (;j<=1000000;j+=i){\\n                    isPrime[j]=1;\\n                }\\n                cnt++;\\n                prime[cnt]=i;\\n            }\\n        }\\n        //cout<<cnt<<\" \"<<prime[cnt-1]<<endl;\\n        for (int i=0;i<n;i++){\\n            int p=1,temp=nums[i];\\n            if (!isPrime[temp]) coprime[temp]++;\\n            else{\\n                while (prime[p]<=temp){\\n                    while (temp%prime[p]==0){\\n                        coprime[prime[p]]++;\\n                        temp=temp/prime[p];\\n                    }\\n                    p++;\\n                }\\n            }\\n        }\\n        //for (int i=0;i<10;i++) cout<<i<<\" \"<<coprime[i]<<endl;\\n        for (int i=0;i<n-1;i++){\\n            int p=1,temp=nums[i];\\n            if (!isPrime[temp]){\\n                if (!f[temp]) meet++;\\n                f[temp]=1;\\n                coprime[temp]--;\\n                if (coprime[temp]==0) zero++;\\n                if (meet==zero) {/*cout<<meet<<\" \"<<zero<<endl;*/return i;}\\n            }\\n            else{\\n                while (prime[p]<=temp){\\n                    if (temp%prime[p]==0){\\n                        if (!f[prime[p]]) meet++;\\n                        f[prime[p]]=1;\\n                        while (temp%prime[p]==0){\\n                            coprime[prime[p]]--;\\n                            temp=temp/prime[p];\\n                        }\\n                        if (coprime[prime[p]]==0) zero++;\\n                        if (meet==zero) {/*cout<<meet<<\" \"<<zero<<endl;*/return i;}\\n                    }\\n                    p++;\\n                }\\n            }\\n            //cout<<meet<<\" \"<<zero<<endl;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prime[80000],isPrime[1000005],coprime[1000005],zero,meet,f[1000005];\\n    int findValidSplit(vector<int>& nums) {\\n        int cnt=0,n=nums.size();\\n        for (long long i=2;i<=1000000;i++){\\n            //coprime[i]=-1;\\n            if (!isPrime[i]){\\n                long long j=i*i;\\n                for (;j<=1000000;j+=i){\\n                    isPrime[j]=1;\\n                }\\n                cnt++;\\n                prime[cnt]=i;\\n            }\\n        }\\n        //cout<<cnt<<\" \"<<prime[cnt-1]<<endl;\\n        for (int i=0;i<n;i++){\\n            int p=1,temp=nums[i];\\n            if (!isPrime[temp]) coprime[temp]++;\\n            else{\\n                while (prime[p]<=temp){\\n                    while (temp%prime[p]==0){\\n                        coprime[prime[p]]++;\\n                        temp=temp/prime[p];\\n                    }\\n                    p++;\\n                }\\n            }\\n        }\\n        //for (int i=0;i<10;i++) cout<<i<<\" \"<<coprime[i]<<endl;\\n        for (int i=0;i<n-1;i++){\\n            int p=1,temp=nums[i];\\n            if (!isPrime[temp]){\\n                if (!f[temp]) meet++;\\n                f[temp]=1;\\n                coprime[temp]--;\\n                if (coprime[temp]==0) zero++;\\n                if (meet==zero) {/*cout<<meet<<\" \"<<zero<<endl;*/return i;}\\n            }\\n            else{\\n                while (prime[p]<=temp){\\n                    if (temp%prime[p]==0){\\n                        if (!f[prime[p]]) meet++;\\n                        f[prime[p]]=1;\\n                        while (temp%prime[p]==0){\\n                            coprime[prime[p]]--;\\n                            temp=temp/prime[p];\\n                        }\\n                        if (coprime[prime[p]]==0) zero++;\\n                        if (meet==zero) {/*cout<<meet<<\" \"<<zero<<endl;*/return i;}\\n                    }\\n                    p++;\\n                }\\n            }\\n            //cout<<meet<<\" \"<<zero<<endl;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3258405,
                "title": "simple-and-unique-approach-in-python",
                "content": "# Intuition\\n- Let us consider a factor ***P*** to divide both prefix and suffix product.\\n- Since P divides prefix product at the present index, **p** will divide the prefix product at all **j > i**.\\n- And for all **j > i** that **P** divides the suffix product, the gcd will be greater than or equal to **P**.\\n- So just check for when **P** does not divide the suffix product, and update P.\\n- If **p == 1** thats you answer.\\n\\n# Code\\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        def gcd(a, b):\\n            a, b = min(a, b), max(a, b)\\n            \\n            if b%a == 0:\\n                return a\\n            return(gcd(b%a, a))\\n        \\n        #suffix product\\n        pro = 1\\n        for i in nums:\\n            pro *= i\\n        \\n\\n        t = 1 # prefix product\\n        n = len(nums)\\n\\n        prev_gcd = -1 #gcd of suffix_product\\n        \\n        for i in range(n - 1):\\n            t *= nums[i]\\n            pro = pro // nums[i]\\n            \\n            if prev_gcd == -1:\\n                prev_gcd = gcd(pro, t)\\n            \\n            if pro%prev_gcd == 0:\\n                continue\\n            \\n            prev_gcd = gcd(pro, t)\\n            \\n            if prev_gcd == 1:\\n                return i\\n            \\n        return -1\\n```\\n\\n- Edit: Doesnt work after new test cases T_T..",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        def gcd(a, b):\\n            a, b = min(a, b), max(a, b)\\n            \\n            if b%a == 0:\\n                return a\\n            return(gcd(b%a, a))\\n        \\n        #suffix product\\n        pro = 1\\n        for i in nums:\\n            pro *= i\\n        \\n\\n        t = 1 # prefix product\\n        n = len(nums)\\n\\n        prev_gcd = -1 #gcd of suffix_product\\n        \\n        for i in range(n - 1):\\n            t *= nums[i]\\n            pro = pro // nums[i]\\n            \\n            if prev_gcd == -1:\\n                prev_gcd = gcd(pro, t)\\n            \\n            if pro%prev_gcd == 0:\\n                continue\\n            \\n            prev_gcd = gcd(pro, t)\\n            \\n            if prev_gcd == 1:\\n                return i\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258391,
                "title": "jump-game",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        left = {}  \\n        right = [-1] * n \\n\\n        def f(p: int, i: int) -> None:\\n            if p in left:\\n                right[left[p]] = i \\n            else:\\n                left[p] = i \\n\\n        for i, x in enumerate(nums):\\n            d = 2\\n            while d * d <= x: \\n                if x % d == 0:\\n                    f(d, i)\\n                    x //= d\\n                    while x % d == 0:\\n                        x //= d\\n                d += 1\\n            if x > 1: f(x, i)\\n\\n        max_r = right[0]\\n        for l, r in enumerate(right):\\n            if l > max_r: \\n                return max_r  \\n            max_r = max(max_r, r)\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        left = {}  \\n        right = [-1] * n \\n\\n        def f(p: int, i: int) -> None:\\n            if p in left:\\n                right[left[p]] = i \\n            else:\\n                left[p] = i \\n\\n        for i, x in enumerate(nums):\\n            d = 2\\n            while d * d <= x: \\n                if x % d == 0:\\n                    f(d, i)\\n                    x //= d\\n                    while x % d == 0:\\n                        x //= d\\n                d += 1\\n            if x > 1: f(x, i)\\n\\n        max_r = right[0]\\n        for l, r in enumerate(right):\\n            if l > max_r: \\n                return max_r  \\n            max_r = max(max_r, r)\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258384,
                "title": "unordered-map-prime-factorization-explained-briefly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved using suffix , prefix and prime factorization.\\nSince each element in the array is $$<= 1e6$$ it can have atmost 8 unique prime factors as $$2*3*5*7*11*13*17*19 $$ exceeds $1e6$.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can first use a map `b` to store frequency of each prime factor in the entire array.Now we use another map `a` and start from the $0th$ index. We store frequency of each prime factor in the prefix and reduce the freqency in the map `b`. If any frequency in map `b` becomes 0 we erase it. After each step we check if the maps are disjoint. If yes then we found our index.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n * sqrt(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\\\\\\\function to check if maps are disjoint\\n\\n    bool dis(unordered_map<int,int> & a, unordered_map<int,int>& b){\\n        for(auto it: a){\\n            if(b.count(it.first)) return false;\\n        }\\n        return true;\\n    }\\n\\n    int findValidSplit(vector<int>& nums) {\\n        unordered_map<int,int> a, b;\\n\\n        \\\\\\\\ calculate all primes in array in map b\\n\\n        for(auto x: nums){\\n            int y = x;\\n            for(int i=2;i*i<=x;i++){\\n                if(y%i==0){\\n                    b[i]++;\\n                    while(y%i==0) y/=i;\\n                }\\n            }\\n            if(y>1) b[y]++;\\n        }\\n\\n\\n        \\\\\\\\start from the beginning and fill a while decreasing frequencies in b\\n\\n        for(int i = 0;i<nums.size()-1;i++){\\n            int x , y;\\n            x=y=nums[i];\\n            for(int j=2;j*j<=x;j++){\\n                if(y%j==0){\\n                    a[j]++;\\n                    b[j]--;\\n                    if(!b[j]) b.erase(j);\\n                    while(y%j==0) y/=j;\\n                }\\n            }\\n            if(y>1){\\n                a[y]++;\\n                b[y]--;\\n                if(!b[y]) b.erase(y);\\n            }\\n\\n        \\\\\\\\ if disjoint return i\\n\\n            if(dis(a,b)) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\\\\\\\function to check if maps are disjoint\\n\\n    bool dis(unordered_map<int,int> & a, unordered_map<int,int>& b){\\n        for(auto it: a){\\n            if(b.count(it.first)) return false;\\n        }\\n        return true;\\n    }\\n\\n    int findValidSplit(vector<int>& nums) {\\n        unordered_map<int,int> a, b;\\n\\n        \\\\\\\\ calculate all primes in array in map b\\n\\n        for(auto x: nums){\\n            int y = x;\\n            for(int i=2;i*i<=x;i++){\\n                if(y%i==0){\\n                    b[i]++;\\n                    while(y%i==0) y/=i;\\n                }\\n            }\\n            if(y>1) b[y]++;\\n        }\\n\\n\\n        \\\\\\\\start from the beginning and fill a while decreasing frequencies in b\\n\\n        for(int i = 0;i<nums.size()-1;i++){\\n            int x , y;\\n            x=y=nums[i];\\n            for(int j=2;j*j<=x;j++){\\n                if(y%j==0){\\n                    a[j]++;\\n                    b[j]--;\\n                    if(!b[j]) b.erase(j);\\n                    while(y%j==0) y/=j;\\n                }\\n            }\\n            if(y>1){\\n                a[y]++;\\n                b[y]--;\\n                if(!b[y]) b.erase(y);\\n            }\\n\\n        \\\\\\\\ if disjoint return i\\n\\n            if(dis(a,b)) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258380,
                "title": "java-145ms-43mb-only-find-primes-1-less-than-1000-or-2-seen-in-the-array",
                "content": "# Intuition\\nIf $$i$$ is the answer for this question, all the primes factors seen $$0$$ thru $$i$$ will not be seen from $$i+1$$ to the end, a.k.a, the last seen index of all the prime factors $$0$$ thru $$i$$ is $$i$$. \\n\\n# Complexity\\n$$m$$ is number of prime numbers no greater than square root of maximum possible value, which is 168 for this question. $$n$$ is the length of array.\\n- Time complexity: $$O(mn)$$ \\n- Space complexity: $$O(mn)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int findValidSplit(int[] nums) {\\n        // A map of a prime factor to the last index the prime factor is seen\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int n = nums.length;\\n        // Find all primes less than 1000;\\n        LinkedList<Integer> primes = new LinkedList<>();\\n        primes.add(2);\\n        for (int i = 3; i < 998; i += 2) {\\n            boolean b = true;\\n            for (int p : primes) if (i % p == 0) {\\n                b = false;\\n                break;\\n            }\\n            if (b) primes.add(i);\\n        }\\n        // Compute the last seen index of each prime factors\\n        // Also store the prime of each elements to avoid computing it twice\\n        LinkedList<Integer>[] lists = new LinkedList[n];\\n        for (int i = 0; i < n; i++) {\\n            int num = nums[i];\\n            lists[i] = new LinkedList<>();\\n            for (int p : list) if (num % p == 0) {\\n                lists[i].add(p);\\n                map.put(p, i);\\n                while (num % p == 0) num /= p;\\n            }\\n            if (num > 1) {\\n                lists[i].add(num);\\n                map.put(num, i);\\n            }\\n        }\\n        // m is the last index of all the prime factors seen 0 thru i\\n        // when m is equal to i, all the prime factors we have seen will not show up in the remaining part, hence i should be returned\\n        for (int i = 0, m = 0; i < n - 1; i++) {\\n            for (int j : lists[i]) m = Math.max(m, map.get(j));\\n            if (i == m) return i;\\n        }\\n        return -1;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int findValidSplit(int[] nums) {\\n        // A map of a prime factor to the last index the prime factor is seen\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int n = nums.length;\\n        // Find all primes less than 1000;\\n        LinkedList<Integer> primes = new LinkedList<>();\\n        primes.add(2);\\n        for (int i = 3; i < 998; i += 2) {\\n            boolean b = true;\\n            for (int p : primes) if (i % p == 0) {\\n                b = false;\\n                break;\\n            }\\n            if (b) primes.add(i);\\n        }\\n        // Compute the last seen index of each prime factors\\n        // Also store the prime of each elements to avoid computing it twice\\n        LinkedList<Integer>[] lists = new LinkedList[n];\\n        for (int i = 0; i < n; i++) {\\n            int num = nums[i];\\n            lists[i] = new LinkedList<>();\\n            for (int p : list) if (num % p == 0) {\\n                lists[i].add(p);\\n                map.put(p, i);\\n                while (num % p == 0) num /= p;\\n            }\\n            if (num > 1) {\\n                lists[i].add(num);\\n                map.put(num, i);\\n            }\\n        }\\n        // m is the last index of all the prime factors seen 0 thru i\\n        // when m is equal to i, all the prime factors we have seen will not show up in the remaining part, hence i should be returned\\n        for (int i = 0, m = 0; i < n - 1; i++) {\\n            for (int j : lists[i]) m = Math.max(m, map.get(j));\\n            if (i == m) return i;\\n        }\\n        return -1;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1822320,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "kata kata kata sabka kata "
                    },
                    {
                        "username": "bettercoder168",
                        "content": "Contest Acceptance Rate 9.1%\nreally?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Don\\'t forget about the hidden case `n == 1`!"
                    },
                    {
                        "username": "K1ppy",
                        "content": "dont need"
                    },
                    {
                        "username": "raggzy",
                        "content": "And \"[1 ...]\" case. Seems like it was added after the contest. Because I just figured out I've lost AC :/"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Damn, this question got me crazy during the contest"
                    },
                    {
                        "username": "HansUXdev",
                        "content": "The test cases on this a really bad... I\\'ve come up with 4 solutions that \"run\" than when I submit it shows time limit exceeded and other issues."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "The test cases will almost never help you catch time limit exceeded. n can be as large as 10^4 for this question, so you need to be aware of the efficiency of your algorithm to figure out for yourself if it will TLE or not. Otherwise yes, the test cases given dont really help too much to catch edge cases, but in a question like this, there can be quite a lot of edge cases depending on how you wrote your code. "
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "why it is showing tle if we solve this problem using prefix array and suffix array concpet .\nhere is my submission and code\n https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/1050705501/"
                    },
                    {
                        "username": "K1ppy",
                        "content": "really easy task()"
                    },
                    {
                        "username": "jaspier",
                        "content": "The intuition that if gcd(a,b) == 1 means that a,b do not share prime factors is the bottleneck that makes this problem so hard. But with this information the solution is pretty easy. Problem is coming up with this insight during the interview time. If there's no help from the interviewer it will be a tough day..."
                    },
                    {
                        "username": "janis__",
                        "content": "In an interview setting, always voice your thought process and work through smaller examples to identify patterns."
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Thats basically the definition of coprime..."
                    },
                    {
                        "username": "harryB17",
                        "content": "code is getting accepted for in an n^2 approach using unordered_map , because of its random order storing method which is causing a break condition to trigger early, cause the last element is appearing early in unordered_map, but in not in normal map. \\n\\na testcase be [2,3,5,7,11,13,17,19,23....2023]\\nwhere the array consist of all prime numbers which will map size go to 1e4, now multiply first element with last element,\\n[4046, 3, 5, 7.....2023]\\nthis testcase will give TLE for anyone using ordered map, since last element comes last in ordered map, during traversal, but not in unordered_map. To make a testcase where unordered_map wont work ->\\n\\ntake an array of size 1e4 with all prime numbers, put them in unordred_map, print the unordered_map, and whatever element comes at last position, place that element at last of array with prime numbers and remove it from its old position in the array.\\nnow multiply the first element with the last element, and you have a testcase which will give TLE for many accepted solutions in contest.\\n\\nI ran some code, and found the array\\n[2,3,5,7.......104723, 104729]\\nwhich is the array of 1e4 prime numbers, printing unordered_map sequence of it, i found 76343 as last number, so resulting array will be\\n[76343*2, 3, 5, 7........104723, 104729, 76343]\\n"
                    },
                    {
                        "username": "sarthakrautelanew",
                        "content": "failing at test 38 out of 39 , geez ."
                    }
                ]
            },
            {
                "id": 1822253,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "kata kata kata sabka kata "
                    },
                    {
                        "username": "bettercoder168",
                        "content": "Contest Acceptance Rate 9.1%\nreally?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Don\\'t forget about the hidden case `n == 1`!"
                    },
                    {
                        "username": "K1ppy",
                        "content": "dont need"
                    },
                    {
                        "username": "raggzy",
                        "content": "And \"[1 ...]\" case. Seems like it was added after the contest. Because I just figured out I've lost AC :/"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Damn, this question got me crazy during the contest"
                    },
                    {
                        "username": "HansUXdev",
                        "content": "The test cases on this a really bad... I\\'ve come up with 4 solutions that \"run\" than when I submit it shows time limit exceeded and other issues."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "The test cases will almost never help you catch time limit exceeded. n can be as large as 10^4 for this question, so you need to be aware of the efficiency of your algorithm to figure out for yourself if it will TLE or not. Otherwise yes, the test cases given dont really help too much to catch edge cases, but in a question like this, there can be quite a lot of edge cases depending on how you wrote your code. "
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "why it is showing tle if we solve this problem using prefix array and suffix array concpet .\nhere is my submission and code\n https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/1050705501/"
                    },
                    {
                        "username": "K1ppy",
                        "content": "really easy task()"
                    },
                    {
                        "username": "jaspier",
                        "content": "The intuition that if gcd(a,b) == 1 means that a,b do not share prime factors is the bottleneck that makes this problem so hard. But with this information the solution is pretty easy. Problem is coming up with this insight during the interview time. If there's no help from the interviewer it will be a tough day..."
                    },
                    {
                        "username": "janis__",
                        "content": "In an interview setting, always voice your thought process and work through smaller examples to identify patterns."
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Thats basically the definition of coprime..."
                    },
                    {
                        "username": "harryB17",
                        "content": "code is getting accepted for in an n^2 approach using unordered_map , because of its random order storing method which is causing a break condition to trigger early, cause the last element is appearing early in unordered_map, but in not in normal map. \\n\\na testcase be [2,3,5,7,11,13,17,19,23....2023]\\nwhere the array consist of all prime numbers which will map size go to 1e4, now multiply first element with last element,\\n[4046, 3, 5, 7.....2023]\\nthis testcase will give TLE for anyone using ordered map, since last element comes last in ordered map, during traversal, but not in unordered_map. To make a testcase where unordered_map wont work ->\\n\\ntake an array of size 1e4 with all prime numbers, put them in unordred_map, print the unordered_map, and whatever element comes at last position, place that element at last of array with prime numbers and remove it from its old position in the array.\\nnow multiply the first element with the last element, and you have a testcase which will give TLE for many accepted solutions in contest.\\n\\nI ran some code, and found the array\\n[2,3,5,7.......104723, 104729]\\nwhich is the array of 1e4 prime numbers, printing unordered_map sequence of it, i found 76343 as last number, so resulting array will be\\n[76343*2, 3, 5, 7........104723, 104729, 76343]\\n"
                    },
                    {
                        "username": "sarthakrautelanew",
                        "content": "failing at test 38 out of 39 , geez ."
                    }
                ]
            },
            {
                "id": 1822355,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "kata kata kata sabka kata "
                    },
                    {
                        "username": "bettercoder168",
                        "content": "Contest Acceptance Rate 9.1%\nreally?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Don\\'t forget about the hidden case `n == 1`!"
                    },
                    {
                        "username": "K1ppy",
                        "content": "dont need"
                    },
                    {
                        "username": "raggzy",
                        "content": "And \"[1 ...]\" case. Seems like it was added after the contest. Because I just figured out I've lost AC :/"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Damn, this question got me crazy during the contest"
                    },
                    {
                        "username": "HansUXdev",
                        "content": "The test cases on this a really bad... I\\'ve come up with 4 solutions that \"run\" than when I submit it shows time limit exceeded and other issues."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "The test cases will almost never help you catch time limit exceeded. n can be as large as 10^4 for this question, so you need to be aware of the efficiency of your algorithm to figure out for yourself if it will TLE or not. Otherwise yes, the test cases given dont really help too much to catch edge cases, but in a question like this, there can be quite a lot of edge cases depending on how you wrote your code. "
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "why it is showing tle if we solve this problem using prefix array and suffix array concpet .\nhere is my submission and code\n https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/1050705501/"
                    },
                    {
                        "username": "K1ppy",
                        "content": "really easy task()"
                    },
                    {
                        "username": "jaspier",
                        "content": "The intuition that if gcd(a,b) == 1 means that a,b do not share prime factors is the bottleneck that makes this problem so hard. But with this information the solution is pretty easy. Problem is coming up with this insight during the interview time. If there's no help from the interviewer it will be a tough day..."
                    },
                    {
                        "username": "janis__",
                        "content": "In an interview setting, always voice your thought process and work through smaller examples to identify patterns."
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Thats basically the definition of coprime..."
                    },
                    {
                        "username": "harryB17",
                        "content": "code is getting accepted for in an n^2 approach using unordered_map , because of its random order storing method which is causing a break condition to trigger early, cause the last element is appearing early in unordered_map, but in not in normal map. \\n\\na testcase be [2,3,5,7,11,13,17,19,23....2023]\\nwhere the array consist of all prime numbers which will map size go to 1e4, now multiply first element with last element,\\n[4046, 3, 5, 7.....2023]\\nthis testcase will give TLE for anyone using ordered map, since last element comes last in ordered map, during traversal, but not in unordered_map. To make a testcase where unordered_map wont work ->\\n\\ntake an array of size 1e4 with all prime numbers, put them in unordred_map, print the unordered_map, and whatever element comes at last position, place that element at last of array with prime numbers and remove it from its old position in the array.\\nnow multiply the first element with the last element, and you have a testcase which will give TLE for many accepted solutions in contest.\\n\\nI ran some code, and found the array\\n[2,3,5,7.......104723, 104729]\\nwhich is the array of 1e4 prime numbers, printing unordered_map sequence of it, i found 76343 as last number, so resulting array will be\\n[76343*2, 3, 5, 7........104723, 104729, 76343]\\n"
                    },
                    {
                        "username": "sarthakrautelanew",
                        "content": "failing at test 38 out of 39 , geez ."
                    }
                ]
            },
            {
                "id": 1822239,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "kata kata kata sabka kata "
                    },
                    {
                        "username": "bettercoder168",
                        "content": "Contest Acceptance Rate 9.1%\nreally?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Don\\'t forget about the hidden case `n == 1`!"
                    },
                    {
                        "username": "K1ppy",
                        "content": "dont need"
                    },
                    {
                        "username": "raggzy",
                        "content": "And \"[1 ...]\" case. Seems like it was added after the contest. Because I just figured out I've lost AC :/"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Damn, this question got me crazy during the contest"
                    },
                    {
                        "username": "HansUXdev",
                        "content": "The test cases on this a really bad... I\\'ve come up with 4 solutions that \"run\" than when I submit it shows time limit exceeded and other issues."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "The test cases will almost never help you catch time limit exceeded. n can be as large as 10^4 for this question, so you need to be aware of the efficiency of your algorithm to figure out for yourself if it will TLE or not. Otherwise yes, the test cases given dont really help too much to catch edge cases, but in a question like this, there can be quite a lot of edge cases depending on how you wrote your code. "
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "why it is showing tle if we solve this problem using prefix array and suffix array concpet .\nhere is my submission and code\n https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/1050705501/"
                    },
                    {
                        "username": "K1ppy",
                        "content": "really easy task()"
                    },
                    {
                        "username": "jaspier",
                        "content": "The intuition that if gcd(a,b) == 1 means that a,b do not share prime factors is the bottleneck that makes this problem so hard. But with this information the solution is pretty easy. Problem is coming up with this insight during the interview time. If there's no help from the interviewer it will be a tough day..."
                    },
                    {
                        "username": "janis__",
                        "content": "In an interview setting, always voice your thought process and work through smaller examples to identify patterns."
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Thats basically the definition of coprime..."
                    },
                    {
                        "username": "harryB17",
                        "content": "code is getting accepted for in an n^2 approach using unordered_map , because of its random order storing method which is causing a break condition to trigger early, cause the last element is appearing early in unordered_map, but in not in normal map. \\n\\na testcase be [2,3,5,7,11,13,17,19,23....2023]\\nwhere the array consist of all prime numbers which will map size go to 1e4, now multiply first element with last element,\\n[4046, 3, 5, 7.....2023]\\nthis testcase will give TLE for anyone using ordered map, since last element comes last in ordered map, during traversal, but not in unordered_map. To make a testcase where unordered_map wont work ->\\n\\ntake an array of size 1e4 with all prime numbers, put them in unordred_map, print the unordered_map, and whatever element comes at last position, place that element at last of array with prime numbers and remove it from its old position in the array.\\nnow multiply the first element with the last element, and you have a testcase which will give TLE for many accepted solutions in contest.\\n\\nI ran some code, and found the array\\n[2,3,5,7.......104723, 104729]\\nwhich is the array of 1e4 prime numbers, printing unordered_map sequence of it, i found 76343 as last number, so resulting array will be\\n[76343*2, 3, 5, 7........104723, 104729, 76343]\\n"
                    },
                    {
                        "username": "sarthakrautelanew",
                        "content": "failing at test 38 out of 39 , geez ."
                    }
                ]
            },
            {
                "id": 1890311,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "kata kata kata sabka kata "
                    },
                    {
                        "username": "bettercoder168",
                        "content": "Contest Acceptance Rate 9.1%\nreally?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Don\\'t forget about the hidden case `n == 1`!"
                    },
                    {
                        "username": "K1ppy",
                        "content": "dont need"
                    },
                    {
                        "username": "raggzy",
                        "content": "And \"[1 ...]\" case. Seems like it was added after the contest. Because I just figured out I've lost AC :/"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Damn, this question got me crazy during the contest"
                    },
                    {
                        "username": "HansUXdev",
                        "content": "The test cases on this a really bad... I\\'ve come up with 4 solutions that \"run\" than when I submit it shows time limit exceeded and other issues."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "The test cases will almost never help you catch time limit exceeded. n can be as large as 10^4 for this question, so you need to be aware of the efficiency of your algorithm to figure out for yourself if it will TLE or not. Otherwise yes, the test cases given dont really help too much to catch edge cases, but in a question like this, there can be quite a lot of edge cases depending on how you wrote your code. "
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "why it is showing tle if we solve this problem using prefix array and suffix array concpet .\nhere is my submission and code\n https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/1050705501/"
                    },
                    {
                        "username": "K1ppy",
                        "content": "really easy task()"
                    },
                    {
                        "username": "jaspier",
                        "content": "The intuition that if gcd(a,b) == 1 means that a,b do not share prime factors is the bottleneck that makes this problem so hard. But with this information the solution is pretty easy. Problem is coming up with this insight during the interview time. If there's no help from the interviewer it will be a tough day..."
                    },
                    {
                        "username": "janis__",
                        "content": "In an interview setting, always voice your thought process and work through smaller examples to identify patterns."
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Thats basically the definition of coprime..."
                    },
                    {
                        "username": "harryB17",
                        "content": "code is getting accepted for in an n^2 approach using unordered_map , because of its random order storing method which is causing a break condition to trigger early, cause the last element is appearing early in unordered_map, but in not in normal map. \\n\\na testcase be [2,3,5,7,11,13,17,19,23....2023]\\nwhere the array consist of all prime numbers which will map size go to 1e4, now multiply first element with last element,\\n[4046, 3, 5, 7.....2023]\\nthis testcase will give TLE for anyone using ordered map, since last element comes last in ordered map, during traversal, but not in unordered_map. To make a testcase where unordered_map wont work ->\\n\\ntake an array of size 1e4 with all prime numbers, put them in unordred_map, print the unordered_map, and whatever element comes at last position, place that element at last of array with prime numbers and remove it from its old position in the array.\\nnow multiply the first element with the last element, and you have a testcase which will give TLE for many accepted solutions in contest.\\n\\nI ran some code, and found the array\\n[2,3,5,7.......104723, 104729]\\nwhich is the array of 1e4 prime numbers, printing unordered_map sequence of it, i found 76343 as last number, so resulting array will be\\n[76343*2, 3, 5, 7........104723, 104729, 76343]\\n"
                    },
                    {
                        "username": "sarthakrautelanew",
                        "content": "failing at test 38 out of 39 , geez ."
                    }
                ]
            },
            {
                "id": 2059603,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "kata kata kata sabka kata "
                    },
                    {
                        "username": "bettercoder168",
                        "content": "Contest Acceptance Rate 9.1%\nreally?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Don\\'t forget about the hidden case `n == 1`!"
                    },
                    {
                        "username": "K1ppy",
                        "content": "dont need"
                    },
                    {
                        "username": "raggzy",
                        "content": "And \"[1 ...]\" case. Seems like it was added after the contest. Because I just figured out I've lost AC :/"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Damn, this question got me crazy during the contest"
                    },
                    {
                        "username": "HansUXdev",
                        "content": "The test cases on this a really bad... I\\'ve come up with 4 solutions that \"run\" than when I submit it shows time limit exceeded and other issues."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "The test cases will almost never help you catch time limit exceeded. n can be as large as 10^4 for this question, so you need to be aware of the efficiency of your algorithm to figure out for yourself if it will TLE or not. Otherwise yes, the test cases given dont really help too much to catch edge cases, but in a question like this, there can be quite a lot of edge cases depending on how you wrote your code. "
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "why it is showing tle if we solve this problem using prefix array and suffix array concpet .\nhere is my submission and code\n https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/1050705501/"
                    },
                    {
                        "username": "K1ppy",
                        "content": "really easy task()"
                    },
                    {
                        "username": "jaspier",
                        "content": "The intuition that if gcd(a,b) == 1 means that a,b do not share prime factors is the bottleneck that makes this problem so hard. But with this information the solution is pretty easy. Problem is coming up with this insight during the interview time. If there's no help from the interviewer it will be a tough day..."
                    },
                    {
                        "username": "janis__",
                        "content": "In an interview setting, always voice your thought process and work through smaller examples to identify patterns."
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Thats basically the definition of coprime..."
                    },
                    {
                        "username": "harryB17",
                        "content": "code is getting accepted for in an n^2 approach using unordered_map , because of its random order storing method which is causing a break condition to trigger early, cause the last element is appearing early in unordered_map, but in not in normal map. \\n\\na testcase be [2,3,5,7,11,13,17,19,23....2023]\\nwhere the array consist of all prime numbers which will map size go to 1e4, now multiply first element with last element,\\n[4046, 3, 5, 7.....2023]\\nthis testcase will give TLE for anyone using ordered map, since last element comes last in ordered map, during traversal, but not in unordered_map. To make a testcase where unordered_map wont work ->\\n\\ntake an array of size 1e4 with all prime numbers, put them in unordred_map, print the unordered_map, and whatever element comes at last position, place that element at last of array with prime numbers and remove it from its old position in the array.\\nnow multiply the first element with the last element, and you have a testcase which will give TLE for many accepted solutions in contest.\\n\\nI ran some code, and found the array\\n[2,3,5,7.......104723, 104729]\\nwhich is the array of 1e4 prime numbers, printing unordered_map sequence of it, i found 76343 as last number, so resulting array will be\\n[76343*2, 3, 5, 7........104723, 104729, 76343]\\n"
                    },
                    {
                        "username": "sarthakrautelanew",
                        "content": "failing at test 38 out of 39 , geez ."
                    }
                ]
            },
            {
                "id": 1890102,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "kata kata kata sabka kata "
                    },
                    {
                        "username": "bettercoder168",
                        "content": "Contest Acceptance Rate 9.1%\nreally?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Don\\'t forget about the hidden case `n == 1`!"
                    },
                    {
                        "username": "K1ppy",
                        "content": "dont need"
                    },
                    {
                        "username": "raggzy",
                        "content": "And \"[1 ...]\" case. Seems like it was added after the contest. Because I just figured out I've lost AC :/"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Damn, this question got me crazy during the contest"
                    },
                    {
                        "username": "HansUXdev",
                        "content": "The test cases on this a really bad... I\\'ve come up with 4 solutions that \"run\" than when I submit it shows time limit exceeded and other issues."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "The test cases will almost never help you catch time limit exceeded. n can be as large as 10^4 for this question, so you need to be aware of the efficiency of your algorithm to figure out for yourself if it will TLE or not. Otherwise yes, the test cases given dont really help too much to catch edge cases, but in a question like this, there can be quite a lot of edge cases depending on how you wrote your code. "
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "why it is showing tle if we solve this problem using prefix array and suffix array concpet .\nhere is my submission and code\n https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/1050705501/"
                    },
                    {
                        "username": "K1ppy",
                        "content": "really easy task()"
                    },
                    {
                        "username": "jaspier",
                        "content": "The intuition that if gcd(a,b) == 1 means that a,b do not share prime factors is the bottleneck that makes this problem so hard. But with this information the solution is pretty easy. Problem is coming up with this insight during the interview time. If there's no help from the interviewer it will be a tough day..."
                    },
                    {
                        "username": "janis__",
                        "content": "In an interview setting, always voice your thought process and work through smaller examples to identify patterns."
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Thats basically the definition of coprime..."
                    },
                    {
                        "username": "harryB17",
                        "content": "code is getting accepted for in an n^2 approach using unordered_map , because of its random order storing method which is causing a break condition to trigger early, cause the last element is appearing early in unordered_map, but in not in normal map. \\n\\na testcase be [2,3,5,7,11,13,17,19,23....2023]\\nwhere the array consist of all prime numbers which will map size go to 1e4, now multiply first element with last element,\\n[4046, 3, 5, 7.....2023]\\nthis testcase will give TLE for anyone using ordered map, since last element comes last in ordered map, during traversal, but not in unordered_map. To make a testcase where unordered_map wont work ->\\n\\ntake an array of size 1e4 with all prime numbers, put them in unordred_map, print the unordered_map, and whatever element comes at last position, place that element at last of array with prime numbers and remove it from its old position in the array.\\nnow multiply the first element with the last element, and you have a testcase which will give TLE for many accepted solutions in contest.\\n\\nI ran some code, and found the array\\n[2,3,5,7.......104723, 104729]\\nwhich is the array of 1e4 prime numbers, printing unordered_map sequence of it, i found 76343 as last number, so resulting array will be\\n[76343*2, 3, 5, 7........104723, 104729, 76343]\\n"
                    },
                    {
                        "username": "sarthakrautelanew",
                        "content": "failing at test 38 out of 39 , geez ."
                    }
                ]
            },
            {
                "id": 1829153,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "kata kata kata sabka kata "
                    },
                    {
                        "username": "bettercoder168",
                        "content": "Contest Acceptance Rate 9.1%\nreally?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Don\\'t forget about the hidden case `n == 1`!"
                    },
                    {
                        "username": "K1ppy",
                        "content": "dont need"
                    },
                    {
                        "username": "raggzy",
                        "content": "And \"[1 ...]\" case. Seems like it was added after the contest. Because I just figured out I've lost AC :/"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Damn, this question got me crazy during the contest"
                    },
                    {
                        "username": "HansUXdev",
                        "content": "The test cases on this a really bad... I\\'ve come up with 4 solutions that \"run\" than when I submit it shows time limit exceeded and other issues."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "The test cases will almost never help you catch time limit exceeded. n can be as large as 10^4 for this question, so you need to be aware of the efficiency of your algorithm to figure out for yourself if it will TLE or not. Otherwise yes, the test cases given dont really help too much to catch edge cases, but in a question like this, there can be quite a lot of edge cases depending on how you wrote your code. "
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "why it is showing tle if we solve this problem using prefix array and suffix array concpet .\nhere is my submission and code\n https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/1050705501/"
                    },
                    {
                        "username": "K1ppy",
                        "content": "really easy task()"
                    },
                    {
                        "username": "jaspier",
                        "content": "The intuition that if gcd(a,b) == 1 means that a,b do not share prime factors is the bottleneck that makes this problem so hard. But with this information the solution is pretty easy. Problem is coming up with this insight during the interview time. If there's no help from the interviewer it will be a tough day..."
                    },
                    {
                        "username": "janis__",
                        "content": "In an interview setting, always voice your thought process and work through smaller examples to identify patterns."
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Thats basically the definition of coprime..."
                    },
                    {
                        "username": "harryB17",
                        "content": "code is getting accepted for in an n^2 approach using unordered_map , because of its random order storing method which is causing a break condition to trigger early, cause the last element is appearing early in unordered_map, but in not in normal map. \\n\\na testcase be [2,3,5,7,11,13,17,19,23....2023]\\nwhere the array consist of all prime numbers which will map size go to 1e4, now multiply first element with last element,\\n[4046, 3, 5, 7.....2023]\\nthis testcase will give TLE for anyone using ordered map, since last element comes last in ordered map, during traversal, but not in unordered_map. To make a testcase where unordered_map wont work ->\\n\\ntake an array of size 1e4 with all prime numbers, put them in unordred_map, print the unordered_map, and whatever element comes at last position, place that element at last of array with prime numbers and remove it from its old position in the array.\\nnow multiply the first element with the last element, and you have a testcase which will give TLE for many accepted solutions in contest.\\n\\nI ran some code, and found the array\\n[2,3,5,7.......104723, 104729]\\nwhich is the array of 1e4 prime numbers, printing unordered_map sequence of it, i found 76343 as last number, so resulting array will be\\n[76343*2, 3, 5, 7........104723, 104729, 76343]\\n"
                    },
                    {
                        "username": "sarthakrautelanew",
                        "content": "failing at test 38 out of 39 , geez ."
                    }
                ]
            },
            {
                "id": 1824381,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "kata kata kata sabka kata "
                    },
                    {
                        "username": "bettercoder168",
                        "content": "Contest Acceptance Rate 9.1%\nreally?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Don\\'t forget about the hidden case `n == 1`!"
                    },
                    {
                        "username": "K1ppy",
                        "content": "dont need"
                    },
                    {
                        "username": "raggzy",
                        "content": "And \"[1 ...]\" case. Seems like it was added after the contest. Because I just figured out I've lost AC :/"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Damn, this question got me crazy during the contest"
                    },
                    {
                        "username": "HansUXdev",
                        "content": "The test cases on this a really bad... I\\'ve come up with 4 solutions that \"run\" than when I submit it shows time limit exceeded and other issues."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "The test cases will almost never help you catch time limit exceeded. n can be as large as 10^4 for this question, so you need to be aware of the efficiency of your algorithm to figure out for yourself if it will TLE or not. Otherwise yes, the test cases given dont really help too much to catch edge cases, but in a question like this, there can be quite a lot of edge cases depending on how you wrote your code. "
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "why it is showing tle if we solve this problem using prefix array and suffix array concpet .\nhere is my submission and code\n https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/1050705501/"
                    },
                    {
                        "username": "K1ppy",
                        "content": "really easy task()"
                    },
                    {
                        "username": "jaspier",
                        "content": "The intuition that if gcd(a,b) == 1 means that a,b do not share prime factors is the bottleneck that makes this problem so hard. But with this information the solution is pretty easy. Problem is coming up with this insight during the interview time. If there's no help from the interviewer it will be a tough day..."
                    },
                    {
                        "username": "janis__",
                        "content": "In an interview setting, always voice your thought process and work through smaller examples to identify patterns."
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Thats basically the definition of coprime..."
                    },
                    {
                        "username": "harryB17",
                        "content": "code is getting accepted for in an n^2 approach using unordered_map , because of its random order storing method which is causing a break condition to trigger early, cause the last element is appearing early in unordered_map, but in not in normal map. \\n\\na testcase be [2,3,5,7,11,13,17,19,23....2023]\\nwhere the array consist of all prime numbers which will map size go to 1e4, now multiply first element with last element,\\n[4046, 3, 5, 7.....2023]\\nthis testcase will give TLE for anyone using ordered map, since last element comes last in ordered map, during traversal, but not in unordered_map. To make a testcase where unordered_map wont work ->\\n\\ntake an array of size 1e4 with all prime numbers, put them in unordred_map, print the unordered_map, and whatever element comes at last position, place that element at last of array with prime numbers and remove it from its old position in the array.\\nnow multiply the first element with the last element, and you have a testcase which will give TLE for many accepted solutions in contest.\\n\\nI ran some code, and found the array\\n[2,3,5,7.......104723, 104729]\\nwhich is the array of 1e4 prime numbers, printing unordered_map sequence of it, i found 76343 as last number, so resulting array will be\\n[76343*2, 3, 5, 7........104723, 104729, 76343]\\n"
                    },
                    {
                        "username": "sarthakrautelanew",
                        "content": "failing at test 38 out of 39 , geez ."
                    }
                ]
            },
            {
                "id": 1823193,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "kata kata kata sabka kata "
                    },
                    {
                        "username": "bettercoder168",
                        "content": "Contest Acceptance Rate 9.1%\nreally?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Don\\'t forget about the hidden case `n == 1`!"
                    },
                    {
                        "username": "K1ppy",
                        "content": "dont need"
                    },
                    {
                        "username": "raggzy",
                        "content": "And \"[1 ...]\" case. Seems like it was added after the contest. Because I just figured out I've lost AC :/"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Damn, this question got me crazy during the contest"
                    },
                    {
                        "username": "HansUXdev",
                        "content": "The test cases on this a really bad... I\\'ve come up with 4 solutions that \"run\" than when I submit it shows time limit exceeded and other issues."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "The test cases will almost never help you catch time limit exceeded. n can be as large as 10^4 for this question, so you need to be aware of the efficiency of your algorithm to figure out for yourself if it will TLE or not. Otherwise yes, the test cases given dont really help too much to catch edge cases, but in a question like this, there can be quite a lot of edge cases depending on how you wrote your code. "
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "why it is showing tle if we solve this problem using prefix array and suffix array concpet .\nhere is my submission and code\n https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/1050705501/"
                    },
                    {
                        "username": "K1ppy",
                        "content": "really easy task()"
                    },
                    {
                        "username": "jaspier",
                        "content": "The intuition that if gcd(a,b) == 1 means that a,b do not share prime factors is the bottleneck that makes this problem so hard. But with this information the solution is pretty easy. Problem is coming up with this insight during the interview time. If there's no help from the interviewer it will be a tough day..."
                    },
                    {
                        "username": "janis__",
                        "content": "In an interview setting, always voice your thought process and work through smaller examples to identify patterns."
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Thats basically the definition of coprime..."
                    },
                    {
                        "username": "harryB17",
                        "content": "code is getting accepted for in an n^2 approach using unordered_map , because of its random order storing method which is causing a break condition to trigger early, cause the last element is appearing early in unordered_map, but in not in normal map. \\n\\na testcase be [2,3,5,7,11,13,17,19,23....2023]\\nwhere the array consist of all prime numbers which will map size go to 1e4, now multiply first element with last element,\\n[4046, 3, 5, 7.....2023]\\nthis testcase will give TLE for anyone using ordered map, since last element comes last in ordered map, during traversal, but not in unordered_map. To make a testcase where unordered_map wont work ->\\n\\ntake an array of size 1e4 with all prime numbers, put them in unordred_map, print the unordered_map, and whatever element comes at last position, place that element at last of array with prime numbers and remove it from its old position in the array.\\nnow multiply the first element with the last element, and you have a testcase which will give TLE for many accepted solutions in contest.\\n\\nI ran some code, and found the array\\n[2,3,5,7.......104723, 104729]\\nwhich is the array of 1e4 prime numbers, printing unordered_map sequence of it, i found 76343 as last number, so resulting array will be\\n[76343*2, 3, 5, 7........104723, 104729, 76343]\\n"
                    },
                    {
                        "username": "sarthakrautelanew",
                        "content": "failing at test 38 out of 39 , geez ."
                    }
                ]
            },
            {
                "id": 1822320,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "kata kata kata sabka kata "
                    },
                    {
                        "username": "bettercoder168",
                        "content": "Contest Acceptance Rate 9.1%\nreally?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Don\\'t forget about the hidden case `n == 1`!"
                    },
                    {
                        "username": "K1ppy",
                        "content": "dont need"
                    },
                    {
                        "username": "raggzy",
                        "content": "And \"[1 ...]\" case. Seems like it was added after the contest. Because I just figured out I've lost AC :/"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Damn, this question got me crazy during the contest"
                    },
                    {
                        "username": "HansUXdev",
                        "content": "The test cases on this a really bad... I\\'ve come up with 4 solutions that \"run\" than when I submit it shows time limit exceeded and other issues."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "The test cases will almost never help you catch time limit exceeded. n can be as large as 10^4 for this question, so you need to be aware of the efficiency of your algorithm to figure out for yourself if it will TLE or not. Otherwise yes, the test cases given dont really help too much to catch edge cases, but in a question like this, there can be quite a lot of edge cases depending on how you wrote your code. "
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "why it is showing tle if we solve this problem using prefix array and suffix array concpet .\nhere is my submission and code\n https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/1050705501/"
                    },
                    {
                        "username": "K1ppy",
                        "content": "really easy task()"
                    },
                    {
                        "username": "jaspier",
                        "content": "The intuition that if gcd(a,b) == 1 means that a,b do not share prime factors is the bottleneck that makes this problem so hard. But with this information the solution is pretty easy. Problem is coming up with this insight during the interview time. If there's no help from the interviewer it will be a tough day..."
                    },
                    {
                        "username": "janis__",
                        "content": "In an interview setting, always voice your thought process and work through smaller examples to identify patterns."
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Thats basically the definition of coprime..."
                    },
                    {
                        "username": "harryB17",
                        "content": "code is getting accepted for in an n^2 approach using unordered_map , because of its random order storing method which is causing a break condition to trigger early, cause the last element is appearing early in unordered_map, but in not in normal map. \\n\\na testcase be [2,3,5,7,11,13,17,19,23....2023]\\nwhere the array consist of all prime numbers which will map size go to 1e4, now multiply first element with last element,\\n[4046, 3, 5, 7.....2023]\\nthis testcase will give TLE for anyone using ordered map, since last element comes last in ordered map, during traversal, but not in unordered_map. To make a testcase where unordered_map wont work ->\\n\\ntake an array of size 1e4 with all prime numbers, put them in unordred_map, print the unordered_map, and whatever element comes at last position, place that element at last of array with prime numbers and remove it from its old position in the array.\\nnow multiply the first element with the last element, and you have a testcase which will give TLE for many accepted solutions in contest.\\n\\nI ran some code, and found the array\\n[2,3,5,7.......104723, 104729]\\nwhich is the array of 1e4 prime numbers, printing unordered_map sequence of it, i found 76343 as last number, so resulting array will be\\n[76343*2, 3, 5, 7........104723, 104729, 76343]\\n"
                    },
                    {
                        "username": "sarthakrautelanew",
                        "content": "failing at test 38 out of 39 , geez ."
                    }
                ]
            },
            {
                "id": 1822253,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "kata kata kata sabka kata "
                    },
                    {
                        "username": "bettercoder168",
                        "content": "Contest Acceptance Rate 9.1%\nreally?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Don\\'t forget about the hidden case `n == 1`!"
                    },
                    {
                        "username": "K1ppy",
                        "content": "dont need"
                    },
                    {
                        "username": "raggzy",
                        "content": "And \"[1 ...]\" case. Seems like it was added after the contest. Because I just figured out I've lost AC :/"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Damn, this question got me crazy during the contest"
                    },
                    {
                        "username": "HansUXdev",
                        "content": "The test cases on this a really bad... I\\'ve come up with 4 solutions that \"run\" than when I submit it shows time limit exceeded and other issues."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "The test cases will almost never help you catch time limit exceeded. n can be as large as 10^4 for this question, so you need to be aware of the efficiency of your algorithm to figure out for yourself if it will TLE or not. Otherwise yes, the test cases given dont really help too much to catch edge cases, but in a question like this, there can be quite a lot of edge cases depending on how you wrote your code. "
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "why it is showing tle if we solve this problem using prefix array and suffix array concpet .\nhere is my submission and code\n https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/1050705501/"
                    },
                    {
                        "username": "K1ppy",
                        "content": "really easy task()"
                    },
                    {
                        "username": "jaspier",
                        "content": "The intuition that if gcd(a,b) == 1 means that a,b do not share prime factors is the bottleneck that makes this problem so hard. But with this information the solution is pretty easy. Problem is coming up with this insight during the interview time. If there's no help from the interviewer it will be a tough day..."
                    },
                    {
                        "username": "janis__",
                        "content": "In an interview setting, always voice your thought process and work through smaller examples to identify patterns."
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Thats basically the definition of coprime..."
                    },
                    {
                        "username": "harryB17",
                        "content": "code is getting accepted for in an n^2 approach using unordered_map , because of its random order storing method which is causing a break condition to trigger early, cause the last element is appearing early in unordered_map, but in not in normal map. \\n\\na testcase be [2,3,5,7,11,13,17,19,23....2023]\\nwhere the array consist of all prime numbers which will map size go to 1e4, now multiply first element with last element,\\n[4046, 3, 5, 7.....2023]\\nthis testcase will give TLE for anyone using ordered map, since last element comes last in ordered map, during traversal, but not in unordered_map. To make a testcase where unordered_map wont work ->\\n\\ntake an array of size 1e4 with all prime numbers, put them in unordred_map, print the unordered_map, and whatever element comes at last position, place that element at last of array with prime numbers and remove it from its old position in the array.\\nnow multiply the first element with the last element, and you have a testcase which will give TLE for many accepted solutions in contest.\\n\\nI ran some code, and found the array\\n[2,3,5,7.......104723, 104729]\\nwhich is the array of 1e4 prime numbers, printing unordered_map sequence of it, i found 76343 as last number, so resulting array will be\\n[76343*2, 3, 5, 7........104723, 104729, 76343]\\n"
                    },
                    {
                        "username": "sarthakrautelanew",
                        "content": "failing at test 38 out of 39 , geez ."
                    }
                ]
            },
            {
                "id": 1822355,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "kata kata kata sabka kata "
                    },
                    {
                        "username": "bettercoder168",
                        "content": "Contest Acceptance Rate 9.1%\nreally?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Don\\'t forget about the hidden case `n == 1`!"
                    },
                    {
                        "username": "K1ppy",
                        "content": "dont need"
                    },
                    {
                        "username": "raggzy",
                        "content": "And \"[1 ...]\" case. Seems like it was added after the contest. Because I just figured out I've lost AC :/"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Damn, this question got me crazy during the contest"
                    },
                    {
                        "username": "HansUXdev",
                        "content": "The test cases on this a really bad... I\\'ve come up with 4 solutions that \"run\" than when I submit it shows time limit exceeded and other issues."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "The test cases will almost never help you catch time limit exceeded. n can be as large as 10^4 for this question, so you need to be aware of the efficiency of your algorithm to figure out for yourself if it will TLE or not. Otherwise yes, the test cases given dont really help too much to catch edge cases, but in a question like this, there can be quite a lot of edge cases depending on how you wrote your code. "
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "why it is showing tle if we solve this problem using prefix array and suffix array concpet .\nhere is my submission and code\n https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/1050705501/"
                    },
                    {
                        "username": "K1ppy",
                        "content": "really easy task()"
                    },
                    {
                        "username": "jaspier",
                        "content": "The intuition that if gcd(a,b) == 1 means that a,b do not share prime factors is the bottleneck that makes this problem so hard. But with this information the solution is pretty easy. Problem is coming up with this insight during the interview time. If there's no help from the interviewer it will be a tough day..."
                    },
                    {
                        "username": "janis__",
                        "content": "In an interview setting, always voice your thought process and work through smaller examples to identify patterns."
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Thats basically the definition of coprime..."
                    },
                    {
                        "username": "harryB17",
                        "content": "code is getting accepted for in an n^2 approach using unordered_map , because of its random order storing method which is causing a break condition to trigger early, cause the last element is appearing early in unordered_map, but in not in normal map. \\n\\na testcase be [2,3,5,7,11,13,17,19,23....2023]\\nwhere the array consist of all prime numbers which will map size go to 1e4, now multiply first element with last element,\\n[4046, 3, 5, 7.....2023]\\nthis testcase will give TLE for anyone using ordered map, since last element comes last in ordered map, during traversal, but not in unordered_map. To make a testcase where unordered_map wont work ->\\n\\ntake an array of size 1e4 with all prime numbers, put them in unordred_map, print the unordered_map, and whatever element comes at last position, place that element at last of array with prime numbers and remove it from its old position in the array.\\nnow multiply the first element with the last element, and you have a testcase which will give TLE for many accepted solutions in contest.\\n\\nI ran some code, and found the array\\n[2,3,5,7.......104723, 104729]\\nwhich is the array of 1e4 prime numbers, printing unordered_map sequence of it, i found 76343 as last number, so resulting array will be\\n[76343*2, 3, 5, 7........104723, 104729, 76343]\\n"
                    },
                    {
                        "username": "sarthakrautelanew",
                        "content": "failing at test 38 out of 39 , geez ."
                    }
                ]
            },
            {
                "id": 1822239,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "kata kata kata sabka kata "
                    },
                    {
                        "username": "bettercoder168",
                        "content": "Contest Acceptance Rate 9.1%\nreally?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Don\\'t forget about the hidden case `n == 1`!"
                    },
                    {
                        "username": "K1ppy",
                        "content": "dont need"
                    },
                    {
                        "username": "raggzy",
                        "content": "And \"[1 ...]\" case. Seems like it was added after the contest. Because I just figured out I've lost AC :/"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Damn, this question got me crazy during the contest"
                    },
                    {
                        "username": "HansUXdev",
                        "content": "The test cases on this a really bad... I\\'ve come up with 4 solutions that \"run\" than when I submit it shows time limit exceeded and other issues."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "The test cases will almost never help you catch time limit exceeded. n can be as large as 10^4 for this question, so you need to be aware of the efficiency of your algorithm to figure out for yourself if it will TLE or not. Otherwise yes, the test cases given dont really help too much to catch edge cases, but in a question like this, there can be quite a lot of edge cases depending on how you wrote your code. "
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "why it is showing tle if we solve this problem using prefix array and suffix array concpet .\nhere is my submission and code\n https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/1050705501/"
                    },
                    {
                        "username": "K1ppy",
                        "content": "really easy task()"
                    },
                    {
                        "username": "jaspier",
                        "content": "The intuition that if gcd(a,b) == 1 means that a,b do not share prime factors is the bottleneck that makes this problem so hard. But with this information the solution is pretty easy. Problem is coming up with this insight during the interview time. If there's no help from the interviewer it will be a tough day..."
                    },
                    {
                        "username": "janis__",
                        "content": "In an interview setting, always voice your thought process and work through smaller examples to identify patterns."
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Thats basically the definition of coprime..."
                    },
                    {
                        "username": "harryB17",
                        "content": "code is getting accepted for in an n^2 approach using unordered_map , because of its random order storing method which is causing a break condition to trigger early, cause the last element is appearing early in unordered_map, but in not in normal map. \\n\\na testcase be [2,3,5,7,11,13,17,19,23....2023]\\nwhere the array consist of all prime numbers which will map size go to 1e4, now multiply first element with last element,\\n[4046, 3, 5, 7.....2023]\\nthis testcase will give TLE for anyone using ordered map, since last element comes last in ordered map, during traversal, but not in unordered_map. To make a testcase where unordered_map wont work ->\\n\\ntake an array of size 1e4 with all prime numbers, put them in unordred_map, print the unordered_map, and whatever element comes at last position, place that element at last of array with prime numbers and remove it from its old position in the array.\\nnow multiply the first element with the last element, and you have a testcase which will give TLE for many accepted solutions in contest.\\n\\nI ran some code, and found the array\\n[2,3,5,7.......104723, 104729]\\nwhich is the array of 1e4 prime numbers, printing unordered_map sequence of it, i found 76343 as last number, so resulting array will be\\n[76343*2, 3, 5, 7........104723, 104729, 76343]\\n"
                    },
                    {
                        "username": "sarthakrautelanew",
                        "content": "failing at test 38 out of 39 , geez ."
                    }
                ]
            },
            {
                "id": 1890311,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "kata kata kata sabka kata "
                    },
                    {
                        "username": "bettercoder168",
                        "content": "Contest Acceptance Rate 9.1%\nreally?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Don\\'t forget about the hidden case `n == 1`!"
                    },
                    {
                        "username": "K1ppy",
                        "content": "dont need"
                    },
                    {
                        "username": "raggzy",
                        "content": "And \"[1 ...]\" case. Seems like it was added after the contest. Because I just figured out I've lost AC :/"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Damn, this question got me crazy during the contest"
                    },
                    {
                        "username": "HansUXdev",
                        "content": "The test cases on this a really bad... I\\'ve come up with 4 solutions that \"run\" than when I submit it shows time limit exceeded and other issues."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "The test cases will almost never help you catch time limit exceeded. n can be as large as 10^4 for this question, so you need to be aware of the efficiency of your algorithm to figure out for yourself if it will TLE or not. Otherwise yes, the test cases given dont really help too much to catch edge cases, but in a question like this, there can be quite a lot of edge cases depending on how you wrote your code. "
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "why it is showing tle if we solve this problem using prefix array and suffix array concpet .\nhere is my submission and code\n https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/1050705501/"
                    },
                    {
                        "username": "K1ppy",
                        "content": "really easy task()"
                    },
                    {
                        "username": "jaspier",
                        "content": "The intuition that if gcd(a,b) == 1 means that a,b do not share prime factors is the bottleneck that makes this problem so hard. But with this information the solution is pretty easy. Problem is coming up with this insight during the interview time. If there's no help from the interviewer it will be a tough day..."
                    },
                    {
                        "username": "janis__",
                        "content": "In an interview setting, always voice your thought process and work through smaller examples to identify patterns."
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Thats basically the definition of coprime..."
                    },
                    {
                        "username": "harryB17",
                        "content": "code is getting accepted for in an n^2 approach using unordered_map , because of its random order storing method which is causing a break condition to trigger early, cause the last element is appearing early in unordered_map, but in not in normal map. \\n\\na testcase be [2,3,5,7,11,13,17,19,23....2023]\\nwhere the array consist of all prime numbers which will map size go to 1e4, now multiply first element with last element,\\n[4046, 3, 5, 7.....2023]\\nthis testcase will give TLE for anyone using ordered map, since last element comes last in ordered map, during traversal, but not in unordered_map. To make a testcase where unordered_map wont work ->\\n\\ntake an array of size 1e4 with all prime numbers, put them in unordred_map, print the unordered_map, and whatever element comes at last position, place that element at last of array with prime numbers and remove it from its old position in the array.\\nnow multiply the first element with the last element, and you have a testcase which will give TLE for many accepted solutions in contest.\\n\\nI ran some code, and found the array\\n[2,3,5,7.......104723, 104729]\\nwhich is the array of 1e4 prime numbers, printing unordered_map sequence of it, i found 76343 as last number, so resulting array will be\\n[76343*2, 3, 5, 7........104723, 104729, 76343]\\n"
                    },
                    {
                        "username": "sarthakrautelanew",
                        "content": "failing at test 38 out of 39 , geez ."
                    }
                ]
            },
            {
                "id": 2059603,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "kata kata kata sabka kata "
                    },
                    {
                        "username": "bettercoder168",
                        "content": "Contest Acceptance Rate 9.1%\nreally?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Don\\'t forget about the hidden case `n == 1`!"
                    },
                    {
                        "username": "K1ppy",
                        "content": "dont need"
                    },
                    {
                        "username": "raggzy",
                        "content": "And \"[1 ...]\" case. Seems like it was added after the contest. Because I just figured out I've lost AC :/"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Damn, this question got me crazy during the contest"
                    },
                    {
                        "username": "HansUXdev",
                        "content": "The test cases on this a really bad... I\\'ve come up with 4 solutions that \"run\" than when I submit it shows time limit exceeded and other issues."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "The test cases will almost never help you catch time limit exceeded. n can be as large as 10^4 for this question, so you need to be aware of the efficiency of your algorithm to figure out for yourself if it will TLE or not. Otherwise yes, the test cases given dont really help too much to catch edge cases, but in a question like this, there can be quite a lot of edge cases depending on how you wrote your code. "
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "why it is showing tle if we solve this problem using prefix array and suffix array concpet .\nhere is my submission and code\n https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/1050705501/"
                    },
                    {
                        "username": "K1ppy",
                        "content": "really easy task()"
                    },
                    {
                        "username": "jaspier",
                        "content": "The intuition that if gcd(a,b) == 1 means that a,b do not share prime factors is the bottleneck that makes this problem so hard. But with this information the solution is pretty easy. Problem is coming up with this insight during the interview time. If there's no help from the interviewer it will be a tough day..."
                    },
                    {
                        "username": "janis__",
                        "content": "In an interview setting, always voice your thought process and work through smaller examples to identify patterns."
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Thats basically the definition of coprime..."
                    },
                    {
                        "username": "harryB17",
                        "content": "code is getting accepted for in an n^2 approach using unordered_map , because of its random order storing method which is causing a break condition to trigger early, cause the last element is appearing early in unordered_map, but in not in normal map. \\n\\na testcase be [2,3,5,7,11,13,17,19,23....2023]\\nwhere the array consist of all prime numbers which will map size go to 1e4, now multiply first element with last element,\\n[4046, 3, 5, 7.....2023]\\nthis testcase will give TLE for anyone using ordered map, since last element comes last in ordered map, during traversal, but not in unordered_map. To make a testcase where unordered_map wont work ->\\n\\ntake an array of size 1e4 with all prime numbers, put them in unordred_map, print the unordered_map, and whatever element comes at last position, place that element at last of array with prime numbers and remove it from its old position in the array.\\nnow multiply the first element with the last element, and you have a testcase which will give TLE for many accepted solutions in contest.\\n\\nI ran some code, and found the array\\n[2,3,5,7.......104723, 104729]\\nwhich is the array of 1e4 prime numbers, printing unordered_map sequence of it, i found 76343 as last number, so resulting array will be\\n[76343*2, 3, 5, 7........104723, 104729, 76343]\\n"
                    },
                    {
                        "username": "sarthakrautelanew",
                        "content": "failing at test 38 out of 39 , geez ."
                    }
                ]
            },
            {
                "id": 1890102,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "kata kata kata sabka kata "
                    },
                    {
                        "username": "bettercoder168",
                        "content": "Contest Acceptance Rate 9.1%\nreally?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Don\\'t forget about the hidden case `n == 1`!"
                    },
                    {
                        "username": "K1ppy",
                        "content": "dont need"
                    },
                    {
                        "username": "raggzy",
                        "content": "And \"[1 ...]\" case. Seems like it was added after the contest. Because I just figured out I've lost AC :/"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Damn, this question got me crazy during the contest"
                    },
                    {
                        "username": "HansUXdev",
                        "content": "The test cases on this a really bad... I\\'ve come up with 4 solutions that \"run\" than when I submit it shows time limit exceeded and other issues."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "The test cases will almost never help you catch time limit exceeded. n can be as large as 10^4 for this question, so you need to be aware of the efficiency of your algorithm to figure out for yourself if it will TLE or not. Otherwise yes, the test cases given dont really help too much to catch edge cases, but in a question like this, there can be quite a lot of edge cases depending on how you wrote your code. "
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "why it is showing tle if we solve this problem using prefix array and suffix array concpet .\nhere is my submission and code\n https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/1050705501/"
                    },
                    {
                        "username": "K1ppy",
                        "content": "really easy task()"
                    },
                    {
                        "username": "jaspier",
                        "content": "The intuition that if gcd(a,b) == 1 means that a,b do not share prime factors is the bottleneck that makes this problem so hard. But with this information the solution is pretty easy. Problem is coming up with this insight during the interview time. If there's no help from the interviewer it will be a tough day..."
                    },
                    {
                        "username": "janis__",
                        "content": "In an interview setting, always voice your thought process and work through smaller examples to identify patterns."
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Thats basically the definition of coprime..."
                    },
                    {
                        "username": "harryB17",
                        "content": "code is getting accepted for in an n^2 approach using unordered_map , because of its random order storing method which is causing a break condition to trigger early, cause the last element is appearing early in unordered_map, but in not in normal map. \\n\\na testcase be [2,3,5,7,11,13,17,19,23....2023]\\nwhere the array consist of all prime numbers which will map size go to 1e4, now multiply first element with last element,\\n[4046, 3, 5, 7.....2023]\\nthis testcase will give TLE for anyone using ordered map, since last element comes last in ordered map, during traversal, but not in unordered_map. To make a testcase where unordered_map wont work ->\\n\\ntake an array of size 1e4 with all prime numbers, put them in unordred_map, print the unordered_map, and whatever element comes at last position, place that element at last of array with prime numbers and remove it from its old position in the array.\\nnow multiply the first element with the last element, and you have a testcase which will give TLE for many accepted solutions in contest.\\n\\nI ran some code, and found the array\\n[2,3,5,7.......104723, 104729]\\nwhich is the array of 1e4 prime numbers, printing unordered_map sequence of it, i found 76343 as last number, so resulting array will be\\n[76343*2, 3, 5, 7........104723, 104729, 76343]\\n"
                    },
                    {
                        "username": "sarthakrautelanew",
                        "content": "failing at test 38 out of 39 , geez ."
                    }
                ]
            },
            {
                "id": 1829153,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "kata kata kata sabka kata "
                    },
                    {
                        "username": "bettercoder168",
                        "content": "Contest Acceptance Rate 9.1%\nreally?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Don\\'t forget about the hidden case `n == 1`!"
                    },
                    {
                        "username": "K1ppy",
                        "content": "dont need"
                    },
                    {
                        "username": "raggzy",
                        "content": "And \"[1 ...]\" case. Seems like it was added after the contest. Because I just figured out I've lost AC :/"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Damn, this question got me crazy during the contest"
                    },
                    {
                        "username": "HansUXdev",
                        "content": "The test cases on this a really bad... I\\'ve come up with 4 solutions that \"run\" than when I submit it shows time limit exceeded and other issues."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "The test cases will almost never help you catch time limit exceeded. n can be as large as 10^4 for this question, so you need to be aware of the efficiency of your algorithm to figure out for yourself if it will TLE or not. Otherwise yes, the test cases given dont really help too much to catch edge cases, but in a question like this, there can be quite a lot of edge cases depending on how you wrote your code. "
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "why it is showing tle if we solve this problem using prefix array and suffix array concpet .\nhere is my submission and code\n https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/1050705501/"
                    },
                    {
                        "username": "K1ppy",
                        "content": "really easy task()"
                    },
                    {
                        "username": "jaspier",
                        "content": "The intuition that if gcd(a,b) == 1 means that a,b do not share prime factors is the bottleneck that makes this problem so hard. But with this information the solution is pretty easy. Problem is coming up with this insight during the interview time. If there's no help from the interviewer it will be a tough day..."
                    },
                    {
                        "username": "janis__",
                        "content": "In an interview setting, always voice your thought process and work through smaller examples to identify patterns."
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Thats basically the definition of coprime..."
                    },
                    {
                        "username": "harryB17",
                        "content": "code is getting accepted for in an n^2 approach using unordered_map , because of its random order storing method which is causing a break condition to trigger early, cause the last element is appearing early in unordered_map, but in not in normal map. \\n\\na testcase be [2,3,5,7,11,13,17,19,23....2023]\\nwhere the array consist of all prime numbers which will map size go to 1e4, now multiply first element with last element,\\n[4046, 3, 5, 7.....2023]\\nthis testcase will give TLE for anyone using ordered map, since last element comes last in ordered map, during traversal, but not in unordered_map. To make a testcase where unordered_map wont work ->\\n\\ntake an array of size 1e4 with all prime numbers, put them in unordred_map, print the unordered_map, and whatever element comes at last position, place that element at last of array with prime numbers and remove it from its old position in the array.\\nnow multiply the first element with the last element, and you have a testcase which will give TLE for many accepted solutions in contest.\\n\\nI ran some code, and found the array\\n[2,3,5,7.......104723, 104729]\\nwhich is the array of 1e4 prime numbers, printing unordered_map sequence of it, i found 76343 as last number, so resulting array will be\\n[76343*2, 3, 5, 7........104723, 104729, 76343]\\n"
                    },
                    {
                        "username": "sarthakrautelanew",
                        "content": "failing at test 38 out of 39 , geez ."
                    }
                ]
            },
            {
                "id": 1824381,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "kata kata kata sabka kata "
                    },
                    {
                        "username": "bettercoder168",
                        "content": "Contest Acceptance Rate 9.1%\nreally?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Don\\'t forget about the hidden case `n == 1`!"
                    },
                    {
                        "username": "K1ppy",
                        "content": "dont need"
                    },
                    {
                        "username": "raggzy",
                        "content": "And \"[1 ...]\" case. Seems like it was added after the contest. Because I just figured out I've lost AC :/"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Damn, this question got me crazy during the contest"
                    },
                    {
                        "username": "HansUXdev",
                        "content": "The test cases on this a really bad... I\\'ve come up with 4 solutions that \"run\" than when I submit it shows time limit exceeded and other issues."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "The test cases will almost never help you catch time limit exceeded. n can be as large as 10^4 for this question, so you need to be aware of the efficiency of your algorithm to figure out for yourself if it will TLE or not. Otherwise yes, the test cases given dont really help too much to catch edge cases, but in a question like this, there can be quite a lot of edge cases depending on how you wrote your code. "
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "why it is showing tle if we solve this problem using prefix array and suffix array concpet .\nhere is my submission and code\n https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/1050705501/"
                    },
                    {
                        "username": "K1ppy",
                        "content": "really easy task()"
                    },
                    {
                        "username": "jaspier",
                        "content": "The intuition that if gcd(a,b) == 1 means that a,b do not share prime factors is the bottleneck that makes this problem so hard. But with this information the solution is pretty easy. Problem is coming up with this insight during the interview time. If there's no help from the interviewer it will be a tough day..."
                    },
                    {
                        "username": "janis__",
                        "content": "In an interview setting, always voice your thought process and work through smaller examples to identify patterns."
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Thats basically the definition of coprime..."
                    },
                    {
                        "username": "harryB17",
                        "content": "code is getting accepted for in an n^2 approach using unordered_map , because of its random order storing method which is causing a break condition to trigger early, cause the last element is appearing early in unordered_map, but in not in normal map. \\n\\na testcase be [2,3,5,7,11,13,17,19,23....2023]\\nwhere the array consist of all prime numbers which will map size go to 1e4, now multiply first element with last element,\\n[4046, 3, 5, 7.....2023]\\nthis testcase will give TLE for anyone using ordered map, since last element comes last in ordered map, during traversal, but not in unordered_map. To make a testcase where unordered_map wont work ->\\n\\ntake an array of size 1e4 with all prime numbers, put them in unordred_map, print the unordered_map, and whatever element comes at last position, place that element at last of array with prime numbers and remove it from its old position in the array.\\nnow multiply the first element with the last element, and you have a testcase which will give TLE for many accepted solutions in contest.\\n\\nI ran some code, and found the array\\n[2,3,5,7.......104723, 104729]\\nwhich is the array of 1e4 prime numbers, printing unordered_map sequence of it, i found 76343 as last number, so resulting array will be\\n[76343*2, 3, 5, 7........104723, 104729, 76343]\\n"
                    },
                    {
                        "username": "sarthakrautelanew",
                        "content": "failing at test 38 out of 39 , geez ."
                    }
                ]
            },
            {
                "id": 1823193,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "kata kata kata sabka kata "
                    },
                    {
                        "username": "bettercoder168",
                        "content": "Contest Acceptance Rate 9.1%\nreally?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Don\\'t forget about the hidden case `n == 1`!"
                    },
                    {
                        "username": "K1ppy",
                        "content": "dont need"
                    },
                    {
                        "username": "raggzy",
                        "content": "And \"[1 ...]\" case. Seems like it was added after the contest. Because I just figured out I've lost AC :/"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Damn, this question got me crazy during the contest"
                    },
                    {
                        "username": "HansUXdev",
                        "content": "The test cases on this a really bad... I\\'ve come up with 4 solutions that \"run\" than when I submit it shows time limit exceeded and other issues."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "The test cases will almost never help you catch time limit exceeded. n can be as large as 10^4 for this question, so you need to be aware of the efficiency of your algorithm to figure out for yourself if it will TLE or not. Otherwise yes, the test cases given dont really help too much to catch edge cases, but in a question like this, there can be quite a lot of edge cases depending on how you wrote your code. "
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "why it is showing tle if we solve this problem using prefix array and suffix array concpet .\nhere is my submission and code\n https://leetcode.com/problems/split-the-array-to-make-coprime-products/submissions/1050705501/"
                    },
                    {
                        "username": "K1ppy",
                        "content": "really easy task()"
                    },
                    {
                        "username": "jaspier",
                        "content": "The intuition that if gcd(a,b) == 1 means that a,b do not share prime factors is the bottleneck that makes this problem so hard. But with this information the solution is pretty easy. Problem is coming up with this insight during the interview time. If there's no help from the interviewer it will be a tough day..."
                    },
                    {
                        "username": "janis__",
                        "content": "In an interview setting, always voice your thought process and work through smaller examples to identify patterns."
                    },
                    {
                        "username": "c-m-d-",
                        "content": "Thats basically the definition of coprime..."
                    },
                    {
                        "username": "harryB17",
                        "content": "code is getting accepted for in an n^2 approach using unordered_map , because of its random order storing method which is causing a break condition to trigger early, cause the last element is appearing early in unordered_map, but in not in normal map. \\n\\na testcase be [2,3,5,7,11,13,17,19,23....2023]\\nwhere the array consist of all prime numbers which will map size go to 1e4, now multiply first element with last element,\\n[4046, 3, 5, 7.....2023]\\nthis testcase will give TLE for anyone using ordered map, since last element comes last in ordered map, during traversal, but not in unordered_map. To make a testcase where unordered_map wont work ->\\n\\ntake an array of size 1e4 with all prime numbers, put them in unordred_map, print the unordered_map, and whatever element comes at last position, place that element at last of array with prime numbers and remove it from its old position in the array.\\nnow multiply the first element with the last element, and you have a testcase which will give TLE for many accepted solutions in contest.\\n\\nI ran some code, and found the array\\n[2,3,5,7.......104723, 104729]\\nwhich is the array of 1e4 prime numbers, printing unordered_map sequence of it, i found 76343 as last number, so resulting array will be\\n[76343*2, 3, 5, 7........104723, 104729, 76343]\\n"
                    },
                    {
                        "username": "sarthakrautelanew",
                        "content": "failing at test 38 out of 39 , geez ."
                    }
                ]
            }
        ]
    }
]